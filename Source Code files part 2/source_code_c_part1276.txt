ServerRole;
    }

    if (!NT_SUCCESS(Status)) {

        return(Status);
    }

    //
    // Get the primary domain info.
    //

    SampGetPrimaryDomainInfo(PrimaryDomainInfo);


    //
    // Open a handle to the parent of the SAM registry location.
    // This parent must already exist.
    //

    RtlInitUnicodeString( &SamParentNameU, SamParentKeyName );

    InitializeObjectAttributes(
        &SamParentAttributes,
        &SamParentNameU,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );
    Status = RtlpNtCreateKey(
                 &SamParentKey,
                 (KEY_READ | KEY_CREATE_SUB_KEY),
                 &SamParentAttributes,
                 0,
                 NULL,
                 &Disposition
                 );

    if ( !NT_SUCCESS(Status) ) {
#if DBG
        BldPrint( "\n" );
        BldPrint( "\n" );
        BldPrint( "  We seem to be having trouble opening the registry\n" );
        BldPrint( "  database key in which the Security Account Manager\n" );
        BldPrint( "  information resides.  This registry key should have been\n" );
        BldPrint( "  created at system startup time.  Please see one of the\n" );
        BldPrint( "  security group developers for assistance in analyzing the\n" );
        BldPrint( "  the problem.\n" );
        BldPrint( "  Indicate that the registry key creation status is 0x%lx \n", Status);
        BldPrint( "\n" );
        BldPrint( "\n" );
#endif

        return(Status);
    }

    //
    // Set up some values, names, and buffers for later use
    //


    NullUnicodeString.Buffer        = NULL;
    NullUnicodeString.Length        = 0;
    NullUnicodeString.MaximumLength = 0;



    TemporaryNamePrefixU.Buffer        = RtlAllocateHeap(RtlProcessHeap(), 0, 256);
    TemporaryNamePrefixU.Length        = 0;
    TemporaryNamePrefixU.MaximumLength = 256;

    KeyNameU.Buffer               = RtlAllocateHeap(RtlProcessHeap(), 0, 256);
    KeyNameU.Length               = 0;
    KeyNameU.MaximumLength        = 256;

    //
    // Set up Security Descriptors needed for initialization...
    //

    CompletionStatus = InitializeSecurityDescriptors();

    if (CompletionStatus) {
        Status = STATUS_SUCCESS;
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }

    return(Status);
}


BOOLEAN
InitializeSecurityDescriptors(
    VOID
    )

/*++

Routine Description:

    This routine initializes security descriptors needed to create
    a SAM database.

    This routine expects all SIDs to be previously initialized.

Arguments:

    None.

Return Value:

    TRUE - Indicates initialization was successful.

    FALSE - Indicates initialization was not successful.


    The security descriptors are pointed to by global variables.

--*/

{
    PSID AceSid[10];          // Don't expect more than 10 ACEs in any of these.
    ACCESS_MASK AceMask[10];  // Access masks corresponding to Sids

    ACCESS_MASK NotForThisProductType; // Used to mask product-specific access restrictions

    GENERIC_MAPPING  SamServerMap =  {SAM_SERVER_READ,
                                      SAM_SERVER_WRITE,
                                      SAM_SERVER_EXECUTE,
                                      SAM_SERVER_ALL_ACCESS
                                      };

    GENERIC_MAPPING  DomainMap    =  {DOMAIN_READ,
                                      DOMAIN_WRITE,
                                      DOMAIN_EXECUTE,
                                      DOMAIN_ALL_ACCESS
                                      };

    GENERIC_MAPPING  AliasMap     =  {ALIAS_READ,
                                      ALIAS_WRITE,
                                      ALIAS_EXECUTE,
                                      ALIAS_ALL_ACCESS
                                      };

    GENERIC_MAPPING  GroupMap     =  {GROUP_READ,
                                      GROUP_WRITE,
                                      GROUP_EXECUTE,
                                      GROUP_ALL_ACCESS
                                      };

    GENERIC_MAPPING  UserMap      =  {USER_READ,
                                      USER_WRITE,
                                      USER_EXECUTE,
                                      USER_ALL_ACCESS
                                      };

    SAMTRACE("InitializeSecurityDescriptors");

    //
    // We need a number of different security descriptors:
    //

    //
    //
    //   The following security is assigned to
    //
    //             - Builtin DOMAIN objects
    //
    //
    //      Owner: Administrators Alias
    //      Group: Administrators Alias
    //
    //      Dacl:   Grant               Grant
    //              WORLD               Administrators
    //              (Execute | Read)    GenericRead    |
    //                                  GenericExecute |
    //                                  DOMAIN_READ_OTHER_PARAMETERS |
    //                                  DOMAIN_ADMINISTER_SERVER     |
    //                                  DOMAIN_CREATE_ALIAS
    //
    //      Sacl:   Audit
    //              Success | Fail
    //              WORLD
    //              (Write | Delete | WriteDacl | AccessSystemSecurity)
    //
    //
    //
    //
    //
    //   The following security is assigned to
    //
    //             - SAM_SERVER object
    //             - Account DOMAIN objects
    //             - The Administrators alias.
    //             - All groups in the ACCOUNT or BUILTIN domain that are
    //               made a member of the Administrators alias.
    //
    //    Note: on WinNt systems, the ACLs do not grant DOMAIN_CREATE_GROUP.
    //
    //
    //      Owner: Administrators Alias
    //      Group: Administrators Alias
    //
    //      Dacl:   Grant               Grant
    //              WORLD               Administrators
    //              (Execute | Read)    GenericAll
    //
    //      Sacl:   Audit
    //              Success | Fail
    //              WORLD
    //              (Write | Delete | WriteDacl | AccessSystemSecurity)
    //
    //
    //
    //   All other aliases and groups must be assigned the following
    //   security:
    //
    //      Owner: Administrators Alias
    //      Group: Administrators Alias
    //
    //      Dacl:   Grant               Grant           Grant
    //              WORLD               Administrators  AccountOperators Alias
    //              (Execute | Read)    GenericAll      GenericAll
    //
    //      Sacl:   Audit
    //              Success | Fail
    //              WORLD
    //              (Write | Delete | WriteDacl | AccessSystemSecurity)
    //
    //
    //             - All users in the ACCOUNT or BUILTIN domain that are
    //               made a member of the Administratos alias.  This includes
    //               direct inclusion or indirect inclusion through group
    //               membership.
    //
    //
    //   The following security is assigned to:
    //
    //             - All users in the ACCOUNT or BUILTIN domain that are
    //               made a member of the Administrators alias.  This includes
    //               direct inclusion or indirect inclusion through group
    //               membership.
    //
    //
    //      Owner: Administrators Alias
    //      Group: Administrators Alias
    //
    //      Dacl:   Grant            Grant          Grant
    //              WORLD            Administrators User's SID
    //              (Execute | Read) GenericAll     GenericWrite
    //
    //      Sacl:   Audit
    //              Success | Fail
    //              WORLD
    //              (Write | Delete | WriteDacl | AccessSystemSecurity)
    //
    //
    //
    //
    //   All other users must be assigned the following
    //   security:
    //
    //      Owner: AccountOperators Alias
    //      Group: AccountOperators Alias
    //
    //      Dacl:   Grant            Grant          Grant                   Grant
    //              WORLD            Administrators Account Operators Alias User's SID
    //              (Execute | Read) GenericAll     GenericAll              GenericWrite
    //
    //      Sacl:   Audit
    //              Success | Fail
    //              WORLD
    //              (Write | Delete | WriteDacl | AccessSystemSecurity)
    //
    //   except builtin GUEST, who can't change their own account info.
    //
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //
    // Note, however, that because we are going to cram these ACLs
    // directly into the backing store, we must map the generic accesses
    // beforehand.
    //
    // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    //






    //
    // Sam Server SD
    //

    AceSid[0]  = WorldSid;
    AceMask[0] = (SAM_SERVER_EXECUTE | SAM_SERVER_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (SAM_SERVER_ALL_ACCESS);


    Status = SampBuildNewProtection(
                 2,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &SamServerMap,                         // GenericMap
                 FALSE,                                 // Not user object
                 &SampProtection[SAMP_PROT_SAM_SERVER]  // Result
                 );
    ASSERT(NT_SUCCESS(Status));

    //
    // Builtin Domain SD
    //

    AceSid[0]  = WorldSid;
    AceMask[0] = (DOMAIN_EXECUTE | DOMAIN_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (DOMAIN_EXECUTE | DOMAIN_READ |
                  DOMAIN_READ_OTHER_PARAMETERS |
                  DOMAIN_ADMINISTER_SERVER     |
                  DOMAIN_CREATE_ALIAS);


    Status = SampBuildNewProtection(
                 2,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &DomainMap,                            // GenericMap
                 FALSE,                                 // Not user object
                 &SampProtection[SAMP_PROT_BUILTIN_DOMAIN]      // Result
                 );
    ASSERT(NT_SUCCESS(Status));

    //
    // Account Domain SD
    //

    if (SampBldProductType == NtProductLanManNt) {
        NotForThisProductType = 0;
    } else {
        NotForThisProductType = DOMAIN_CREATE_GROUP;
    }

    AceSid[0]  = WorldSid;
    AceMask[0] = (DOMAIN_EXECUTE | DOMAIN_READ) & ~NotForThisProductType;

    AceSid[1]  = UsersAliasSid;
    AceMask[1] = (DOMAIN_EXECUTE | DOMAIN_READ)
                 & ~NotForThisProductType;

    AceSid[2]  = AdminsAliasSid;
    AceMask[2] = (DOMAIN_ALL_ACCESS) & ~NotForThisProductType;

    AceSid[3]  = PowerUsersAliasSid;
    AceMask[3] = (DOMAIN_EXECUTE | DOMAIN_READ | DOMAIN_CREATE_USER |
                                                 DOMAIN_CREATE_ALIAS)
                                                 & ~NotForThisProductType;

    AceSid[4]  = AccountAliasSid;
    AceMask[4] = (DOMAIN_EXECUTE | DOMAIN_READ | DOMAIN_CREATE_USER  |
                                                 DOMAIN_CREATE_GROUP |
                                                 DOMAIN_CREATE_ALIAS)
                                                 & ~NotForThisProductType;


    Status = SampBuildNewProtection(
                 5,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &DomainMap,                            // GenericMap
                 FALSE,                                 // Not user object
                 &SampProtection[SAMP_PROT_ACCOUNT_DOMAIN]      // Result
                 );
    ASSERT(NT_SUCCESS(Status));



    //
    // Admin Alias SD
    //

    AceSid[0]  = WorldSid;
    AceMask[0] = (ALIAS_EXECUTE | ALIAS_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (ALIAS_ALL_ACCESS);


    Status = SampBuildNewProtection(
                 2,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &AliasMap,                             // GenericMap
                 FALSE,                                 // Not user object
                 &SampProtection[SAMP_PROT_ADMIN_ALIAS] // Result
                 );
    ASSERT(NT_SUCCESS(Status));



    //
    // Normal Alias SD
    //

    AceSid[0]  = WorldSid;
    AceMask[0] = (ALIAS_EXECUTE | ALIAS_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (ALIAS_ALL_ACCESS);

    AceSid[2]  = AccountAliasSid;
    AceMask[2] = (ALIAS_ALL_ACCESS);


    Status = SampBuildNewProtection(
                 3,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &AliasMap,                             // GenericMap
                 FALSE,                                 // Not user object
                 &SampProtection[SAMP_PROT_NORMAL_ALIAS] // Result
                 );
    ASSERT(NT_SUCCESS(Status));




    //
    // Power User accessible Alias SD
    //

    AceSid[0]  = WorldSid;
    AceMask[0] = (ALIAS_EXECUTE | ALIAS_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (ALIAS_ALL_ACCESS);

    AceSid[2]  = AccountAliasSid;
    AceMask[2] = (ALIAS_ALL_ACCESS);

    AceSid[3]  = PowerUsersAliasSid;
    AceMask[3] = (ALIAS_ALL_ACCESS);


    Status = SampBuildNewProtection(
                 4,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &AliasMap,                             // GenericMap
                 FALSE,                                 // Not user object
                 &SampProtection[SAMP_PROT_PWRUSER_ACCESSIBLE_ALIAS] // Result
                 );
    ASSERT(NT_SUCCESS(Status));




    //
    // Admin Group SD
    //

    AceSid[0]  = WorldSid;
    AceMask[0] = (GROUP_EXECUTE | GROUP_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (GROUP_ALL_ACCESS);


    Status = SampBuildNewProtection(
                 2,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &GroupMap,                             // GenericMap
                 FALSE,                                 // Not user object
                 &SampProtection[SAMP_PROT_ADMIN_GROUP] // Result
                 );
    ASSERT(NT_SUCCESS(Status));



    //
    // Normal GROUP SD
    //

    AceSid[0]  = WorldSid;
    AceMask[0] = (GROUP_EXECUTE | GROUP_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (GROUP_ALL_ACCESS);

    AceSid[2]  = AccountAliasSid;
    AceMask[2] = (GROUP_ALL_ACCESS);


    Status = SampBuildNewProtection(
                 3,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &GroupMap,                             // GenericMap
                 FALSE,                                 // Not user object
                 &SampProtection[SAMP_PROT_NORMAL_GROUP] // Result
                 );
    ASSERT(NT_SUCCESS(Status));



    //
    // Admin User SD
    //

    AceSid[0]  = WorldSid;
    AceMask[0] = (USER_EXECUTE | USER_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (USER_ALL_ACCESS);

    AceSid[2]  = AnySidInAccountDomain;
    AceMask[2] = (USER_WRITE);


    Status = SampBuildNewProtection(
                 3,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &UserMap,                              // GenericMap
                 TRUE,                                  // user object (rid replacement)
                 &SampProtection[SAMP_PROT_ADMIN_USER]  // Result
                 );
    ASSERT(NT_SUCCESS(Status));


    //
    // Normal User SD
    //

    AceSid[0]  = WorldSid;
    AceMask[0] = (USER_EXECUTE | USER_READ);

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (USER_ALL_ACCESS);

    AceSid[2]  = AccountAliasSid;
    AceMask[2] = (USER_ALL_ACCESS);

    AceSid[3]  = AnySidInAccountDomain;
    AceMask[3] = (USER_WRITE);


    Status = SampBuildNewProtection(
                 4,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &UserMap,                              // GenericMap
                 TRUE,                                  // user object (rid replacement)
                 &SampProtection[SAMP_PROT_NORMAL_USER] // Result
                 );
    ASSERT(NT_SUCCESS(Status));



    //
    // Builtin Guest Account SD
    // Can't change own password or other setable fields
    //

    AceSid[0]  = WorldSid;
    AceMask[0] = (USER_READ | USER_EXECUTE & ~(USER_CHANGE_PASSWORD));

    AceSid[1]  = AdminsAliasSid;
    AceMask[1] = (USER_ALL_ACCESS);

    AceSid[2]  = AccountAliasSid;
    AceMask[2] = (USER_ALL_ACCESS);




    Status = SampBuildNewProtection(
                 3,                                     // AceCount
                 &AceSid[0],                            // AceSid array
                 &AceMask[0],                           // Ace Mask array
                 &UserMap,                              // GenericMap
                 FALSE,                                 // no rid replacement
                 &SampProtection[SAMP_PROT_GUEST_ACCOUNT]  // Result
                 );
    ASSERT(NT_SUCCESS(Status));



    return(TRUE);

}


NTSTATUS
SampBuildNewProtection(
    IN ULONG AceCount,
    IN PSID *AceSid,
    IN ACCESS_MASK *AceMask,
    IN PGENERIC_MAPPING GenericMap,
    IN BOOLEAN UserObject,
    OUT PSAMP_PROTECTION Result
    )

/*++


Routine Description:

    This routine builds a self-relative security descriptor ready
    to be applied to one of the SAM objects.

    If so indicated, a pointer to the last RID of the SID in the last
    ACE of the DACL is returned and a flag set indicating that the RID
    must be replaced before the security descriptor is applied to an object.
    This is to support USER object protection, which must grant some
    access to the user represented by the object.

    The owner and group of each security descriptor will be set
    to:

                    Owner:  Administrators Alias
                    Group:  Administrators Alias


    The SACL of each of these objects will be set to:


                    Audit
                    Success | Fail
                    WORLD
                    (Write | Delete | WriteDacl | AccessSystemSecurity) & !ReadControl



Arguments:

    AceCount - The number of ACEs to be included in the DACL.

    AceSid - Points to an array of SIDs to be granted access by the DACL.
        If the target SAM object is a User object, then the last entry
        in this array is expected to be the SID of an account within the
        domain with the last RID not yet set.  The RID will be set during
        actual account creation.

    AceMask - Points to an array of accesses to be granted by the DACL.
        The n'th entry of this array corresponds to the n'th entry of
        the AceSid array.  These masks should not include any generic
        access types.

    GenericMap - Points to a generic mapping for the target object type.


    UserObject - Indicates whether the target SAM object is a User object
        or not.  If TRUE (it is a User object), then the resultant
        protection will be set up indicating Rid replacement is necessary.

    Result - Receives a pointer to the resultant protection information.
        All access masks in ACLs in the result are mapped to standard and
        specific accesses.


Return Value:

    TBS.

--*/
{



    SECURITY_DESCRIPTOR     Absolute;
    PSECURITY_DESCRIPTOR    Relative;
    PACL                    TmpAcl;
    PACCESS_ALLOWED_ACE     TmpAce;
    PSID                    TmpSid;
    ULONG                   Length, i;
    PULONG                  RidLocation = NULL;
    BOOLEAN                 IgnoreBoolean;
    ACCESS_MASK             MappedMask;

    SAMTRACE("SampBuildNewProtection");

    //
    // The approach is to set up an absolute security descriptor that
    // looks like what we want and then copy it to make a self-relative
    // security descriptor.
    //


    Status = RtlCreateSecurityDescriptor(
                 &Absolute,
                 SECURITY_DESCRIPTOR_REVISION1
                 );
    ASSERT( NT_SUCCESS(Status) );



    //
    // Owner
    //

    Status = RtlSetOwnerSecurityDescriptor (&Absolute, AdminsAliasSid, FALSE );
    ASSERT(NT_SUCCESS(Status));



    //
    // Group
    //

    Status = RtlSetGroupSecurityDescriptor (&Absolute, AdminsAliasSid, FALSE );
    ASSERT(NT_SUCCESS(Status));




    //
    // Discretionary ACL
    //
    //      Calculate its length,
    //      Allocate it,
    //      Initialize it,
    //      Add each ACE
    //      Add it to the security descriptor
    //

    Length = (ULONG)sizeof(ACL);
    for (i=0; i<AceCount; i++) {

        Length += RtlLengthSid( AceSid[i] ) +
                  (ULONG)sizeof(ACCESS_ALLOWED_ACE) -
                  (ULONG)sizeof(ULONG);  //Subtract out SidStart field length
    }

    TmpAcl = RtlAllocateHeap( RtlProcessHeap(), 0, Length );
    ASSERT(TmpAcl != NULL);
    if (NULL==TmpAcl)
    {
        return(STATUS_NO_MEMORY);
    }


    Status = RtlCreateAcl( TmpAcl, Length, ACL_REVISION2);
    ASSERT( NT_SUCCESS(Status) );

    for (i=0; i<AceCount; i++) {
        MappedMask = AceMask[i];
        RtlMapGenericMask( &MappedMask, GenericMap );
        Status = RtlAddAccessAllowedAce (
                     TmpAcl,
                     ACL_REVISION2,
                     MappedMask,
                     AceSid[i]
                     );
        ASSERT( NT_SUCCESS(Status) );
    }

    Status = RtlSetDaclSecurityDescriptor (&Absolute, TRUE, TmpAcl, FALSE );
    ASSERT(NT_SUCCESS(Status));




    //
    // Sacl
    //


    Length = (ULONG)sizeof(ACL) +
             RtlLengthSid( WorldSid ) +
             RtlLengthSid( SampAnonymousSid ) +
             2*((ULONG)sizeof(SYSTEM_AUDIT_ACE) - (ULONG)sizeof(ULONG));  //Subtract out SidStart field length
    TmpAcl = RtlAllocateHeap( RtlProcessHeap(), 0, Length );
    ASSERT(TmpAcl != NULL);
    if (NULL == TmpAcl)
    {
        return(STATUS_NO_MEMORY);
    }

    Status = RtlCreateAcl( TmpAcl, Length, ACL_REVISION2);
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlAddAuditAccessAce (
                 TmpAcl,
                 ACL_REVISION2,
                 (GenericMap->GenericWrite | DELETE | WRITE_DAC | ACCESS_SYSTEM_SECURITY) & ~READ_CONTROL,
                 WorldSid,
                 TRUE,          //AuditSuccess,
                 TRUE           //AuditFailure
                 );
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlAddAuditAccessAce (
                 TmpAcl,
                 ACL_REVISION2,
                 GenericMap->GenericWrite | STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL,
                 SampAnonymousSid,
                 TRUE,          //AuditSuccess,
                 TRUE           //AuditFailure
                 );
    ASSERT( NT_SUCCESS(Status) );

    Status = RtlSetSaclSecurityDescriptor (&Absolute, TRUE, TmpAcl, FALSE );
    ASSERT(NT_SUCCESS(Status));






    //
    // Convert the Security Descriptor to Self-Relative
    //
    //      Get the length needed
    //      Allocate that much memory
    //      Copy it
    //      Free the generated absolute ACLs
    //

    Length = 0;
    Status = RtlAbsoluteToSelfRelativeSD( &Absolute, NULL, &Length );
    ASSERT(Status == STATUS_BUFFER_TOO_SMALL);

    Relative = RtlAllocateHeap( RtlProcessHeap(), 0, Length );
    ASSERT(Relative != NULL);
    if (NULL==Relative)
    {
        return(STATUS_NO_MEMORY);
    }
    Status = RtlAbsoluteToSelfRelativeSD(&Absolute, Relative, &Length );
    ASSERT(NT_SUCCESS(Status));


    RtlFreeHeap( RtlProcessHeap(), 0, Absolute.Dacl );
    RtlFreeHeap( RtlProcessHeap(), 0, Absolute.Sacl );




    //
    // If the object is a user object, then get the address of the
    // last RID of the SID in the last ACE in the DACL.
    //

    if (UserObject == TRUE) {

        Status = RtlGetDaclSecurityDescriptor(
                    Relative,
                    &IgnoreBoolean,
                    &TmpAcl,
                    &IgnoreBoolean
                    );
        ASSERT(NT_SUCCESS(Status));
        Status = RtlGetAce ( TmpAcl, AceCount-1, (PVOID *)&TmpAce );
        ASSERT(NT_SUCCESS(Status));
        TmpSid = (PSID)(&TmpAce->SidStart),

        RidLocation = RtlSubAuthoritySid(
                          TmpSid,
                          (ULONG)(*RtlSubAuthorityCountSid( TmpSid ) - 1)
                          );
    }







    //
    // Set the result information
    //

    Result->Length = Length;
    Result->Descriptor = Relative;
    Result->RidToReplace = RidLocation;
    Result->RidReplacementRequired = UserObject;



    return(Status);

}

NTSTATUS
SampGetDomainPolicy(
    IN PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo OPTIONAL
    )
/*++


Routine Description:

    This routine builds the name strings for domains.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG Size;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo;

    SAMTRACE("SampGetDomainPolicy");

    //
    // Builtin domain - Well-known External Name and Sid
    //                - Internal Name matches External Name

    RtlInitUnicodeString( &BuiltinInternalDomainNameU, L"Builtin");
    FullBuiltinInternalDomainNameU.Buffer        = RtlAllocateHeap(RtlProcessHeap(), 0, 256);
    if(NULL==FullBuiltinInternalDomainNameU.Buffer)
    {
        return(STATUS_NO_MEMORY);
    }
    FullBuiltinInternalDomainNameU.Length        = 0;
    FullBuiltinInternalDomainNameU.MaximumLength = 256;
    RtlCopyUnicodeString( &FullBuiltinInternalDomainNameU, &DomainNamePrefixU );
    Status = RtlAppendUnicodeToString( &FullBuiltinInternalDomainNameU, L"\\" );
    RtlAppendUnicodeStringToString( &FullBuiltinInternalDomainNameU, &BuiltinInternalDomainNameU );

    BuiltinExternalDomainNameU = BuiltinInternalDomainNameU;

    SampBuiltinDomainSid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 1 ));
    ASSERT( SampBuiltinDomainSid != NULL );
    if(NULL==SampBuiltinDomainSid)
    {
        return(STATUS_NO_MEMORY);
    }
    RtlInitializeSid( SampBuiltinDomainSid,   &BuiltinAuthority, 1 );
    *(RtlSubAuthoritySid( SampBuiltinDomainSid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;

    //
    // Account domain - Configurable External Name and Sid.
    //
    //                  The External Name and Sid are obtained from the
    //                  Lsa Policy Object (PolicyAccountDomainInformation
    //                  information class).  For a DC, the External Name
    //                  is the Domain Name and for a Wksta, the External
    //                  Name is the Computer Name as at the time of the
    //                  system load.
    //
    //                  For DC's the Internal Name is the Domain Name
    //                - For Wksta's the Internal Name is the constant name
    //                  "Account".
    //
    //                NOTE:  The reason for these choices of Internal Name
    //                       is to avoid having to change the SAM Database.
    //

    if (!ARGUMENT_PRESENT(AccountDomainInfo)) {
        Status = SampGetAccountDomainInfo( &PolicyAccountDomainInfo );
    } else {
        PolicyAccountDomainInfo = AccountDomainInfo;
        Status = STATUS_SUCCESS;
    }

    if (!NT_SUCCESS(Status)) {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "BLDSAM3:  Couldn't retrieve policy information from LSA.\n"
                   "          Status = 0x%lx\n",
                   Status));

        return Status;
    }

    SampAccountDomainSid = PolicyAccountDomainInfo->DomainSid;

    AccountExternalDomainNameU = PolicyAccountDomainInfo->DomainName;

    RtlInitUnicodeString( &AccountInternalDomainNameU, L"Account");

    FullAccountInternalDomainNameU.Buffer        = RtlAllocateHeap(RtlProcessHeap(), 0, 256);
    if(NULL==FullAccountInternalDomainNameU.Buffer)
    {
        return(STATUS_NO_MEMORY);
    }
    FullAccountInternalDomainNameU.Length        = 0;
    FullAccountInternalDomainNameU.MaximumLength = SAMP_MAXIMUM_INTERNAL_NAME_LENGTH;
    RtlCopyUnicodeString( &FullAccountInternalDomainNameU, &DomainNamePrefixU );
    Status = RtlAppendUnicodeToString( &FullAccountInternalDomainNameU, L"\\" );
    RtlAppendUnicodeStringToString( &FullAccountInternalDomainNameU, &AccountInternalDomainNameU );

    //
    // Now initialize a SID that can be used to represent accounts
    // in this domain.  Same as SampAccountDomainSid except with one
    // extra sub-authority.  It doesn't matter what the value of the
    // last RID is because it is always replaced before use.
    //

    Size = RtlLengthSid( SampAccountDomainSid ) + sizeof(ULONG);
    AnySidInAccountDomain = RtlAllocateHeap( RtlProcessHeap(), 0, Size);
    ASSERT( AnySidInAccountDomain != NULL );
    if(NULL==AnySidInAccountDomain)
    {
        return(STATUS_NO_MEMORY);
    }
    Status = RtlCopySid( Size, AnySidInAccountDomain, SampAccountDomainSid );
    ASSERT(NT_SUCCESS(Status));
    (*RtlSubAuthorityCountSid( AnySidInAccountDomain )) += 1;


    //
    // Set builtin as "current" domain
    //

    SetCurrentDomain( DomainBuiltin );

    return(STATUS_SUCCESS);
}


VOID
SetCurrentDomain(
    IN SAMP_DOMAIN_SELECTOR Domain
    )
/*++


Routine Description:

    This routine sets the current domain to be
    either the account or builtin domain.

Arguments:

    Domain - Specifies either builtin or account domain.
             (DomainBuiltin or DomainAccount).


Return Value:

    None.

--*/
{

    SAMTRACE("SetCurrentDomain");


    if (Domain == DomainBuiltin) {

        DomainNameU = &BuiltinInternalDomainNameU;
        FullDomainNameU = &FullBuiltinInternalDomainNameU;
        DomainSid = SampBuiltinDomainSid;

    } else {

        DomainNameU = &AccountInternalDomainNameU;
        FullDomainNameU = &FullAccountInternalDomainNameU;
        DomainSid = SampAccountDomainSid;

    }



    return;
}

NTSTATUS
InitializeSam(
    )

/*++

Routine Description:

    This routine initializes the SAM-level registry information.
    It does not initialize any domains in the SAM.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PSAMP_V1_FIXED_LENGTH_SERVER ServerFixedAttributes;
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE ServerVariableAttributeArray;
    PVOID ServerVariableData;
    OBJECT_ATTRIBUTES SamAttributes;
    UNICODE_STRING SamNameU;
    ULONG Disposition;
    ULONG ServerAttributeLength;
    SECURITY_DESCRIPTOR SecurityDescriptor;
    BOOLEAN IgnoreBoolean;
    PACL Dacl;

    SAMTRACE("InitializeSam");

    //
    // Build a system default Dacl to protect the SAM database
    // with.
    //

    Status = SampCreateDatabaseProtection( &SecurityDescriptor );
    if (!NT_SUCCESS(Status)) {
        return(Status);
    }

    //
    // See if a remnant of a SAM database already exists
    //

    RtlInitUnicodeString( &SamNameU, L"SAM" );

    InitializeObjectAttributes(
        &SamAttributes,
        &SamNameU,
        OBJ_CASE_INSENSITIVE,
        SamParentKey,
        &SecurityDescriptor
        );
    Status = RtlpNtCreateKey(
                 &SamKey,
                 (KEY_READ | KEY_CREATE_SUB_KEY | KEY_WRITE),
                 &SamAttributes,
                 0,
                 NULL,
                 &Disposition
                 );

    Status = RtlGetDaclSecurityDescriptor(
                 &SecurityDescriptor,
                 &IgnoreBoolean,
                 &Dacl,
                 &IgnoreBoolean
                 );

    if (Dacl != NULL) {
        RtlFreeHeap( RtlProcessHeap(), 0, Dacl );
    }
    ASSERT(SecurityDescriptor.Sacl == NULL);
    ASSERT(SecurityDescriptor.Owner == NULL);
    ASSERT(SecurityDescriptor.Group == NULL);

    if ( !NT_SUCCESS(Status) ) {

#if DBG
        BldPrint( "\n" );
        BldPrint( "\n" );
        BldPrint( "  We seem to  be having trouble creating  the registry\n" );
        BldPrint( "  database key in which  the  Security Account Manager\n" );
        BldPrint( "  information resides.  Please see one of the security\n" );
        BldPrint( "  group  developers  for  assistance in  analyzing the\n" );
        BldPrint( "  the problem.\n" );
        BldPrint( "\n" );
        BldPrint( "\n" );
#endif

        return(Status);
    }

    if ( Disposition != REG_CREATED_NEW_KEY ) {

#if DBG
        BldPrint( "\n" );
        BldPrint( "\n" );
        BldPrint( "  I'm terribly sorry, but you have specified that a SAM\n" );
        BldPrint( "  database be initialized and yet there is already a SAM\n" );
        BldPrint( "  database in existance.  If the SAM database is corrupt\n" );
        BldPrint( "  or you would like to replace the existing domain anyway,\n" );
        BldPrint( "  please delnode the existing database and re-issue this \n");
        BldPrint( "  command.  \n");
        BldPrint( "  The SAM database is in ...\\registry\\Machine\\security\\sam.\n" );
        BldPrint( "  Thank you.\n" );
        BldPrint( "\n" );
        BldPrint( "\n" );
#endif

        Usage();

        Status = NtClose( SamKey );


        return(Status);
    }


    //
    // Initialize the registry transaction structure for SAM.
    //

    Status = RtlInitializeRXact( SamKey, FALSE, &SamRXactContext );

    if ( Status != STATUS_RXACT_STATE_CREATED ) {
#if DBG
        BldPrint("\n");
        BldPrint("  The SAM database already has a structure in place.\n");
        BldPrint("  This indicates multiple initializations being performed\n");
        BldPrint("  simultaneously.  Please be sure no other initializations\n");
        BldPrint("  are being performed and issue this command again.\n");
        BldPrint("\n");
        BldPrint("\n");
#endif

        if ( Status == STATUS_SUCCESS ) {

            //
            // Shouldn't happen, but let's program defensively.
            //

            Status = STATUS_RXACT_INVALID_STATE;
        }

        return(Status);
    }

    //
    // Start an RXACT to do the rest in ...
    //

    Status = RtlStartRXact( SamRXactContext );
    SUCCESS_ASSERT(Status, "  Starting transaction\n");

    //
    // Set the server's fixed and variable attributes
    //

    ServerAttributeLength = sizeof( SAMP_V1_FIXED_LENGTH_SERVER ) +
                                ( SAMP_SERVER_VARIABLE_ATTRIBUTES *
                                sizeof( SAMP_VARIABLE_LENGTH_ATTRIBUTE ) ) +
                                SampProtection[SAMP_PROT_SAM_SERVER].Length;

    ServerFixedAttributes = (PSAMP_V1_FIXED_LENGTH_SERVER)RtlAllocateHeap(
                                RtlProcessHeap(), 0,
                                ServerAttributeLength
                                );

    if ( ServerFixedAttributes == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    SUCCESS_ASSERT(Status, "  Failed to create server attributes\n");

    //
    // The server revision on the a new SAM database may not be the same
    // as the revision on the rest of SAM.  This allows the server revision
    // to indicate which bugs have been fixed in this SAM.
    //

    ServerFixedAttributes->RevisionLevel = SAMP_NT4_SERVER_REVISION;

    ServerVariableAttributeArray = (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)
                                   ((PUCHAR)(ServerFixedAttributes) +
                                   sizeof( SAMP_V1_FIXED_LENGTH_SERVER ) );

    ServerVariableAttributeArray->Offset = 0;
    ServerVariableAttributeArray->Length =
        SampProtection[SAMP_PROT_SAM_SERVER].Length;
    ServerVariableAttributeArray->Qualifier = SAMP_REVISION;

    ServerVariableData = (PVOID)( (PUCHAR)(ServerVariableAttributeArray) +
                         sizeof( SAMP_VARIABLE_LENGTH_ATTRIBUTE ) );

    RtlCopyMemory(
        ServerVariableData,
        SampProtection[SAMP_PROT_SAM_SERVER].Descriptor,
        SampProtection[SAMP_PROT_SAM_SERVER].Length
        );

    //
    // Now write out the attributes via the RXACT.
    //

    RtlInitUnicodeString( &SamNameU, NULL );

    SampDumpRXact(SampRXactContext,
                  RtlRXactOperationSetValue,
                  &SamNameU,
                  INVALID_HANDLE_VALUE,
                  &SampCombinedAttributeName,
                  REG_BINARY,
                  (PVOID)ServerFixedAttributes,
                  ServerAttributeLength,
                  FIXED_LENGTH_SERVER_FLAG);

    Status = RtlAddAttributeActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &SamNameU,
                 INVALID_HANDLE_VALUE,
                 &SampCombinedAttributeName,
                 REG_BINARY,
                 (PVOID)ServerFixedAttributes,
                 ServerAttributeLength
                 );

    SUCCESS_ASSERT(Status, "  Failed to write out server attributes\n" );

    RtlFreeHeap( RtlProcessHeap(), 0, ServerFixedAttributes );

    //
    // Create SAM\Domains
    //

    Status = RtlAddActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &DomainNamePrefixU,
                 0,
                 NULL,
                 0
                 );

    SUCCESS_ASSERT(Status, "  Failed to add domain key to log\n");

    Status = RtlApplyRXactNoFlush( SamRXactContext );
    SUCCESS_ASSERT(Status, "  Committing SAM INIT transaction\n");

    return(Status);
}


NTSTATUS
SampCreateDatabaseProtection(
    PISECURITY_DESCRIPTOR   Sd
    )


/*++

Routine Description:

    This function allocates and initializes protection to assign to
    the SAM database.

    Upon return, any non-zero pointers in the security descriptors
    point to memory allocated from process heap.  It is the caller's
    responsibility to free this memory.


    Protection is:

                        System: All Access
                        Admin:  ReadControl | WriteDac

Arguments:

    Sd - Address of a security descriptor to initialize.

Return Value:

    STATUS_SUCCESS - The Security descriptor has been initialize.

    STATUS_NO_MEMORY - couldn't allocate memory for the protection info.

--*/


{
    NTSTATUS
        Status;

    ULONG
        Length;

    USHORT
        i;

    PACL
        Dacl;

    PACE_HEADER
        Ace;

    SAMTRACE("SampCreateDatabaseProtection");


    //
    // Initialize the security descriptor.
    // This call should not fail.
    //

    Status = RtlCreateSecurityDescriptor( Sd, SECURITY_DESCRIPTOR_REVISION1 );
    ASSERT(NT_SUCCESS(Status));

    Length = (ULONG)sizeof(ACL) +
                 (2*((ULONG)sizeof(ACCESS_ALLOWED_ACE))) +
                 RtlLengthSid( LocalSystemSid ) +
                 RtlLengthSid( AdminsAliasSid ) +
                 8; // The 8 is just for good measure


    Dacl = RtlAllocateHeap( RtlProcessHeap(), 0, Length );

    if (Dacl == NULL) {
        return(STATUS_NO_MEMORY);
    }


    Status = RtlCreateAcl (Dacl, Length, ACL_REVISION2 );
    ASSERT(NT_SUCCESS(Status));

    //
    // Add ACEs to the ACL...
    // These calls should not be able to fail.
    //

    Status = RtlAddAccessAllowedAce(
                 Dacl,
                 ACL_REVISION2,
                 (GENERIC_ALL ),
                 LocalSystemSid
                 );
    ASSERT(NT_SUCCESS(Status));

    Status = RtlAddAccessAllowedAce(
                 Dacl,
                 ACL_REVISION2,
                 (READ_CONTROL | WRITE_DAC),
                 AdminsAliasSid
                 );
    ASSERT(NT_SUCCESS(Status));


    //
    // Now mark the ACEs as inheritable...
    //

    for ( i=0; i<Dacl->AceCount; i++) {

        //
        // Get the address of the next ACE
        // (Shouldn't fail)
        //

        Status = RtlGetAce( Dacl, (ULONG)i, &Ace );
        ASSERT(NT_SUCCESS(Status));

        Ace->AceFlags |= (CONTAINER_INHERIT_ACE);

    }


    //
    // And add the ACL to the security descriptor.
    // This call should not fail.
    //

    Status = RtlSetDaclSecurityDescriptor(
                 Sd,
                 TRUE,              // DaclPresent
                 Dacl,              // Dacl OPTIONAL
                 FALSE              // DaclDefaulted OPTIONAL
                 );
    ASSERT(NT_SUCCESS(Status));



    return(STATUS_SUCCESS);

}


NTSTATUS
CreateBuiltinDomain (
    )

/*++

Routine Description:

    This routine creates a new builtin domain.

Arguments:

    None.

Return Value:

    None.

--*/

{
    NTSTATUS Status;
    UNICODE_STRING Name, Comment;
    HMODULE AccountNamesResource;
    OSVERSIONINFOEXW osvi;
    BOOL fPersonalSKU = FALSE;

    SAMTRACE("CreateBuiltinDomain");


    //
    // Determine if we are installing Personal SKU
    //

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);
    GetVersionEx((OSVERSIONINFOW*)&osvi);

    fPersonalSKU = ( osvi.wProductType == VER_NT_WORKSTATION && (osvi.wSuiteMask & VER_SUITE_PERSONAL));


    //
    // Get the message resource we need to get the account names from
    //

    AccountNamesResource = (HMODULE) LoadLibrary( L"SAMSRV.DLL" );
    if (AccountNamesResource == NULL) {
        return(STATUS_RESOURCE_DATA_NOT_FOUND);
    }




    //
    // Prep the standard domain registry structure for this domain
    //

    Status = PrepDomain(DomainBuiltin,FALSE);

    if (!NT_SUCCESS(Status)) {

        return(Status);
    }

    //
    // Create the alias accounts with no members
    // (Common to LanManNT and WinNT products)
    //

    if (fPersonalSKU)
	{
        Status = SampGetMessageStrings(
					AccountNamesResource,
					SAMP_ALIAS_NAME_ADMINS_PERS,
					&Name,
					SAMP_ALIAS_COMMENT_ADMINS_PERS,
					&Comment
					); ASSERT(NT_SUCCESS(Status));

	}
    else
	{

        Status = SampGetMessageStrings(
					AccountNamesResource,
					SAMP_ALIAS_NAME_ADMINS,
					&Name,
					SAMP_ALIAS_COMMENT_ADMINS,
					&Comment
					); ASSERT(NT_SUCCESS(Status));
	}

    Status = CreateAlias(&Name,                          // AccountName
                         &Comment,                       // AccountComment
                         TRUE,                           // SpecialAccount
                         DOMAIN_ALIAS_RID_ADMINS,        // Rid
                         SAMP_PROT_ADMIN_ALIAS           // Protection
                         ); ASSERT(NT_SUCCESS(Status));
    LocalFree( Name.Buffer );
    LocalFree( Comment.Buffer );

    Status = SampGetMessageStrings(
                AccountNamesResource,
                SAMP_ALIAS_NAME_USERS,
                &Name,
                SAMP_ALIAS_COMMENT_USERS,
                &Comment
                ); ASSERT(NT_SUCCESS(Status));

    Status = CreateAlias(&Name,                   // AccountName
                        &Comment,                // AccountComment
                        TRUE,                           // SpecialAccount
                        DOMAIN_ALIAS_RID_USERS,         // Rid
                        SAMP_PROT_PWRUSER_ACCESSIBLE_ALIAS // Protection
                        ); ASSERT(NT_SUCCESS(Status));

    LocalFree( Name.Buffer );
    LocalFree( Comment.Buffer );

    Status = SampGetMessageStrings(
                AccountNamesResource,
                SAMP_ALIAS_NAME_GUESTS,
                &Name,
                SAMP_ALIAS_COMMENT_GUESTS,
                &Comment
                ); ASSERT(NT_SUCCESS(Status));

    Status = CreateAlias(&Name,                   // AccountName
                        &Comment,                // AccountComment
                        TRUE,                           // SpecialAccount
                        DOMAIN_ALIAS_RID_GUESTS,        // Rid
                        SAMP_PROT_PWRUSER_ACCESSIBLE_ALIAS // Protection
                        ); ASSERT(NT_SUCCESS(Status));

    LocalFree( Name.Buffer );
    LocalFree( Comment.Buffer );


    if (!fPersonalSKU)
	{
        // Personal SKU doesn't have Backup Operators or Replicators

        Status = SampGetMessageStrings(
					AccountNamesResource,
					SAMP_ALIAS_NAME_BACKUP_OPS,
					&Name,
					SAMP_ALIAS_COMMENT_BACKUP_OPS,
					&Comment
					); ASSERT(NT_SUCCESS(Status));

        Status = CreateAlias(&Name,                   // AccountName
							&Comment,                // AccountComment
							TRUE,                           // SpecialAccount
							DOMAIN_ALIAS_RID_BACKUP_OPS,    // Rid
							SAMP_PROT_ADMIN_ALIAS          // Protection
							); ASSERT(NT_SUCCESS(Status));

        LocalFree( Name.Buffer );
        LocalFree( Comment.Buffer );


        Status = SampGetMessageStrings(
					AccountNamesResource,
					SAMP_ALIAS_NAME_REPLICATOR,
					&Name,
					SAMP_ALIAS_COMMENT_REPLICATOR,
					&Comment
					); ASSERT(NT_SUCCESS(Status));

        Status = CreateAlias(&Name,                   // AccountName
							&Comment,                // AccountComment
							TRUE,                           // SpecialAccount
							DOMAIN_ALIAS_RID_REPLICATOR,    // Rid
							SAMP_PROT_NORMAL_ALIAS          // Protection
							); ASSERT(NT_SUCCESS(Status));

        LocalFree( Name.Buffer );
        LocalFree( Comment.Buffer );
	}


    if (SampBldProductType == NtProductLanManNt) {

        //
        // specific to LanManNT products
        //

        Status = SampGetMessageStrings(
                    AccountNamesResource,
                    SAMP_ALIAS_NAME_SERVER_OPS,
                    &Name,
                    SAMP_ALIAS_COMMENT_SERVER_OPS,
                    &Comment
                    ); ASSERT(NT_SUCCESS(Status));

        Status = CreateAlias(&Name,                   // AccountName
                            &Comment,                // AccountComment
                            TRUE,                           // SpecialAccount
                            DOMAIN_ALIAS_RID_SYSTEM_OPS,    // Rid
                            SAMP_PROT_ADMIN_ALIAS           // Protection
                            ); ASSERT(NT_SUCCESS(Status));

        LocalFree( Name.Buffer );
        LocalFree( Comment.Buffer );


        Status = SampGetMessageStrings(
                    AccountNamesResource,
                    SAMP_ALIAS_NAME_ACCOUNT_OPS,
                    &Name,
                    SAMP_ALIAS_COMMENT_ACCOUNT_OPS,
                    &Comment
                    ); ASSERT(NT_SUCCESS(Status));

        Status = CreateAlias(&Name,                   // AccountName
                            &Comment,                // AccountComment
                            TRUE,                           // SpecialAccount
                            DOMAIN_ALIAS_RID_ACCOUNT_OPS,   // Rid
                            SAMP_PROT_ADMIN_ALIAS           // Protection
                            ); ASSERT(NT_SUCCESS(Status));

        LocalFree( Name.Buffer );
        LocalFree( Comment.Buffer );


        Status = SampGetMessageStrings(
                    AccountNamesResource,
                    SAMP_ALIAS_NAME_PRINT_OPS,
                    &Name,
                    SAMP_ALIAS_COMMENT_PRINT_OPS,
                    &Comment
                    ); ASSERT(NT_SUCCESS(Status));

        Status = CreateAlias(&Name,                   // AccountName
                            &Comment,                // AccountComment
                            TRUE,                           // SpecialAccount
                            DOMAIN_ALIAS_RID_PRINT_OPS,     // Rid
                            SAMP_PROT_ADMIN_ALIAS           // Protection
                            ); ASSERT(NT_SUCCESS(Status));

        LocalFree( Name.Buffer );
        LocalFree( Comment.Buffer );


    } else {

        //
        // specific to WinNT products
        //
        if (!fPersonalSKU)
		{

			Status = SampGetMessageStrings(
						AccountNamesResource,
						SAMP_ALIAS_NAME_POWER_USERS,
						&Name,
						SAMP_ALIAS_COMMENT_POWER_USERS,
						&Comment
						); ASSERT(NT_SUCCESS(Status));

			Status = CreateAlias(&Name,                   // AccountName
								&Comment,                // AccountComment
								TRUE,                           // SpecialAccount
								DOMAIN_ALIAS_RID_POWER_USERS,   // Rid
								SAMP_PROT_PWRUSER_ACCESSIBLE_ALIAS // Protection
								); ASSERT(NT_SUCCESS(Status));

			LocalFree( Name.Buffer );
			LocalFree( Comment.Buffer );
		}


    }

    return(Status);
}



NTSTATUS
CreateAccountDomain (
    IN BOOLEAN PreserveSyskeySettings
    )
/*++


Routine Description:

    This routine creates a new account domain using information
    from the configuration database and based upon the system's
    product type.

    If the product is a WinNt system, then the domain's name is
    "Account".  If the product is a LanManNT system, then the
    domain's name is retrieved from the configuration information.

Arguments:

    None.

Return Value:

    None.

--*/

{

    NTSTATUS Status;
    UNICODE_STRING Name, Comment;
    HMODULE AccountNamesResource;
    ULONG AccountControl;
    ULONG PrimaryGroup;
    OSVERSIONINFOEXW osvi;
    BOOL fPersonalSKU = FALSE;

    SAMTRACE("CreateAccountDomain");


    //
    // Determine if we are installing Personal SKU
    //

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);
    GetVersionEx((OSVERSIONINFOW*)&osvi);

    fPersonalSKU = ( osvi.wProductType == VER_NT_WORKSTATION && (osvi.wSuiteMask && VER_SUITE_PERSONAL));


    //
    // Get the message resource we need to get the account names from
    //

    AccountNamesResource = (HMODULE) LoadLibrary( L"SAMSRV.DLL" );
    if (AccountNamesResource == NULL) {
        DbgPrint("BLDSAM3: Error loading library - error is 0x%lx", GetLastError());
        return(STATUS_RESOURCE_DATA_NOT_FOUND);
    }



    //
    // Prep the standard domain registry structure for this domain
    //

    Status = PrepDomain(DomainAccount,PreserveSyskeySettings);

    if (!NT_SUCCESS(Status)) {

        return(Status);
    }

    //
    // Create the group accounts with no members
    //

    if ((SampBldProductType == NtProductWinNt) ||
        (SampBldProductType == NtProductServer)) {

        //
        // WinNt systems only have one group (called 'None').
        // This group has the same RID as the 'Domain Users' group.
        //

        Status = SampGetMessageStrings(
                    AccountNamesResource,
                    SAMP_GROUP_NAME_NONE,
                    &Name,
                    SAMP_GROUP_COMMENT_NONE,
                    &Comment
                    ); ASSERT(NT_SUCCESS(Status));

        Status = CreateGroup(&Name,                   // AccountName
                             &Comment,                // AccountComment
                             TRUE,                           // SpecialAccount
                             DOMAIN_GROUP_RID_USERS,         // Rid
                             FALSE                           // Admin
                             ); ASSERT(NT_SUCCESS(Status));

        LocalFree( Name.Buffer );
        LocalFree( Comment.Buffer );

    } else {

        //
        // LanManNT
        //

        //
        // USERS global group
        //

        Status = SampGetMessageStrings(
                    AccountNamesResource,
                    SAMP_GROUP_NAME_USERS,
                    &Name,
                    SAMP_GROUP_COMMENT_USERS,
                    &Comment
                    ); ASSERT(NT_SUCCESS(Status));

        Status = CreateGroup(&Name,                   // AccountName
                             &Comment,                // AccountComment
                             TRUE,                           // SpecialAccount
                             DOMAIN_GROUP_RID_USERS,         // Rid
                             FALSE                           // Admin
                             ); ASSERT(NT_SUCCESS(Status));

        LocalFree( Name.Buffer );
        LocalFree( Comment.Buffer );

        //
        // ADMINS global group
        //

        Status = SampGetMessageStrings(
                    AccountNamesResource,
                    SAMP_GROUP_NAME_ADMINS,
                    &Name,
                    SAMP_GROUP_COMMENT_ADMINS,
                    &Comment
                    ); ASSERT(NT_SUCCESS(Status));

        Status = CreateGroup(&Name,                   // AccountName
                             &Comment,                // AccountComment
                             TRUE,                           // SpecialAccount
                             DOMAIN_GROUP_RID_ADMINS,        // Rid
                             TRUE                            // Admin
                             ); ASSERT(NT_SUCCESS(Status));

        LocalFree( Name.Buffer );
        LocalFree( Comment.Buffer );


        //
        // GUESTS global group
        //

        Status = SampGetMessageStrings(
                    AccountNamesResource,
                    SAMP_GROUP_NAME_GUESTS,
                    &Name,
                    SAMP_GROUP_COMMENT_GUESTS,
                    &Comment
                    ); ASSERT(NT_SUCCESS(Status));

        Status = CreateGroup(&Name,                   // AccountName
                             &Comment,                // AccountComment
                             TRUE,                           // SpecialAccount
                             DOMAIN_GROUP_RID_GUESTS,        // Rid
                             FALSE                           // Admin
                             ); ASSERT(NT_SUCCESS(Status));

        LocalFree( Name.Buffer );
        LocalFree( Comment.Buffer );

    }

    //
    // create the user accounts ...
    // These are automatically added to the "Domain Users" group
    // (except for Guest).
    //

    Status = SampGetMessageStrings(
                AccountNamesResource,
                SAMP_USER_NAME_ADMIN,
                &Name,
                SAMP_USER_COMMENT_ADMIN,
                &Comment
                ); ASSERT(NT_SUCCESS(Status));

    Status = CreateUser( &Name,                         // AccountName
                         &Comment,                      // AccountComment
                         TRUE,                          // SpecialAccount
                         DOMAIN_USER_RID_ADMIN,         // UserRid
                         DOMAIN_GROUP_RID_USERS,        // PrimaryGroup
                         TRUE,                          // Admin flag
                         USER_NORMAL_ACCOUNT |
                             USER_DONT_EXPIRE_PASSWORD, // AccountControl
                         SAMP_PROT_ADMIN_USER           // ProtectionIndex
                         ); ASSERT(NT_SUCCESS(Status));

        LocalFree( Name.Buffer );
        LocalFree( Comment.Buffer );


    Status = SampGetMessageStrings(
                AccountNamesResource,
                SAMP_USER_NAME_GUEST,
                &Name,
                SAMP_USER_COMMENT_GUEST,
                &Comment
                ); ASSERT(NT_SUCCESS(Status));

    //
    // Only Enable Guest user account on Personal systems, all others disable
    //

	
    AccountControl = USER_NORMAL_ACCOUNT |
                     USER_DONT_EXPIRE_PASSWORD |
                     USER_PASSWORD_NOT_REQUIRED;

    if ( !fPersonalSKU )
        AccountControl |= USER_ACCOUNT_DISABLED;


    if (SampBldProductType == NtProductLanManNt) {

        //
        // Guest group is in GUESTS global group for LmNT systems.
        //

        PrimaryGroup = DOMAIN_GROUP_RID_GUESTS;

    } else {

        //
        // There isn't a GUESTS global group on WinNt systems.
        // Put the guest in the NONE group (same as USERS group).
        //

        PrimaryGroup = DOMAIN_GROUP_RID_USERS;

    }


    Status = CreateUser( &Name,                         // AccountName
                         &Comment,                      // AccountComment
                         TRUE,                          // SpecialAccount
                         DOMAIN_USER_RID_GUEST,         // UserRid
                         PrimaryGroup,                  // PrimaryGroup
                         FALSE,                         // Admin flag
                         AccountControl,                // AccountControl
                         SAMP_PROT_GUEST_ACCOUNT        // ProtectionIndex
                         ); ASSERT(NT_SUCCESS(Status));

        LocalFree( Name.Buffer );
        LocalFree( Comment.Buffer );

    return(Status);
}


NTSTATUS
PrepDomain(
    IN SAMP_DOMAIN_SELECTOR Domain,
    IN BOOLEAN PreserveSyskeySettings
    )

/*++

Routine Description:

    This routine adds the domain level definitions to the operation log.

Arguments:

    Domain - Indicates which domain is being prep'd
    PreserveSyskeySettings -- Indicates that current syskey settings needs to
                              be preserved


Return Value:

    TBS

--*/

{
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN DomainFixedAttributes;
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE DomainVariableAttributeArray;
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE DomainVariableAttributeArrayStart;
    PVOID DomainVariableData;
    ULONG DomainAttributeLength;
    ULONG ProtectionIndex;
    ULONG UserCount, GroupCount, AliasCount;
    OSVERSIONINFOEXW osvi;
    BOOL fPersonalSKU = FALSE;

    SAMTRACE("PrepDomain");

    //
    // Determine if we are installing Personal SKU
    //

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);
    GetVersionEx((OSVERSIONINFOW*)&osvi);

    fPersonalSKU = ( osvi.wProductType == VER_NT_WORKSTATION && (osvi.wSuiteMask && VER_SUITE_PERSONAL));


    //
    // Set current domain
    //

    SetCurrentDomain( Domain );

    //
    // Select correct protection, and the number of accounts we're going
    // to create
    //

    if (Domain == DomainBuiltin) {

        ProtectionIndex = SAMP_PROT_BUILTIN_DOMAIN;

        UserCount = 0;
        GroupCount = 0;

        if (SampBldProductType == NtProductLanManNt) {

            //
            // Admins, BackupOps, Guests, Replicator, Users, SysOps,
            // AcctOps, PrintOps
            //

            AliasCount = 8;

        } else {
            if (fPersonalSKU)
			{
                //
                // Admins, Guests, Users
                //
	            AliasCount = 3;
			}
            else
			{
                //
                // Admins, BackupOps, Guests, Replicator, Users, Power Users
                //
                AliasCount = 6;
			}
        }

    } else {

        ProtectionIndex = SAMP_PROT_ACCOUNT_DOMAIN;

        AliasCount = 0;
        UserCount = 2;  // Administrator, Guest

        if (SampBldProductType == NtProductLanManNt) {

            GroupCount = 3; // Users, Administrators, Guests

        } else {

            GroupCount = 1; // "None"
        }
    }

    //
    // Use a transaction.
    //

    Status = RtlStartRXact( SamRXactContext );
    SUCCESS_ASSERT(Status, "  Starting transaction\n");

    //
    // Create SAM\Domains\(DomainName) (KeyValueType is revision level)
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );

    //
    // Set the domain's fixed and variable attributes.
    //

    DomainFixedAttributes = (PSAMP_V1_0A_FIXED_LENGTH_DOMAIN)RtlAllocateHeap(
                                RtlProcessHeap(), 0,
                                sizeof( SAMP_V1_0A_FIXED_LENGTH_DOMAIN )
                                );

    if ( DomainFixedAttributes == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    SUCCESS_ASSERT(Status, "  Failed to create domain fixed attributes\n");

    RtlZeroMemory(
        DomainFixedAttributes,
        sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN));

    DomainFixedAttributes->Revision                  = SAMP_REVISION;
    DomainFixedAttributes->MinPasswordLength         = 0;
    DomainFixedAttributes->PasswordHistoryLength     = 0;
    DomainFixedAttributes->PasswordProperties        = 0L;
    DomainFixedAttributes->NextRid                   = 1000;
    DomainFixedAttributes->ServerState               = DomainServerEnabled;
    DomainFixedAttributes->ServerRole                = SampServerRole;
    NtQuerySystemTime( &(DomainFixedAttributes->CreationTime) );
    DomainFixedAttributes->ModifiedCount             = ModifiedCount;
    DomainFixedAttributes->MaxPasswordAge            = DomainMaxPasswordAge;
    DomainFixedAttributes->MinPasswordAge            = SampImmediatelyDeltaTime;
    DomainFixedAttributes->ForceLogoff               = SampNeverDeltaTime;
    DomainFixedAttributes->UasCompatibilityRequired  = TRUE;
    DomainFixedAttributes->LockoutDuration.LowPart   = 0xCF1DCC00; // 30 minutes - low part
    DomainFixedAttributes->LockoutDuration.HighPart  = 0XFFFFFFFB; // 30 minutes - high part
    DomainFixedAttributes->LockoutObservationWindow.LowPart  = 0xCF1DCC00; // 30 minutes - low part
    DomainFixedAttributes->LockoutObservationWindow.HighPart = 0XFFFFFFFB; // 30 minutes - high part
    DomainFixedAttributes->LockoutThreshold          = 0;   // Disabled
    DomainFixedAttributes->ModifiedCountAtLastPromotion = ModifiedCount;
    if (PreserveSyskeySettings)
    {
        ASSERT(SampSecretEncryptionEnabled);
        ASSERT(NULL!=SampDefinedDomains);
        ASSERT(SampDefinedDomainsCount>=2);

        DomainFixedAttributes->DomainKeyAuthType
                 = SampDefinedDomains[1].UnmodifiedFixed.DomainKeyAuthType;
        DomainFixedAttributes->DomainKeyFlags =
                   SampDefinedDomains[1].UnmodifiedFixed.DomainKeyFlags|
                     SAMP_DOMAIN_KEY_AUTH_FLAG_UPGRADE ;

        RtlCopyMemory(
          &DomainFixedAttributes->DomainKeyInformation,
          &SampDefinedDomains[1].UnmodifiedFixed.DomainKeyInformation,
          SAMP_DOMAIN_KEY_INFO_LENGTH
          );
    }

    DomainAttributeLength = SampDwordAlignUlong(RtlLengthSid( DomainSid ) ) +
                                ( SAMP_DOMAIN_VARIABLE_ATTRIBUTES *
                                sizeof( SAMP_VARIABLE_LENGTH_ATTRIBUTE ) ) +
                                SampDwordAlignUlong(SampProtection[ProtectionIndex].Length);

    DomainVariableAttributeArrayStart = (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)
                                   RtlAllocateHeap(
                                       RtlProcessHeap(), 0,
                                       DomainAttributeLength
                                       );

    if ( DomainVariableAttributeArrayStart == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    SUCCESS_ASSERT(Status, "  Failed to create domain variable attributes\n");

    DomainVariableAttributeArray = DomainVariableAttributeArrayStart;

    DomainVariableAttributeArray->Offset = 0;
    DomainVariableAttributeArray->Length =
        SampProtection[ProtectionIndex].Length;
    DomainVariableAttributeArray->Qualifier = SAMP_REVISION;

    DomainVariableAttributeArray++;

    DomainVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length);
    DomainVariableAttributeArray->Length =
        RtlLengthSid( DomainSid );
    DomainVariableAttributeArray->Qualifier = 0;

    DomainVariableAttributeArray++;

    DomainVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(RtlLengthSid( DomainSid ));
    DomainVariableAttributeArray->Length = 0;
    DomainVariableAttributeArray->Qualifier = 0;

    DomainVariableAttributeArray++;

    DomainVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(RtlLengthSid( DomainSid ));
    DomainVariableAttributeArray->Length = 0;
    DomainVariableAttributeArray->Qualifier = 0;

    DomainVariableData = (PVOID)( (PUCHAR)(DomainVariableAttributeArray) +
                         sizeof( SAMP_VARIABLE_LENGTH_ATTRIBUTE ) );

    RtlCopyMemory(
        DomainVariableData,
        SampProtection[ProtectionIndex].Descriptor,
        SampProtection[ProtectionIndex].Length
        );

    RtlCopyMemory(
        (PVOID)((PUCHAR)(DomainVariableData) +
            SampDwordAlignUlong(SampProtection[ProtectionIndex].Length)),
        DomainSid,
        RtlLengthSid( DomainSid )
        );

    //
    // Now write out the attributes via the RXACT.
    //

    SampDumpRXact(SampRXactContext,
                  RtlRXactOperationSetValue,
                  &KeyNameU,
                  INVALID_HANDLE_VALUE,
                  &SampFixedAttributeName,
                  REG_BINARY,
                  (PVOID)DomainFixedAttributes,
                  sizeof( SAMP_V1_0A_FIXED_LENGTH_DOMAIN ),
                  FIXED_LENGTH_DOMAIN_FLAG);

    Status = RtlAddAttributeActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 INVALID_HANDLE_VALUE,
                 &SampFixedAttributeName,
                 REG_BINARY,
                 (PVOID)DomainFixedAttributes,
                 sizeof( SAMP_V1_0A_FIXED_LENGTH_DOMAIN )
                 );

    SUCCESS_ASSERT(Status, "  Failed to write out domain fixed attributes\n" );
    RtlFreeHeap( RtlProcessHeap(), 0, DomainFixedAttributes );

    SampDumpRXact(SampRXactContext,
                  RtlRXactOperationSetValue,
                  &KeyNameU,
                  INVALID_HANDLE_VALUE,
                  &SampVariableAttributeName,
                  REG_BINARY,
                  (PUCHAR)DomainVariableAttributeArrayStart,
                  sizeof( SAMP_V1_0A_FIXED_LENGTH_DOMAIN ),
                  VARIABLE_LENGTH_ATTRIBUTE_FLAG);

    Status = RtlAddAttributeActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 INVALID_HANDLE_VALUE,
                 &SampVariableAttributeName,
                 REG_BINARY,
                 (PVOID)DomainVariableAttributeArrayStart,
                 DomainAttributeLength
                 );

    RtlFreeHeap( RtlProcessHeap(), 0, DomainVariableAttributeArrayStart );
    SUCCESS_ASSERT(Status, "  Failed to write out domain variable attributes\n" );

    //
    // Create SAM\Domains\(DomainName)\Users
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Users" );
    SUCCESS_ASSERT(Status, "  Failed to append to unicode: \\Users\n" );

    Status = RtlAddActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 UserCount,
                 NULL,
                 0
                 );

    SUCCESS_ASSERT(Status, "  Failed to add Users key to log\n");

    //
    // Create SAM\Domains\(DomainName)\Users\Names
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Users\\Names" );
    SUCCESS_ASSERT(Status, "  Failed to append to unicode: \\Users\\Names\n" );
    Status = RtlAddActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 0,
                 NULL,
                 0
                 );
    SUCCESS_ASSERT(Status, "  Failed to add Users/Names key to log\n");

    //
    // Create SAM\Domains\(DomainName)\Groups
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Groups" );
    SUCCESS_ASSERT(Status, "  Failed to append Groups key name to unicode\n" );
    Status = RtlAddActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 GroupCount,
                 NULL,
                 0
                 );
    SUCCESS_ASSERT(Status, "  Failed to add Groups key to log\n");

    //
    // Create SAM\Domains\(DomainName)\Groups\Names
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Groups\\Names" );
    SUCCESS_ASSERT(Status, "  Failed to append Groups key name to unicode\n" );
    Status = RtlAddActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 0,
                 NULL,
                 0
                 );
    SUCCESS_ASSERT(Status, "  Failed to add Groups key to log\n");

    //
    // Create SAM\Domains\(DomainName)\Aliases
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Aliases" );
    SUCCESS_ASSERT(Status, "  Failed to append Aliases key name to unicode\n" );
    Status = RtlAddActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 AliasCount,
                 NULL,
                 0
                 );
    SUCCESS_ASSERT(Status, "  Failed to add aliases key to log\n");

    //
    // Create SAM\Domains\(DomainName)\Aliases\Names
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Aliases\\Names" );
    SUCCESS_ASSERT(Status, "  Failed to append Aliases key name to unicode\n" );
    Status = RtlAddActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 0,
                 NULL,
                 0
                 );
    SUCCESS_ASSERT(Status, "  Failed to add Aliases\\Names key to log\n");

    //
    // Create SAM\Domains\(DomainName)\Aliases\Members
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Aliases\\Members" );
    SUCCESS_ASSERT(Status, "  Failed to append Aliases\\Members key name to unicode\n" );
    Status = RtlAddActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 0,             // Domain Count
                 NULL,
                 0
                 );
    SUCCESS_ASSERT(Status, "  Failed to add Aliases\\Members key to log\n");

    //
    // Commit these additions...
    //

    Status = RtlApplyRXactNoFlush( SamRXactContext );
    SUCCESS_ASSERT(Status, "  Failed to commit domain initialization.\n");

    return Status;
}


NTSTATUS
CreateAlias(
    IN PUNICODE_STRING AccountNameU,
    IN PUNICODE_STRING AccountCommentU,
    IN BOOLEAN SpecialAccount,
    IN ULONG Rid,
    IN ULONG ProtectionIndex
    )

/*++

Routine Description:

    This routine adds the keys necessary to create an alias.  It also applies
    the appropriate protection to the alias.

Arguments:

    AccountNameU - The Unicode name of the Alias.

    AccountCommentU - A Unicode comment to put in the object's variable data.

    SpecialAccount - A boolean indicating whether or not the account
        is special.  Special accounts are marked as such and can not
        be deleted.

    Rid - The RID of the account.


    Admin - Indicates whether the account is in the Administrators alias
        or not. TRUE means it is, FALSE means it isn't.

Return Value:

    TBS

--*/

{
    PSAMP_V1_FIXED_LENGTH_ALIAS AliasFixedAttributes;
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE AliasVariableAttributeArray;
    PVOID AliasVariableData;
    PSID Sid1 = NULL, Sid2 = NULL;
    PSID AliasMembers = NULL;
    ULONG MemberCount, TotalLength, AliasAttributeLength;
    UNICODE_STRING AliasNameU, AliasCommentU;

    SAMTRACE("CreateAlias");

    AliasNameU = *AccountNameU;
    AliasCommentU = *AccountCommentU;

    //
    // Set the account specific RID in the DACL's if necessary
    //

    if ( SampProtection[ProtectionIndex].RidReplacementRequired == TRUE ) {

        (*SampProtection[ProtectionIndex].RidToReplace) = Rid;
    }

    //
    // Use a transaction.
    //

    Status = RtlStartRXact( SamRXactContext );
    SUCCESS_ASSERT(Status, "  Failed to start Alias addition transaction\n");

    //
    // Add Aliases\Names\(AccountName) [ Rid, ]
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Aliases\\Names\\" );
    SUCCESS_ASSERT(Status, "  Failed to append \\aliases\\names to keyname\n");
    Status = RtlAppendUnicodeStringToString( &KeyNameU, &AliasNameU);
    SUCCESS_ASSERT(Status, "  Failed to append Alias account name to\n");
    Status = RtlAddActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 Rid,
                 NULL,
                 0
                 );
    SUCCESS_ASSERT(Status, "  Failed to add Aliases\\Names\\(AliasName) to log\n");


    //
    // Set the Members attribute.  We know which accounts are supposed
    // to be members of which aliases, so we'll build the memberships in
    // automatically.
    //
    // Each domain has a list of SIDs that are members of its aliases.
    // We'll update these values at the same time that we set the alias
    // members by calling UpdateAliasXReference().  Currently, that only
    // happens in the builtin domain, where things look like this:
    //
    //    BuiltinDomainSid
    //        AdminUserRid  - Admins alias (WinNt + primary domain)
    //        UserUserRid   - Users alias (WinNt + developer setup),
    //                        Power users alias (WinNt + developer setup)
    //    AccountDomainSid
    //        AdminUserRid  - Admins alias (always)
    //        GuestUserRid  - Guests alias (always)
    //        UserGroupRid  - Users alias, (always)
    //                        Power users alias (WinNt + developer setup)
    //        AdminGroupRid - Admins alias (LanManNt only)
    //

    MemberCount = 0;
    TotalLength = 0;

    switch ( Rid ) {

        case DOMAIN_ALIAS_RID_ADMINS: {

            MemberCount = 1;

            Sid1 = BuildAccountSid( DomainAccount, DOMAIN_USER_RID_ADMIN );
            if ( Sid1 == NULL ) {
                SUCCESS_ASSERT( STATUS_INSUFFICIENT_RESOURCES, "  Could not allocate Sid\n" );
            }

            if ( SampBldProductType == NtProductLanManNt ) {

                MemberCount = 2;

                Sid2 = BuildAccountSid( DomainAccount, DOMAIN_GROUP_RID_ADMINS );
                if ( Sid2 == NULL ) {
                    SUCCESS_ASSERT( STATUS_INSUFFICIENT_RESOURCES, "  Could not allocate Sid\n" );
                }
            }

            if ( ( SampBldProductType != NtProductLanManNt ) &&
                 ( SampBldPrimaryDomain != NULL ) ) {

                MemberCount = 2;

                Sid2 = BuildPrimaryDomainSid( DOMAIN_GROUP_RID_ADMINS );
                if ( Sid2 == NULL ) {
                    SUCCESS_ASSERT( STATUS_INSUFFICIENT_RESOURCES, " Could not allocate Sid\n" );
                }
            }

            break;
        }

        case DOMAIN_ALIAS_RID_USERS: {

            MemberCount = 0;

            if ( (SampBldProductType == NtProductWinNt)
               || (SampBldProductType == NtProductServer) ) {

                if ( SampBldPrimaryDomain != NULL ) {

                    MemberCount = 1;
                    Sid1 = BuildPrimaryDomainSid( DOMAIN_GROUP_RID_USERS );

                    if ( Sid1 == NULL ) {

                        SUCCESS_ASSERT( STATUS_INSUFFICIENT_RESOURCES, " Could not allocate Sid\n" );
                    }
                }

            } else {

                //
                //
                if (SampBldProductType == NtProductLanManNt ) {

                    //
                    // NTAS systems have the USERS global group in
                    // the USERS alias.
                    //

                    MemberCount = 1;
                    Sid1 = BuildAccountSid(
                               DomainAccount,
                               DOMAIN_GROUP_RID_USERS
                               );

                    if ( Sid1 == NULL ) {
                        SUCCESS_ASSERT( STATUS_INSUFFICIENT_RESOURCES, " Could not allocate Sid\n" );
                    }
                } else {

                    //
                    // WinNT systems have the ADMINISTRATOR user account
                    // in the USERS alias.  The None group is NOT in this
                    // alias because even guests are in the None group.
                    //

                    MemberCount = 1;
                    Sid1 = BuildAccountSid(
                               DomainAccount,
                               DOMAIN_USER_RID_ADMIN
                               );

                    if ( Sid1 == NULL ) {
                        SUCCESS_ASSERT( STATUS_INSUFFICIENT_RESOURCES, " Could not allocate Sid\n" );
                    }
                }
            }

            break;
        }

        case DOMAIN_ALIAS_RID_GUESTS: {


            if ( (SampBldProductType == NtProductWinNt)
                || (SampBldProductType == NtProductServer) ) {

                //
                // WinNT system - make our GUEST user account a member of
                //                the GUESTS alias.
                //

                MemberCount = 1;
                Sid1 = BuildAccountSid( DomainAccount, DOMAIN_USER_RID_GUEST );
                if (Sid1 == NULL ) {
                    SUCCESS_ASSERT(STATUS_INSUFFICIENT_RESOURCES, "Could not allocate Sid\n");
                }


                //
                // If we are in a primary domain, then add that domain's
                // GUESTS global group to the alias as well.
                //

                if ( SampBldPrimaryDomain != NULL ) {

                    MemberCount += 1;
                    Sid2 = BuildPrimaryDomainSid( DOMAIN_GROUP_RID_GUESTS );
                    if ( Sid2 == NULL ) {
                        SUCCESS_ASSERT( STATUS_INSUFFICIENT_RESOURCES, " Could not allocate Sid\n" );
                    }
                }
            } else {

                //
                // NTAS System - Just make the GUESTS global group
                //               a member of the GUESTS alias.
                //

                MemberCount = 1;
                Sid1 = BuildPrimaryDomainSid( DOMAIN_GROUP_RID_GUESTS );
                if ( Sid1 == NULL ) {
                    SUCCESS_ASSERT( STATUS_INSUFFICIENT_RESOURCES, " Could not allocate Sid\n" );
                }
            }


            break;
        }


        case DOMAIN_ALIAS_RID_POWER_USERS:
        case DOMAIN_ALIAS_RID_ACCOUNT_OPS:
        case DOMAIN_ALIAS_RID_SYSTEM_OPS:
        case DOMAIN_ALIAS_RID_PRINT_OPS:
        case DOMAIN_ALIAS_RID_BACKUP_OPS:
        case DOMAIN_ALIAS_RID_REPLICATOR: {

            break;
        }

        default: {

            SUCCESS_ASSERT(STATUS_UNSUCCESSFUL, "  Bad Alias RID\n");
            break;
        }
    };

    if ( MemberCount > 0 ) {

        TotalLength = RtlLengthSid( Sid1 );
        if ( MemberCount == 2 ) {

            TotalLength += RtlLengthSid( Sid2 );
        }

        AliasMembers = RtlAllocateHeap( RtlProcessHeap(), 0, TotalLength );
        if ( AliasMembers == NULL ) {
            SUCCESS_ASSERT( STATUS_INSUFFICIENT_RESOURCES, "  Could not allocate AliasMembers\n" );
        }

        Status = RtlCopySid( RtlLengthSid( Sid1 ), AliasMembers, Sid1 );
        SUCCESS_ASSERT( Status, "  Couldn't copy Sid1\n" );

        Status = UpdateAliasXReference( Rid, Sid1 );
        SUCCESS_ASSERT( Status, "  Couldn't update alias xref\n" );

        if ( MemberCount == 2 ) {

            Status = RtlCopySid(
                         RtlLengthSid( Sid2 ),
                         (PSID)((PUCHAR)AliasMembers + RtlLengthSid( Sid1 ) ),
                         Sid2 );
            SUCCESS_ASSERT( Status, "  Couldn't copy Sid2\n" );

            Status = UpdateAliasXReference( Rid, Sid2 );
            RtlFreeHeap( RtlProcessHeap(), 0, Sid2 );
            SUCCESS_ASSERT( Status, "  Couldn't update alias xref\n" );
        }

        RtlFreeHeap( RtlProcessHeap(), 0, Sid1 );
    }


    //
    // Set the alias's fixed and variable attributes
    //

    AliasAttributeLength = sizeof( SAMP_V1_FIXED_LENGTH_ALIAS ) +
                                ( SAMP_ALIAS_VARIABLE_ATTRIBUTES *
                                sizeof( SAMP_VARIABLE_LENGTH_ATTRIBUTE ) ) +
                                SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
                                SampDwordAlignUlong(AccountNameU->Length) +
                                SampDwordAlignUlong(AccountCommentU->Length) +
                                TotalLength;

    AliasFixedAttributes = (PSAMP_V1_FIXED_LENGTH_ALIAS)RtlAllocateHeap(
                                RtlProcessHeap(), 0,
                                AliasAttributeLength
                                );

    if ( AliasFixedAttributes == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    SUCCESS_ASSERT(Status, "  Failed to create alias attributes\n");

    AliasFixedAttributes->RelativeId   = Rid;

    AliasVariableAttributeArray = (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)
                                   ((PUCHAR)(AliasFixedAttributes) +
                                   sizeof( SAMP_V1_FIXED_LENGTH_ALIAS ) );

    AliasVariableAttributeArray->Offset = 0;
    AliasVariableAttributeArray->Length =
        SampProtection[ProtectionIndex].Length;
    AliasVariableAttributeArray->Qualifier = SAMP_REVISION;

    AliasVariableAttributeArray++;

    AliasVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length);
    AliasVariableAttributeArray->Length = AliasNameU.Length;
    AliasVariableAttributeArray->Qualifier = 0;

    AliasVariableAttributeArray++;

    AliasVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(AccountNameU->Length);
    AliasVariableAttributeArray->Length = AliasCommentU.Length;
    AliasVariableAttributeArray->Qualifier = 0;

    AliasVariableAttributeArray++;

    AliasVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(AliasNameU.Length) +
        SampDwordAlignUlong(AliasCommentU.Length);
    AliasVariableAttributeArray->Length = TotalLength;
    AliasVariableAttributeArray->Qualifier = MemberCount;

    AliasVariableData = (PVOID)( (PUCHAR)(AliasVariableAttributeArray) +
                         sizeof( SAMP_VARIABLE_LENGTH_ATTRIBUTE ) );

    RtlCopyMemory(
        AliasVariableData,
        SampProtection[ProtectionIndex].Descriptor,
        SampProtection[ProtectionIndex].Length
        );

    RtlCopyMemory(
        (PVOID)((PUCHAR)(AliasVariableData) +
            SampDwordAlignUlong(SampProtection[ProtectionIndex].Length)),
        AccountNameU->Buffer,
        AccountNameU->Length
        );

    RtlCopyMemory(
        (PVOID)((PUCHAR)(AliasVariableData) +
            SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
            SampDwordAlignUlong(AliasNameU.Length)),
        AccountCommentU->Buffer,
        AccountCommentU->Length
        );

    RtlCopyMemory(
        (PVOID)((PUCHAR)(AliasVariableData) +
            SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
            SampDwordAlignUlong(AliasNameU.Length) +
            SampDwordAlignUlong(AliasCommentU.Length)),
        AliasMembers,
        TotalLength
        );

    if ( AliasMembers != NULL ) {

        RtlFreeHeap( RtlProcessHeap(), 0, AliasMembers );
    }

    //
    // Create Aliases\(AliasRid) [Revision,]  key
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Aliases\\" );
    SUCCESS_ASSERT(Status, "  Failed to append \\aliases\\ to keyname\n");

    //
    // Convert the Rid to a Unicode String with leading zero's
    //

    Status = SampRtlConvertUlongToUnicodeString(
                 Rid,
                 16,
                 8,
                 FALSE,
                 &KeyNameU
                 );

    SUCCESS_ASSERT(Status, "  CreateAlias' SampRtlConvertUlongToUnicodeString failed\n");

    //
    // Now write out the attributes via the RXACT.
    //

    SampDumpRXact(SampRXactContext,
                  RtlRXactOperationSetValue,
                  &KeyNameU,
                  INVALID_HANDLE_VALUE,
                  &SampCombinedAttributeName,
                  REG_BINARY,
                  (PVOID)AliasFixedAttributes,
                  AliasAttributeLength,
                  FIXED_LENGTH_ALIAS_FLAG);

    Status = RtlAddAttributeActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 INVALID_HANDLE_VALUE,
                 &SampCombinedAttributeName,
                 REG_BINARY,
                 (PVOID)AliasFixedAttributes,
                 AliasAttributeLength
                 );

    SUCCESS_ASSERT(Status, "  Failed to write out alias attributes\n" );

    RtlFreeHeap( RtlProcessHeap(), 0, AliasFixedAttributes );

    //
    // Commit these additions...
    //

    Status = RtlApplyRXactNoFlush( SamRXactContext );
    SUCCESS_ASSERT(Status, "  Failed to commit Alias addition.\n");

    return Status;
    DBG_UNREFERENCED_PARAMETER(SpecialAccount);

}


NTSTATUS
CreateGroup(
    IN PUNICODE_STRING AccountNameU,
    IN PUNICODE_STRING AccountCommentU,
    IN BOOLEAN SpecialAccount,
    IN ULONG Rid,
    IN BOOLEAN Admin
    )

/*++

Routine Description:

    This routine adds the keys necessary to create a group.  It also applies
    the appropriate protection to the group.

Arguments:

    AccountNameU - The Unicode name of the group.

    AccountCommentU - A Unicode comment to put in the object's variable data.

    SpecialAccount - A boolean indicating whether or not the account
        is special.  Special accounts are marked as such and can not
        be deleted.

    Rid - The RID of the account.

    Admin - Indicates whether the account is in the Administrators alias
        or not. TRUE means it is, FALSE means it isn't.

Return Value:

    TBS

--*/

{
    PSAMP_V1_0A_FIXED_LENGTH_GROUP GroupFixedAttributes;
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE GroupVariableAttributeArray;
    PVOID GroupVariableData;

    ULONG Attributes, ProtectionIndex, GroupCount, GroupAttributeLength;
    ULONG GroupMembers[2];

    UNICODE_STRING GroupNameU, GroupCommentU;

    SAMTRACE("CreateGroup");

    GroupNameU = *AccountNameU;
    GroupCommentU = *AccountCommentU;

    Attributes = (SE_GROUP_MANDATORY          |
                  SE_GROUP_ENABLED_BY_DEFAULT |
                  SE_GROUP_ENABLED);

    //
    // Set the correct protection.
    //

    if (Admin == TRUE) {

        ProtectionIndex = SAMP_PROT_ADMIN_GROUP;

    } else {

        ProtectionIndex = SAMP_PROT_NORMAL_GROUP;
    }

    //
    // Set the account specific RID in the DACL's if necessary
    //

    if ( SampProtection[ProtectionIndex].RidReplacementRequired == TRUE ) {

        (*SampProtection[ProtectionIndex].RidToReplace) = Rid;
    }

    //
    // Use a transaction
    //

    Status = RtlStartRXact( SamRXactContext );
    SUCCESS_ASSERT(Status, "  Failed to start group addition transaction\n");

    //
    // Add Groups\Names\(GroupName) [ Rid, ]
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Groups\\Names\\" );
    SUCCESS_ASSERT(Status, "  Failed to append \\Groups\\Names\n");
    Status = RtlAppendUnicodeStringToString( &KeyNameU, AccountNameU);
    SUCCESS_ASSERT(Status, "  Failed to append AccountName\n");

    Status = RtlAddActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 Rid,
                 NULL,
                 0
                 );

    SUCCESS_ASSERT(Status, "  Failed to add Groups\\Names\\(GroupName) to log\n");

    //
    // Create Groups\(GroupRid) [Revision,]  key
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Groups\\" );
    SUCCESS_ASSERT(Status, "  Failed to append \\Groups\\\n");

    Status = SampRtlConvertUlongToUnicodeString(
                 Rid,
                 16,
                 8,
                 FALSE,
                 &KeyNameU
                 );

    SUCCESS_ASSERT(Status, "CreateGroup:  Failed to append Rid Name\n");

    //
    // Set the Members attribute.  The Admin and Guest users are always
    // members of the Users group.  If there is an Admins group, then the
    // Admin user is a member of it.
    //

    GroupCount = 0;
    if ( (Rid == DOMAIN_GROUP_RID_USERS) ||
         (Rid == DOMAIN_GROUP_RID_ADMINS) ) {

        GroupMembers[GroupCount] = DOMAIN_USER_RID_ADMIN;
        GroupCount++;

    }

    //
    // Guests are only members of the Guest group on NTAS systems.
    // On WinNT systems they are members of NONE (which is the sam
    // as USERS
    //

    if ( (Rid == DOMAIN_GROUP_RID_GUESTS)  &&
         (SampBldProductType == NtProductLanManNt) ) {

        GroupMembers[GroupCount] = DOMAIN_USER_RID_GUEST;
        GroupCount++;
    }

    if ( (Rid == DOMAIN_GROUP_RID_USERS)  &&
         ((SampBldProductType == NtProductWinNt)
           || (SampBldProductType == NtProductServer)) ) {

        GroupMembers[GroupCount] = DOMAIN_USER_RID_GUEST;
        GroupCount++;
    }

    //
    // Set the group's fixed and variable attributes
    //

    GroupAttributeLength = sizeof( SAMP_V1_0A_FIXED_LENGTH_GROUP ) +
                                ( SAMP_GROUP_VARIABLE_ATTRIBUTES *
                                sizeof( SAMP_VARIABLE_LENGTH_ATTRIBUTE ) ) +
                                SampDwordAlignUlong(SampProtection[ProtectionIndex].Length)
                                + SampDwordAlignUlong(GroupNameU.Length) +
                                SampDwordAlignUlong(GroupCommentU.Length) +
                                ( GroupCount * sizeof( ULONG ) );

    GroupFixedAttributes = (PSAMP_V1_0A_FIXED_LENGTH_GROUP)RtlAllocateHeap(
                                RtlProcessHeap(), 0,
                                GroupAttributeLength
                                );

    if ( GroupFixedAttributes == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    SUCCESS_ASSERT(Status, "  Failed to create group attributes\n");

    GroupFixedAttributes->RelativeId   = Rid;
    GroupFixedAttributes->Attributes   = Attributes;
    GroupFixedAttributes->AdminCount   = Admin ? 1 : 0;
    GroupFixedAttributes->OperatorCount = 0;
    GroupFixedAttributes->Revision     = SAMP_REVISION;

    GroupVariableAttributeArray = (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)
                                   ((PUCHAR)(GroupFixedAttributes) +
                                   sizeof( SAMP_V1_0A_FIXED_LENGTH_GROUP ) );

    GroupVariableAttributeArray->Offset = 0;
    GroupVariableAttributeArray->Length =
        SampProtection[ProtectionIndex].Length;
    GroupVariableAttributeArray->Qualifier = SAMP_REVISION;

    GroupVariableAttributeArray++;

    GroupVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length);
    GroupVariableAttributeArray->Length = GroupNameU.Length;
    GroupVariableAttributeArray->Qualifier = 0;

    GroupVariableAttributeArray++;

    GroupVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(GroupNameU.Length);
    GroupVariableAttributeArray->Length = GroupCommentU.Length;
    GroupVariableAttributeArray->Qualifier = 0;

    GroupVariableAttributeArray++;

    GroupVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(GroupNameU.Length) +
        SampDwordAlignUlong(GroupCommentU.Length);
    GroupVariableAttributeArray->Length = GroupCount * sizeof( ULONG );
    GroupVariableAttributeArray->Qualifier = GroupCount;

    GroupVariableData = (PVOID)( (PUCHAR)(GroupVariableAttributeArray) +
                         sizeof( SAMP_VARIABLE_LENGTH_ATTRIBUTE ) );

    RtlCopyMemory(
        GroupVariableData,
        SampProtection[ProtectionIndex].Descriptor,
        SampProtection[ProtectionIndex].Length
        );

    RtlCopyMemory(
        (PVOID)((PUCHAR)(GroupVariableData) +
            SampDwordAlignUlong(SampProtection[ProtectionIndex].Length)),
        GroupNameU.Buffer,
        GroupNameU.Length
        );

    RtlCopyMemory(
        (PVOID)((PUCHAR)(GroupVariableData) +
            SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
            SampDwordAlignUlong(GroupNameU.Length)),
        GroupCommentU.Buffer,
        GroupCommentU.Length
        );

    RtlCopyMemory(
        (PVOID)((PUCHAR)(GroupVariableData) +
            SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
            SampDwordAlignUlong(GroupNameU.Length) +
            SampDwordAlignUlong(GroupCommentU.Length)),
        GroupMembers,
        GroupCount * sizeof( ULONG )
        );

    //
    // Now write out the attributes via the RXACT.
    //

    SampDumpRXact(SampRXactContext,
                  RtlRXactOperationSetValue,
                  &KeyNameU,
                  INVALID_HANDLE_VALUE,
                  &SampCombinedAttributeName,
                  REG_BINARY,
                  (PVOID)GroupFixedAttributes,
                  GroupAttributeLength,
                  FIXED_LENGTH_GROUP_FLAG);

    Status = RtlAddAttributeActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 INVALID_HANDLE_VALUE,
                 &SampCombinedAttributeName,
                 REG_BINARY,
                 (PVOID)GroupFixedAttributes,
                 GroupAttributeLength
                 );
    SUCCESS_ASSERT(Status, "  Failed to write out group attributes\n" );

    RtlFreeHeap( RtlProcessHeap(), 0, GroupFixedAttributes );

    //
    // Commit these additions...
    //

    Status = RtlApplyRXactNoFlush( SamRXactContext );
    SUCCESS_ASSERT(Status, "  Failed to commit group addition.\n");

    return Status;
    DBG_UNREFERENCED_PARAMETER(SpecialAccount);
}


NTSTATUS
CreateUser(
    IN PUNICODE_STRING AccountNameU,
    IN PUNICODE_STRING AccountCommentU,
    IN BOOLEAN SpecialAccount,
    IN ULONG UserRid,
    IN ULONG PrimaryGroup,
    IN BOOLEAN Admin,
    IN ULONG  UserControl,
    IN ULONG ProtectionIndex
    )

/*++


Routine Description:

    This routine adds keys for a single user.
    This routine adds the keys necessary to create a user.  It also applies
    the appropriate protection to the user (protection differs for some
    standard users).


Arguments:

    AccountNameU - The Unicode name of the user.

    AccountCommentU - A Unicode comment to put in the object's variable data.

    SpecialAccount - A boolean indicating whether or not the account
        is special.  Special accounts are marked as such and can not
        be deleted.

    UserRid - The RID of the user account.

    PrimaryGroup - The RID of the account's primary group.  The user
        does not have to be a member of the group.  In fact, it doesn't
        have to be a group.  In fact, no checking is done to see if it
        is even a valid account.

    Admin - Indicates whether the account is in the Administrators alias
        or not. TRUE means it is, FALSE means it isn't.

    ProtectionIndex - Indicates which security descriptor to use to protect
        this object.


Return Value:

    TBS

--*/

{
    PSAMP_V1_0A_FIXED_LENGTH_USER UserFixedAttributes;
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE UserVariableAttributeArray;
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE UserVariableAttributeArrayStart;
    PVOID UserVariableData;
    GROUP_MEMBERSHIP GroupMembership[2];

    WCHAR RidNameBuffer[9], GroupIndexNameBuffer[9];
    ULONG GroupCount, UserAttributeLength;

    // SAM BUG 42367 FIX - ChrisMay 7/1/96.

    BOOLEAN DomainAdminMember = FALSE;

    UNICODE_STRING UserNameU, UserCommentU;

    SAMTRACE("CreateUser");

    UserNameU = *AccountNameU;
    UserCommentU = *AccountCommentU;


    //
    // Set the account specific RID in the DACL's if necessary
    //

    if ( SampProtection[ProtectionIndex].RidReplacementRequired == TRUE ) {

        (*SampProtection[ProtectionIndex].RidToReplace) = UserRid;
    }

    //
    // Use a transaction.
    //

    Status = RtlStartRXact( SamRXactContext );
    SUCCESS_ASSERT(Status, "  Failed to start user addition transaction\n");

    RidNameBuffer[8] = 0;
    GroupIndexNameBuffer[8] = 0;

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Users\\Names\\" );
    SUCCESS_ASSERT(Status, "  Failed to append \\Users\\Names\\\n");
    Status = RtlAppendUnicodeStringToString( &KeyNameU, &UserNameU);
    SUCCESS_ASSERT(Status, "  Failed to append User Account Name\n");
    Status = RtlAddActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 UserRid,
                 NULL,
                 0
                 );
    SUCCESS_ASSERT(Status, "  Failed to add Users\\Names\\(Name) to log\n");

    //
    // Create Users\(UserRid)  key
    // (KeyValueType is revision, KeyValue is SecurityDescriptor)
    //

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Users\\" );
    SUCCESS_ASSERT(Status, "  Failed to append \\Users\\\n");

    Status = SampRtlConvertUlongToUnicodeString(
                 UserRid,
                 16,
                 8,
                 FALSE,
                 &KeyNameU
                 );

    SUCCESS_ASSERT(Status, "  CreateUser: Failed to append UserRid Name\n");

    //
    // Set the Groups attribute.
    // Everybody except GUEST is a member of the Users group.
    // On WindowsNT systems (as opposed to NTAS systems) even GUEST
    // is a member of the Users group.
    // On LanManNt systems, the Admin is a member of the Admins group.
    //

    GroupCount = 0;

    if ( (UserRid != DOMAIN_USER_RID_GUEST) ||
         (SampBldProductType != NtProductLanManNt)      ) {

        GroupMembership[GroupCount].RelativeId = DOMAIN_GROUP_RID_USERS;
        GroupMembership[GroupCount].Attributes = SE_GROUP_MANDATORY          |
                                                 SE_GROUP_ENABLED_BY_DEFAULT |
                                                 SE_GROUP_ENABLED;
        GroupCount++;
    }

    if ( (UserRid == DOMAIN_USER_RID_GUEST) &&
         (SampBldProductType == NtProductLanManNt)      ) {

        GroupMembership[GroupCount].RelativeId = DOMAIN_GROUP_RID_GUESTS;
        GroupMembership[GroupCount].Attributes = SE_GROUP_MANDATORY          |
                                                 SE_GROUP_ENABLED_BY_DEFAULT |
                                                 SE_GROUP_ENABLED;
        GroupCount++;
    }


    if ( ( UserRid == DOMAIN_USER_RID_ADMIN ) &&
        ( SampBldProductType == NtProductLanManNt ) ) {

        GroupMembership[GroupCount].RelativeId = DOMAIN_GROUP_RID_ADMINS;
        GroupMembership[GroupCount].Attributes = SE_GROUP_MANDATORY          |
                                                 SE_GROUP_ENABLED_BY_DEFAULT |
                                                 SE_GROUP_ENABLED;
        GroupCount++;

        // SAM BUG 42367 FIX - ChrisMay 7/1/96.

        DomainAdminMember = TRUE;
    }

    //
    // Set the user's fixed and variable attributes
    //

    UserFixedAttributes = (PSAMP_V1_0A_FIXED_LENGTH_USER)RtlAllocateHeap(
                                RtlProcessHeap(), 0,
                                sizeof( SAMP_V1_0A_FIXED_LENGTH_USER )
                                );

    if ( UserFixedAttributes == NULL ) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    SUCCESS_ASSERT(Status, "  Failed to create user fixed attributes\n");

    UserFixedAttributes->Revision            = SAMP_REVISION;

    UserFixedAttributes->CountryCode         = 0;
    UserFixedAttributes->CodePage            = 0;
    UserFixedAttributes->BadPasswordCount    = 0;
    UserFixedAttributes->LogonCount          = 0;
    UserFixedAttributes->OperatorCount       = 0;
    UserFixedAttributes->Unused1             = 0;
    UserFixedAttributes->Unused2             = 0;

    if ( Admin ) {

        // SAM BUG 42367 FIX - ChrisMay 7/1/96.

        // UserFixedAttributes->AdminCount      = 1;

        // If the user is an admin and a member of Domain Admins, set the
        // count to two.

        if (DomainAdminMember)
        {
            UserFixedAttributes->AdminCount  = 2;
        }
        else
        {
            UserFixedAttributes->AdminCount  = 1;
        }

    } else {

        UserFixedAttributes->AdminCount      = 0;
    }

    UserFixedAttributes->UserAccountControl  = UserControl;
    UserFixedAttributes->UserId              = UserRid;
    UserFixedAttributes->PrimaryGroupId      = PrimaryGroup;
    UserFixedAttributes->LastLogon           = SampHasNeverTime;
    UserFixedAttributes->LastLogoff          = SampHasNeverTime;
    UserFixedAttributes->PasswordLastSet     = SampHasNeverTime;
    UserFixedAttributes->AccountExpires      = SampWillNeverTime;
    UserFixedAttributes->LastBadPasswordTime = SampHasNeverTime;


    UserAttributeLength =  SampDwordAlignUlong(UserNameU.Length) +
                                SampDwordAlignUlong(UserCommentU.Length) +
                                SampDwordAlignUlong( GroupCount *
                                sizeof( GROUP_MEMBERSHIP ) ) +
                                ( SAMP_USER_VARIABLE_ATTRIBUTES *
                                sizeof( SAMP_VARIABLE_LENGTH_ATTRIBUTE ) ) +
                                SampDwordAlignUlong(SampProtection[ProtectionIndex].Length);

    UserVariableAttributeArrayStart = (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)
                                   RtlAllocateHeap(
                                       RtlProcessHeap(), 0,
                                       UserAttributeLength
                                       );

    if ( UserVariableAttributeArrayStart == NULL ) {

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    SUCCESS_ASSERT(Status, "  Failed to create user variable attributes\n");

    UserVariableAttributeArray = UserVariableAttributeArrayStart;

    UserVariableAttributeArray->Offset = 0;
    UserVariableAttributeArray->Length =
        SampProtection[ProtectionIndex].Length;
    UserVariableAttributeArray->Qualifier = SAMP_REVISION;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length);
    UserVariableAttributeArray->Length = UserNameU.Length;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length);
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length);
    UserVariableAttributeArray->Length = UserCommentU.Length;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length);
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length);
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length);
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length);
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length);
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length);
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length);
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length);
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length);
    UserVariableAttributeArray->Length = GroupCount * sizeof( GROUP_MEMBERSHIP );
    UserVariableAttributeArray->Qualifier = GroupCount;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length) +
        SampDwordAlignUlong((GroupCount * sizeof( GROUP_MEMBERSHIP )));
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length) +
        SampDwordAlignUlong((GroupCount * sizeof( GROUP_MEMBERSHIP )));
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length) +
        SampDwordAlignUlong((GroupCount * sizeof( GROUP_MEMBERSHIP )));
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableAttributeArray++;

    UserVariableAttributeArray->Offset =
        SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
        SampDwordAlignUlong(UserNameU.Length) +
        SampDwordAlignUlong(UserCommentU.Length) +
        SampDwordAlignUlong((GroupCount * sizeof( GROUP_MEMBERSHIP )));
    UserVariableAttributeArray->Length = 0;
    UserVariableAttributeArray->Qualifier = 0;

    UserVariableData = (PVOID)( (PUCHAR)(UserVariableAttributeArray) +
                         sizeof( SAMP_VARIABLE_LENGTH_ATTRIBUTE ) );

    RtlCopyMemory(
        UserVariableData,
        SampProtection[ProtectionIndex].Descriptor,
        SampProtection[ProtectionIndex].Length
        );

    RtlCopyMemory(
        (PVOID)((PUCHAR)(UserVariableData) +
            SampDwordAlignUlong(SampProtection[ProtectionIndex].Length)),
        UserNameU.Buffer,
        UserNameU.Length
        );

    RtlCopyMemory(
        (PVOID)((PUCHAR)(UserVariableData) +
            SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
            SampDwordAlignUlong(UserNameU.Length)),
        UserCommentU.Buffer,
        UserCommentU.Length
        );

    RtlCopyMemory(
        (PVOID)((PUCHAR)(UserVariableData) +
            SampDwordAlignUlong(SampProtection[ProtectionIndex].Length) +
            SampDwordAlignUlong(UserNameU.Length) +
            SampDwordAlignUlong(UserCommentU.Length)),
        &GroupMembership,
        GroupCount * sizeof( GROUP_MEMBERSHIP )
        );

    //
    // Now write out the attributes via the RXACT.
    //

    SampDumpRXact(SampRXactContext,
                  RtlRXactOperationSetValue,
                  &KeyNameU,
                  INVALID_HANDLE_VALUE,
                  &SampFixedAttributeName,
                  REG_BINARY,
                  (PVOID)UserFixedAttributes,
                  sizeof( SAMP_V1_0A_FIXED_LENGTH_USER ),
                  FIXED_LENGTH_USER_FLAG);

    Status = RtlAddAttributeActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 INVALID_HANDLE_VALUE,
                 &SampFixedAttributeName,
                 REG_BINARY,
                 (PVOID)UserFixedAttributes,
                 sizeof( SAMP_V1_0A_FIXED_LENGTH_USER )
                 );
    SUCCESS_ASSERT(Status, "  Failed to write out user fixed attributes\n" );

    RtlFreeHeap( RtlProcessHeap(), 0, UserFixedAttributes );

    SampDumpRXact(SampRXactContext,
                  RtlRXactOperationSetValue,
                  &KeyNameU,
                  INVALID_HANDLE_VALUE,
                  &SampVariableAttributeName,
                  REG_BINARY,
                  (PVOID)UserVariableAttributeArrayStart,
                  UserAttributeLength,
                  VARIABLE_LENGTH_ATTRIBUTE_FLAG);

    Status = RtlAddAttributeActionToRXact(
                 SamRXactContext,
                 RtlRXactOperationSetValue,
                 &KeyNameU,
                 INVALID_HANDLE_VALUE,
                 &SampVariableAttributeName,
                 REG_BINARY,
                 (PVOID)UserVariableAttributeArrayStart,
                 UserAttributeLength
                 );
    SUCCESS_ASSERT(Status, "  Failed to write out user variable attributes\n" );

    RtlFreeHeap( RtlProcessHeap(), 0, UserVariableAttributeArrayStart );

    //
    // Commit these additions...
    //

    Status = RtlApplyRXactNoFlush( SamRXactContext );
    SUCCESS_ASSERT(Status, "  Failed to commit user addition.\n");

    return Status;

    DBG_UNREFERENCED_PARAMETER(SpecialAccount);
    DBG_UNREFERENCED_PARAMETER(UserControl);
}



PSID
BuildPrimaryDomainSid(
    ULONG Rid
    )
{
    NTSTATUS Status;
    PSID SourceDomainSid, NewSid;
    ULONG SidLength, SubAuthorityCount;

    SourceDomainSid = SampBldPrimaryDomain->Sid;

    SidLength = RtlLengthSid( SourceDomainSid ) + sizeof(ULONG);
    NewSid = RtlAllocateHeap( RtlProcessHeap(), 0, SidLength );
    if (NewSid != NULL) {

        Status = RtlCopySid (SidLength, NewSid, SourceDomainSid );
        ASSERT(NT_SUCCESS(Status));

        (*RtlSubAuthorityCountSid( NewSid )) += 1;
        SubAuthorityCount = (ULONG)(*RtlSubAuthorityCountSid( NewSid ));
        (*RtlSubAuthoritySid( NewSid, SubAuthorityCount-1)) = Rid;

    }


    return(NewSid);


}




PSID
BuildAccountSid(
    SAMP_DOMAIN_SELECTOR Domain,
    ULONG Rid
    )
{
    NTSTATUS Status;
    PSID SourceDomainSid, NewSid;
    ULONG SidLength, SubAuthorityCount;


    if (Domain == DomainBuiltin) {
        SourceDomainSid = SampBuiltinDomainSid;
    } else {
        SourceDomainSid = SampAccountDomainSid;
    }

    SidLength = RtlLengthSid( SourceDomainSid ) + sizeof(ULONG);
    NewSid = RtlAllocateHeap( RtlProcessHeap(), 0, SidLength );
    if (NewSid != NULL) {

        Status = RtlCopySid (SidLength, NewSid, SourceDomainSid );
        ASSERT(NT_SUCCESS(Status));

        (*RtlSubAuthorityCountSid( NewSid )) += 1;
        SubAuthorityCount = (ULONG)(*RtlSubAuthorityCountSid( NewSid ));
        (*RtlSubAuthoritySid( NewSid, SubAuthorityCount-1)) = Rid;

    }


    return(NewSid);


}



NTSTATUS
UpdateAliasXReference(
    IN ULONG AliasRid,
    IN PSID Sid
    )

/*++


Routine Description:

    This routine updates the set of alias member SIDs either by adding
    specified SID (if it isn't already an alias member) or incrementing
    its count (if it is already an alias member).


    The BUILTIN domain is updated.



Arguments:


    Sid - member Sid to update.




Return Value:

    TBS

--*/

{
    NTSTATUS                IgnoreStatus;

    HANDLE                  KeyHandle;

    SAMTRACE("UpdateAliasXReference");



    if (RtlSubAuthorityCountSid( Sid ) == 0) {
        return(STATUS_INVALID_SID);
    }


    //
    // Open the domain key for this alias member.
    //

    SetCurrentDomain( DomainBuiltin );
    Status = OpenAliasMember( Sid, &KeyHandle );


    if (NT_SUCCESS(Status)) {

        ULONG                   MembershipCount,
                                KeyValueLength,
                                OldKeyValueLength,
                                i;
        PULONG                  MembershipArray;

        //
        // Retrieve the length of the current membership buffer
        // and allocate one large enough for that plus another member.
        //

        KeyValueLength = 0;
        Status = RtlpNtQueryValueKey( KeyHandle,
                                      &MembershipCount,
                                      NULL,
                                      &KeyValueLength,
                                      NULL);

        SampDumpRtlpNtQueryValueKey(&MembershipCount,
                                    NULL,
                                    &KeyValueLength,
                                    NULL);

        if (NT_SUCCESS(Status) || (Status == STATUS_BUFFER_OVERFLOW)) {

            KeyValueLength +=  sizeof(ULONG);
            MembershipArray = RtlAllocateHeap( RtlProcessHeap(), 0, KeyValueLength );


            if (MembershipArray == NULL) {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            } else {

                OldKeyValueLength = KeyValueLength;
                Status = RtlpNtQueryValueKey(
                               KeyHandle,
                               NULL,
                               MembershipArray,
                               &OldKeyValueLength,
                               NULL);

                SampDumpRtlpNtQueryValueKey(NULL,
                                            MembershipArray,
                                            &OldKeyValueLength,
                                            NULL);

                if (NT_SUCCESS(Status)) {

                    //
                    // See if the account is already a member ...
                    //

                    for (i = 0; i<MembershipCount ; i++ ) {
                        if ( MembershipArray[i] == AliasRid )
                        {
                            Status = STATUS_MEMBER_IN_ALIAS;
                        }
                    }

                    if (NT_SUCCESS(Status)) {

                        //
                        // Add the Aliasrid to the end
                        //

                        MembershipCount += 1;
                        MembershipArray[MembershipCount-1] = AliasRid;

                        //
                        // And write it out.
                        //

                        Status = RtlpNtSetValueKey(
                                       KeyHandle,
                                       MembershipCount,
                                       MembershipArray,
                                       KeyValueLength
                                       );

                        SampDumpRtlpNtSetValueKey(MembershipCount,
                                                  MembershipArray,
                                                  KeyValueLength);
                    }
                }

                RtlFreeHeap(RtlProcessHeap(), 0, MembershipArray);
            }

        }

        IgnoreStatus = NtClose( KeyHandle );
        ASSERT( NT_SUCCESS(IgnoreStatus) );

    }



    return( Status );

}


NTSTATUS
OpenAliasMember(
    IN PSID Sid,
    OUT PHANDLE KeyHandle
    )

/*++

Routine Description:

    This routine opens the registry key containing the alias
    xreference for the specified SID.  If either this key, or
    its corresponding parent key doesn't exist, it (they) will
    be created.

    If a new domain-level key is created, the DomainCount in the
    ALIASES\MEMBERS key is incremented as well.


Arguments:

    Sid - The SID that is an alias member.

    KeyHandle - Receives a handle to the registry key for this alias
        member account xreference.

Return Value:

    None.

--*/

{

    NTSTATUS IgnoreStatus;
    HANDLE AliasDomainHandle;

    SAMTRACE("OpenAliasMember");

    //
    // Open or create the domain-level key.
    //


    Status = OpenOrCreateAliasDomainKey( Sid, &AliasDomainHandle );

    if (NT_SUCCESS(Status)) {


        //
        // Open or create the account-rid key
        //

        Status = OpenOrCreateAccountRidKey( Sid,
                                            AliasDomainHandle,
                                            KeyHandle
                                            );

        IgnoreStatus = NtClose( AliasDomainHandle );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    return(Status);


}



NTSTATUS
OpenOrCreateAccountRidKey(
    IN PSID Sid,
    IN HANDLE AliasDomainHandle,
    OUT PHANDLE KeyHandle
    )

/*++

Routine Description:

    This routine opens an account xreference key for an alias
    member SID.

    If this key doesn't exist, it will be created.

    If a new key is created, the RidCount in the AliasDomainHandle
    key is incremented as well.


Arguments:

    Sid - The SID that is an alias member.

    AliasDomainHandle

    KeyHandle - Receives a handle to the registry key for this alias
        member domain xreference.

Return Value:

    None.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG Disposition;
    ULONG Rid;

    SAMTRACE("OpenOrCreateAccountRidKey");

    if (RtlSubAuthorityCountSid( Sid ) == 0) {
        return(STATUS_INVALID_SID);
    }

    Rid = (*RtlSubAuthoritySid(Sid, (ULONG)(*RtlSubAuthorityCountSid(Sid))-1));

    //
    // Build the Unicode Key for this Rid.
    //

    KeyNameU.Length = (USHORT) 0;

    Status = SampRtlConvertUlongToUnicodeString(
                 Rid,
                 16,
                 8,
                 FALSE,
                 &KeyNameU
                 );

    //
    // Open this key relative to the alias domain key
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyNameU,
        OBJ_CASE_INSENSITIVE,
        AliasDomainHandle,
        NULL
        );
    Status = RtlpNtCreateKey(
                 KeyHandle,
                 (KEY_READ | KEY_WRITE),
                 &ObjectAttributes,
                 0,                 //Options
                 NULL,              //Provider
                 &Disposition
                 );

    if (NT_SUCCESS(Status)) {

        if (Disposition == REG_CREATED_NEW_KEY) {

            //
            // Update the AccountRid count in the alias domain key
            //

            ULONG                    MembershipCount;


            //
            // Retrieve the current domain count and increment it by 1.
            //

            Status = RtlpNtQueryValueKey( AliasDomainHandle,
                                          &MembershipCount,
                                          NULL,
                                          NULL,
                                          NULL);

            SampDumpRtlpNtQueryValueKey(&MembershipCount,
                                        NULL,
                                        NULL,
                                        NULL);

            if (NT_SUCCESS(Status)) {

                MembershipCount += 1;

                //
                // Write it back out.
                //

                Status = RtlpNtSetValueKey(
                               AliasDomainHandle,
                               MembershipCount,
                               NULL,
                               0
                               );

                SampDumpRtlpNtSetValueKey(MembershipCount,
                                          NULL,
                                          0);
            }

            //
            // Now write out the AccountRid key info
            //

            Status = RtlpNtSetValueKey(
                         *KeyHandle,
                         0,                 //Not yet a member of any aliases
                         NULL,
                         0
                         );

            SampDumpRtlpNtSetValueKey(0,
                                      NULL,
                                      0);
        }
    }

    return(Status);
}



NTSTATUS
OpenOrCreateAliasDomainKey(
    IN PSID Sid,
    OUT PHANDLE KeyHandle
    )

/*++

Routine Description:

    This routine opens a domain xreference key for an alias
    member SID.

    If this key doesn't exist, it will be created.

    If a new key is created, the DomainCount in the
    ALIASES\MEMBERS key is incremented as well.


Arguments:

    Sid - The SID that is an alias member.

    KeyHandle - Receives a handle to the registry key for this alias
        member domain xreference.

Return Value:

    None.

--*/

{
    NTSTATUS IgnoreStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG Disposition;

    SAMTRACE("OpenOrCreateAliasDomainKey");

    RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Aliases" );
    Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Members\\" );
    Status = AppendAliasDomainNameToUnicodeString( &KeyNameU, Sid );

    InitializeObjectAttributes(
        &ObjectAttributes,
        &KeyNameU,
        OBJ_CASE_INSENSITIVE,
        SamKey,
        NULL
        );
    Status = RtlpNtCreateKey(
                 KeyHandle,
                 (KEY_READ | KEY_WRITE),
                 &ObjectAttributes,
                 0,                 //Options
                 NULL,              //Provider
                 &Disposition
                 );

    if (NT_SUCCESS(Status)) {

        if (Disposition == REG_CREATED_NEW_KEY) {

            HANDLE TmpHandle;

            //
            // Update the Domain count
            //

            RtlCopyUnicodeString( &KeyNameU, FullDomainNameU );
            Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Aliases" );
            Status = RtlAppendUnicodeToString( &KeyNameU, L"\\Members\\" );

            InitializeObjectAttributes(
                &ObjectAttributes,
                &KeyNameU,
                OBJ_CASE_INSENSITIVE,
                SamKey,
                NULL
                );

            SampDumpNtOpenKey((KEY_READ | KEY_WRITE), &ObjectAttributes, 0);

            Status = RtlpNtOpenKey(
                           &TmpHandle,
                           (KEY_READ | KEY_WRITE),
                           &ObjectAttributes,
                           0
                           );
            ASSERT(NT_SUCCESS(Status));

            if (NT_SUCCESS(Status)) {

                ULONG                    MembershipCount;


                //
                // Retrieve the current domain count and increment it by 1.
                //

                Status = RtlpNtQueryValueKey( TmpHandle,
                                              &MembershipCount,
                                              NULL,
                                              NULL,
                                              NULL);

                SampDumpRtlpNtQueryValueKey(&MembershipCount,
                                            NULL,
                                            NULL,
                                            NULL);

                if (NT_SUCCESS(Status)) {

                    MembershipCount += 1;

                    //
                    // Write it back out.
                    //

                    Status = RtlpNtSetValueKey(
                                   TmpHandle,
                                   MembershipCount,
                                   NULL,
                                   0
                                   );

                    SampDumpRtlpNtSetValueKey(MembershipCount,
                                              NULL,
                                              0);
                }

                IgnoreStatus = NtClose( TmpHandle );
                ASSERT( NT_SUCCESS(IgnoreStatus) );

            }
        }
    }

    return(Status);
}


NTSTATUS
AppendAliasDomainNameToUnicodeString(
    IN OUT PUNICODE_STRING Destination,
    IN PSID Sid
    )

{
    UCHAR OriginalCount;

    SAMTRACE("AppendAliasDomainNameToUnicodeString");

    //
    // Save the current sub-authority count and decrement it by one.
    //

    OriginalCount = (*RtlSubAuthorityCountSid(Sid));
    (*RtlSubAuthorityCountSid(Sid)) = OriginalCount -1;

    //
    // Convert the Sid to a Unicode String and place it in the global
    // temporary Unicode String buffer.
    //

    Status = RtlConvertSidToUnicodeString( &TempStringU, Sid, TRUE);

    (*RtlSubAuthorityCountSid(Sid)) = OriginalCount;

    if (NT_SUCCESS(Status)) {

        Status = RtlAppendUnicodeStringToString( Destination, &TempStringU );
    }

    return(Status);
}



VOID
SampGetServerRole(
    VOID
    )

/*++

Routine Description:

    This routine retrieves the server role from the LSA policy database
    and places it in the global variable SampServerRole.

Arguments:

    None.


Return Value:

    (placed in the global variable (Status) )

    STATUS_SUCCESS - Succeeded.

    Other status values that may be returned from:

        LsarQueryInformationPolicy()
--*/

{
    NTSTATUS IgnoreStatus;
    PPOLICY_LSA_SERVER_ROLE_INFO ServerRoleInfo = NULL;

    SAMTRACE("SampGetServerRole");

    //
    // Query the server role information
    //

    Status = LsarQueryInformationPolicy(
                 SampBldPolicyHandle,
                 PolicyLsaServerRoleInformation,
                 (PLSAPR_POLICY_INFORMATION *)&ServerRoleInfo
                 );

    if (NT_SUCCESS(Status)) {

        if (ServerRoleInfo->LsaServerRole == PolicyServerRolePrimary) {

            SampServerRole = DomainServerRolePrimary;

        } else {

            SampServerRole = DomainServerRoleBackup;
        }

        IgnoreStatus = LsaFreeMemory( ServerRoleInfo );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    return;
}




VOID
SampGetPrimaryDomainInfo(
    IN PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo OPTIONAL
    )

/*++

Routine Description:

    This routine retrieves the primary domain name/sid from the
    LSA policy database and places it in the global variable
    SampBldPrimaryDomain.


Arguments:

    None.


Return Value:

    (placed in the global variable (Status) )

    STATUS_SUCCESS - Succeeded.

    Other status values that may be returned from:

        LsarQueryInformationPolicy()

    NOTE:  The Rdr and Bowser components of the LanmanWorkstation
           service rely on there always being a primary domain name.
           For this reason Network SETUP always supplies a default
           "workgroup" name, which is set as the primary domain name.
           In this case, the name is present but the SID is NULL;
           this is equivalent to NOT having a primary domain at all.

--*/

{
    SAMTRACE("SampGetPrimaryDomainInfo");

    SampBldPrimaryDomain = NULL;

    if (!ARGUMENT_PRESENT(PrimaryDomainInfo)) {
        Status = LsarQueryInformationPolicy(
                     SampBldPolicyHandle,
                     PolicyPrimaryDomainInformation,
                     (PLSAPR_POLICY_INFORMATION *) &SampBldPrimaryDomain
                     );
    } else {

        SampBldPrimaryDomain = PrimaryDomainInfo;
        Status = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(Status) && ( SampBldPrimaryDomain->Sid == NULL )) {

        if (!ARGUMENT_PRESENT(PrimaryDomainInfo)) {

            LsaIFree_LSAPR_POLICY_INFORMATION(
                PolicyPrimaryDomainInformation,
                (PLSAPR_POLICY_INFORMATION) SampBldPrimaryDomain
                );

        }

        SampBldPrimaryDomain = NULL;
    }

    return;
}


NTSTATUS
SampDetermineSetupEnvironment( VOID )


/*++

Routine Description:

    This function checks to see whether we are running folloing
    a formal SETUP.  If not, it is assumed we are running to
    perform a developer's setup.

    Global variables are set to indicate our setup environment.


        BOOLEAN SampRealSetupWasRun;   //Indicates a real setup was run
        BOOLEAN SampDeveloperSetup;    //Indicates a developer setup is running


Arguments:

    None.

Return Value:


--*/

{
    NTSTATUS NtStatus, TmpStatus;
    HANDLE InstallationEvent;
    OBJECT_ATTRIBUTES EventAttributes;
    UNICODE_STRING EventName;

    SAMTRACE("SampDetermineSetupEnvironment");

    SampRealSetupWasRun = FALSE;
    SampDeveloperSetup = FALSE;

    //
    // If the following event exists, it is an indication that
    // a real setup was run.
    //

    RtlInitUnicodeString( &EventName, L"\\INSTALLATION_SECURITY_HOLD");
    InitializeObjectAttributes( &EventAttributes, &EventName, 0, 0, NULL );

    NtStatus = NtOpenEvent(
                   &InstallationEvent,
                   SYNCHRONIZE,
                   &EventAttributes
                   );

    if ( NT_SUCCESS(NtStatus)) {

        //
        // The event exists - installation created it and will signal it
        // when it is ok to proceed with security initialization.
        //

        SampRealSetupWasRun = TRUE;

        TmpStatus = NtClose( InstallationEvent );
        ASSERT(NT_SUCCESS(TmpStatus));

    } else {
        SampDeveloperSetup = TRUE;
    }



    return(NtStatus);

}



NTSTATUS
SampInitializeRegistry (
    WCHAR                      *SamParentKeyName,
    PNT_PRODUCT_TYPE            ProductType       OPTIONAL,
    PPOLICY_LSA_SERVER_ROLE     ServerRole        OPTIONAL,
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomainInfo OPTIONAL,
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo OPTIONAL,
    BOOLEAN                     PreserveSyskeySettings
    )
/*++

Routine Description:

    This routine initializes a SAM database in the registry.

Arguments:

    NONE

Return Value:

    STATUS_SUCCESS or an error received along the way.

--*/

{
    NTSTATUS IgnoreStatus;

    SAMTRACE("SampInitializeRegistry");

    Status = Initialize(SamParentKeyName,
                        ProductType,
                        ServerRole,
                        AccountDomainInfo,
                        PrimaryDomainInfo);

    if (!NT_SUCCESS(Status)) {
        return( Status );
    }

    //
    // Initialize SAM-level registry structures
    //

    Status = InitializeSam( );
    if (!NT_SUCCESS(Status)) {return(Status);}

    //
    // OK, we have a SAM key.
    // Create each of the domains.
    //

    Status = CreateBuiltinDomain( );  if (!NT_SUCCESS(Status)) {return(Status);}
    Status = CreateAccountDomain(PreserveSyskeySettings);  if (!NT_SUCCESS(Status)) {return(Status);}

    //
    // all done
    //

    //
    // Close our handle to LSA.  Ignore any errors.
    //

    IgnoreStatus = LsarClose( (PLSAPR_HANDLE) &SampBldPolicyHandle );
    SampBldPolicyHandle = NULL;


    //
    // Free up the transaction context we created
    //

    RtlFreeHeap( RtlProcessHeap(), 0, SamRXactContext );
    SamRXactContext = NULL;

    //
    // Close the database root key after flushing all the changes we made.
    //

    Status = NtFlushKey( SamKey );

    if (NT_SUCCESS(Status)) {

        IgnoreStatus = NtClose( SamKey );
        ASSERT(NT_SUCCESS(IgnoreStatus));

    } else {

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSRV:  FlushKey failed, database not built.  Status: 0x%lx\n",
                   Status));

        IgnoreStatus = NtClose( SamKey );
    }

    SamKey = NULL;

    //
    // Close the database root parent key
    //

    if (SamParentKey != NULL) {
        IgnoreStatus = NtClose( SamParentKey );
    }

    return( Status );
}


NTSTATUS
SampGetMessageStrings(
    LPVOID              Resource,
    DWORD               Index1,
    PUNICODE_STRING     String1,
    DWORD               Index2,
    PUNICODE_STRING     String2 OPTIONAL
    )


/*++

Routine Description:

    This gets 1 or 2 message strings values from a resource message table.
    The string buffers are allocated and the strings initialized properly.

    The string buffers must be freed using LocalFree() when no longer needed.

Arguments:

    Resource - points to the resource table.

    Index1 - Index of first message to retrieve.

    String1 - Points to a UNICODE_STRING structure to receive the first
        message string.

    Index2 - Index of second message to retrieve.

    String2 - Points to a UNICODE_STRING structure to receive the first
        message string.  If this parameter is NULL, then only one message
        string is retrieved.

Return Value:

    None.

--*/


{

    SAMTRACE("SampGetMessageStrings");

    String1->Buffer    = NULL;

    String1->MaximumLength = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                          FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                          Resource,
                                          Index1,
                                          0,                 // Use caller's language
                                          (LPWSTR)&(String1->Buffer),
                                          0,
                                          NULL
                                          );

    if (String1->Buffer == NULL) {
        return(STATUS_RESOURCE_DATA_NOT_FOUND);
    } else {

        //
        // Note that we are retrieving a message from a message file.
        // This message will have a cr/lf tacked on the end of it
        // (0x0d 0x0a) that we don't want to be part of our returned
        // strings.  Also note that FormatMessage() returns a character
        // count, not a byte count.  So, we have to do some adjusting
        // to make the string lengths correct.
        //

        String1->MaximumLength -=  2; // For the cr/lf we don't want.
        String1->MaximumLength *=  sizeof(WCHAR);  // to make it a byte count
        String1->Length = String1->MaximumLength;
    }


    if (!ARGUMENT_PRESENT(String2)) {
        return(STATUS_SUCCESS);
    }

    String2->Buffer = NULL;
    String2->MaximumLength = (USHORT) FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                                          FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                          Resource,
                                          Index2,
                                          0,                 // Use caller's language
                                          (LPWSTR)&(String2->Buffer),
                                          0,
                                          NULL
                                          );

    if (String2->Buffer == NULL) {
        LocalFree( String1->Buffer );
        return(STATUS_RESOURCE_DATA_NOT_FOUND);
    } else {

        //
        // Note that we are retrieving a message from a message file.
        // This message will have a cr/lf tacked on the end of it
        // (0x0d 0x0a) that we don't want to be part of our returned
        // strings.  Also note that FormatMessage() returns a character
        // count, not a byte count.  So, we have to do some adjusting
        // to make the string lengths correct.
        //

        String2->MaximumLength -=  2; // For the cr/lf we don't want.
        String2->MaximumLength *=  sizeof(WCHAR);  // to make it a byte count
        String2->Length = String2->MaximumLength;
    }



    return(STATUS_SUCCESS);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\context.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    context.c

Abstract:

    This file contains services for operating on internal context blocks.


Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:
    31 - May 1996 Murlis
        Ported to use the NT5 DS.

    ChrisMay 10-Jun-96
        Added initialization of Context->ObjectNameInDs and IsDsObject data
        members. Note that this causes context objects to be created with a
        default storage of type registry (instead of DS).

    6-16-96
       Moved DS object decision to SampCreateContext for account objects.

    9-19-97
        Added full multi threading support for logons

--*/


//
// DESCRIPTION and brief History
//
//  Sam Context's in the NT4  time frame used to be created
//  with SampCreateContext. This used to create a context, initialize it and
//  and add it to the various list's of currently active context's. Delete
//  operations in SAM would then invalidate all the open context's for that
//  object by walking through the list of context's and checking for the
//  corresponding object. This scheme worked in NT4 and earlier SAM because
//  all services held the SAM lock for exclusive access. To improve performance
//  NT5 Sam multi-threads many operations. To allow for easy multi-threading
//  the CreateContextEx service was introduced. This service takes the NotSharedByMultiThreads 
//  parameter, and does not add ThreadSafe context's into any of the in-memory
//  Context lists in DS. This prevents any invalidations,if the object corresponding to
//  the context was deleted. Sam service calls in Ds mode, simply error out if
//  any Ds call would fail, as would happen when the object is deleted. The
//  CreateContextEx also allows setting of many parameters on the context, that
//  allow for more intelligent caching and updates of the object.
//

//
//  10-27-2000 (ShaoYin)
//  Change variable ThreadSafe to NotSharedByMultiThreads
//  
//      NotSharedByMultiThreads will be set for all user, group and alias contexts,
//      and all domain and server contexts that do not originate from in process
//      callers that share handles among threads.
//
// 



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <dslayer.h>
#include <dsmember.h>




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////




NTSTATUS
SampCheckIfObjectExists(
                        IN  PSAMP_OBJECT    Context
                        );

BOOLEAN
SampIsObjectLocated(
                    IN  PSAMP_OBJECT Context
                    );

NTSTATUS
SampLocateObject(
                 IN PSAMP_OBJECT Context,
                 IN ULONG   Rid
                 );



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////





PSAMP_OBJECT
SampCreateContext(
    IN SAMP_OBJECT_TYPE Type,
    IN ULONG   DomainIndex,
    IN BOOLEAN TrustedClient
    )
/*++

  Routine Description

    This service creates a context, that is compatible with the context's
    created in NT4 SAM. This routine requires that a transaction domain be
    set, if the required context was user, group or alias object type. This
    service calls SampCreateContextEx with appropriate parameters to do the
    job.

    Note: 10/12/2000 (ShaoYin) 
        "Transaction Domain be set" is no longer a requirement for this 
        routine. Actually all it wants for "Transaction Domain" is "Domain
        Index". So just passing "DomainIndex" into this routine, we will
        no longer need "TransactionDomain be set", thus no lock is required
        for this routine. Just like SampCreateContextEx(). 

  Arguments

    Type  -- The type of the object.

    DomainIndex - set the domain index of this context
    
    TrustedClient -- Indicates whether this is a trusted client

  Return Values

    Address of valid context on success
    NULL on failure

--*/
{
    BOOLEAN NotSharedByMultiThreads = FALSE;


    // 
    // Comment this out, or let the caller calls SampCreateContextEx  10/12/2000
    // 
    // ASSERT(SampCurrentThreadOwnsLock() || (SampServiceState!=SampServiceEnabled)); 
    // 

    //
    // Account Context's are thread safe in DS mode
    //

    if ( (SampUserObjectType==Type) ||
         (SampGroupObjectType == Type) || 
         (SampAliasObjectType == Type) )
    {
        NotSharedByMultiThreads = TRUE;
    }

    return ( SampCreateContextEx(
                    Type,
                    TrustedClient,
                    SampUseDsData,
                    NotSharedByMultiThreads, // NotSharedByMultiThreads
                    FALSE, // loopback client
                    FALSE, // lazy commit
                    FALSE, // persis across across calls
                    FALSE, // Buffer Writes
                    FALSE, // Opened By DCPromo
                    DomainIndex
                    ));
}




PSAMP_OBJECT
SampCreateContextEx(
    IN SAMP_OBJECT_TYPE Type,
    IN BOOLEAN TrustedClient,
    IN BOOLEAN DsMode,
    IN BOOLEAN NotSharedByMultiThreads,
    IN BOOLEAN LoopbackClient,
    IN BOOLEAN LazyCommit,
    IN BOOLEAN PersistAcrossCalls,
    IN BOOLEAN BufferWrites,
    IN BOOLEAN OpenedByDCPromo,
    IN ULONG   DomainIndex
    )

/*++

Routine Description:

    This service creates a new object context block of the specified type.

    If the context block is for either a user or group object type, then
    it will be added to the list of contexts for the domain specified by the
    context.


    Upon return:

         - The ObjectType field will be set to the passed value.

         - The Reference count field will be set to 1,

         - The GrantedAccess field will be zero.

         - The TrustedClient field will be set according to the passed
           value.

         - The Valid flag will be TRUE.

    All other fields must be filled in by the creator.


Arguments:

    Type - Specifies the type of context block being created.

    TrustedClient  Indicates whether the client is a trusted component
            of the operating syste.  If so, than all access checks are
            circumvented.

    DsMode   - Indicates that the given context is for DsMode operation

    NotSharedByMultiThreads - Allows the context to be marked as NotSharedByMultiThreads. 
             This allows many query API's in DS Mode to bypass the Sam lock 
             mechanism. NotSharedByMultiThreads context's in DS Mode are not 
             added to list of context's maintained in global data structures. 
             This keeps them safe from being invalidated because of deletions 
             to the object.

             This variable will be set for all User, Group and Alias contexts, 
             and all domain and server contexts that do not originate from in 
             process callers that share handles amongst threads. Routines 
             manipulating a domain context that is shared across multiple threads, 
             but do no real work on the domain context can still choose not to 
             lock and be careful about DerefernceContext2.


    LoopbackClient - Allows the context to be marked as Loopback Client. This
             allows LDAP clients to bypass the SAM lock mechanism. Loopback
             client context's are NOT added to list of the context's maintained
             in global data structures, since Loopback client does not share 
             context handle. And loopback clients are safe wrt object deletions.             

    LazyCommit - Will mark the context as such. This will let the commit code
                 do lazy commits on this context

    PersistAcrossCalls  -- Data cached in the context will be persisted across
                      Sam calls

    BufferWrites -- Writes will be made only to the SAM context and then will be
                    written out during close handle time

    OpenedByDCPromo -- Indicates whether this context is opened by DCPromo part or not                    

    DomainIndex  --   Index specifying the domain

Return Value:


    Non-Null - Pointer to a context block.

    NULL - Insufficient resources.  No context block allocated.


--*/
{

    PSAMP_OBJECT Context = NULL;
    NTSTATUS     NtStatus = STATUS_SUCCESS;

    SAMTRACE("SampCreateContextEx");


    Context = MIDL_user_allocate( sizeof(SAMP_OBJECT) );
    if (Context != NULL) {

#if SAMP_DIAGNOSTICS
    IF_SAMP_GLOBAL( CONTEXT_TRACKING ) {
            SampDiagPrint( CONTEXT_TRACKING, ("Creating  ") );
            if (Type == SampServerObjectType) SampDiagPrint(CONTEXT_TRACKING, ("Server "));
            if (Type == SampDomainObjectType) SampDiagPrint(CONTEXT_TRACKING, (" Domain "));
            if (Type == SampGroupObjectType)  SampDiagPrint(CONTEXT_TRACKING, ("  Group "));
            if (Type == SampAliasObjectType)  SampDiagPrint(CONTEXT_TRACKING, ("   Alias "));
            if (Type == SampUserObjectType)   SampDiagPrint(CONTEXT_TRACKING, ("    User "));
            SampDiagPrint(CONTEXT_TRACKING, ("context : 0x%lx\n", Context ));
    }
#endif //SAMP_DIAGNOSTICS

        RtlZeroMemory( Context, sizeof(SAMP_OBJECT) );

        //
        // Check How many Active Contexts have been opened by 
        // this client so far
        // 

        if (!TrustedClient && !LoopbackClient) {

            //
            // Context has been passed into the following routine
            // so that the pointer to the element will be set when succeeded.
            // 
            NtStatus = SampIncrementActiveContextCount(Context);

            if (!NT_SUCCESS(NtStatus))
            {
                MIDL_user_free(Context);
                return(NULL);
            }
        }


        Context->ObjectType      = Type;
        Context->ReferenceCount  = 1;    // Represents RPCs held context handle value
        Context->GrantedAccess   = 0;

        Context->RootKey         = INVALID_HANDLE_VALUE;
        RtlInitUnicodeString(&Context->RootName, NULL);

        //
        // Here is my observation: for User / Group / Alias Object
        // 
        // In DS mode, 
        // the context should either be NotSharedByMultiThreads or LoopbackClient.
        //
        // So for those object contexts (User / Group / Alias)
        // Since they are either NotSharedByMultiThreads or Loopback Client, we
        // will not put them in the Global Context List,
        // therefore we don't need to invalidate the ContextList 
        // during Object Deletion.
        // 
        // Server and Domain Object are not included. However, no one
        // will try to (or allowed to) delete server or domain object.
        // 

        ASSERT(!DsMode || 
               (SampServerObjectType == Type) ||
               (SampDomainObjectType == Type) ||
               NotSharedByMultiThreads ||
               LoopbackClient);

        Context->TrustedClient   = TrustedClient;
        Context->LoopbackClient  = LoopbackClient;
        Context->MarkedForDelete = FALSE;
        Context->AuditOnClose    = FALSE;

        Context->OnDisk          = NULL;
        Context->PreviousOnDisk  = NULL;
        Context->OnDiskAllocated = 0;
        Context->FixedValid      = FALSE;
        Context->VariableValid   = FALSE;
        Context->NotSharedByMultiThreads      = NotSharedByMultiThreads || LoopbackClient;    // Loopback Client is also Thread Safe
        Context->RemoveAccountNameFromTable = FALSE;
        Context->LazyCommit      = LazyCommit;
        Context->PersistAcrossCalls = PersistAcrossCalls;
        Context->BufferWrites    = BufferWrites;
        Context->ReplicateUrgently  = FALSE;
        Context->OpenedBySystem     = FALSE;
        Context->OpenedByDCPromo = OpenedByDCPromo;

        //
        // The following are meaningless at this point because of the
        // values of the variables above, but we'll set them just to be
        // neat.
        //

        Context->FixedDirty      = FALSE;
        Context->VariableDirty   = FALSE;

        Context->OnDiskUsed      = 0;
        Context->OnDiskFree      = 0;

        //
        // Initialize the Client revision to pre-NT5 for safety
        //

        Context->ClientRevision = SAM_CLIENT_PRE_NT5;

        //
        // Initialize the Per attribute Dirty Bits
        //

        RtlInitializeBitMap(
            &Context->PerAttributeDirtyBits,
            Context->PerAttributeDirtyBitsBuffer,
            MAX_SAM_ATTRS
            );

        RtlClearAllBits(
            &Context->PerAttributeDirtyBits
            );

        Context->AttributesPartiallyValid = FALSE;

        //
        // Intialize the per attribute Invalid Bits
        //

        RtlInitializeBitMap(
            &Context->PerAttributeInvalidBits,
            Context->PerAttributeInvalidBitsBuffer,
            MAX_SAM_ATTRS
            );

        RtlClearAllBits(
            &Context->PerAttributeInvalidBits
            );

        //
        // Initialize the attributes granted bit map
        //
        RtlInitializeBitMap(
            &Context->WriteGrantedAccessAttributes,
            Context->WriteGrantedAccessAttributesBuffer,
            MAX_SAM_ATTRS
            );

        RtlClearAllBits(
            &Context->WriteGrantedAccessAttributes
            );

        //
        // Initialize the Type of context ( Registry or DS )
        // The root key in registry mode, and the object name in DS
        // in DsMode fields will be set later to indicate valid
        // database pointers to the object
        //

        if (DsMode)
        {
            SetDsObject(Context);
            Context->DsClassId = SampDsClassFromSamObjectType(Type);
        }
        else
        {
            SetRegistryObject(Context);
            Context->DsClassId = 0;
        }

        Context->ObjectNameInDs = NULL;


        //
        // Add this new context to the set of valid contexts ...
        //

        SampAddNewValidContextAddress( Context );


        //
        // User and group context blocks are kept on linked lists
        // from the domain's in-memory structure.  Insert in the
        // Appropriate List and then additionally for Account Objects
        // Make the DS/Registry decision by looking at the TransactionDomain
        //

        Context->DomainIndex = DomainIndex;

        switch (Type) {

        case SampDomainObjectType:

            Context->TypeBody.Domain.DsDisplayState.Restart = NULL;
            Context->TypeBody.Domain.DsDisplayState.TotalAvailable=0;
            Context->TypeBody.Domain.DsDisplayState.TotalEntriesReturned = 0;
            Context->TypeBody.Domain.DsDisplayState.DisplayInformation = 0;
            Context->TypeBody.Domain.DsDisplayState.NextStartingOffset = 0;

            //////////////////////////////////////////////////////
            //                                                  //
            //   Warning This case falls into the next one      //
            //                                                  //
            //////////////////////////////////////////////////////
        case SampServerObjectType:

            //
            // Clients marked as NotSharedByMultiThreads are free
            // of object deletion. Do not need to put them into the ContextList
            // 
            // Don't put context opened by dcpromo to ContextList
            // 
            if ((!Context->NotSharedByMultiThreads || !IsDsObject(Context))
                && !OpenedByDCPromo)
            {
                SampInsertContextList(
                    &SampContextListHead,
                    &Context->ContextListEntry
                    );
            }

            break;

        case SampUserObjectType:

            if ((!Context->NotSharedByMultiThreads || !IsDsObject(Context))
                && !OpenedByDCPromo)
            {
                // Insert into List
                SampInsertContextList(
                    &SampContextListHead,
                    &Context->ContextListEntry
                    );
            }

            // Set PrivilegedMachineAccountCreate to False
            Context->TypeBody.User.PrivilegedMachineAccountCreate = FALSE;

            // Initialize the supplemental credential information
            Context->TypeBody.User.CachedSupplementalCredentials = NULL;
            Context->TypeBody.User.CachedSupplementalCredentialLength = 0;
            Context->TypeBody.User.CachedSupplementalCredentialsValid = FALSE;
            Context->TypeBody.User.SupplementalCredentialsToWrite = NULL;

            // Initialize uparms accessible and DomainSidForNT4Conversion fields
            Context->TypeBody.User.UparmsInformationAccessible = FALSE;
            Context->TypeBody.User.DomainSidForNt4SdConversion = NULL;

            // Mark the Original UserParms invalid
            Context->TypeBody.User.CachedOrigUserParms = NULL;
            Context->TypeBody.User.CachedOrigUserParmsLength = 0;
            Context->TypeBody.User.CachedOrigUserParmsIsValid = FALSE;

            // Initialize the UPN in the context

            RtlZeroMemory(&Context->TypeBody.User.UPN, sizeof(UNICODE_STRING));
            Context->TypeBody.User.UpnDefaulted = TRUE;

            Context->TypeBody.User.fNoGcAvailable = FALSE;

            // Clear the A2D2 Attribute
            Context->TypeBody.User.A2D2List = NULL;

            break;

        case SampGroupObjectType:

            if ((!Context->NotSharedByMultiThreads || !IsDsObject(Context))
                && !OpenedByDCPromo)
            {
                // Insert into List
                SampInsertContextList(
                    &SampContextListHead,
                    &Context->ContextListEntry
                    );
            }

            Context->TypeBody.Group.SecurityEnabled = TRUE;
            Context->TypeBody.Group.NT4GroupType = NT4GlobalGroup;
            Context->TypeBody.Group.NT5GroupType = NT5AccountGroup;
            Context->TypeBody.Group.CachedMembershipOperationsListMaxLength = 0;
            Context->TypeBody.Group.CachedMembershipOperationsListLength = 0;
            Context->TypeBody.Group.CachedMembershipOperationsList = NULL;

            break;

        case SampAliasObjectType:

            if ((!Context->NotSharedByMultiThreads || !IsDsObject(Context))
                && !OpenedByDCPromo)
            {
                // Insert into List
                SampInsertContextList(
                    &SampContextListHead,
                    &Context->ContextListEntry
                    );
            }


            Context->TypeBody.Alias.SecurityEnabled = TRUE;
            Context->TypeBody.Alias.NT4GroupType = NT4LocalGroup;
            Context->TypeBody.Alias.NT5GroupType = NT5ResourceGroup;
            Context->TypeBody.Alias.CachedMembershipOperationsListMaxLength = 0;
            Context->TypeBody.Alias.CachedMembershipOperationsListLength = 0;
            Context->TypeBody.Alias.CachedMembershipOperationsList = NULL;

            break;
        }

    }

    return(Context);
}


VOID
SampDeleteContext(
    IN PSAMP_OBJECT Context
    )

/*++

Routine Description:

    This service marks a context object for delete and dereferences it.
    If this causes the reference count to go to zero, then the context
    block will be immediately deleted (deallocated).  Otherwise, the
    context block will be deleted when the reference count finally does
    go to zero.


    THIS SERVICE MUST BE CALLED WITH THE SampLock HELD FOR WRITE ACCESS.


Arguments:

    Context - Pointer to the context block to delete.

Return Value:

    None.



--*/
{
    NTSTATUS IgnoreStatus;
    BOOLEAN  ImpersonatingAnonymous = FALSE;
    BOOLEAN  Impersonating = FALSE;


    SAMTRACE("SampDeleteContext");

    Context->MarkedForDelete = TRUE;



    if (!Context->TrustedClient) 
    {
        IgnoreStatus = SampImpersonateClient(&ImpersonatingAnonymous );
        if (NT_SUCCESS(IgnoreStatus))
        {
            Impersonating = TRUE;
        }

        //
        // On a failure to impersonate do not fail the DelteContext
        // as that would cause the handle to be not closed and leak
        // memory. Instead proceed to audit the close as system if
        // possible
        //
    }
        
    //
    // Audit the close of this context.
    //

    (VOID) NtCloseObjectAuditAlarm (
               &SampSamSubsystem,
               (PVOID)Context,
               Context->AuditOnClose
               );

    if (Impersonating)
    {
        SampRevertToSelf(ImpersonatingAnonymous);
    }



    //
    // Remove this context from the valid context set.
    // Note that the context may have already been removed.  This is
    // not an error.
    //

    SampInvalidateContextAddress( Context );


    //
    // User and group context blocks are kept on linked lists
    // from the domain's in-memory structure.  Domain and
    // server context blocks are kept on a global in-memory list.
    // They are removed when they are marked for delete.
    //
    // Context opened by DCPromo is not in ContextList.
    // 

    if ((!Context->NotSharedByMultiThreads || !IsDsObject(Context))
        && (!Context->OpenedByDCPromo))
    {
        SampRemoveEntryContextList(&Context->ContextListEntry);
    }

    //
    // We have to call dereference to counter the initial count of 1
    // put on by create.
    //


    IgnoreStatus = SampDeReferenceContext( Context, FALSE );


    return;

}


NTSTATUS
SampLookupContext(
    IN PSAMP_OBJECT Context,
    IN ACCESS_MASK DesiredAccess,
    IN SAMP_OBJECT_TYPE ExpectedType,
    OUT PSAMP_OBJECT_TYPE FoundType
    )
//
// See SampLookupContextEx
//
{

    return SampLookupContextEx(Context,
                               DesiredAccess,
                               NULL,
                               ExpectedType,
                               FoundType);
}




NTSTATUS
SampLookupContextEx(
    IN PSAMP_OBJECT Context,
    IN ACCESS_MASK DesiredAccess,
    IN PRTL_BITMAP RequestedAttributeAccess OPTIONAL,
    IN SAMP_OBJECT_TYPE ExpectedType,
    OUT PSAMP_OBJECT_TYPE FoundType
    )

/*++

Routine Description:

    This service:

        - Checks to make sure the Service state is one in which an
          object can be looked up (i.e., not Initializing or Terminating).

        - Makes sure the Service state is compatible with the lookup.
          Non-trusted clients can only perform lookups when the Service
          state is Enabled.  If the client isn't trusted and the context
          is for a group or user, then the state of that object's domain
          must also be enabled

        - Checks to make sure the context block represents the
          type of object expected, and, if so:

            - Checks to see that the caller has the requested (desired)
              access, and, if so:

                - Makes sure the object still exists, and opens it if it
                  does.  Servers and domains can't be deleted, and so
                  their handle is left open.

                - References the context block


    Note that if the block is marked as TrustedClient, then access will
    always be granted unless service state prevents it.

    Also, if the ExpectedType is specified to be unknown, then any type
    of context will be accepted.



    If the type of object is found to be , Domain, Group or User, then the
    this service will set the transaction domain.

    THIS SERVICE MUST BE CALLED WITH THE SampLock HELD FOR WRITE ACCESS.
    (For Loopback Client, the SAM Lock is not a requirement) 


Arguments:

    Context - Pointer to the context block to look-up.

    DesiredAccess - The type of access the client is requesting to this
        object.  A zero-valued access mask may be specified.  In this case,
        the calling routine must do access validation.

        Note: SAMP_CLOSE_OPERATION_ACCESS_MASK is a special value, which 
              indicates the caller is SamrCloseHandle, thus we should not 
              check Context->Valid Flag.

    RequestedAttributeAccess -- bit mask of requested attributes

    ExpectedType - The type of object expected.  This may be unknown.  In
        this case, the DesiredAccess should only include access types that
        apply to any type of object (e.g., Delete, WriteDacl, et cetera).

    FoundType - Receives the type of context actually found.

Return Value:

    STATUS_SUCCESS - The context was found to be the type expected (or any
        type if ExpectedType was unknown) and the DesiredAccesses are all
        granted.

    STATUS_OBJECT_TYPE_MISMATCH - Indicates the context was not the expected
        type.

    STATUS_ACCESS_DENIED - The desired access is not granted by this context.


--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN  CloseOperation = FALSE;

    SAMTRACE("SampLookupContext");



    //
    // Make sure we are in a legitimate state to at least access
    // a context block.  If we are initializing we have somehow allowed
    // a connect through.  This should never happen.
    // If we are terminating, clients may still have handles (since we
    // have no way to tell RPC they are no longer valid without the client
    // calling us, Argh!).  However, since we are terminating, the blocks
    // are being cleaned up and may no longer be allocated.
    //

    ASSERT( (SampServiceState != SampServiceInitializing) || (SampUpgradeInProcess) );
    if ( SampServiceState == SampServiceTerminating ) {
        return(STATUS_INVALID_SERVER_STATE);
    }


    //
    // Make sure the passed context address is (still) valid.
    //

    NtStatus = SampValidateContextAddress( Context );
    if ( !NT_SUCCESS(NtStatus) ) {
        return(NtStatus);
    }

    //
    // if SAMP_CLOSE_OPERATION_ACCESS_MASK 1 is passed in as desired access, 
    // don't do any access check. 
    // otherwise, make sure this context is marked valid.
    // 

    if ( SAMP_CLOSE_OPERATION_ACCESS_MASK  == DesiredAccess) 
    {
        DesiredAccess = 0;
        CloseOperation = TRUE;
    }
    else
    {
        if (!Context->Valid)
        {
            return(STATUS_INVALID_HANDLE); 
        }
    }

    //
    // Check type
    //

    (*FoundType) = Context->ObjectType;
    if (ExpectedType != SampUnknownObjectType) {
        if (ExpectedType != (*FoundType)) {
            return(STATUS_OBJECT_TYPE_MISMATCH);
        }
    }


    //
    // If we own the lock, then set the transaction domain and also validate
    // the domain cache if necessary. If we are not holding the lock, the caller
    // is not expected to use transaction domains or refer to anything in the
    // domain cache.
    //

    if (SampCurrentThreadOwnsLock())
    {



        NtStatus = SampValidateDomainCache();
        if (!NT_SUCCESS(NtStatus))
            return(NtStatus);

        //
        // if the object is either user or group, then we need to set the
        // transaction domain. We also need to validate the Domain Cache ,
        // as a previous Write could have invalidated it.
        //

        if ((Context->ObjectType == SampDomainObjectType) ||
            (Context->ObjectType == SampGroupObjectType)  ||
            (Context->ObjectType == SampAliasObjectType)  ||
            (Context->ObjectType == SampUserObjectType) ) {

            SampSetTransactionWithinDomain(FALSE);
            SampSetTransactionDomain( Context->DomainIndex );
        }

    }
    else
    {
        //
        // If the SAM lock is not held then the context is either thread safe ( ie never
        // shared across multiple threads. Or it is the case of a domain context used
        // by a non loopback client in DS mode.
        //

        ASSERT((Context->NotSharedByMultiThreads)
                          || ( (SampDomainObjectType == Context->ObjectType)
                                   && (IsDsObject(Context))
                                   && (!Context->LoopbackClient))
              );
        ASSERT(IsDsObject(Context));


        //
        // NotSharedByMultiThread is always set for Loopback client
        // 

        ASSERT(!Context->LoopbackClient || Context->NotSharedByMultiThreads);
    }

    //
    // If the client isn't trusted, then there are a number of things
    // that will prevent them from continuing...
    //

    // If the service isn't enabled, we allow trusted clients to continue,
    // but reject non-trusted client lookups.
    //

    if ( !Context->TrustedClient ) {

        //
        // The SAM service must be enabled
        //

        if (SampServiceState != SampServiceEnabled) {
            return(STATUS_INVALID_SERVER_STATE);
        }


        //
        // If the access is to a USER or GROUP and the client isn't trusted
        // then the domain must be enabled or the operation is rejected.
        //

        if ( (Context->ObjectType == SampUserObjectType) ||
             (Context->ObjectType == SampAliasObjectType) ||
             (Context->ObjectType == SampGroupObjectType)    ) {
            if (SampDefinedDomains[Context->DomainIndex].CurrentFixed.ServerState
                != DomainServerEnabled) {
                return(STATUS_INVALID_DOMAIN_STATE);
            }
        }

    }

    //
    // Make sure the object is still around (that is, somebody didn't delete
    // it right out from under us). We will not do this check in DS mode, and
    // hope that a DS call failure will fail decently. This will reduce one
    // DirSearch per lookup context, and since lookup context is called almost
    // every time that someone makes a Sam Call, this will be a significant performance
    // improvement
    //

    if ((!IsDsObject(Context)) && !CloseOperation)
    {
        NtStatus = SampCheckIfObjectExists(Context);
        if (!NT_SUCCESS(NtStatus))
        {
            return(NtStatus);
        }
    }
    //
    // Check the desired access ...
    //
    // There are several special cases:
    //
    //  1) The client is trusted.  This is granted with no access check
    //     or role consistency check.
    //
    //  2) The caller specified 0 for desired access.  This is used
    //     to close handles and is granted with no access check.
    //

    if ( (!Context->TrustedClient) ) {


        if (SampUserObjectType==Context->ObjectType) {


            if ( DesiredAccess & USER_CHANGE_PASSWORD)
            {
                //
                // If it is the user object, then special case the access ck for
                // password changes. The password change access ck is always done 
                // at password change time, vs at OpenUser time.
                //

                ACCESS_MASK SavedGrantedAccess;
                BOOLEAN     SavedAuditOnClose;
                SAMP_DEFINE_SAM_ATTRIBUTE_BITMASK(SavedWriteGrantedAccessAttributes);
                
            
                DesiredAccess &= ~(USER_CHANGE_PASSWORD);

                SavedGrantedAccess = Context->GrantedAccess;
                SavedAuditOnClose  = Context->AuditOnClose;
                SAMP_COPY_SAM_ATTRIBUTE_BITMASK(SavedWriteGrantedAccessAttributes,
                    Context->WriteGrantedAccessAttributes);

                NtStatus = SampValidateObjectAccess2(
                                     Context,
                                     USER_CHANGE_PASSWORD,
                                     NULL,
                                     FALSE,
                                     TRUE,
                                     FALSE
                                     );

                Context->GrantedAccess = SavedGrantedAccess;
                Context->AuditOnClose = SavedAuditOnClose;
                SAMP_COPY_SAM_ATTRIBUTE_BITMASK(Context->WriteGrantedAccessAttributes,
                    SavedWriteGrantedAccessAttributes);



                if (!NT_SUCCESS(NtStatus)) {
                    return(NtStatus);
                }
            }

            //
            // if this is ntdsa looping back and we are being asked for set password
            // operation then access ck here
            //

            if ((Context->LoopbackClient) && 
                (DesiredAccess & USER_FORCE_PASSWORD_CHANGE))
            {
                ACCESS_MASK SavedGrantedAccess;
                BOOLEAN     SavedAuditOnClose;
                SAMP_DEFINE_SAM_ATTRIBUTE_BITMASK(SavedWriteGrantedAccessAttributes);
           

                DesiredAccess &= ~(USER_FORCE_PASSWORD_CHANGE);

                
                SavedGrantedAccess = Context->GrantedAccess;
                SavedAuditOnClose  = Context->AuditOnClose;
                SAMP_COPY_SAM_ATTRIBUTE_BITMASK(SavedWriteGrantedAccessAttributes,
                    Context->WriteGrantedAccessAttributes);

                NtStatus = SampValidateObjectAccess2(
                                     Context,
                                     USER_FORCE_PASSWORD_CHANGE,
                                     NULL,
                                     FALSE,
                                     FALSE,
                                     TRUE
                                     );

                
                Context->GrantedAccess = SavedGrantedAccess;
                Context->AuditOnClose  = SavedAuditOnClose;
                SAMP_COPY_SAM_ATTRIBUTE_BITMASK(Context->WriteGrantedAccessAttributes,
                    SavedWriteGrantedAccessAttributes);

                if (!NT_SUCCESS(NtStatus)) {
                    return(NtStatus);
                }
            }

        }

        //
        // Validate the general SAM level accesses.
        //
        if (DesiredAccess != 0)  {

            if (!RtlAreAllAccessesGranted( Context->GrantedAccess, DesiredAccess)) {
                return(STATUS_ACCESS_DENIED);
            }
        }

    }


    //
    // Make sure the client has access to the requested attributes
    //
    if ( (!Context->TrustedClient) ) {

        if (RequestedAttributeAccess) {

            if (!SampIsAttributeAccessGranted(&Context->WriteGrantedAccessAttributes, RequestedAttributeAccess)) {
                return(STATUS_ACCESS_DENIED);
            }

        }
    }


    if (NT_SUCCESS(NtStatus)) {

        ULONG ReferenceCount = 1;

        //
        // Reference the context
        //

        ReferenceCount = InterlockedIncrement(&Context->ReferenceCount);
        ASSERT(ReferenceCount>1);
    }


    return(NtStatus);

}





VOID
SampReferenceContext(
    IN PSAMP_OBJECT Context
    )

/*++

Routine Description:

    This service increments a context block's reference count.

    THIS SERVICE MUST BE CALLED WITH THE SampLock HELD FOR WRITE ACCESS.


Arguments:

    Context - Pointer to the context block to dreference.

Return Value:

    None.

--*/
{
    SAMTRACE("SampReferenceContext");

    InterlockedIncrement(&Context->ReferenceCount);

    return;
}


NTSTATUS
SampDeReferenceContext2(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN Commit
    )
/*++

  Routine Description

    This routine is a fast dereference that can be used for domain context's
    that can be potentially shared across multiple thread's and can be called
    without the SAM lock held, provided the caller is very careful never to
    modify any field of the domain context except the reference count. This
    routine cannot be used for other types of Context's. For lockless operation
    the only safe way for account context's is to not share the handles across
    calls. In registry mode this reverts to SampDeReferenceContext below.

    The only SAM API Calls that can call this are

        SamIGetUserLogonInformation
        SamIGetAliasMembership
        SamIGetResourceGroupsTransitive
        SamrGetAliasMembership
        SamrLookupNamesInDomain
        SamrLookupIdsInDomain
        SamIOpenAccount


   All of these API are very careful to not do anything to the domain handle except
   to reference or dereference.

   Arguments


     Context -- Open handle to a domain object
     Commit  -- Boolean specifying whether to commit or not.

   Return Values

    STATUS_SUCCESS - The service completed successfully.

    Errors may be returned from SampDereferenceContextInRegistryMode below

--*/
{

    ULONG    ReferenceCount=0;

    //
    // Registry mode => Call the normal API
    //

    if (!IsDsObject(Context))
    {
        return(SampDeReferenceContext(Context,Commit));
    }

    //
    // DS mode, assert that it is a domain context
    //

    ASSERT(SampDomainObjectType==Context->ObjectType);

    //
    // Drop the reference count by 1
    //

    ReferenceCount = InterlockedDecrement(&Context->ReferenceCount);

    //
    // The reference count should not drop to a 0
    //

    ASSERT(0!=ReferenceCount);

    return(STATUS_SUCCESS);
}



NTSTATUS
SampDeReferenceContext(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN Commit
    )

/*++

Routine Description:

    This service decrements a context block's reference count.
    If the reference count drops to zero, then the MarkedForDelete
    flag is checked.  If it is true, then the context block is
    deallocated.

    The attribute buffers are always deleted.


Arguments:

    Context - Pointer to the context block to de-reference.

    Commit - if TRUE, the attribute buffers will be added to the RXACT.
        Otherwise, they will just be ignored.

Return Value:


    STATUS_SUCCESS - The service completed successfully.

    Errors may be returned from SampStoreObjectAttributes().


--*/
{
    NTSTATUS        NtStatus, IgnoreStatus;
    BOOLEAN         TrustedClient;
    BOOLEAN         LoopbackClient;
    BOOLEAN         PersistAcrossCalls;
    BOOLEAN         DirtyBuffers;
    BOOLEAN         FlushBuffers;

    SAMTRACE("SampDeReferenceContext");

    //
    // The following ASSERT is used to catch domain context dereference during
    // any lockless session. Currently, SAM allows sharing of Domain Context,
    // but only the thread owns SAM lock can call SampDereferenceContext to
    // delete attribute buffers. For any locklese thread, to dereference Domain
    // Context, they need to call SampDeReferenceContext2().
    //

    // 
    // either the lock is held, or the context is not shared across threads
    // 


    ASSERT(!IsDsObject(Context) ||
           SampCurrentThreadOwnsLock() || 
           Context->NotSharedByMultiThreads
           );

    ASSERT( Context->ReferenceCount != 0 );
    InterlockedDecrement(&Context->ReferenceCount);

    TrustedClient = Context->TrustedClient;
    LoopbackClient = Context->LoopbackClient;
    PersistAcrossCalls   = Context->PersistAcrossCalls;


    //
    // Buffers are dirty if either the fixed or the variable attributes
    // are dirty
    //

    DirtyBuffers  = (Context->FixedDirty)
                        || (Context->VariableDirty);


    //
    // We will flush buffers if
    //      1. Commit is specified AND
    //      2. Buffers are Dirty AND
    //      3. If no sticky cache is specified OR
    //      4. If sticky cache is specified then flush the buffer if its
    //         reference count drops to 0.
    //

    FlushBuffers  = ((Commit) &&  (DirtyBuffers) && (!Context->BufferWrites));

    NtStatus = STATUS_SUCCESS;

    if ( Context->OnDisk != NULL ) {

        //
        // There are attribute buffers for this context.  Flush them if
        // asked to do so.
        // Use existing open keys
        //

        if ( FlushBuffers ) {

            NtStatus = SampStoreObjectAttributes(Context, TRUE);

        } else if (!Commit) {

            //
            // If we aren't committing, then the data doesn't need to be flushed
            // hence reset the Dirty fields. Note that SampFreeAttributeBuffer 
            // will assert otherwise.
            //
            Context->FixedDirty = FALSE;
            Context->VariableDirty = FALSE;
        }

        //
        // Free the buffer that was being used to hold attributes.
        // If StickyCache was asked for in the context, perform the
        // free only if the reference count is about to go to 0, or
        // if the attribute buffers were dirty, or if the commit failed
        //

        if ((Context->ReferenceCount == 0) 
         || (!PersistAcrossCalls) 
         || (FlushBuffers) 
         || (!Commit) ) 
        {

            SampFreeAttributeBuffer( Context );
            if (SampUserObjectType==Context->ObjectType)
            {
                if (NULL!=Context->TypeBody.User.CachedSupplementalCredentials)
                    MIDL_user_free(Context->TypeBody.User.CachedSupplementalCredentials);
                Context->TypeBody.User.CachedSupplementalCredentials
                    = NULL;
                Context->TypeBody.User.CachedSupplementalCredentialLength =0;
                Context->TypeBody.User.CachedSupplementalCredentialsValid = FALSE;
            }

        }
    }


    if (Context->ReferenceCount == 0) {

        //
        // ReferenceCount has dropped to 0, see if we should delete this
        // context.
        //

        ASSERT(Context->MarkedForDelete);

        if (Context->MarkedForDelete == TRUE) {

            PVOID    ElementInActiveContextTable = 
                            Context->ElementInActiveContextTable;

            Context->ElementInActiveContextTable = NULL; 

            //
            // For Group and Alias Object, release CachedMembershipOperationsList
            // for User Object, release CachedOrigUserParms
            //

            switch (Context->ObjectType) {

            case SampUserObjectType:

                if (NULL != Context->TypeBody.User.CachedOrigUserParms)
                {
                    MIDL_user_free(Context->TypeBody.User.CachedOrigUserParms);
                    Context->TypeBody.User.CachedOrigUserParms = NULL;
                }

                Context->TypeBody.User.CachedOrigUserParmsLength = 0;
                Context->TypeBody.User.CachedOrigUserParmsIsValid = FALSE;

                SampFreeSupplementalCredentialList(Context->TypeBody.User.SupplementalCredentialsToWrite);
                Context->TypeBody.User.SupplementalCredentialsToWrite = NULL;

                if (NULL!=Context->TypeBody.User.UPN.Buffer)
                {
                    MIDL_user_free(Context->TypeBody.User.UPN.Buffer);
                }

                break;

            case SampGroupObjectType:

                SampDsFreeCachedMembershipOperationsList(Context);

                break;

            case SampAliasObjectType:

                SampDsFreeCachedMembershipOperationsList(Context);

                break;

            default:
                ;
            }

            //
            // Close the context block's root key.
            // Domain and server contexts contain root key
            // handles that are shared - so don't clean-up these
            // if they match the ones in memory.
            //

            switch (Context->ObjectType) {

            case SampServerObjectType:

                if ((Context->RootKey != SampKey) &&
                    (Context->RootKey != INVALID_HANDLE_VALUE)) {

                    IgnoreStatus = NtClose( Context->RootKey );
                    ASSERT(NT_SUCCESS(IgnoreStatus));
                }
                break;

            case SampDomainObjectType:
                if (IsDsObject(Context))
                {

                    //
                    // Free the Restart structure in display state
                    //

                    if (NULL!=
                            Context->TypeBody.Domain.DsDisplayState.Restart)
                    {
                        MIDL_user_free(Context->TypeBody.Domain.DsDisplayState.Restart);
                        Context->TypeBody.Domain.DsDisplayState.Restart = NULL;
                    }

                    //  Do Not do this as the object name in
                    //  in Domain Context actually references the one in
                    //  PSAMP_DEFINED_DOMAINS
                    //
                    // Free the DsName
                    // MIDL_user_free(Context->ObjectNameInDs);
                    // Context->ObjectNameInDs = NULL;

                }
                else
                {

                    // Free all the Key Stuff
                    if ((Context->RootKey != SampDefinedDomains[Context->DomainIndex].Context->RootKey) &&
                        (Context->RootKey != INVALID_HANDLE_VALUE))
                    {

                        IgnoreStatus = NtClose( Context->RootKey );
                        ASSERT(NT_SUCCESS(IgnoreStatus));
                    }
                }

                break;

            default:

                if (IsDsObject(Context))
                {
                    // Free the DSName
                    MIDL_user_free(Context->ObjectNameInDs);
                    Context->ObjectNameInDs = NULL;
                }
                else
                {

                    //
                    // Close the root key handle
                    //

                    if (Context->RootKey != INVALID_HANDLE_VALUE)
                    {

                        IgnoreStatus = NtClose( Context->RootKey );
                        ASSERT(NT_SUCCESS(IgnoreStatus));
                    }

                    //
                    // Free the root key name
                    //

                    SampFreeUnicodeString( &(Context->RootName) );
                }
            }


#if SAMP_DIAGNOSTICS
            IF_SAMP_GLOBAL( CONTEXT_TRACKING ) {
                SampDiagPrint( CONTEXT_TRACKING, ("Deallocating  ") );
                if (Context->ObjectType == SampServerObjectType) SampDiagPrint(CONTEXT_TRACKING, ("Server "));
                if (Context->ObjectType == SampDomainObjectType) SampDiagPrint(CONTEXT_TRACKING, (" Domain "));
                if (Context->ObjectType == SampGroupObjectType)  SampDiagPrint(CONTEXT_TRACKING, ("  Group "));
                if (Context->ObjectType == SampAliasObjectType)  SampDiagPrint(CONTEXT_TRACKING, ("   Alias "));
                if (Context->ObjectType == SampUserObjectType)   SampDiagPrint(CONTEXT_TRACKING, ("    User "));
                SampDiagPrint(CONTEXT_TRACKING, ("context : 0x%lx\n", Context ));
    }
#endif //SAMP_DIAGNOSTICS

            MIDL_user_free( Context );


            //
            // For TrustedClient or LoopbackClient, ElementInActiveContextTable 
            // should be NULL
            // 
            ASSERT((!TrustedClient && !LoopbackClient) || 
                   (NULL == ElementInActiveContextTable) );

            //
            // Decrement the number of active opens
            //

            if (!TrustedClient && !LoopbackClient) {

                SampDecrementActiveContextCount(
                        ElementInActiveContextTable
                        );

            }

        }
    }

#if DBG
    //
    // Make sure a commit worked.
    //

    if (Commit) {
        if (!NT_SUCCESS(NtStatus)) {
            SampDiagPrint(DISPLAY_STORAGE_FAIL,
                          ("SAM: Commit failure, status: 0x%lx\n",
                          NtStatus) );
            IF_SAMP_GLOBAL( BREAK_ON_STORAGE_FAIL ) {
                ASSERT(NT_SUCCESS(NtStatus));
            }
        }
    }
#endif //DBG


    return( NtStatus );
}


VOID
SampInvalidateContextAddress(
    IN PSAMP_OBJECT Context
    )

/*++

Routine Description:

    This service removes a context from the set of valid contexts.

    Note that we may have already removed the context.  This is not an
    error is expected to happen in the case where an object (like a user
    or group) is deleted out from under an open handle.



    THIS SERVICE MUST BE CALLED WITH THE SampLock HELD FOR WRITE ACCESS.


Arguments:

    Context - Pointer to the context block to be removed from the set
        of valid contexts.  The ObjectType field of this context must
        be valid.

Return Value:

    None.



--*/
{

    SAMTRACE("SampInvalidateContextAddress");


    ASSERT( (Context->ObjectType == SampUserObjectType)    ||
            (Context->ObjectType == SampGroupObjectType)   ||
            (Context->ObjectType == SampAliasObjectType)   ||
            (Context->ObjectType == SampDomainObjectType)  ||
            (Context->ObjectType == SampServerObjectType)
          );

    Context->Valid = FALSE;

}




#ifdef SAMP_DIAGNOSTICS
VOID
SampDumpContext(
    IN PSAMP_OBJECT Context
    )


/*++

Routine Description:

    This service prints out info on a context to debugger

Arguments:

    Context - a context

Return Value:

    None.



--*/
{
    PSTR Type = NULL;

    switch (Context->ObjectType) {
    case SampServerObjectType:
        Type = "S";
        break;
    case SampDomainObjectType:
        if (Context == SampDefinedDomains[Context->DomainIndex].Context) {
            Type = "d";
        } else {
            Type = "D";
        }
        break;
    case SampUserObjectType:
        Type = "U";
        break;
    case SampAliasObjectType:
        Type = "A";
        break;
    case SampGroupObjectType:
        Type = "G";
        break;
    }

    KdPrintEx((DPFLTR_SAMSS_ID,
               DPFLTR_INFO_LEVEL,
               "%s 0x%8x  %2d  0x%8x  %s %s %s %wZ\n",
               Type,
               Context,
               Context->ReferenceCount,
               Context->RootKey,
               Context->MarkedForDelete ? "D": " ",
               Context->Valid ? "  ": "NV",
               Context->TrustedClient ? "TC": "  ",
               &Context->RootName));
}


VOID
SampDumpContexts(
    VOID
    )

/*++

Routine Description:

    Prints out info on all contexts

Arguments:


Return Value:

    None.

--*/
{
    PLIST_ENTRY     NextEntry;
    PLIST_ENTRY     Head;
    ULONG Servers = 0;
    ULONG Domains = 0;
    ULONG DomainUsers = 0;
    ULONG DomainAliases = 0;
    ULONG DomainGroups = 0;


    Head = &SampContextListHead;
    NextEntry = Head->Flink;
    while (NextEntry != Head) {

        PSAMP_OBJECT    NextContext;

        NextContext = CONTAINING_RECORD(
                          NextEntry,
                          SAMP_OBJECT,
                          ContextListEntry
                          );

        switch (NextContext->ObjectType) {
        case SampServerObjectType:
            (Servers)++;
            break;
        case SampDomainObjectType:
            (Domains)++;
            break;
        case SampUserObjectType:
            (DomainUsers)++;
            break;
        case SampGroupObjectType:
            (DomainGroups)++;
            break;
        case SampAliasObjectType:
            (DomainAliases)++;
            break;
        default:
            ASSERT(FALSE);
            break;
        }

        SampDumpContext(NextContext);

        NextEntry = NextEntry->Flink;
    }


    KdPrintEx((DPFLTR_SAMSS_ID,
               DPFLTR_INFO_LEVEL,
               "     Server = %4d Domain = %4d\n",
               Servers,
               Domains));

    KdPrintEx((DPFLTR_SAMSS_ID,
               DPFLTR_INFO_LEVEL,
               "     Users = %4d Groups = %4d Aliases = %4d\n",
               DomainUsers,
               DomainAliases,
               DomainGroups));

}
#endif  //SAMP_DIAGNOSTICS



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service Implementations                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


VOID
SampAddNewValidContextAddress(
    IN PSAMP_OBJECT NewContext
    )


/*++

Routine Description:

    This service adds the new context to the set of valid contexts.


    THIS SERVICE MUST BE CALLED WITH THE SampLock HELD FOR WRITE ACCESS.


Arguments:

    NewContext - Pointer to the context block to be added to the set
        of valid contexts.  The ObjectType field of this context must
        be set.


Return Value:

    None.



--*/
{
    SAMTRACE("SampAddNewValidContextAddress");

    ASSERT( (NewContext->ObjectType == SampUserObjectType)    ||
            (NewContext->ObjectType == SampGroupObjectType)   ||
            (NewContext->ObjectType == SampAliasObjectType)   ||
            (NewContext->ObjectType == SampDomainObjectType)  ||
            (NewContext->ObjectType == SampServerObjectType)
          );


    NewContext->Valid = TRUE;
    NewContext->Signature = SAMP_CONTEXT_SIGNATURE;


}



NTSTATUS
SampValidateContextAddress(
    IN PSAMP_OBJECT Context
    )

/*++

Routine Description:

    This service checks to make sure a context is still valid.

    Note that even though RPC still thinks we have a context related
    to a SAM_HANDLE, we may, in fact, have deleted it out from under
    the user.  Since there is no way to inform RPC of this, we must
    suffer, and wait until RPC calls us (either with a call by the client
    or to rundown the context handle). but there apparently
    isn't any other way around it.



    WARNING - IT IS ASSUMED THE CONTEXT WAS ONCE VALID.  IT MAY HAVE
              BEEN INVALIDATED, BUT IF  YOU ARE CALLING THIS ROUTINE
              IT BETTER STILL HAVE A NON-ZERO REFERENCE COUNT.  THIS
              COULD BE CHANGED IN THE FUTURE, BUT IT WOULD REQUIRE
              KEEPING A LIST OF VALID DOMAINS AND PERFORMING THE BULK
              OF THIS ROUTINE INSIDE A TRY-EXCEPT CLAUSE.  YOU COULD
              LOCATE THE CONTEXT'S DOMAIN (WHICH MIGHT ACCESS VIOLATE)
              AND THEN MAKE SURE THAT DOMAIN IS VALID.  THEN WALK THAT
              DOMAIN'S LIST TO ENSURE THE USER OR GROUP IS VALID.

    THIS SERVICE MUST BE CALLED WITH THE SampLock HELD FOR WRITE ACCESS.


Arguments:

    Context - Pointer to the context block to be validated as still being
        a valid context.  The ObjectType field of this context must
        be valid.

Return Value:

    STATUS_SUCCESS - The context is still valid.

    STATUS_INVALID_HANDLE - The context is no longer valid and the handle
        that caused the reference should be invalidated as well.  When the
        handle is invalidated, the context should be closed (deleted).

    STATUS_NO_SUCH_CONTEXT - This value is not yet returned by this routine.
        It may be added in the future to distinguish between an attempt to
        use a context that has been invalidated and an attempt to use a
        context that doesn't exist.  The prior being a legitimate condition,
        the later representing a bug-check condition.



--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    SAMTRACE("SampValidateContextAddress");


    __try {

        ASSERT(Context!=NULL);

        ASSERT( (Context->ObjectType == SampUserObjectType)    ||
                (Context->ObjectType == SampGroupObjectType)   ||
                (Context->ObjectType == SampAliasObjectType)   ||
                (Context->ObjectType == SampDomainObjectType)  ||
                (Context->ObjectType == SampServerObjectType)
              );


        if (SAMP_CONTEXT_SIGNATURE != Context->Signature) {
            return(STATUS_INVALID_HANDLE);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        NtStatus = STATUS_INVALID_HANDLE;
    }

    return(NtStatus);

}

NTSTATUS
SampCheckIfObjectExists(
                        IN  PSAMP_OBJECT    Context
                        )
/*++

  Routine Description:

        Checks to see if the object exists in the DS/ Registry.
        Will fill out the following information

            1. If DS object its DSNAME, which must exist
            2. If Registry object, Open its Root Key and fill out
               the handle of the Root Key in the registry.

  IMPORTANT NOTE:

     In the Registry Case of SAM once the key is open nobody can
     delete the object. However in the DS case this is not so. Currently
     we have only the DS Name of the Object in Hand, and we have no way
     of Locking the Object, for access. Since this is the case

  Arguments:
        Context -- Pointer to a Context block desribing the Object
            Rid -- Rid of the desired Object

  Return Values:
        STATUS_SUCCESS if everything succeeds
        Error codes from Registry Manipulation / DsLayer.
--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG    Rid = 0;



    //
    // Check wether the Object is located or not.
    // Location is the process of finding out
    //      1. DSNAME of the object if it is in the DS. An object with this
    //         DSNAME must exist.
    //
    //      2. The Root Key HANDLE of the Object if it is in the Registry
    //

    if (!SampIsObjectLocated(Context)) {

        //
        // No we first need to locate the Object.
        // This is done by using the Rid for Account Objects
        // For Domain Objects we already cache all the defined domains, so fill out
        // From the Cache
        // BUG: For Server Objects Don't know what to do.
        //

        switch (Context->ObjectType) {

        case SampGroupObjectType:
            SampDiagPrint( CONTEXT_TRACKING, ("SAM: Reopened group handle <%wZ>,", &Context->RootName));
            Rid = Context->TypeBody.Group.Rid;
            break;

        case SampAliasObjectType:
            SampDiagPrint( CONTEXT_TRACKING, ("SAM: Reopened alias handle <%wZ>,", &Context->RootName));
            Rid = Context->TypeBody.Alias.Rid;
            break;

        case SampUserObjectType:
            SampDiagPrint( CONTEXT_TRACKING, ("SAM: Reopened user handle <%wZ>,", &Context->RootName));
            Rid = Context->TypeBody.User.Rid;
            break;

        case SampDomainObjectType:

            //
            // Domain objects share the root key and the object name in the DS that
            // we keep around in the in memory domain context for each domain
            //


            ASSERT(Context != SampDefinedDomains[Context->DomainIndex].Context);

            Context->RootKey = SampDefinedDomains[Context->DomainIndex].Context->RootKey;
            Context->ObjectNameInDs = SampDefinedDomains[Context->DomainIndex].Context->ObjectNameInDs;
            Context->ObjectNameInDs = SampDefinedDomains[Context->DomainIndex].Context->ObjectNameInDs;

            ASSERT(SampIsObjectLocated(Context));

            SampDiagPrint( CONTEXT_TRACKING, ("SAM: Recopied domain context handle <%wZ>, 0x%lx\n", &Context->RootName, Context->RootKey));
            goto ObjectLocated;

        case SampServerObjectType:

            //
            // Server objects share our global root key
            //


            Context->RootKey = SampKey;
            ASSERT(SampIsObjectLocated(Context));

            SampDiagPrint( CONTEXT_TRACKING, ("SAM: Recopied server context handle <%wZ>, 0x%lx\n", &Context->RootName, Context->RootKey));
            goto ObjectLocated;

        default:
            
            ASSERT(FALSE && "Invalid Object Type\n");
            NtStatus = STATUS_INVALID_PARAMETER;
            goto ObjectLocated;

        }

        //
        // Go open the appropriate account key/ or find object Name from RID
        //
        ASSERT(Rid && "Rid not initialized\n");

        NtStatus = SampLocateObject(Context, Rid);

ObjectLocated:
        ;;



    }

    return NtStatus;
}


BOOLEAN
SampIsObjectLocated(
                    IN  PSAMP_OBJECT Context
                    )
/*++

  Description:
        Checks if an object has been located in the DS or in the registry
        An Object being Located implies the Following
            1. For a DS Object we have the DS Name
            2. For a Registry Object we have a Valid Open Registry Key for
               the Object.

  Arguments:
        Context -- Pointer to a Context block desribing the Object

  Return Values:
        TRUE -- If Conditions above are satisfied
        FALSE -- If Conditions above are not satisfied
--*/
{
    if (IsDsObject(Context))
        return (Context->ObjectNameInDs != NULL);
    else
        return (Context->RootKey != INVALID_HANDLE_VALUE);
}


NTSTATUS
SampLocateObject(
                 IN PSAMP_OBJECT Context,
                 IN ULONG   Rid
                 )
/*++

  Description:
        Uses the Rid to find the Object in either the DS or
        the Registry.


  NOTE:
        This routine is meaningful for Context's that represent
        Account Objects Only.

  Arguments:
        Context -- Pointer to a Context block desribing the Object
            Rid -- Rid of the desired Object

  Return Values:
        STATUS_SUCCESS if everything succeeds
        Error codes from Registry Manipulation / DsLayer.
--*/

{

   NTSTATUS Status = STATUS_SUCCESS;
   PSAMP_OBJECT  DomainContext = NULL;
   OBJECT_ATTRIBUTES ObjectAttributes;



   //
   //  This routine can be called only for Account Objects
   //

   ASSERT((Context->ObjectType == SampGroupObjectType)
            || (Context->ObjectType == SampAliasObjectType)
            || (Context->ObjectType == SampUserObjectType)
            );

   //
   // Get the Domain Object, as we will need this to find out
   // to find out in which domain we look for the Rid.
   //
   DomainContext = SampDefinedDomains[Context->DomainIndex].Context;

   // Now Make the Decision
   if (IsDsObject(Context))
   {
       //
       // Object is in the DS
       //

       // Look it up using the Rid
       Status = SampDsLookupObjectByRid(DomainContext->ObjectNameInDs, Rid, &Context->ObjectNameInDs);
       if (!NT_SUCCESS(Status))
       {
           Context->ObjectNameInDs = NULL;
       }

   }
   else
   {
       // Object Should be in Registry
       SetRegistryObject(Context);
       InitializeObjectAttributes(
                        &ObjectAttributes,
                        &Context->RootName,
                        OBJ_CASE_INSENSITIVE,
                        SampKey,
                        NULL
                        );

       SampDumpNtOpenKey((KEY_READ | KEY_WRITE), &ObjectAttributes, 0);

       // Try opening the Key
       Status = RtlpNtOpenKey(
                           &Context->RootKey,
                           (KEY_READ | KEY_WRITE),
                           &ObjectAttributes,
                           0
                           );

        if (!NT_SUCCESS(Status))
        {
            Context->RootKey = INVALID_HANDLE_VALUE;
        }
   }

   return Status;

}







PVOID
SampActiveContextTableAllocate(
    ULONG   BufferSize
    )
/*++
Routine Description:

    This routine is used by RtlGenericTable2 to allocate memory
    
Parameters:

    BufferSize - indicates the size of memory to be allocated. 
    
Return Values:

    Address of the buffer

--*/
{
    PVOID   Buffer = NULL;

    Buffer = MIDL_user_allocate(BufferSize);

    return( Buffer );
}



VOID
SampActiveContextTableFree(
    PVOID   Buffer
    )
/*++
Routine Description:

    This routine frees the memory used by RtlGenericTable2
    
Arguments:
    
    Buffer - address of the buffer
    
Return Value:

    None

--*/
{
    MIDL_user_free(Buffer);

    return;
}


RTL_GENERIC_COMPARE_RESULTS
SampActiveContextTableCompare(
    PVOID   Node1,
    PVOID   Node2
    )
/*++
Routine Description:

    This routine is used by RtlGenericTable2 to compare two nodes. 
    We use SID to do the comparasion. 
    
Parameters:

    Node1 - first element in the table 
    Node2 - pointer to the second element in the table

Return Values:

    GenericEqual, GenericGreaterThan, GenericLessThan

--*/
{
    PSID    Sid1 = NULL;
    PSID    Sid2 = NULL;
    ULONG   Length1, Length2;

    Sid1 = ((SAMP_ACTIVE_CONTEXT_TABLE_ELEMENT *)Node1)->ClientSid;
    Sid2 = ((SAMP_ACTIVE_CONTEXT_TABLE_ELEMENT *)Node2)->ClientSid;

    Length1 = RtlLengthSid(Sid1);
    Length2 = RtlLengthSid(Sid2);

    if (Length1 <  Length2)
    {
        return GenericLessThan;
    }
    else if (Length1 > Length2)
    {
        return GenericGreaterThan;
    }
    else
    {
        LONG   Result;
        Result = memcmp(Sid1, Sid2, Length1);
        if (Result == 0)
        {
            return(GenericEqual);
        }
        else if (Result > 0 )
        {
            return(GenericGreaterThan);

        }
        else
        {
            return(GenericLessThan);
        }
    }
}



VOID
SampInitializeActiveContextTable(
    )
/*++
Routine Description:

    initialize Active Context Table 
    
Paramenters:

    None
    
Return Values:

    None

--*/
{

    RtlInitializeGenericTable2(
                &SampActiveContextTable,
                SampActiveContextTableCompare,
                SampActiveContextTableAllocate,
                SampActiveContextTableFree
                );
}

NTSTATUS
SampCreateActiveContextTableElement(
    IN PSID pSid, 
    OUT PSAMP_ACTIVE_CONTEXT_TABLE_ELEMENT  *ppElement
    )
/*++
Routine Description:

    This routine creates an element for the Active Context Table. 
    Allocate the memory for the element, also set the SID fields
    
Parameters:

    pSid - SID of the current client
    
    ppElement - returns the element is succeeded.
    
Return Values:

    NtStatus

    ppElement - caller is responsible to free it

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    *ppElement = MIDL_user_allocate(sizeof(SAMP_ACTIVE_CONTEXT_TABLE_ELEMENT));

    if (NULL == *ppElement)
    {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }

    memset(*ppElement, 0, sizeof(SAMP_ACTIVE_CONTEXT_TABLE_ELEMENT));

    (*ppElement)->ActiveContextCount = 0;
    (*ppElement)->ClientSid = pSid;

    return( NtStatus );
}




PVOID
SampLookupElementInTable(
    IN RTL_GENERIC_TABLE2   *pTable, 
    IN PVOID    pElement, 
    IN ULONG    MaximumTableElements,
    OUT BOOLEAN *fNewElement
    )
/*++
Routine Description:

    This routine looks up the element in table. Returns the pointer to the 
    element in table if lookup succeeded. Otherwise, if failed to find 
    the element, then inserts this element into table. 
    
    We will check how much elements in the table before inserting the 
    new element 
     
Parameter:

    pTable - pointer to the table 
    
    pElement - pointer to the element needs to be looked up. or new element

    MaximumTableElements - Upper limits of the table entries.
    
    fNewElement - used to indicate whether the element is a new one or exists 
                  already


Return Values:

    if success, returns the pointer to the element in the table 
    if not. returns NULL

--*/
{
    PVOID   OldElement = NULL;
    ULONG   MaxEntries = 0;
    

    *fNewElement = FALSE;

    //
    // lookup the element in the table first
    // 
    OldElement = RtlLookupElementGenericTable2(
                    pTable, 
                    pElement
                    );

    if (OldElement)
    {
        //
        // found the element, return now
        // 
        return(OldElement);
    }
    else
    {
        //
        // new element
        // check how many clients in table now
        // 
        MaxEntries = RtlNumberElementsGenericTable2(pTable);

        if (MaxEntries > MaximumTableElements)
        {
            //
            // Total number of elements (clients) in Table exceed
            // maximum allowed
            // 
            return( NULL );
        }

        //
        // insert the new element
        // 
        (VOID) RtlInsertElementGenericTable2(
                        pTable, 
                        pElement, 
                        fNewElement
                        );

        ASSERT(*fNewElement);

        return( pElement );
    }
}



NTSTATUS
SampIncrementActiveContextCount(
    PSAMP_OBJECT    Context
    )
/*++

Routine Description:

    This routine impersonates client, gets the user's SID fromm the token
    and keep it is the active Context table. 
    
    if SID is already in table, need to increment ActiveContextCount. If 
    SID is not in the table yet, then add it. 
    
    This routine will fail in the following conditions, 
    
    1. this user's ActiveContextCount exceed the limit. 
    2. total elements in table exceed limit
    
    Note: 
    
    1. TrustedClient or LoopbackClient should not fall into this routine. 
    2. Need to acquire SAM Lock when doing any update

Parameters: 

    Context - pointer to the context to be created
    
Return Values:

    NtStatus

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    BOOLEAN     fNewElement = FALSE;
    BOOLEAN     fLockAcquired = FALSE;
    PSID        pSid = NULL;
    PSAMP_ACTIVE_CONTEXT_TABLE_ELEMENT   pElement = NULL, ElementInTable = NULL;
    BOOL        Administrator = FALSE;


    // 
    // Set initial value
    //  

    Context->ElementInActiveContextTable = NULL;


    //
    // Get current client SID 
    // 

    NtStatus = SampGetCurrentClientSid(NULL,&pSid, &Administrator);
    if (!NT_SUCCESS(NtStatus)) {

        goto Error;
    }


    //
    // do NOT apply this restriction on LocalSystem or Administrator Account
    // 

    if (RtlEqualSid(pSid, SampLocalSystemSid) || 
        RtlEqualSid(pSid, SampAdministratorUserSid) )
    {
        goto Error;
    }


    // 
    // Create a table element used to lookup or insert
    // 

    NtStatus = SampCreateActiveContextTableElement(
                    pSid, 
                    &pElement
                    );
    if (!NT_SUCCESS(NtStatus)) {

        goto Error;
    }


    //
    // Acquire SAM Lock exclusive
    // 

    if (!SampCurrentThreadOwnsLock())
    {
        SampAcquireSamLockExclusive();
        fLockAcquired = TRUE;
    }


    //
    // Lookup or insert this element as a new client
    //

    ElementInTable = SampLookupElementInTable(
                            &SampActiveContextTable,
                            pElement,
                            SAMP_MAXIMUM_CLIENTS_COUNT,
                            &fNewElement
                            );

    if (NULL == ElementInTable)
    {
        //
        // failed due to SAMP_MAXIMUM_CLIENTS_COUNT exceeded 
        // 
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        fNewElement = FALSE;
        goto Error;
    }


    if (ElementInTable->ActiveContextCount >= 
        SAMP_PER_CLIENT_MAXIMUM_ACTIVE_CONTEXTS)
    {
        //
        // Active Contexts exceed maximum allowed 
        // 

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        ASSERT(FALSE == fNewElement);
    }
    else
    {
        //
        // Increment Active Context Count by 1
        // And keep the pointer to the Element in Context
        // so that we can access this element without
        // lookup again during context dereference.
        // 

        ElementInTable->ActiveContextCount ++;
        Context->ElementInActiveContextTable = ElementInTable;
    }


Error:

    //
    //  Release SAM lock if necessary
    // 
    if (fLockAcquired)
    {
        SampReleaseSamLockExclusive();
    }


    //
    // clean up
    // 
    if (!fNewElement)
    {
        if (pSid)
            MIDL_user_free(pSid);

        if (pElement)
            MIDL_user_free(pElement);
    }

    ASSERT(!fNewElement || (pElement == Context->ElementInActiveContextTable));

    return(NtStatus);
}




VOID
SampDecrementActiveContextCount(
    PVOID   ElementInActiveContextTable
    )
/*++

Routine Description: 

    This routines is called during Context deletion. It decrements
    ActiveContextCount, if ref count drops to 0 then remove if from the
    table.  


Parameters:

    ClientSid - pointer to the user SID
    
Return Value: 
    
    NtStatus

--*/
{
    BOOLEAN     Success, fLockAcquired = FALSE;
    SAMP_ACTIVE_CONTEXT_TABLE_ELEMENT   *Element = ElementInActiveContextTable;
    BOOL        Administrator = FALSE;


    //
    // LocalSystem and Administrator 
    // 
    if (NULL == Element) {

#ifdef DBG
    {
        NTSTATUS    NtStatus = STATUS_SUCCESS;
        PSID        pSid = NULL;

        NtStatus = SampGetCurrentClientSid(NULL,&pSid, &Administrator);
        if (NT_SUCCESS(NtStatus))
        {
            ASSERT(RtlEqualSid(pSid, SampLocalSystemSid) ||
                   RtlEqualSid(pSid, SampAdministratorUserSid) );

            MIDL_user_free(pSid);
        }
    }
#endif // DBG

        return;
    }

    //
    // Acquire SAM Lock exclusive
    // 
    if (!SampCurrentThreadOwnsLock())
    {
        SampAcquireSamLockExclusive();
        fLockAcquired = TRUE;
    }


    //
    // Decresment active context count
    //

    Element->ActiveContextCount--;

    //
    // Remove this entry is ref count drops to 0
    // 
    if (Element->ActiveContextCount == 0)
    {
        Success = RtlDeleteElementGenericTable2(
                        &SampActiveContextTable, 
                        Element
                        );

        ASSERT(Success);

        MIDL_user_free(Element->ClientSid);
        MIDL_user_free(Element);
    }


    //
    // Release lock if neccessary
    // 
    if (fLockAcquired)
    {
        SampReleaseSamLockExclusive();
    }

    return;
}




VOID
SampInsertContextList(
    PLIST_ENTRY ListHead,
    PLIST_ENTRY Entry
    )
/*++
Routine Description:

    This routine inserts an Entry to a double link list, pointed by 
    SampContextListHead. 
    
    To prevent multi clients contention, this routine use Critical Secition
    to guard this global link list. 
    
Parameters:

    ListHead - Pointer to the head of the link list. 

    Entry - Pointer to the entry to be inserted. 
    
Return Value:

    None

--*/
{
    NTSTATUS    IgnoreStatus = STATUS_SUCCESS;

    //
    // enter critical section
    //

    IgnoreStatus = RtlEnterCriticalSection( &SampContextListCritSect );
    ASSERT(NT_SUCCESS(IgnoreStatus));

    //
    // insert the entry to list
    // 

    InsertTailList(ListHead, Entry);

    //
    // leave critical section
    //

    RtlLeaveCriticalSection( &SampContextListCritSect );

    return;
}



VOID
SampRemoveEntryContextList(
    PLIST_ENTRY Entry
    )
/*++
Routine Description:
    
    This routine removes an entry from SampContextList 

Parameter:

    Entry - pointer to the entry to be removed. 

Return Value:

    None

--*/
{
    NTSTATUS    IgnoreStatus = STATUS_SUCCESS;

    // 
    // enter critical section
    // 

    IgnoreStatus = RtlEnterCriticalSection( &SampContextListCritSect );
    ASSERT(NT_SUCCESS(IgnoreStatus));

    //
    // the entry should be in the list already
    // 

    ASSERT((NULL != Entry->Flink) && (NULL != Entry->Blink));

    if ((NULL != Entry->Flink) && (NULL != Entry->Blink))
    {
        RemoveEntryList(Entry);
    }

    // 
    // leave critical section
    // 

    RtlLeaveCriticalSection( &SampContextListCritSect );

    return;
}




VOID
SampInvalidateObjectContexts(
    IN PSAMP_OBJECT ObjectContext,
    IN ULONG Rid
    )
/*++

Routine Description:

    This routine scans the SampContextList, find the matching object (with same
    object type and same Rid), then invalidate the context in ContextList.

Parameter: 

    ObjectContext - Pointer to object context

    Rid - Account Rid

Return Value:

    None

--*/
{
    NTSTATUS    IgnoreStatus;
    SAMP_OBJECT_TYPE    ObjectType = ObjectContext->ObjectType;
    PLIST_ENTRY     Head, NextEntry;
    PSAMP_OBJECT    NextContext;


    //
    // do nothing in DS mode
    // 

    if (IsDsObject(ObjectContext))
    {
        return;
    }

    //
    // Check passed in parameter
    // 

    if ((SampUserObjectType != ObjectType) &&
        (SampGroupObjectType != ObjectType) &&
        (SampAliasObjectType != ObjectType))
    {
        ASSERT(FALSE && "Invalid parameter");
        return;
    }

    IgnoreStatus = RtlEnterCriticalSection( &SampContextListCritSect );
    ASSERT(NT_SUCCESS(IgnoreStatus));

    //
    // Walk the list of active contexts, check for contexts with matching 
    // ObjectType and RID
    //

    Head = &SampContextListHead;
    NextEntry = Head->Flink;

    while (NextEntry != Head) 
    {
        BOOLEAN     fContextMatched = FALSE;

        NextContext = CONTAINING_RECORD(
                          NextEntry,
                          SAMP_OBJECT,
                          ContextListEntry
                          );

        //
        // check whether the current entry matches the Context or not 
        //  1) Object Type matched And  
        //  2) Object Rid equals. 
        // 

        switch (ObjectType)
        {
        case SampUserObjectType:
            fContextMatched = ((ObjectType == NextContext->ObjectType) &&
                               (Rid == NextContext->TypeBody.User.Rid) &&
                               (TRUE == NextContext->Valid));
                              
            break;
        case SampGroupObjectType:
            fContextMatched = ((ObjectType == NextContext->ObjectType) &&
                               (Rid == NextContext->TypeBody.Group.Rid) &&
                               (TRUE == NextContext->Valid));

            break;
        case SampAliasObjectType:
            fContextMatched = ((ObjectType == NextContext->ObjectType) &&
                               (Rid == NextContext->TypeBody.Alias.Rid) &&
                               (TRUE == NextContext->Valid));

            break;
        default:
            ASSERT(FALSE && "Invalid Object Type");
        }

        if ( fContextMatched )
        {
            NextContext->Valid = FALSE;

            if (NextContext->RootKey != INVALID_HANDLE_VALUE) 
            {
                IgnoreStatus = NtClose(NextContext->RootKey);
                ASSERT(NT_SUCCESS(IgnoreStatus));
                NextContext->RootKey = INVALID_HANDLE_VALUE;
            }
        }

        NextEntry = NextEntry->Flink;
    }

    RtlLeaveCriticalSection( &SampContextListCritSect );

    return;
}


VOID
SampInvalidateContextListKeysByObjectType(
    IN SAMP_OBJECT_TYPE  ObjectType,
    IN BOOLEAN  Close
    )
/*++
Routine Description:

    this routine walks the SampContextList, and invalidates all contexts with
    the same ObjectType

Parameters: 

    ObjectType - indicates which object to be invalidated.

    Close - Tells whether close the registry key or not

Return Values:

    None

--*/
{
    NTSTATUS        IgnoreStatus = STATUS_SUCCESS;
    PLIST_ENTRY     Head, NextEntry;
    PSAMP_OBJECT    NextContext;

    IgnoreStatus = RtlEnterCriticalSection( &SampContextListCritSect );
    ASSERT(NT_SUCCESS(IgnoreStatus));

    //
    // walk the active context list, invalidate the matching context 
    // 

    Head = &SampContextListHead;
    NextEntry = Head->Flink;

    while (NextEntry != Head) 
    {
        NextContext = CONTAINING_RECORD(
                          NextEntry,
                          SAMP_OBJECT,
                          ContextListEntry
                          );

        if ( ObjectType == NextContext->ObjectType )
        {
            //
            // close registry key if asked to do so.
            // 

            if (Close && (NextContext->RootKey != INVALID_HANDLE_VALUE)) 
            {
                IgnoreStatus = NtClose( NextContext->RootKey );
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }

            NextContext->RootKey = INVALID_HANDLE_VALUE;
        }

        NextEntry = NextEntry->Flink;
    }

    RtlLeaveCriticalSection( &SampContextListCritSect );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\close.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    close.c

Abstract:

    This file contains the object close routine for SAM objects.


Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <samtrace.h>





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////






NTSTATUS
SamrCloseHandle(
    IN OUT SAMPR_HANDLE * SamHandle
    )

/*++

Routine Description:

    This service closes a handle for any type of SAM object.

    Any race conditions that may occur with respect to attempts to
    close a handle that is just becoming invalid by other means are
    expected to be handled by the RPC runtime.  That is, this service
    will never be called by the RPC runtime when the handle value is
    no longer valid.  It will also never call this routine when there
    is another call outstanding with this same context handle.

Arguments:

    SamHandle - A valid handle to a SAM object.

Return Value:


    STATUS_SUCCESS - The handle has successfully been closed.

    Others that might be returned by:

                SampLookupcontext()


--*/
{
    NTSTATUS            NtStatus=STATUS_SUCCESS;
    PSAMP_OBJECT        Context;
    SAMP_OBJECT_TYPE    FoundType;
    BOOLEAN             fLockAcquired = FALSE;

    SAMTRACE_EX("SamrCloseHandle");

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidCloseHandle
                   );

    if (NULL==SamHandle)
    {
        NtStatus = STATUS_INVALID_HANDLE;
        goto Error;
    }

    Context = (PSAMP_OBJECT)(* SamHandle);

    if (NULL==Context)
    {
        NtStatus = STATUS_INVALID_HANDLE;
        goto Error;
    }

    //
    // acquire lock is necessary
    // 

    SampMaybeAcquireReadLock(Context, 
                             DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                             &fLockAcquired);

    //
    // should holds lock or the context is not shared among multi threads
    // 
    ASSERT(SampCurrentThreadOwnsLock() || Context->NotSharedByMultiThreads);

    //
    // pass -1 as DesiredAccess to indicate SampLookupContext() is called
    // during Context deletion phase.
    // 
    NtStatus = SampLookupContext(
                   Context,                     //Context
                   SAMP_CLOSE_OPERATION_ACCESS_MASK,  //DesiredAccess
                   SampUnknownObjectType,       //ExpectedType
                   &FoundType                   //FoundType
                  );


    if (NT_SUCCESS(NtStatus)) {

        ASSERT(Context->ReferenceCount>=2);

        //
        // Mark it for delete and remove the reference caused by
        // context creation (representing the handle reference).
        //

        SampDeleteContext( Context );

        //
        // And drop our reference from the lookup operation
        //

        SampDeReferenceContext( Context, FALSE );

        //
        // Tell RPC that the handle is no longer valid...
        //

        (*SamHandle) = NULL;
    }

    //
    // Free read lock
    //

    SampMaybeReleaseReadLock(fLockAcquired);


    if ( ( NT_SUCCESS( NtStatus ) ) &&
        ( FoundType == SampServerObjectType ) &&
        ( FALSE == SampUseDsData) &&
        ( !(LastUnflushedChange.QuadPart == SampHasNeverTime.QuadPart) ) ) {

        //
        // If we are registry mode and if 
        // Some app is closing the server object after having made
        // changes.  We should make sure that the changes get
        // flushed to disk before the app exits.  We need to get
        // the write lock for this.
        //

        FlushImmediately = TRUE;

        NtStatus = SampAcquireWriteLock();

        if ( NT_SUCCESS( NtStatus ) ) {

            if ( !(LastUnflushedChange.QuadPart ==SampHasNeverTime.QuadPart) ) {

                //
                // Nobody flushed while we were waiting for the
                // write lock.  So flush the changes now.
                //

                NtStatus = NtFlushKey( SampKey );

                if ( NT_SUCCESS( NtStatus ) ) {

                    FlushImmediately = FALSE;
                    LastUnflushedChange = SampHasNeverTime;
                }
            }

            SampReleaseWriteLock( FALSE );
        }
    }

    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:
    
    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidCloseHandle
                   );

    return(NtStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\attr.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    attr.c

Abstract:

    This file contains services that manipulate SAM object attributes.


    WARNING: Terminology can sometimes be confusing.  SAM objects have
             attributes (e.g., users have LogonHours, FullName, AcctName,
             et cetera).  These attributes are stored in the registry
             in registry-key-attributes.  There is NOT a one-to-one
             correllation between object-attributes and registry-key-
             attributes.  For example, all the fixed-length attributes
             of an object are stored in a single registry-key-attribute
             (whose name is pointed to by SampFixedAttributeName).


Author:

    Jim Kelly    (JimK)  26-June-1992

Environment:

    User Mode - Win32

Revision History:

    ChrisMay    04-Jun-96
        Added routines for DS data manipulation.
    ChrisMay    10-Jun-96
        Rewrote SampStoreObjectAttributes to branch to either the registry
        or DS backing store, based on the value of Context->ObjectFlags. Note
        that when a context object is created, this member is set to indicate
        registry storage by default.
    ChrisMay    18-Jun-96
        Set FlushVariable flag correctly in SampStoreDsObjectAttributes. Add-
        ed routines to validate DS data by making SampValidateAttributes a
        wrapper for SampValidateRegAttributes and SampValidateDsAttributes.
        Moved SAMP_FIXED/VARIABLE_ATTRIBUTES into dsutilp.h.
    ChrisMay    25-Jun-96
        Added code to SampValidateDsAttributes to update the SAM context
        OnDisk member if the attributes are invalid. Added code to handle
        initial case when OnDisk is NULL (new context).
    ChrisMay    26-Jun-96
        Added code to update the buffer lengths and offsets in the SAMP_-
        OBJECT and SAMP_OBJECT_INFORMATION structures after the attribute
        buffer (Context.OnDisk) has been updated during SampDsValidateAttri-
        butes.
    ChrisMay    28-Jun-96
        Finished separating the attribute accessor macros to handle both
        the registry and DS versions of the attribute buffers.
    ChrisMay    02-Jul-96
        Corrected attribute-address computation in SampObjectAttributeAddress
        for DS attributes. Corrected attribute-offset computation in Samp-
        VariableAttributeOffset for DS attributes.
    ChrisMay    19-Jul-96
        Corrected buffer-length computation in SampDsUpdateContextFixed-
        Attributes.

--*/



/*

    Each SAM object-type has an Object-type descriptor.  This is in a
    data structure called SAMP_OBJECT_INFORMATION.  This structure
    contains information that applies to all instances of that object
    type.  This includes things like a mask of write operations for
    the object type, and a name for the object type to be used in
    auditing.

    Each instance of an open SAM object has another data structure
    used to identify it (called SAMP_OBJECT).  The header of this
    structure contains information that is common to all object-types
    and is there to allow unified object manipulation.  This includes
    things like the handle to the object's registry key.

    There are fields in each of these structures that are there to
    allow generic object-attribute support routines to operate.  In
    SAMP_OBJECT, there is a pointer to a block of allocated memory
    housing a copy of the object's attributes as they are stored on-disk.
    These attributes are arbitrarily divided into two groups: fixed-length
    and variable-length.

    One of the fields in SAMP_OBJECT_INFORMATION indicates whether the
    fixed-length and variable-length attributes for that object-type
    are stored together in a single registry-key-attribute or separately
    in two registry-key-attributes.


    The registry api for querying and setting registry-key attributes are
    rather peculiar in that they require the I/O buffer to include a
    description of the data.  Even the simplest data structure for reading
    attribute values (KEY_VALUE_PARTIAL_INFORMATION) includes 3 ULONGs
    before the actual data (TitleIndex, value Type, data length,
    and then, finally, the data).  To efficiently perform registry i/o,
    the in-memory copy of the on-disk object attributes includes room
    for this information preceeding the fixed and variable-length attribute
    sections of the data.


        NOTE: For object classes that store fixed and variable-length
              data together, only the KEY_VALUE_PARTIAL_INFORMATION
              structure preceeding the fixed-length attributes is used.
              The one preceeding the variable-length attributes is
              #ifdef'd out.


    The structures related to object-attributes look like:


                        On-Disk Image
                       +-------------+               SAMP_OBJECT_INFORMATION
                   +-->|KEY_VALUE_   |              +-----------------------+
     SAMP_OBJECT   |   |PARTIAL_     |              |                       |
    +-----------+  |   |INFORMATION  |              |  (header)             |
    |           |  |   |-------------|              |                       |
    | (header)  |  |   | Fixed-Length|<-----+       |                       |
    |           |  |   | Attributes  |      |       |-----------------------|
    |-----------|  |   |             |      +-------|-< FixedAttrsOffset    |
    |  OnDisk >-|--+   |-------------+              |-----------------------|
    |-----------|      |KEY_VALUE_   |<-------------|-< VariableBuffOffset  |
    |  OnDisk   |      |PARTIAL_     |              |-----------------------|
    |  Control  |      |INFORMATION  |      +-------|-< VariableArrayOffset |
    |  Flags    |      |(Optional)   |      |       |-----------------------|
    |-----------|      |-------------|      |  +----|-< VariableDataOffset  |
    |           |      | Variable-   |<-----+  |    |-----------------------|
    |  type-    |      | Length      |         |    |VariableAttributeCount |
    |  specific |      | Attributes  |         |    |-----------------------|
    |  body     |      | Array       |         |    |FixedStoredSeparately  |
    |           |      |-------------|         |    |-----------------------|
    +-----------+      | Variable-   |<--------+    |                       |
                       | Length      |              |                       |
                       | Attributes  |              |          o            |
                       | Data        |              |          o            |
                       |             |              +-----------------------+
                       |             |
                       +-------------+




    The KEY_VALUE_PARTIAL_INFORMATION preceeding the VariableLengthAttributes
    array is marked optional because it is only present if fixed-length and
    variable-length attribute information is stored separately.  In this case,
    the VariableBufferOffset field in the SAMP_OBJECT_INFORMATION structure
    is set to be zero.

*/



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <sdconvrt.h>
#include <lmcons.h>
#include <nturtl.h>
#include <dsutilp.h>
#include <dslayer.h>
#include <attids.h>

#include <ntlsa.h>
//#include <nlrepl.h>



//
// This value indicates the minumum size block of memory to allocate
// when retrieving object attributes from disk.

#define SAMP_MINIMUM_ATTRIBUTE_ALLOC    (1000)

//
// This value is used when growing the size of the buffer containing
// object attributes.  It represents the amount of free space that
// should be left (approximately) for future growth in the buffer.
//

#define SAMP_MINIMUM_ATTRIBUTE_PAD      (200)

//
// The following line enables attribute debugging code
//

//#define SAM_DEBUG_ATTRIBUTES
//#ifdef SAM_DEBUG_ATTRIBUTES
//Boolean that allows us to turn off debugging output
//BOOLEAN SampDebugAttributes = FALSE;
//#endif

// Private debugging display routine is enabled when ATTR_DBG_PRINTF = 1.

#define ATTR_DBG_PRINTF                     0

#if (ATTR_DBG_PRINTF == 1)
#define DebugPrint printf
#else
#define DebugPrint
#endif



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private macros                                                            //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// Make sure an object type and corresponding variable-length attribute
// index are legitimate.
//

#define SampValidateAttributeIndex( c, i )   {                                      \
    ASSERT( ((c)->ObjectType < SampUnknownObjectType) );                            \
    ASSERT(((i) < SampObjectInformation[(c)->ObjectType].VariableAttributeCount) ); \
}

//
// Test to see if an object's fixed or variable-length attributes
// are in memory.
//

#define SampFixedAttributesValid( c )    ((c)->FixedValid)

#define SampVariableAttributesValid( c ) ((c)->VariableValid)

//
// Get the number of variable-length attributes defined for the
// specified object
//

#define SampVariableAttributeCount( c )                                     \
    (SampObjectInformation[(c)->ObjectType].VariableAttributeCount)

//
// Get the offset of the beginning of the attribute buffers
//

#define SampRegFixedBufferOffset( c )                                       \
    (                                                                       \
        SampObjectInformation[(c)->ObjectType].FixedAttributesOffset        \
    )

#define SampDsFixedBufferOffset( c )                                        \
    (                                                                       \
        SampObjectInformation[(c)->ObjectType].FixedDsAttributesOffset      \
    )

#define SampFixedBufferOffset( c )                                          \
    (                                                                       \
        (IsDsObject(c)) ?                                                   \
            SampDsFixedBufferOffset(c) : SampRegFixedBufferOffset(c)        \
    )

#define SampRegVariableBufferOffset( c )                                    \
    (                                                                       \
        SampObjectInformation[(c)->ObjectType].VariableBufferOffset         \
    )

#define SampDsVariableBufferOffset( c )                                     \
    (                                                                       \
        SampObjectInformation[(c)->ObjectType].VariableDsBufferOffset       \
    )

#define SampVariableBufferOffset( c )                                       \
    (                                                                       \
        (IsDsObject(c)) ?                                                   \
            SampDsVariableBufferOffset(c) : SampRegVariableBufferOffset(c)  \
    )

//
// Get the offset of the beginning of the variable data i/o buffer.
// If the fixed and variable-length attributes  are stored separately,
// then this will be the lower half of the buffer.
// Otherwise, there is only one buffer, so it is the entire allocated buffer.
//

#define SampRegFixedBufferAddress( c )                                      \
    (                                                                       \
        ((PUCHAR)((c)->OnDisk)) + SampFixedBufferOffset( c )                \
    )

#define SampDsFixedBufferAddress( c )                                       \
    (                                                                       \
        ((PUCHAR)((c)->OnDisk)) + SampDsFixedBufferOffset( c )              \
    )

#define SampFixedBufferAddress( c )                                         \
    (                                                                       \
        (IsDsObject(c)) ?                                                   \
            SampDsFixedBufferAddress(c): SampRegFixedBufferAddress(c)       \
    )

#define SampRegVariableBufferAddress( c )                                   \
    (                                                                       \
        ((PUCHAR)((c)->OnDisk)) + SampVariableBufferOffset( c )             \
    )

#define SampDsVariableBufferAddress( c )                                    \
    (                                                                       \
        ((PUCHAR)((c)->OnDisk)) + SampDsVariableBufferOffset( c )           \
    )

#define SampVariableBufferAddress( c )                                      \
    (                                                                       \
        (IsDsObject(c)) ?                                                   \
            SampDsVariableBufferAddress(c) : SampRegVariableBufferAddress(c)\
    )

//
// Get the offset of the beginning of the variable-length
// attributes discriptors array.  This address is dword-aligned.
//

#define SampRegVariableArrayOffset( c )                                     \
    (                                                                       \
        SampObjectInformation[(c)->ObjectType].VariableArrayOffset          \
    )

#define SampDsVariableArrayOffset( c )                                      \
    (                                                                       \
        SampObjectInformation[(c)->ObjectType].VariableDsArrayOffset        \
    )

#define SampVariableArrayOffset( c )                                        \
    (                                                                       \
        (IsDsObject(c)) ?                                                   \
            SampDsVariableArrayOffset(c) : SampRegVariableArrayOffset(c)    \
    )

//
// Calculate the address of the beginning of the variable-length
// attributes array.
//

#define SampRegVariableArrayAddress( c )                                    \
    (                                                                       \
        (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)((PUCHAR)((c)->OnDisk) +           \
            SampVariableArrayOffset( c ) )                                  \
    )

#define SampDsVariableArrayAddress( c )                                     \
    (                                                                       \
        (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)((PUCHAR)((c)->OnDisk) +           \
            SampDsVariableArrayOffset( c ) )                                \
    )

#define SampVariableArrayAddress( c )                                       \
    (                                                                       \
        (IsDsObject(c)) ?                                                   \
            SampDsVariableArrayAddress(c) : SampRegVariableArrayAddress(c)  \
    )

//
// Get the offset of the beginning of the variable-length
// attributes data.
//

#define SampRegVariableDataOffset( c )                                      \
    (                                                                       \
        SampObjectInformation[(c)->ObjectType].VariableDataOffset           \
    )

#define SampDsVariableDataOffset( c )                                       \
    (                                                                       \
        SampObjectInformation[(c)->ObjectType].VariableDsDataOffset         \
    )

#define SampVariableDataOffset( c )                                         \
    (                                                                       \
        (IsDsObject(c)) ?                                                   \
            SampDsVariableDataOffset(c) : SampRegVariableDataOffset(c)      \
    )

//
// Get the length of the on-disk buffer for holding the variable-length
// attribute array and data.  If the fixed and variable-length attributes
// are stored separately, then this will be the lower half of the buffer.
// Otherwise, there is only one buffer, so it is the entire allocated buffer.
//

#define SampRegFixedBufferLength( c )                                       \
    (                                                                       \
            SampObjectInformation[(c)->ObjectType].FixedLengthSize          \
    )

#define SampDsFixedBufferLength( c )                                        \
    (                                                                       \
            SampObjectInformation[(c)->ObjectType].FixedDsLengthSize        \
    )

#define SampFixedBufferLength( c )                                          \
    (                                                                       \
        (IsDsObject(c)) ?                                                   \
            SampDsFixedBufferLength(c) : SampRegFixedBufferLength(c)        \
    )

#define SampRegVariableBufferLength( c )                                    \
    (                                                                       \
            (c)->OnDiskAllocated - SampVariableBufferOffset( c )            \
    )

#define SampDsVariableBufferLength( c )                                     \
    (                                                                       \
            (c)->OnDiskAllocated - SampDsVariableBufferOffset( c )          \
    )

#define SampVariableBufferLength( c )                                       \
    (                                                                       \
        (IsDsObject(c)) ?                                                   \
            SampDsVariableBufferLength(c) : SampRegVariableBufferLength(c)  \
    )

//
// Return the address of a Qualifier field within the variable-length
// attribute descriptor array.
//

#define SampRegVariableQualifier( c, i )                                    \
    (                                                                       \
        SampVariableArrayAddress( c ) +                                     \
        (sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE) * i)                        \
        + FIELD_OFFSET(SAMP_VARIABLE_LENGTH_ATTRIBUTE, Qualifier)           \
    )

#define SampDsVariableQualifier( c, i )                                     \
    (                                                                       \
        SampDsVariableArrayAddress( c ) +                                   \
        (sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE) * i)                        \
        + FIELD_OFFSET(SAMP_VARIABLE_LENGTH_ATTRIBUTE, Qualifier)           \
    )

#define SampVariableQualifier( c, i )                                       \
    (                                                                       \
        (IsDsObject(c)) ?                                                   \
            SampDsVariableQualifier(c, i) : SampRegVariableQualifier(c, i)  \
    )

//
// Return the address of the first byte of free space
// in an object's attribute data buffer.
// This will be dword aligned.
//

#define SampRegFirstFreeVariableAddress( c )                                \
         (PUCHAR)(((PUCHAR)((c)->OnDisk)) + (c)->OnDiskUsed)

#define SampDsFirstFreeVariableAddress( c )                                 \
         (PUCHAR)(((PUCHAR)((c)->OnDisk)) + (c)->OnDiskUsed)

#define SampFirstFreeVariableAddress( c )                                   \
    (                                                                       \
        (IsDsObject(c)) ?                                                   \
            SampDsFirstFreeVariableAddress(c) :                             \
            SampRegFirstFreeVariableAddress(c)                              \
    )

//
// Get the number of bytes needed to store the entire variable-length
// attribute information on disk.
//

#define SampRegVariableBufferUsedLength( c )                                \
    (                                                                       \
        (ULONG)((PUCHAR)SampFirstFreeVariableAddress(c) -                   \
        (PUCHAR)SampVariableArrayAddress(c))                                \
    )

#define SampDsVariableBufferUsedLength( c )                                 \
    (                                                                       \
        (ULONG)((PUCHAR)SampDsFirstFreeVariableAddress(c) -                 \
        (PUCHAR)SampDsVariableArrayAddress(c))                              \
    )

#define SampVariableBufferUsedLength( c )                                   \
    (                                                                       \
        (IsDsObject(c)) ?                                                   \
            SampDsVariableBufferUsedLength(c):                              \
            SampRegVariableBufferUsedLength(c)                              \
    )

#define ClearPerAttributeDirtyBits( c )                                     \
    (RtlClearAllBits(&c->PerAttributeDirtyBits))

#define SetPerAttributeDirtyBit(c,a)                                        \
    (RtlSetBits(&c->PerAttributeDirtyBits,a,1))

#define SetAllPerAttributeDirtyBits( c )                                    \
    (RtlSetAllBits(&c->PerAttributeDirtyBits))

#define SetPerAttributeInvalidBit(c,a)                                      \
    (RtlSetBits(&c->PerAttributeInvalidBits,a,1))

#define ClearPerAttributeInvalidBit(c,a)                                    \
    (RtlSetBits(&c->PerAttributeInvalidBits,a,0))

#define SampIsAttributeInvalid( context, attribute )                        \
    (RtlCheckBit(&Context->PerAttributeInvalidBits, attribute ))


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
SampValidateAttributes(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeGroup,
    IN ULONG Attribute,
    IN BOOLEAN SetOperation
    );

PUCHAR
SampObjectAttributeAddress(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex
    );

ULONG
SampObjectAttributeLength(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex
    );

PULONG
SampObjectAttributeQualifier(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex
    );

NTSTATUS
SampGetAttributeBufferReadInfo(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeGroup,
    OUT PUCHAR *Buffer,
    OUT PULONG BufferLength,
    OUT PUNICODE_STRING *KeyAttributeName
    );

NTSTATUS
SampExtendAttributeBuffer(
    IN PSAMP_OBJECT Context,
    IN ULONG NewSize
    );

NTSTATUS
SampReadRegistryAttribute(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    IN ULONG  BufferLength,
    IN PUNICODE_STRING AttributeName,
    OUT PULONG RequiredLength
    );

NTSTATUS
SampSetVariableAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN ULONG Qualifier,
    IN PUCHAR Buffer,
    IN ULONG Length
    );

NTSTATUS
SampUpgradeToCurrentRevision(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeGroup,
    IN PUCHAR Buffer,
    IN ULONG  LengthOfDataRead,
    IN PULONG  TotalRequiredLength
    );


//
// extern from usrparms.c
//

NTSTATUS
SampConvertUserParmsToDsAttrBlock(
    IN PSAMP_OBJECT Context OPTIONAL,
    IN ULONG Flags,
    IN PSID  DomainSid,
    IN ULONG ObjectRid,
    IN ULONG UserParmsLengthOrig,
    IN PVOID UserParmsOrig,
    IN ULONG UserParmsLengthNew,
    IN PVOID UserParmsNew,
    IN PDSATTRBLOCK InAttrBlock,
    OUT PDSATTRBLOCK *OutAttrBlock
    );

NTSTATUS
SampMergeDsAttrBlocks(
    IN PDSATTRBLOCK FirstAttrBlock,
    IN PDSATTRBLOCK SecondAttrBlock,
    OUT PDSATTRBLOCK * AttrBlock
    );



#ifdef SAM_DEBUG_ATTRIBUTES
VOID
SampDumpAttributes(
    IN PSAMP_OBJECT Context
    );

VOID
SampDumpData(
    IN PVOID Buffer,
    IN ULONG Length
    );
#endif


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Routines                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

VOID
SampInitDsObjectInfoAttributes(
    )

/*++

Routine Description:

    This routine initializes the offset and length information fields of the
    SAM_OBJECT_INFORMATION structure for DS attributes. This structure con-
    tains offset and length information for two sets of attributes:

    -Those attributes stored in the registry (workstation account info)

    -Those attributes stored in the DS (domain or DC account info)

    The former set are initialized by SampInitObjectInfoAttriubtes, while this
    routine inializes the latter set of information. Regardless of whether the
    attributes are persistently stored in the registry or the DS, their in-
    memory representation always uses the SAM fixed-length and variable-length
    data buffers.

    Note that DS data buffers do not contain the KEY_VALUE_PARTIAL_INFORMATION
    data because this is registry-specific, hence unnecessary for the DS-based
    attributes.

Parameters:

    None.

Return Values:

    None.

--*/

{
    PSAMP_OBJECT_INFORMATION Object;

    SAMTRACE("SampInitDsObjectInfoAttributes");

    //
    // SERVER object attribute information
    //

    Object = &SampObjectInformation[SampServerObjectType];

    // Object->FixedStoredSeparately = SAMP_SERVER_STORED_SEPARATELY;
    Object->FixedDsAttributesOffset = 0;
    Object->FixedDsLengthSize = sizeof(SAMP_V1_FIXED_LENGTH_SERVER);

    Object->VariableDsBufferOffset =
        Object->FixedDsAttributesOffset +
        SampDwordAlignUlong(Object->FixedDsLengthSize);

    Object->VariableDsArrayOffset =
        Object->VariableDsBufferOffset + 0;

    // Object->VariableAttributeCount = SAMP_SERVER_VARIABLE_ATTRIBUTES;

    Object->VariableDsDataOffset =
        SampDwordAlignUlong( Object->VariableDsArrayOffset +
                             (SAMP_SERVER_VARIABLE_ATTRIBUTES *
                             sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE))
                           );

    //
    // DOMAIN object attribute information
    //

    Object = &SampObjectInformation[SampDomainObjectType];

    // Object->FixedStoredSeparately = SAMP_DOMAIN_STORED_SEPARATELY;
    Object->FixedDsAttributesOffset = 0;
    Object->FixedDsLengthSize = sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN);

    Object->VariableDsBufferOffset =
        Object->FixedDsAttributesOffset +
        SampDwordAlignUlong(Object->FixedDsLengthSize);

    Object->VariableDsArrayOffset =
        Object->VariableDsBufferOffset + 0;

    // Object->VariableAttributeCount = SAMP_DOMAIN_VARIABLE_ATTRIBUTES;

    Object->VariableDsDataOffset =
        SampDwordAlignUlong( Object->VariableDsArrayOffset +
                             (SAMP_DOMAIN_VARIABLE_ATTRIBUTES *
                             sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE))
                           );

    //
    // USER object attribute information
    //

    Object = &SampObjectInformation[SampUserObjectType];

    // Object->FixedStoredSeparately = SAMP_USER_STORED_SEPARATELY;
    Object->FixedDsAttributesOffset = 0;
    Object->FixedDsLengthSize = sizeof(SAMP_V1_0A_FIXED_LENGTH_USER);

    Object->VariableDsBufferOffset =
        Object->FixedDsAttributesOffset +
        SampDwordAlignUlong(Object->FixedDsLengthSize);

    Object->VariableDsArrayOffset =
        Object->VariableDsBufferOffset + 0;

    // Object->VariableAttributeCount = SAMP_USER_VARIABLE_ATTRIBUTES;

    Object->VariableDsDataOffset =
        SampDwordAlignUlong( Object->VariableDsArrayOffset +
                             (SAMP_USER_VARIABLE_ATTRIBUTES *
                             sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE))
                           );

    //
    // GROUP object attribute information
    //

    Object = &SampObjectInformation[SampGroupObjectType];

    // Object->FixedStoredSeparately = SAMP_GROUP_STORED_SEPARATELY;
    Object->FixedDsAttributesOffset = 0;
    Object->FixedDsLengthSize = sizeof(SAMP_V1_0A_FIXED_LENGTH_GROUP);

    Object->VariableDsBufferOffset =
        Object->FixedDsAttributesOffset +
        SampDwordAlignUlong(Object->FixedDsLengthSize);

    Object->VariableDsArrayOffset =
        Object->VariableDsBufferOffset + 0;

    // Object->VariableAttributeCount = SAMP_GROUP_VARIABLE_ATTRIBUTES;

    Object->VariableDsDataOffset =
        SampDwordAlignUlong( Object->VariableDsArrayOffset +
                             (SAMP_GROUP_VARIABLE_ATTRIBUTES *
                             sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE))
                           );

    //
    // ALIAS object attribute information
    //

    Object = &SampObjectInformation[SampAliasObjectType];

    // Object->FixedStoredSeparately = SAMP_ALIAS_STORED_SEPARATELY;
    Object->FixedDsAttributesOffset = 0;
    Object->FixedDsLengthSize = sizeof(SAMP_V1_FIXED_LENGTH_ALIAS);

    Object->VariableDsBufferOffset =
        Object->FixedDsAttributesOffset +
        SampDwordAlignUlong(Object->FixedDsLengthSize);

    Object->VariableDsArrayOffset =
        Object->VariableDsBufferOffset + 0;

    // Object->VariableAttributeCount = SAMP_ALIAS_VARIABLE_ATTRIBUTES;

    Object->VariableDsDataOffset =
        SampDwordAlignUlong( Object->VariableDsArrayOffset +
                             (SAMP_ALIAS_VARIABLE_ATTRIBUTES *
                             sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE))
                           );

    return;
}



VOID
SampInitObjectInfoAttributes(
    )


/*++

    This API initializes the attribute field information
    of the various object information structures.

    Attribute information includes:

            FixedStoredSeparately   (BOOLEAN)

            FixedAttributeOffset    (ULONG)
            VariableBufferOffset    (ULONG)
            VariableArrayOffset     (ULONG)
            VariableDataOffset      (ULONG)

            FixedLengthSize         (ULONG)
            VariableAttributeCount  (ULONG)


Parameters:

    None.



Return Values:

    None.


--*/
{


    //
    // Define the size of the header that is in front of our data when
    // we read it back out of the registry.
    //

#define KEY_VALUE_HEADER_SIZE (SampDwordAlignUlong( \
              FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)))


    PSAMP_OBJECT_INFORMATION Object;

    SAMTRACE("SampInitObjectInfoAttributes");

    //
    // SERVER object attribute information
    //

    Object = &SampObjectInformation[SampServerObjectType];

    Object->FixedStoredSeparately = SAMP_SERVER_STORED_SEPARATELY;

    Object->FixedAttributesOffset = KEY_VALUE_HEADER_SIZE;

    Object->FixedLengthSize = sizeof(SAMP_V1_FIXED_LENGTH_SERVER);

#if SAMP_SERVER_STORED_SEPARATELY

    Object->VariableBufferOffset =
        Object->FixedAttributesOffset +
        SampDwordAlignUlong(Object->FixedLengthSize);

    Object->VariableArrayOffset =
        Object->VariableBufferOffset + KEY_VALUE_HEADER_SIZE;
#else

    Object->VariableBufferOffset = 0;

    Object->VariableArrayOffset =
        Object->FixedAttributesOffset +
        SampDwordAlignUlong(Object->FixedLengthSize);

#endif  //SAMP_SERVER_STORED_SEPARATELY


    Object->VariableAttributeCount = SAMP_SERVER_VARIABLE_ATTRIBUTES;

    Object->VariableDataOffset =
        SampDwordAlignUlong( Object->VariableArrayOffset +
                             (SAMP_SERVER_VARIABLE_ATTRIBUTES *
                             sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE))
                           );





    //
    // DOMAIN object attribute information
    //

    Object = &SampObjectInformation[SampDomainObjectType];

    Object->FixedStoredSeparately = SAMP_DOMAIN_STORED_SEPARATELY;

    Object->FixedAttributesOffset = KEY_VALUE_HEADER_SIZE;

    Object->FixedLengthSize = sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN);

#if SAMP_DOMAIN_STORED_SEPARATELY

    Object->VariableBufferOffset =
        Object->FixedAttributesOffset +
        SampDwordAlignUlong(Object->FixedLengthSize);

    Object->VariableArrayOffset =
        Object->VariableBufferOffset + KEY_VALUE_HEADER_SIZE;
#else

    Object->VariableBufferOffset = 0;

    Object->VariableArrayOffset =
        Object->FixedAttributesOffset +
        SampDwordAlignUlong(Object->FixedLengthSize);

#endif  //SAMP_DOMAIN_STORED_SEPARATELY


    Object->VariableAttributeCount = SAMP_DOMAIN_VARIABLE_ATTRIBUTES;

    Object->VariableDataOffset =
        SampDwordAlignUlong( Object->VariableArrayOffset +
                             (SAMP_DOMAIN_VARIABLE_ATTRIBUTES *
                             sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE))
                           );





    //
    // USER object attribute information
    //

    Object = &SampObjectInformation[SampUserObjectType];

    Object->FixedStoredSeparately = SAMP_USER_STORED_SEPARATELY;

    Object->FixedAttributesOffset = KEY_VALUE_HEADER_SIZE;

    Object->FixedLengthSize = sizeof(SAMP_V1_0A_FIXED_LENGTH_USER);

#if SAMP_USER_STORED_SEPARATELY

    Object->VariableBufferOffset =
        Object->FixedAttributesOffset +
        SampDwordAlignUlong(Object->FixedLengthSize);

    Object->VariableArrayOffset =
        Object->VariableBufferOffset + KEY_VALUE_HEADER_SIZE;
#else

    Object->VariableBufferOffset = 0;

    Object->VariableArrayOffset =
        Object->FixedAttributesOffset +
        SampDwordAlignUlong(Object->FixedLengthSize);

#endif  //SAMP_USER_STORED_SEPARATELY


    Object->VariableAttributeCount = SAMP_USER_VARIABLE_ATTRIBUTES;

    Object->VariableDataOffset =
        SampDwordAlignUlong( Object->VariableArrayOffset +
                             (SAMP_USER_VARIABLE_ATTRIBUTES *
                             sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE))
                           );





    //
    // GROUP object attribute information
    //

    Object = &SampObjectInformation[SampGroupObjectType];

    Object->FixedStoredSeparately = SAMP_GROUP_STORED_SEPARATELY;

    Object->FixedAttributesOffset = KEY_VALUE_HEADER_SIZE;

    Object->FixedLengthSize = sizeof(SAMP_V1_0A_FIXED_LENGTH_GROUP);

#if SAMP_GROUP_STORED_SEPARATELY

    Object->VariableBufferOffset =
        Object->FixedAttributesOffset +
        SampDwordAlignUlong(Object->FixedLengthSize);

    Object->VariableArrayOffset =
        Object->VariableBufferOffset + KEY_VALUE_HEADER_SIZE;
#else

    Object->VariableBufferOffset = 0;

    Object->VariableArrayOffset =
        Object->FixedAttributesOffset +
        SampDwordAlignUlong(Object->FixedLengthSize);

#endif  //SAMP_GROUP_STORED_SEPARATELY


    Object->VariableAttributeCount = SAMP_GROUP_VARIABLE_ATTRIBUTES;

    Object->VariableDataOffset =
        SampDwordAlignUlong( Object->VariableArrayOffset +
                             (SAMP_GROUP_VARIABLE_ATTRIBUTES *
                             sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE))
                           );





    //
    // ALIAS object attribute information
    //

    Object = &SampObjectInformation[SampAliasObjectType];

    Object->FixedStoredSeparately = SAMP_ALIAS_STORED_SEPARATELY;

    Object->FixedAttributesOffset = KEY_VALUE_HEADER_SIZE;

    Object->FixedLengthSize = sizeof(SAMP_V1_FIXED_LENGTH_ALIAS);

#if SAMP_ALIAS_STORED_SEPARATELY

    Object->VariableBufferOffset =
        Object->FixedAttributesOffset +
        SampDwordAlignUlong(Object->FixedLengthSize);

    Object->VariableArrayOffset =
        Object->VariableBufferOffset + KEY_VALUE_HEADER_SIZE;
#else

    Object->VariableBufferOffset = 0;

    Object->VariableArrayOffset =
        Object->FixedAttributesOffset +
        SampDwordAlignUlong(Object->FixedLengthSize);

#endif  //SAMP_ALIAS_STORED_SEPARATELY


    Object->VariableAttributeCount = SAMP_ALIAS_VARIABLE_ATTRIBUTES;

    Object->VariableDataOffset =
        SampDwordAlignUlong( Object->VariableArrayOffset +
                             (SAMP_ALIAS_VARIABLE_ATTRIBUTES *
                             sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE))
                           );

    // Initialize the DS-specific buffer offsets and lengths.

    SampInitDsObjectInfoAttributes();

    return;
}





NTSTATUS
SampUpgradeUserParmsActual(
    IN PSAMP_OBJECT Context OPTIONAL,
    IN ULONG        Flags,
    IN PSID         DomainSid,
    IN ULONG        ObjectRid,
    IN OUT PDSATTRBLOCK * AttributesBlock
    )

/*++
Routine Description:

    This routine is the worker routine to converts SampUserObject's
    ATT_USER_PARAMETERS attribute to AttrBlock through Notification Package.

Arguments:

    Context - pointer to user object's context, optional.
              however, the caller must provide Context if "Upgrade == FALSE"

    Flags -   Values:

          SAM_USERPARMS_DURING_UPGRADE:

              Indicates whether this routine is called because of DCPROMOTE upgrade
              or because of down level compatibility

              The reason why we need this parameter (Flags) is that: in SampConvertCredenialToAttr
              we will call SampQueryUserSupplementalCredentials to get this User's old credential
              data. While, during DCPromote, the DS object representing the SAM User Object is not
              created yet. So we do not want to Query User's credential during the DCpromote.
              We use Upgrade to indicate it during DCpromote or keep down level SAM API compatibly.
              if SAM_USERPARMS_DURING_UPGRADE bit is set on: during DCPromote.

              Another reason is that: RAS group needs to know their converting routine --
              UserParmsConvert is called during upgrade or not to decide to do different things.


    DomainSid - Pointer to Parent Domain Sid.

    ObjectRid - This object's relative ID.

    AttributesBlock - DSATTRBLOCK, passed in DSATTRBLOCK structure which MAY or MAY NOT include
                      ATT_USER_PARAMETERS attribute,

                      if success, AttributesBlock will return the new Attributes Block which
                      contains converted attributes from UserParms.

                      if failure, AttributesBlock keeps unchanged.

Return Values:

    STATUS_SUCCESS


--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       UserParmsLengthOrig = 0;
    PVOID       UserParmsOrig = NULL;
    ULONG       UserParmsLengthNew = 0;
    PVOID       UserParmsNew = NULL;
    ULONG       Index = 0;
    PDSATTRBLOCK TmpAttrBlock = NULL;
    PDSATTRBLOCK UserParmsAttrBlock = NULL;


    SAMTRACE("SampUpgradeUserParmsActual");


    ASSERT(ARGUMENT_PRESENT(Context) || (Flags & SAM_USERPARMS_DURING_UPGRADE));
    ASSERT(DomainSid);
    ASSERT(ObjectRid);
    ASSERT(*AttributesBlock);

    if (NULL == *AttributesBlock)
    {
        return NtStatus;
    }

    //
    // search NON zero value ATT_USER_PARAMETERS
    //
    for (Index = 0; Index < (*AttributesBlock)->attrCount; Index ++)
    {
        if ( ATT_USER_PARAMETERS == (*AttributesBlock)->pAttr[Index].attrTyp &&
             0 != (*AttributesBlock)->pAttr[Index].AttrVal.pAVal[0].valLen)
        {

            ASSERT(1 == (*AttributesBlock)->pAttr[Index].AttrVal.valCount);

            if ( !(Flags & SAM_USERPARMS_DURING_UPGRADE) )
            {
                // not a upgrade case, so we need to provide the old UserParms Value
                ASSERT(Context->TypeBody.User.CachedOrigUserParmsIsValid);

                UserParmsLengthOrig = Context->TypeBody.User.CachedOrigUserParmsLength;
                UserParmsOrig = Context->TypeBody.User.CachedOrigUserParms;
            }

            UserParmsLengthNew = (*AttributesBlock)->pAttr[Index].AttrVal.pAVal[0].valLen;
            UserParmsNew = (*AttributesBlock)->pAttr[Index].AttrVal.pAVal[0].pVal;

            NtStatus = SampConvertUserParmsToDsAttrBlock(Context,
                                                         Flags,
                                                         DomainSid,
                                                         ObjectRid,
                                                         UserParmsLengthOrig,
                                                         UserParmsOrig,
                                                         UserParmsLengthNew,
                                                         UserParmsNew,
                                                         *AttributesBlock,
                                                         &UserParmsAttrBlock
                                                         );

            if (NT_SUCCESS(NtStatus) && NULL != UserParmsAttrBlock)
            {
                NtStatus = SampMergeDsAttrBlocks(*AttributesBlock,
                                                 UserParmsAttrBlock,
                                                 &TmpAttrBlock
                                                 );

                if (NT_SUCCESS(NtStatus))
                {
                    *AttributesBlock = TmpAttrBlock;
                    TmpAttrBlock = NULL;
                    UserParmsAttrBlock = NULL;
                }
            }

            break;
        }
    }

    if (!NT_SUCCESS(NtStatus))
    {
        goto UpgradeUserParmsActualError;
    }


    return NtStatus;

UpgradeUserParmsActualError:


    if (UserParmsAttrBlock)
    {
        SampFreeAttributeBlock(UserParmsAttrBlock);
    }

    return NtStatus;

}





NTSTATUS
SampUpgradeUserParms(
    IN PSAMP_OBJECT Context,
    IN OUT PDSATTRBLOCK * AttributesBlock
    )

/*++

Routine Description:

    This routine retrieves Domain SID and ObjectRid from Context, then call
    SampUpgradeUserParmsActual. if failure, also log error in System Event Log.

    Note: this routine is only called by UserParms Migration (Normal Operation),
          and not called during either Upgrade or Fresh Install, so this routine
          does not need to provide Flags as one Parameter.

Arguments:

    Context - pointer to a User Object's context block.

    AttributeBlock - pointer to DSATTRBLOCK structure, passed in original attributes block,
                     and used to return the updated attribute block to set.

Return Values:

    STATUS_SUCCESS - complete successfully.

    STATUS_NO_MEMORY - no resources.

    STATUS_INVALID_PARAMETERS - notification package trying to set invalid attribute.

--*/

{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PSID        DomainSid = NULL;
    ULONG       ObjectRid;


    SAMTRACE("SampUpgradeUserParms");

    ASSERT(Context);
    ASSERT(SampCurrentThreadOwnsLock());

    DomainSid = SampDefinedDomains[Context->DomainIndex].Sid;
    ObjectRid = Context->TypeBody.User.Rid;

    NtStatus = SampUpgradeUserParmsActual(Context,
                                          0,            // not during Upgrade(DCPromote), flags set to 0
                                          DomainSid,
                                          ObjectRid,
                                          AttributesBlock
                                          );

    if (!NT_SUCCESS(NtStatus))
    {
        //
        // if failure to upgrade UserParms attribute, log ERROR, and fail this operation.
        //
        SampWriteEventLog(EVENTLOG_ERROR_TYPE,     // Event Type
                          0,                       // Category
                          SAMMSG_ERROR_SET_USERPARMS,
                          &(Context->ObjectNameInDs->Sid),      // SID
                          0,                       // Num of String
                          sizeof(NTSTATUS),        // Data Size
                          NULL,                    // String Array -- User Name
                          (PVOID) &NtStatus        // Data
                          );
    }

    return NtStatus;
}




NTSTATUS
SampStoreDsObjectAttributes(
    IN PSAMP_OBJECT Context
    )

/*++

Routine Description:

    This routine does the work of writing the SAM attributes out to the DS
    backing store. Determination is made as to whether the fixed, or vari-
    able, or both sets of attributes are dirty and valid. If so, then they
    are updated in the backing store. The SAM attributes are first converted
    into a DSATTRBLOCK so that they can be written to storage. The dirty
    flags are updated accordingly.

Arguments:

    Context - Pointer, the object's SAM context.

Return Value:

    STATUS_SUCCESS - storage was updated without a problem, otherwise an
        error code is returned.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN FlushFixed = FALSE;
    BOOLEAN FlushVariable = FALSE;
    INT ObjectType = Context->ObjectType;
    ULONG Flags = 0;
    PDSNAME DsObjectName = Context->ObjectNameInDs;
    PDSATTRBLOCK AttributeBlock = NULL;
    PDSATTRBLOCK SAAttrBlock = NULL;
    ULONG   *Operations = NULL;

    SAMTRACE("SampStoreDsObjectAttributes");

    // Determine which attributes (fixed or variable) need to be written to
    // storage.

    if (Context->FixedValid && Context->FixedDirty)
    {
        FlushFixed = TRUE;
    }

    if (Context->VariableValid && Context->VariableDirty)
    {
        FlushVariable = TRUE;
    }

    //
    // Return right away if nothing is dirty
    //

    if (!FlushFixed && !FlushVariable)
    {
        return STATUS_SUCCESS;
    }

    //
    // Do a lazy commit, if lazy commit is specified
    //

    if (Context->LazyCommit)
    {
        Flags|=SAM_LAZY_COMMIT;
    }

    //
    // If an On disk exists proceed on writing
    //

    if (NULL!=Context->OnDisk)
    {

        if ((FlushFixed)&&(FlushVariable))
        {


            // If both Fixed and Variable Attributes need to be flushed ...
            // Get a pointer to the combined (i.e. fixed and variable-
            // length) attributes and convert them into a DSATTRBLOCK.

            NtStatus = SampConvertCombinedAttributesToAttrBlock(
                            Context,
                            SampDsFixedBufferLength(Context),
                            SampDsVariableBufferLength(Context),
                            &AttributeBlock);


        }
        else if (FlushFixed)
        {
            //
            // Only Fixed attributes have been modified. Therefore just flush them
            //

            NtStatus = SampConvertFixedLengthAttributesToAttrBlock(
                            Context->ObjectType,
                            SampDsFixedBufferAddress(Context),
                            &AttributeBlock);
        }
        else if (FlushVariable)
        {
            //
            // Only variable attributes are modified
            //

            NtStatus = SampConvertVarLengthAttributesToAttrBlock(
                            Context,
                            SampDsVariableArrayAddress(Context),
                            &AttributeBlock);
        }

        if (NT_SUCCESS(NtStatus))
        {
            ATTR    CredentialAttr;

            //
            // Map SAM attribute ID to DS attribute ID, should have NO problem.
            //
            SampMapSamAttrIdToDsAttrId(Context->ObjectType,
                                       AttributeBlock
                                       );

            //
            // Upgrade the User Parameters Attribute through Notification Package
            // when the User Parms change is trigger by down level SAM API.
            //

            if ((SampUserObjectType == Context->ObjectType) &&
                (!Context->LoopbackClient) &&
                (RtlCheckBit(&Context->PerAttributeDirtyBits, SAMP_USER_PARAMETERS))
                )
            {
                ASSERT(SampCurrentThreadOwnsLock());

                NtStatus = SampUpgradeUserParms(Context,
                                                &AttributeBlock
                                                );
            }

            //
            // If the context has a list of supplemental credentials to be set, then merge that in
            //

            if ((SampUserObjectType==Context->ObjectType ) &&
                (NULL != Context->TypeBody.User.SupplementalCredentialsToWrite))
            {
                NtStatus = SampConvertCredentialsToAttr(Context,
                                            0,
                                            Context->TypeBody.User.Rid,
                                            Context->TypeBody.User.SupplementalCredentialsToWrite,
                                            &CredentialAttr
                                            );

                if (NT_SUCCESS(NtStatus))
                {
                    //
                    // Free the supplemenal credentials in the context
                    //

                    SampFreeSupplementalCredentialList(
                         Context->TypeBody.User.SupplementalCredentialsToWrite);

                    Context->TypeBody.User.SupplementalCredentialsToWrite = NULL;

                    NtStatus = SampAppendAttrToAttrBlock(CredentialAttr,
                                             &AttributeBlock
                                             );
                }

            }

            if (  (SampUserObjectType==Context->ObjectType)
               && (Context->TypeBody.User.fCheckForSiteAffinityUpdate))
            {
                SAMP_SITE_AFFINITY NewSA;
                BOOLEAN            fDeleteOld;
                SAMP_SITE_AFFINITY *TempSA = NULL;

                if (SampCheckForSiteAffinityUpdate(Context,
                                                   0, 
                                                  &Context->TypeBody.User.SiteAffinity,
                                                  &NewSA,
                                                  &fDeleteOld))
                {
                    //
                    // Site Affinity needs updating -- create an attrblock
                    // for the changes.  There will be at least on addition,
                    // and possible a removal if a value already exists
                    // for this site.
                    //

                    ULONG SAAttrCount;
                    ULONG Index, i;
                    PDSATTRBLOCK NewAttributeBlock;
                    ATTRVAL *AttrVal = NULL;

    
                    SAAttrCount = 1;
                    if (fDeleteOld) {
                        SAAttrCount++;
                    }

                    SAAttrBlock = MIDL_user_allocate(sizeof(DSATTRBLOCK));
                    if (NULL == SAAttrBlock) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        goto Error;
                    }
                    RtlZeroMemory(SAAttrBlock, sizeof(DSATTRBLOCK));

                    SAAttrBlock->pAttr = MIDL_user_allocate(SAAttrCount * sizeof(DSATTR));
                    if (NULL == SAAttrBlock->pAttr) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        goto Error;
                    }
                    RtlZeroMemory(SAAttrBlock->pAttr, SAAttrCount * sizeof(DSATTR));
                    SAAttrBlock->attrCount = SAAttrCount;

                    Index = 0;
                    if (fDeleteOld) {
                        AttrVal = MIDL_user_allocate(sizeof(*AttrVal));
                        if (NULL == AttrVal) {
                            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                            goto Error;
                        }
                        TempSA = MIDL_user_allocate(sizeof(SAMP_SITE_AFFINITY));
                        if (NULL == TempSA) {
                            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                            goto Error;
                        }
                        *TempSA = Context->TypeBody.User.SiteAffinity;

                        AttrVal->valLen = sizeof(SAMP_SITE_AFFINITY);
                        AttrVal->pVal = (UCHAR*)TempSA;
                        TempSA = NULL;

                        SAAttrBlock->pAttr[Index].attrTyp = ATT_MS_DS_SITE_AFFINITY;
                        SAAttrBlock->pAttr[Index].AttrVal.valCount = 1;
                        SAAttrBlock->pAttr[Index].AttrVal.pAVal = AttrVal;
                        Index++;
                    }

                    AttrVal = MIDL_user_allocate(sizeof(*AttrVal));
                    if (NULL == AttrVal) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        goto Error;
                    }
                    TempSA = MIDL_user_allocate(sizeof(SAMP_SITE_AFFINITY));
                    if (NULL == TempSA) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        goto Error;
                    }
                    *TempSA = NewSA;
                    AttrVal->valLen = sizeof(SAMP_SITE_AFFINITY);
                    AttrVal->pVal = (UCHAR*)TempSA;
                    TempSA = NULL;
                    SAAttrBlock->pAttr[Index].attrTyp = ATT_MS_DS_SITE_AFFINITY;
                    SAAttrBlock->pAttr[Index].AttrVal.valCount = 1;
                    SAAttrBlock->pAttr[Index].AttrVal.pAVal = AttrVal;

                    //
                    // Now merge the attrblock's together
                    //
                    NtStatus = SampMergeDsAttrBlocks(AttributeBlock,
                                                     SAAttrBlock,
                                                     &NewAttributeBlock);

                    if (!NT_SUCCESS(NtStatus)) {
                        goto Error;
                    }
                    // SampMergeDsAttrBlocks frees both IN parameters
                    AttributeBlock = NewAttributeBlock;
                    SAAttrBlock = NULL;
                    NewAttributeBlock = NULL;

                    //
                    // Now prepare an operation array 
                    //
                    Operations = MIDL_user_allocate(AttributeBlock->attrCount * sizeof(ULONG));
                    if (NULL == Operations) {
                        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                        goto Error;
                    }

                    //
                    // Most SAM attr's are simply to replace
                    //
                    for (i = 0; i < AttributeBlock->attrCount; i++) {
                        Operations[i] = REPLACE_ATT;
                    }

                    //
                    // Since SA is multi valued, we have to remove and add
                    //
                    if (fDeleteOld) {
                        Operations[AttributeBlock->attrCount-2] = REMOVE_VALUE;
                        ASSERT(AttributeBlock->pAttr[AttributeBlock->attrCount-2].attrTyp = ATT_MS_DS_SITE_AFFINITY);
                    }
                    Operations[AttributeBlock->attrCount-1] = ADD_VALUE;
                    ASSERT(AttributeBlock->pAttr[AttributeBlock->attrCount-1].attrTyp = ATT_MS_DS_SITE_AFFINITY);
                }
            }

            //
            // Replicate urgently if requested to do so
            //
            if ( Context->ReplicateUrgently )
            {
                Flags |= SAM_URGENT_REPLICATION;
            }

            //
            // An Attr block is ready to be written.
            // Go Ahead and write it !
            //
            if (NT_SUCCESS(NtStatus))
            {
                ULONG NewFlags = Flags | ALREADY_MAPPED_ATTRIBUTE_TYPES;
                if (Operations) {

                    NtStatus = SampDsSetAttributesEx(DsObjectName,
                                                     NewFlags,
                                                     Operations,
                                                     ObjectType,
                                                     AttributeBlock);

                } else {

                    NtStatus = SampDsSetAttributes(DsObjectName,
                                                   NewFlags,
                                                   REPLACE_ATT,
                                                   ObjectType,
                                                   AttributeBlock);

                }
            }

            //
            // Mark FixedDirtyand VariableDirty any way, since we do not want hit the
            // ASSERT in SampFreeAttributeBuffer.
            //
            Context->FixedDirty = FALSE;
            Context->VariableDirty = FALSE;
            ClearPerAttributeDirtyBits(Context);

            //
            // Also clear the urgently replicated bit
            //
            Context->ReplicateUrgently = FALSE;

        }
    }

Error:

    if (NULL!=AttributeBlock)
    {
        SampFreeAttributeBlock(AttributeBlock);
        AttributeBlock = NULL;
    }

    if (Operations) {
        MIDL_user_free(Operations);
    }

    if (SAAttrBlock) {
        SampFreeAttributeBlock(SAAttrBlock);
    }

    return(NtStatus);
}





NTSTATUS
SampStoreRegObjectAttributes(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN UseKeyHandle
    )

/*++

    This API is used to store an object's attributes onto
    backing store.

    The object attributes are not flushed to disk with this
    routine.  They are just added to the RXACT.




Parameters:

    Context - Pointer to an object context block.

    UseKeyHandle - If TRUE, the RootKey in the context block is passed
        to the transaction code - this assumes that the key
        will still be open when the transaction is committed.
        If FALSE, the RootKey will be ignored and the transaction code will
        open a key for itself.


Return Values:

    STATUS_SUCCESS - The service completed successfully.


    Other status values as may be returned by the RXACT services.


--*/
{
    NTSTATUS
        NtStatus;

    BOOLEAN
        FlushFixed        = FALSE,
        FlushVariable     = FALSE;

    HANDLE
        RootKey;

    SAMTRACE("SampStoreRegObjectAttributes");

    //
    // See if anything is dirty and needs to be stored
    //

    if (Context->FixedValid  &&  Context->FixedDirty) {

        FlushFixed = TRUE;
    }

    if (Context->VariableValid  &&  Context->VariableDirty) {

        FlushVariable = TRUE;
    }


    if (!(FlushFixed || FlushVariable)) {

        return(STATUS_SUCCESS);
    }


    //
    // Calculate the RootKey to pass to the transaction code
    //

    if (UseKeyHandle) {
        RootKey = Context->RootKey;
    } else {
        RootKey = INVALID_HANDLE_VALUE;
    }

    //
    // We keep an open domain context that is used to modify the change
    // count whenever a change is made.  But if this is a domain change
    // here, then that change will overwrite this one.  Check for that
    // case, and copy this fixed data to the open domain context.  Note
    // that the open domain's variable data never gets changed.
    //

    if ( ( Context->ObjectType == SampDomainObjectType ) &&
         ( Context != SampDefinedDomains[Context->DomainIndex].Context ) ) {

        PSAMP_OBJECT DefinedContext;

        //
        // Get a pointer to the corresponding open defined domain.
        // No changes should have been made to its data.
        //

        DefinedContext = SampDefinedDomains[Context->DomainIndex].Context;

        ASSERT( DefinedContext->FixedValid == TRUE );
        ASSERT( DefinedContext->FixedDirty == FALSE );

#if DBG
        if ( DefinedContext->VariableValid ) {
            ASSERT( DefinedContext->VariableDirty == FALSE );
        }
#endif
        DefinedContext->VariableDirty = FALSE;
        ClearPerAttributeDirtyBits(DefinedContext);

        //
        // Copy our fixed data over the defined domain's fixed data.
        // Note that we're assuming that the fixed and variable data are
        // stored separately.
        //

        ASSERT(SampObjectInformation[SampDomainObjectType].FixedStoredSeparately);

        RtlCopyMemory(
            SampFixedBufferAddress( DefinedContext ),
            SampFixedBufferAddress( Context ),
            SampFixedBufferLength( Context )
            );

        //
        // No need to flush this context's fixed data, since the commit
        // code will flush the same stuff (plus an altered modified count).
        //

        FlushFixed = FALSE;
        Context->FixedDirty    = FALSE;
    }

    //
    // One or more of the attributes needs to be stored.
    //

    if (!SampObjectInformation[Context->ObjectType].FixedStoredSeparately) {

        //
        // fixed and variable-length attributes stored together.
        // Note - strip off the partial key info struct from the start
        //

        SampDumpRXact(SampRXactContext,
                      RtlRXactOperationSetValue,
                      &(Context->RootName),
                      RootKey,
                      &SampCombinedAttributeName,
                      REG_BINARY,
                      SampFixedBufferAddress(Context),
                      Context->OnDiskUsed - SampFixedBufferOffset(Context),
                      FixedBufferAddressFlag);

        NtStatus = RtlAddAttributeActionToRXact(
                       SampRXactContext,
                       RtlRXactOperationSetValue,
                       &(Context->RootName),
                       RootKey,
                       &SampCombinedAttributeName,
                       REG_BINARY,
                       SampFixedBufferAddress(Context),
                       Context->OnDiskUsed - SampFixedBufferOffset(Context)
                       );
#if SAMP_DIAGNOSTICS
        if (!NT_SUCCESS(NtStatus)) {
            SampDiagPrint( DISPLAY_STORAGE_FAIL,
                           ("SAM: Failed to add action to RXact (0x%lx)\n",
                           NtStatus) );
            IF_SAMP_GLOBAL( BREAK_ON_STORAGE_FAIL ) {
                ASSERT(NT_SUCCESS(NtStatus));
            }
        }
#endif //SAMP_DIAGNOSTICS


        if ( NT_SUCCESS( NtStatus ) ) {

            Context->FixedDirty    = FALSE;
            Context->VariableDirty = FALSE;
            ClearPerAttributeDirtyBits(Context);
        }

    } else {

        //
        // fixed and variable-length attributes stored separately.
        // Only update the one(s) we need to.
        //

        NtStatus = STATUS_SUCCESS;
        if (FlushFixed) {

            SampDumpRXact(SampRXactContext,
                          RtlRXactOperationSetValue,
                          &(Context->RootName),
                          RootKey,
                          &SampFixedAttributeName,
                          REG_BINARY,
                          SampFixedBufferAddress(Context),
                          SampVariableBufferOffset(Context) - SampFixedBufferOffset(Context),
                          FixedBufferAddressFlag);

            NtStatus = RtlAddAttributeActionToRXact(
                           SampRXactContext,
                           RtlRXactOperationSetValue,
                           &(Context->RootName),
                           RootKey,
                           &SampFixedAttributeName,
                           REG_BINARY,
                           SampFixedBufferAddress(Context),
                           SampVariableBufferOffset(Context) - SampFixedBufferOffset(Context)
                           );

#if SAMP_DIAGNOSTICS
            if (!NT_SUCCESS(NtStatus)) {
                SampDiagPrint( DISPLAY_STORAGE_FAIL,
                               ("SAM: Failed to add action to RXact (0x%lx)\n",
                               NtStatus) );
                IF_SAMP_GLOBAL( BREAK_ON_STORAGE_FAIL ) {
                    ASSERT(NT_SUCCESS(NtStatus));
                }
            }
#endif //SAMP_DIAGNOSTICS

            if ( NT_SUCCESS( NtStatus ) ) {

                Context->FixedDirty = FALSE;
            }
        }

        if (NT_SUCCESS(NtStatus) && FlushVariable) {

            SampDumpRXact(SampRXactContext,
                          RtlRXactOperationSetValue,
                          &(Context->RootName),
                          RootKey,
                          &SampVariableAttributeName,
                          REG_BINARY,
                          (PUCHAR)SampVariableArrayAddress(Context),
                          SampVariableBufferUsedLength(Context),
                          VARIABLE_LENGTH_ATTRIBUTE_FLAG);

            NtStatus = RtlAddAttributeActionToRXact(
                           SampRXactContext,
                           RtlRXactOperationSetValue,
                           &(Context->RootName),
                           RootKey,
                           &SampVariableAttributeName,
                           REG_BINARY,
                           SampVariableArrayAddress( Context ),
                           SampVariableBufferUsedLength(Context)
                           );

#if SAMP_DIAGNOSTICS
            if (!NT_SUCCESS(NtStatus)) {
                SampDiagPrint( DISPLAY_STORAGE_FAIL,
                               ("SAM: Failed to add action to RXact (0x%lx)\n",
                               NtStatus) );
                IF_SAMP_GLOBAL( BREAK_ON_STORAGE_FAIL ) {
                    ASSERT(NT_SUCCESS(NtStatus));
                }
            }
#endif //SAMP_DIAGNOSTICS


            if ( NT_SUCCESS( NtStatus ) ) {
                Context->VariableDirty = FALSE;
                ClearPerAttributeDirtyBits(Context);
            }
        }
    }

    return(NtStatus);
}



NTSTATUS
SampStoreObjectAttributes(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN UseKeyHandle
    )

/*++

Routine Description:

    This routine determines from the object context whether to update object
    attributes residing in the registry or in the DS backing store, and then
    calls the appropriate routine to do the work.

Arguments:

    Context - Pointer, the object's SAM context.

    UseKeyHandle - Flag indicating that the registry key handle should be
        used (if this is a registry update--it is not used in DS updates).

Return Value:

    STATUS_SUCCESS - storage was updated without a problem, otherwise an
        error code is returned.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampStoreObjectAttributes");

    if (NULL != Context)
    {
        if (IsDsObject(Context))
        {
            NtStatus = SampStoreDsObjectAttributes(Context);
        }
        else
        {
            NtStatus = SampStoreRegObjectAttributes(Context, UseKeyHandle);
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return(NtStatus);
}



NTSTATUS
SampDeleteAttributeKeys(
    IN PSAMP_OBJECT Context
    )

/*++

    This API is used to delete the attribute keys that are created in the
    registry underneath a SAM object.



Parameters:

    Context - Pointer to an object context block.



Return Values:

    STATUS_SUCCESS - The service completed successfully.

    Error status may be returned by registry calls.

--*/
{
    UNICODE_STRING
        KeyName;

    NTSTATUS
        NtStatus;

    SAMTRACE("SampDeleteAttributeKeys");

    if (SampObjectInformation[Context->ObjectType].FixedStoredSeparately) {

        //
        // Must delete both fixed and variable attribute keys.
        //

        NtStatus = SampBuildAccountSubKeyName(
                       SampUserObjectType,
                       &KeyName,
                       Context->TypeBody.User.Rid,
                       &SampFixedAttributeName
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = RtlAddActionToRXact(
                           SampRXactContext,
                           RtlRXactOperationDelete,
                           &KeyName,
                           0,
                           NULL,
                           0
                           );
            SampFreeUnicodeString( &KeyName );

            NtStatus = SampBuildAccountSubKeyName(
                           SampUserObjectType,
                           &KeyName,
                           Context->TypeBody.User.Rid,
                           &SampVariableAttributeName
                           );

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = RtlAddActionToRXact(
                               SampRXactContext,
                               RtlRXactOperationDelete,
                               &KeyName,
                               0,
                               NULL,
                               0
                               );
                SampFreeUnicodeString( &KeyName );
            }
        }

    } else {

        //
        // Must delete the combined attribute key.
        //

        NtStatus = SampBuildAccountSubKeyName(
                       SampUserObjectType,
                       &KeyName,
                       Context->TypeBody.User.Rid,
                       &SampCombinedAttributeName
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = RtlAddActionToRXact(
                           SampRXactContext,
                           RtlRXactOperationDelete,
                           &KeyName,
                           0,
                           NULL,
                           0
                           );

            SampFreeUnicodeString( &KeyName );
        }
    }

    return( NtStatus );
}



NTSTATUS
SamIGetFixedAttributes(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN MakeCopy,
    OUT PVOID *FixedData
    )

/*++

    This API is an exported wrapper for SampGetFixedAttributes that is used
    in samwrite.c, in ntdsa.dll.

Parameters:

    Refer to SampGetFixedAttributes.

Return Values:

    Refer to SampGetFixedAttributes.

--*/

{
    return(SampGetFixedAttributes(Context, MakeCopy, FixedData));
}


NTSTATUS
SampGetFixedAttributes(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN MakeCopy,
    OUT PVOID *FixedData
    )

/*++

    This API is used to get a pointer to the fixed-length attributes.




Parameters:

    Context - Pointer to an object context block.

    FixedData - Receives a pointer to the fixed-length data.



Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;

    SAMTRACE("SampGetFixedAttributes");

    //
    // Make the data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_FIXED_ATTRIBUTES, 0, FALSE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Return a pointer to the fixed-length attributes.
    //

    if (MakeCopy == FALSE) {
        *FixedData = (PVOID)SampFixedBufferAddress( Context );
        return(STATUS_SUCCESS);
    }

    //
    // Need to make a copy of the fixed data
    //

    *FixedData = (PVOID)MIDL_user_allocate( SampFixedBufferLength( Context ) );
    if ((*FixedData) == NULL) {
        return(STATUS_NO_MEMORY);
    }

    RtlCopyMemory( *FixedData,
                   SampFixedBufferAddress( Context ),
                   SampFixedBufferLength( Context ) );

    return(STATUS_SUCCESS);
}




NTSTATUS
SampSetFixedAttributes(
    IN PSAMP_OBJECT Context,
    IN PVOID FixedData
    )

/*++

    This API is used to replace the fixed-length data attribute.



Parameters:

    Context - Pointer to an object context block.




Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    NTSTATUS
        NtStatus;

    SAMTRACE("SampSetFixedAttributes");

    //
    // Make the fixed-length data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_FIXED_ATTRIBUTES, 0, TRUE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    if ( FixedData != SampFixedBufferAddress( Context ) ) {

        //
        // The caller had a copy of the data, so we must copy the changes
        // over our data buffer.
        //

        RtlCopyMemory( SampFixedBufferAddress( Context ),
                       FixedData,
                       SampFixedBufferLength( Context ) );
    }

    //
    // Mark the buffer dirty now and it will get flushed when the
    // changes are committed.
    //

    Context->FixedDirty = TRUE;

    return( NtStatus );
}




NTSTATUS
SampGetUnicodeStringAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PUNICODE_STRING UnicodeAttribute
    )


/*++

    This API is used to get a copy of a UNICODE_STRING attribute or a
    pointer to the attribute.  If a pointer to the attribute is sought,
    care must be taken to ensure the pointer is not used after it becomes
    invalid. Actions that may cause an attribute pointer to become invalid
    include setting an attribute value or dereferencing and then referencing the
    object again.

    If MakeCopy is FALSE, indicating the string is to be referenced rather
    than copied, then only the body of the string is referenced.  The lengths
    and pointer are set in the provided argument.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be retrieved as a UNICODE_STRING.

    MakeCopy - If TRUE, indicates that a copy of the attribute is to be made.
        If FALSE, indicates a pointer to the attribute is desired without
        making a copy.  WARNING, if this is FALSE, the pointer is only
        valid while the in-memory copy of the attribute remains in place.
        Addition or replacement of any variable length attribute may
        cause the attribute to be moved, and previously returned pointers
        invalidated.

    UnicodeAttribute - Receives a pointer to the UNICODE_STRING.  If
        MakeCopy was specified as TRUE, then this pointer points to a block
        of memory allocated with MIDL_user_allocate() which the caller is
        responsible for freeing (using MIDL_user_free()).



Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/

{
    NTSTATUS NtStatus;
    ULONG Length;

    SAMTRACE("SampGetUnicodeStringAttribute");

    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );

    //
    // Make the data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, FALSE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Get the length of the attribute
    //

    Length = SampObjectAttributeLength( Context, AttributeIndex );
    ASSERT(Length <= 0xFFFF);

    UnicodeAttribute->MaximumLength = (USHORT)Length;
    UnicodeAttribute->Length = (USHORT)Length;

    //
    // If we are not to allocate memory, then just return a pointer
    // to the attribute.
    //

    if (MakeCopy == FALSE) {
        UnicodeAttribute->Buffer =
            (PWSTR)SampObjectAttributeAddress( Context, AttributeIndex );
        return(STATUS_SUCCESS);
    }

    //
    // Need to make a copy of the attribute
    //
    // NOTE: We should test for zero length here and return a NULL pointer
    // in that case, but this change would require verification of all of the
    // callers of this routine, so I'm leaving it as is.
    //

    UnicodeAttribute->Buffer = (PSID)MIDL_user_allocate( Length );
    if ((UnicodeAttribute->Buffer) == NULL) {
        return(STATUS_NO_MEMORY);
    }

    RtlCopyMemory(
        UnicodeAttribute->Buffer,
        SampObjectAttributeAddress( Context, AttributeIndex ),
        Length
        );

    return(STATUS_SUCCESS);

}


NTSTATUS
SampSetUnicodeStringAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PUNICODE_STRING Attribute
    )


/*++

    This API is used to replace a UNICODE_STRING attribute in an
    object's variable length attributes.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be set as a UNICODE_STRING.


    Attribute - Points to the new UNICODE_STRING value.




Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;

    SAMTRACE("SampSetUnicodeStringAttribute");


    //
    // Verify that the passed in unicode string is not malformed
    //

    if ((Attribute->Length>0) && (NULL==Attribute->Buffer))
    {
       return STATUS_INVALID_PARAMETER;
    }

    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );

    //
    // Make the variable-length data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, TRUE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Set the new attribute value...
    //

    NtStatus = SampSetVariableAttribute(
                   Context,
                   AttributeIndex,
                   0,                   // Qualifier not used
                   (PUCHAR)Attribute->Buffer,
                   Attribute->Length
                   );

    return(NtStatus);

}


NTSTATUS
SampGetSidAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PSID *Sid
    )


/*++

    This API is used to get a copy of a SID attribute or a pointer to
    the attribute.  If a pointer to the attribute is sought, care must
    be taken to ensure the pointer is not used after it becomes invalid.
    Actions that may cause an attribute pointer to become invalid include
    setting an attribute value or dereferencing and then referencing the
    object again.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be retrieved as a SID.

    MakeCopy - If TRUE, indicates that a copy of the SID is to be made.
        If FALSE, indicates a pointer to the SID is desired without
        making a copy.  WARNING, if this is FALSE, the pointer is only
        valid while the in-memory copy of the SID remains in place.
        Addition or replacement of any variable length attribute may
        cause the SID to be moved, and previously returned pointers
        invalidated.

    Sid - Receives a pointer to the SID.  If MakeCopy was specified, then
        this pointer points to a block of memory allocated with
        MIDL_user_allocate() which the caller is responsible for freeing
        (using MIDL_user_free()).



Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;

    ULONG
        Length;

    PSID
        SidAttribute;


    SAMTRACE("SampGetSidAttribute");



    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );

    //
    // Make the variable-length data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, FALSE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }



    //
    // Get the address of the attribute in question
    //

    SidAttribute = (PSID)SampObjectAttributeAddress( Context, AttributeIndex );

    //
    // If we are not to allocate memory, then just return a pointer
    // to the attribute.
    //

    if (MakeCopy == FALSE) {
        (*Sid) = SidAttribute;
        return(STATUS_SUCCESS);
    }


    //
    // Need to make a copy of the SID
    //

    Length = SampObjectAttributeLength( Context, AttributeIndex );
    ASSERT(Length == RtlLengthSid( SidAttribute ) );

    (*Sid) = (PSID)MIDL_user_allocate( Length );
    if ((*Sid) == NULL) {
        return(STATUS_NO_MEMORY);
    }

    NtStatus = RtlCopySid( Length, (*Sid), SidAttribute );
    ASSERT(NT_SUCCESS(NtStatus));

    return(NtStatus);

}



NTSTATUS
SampSetSidAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PSID Attribute
    )


/*++

    This API is used to replace a SID attribute in an object's variable
    length attributes.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be set as a SID.


    Attribute - Points to the new SID value.

    Length - The length of the new attribute value (in bytes).



Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;

    SAMTRACE("SampSetSidAttribute");

    //
    // Validate the passed SID
    //

    ASSERT(RtlValidSid(Attribute));


    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );

    //
    // Make the variable-length data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, TRUE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Set the new attribute value...
    //

    NtStatus = SampSetVariableAttribute(
                   Context,
                   AttributeIndex,
                   0,                   // Qualifier not used
                   (PUCHAR)Attribute,
                   RtlLengthSid(Attribute)
                   );

    return(NtStatus);

}


NTSTATUS
SampGetAccessAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PULONG Revision,
    OUT PSECURITY_DESCRIPTOR *SecurityDescriptor
    )


/*++

    This API is used to get a copy of the object access information.
    This includes the security descriptor and revision level of the
    object.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be retrieved.

    MakeCopy - If TRUE, indicates that a copy of the attribute is to be made.
        If FALSE, indicates a pointer to the attribute is desired without
        making a copy.  WARNING, if this is FALSE, the pointer is only
        valid while the in-memory copy of the attribute remains in place.
        Addition or replacement of any variable length attribute may
        cause the attribute to be moved, and previously returned pointers
        invalidated.

    Revision - Receives the revision level from the access information.

    SecurityDescriptor - Receives a pointer to the attribute.  If MakeCopy
        was specified as TRUE, then this pointer points to a block of memory
        allocated with MIDL_user_allocate() which the caller is responsible
        for freeing (using MIDL_user_free()).



Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;

    ULONG
        Length;

    PVOID
        RawAttribute;

    SAMTRACE("SampGetAccessAttribute");


    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );



    //
    // Make the data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, FALSE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }



    //
    // Get the revision level from the qualifier field of the variable
    // array entry.
    //

    (*Revision) = *(SampObjectAttributeQualifier( Context, AttributeIndex ));


    //
    // Get the address of the attribute in question
    //

    RawAttribute = (PVOID)SampObjectAttributeAddress( Context, AttributeIndex );


    //
    // If we are not to allocate memory, then just return a pointer
    // to the attribute.
    //

    if (MakeCopy == FALSE) {
        (*SecurityDescriptor) = (PSECURITY_DESCRIPTOR)RawAttribute;
        return(STATUS_SUCCESS);
    }


    //
    // Need to make a copy of the attribute
    //

    Length = SampObjectAttributeLength( Context, AttributeIndex );

    (*SecurityDescriptor) = (PSECURITY_DESCRIPTOR)MIDL_user_allocate( Length );
    if ((*SecurityDescriptor) == NULL) {
        return(STATUS_NO_MEMORY);
    }

    RtlCopyMemory( (*SecurityDescriptor), RawAttribute, Length );

    return(STATUS_SUCCESS);

}



NTSTATUS
SampSetAccessAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PSECURITY_DESCRIPTOR Attribute,
    IN ULONG Length
    )


/*++

    This API is used to replace a SECURITY_DESCRIPTOR attribute in
    an object's variable length attributes.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be set as a SECURITY_DESCRIPTOR.


    Attribute - Points to the new SECURITY_DESCRIPTOR value.

    Length - The length of the new attribute value (in bytes).



Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;

    SAMTRACE("SampSetAccessAttribute");


    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );

    //
    // Make the variable-length data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, TRUE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Set the new attribute value...
    //

    NtStatus = SampSetVariableAttribute(
                   Context,
                   AttributeIndex,
                   SAMP_REVISION,
                   (PUCHAR)Attribute,
                   Length
                   );

    return(NtStatus);

}


NTSTATUS
SampGetUlongArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PULONG *UlongArray,
    OUT PULONG UsedCount,
    OUT PULONG LengthCount
    )


/*++

    This API is used to get a copy of an array of ULONGs attribute or
    a pointer to the attribute.  If a pointer to the attribute is sought,
    care must be taken to ensure the pointer is not used after it becomes
    invalid. Actions that may cause an attribute pointer to become invalid
    include setting an attribute value or dereferencing and then referencing
    the object again.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be retrieved as a ULONG array.

    MakeCopy - If TRUE, indicates that a copy of the attribute is to be made.
        If FALSE, indicates a pointer to the attribute is desired without
        making a copy.  WARNING, if this is FALSE, the pointer is only
        valid while the in-memory copy of the attribute remains in place.
        Addition or replacement of any variable length attribute may
        cause the attribute to be moved, and previously returned pointers
        invalidated.

    UlongArray - Receives a pointer to the array of ULONGS.  If
        MakeCopy was specified as TRUE, then this pointer points to a block
        of memory allocated with MIDL_user_allocate() which the caller is
        responsible for freeing (using MIDL_user_free()).

    UsedCount - Receives the number of elements used in the array.

    LengthCount - Receives the total number of elements in the array (some
        at the end may be unused).  If this value is zero, then
        UlongArray will be returned as NULL.


Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;

    ULONG
        Length;


    SAMTRACE("SampGetUlongArrayAttribute");



    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );



    //
    // Make the data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, FALSE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Get the count of array elements.
    // If this is zero, then return will a null buffer pointer.
    //

    (*UsedCount) = *(SampObjectAttributeQualifier( Context, AttributeIndex));




    //
    // Get the length of the attribute
    //

    Length = SampObjectAttributeLength( Context, AttributeIndex );

    (*LengthCount) = Length / sizeof(ULONG);

    ASSERT( (*UsedCount) <= (*LengthCount) );

    if ((*LengthCount) == 0) {
        (*UlongArray) = NULL;
        return(STATUS_SUCCESS);
    }


    //
    // If we are not to allocate memory, then just return a pointer
    // to the attribute.
    //

    if (MakeCopy == FALSE) {
        (*UlongArray) =
            (PULONG)SampObjectAttributeAddress( Context, AttributeIndex );
        return(STATUS_SUCCESS);
    }


    //
    // Need to make a copy of the attribute
    //

    (*UlongArray) = (PULONG)MIDL_user_allocate( Length );
    if ((*UlongArray) == NULL) {
        return(STATUS_NO_MEMORY);
    }


    RtlCopyMemory( (*UlongArray),
                   SampObjectAttributeAddress( Context, AttributeIndex ),
                   Length );

    return(STATUS_SUCCESS);

}


NTSTATUS
SampSetUlongArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PULONG Attribute,
    IN ULONG UsedCount,
    IN ULONG LengthCount
    )


/*++

    This API is used to replace a ULONG array attribute in an
    object's variable length attributes.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be set.


    Attribute - Points to the new ULONG array value.

    UsedCount - The number of used elements in the array.

    LengthCount - the total number of elements in the array (some at the
        end may be unused).


Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;

    SAMTRACE("SampSetUlongArrayAttribute");

    ASSERT( LengthCount >= UsedCount );

    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );

    //
    // Make the variable-length data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, TRUE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Set the new attribute value...
    //

    NtStatus = SampSetVariableAttribute(
                   Context,
                   AttributeIndex,
                   UsedCount,           // Qualifier contains used element count
                   (PUCHAR)Attribute,
                   (LengthCount * sizeof(ULONG))
                   );

    return(NtStatus);

}


NTSTATUS
SampGetLargeIntArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PLARGE_INTEGER *LargeIntArray,
    OUT PULONG Count
    )


/*++

    This API is used to get a copy of an array of LARGE_INTEGERs attribute or
    a pointer to the attribute.  If a pointer to the attribute is sought,
    care must be taken to ensure the pointer is not used after it becomes
    invalid. Actions that may cause an attribute pointer to become invalid
    include setting an attribute value or dereferencing and then referencing
    the object again.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be retrieved.

    MakeCopy - If TRUE, indicates that a copy of the attribute is to be made.
        If FALSE, indicates a pointer to the attribute is desired without
        making a copy.  WARNING, if this is FALSE, the pointer is only
        valid while the in-memory copy of the attribute remains in place.
        Addition or replacement of any variable length attribute may
        cause the attribute to be moved, and previously returned pointers
        invalidated.

    LargeIntArray - Receives a pointer to the array of ULONGS.  If
        MakeCopy was specified as TRUE, then this pointer points to a block
        of memory allocated with MIDL_user_allocate() which the caller is
        responsible for freeing (using MIDL_user_free()).


    Count - Receives the number of elements in the array.  If this value
        is zero, then LargeIntArray will be returned as NULL.

Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;

    ULONG
        Length;


    SAMTRACE("SampGetLargeIntArrayAttribute");



    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );



    //
    // Make the data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, FALSE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Get the count of array elements.
    // If this is zero, then return will a null buffer pointer.
    //

    (*Count) = *(SampObjectAttributeQualifier( Context, AttributeIndex));

    if ((*Count) == 0) {
        (*LargeIntArray) = NULL;
        return(STATUS_SUCCESS);
    }



    //
    // Get the length of the attribute
    //

    Length = SampObjectAttributeLength( Context, AttributeIndex );

    ASSERT((*Count) == (Length / sizeof(LARGE_INTEGER)) );



    //
    // If we are not to allocate memory, then just return a pointer
    // to the attribute.
    //

    if (MakeCopy == FALSE) {
        (*LargeIntArray) =
            (PLARGE_INTEGER)SampObjectAttributeAddress( Context, AttributeIndex );
        return(STATUS_SUCCESS);
    }


    //
    // Need to make a copy of the attribute
    //

    (*LargeIntArray) = (PLARGE_INTEGER)MIDL_user_allocate( Length );
    if ((*LargeIntArray) == NULL) {
        return(STATUS_NO_MEMORY);
    }


    RtlCopyMemory( (*LargeIntArray),
                   SampObjectAttributeAddress( Context, AttributeIndex ),
                   Length );

    return(STATUS_SUCCESS);

}


NTSTATUS
SampSetLargeIntArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PLARGE_INTEGER Attribute,
    IN ULONG Count
    )


/*++

    This API is used to replace a LARGE_INTEGER array attribute in an
    object's variable length attributes.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be set.


    Attribute - Points to the new LARGE_INTEGER array value.

    Count - The number of elements in the array.


Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;

    SAMTRACE("SampSetLargeIntArrayAttribute");


    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );

    //
    // Make the variable-length data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, TRUE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Set the new attribute value...
    //

    NtStatus = SampSetVariableAttribute(
                   Context,
                   AttributeIndex,
                   Count,                   // Qualifier contains element count
                   (PUCHAR)Attribute,
                   (Count * sizeof(LARGE_INTEGER))
                   );

    return(NtStatus);

}


NTSTATUS
SampGetSidArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PSID *SidArray,
    OUT PULONG Length,
    OUT PULONG Count
    )


/*++

    This API is used to get a copy of an array of SIDs attribute or
    a pointer to the attribute.  If a pointer to the attribute is sought,
    care must be taken to ensure the pointer is not used after it becomes
    invalid. Actions that may cause an attribute pointer to become invalid
    include setting an attribute value or dereferencing and then referencing
    the object again.


    NOTE: This routine does not define the structure of a SID array,
          so this effectively is a GetRawDataAttribute routine.



Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be retrieved.

    MakeCopy - If TRUE, indicates that a copy of the attribute is to be made.
        If FALSE, indicates a pointer to the attribute is desired without
        making a copy.  WARNING, if this is FALSE, the pointer is only
        valid while the in-memory copy of the attribute remains in place.
        Addition or replacement of any variable length attribute may
        cause the attribute to be moved, and previously returned pointers
        invalidated.

    SidArray - Receives a pointer to the array of SIDs.  If
        MakeCopy was specified as TRUE, then this pointer points to a block
        of memory allocated with MIDL_user_allocate() which the caller is
        responsible for freeing (using MIDL_user_free()).


    Count - Receives the number of elements in the array.  If this value
        is zero, then SidArray will be returned as NULL.

Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;


    SAMTRACE("SampGetSidArrayAttribute");



    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );



    //
    // Make the data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, FALSE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Get the count of array elements.
    // If this is zero, then return will a null buffer pointer.
    //

    (*Count) = *(SampObjectAttributeQualifier( Context, AttributeIndex));

    if ((*Count) == 0) {
        (*SidArray) = NULL;
        (*Length) = 0;
        return(STATUS_SUCCESS);
    }



    //
    // Get the length of the attribute
    //

    (*Length) = SampObjectAttributeLength( Context, AttributeIndex );




    //
    // If we are not to allocate memory, then just return a pointer
    // to the attribute.
    //

    if (MakeCopy == FALSE) {
        (*SidArray) =
            (PSID)SampObjectAttributeAddress( Context, AttributeIndex );
        return(STATUS_SUCCESS);
    }


    //
    // Need to make a copy of the attribute
    //

    (*SidArray) = (PSID)MIDL_user_allocate( (*Length) );
    if ((*SidArray) == NULL) {
        return(STATUS_NO_MEMORY);
    }


    RtlCopyMemory( (*SidArray),
                   SampObjectAttributeAddress( Context, AttributeIndex ),
                   (*Length) );

    return(STATUS_SUCCESS);

}


NTSTATUS
SampSetSidArrayAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PSID Attribute,
    IN ULONG Length,
    IN ULONG Count
    )


/*++

    This API is used to replace a SID array attribute in an
    object's variable length attributes.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be set.


    Attribute - Points to the new SID array value.

    Length - Number of byte in the attribute buffer.

    Count - Number of SIDs in the array.


Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;

    SAMTRACE("SampSetSidArrayAttribute");


    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );

    //
    // Make the variable-length data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, TRUE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Set the new attribute value...
    //

    NtStatus = SampSetVariableAttribute(
                   Context,
                   AttributeIndex,
                   Count,                   // Qualifier contains element count
                   (PUCHAR)Attribute,
                   Length
                   );

    return(NtStatus);

}


NTSTATUS
SampGetLogonHoursAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN BOOLEAN MakeCopy,
    OUT PLOGON_HOURS LogonHours
    )


/*++

    This API is used to get a copy of a logon hours attribute or
    a pointer to the attribute.  If a pointer to the attribute is sought,
    care must be taken to ensure the pointer is not used after it becomes
    invalid. Actions that may cause an attribute pointer to become invalid
    include setting an attribute value or dereferencing and then referencing
    the object again.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be retrieved.

    MakeCopy - If TRUE, indicates that a copy of the attribute is to be made.
        If FALSE, indicates a pointer to the attribute is desired without
        making a copy.  WARNING, if this is FALSE, the pointer is only
        valid while the in-memory copy of the attribute remains in place.
        Addition or replacement of any variable length attribute may
        cause the attribute to be moved, and previously returned pointers
        invalidated.

    LogonHours - Receives the logon hours information.  If MakeCopy is TRUE
        then the bitmap pointed to from within this structure will be a copy
        of the attribute and must be deallocated uing MIDL_user_free().
        Otherwise, this same field will point to the bitmap in the on-disk
        buffer.


Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;

    ULONG
        Length,
        Units;


    SAMTRACE("SampGetLogonHoursAttribute");



    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );



    //
    // Make the data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, FALSE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    //
    // Get the time units.
    // If this is zero, then return will a null buffer pointer.
    //

    Units = *(SampObjectAttributeQualifier( Context, AttributeIndex));
    ASSERT(Units <= 0xFFFF);
    LogonHours->UnitsPerWeek = (USHORT)Units;

    if (Units == 0) {
        LogonHours->LogonHours = NULL;
        return(STATUS_SUCCESS);
    }




    //
    // If we are not to allocate memory, then just return a pointer
    // to the attribute.
    //

    if (MakeCopy == FALSE) {
        LogonHours->LogonHours =
            (PUCHAR)SampObjectAttributeAddress( Context, AttributeIndex );
        return(STATUS_SUCCESS);
    }


    //
    // Get the length of the attribute
    //

    Length = SampObjectAttributeLength( Context, AttributeIndex );
    ASSERT(Length <= 0xFFFF);


    //
    // Need to make a copy of the attribute
    //

    LogonHours->LogonHours =
        (PUCHAR)MIDL_user_allocate( Length );
    if (LogonHours->LogonHours == NULL) {
        return(STATUS_NO_MEMORY);
    }


    RtlCopyMemory( LogonHours->LogonHours,
                   SampObjectAttributeAddress( Context, AttributeIndex ),
                   Length );

    return(STATUS_SUCCESS);

}



NTSTATUS
SampPreventTimeUnitChange(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PLOGON_HOURS Attribute
    )
/*++

    This routine prevents clients from changing the logon-hours TIME UNITS
    for the specified account.

    Note: In the NT5 Beta 1 release, support for changing the time units of
    the account's logon hours is missing, pending further work. Because this
    is not supported, this routine is called by SampSetLogonHoursAttribute
    to disallow any changes to the time units.

    Since very few, if any, clients actually know how to/desire changing
    this attribute, it may not be supported in future releases of NT. If
    this is not the case, then this routine is temporary and should be re-
    moved when support for this operation is available. Also note that the
    utilities, usrmgr.exe and "net user" do not support this type of change.

Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be set.

    Attribute - Points to the new LOGON_HOURS value.

Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS NtStatus = STATUS_NOT_SUPPORTED;
    ULONG CurrentUnits = 0;
    ULONG CurrentLength = 0;
    ULONG NewUnits = 0;
    ULONG NewLength = 0;
    PUCHAR LogonHours = NULL;

    ASSERT(NULL != Attribute);

    // It is invalid to specify non-zero units and a NULL bitmask for the
    // logon hours. SAM accounts, however, are initially created with a NULL
    // logon-hours attribute and units equal to zero, which is legal and
    // allows the account to logon at any time (the default). If the bitmask
    // is NULL, this means that the caller does not want to change the logon
    // hours (or time units).

    if (NULL == Attribute->LogonHours)
    {
        if (0 != Attribute->UnitsPerWeek)
        {
            return(STATUS_INVALID_PARAMETER);
        }

        // No change in logon hours (or time units) requested by caller.

        return(STATUS_SUCCESS);
    }

    // Get the current time units and logon-hours buffer length from the
    // specified account. Compare these values to the input time units and
    // length specified in the logon hours parameter. If they are the same,
    // return status success, otherwise return STATUS_NOT_SUPPORTED to dis-
    // allow this kind of modification.
    //
    // Days per week    = 7,        SAM_DAYS_PER_WEEK
    // Hours per week   = 168,      SAM_HOURS_PER_WEEK
    // Minutes per week = 10080,    SAM_MINUTES_PER_WEEK

    LogonHours = (PUCHAR)SampObjectAttributeAddress(Context, AttributeIndex);
    CurrentUnits = *(SampObjectAttributeQualifier(Context, AttributeIndex));
    CurrentLength = SampObjectAttributeLength(Context, AttributeIndex);

    ASSERT(CurrentUnits <= SAM_MINUTES_PER_WEEK);
    ASSERT(CurrentLength <= SAM_MINUTES_PER_WEEK);

    if (NULL == LogonHours)
    {
        if ((0 != CurrentUnits) || (0 != CurrentLength))
        {
            return(STATUS_INTERNAL_ERROR);
        }
    }

    // The account's logon hours are non-NULL and non-zero time units have
    // been specified, so perform further validation.

    NewUnits = Attribute->UnitsPerWeek;
    NewLength = ((NewUnits + 7) / 8);

    ASSERT(NewUnits <= SAM_MINUTES_PER_WEEK);
    ASSERT(NewLength <= SAM_MINUTES_PER_WEEK);

    if ((CurrentUnits == NewUnits) && (CurrentLength == NewLength))
    {
        // If the time units are the same then there is no change being asked
        // for in logon hours time units.

        return(STATUS_SUCCESS);
    }

    if ((0 == CurrentUnits) &&
        (0 == CurrentLength) &&
        (SAM_HOURS_PER_WEEK == NewUnits) &&
        ((SAM_HOURS_PER_WEEK / 8) == NewLength))
    {
        // Creating new users with usrmgr.exe hits a case where the logon
        // time units are zero, but the requested new units are the default
        // SAM_HOURS_PER_WEEK. Let this case return successfully, otherwise
        // usrmgr.exe cannot be used to create accounts or modify logon
        // hours.

        return(STATUS_SUCCESS);
    }

    return(NtStatus);
}


NTSTATUS
SampSetLogonHoursAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN PLOGON_HOURS Attribute
    )


/*++

    This API is used to replace a LOGON_HOURS attribute in an
    object's variable length attributes.

    UnitsPerWeek are stored in the Qualifier field of the attribute.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be set.


    Attribute - Points to the new LOGON_HOURS value.




Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/
{
    NTSTATUS NtStatus;
    PUCHAR LogonHours;
    ULONG Length;
    USHORT UnitsPerWeek;

    SAMTRACE("SampSetLogonHoursAttribute");

    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );

    //
    // Make the variable-length data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, TRUE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // Grab the UnitsPerWeek value for the logon_hours structure.
    // We use this to calculate the length of the data.
    //

    // If the input logon hours (Attribute) is NULL, the caller is not
    // changing the logon hours or time unit. Otherwise, the caller has
    // specified explicit logon-hours data, so verify that the unit of
    // time in the logon hours is not changing. If it is not changing,
    // continue processing the request.

    if ( Attribute == NULL ) {

        UnitsPerWeek = 0;
        LogonHours = NULL;

    } else {

        // BUG: Temporarily disable logon-hours-time-unit modification.

        // For the NT5 Beta, the little-used capability that allows the user
        // to change the time units for logon hours will not be enabled.
        // Supporting this feature in the DS version is a significant enough
        // change to the underlying code as to make it too risky for Beta
        // (and given that it is probably not used--usrmgr.exe and "net user"
        // do not use this feature--it is not worth the risk.

        NtStatus = SampPreventTimeUnitChange(Context,
                                             AttributeIndex,
                                             Attribute);

        if (!NT_SUCCESS(NtStatus)) {

            // The caller is attempting to change the logon-hours time units,
            // which is unsupported in the Beta release, so return the error.

            return(NtStatus);
        }

        UnitsPerWeek = Attribute->UnitsPerWeek;
        LogonHours = Attribute->LogonHours;

    }

    //
    // Validate the data - make sure that if the units per week are non-zero
    // then the logon hours buffer is non-NULL.
    //

    if ( (UnitsPerWeek != 0) && (LogonHours == NULL) ) {

        return(STATUS_INVALID_PARAMETER);
    }
    //
    // Calculate length of logon_hours structure
    //

    Length = (ULONG)((UnitsPerWeek + 7) / 8);

    //
    // Set the new attribute value...
    //

    NtStatus = SampSetVariableAttribute(
                   Context,
                   AttributeIndex,
                   (ULONG)UnitsPerWeek, // Qualifier contains units per week
                   LogonHours,
                   Length
                   );

    return(NtStatus);

}

NTSTATUS
SampUpgradeSecretDataToDSAndSetClassId(
     IN OUT  PSAMP_OBJECT  UserContext
     )
/*+

    Upgrades all Encrypted properties from the Encryption
    system used in the Registry to the Encryption System in
    the DS. Also sets the Correct Class Id for Computer accounts
    for computers

    Parameters:

        UserContext -- Context to the User Object

    Return Values:

        STATUS_SUCCESS
        Other Error Codes
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    UNICODE_STRING  Buffer, TempString,TempString2;
    ULONG           i;
    ULONG  SecretDataAttributes[] = {
                                        SAMP_USER_DBCS_PWD,
                                        SAMP_USER_UNICODE_PWD,
                                        SAMP_USER_LM_PWD_HISTORY,
                                        SAMP_USER_NT_PWD_HISTORY
                                    };
    SAMP_ENCRYPTED_DATA_TYPE DataType[] = {
                                        LmPassword,
                                        NtPassword,
                                        LmPasswordHistory,
                                        NtPasswordHistory
                                        };

    PVOID                           FixedData;
    SAMP_V1_0A_FIXED_LENGTH_USER    V1aFixed;
    ULONG   Rid;
    BOOLEAN fSetFixedAttributes = FALSE;

    RtlZeroMemory(&TempString,sizeof(UNICODE_STRING));
    RtlZeroMemory(&TempString2,sizeof(UNICODE_STRING));

    //
    // Get the Rid, note that DS upgrade code does not
    // initialize TypeBody.Rid, so fetch the Rid from
    // Context->OnDisk
    //

    NtStatus = SampGetFixedAttributes(
                    UserContext,
                    FALSE, // Don't make Copy
                    &FixedData
                    );
    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    RtlCopyMemory(&V1aFixed,FixedData,sizeof(SAMP_V1_0A_FIXED_LENGTH_USER));
    Rid = V1aFixed.UserId;

    //
    // Set the Class Id based on User account Control
    //

    if (V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK)
    {
        //
        // Computer Account
        //


        //
        // Change the Class Id to class computer
        //

        UserContext->DsClassId = CLASS_COMPUTER;

        //
        // Change the primary group Id to DOMAIN_COMPUTERS
        // (or DOMAIN_CONTROLLERS )
        //

        //
        // We determine the primary group id only in DS case,
        // so turn the object's flags to DS_OBJECT, after
        // we use it, set it back to REGISTRY_OBJECT in case
        // some other routines need that flags.
        //

        SetDsObject(UserContext);
        V1aFixed.PrimaryGroupId = SampDefaultPrimaryGroup(
                                     UserContext,
                                     V1aFixed.UserAccountControl
                                    );
        SetRegistryObject(UserContext);


        fSetFixedAttributes = TRUE;

    }
    else if (V1aFixed.UserAccountControl & USER_TEMP_DUPLICATE_ACCOUNT) 
    {
        //
        // Eliminate the concept of temp duplicate accounts from SAM.
        // Migrate them as normal user accounts
        //

        V1aFixed.UserAccountControl &= ~((ULONG)USER_TEMP_DUPLICATE_ACCOUNT);
        V1aFixed.UserAccountControl |=USER_NORMAL_ACCOUNT|USER_ACCOUNT_DISABLED;

        fSetFixedAttributes = TRUE;
    }

    //
    //  Administrator on Domain Controller can't be disabled
    // 
    if ((DOMAIN_USER_RID_ADMIN) == Rid &&
        (V1aFixed.UserAccountControl & USER_ACCOUNT_DISABLED)) 
    {
        V1aFixed.UserAccountControl &= ~USER_ACCOUNT_DISABLED;

        fSetFixedAttributes = TRUE;
    }

    if (fSetFixedAttributes)
    {
        NtStatus = SampSetFixedAttributes(
                        UserContext,
                        &V1aFixed
                        );

        if (!NT_SUCCESS(NtStatus))
            goto Error;
    }

    for (i=0;i<ARRAY_COUNT(SecretDataAttributes);i++)
    {


        RtlZeroMemory(&TempString,sizeof(UNICODE_STRING));
        RtlZeroMemory(&TempString2,sizeof(UNICODE_STRING));

        //
        // Read The Secret Data Attribute From Registry
        //

        NtStatus = SampGetUnicodeStringAttribute(
                        UserContext,
                        SecretDataAttributes[i],
                        FALSE,
                        &Buffer
                        );

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }


        //
        // Decrypt It
        //

        NtStatus = SampDecryptSecretData(
                   &TempString,
                   DataType[i],
                   &Buffer,
                   Rid
                   );

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        //
        // Re Encrypt It
        //

        NtStatus = SampEncryptSecretData(
                        &TempString2,
                        SAMP_NO_ENCRYPTION,
                        DataType[i],
                        &TempString,
                        Rid
                        );

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        //
        // Write it Back
        //

        NtStatus = SampSetUnicodeStringAttribute(
                        UserContext,
                        SecretDataAttributes[i],
                        &TempString2
                        );

        if (!NT_SUCCESS(NtStatus))
            goto Error;


        SampFreeUnicodeString(&TempString);
        TempString.Buffer = NULL;
        SampFreeUnicodeString(&TempString2);
        TempString2.Buffer = NULL;

    }

Error:

    if (NULL!=TempString.Buffer)
        SampFreeUnicodeString(&TempString);

    if (NULL!=TempString2.Buffer)
        SampFreeUnicodeString(&TempString2);

    return NtStatus;
}



NTSTATUS
SampNt4ToNt5Object (
     IN OUT  PSAMP_OBJECT     pObject
     )
/*++

    This routine upgrades the security descriptor of the passed in object
    and sets the SAMP_*_MEMBERS field to zero length.

    This routine is only called during the process of transferring SAM objects
    from the registry to the DS.

Parameters:

    pObject - a non pointer to the SAM object to be converted

Return Values:

    STATUS_SUCCESS - The service completed successfully.

--*/
{
    NTSTATUS NtStatus;
    ULONG SdRevision, SdLength;
    ULONG SdIndex = 0;
    ULONG DsRevision = SAMP_DS_REVISION; 
    SAMP_V1_FIXED_LENGTH_SERVER ServerFixedAttributes;

    //
    // These resources must be released
    //
    PVOID Nt4SecDescr = NULL;
    PVOID Nt5SecDescr = NULL;

    //
    //  Parameter check
    //
    ASSERT(pObject);

    //
    // Set The DS Class id on the context. This is needed by
    // security descriptor conversion routines.
    //

    pObject->DsClassId = SampDsClassFromSamObjectType(pObject->ObjectType);

    //
    // Determine the attribute index of the security descriptor
    // and wipe out the GROUP_MEMBERS_UNUSED field
    //

    NtStatus = STATUS_SUCCESS;
    switch ( pObject->ObjectType ) {

        case SampUserObjectType:

            // Upgrade all the Password Properties
            NtStatus = SampUpgradeSecretDataToDSAndSetClassId(pObject);

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = SampSetVariableAttribute(pObject,
                                                SAMP_USER_GROUPS,
                                                0, NULL, 0);
            }

            SdIndex = SAMP_USER_SECURITY_DESCRIPTOR;

            break;

        case SampGroupObjectType:

            NtStatus = SampSetVariableAttribute(pObject,
                                                SAMP_GROUP_MEMBERS,
                                                0, NULL, 0);

            SdIndex = SAMP_GROUP_SECURITY_DESCRIPTOR;

            break;


        case SampAliasObjectType:

            NtStatus = SampSetVariableAttribute(pObject,
                                                SAMP_ALIAS_MEMBERS,
                                                0, NULL, 0);

            SdIndex = SAMP_ALIAS_SECURITY_DESCRIPTOR;

            break;

        case SampDomainObjectType:

            SdIndex = SAMP_DOMAIN_SECURITY_DESCRIPTOR;
            break;

    case SampServerObjectType:

            ServerFixedAttributes.RevisionLevel = SAMP_DS_REVISION;

            NtStatus = SampSetFixedAttributes(
                            pObject,
                            &ServerFixedAttributes
                            );

            SdIndex = SAMP_SERVER_SECURITY_DESCRIPTOR;
            break;

        default:

            ASSERT(FALSE&&"Unknown Object Type");
    }

    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    //
    // Get the Nt5 security descriptor
    //
    NtStatus  =  SampGetObjectSD(pObject,
                                 &SdLength,
                                 &Nt4SecDescr);
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    NtStatus =  SampConvertNt4SdToNt5Sd(Nt4SecDescr,
                                        pObject->ObjectType,
                                        pObject,
                                        &Nt5SecDescr
                                       );
    if (!NT_SUCCESS(NtStatus)) {
        goto Cleanup;
    }

    SdLength = GetSecurityDescriptorLength(Nt5SecDescr);

    NtStatus = SampSetAccessAttribute(pObject,
                                      SdIndex,
                                      Nt5SecDescr,
                                      SdLength);

    if (NT_SUCCESS(NtStatus))
    {
        //
        // Check all per attribute Dirty Bits in the
        // context
        //

        RtlSetAllBits(&pObject->PerAttributeDirtyBits);
    }


Cleanup:

    if ( Nt4SecDescr ) {
        MIDL_user_free(Nt4SecDescr);
    }

    if ( Nt5SecDescr ) {
        MIDL_user_free(Nt5SecDescr);
    }

    return NtStatus;

}


NTSTATUS
SampRegObjToDsObj(
     IN OUT  PSAMP_OBJECT     pObject,
     OUT     ATTRBLOCK**      ppAttrBlock
     )
/*++

    This routine changes pObject from a Registry Object to a DS Object; as well
    it creates a ATTRBLOCK from the data in pObject.

Parameters:

    pObject - a non pointer to the SAM object to be converted

    ppAttrBlock - a non null pointer to location where a pointer to the attrblock
                  can be placed

Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to receive a copy of the attribute could not
        be allocated.

--*/

{
    NTSTATUS NtStatus;

    ULONG TotalLength      = 0,
          FixedLength      = 0,
          VarArrayLength   = 0,
          VarLength        = 0;

    PSAMP_VARIABLE_LENGTH_ATTRIBUTE pVarLengthAttr;
    PBYTE  pNewOnDisk, pTemp;
    ULONG i;

    PSAMP_VARIABLE_LENGTH_ATTRIBUTE pVarLengthAttrTemp;

    SAMTRACE("SampRegObjToDsObj");

    //
    // Begin lazy thread transactioning.
    //

    NtStatus = SampMaybeBeginDsTransaction(TransactionWrite);
    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    //
    // Adjust attributes so object have NT5 style properties
    //
    NtStatus = SampNt4ToNt5Object(pObject);
    if (!NT_SUCCESS(NtStatus)) {
        return NtStatus;
    }

    //
    // Convert SAM registry object to a SAM ds object
    //

    //
    // Determine the length of all of the data
    //

    FixedLength = SampObjectInformation[pObject->ObjectType].FixedLengthSize;

    VarArrayLength = SampObjectInformation[(pObject)->ObjectType].VariableAttributeCount *
                   sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE);

    pVarLengthAttr = SampVariableArrayAddress(pObject);

    VarLength = pVarLengthAttr[SampObjectInformation[(pObject)->ObjectType].VariableAttributeCount-1].Offset +
                pVarLengthAttr[SampObjectInformation[(pObject)->ObjectType].VariableAttributeCount-1].Length;

    //
    //  Adjust the offset since SAM/DS objects' offsets are based from the beginning of the
    // variable attribute array.
    //
    for ( i = 0; i < SampObjectInformation[(pObject)->ObjectType].VariableAttributeCount; i++ ) {
        pVarLengthAttr[i].Offset += VarArrayLength;
    }

    TotalLength = FixedLength + VarArrayLength + VarLength;

    // Reserve the space for the new OnDisk buffer
    pNewOnDisk = RtlAllocateHeap(RtlProcessHeap(), 0, TotalLength);
    if ( !pNewOnDisk ) {
        return STATUS_NO_MEMORY;
    }
    RtlZeroMemory(pNewOnDisk, TotalLength);

    //
    // Now copy over the attributes into the new buffer
    //

    pTemp = pNewOnDisk;
    RtlCopyMemory(pTemp, SampFixedBufferAddress(pObject), FixedLength);

    pTemp = pNewOnDisk + SampDwordAlignUlong(FixedLength);
    RtlCopyMemory(pTemp, SampVariableArrayAddress(pObject), VarArrayLength);

    pTemp = pNewOnDisk + SampDwordAlignUlong(FixedLength + VarArrayLength);
    RtlCopyMemory(pTemp, (PBYTE)pObject->OnDisk + SampVariableDataOffset(pObject), VarLength);

    //
    // Transfer the memory
    //
    RtlFreeHeap(RtlProcessHeap(), 0, pObject->OnDisk);
    pObject->OnDisk = pNewOnDisk;

    pObject->OnDiskAllocated = TotalLength;
    pObject->OnDiskUsed = TotalLength;
    pObject->OnDiskFree = 0;
    SetDsObject(pObject);

    //
    // Now convert into ATTRBLOCK for DS
    //

    NtStatus = SampConvertCombinedAttributesToAttrBlock(
                   pObject,
                   SampDsFixedBufferLength(pObject),
                   SampDsVariableBufferLength(pObject),
                   ppAttrBlock);


    return NtStatus;


}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private routines                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

BOOLEAN
SampDsIsAlreadyValidData(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeGroup
    )

/*++

Description:

    This routine determines whether or not the attributes are in memory or
    not (i.e. valid or not). OnDisk should only be NULL for a newly created
    context that has just been initialized, otherwise it is non-NULL.

Parameters:

    Context - Pointer to an object context block.

    AttributeGroup - Flag, either SAMP_FIXED_ATTRIBUTES or SAMP_VARIABLE-
        ATTRIBUTES.

Return Values:

    This routine returns a flag, TRUE if the attributes are in memory, FALSE
    otherwise.

--*/

{
    BOOLEAN Flag = FALSE;

    SAMTRACE("SampDsIsAlreadyValidData");

    if (NULL != Context->OnDisk)
    {
        if (AttributeGroup == SAMP_FIXED_ATTRIBUTES)
        {
            if (SampFixedAttributesValid(Context))
            {
                Flag = TRUE;
            }
        }
        else
        {
            ASSERT(AttributeGroup == SAMP_VARIABLE_ATTRIBUTES);

            if (SampVariableAttributesValid(Context))
            {
                Flag = TRUE;
            }
        }
    }

    return(Flag);
}



NTSTATUS
SampDsPrepareAttrBlock(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG FixedCount,
    IN PSAMP_FIXED_ATTRIBUTE_TYPE_INFO FixedAttrIds[],
    IN ULONG VarCount,
    IN ULONG WhichFields,
    IN PSAMP_VAR_ATTRIBUTE_TYPE_INFO VarAttrIds[],
    OUT PDSATTRBLOCK AttrBlock
    )

/*++

Description:

    This routine sets up a DSATTRBLOCK in preparation to read the DS. An
    attribute block is created containaing the attribute identifiers for
    the attributes to read.

Parameters:

    FixedCount - Number of fixed-length attributes.

    FixedAttrIds - Array of attribute IDs of the fixed-length attributes.

    VarCount - Number of variable-length attributes.

    VarAttrIds - Array of attribute IDs of the fixed-length attributes.

    AttrBlock - Pointer, the generated attribute block with IDs.

Return Values:

    STATUS_SUCCESS if successful, error otherwise.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG i = 0;
    ULONG Index=0;
    ULONG AttrCount = FixedCount + VarCount;
    PDSATTR Attributes = NULL;

    SAMTRACE("SampDsPrepareAttrBlock");

    Attributes = RtlAllocateHeap(RtlProcessHeap(),
                                 0,
                                 AttrCount * sizeof(DSATTR));

    if (NULL != Attributes)
    {
        RtlZeroMemory(Attributes, (AttrCount * sizeof(DSATTR)));

        // This loop is set up to handle the case where both fixed-length
        // and variable-length attribute buffers are passed in (which may
        // be needed for combined attribute conversion).

        AttrBlock->attrCount=0;
        for (i = 0; i < AttrCount; i++)
        {
            if (i < FixedCount)
            {
                // Set the fixed-length attribute type/id.

                Attributes[Index].attrTyp = FixedAttrIds[i].Type;
            }
            else
            {
                // ASSERT(0 <= (i - FixedCount));

                // Set the variable-length attribute type/id.
                // Do not request the group membership attributes

                if ((0!=WhichFields) && 
                   (VarAttrIds[i-FixedCount].FieldIdentifier !=0) &
                   ((VarAttrIds[i-FixedCount].FieldIdentifier & WhichFields)==0))
                {
                    continue;
                }

                if (VarAttrIds[i-FixedCount].IsGroupMembershipAttr)
                {
                    continue;
                }



                Attributes[Index].attrTyp = VarAttrIds[i - FixedCount].Type;
            }

            // The read operation does not require setting up valCount or
            // pAVal.

            Attributes[Index].AttrVal.valCount = 0;
            Attributes[Index].AttrVal.pAVal = NULL;
            AttrBlock->attrCount++;
            Index++;
        }

        // Hook up the attributes to the top-level attrblock and return.

        AttrBlock->pAttr = Attributes;

        NtStatus = STATUS_SUCCESS;
    }
    else
    {
        NtStatus = STATUS_NO_MEMORY;
    }

    return(NtStatus);
}



NTSTATUS
SampDsMakeAttrBlock(
    IN INT ObjectType,
    IN ULONG AttributeGroup,
    IN ULONG WhichFields,
    OUT PDSATTRBLOCK AttrBlock
    )

/*++

Description:

    This routine determines the object type and sets the count of fixed-
    length and variable-length attributes for the object. SampDsPrepare-
    AttrBlock to set up the DSATTRBLOCK.

Parameters:

    ObjectType - SAM object ID.

    AttributeGroup - Flag, either SAMP_FIXED_ATTRIBUTES or SAMP_VARIABLE-
        ATTRIBUTES.

    AttrBlock - Pointer, generated attribute block.

Return Values:

    STATUS_SUCCESS if no errors.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG FixedLenAttrCount = 0;
    ULONG VarLenAttrCount = 0;

    SAMTRACE("SampDsMakeAttrBlock");

    switch(ObjectType)
    {

    case SampServerObjectType:
        FixedLenAttrCount = SAMP_SERVER_FIXED_ATTR_COUNT;
        VarLenAttrCount = SAMP_SERVER_VARIABLE_ATTRIBUTES;
        break;

    case SampDomainObjectType:
        FixedLenAttrCount = SAMP_DOMAIN_FIXED_ATTR_COUNT;
        VarLenAttrCount = SAMP_DOMAIN_VARIABLE_ATTRIBUTES;
        break;

    case SampGroupObjectType:
        FixedLenAttrCount = SAMP_GROUP_FIXED_ATTR_COUNT;
        VarLenAttrCount = SAMP_GROUP_VARIABLE_ATTRIBUTES;
        break;

    case SampAliasObjectType:
        FixedLenAttrCount = SAMP_ALIAS_FIXED_ATTR_COUNT;
        VarLenAttrCount = SAMP_ALIAS_VARIABLE_ATTRIBUTES;
        break;

    case SampUserObjectType:
        FixedLenAttrCount = SAMP_USER_FIXED_ATTR_COUNT;
        VarLenAttrCount = SAMP_USER_VARIABLE_ATTRIBUTES;
        break;

    default:

        ASSERT(FALSE && "Invalid SampObjectType");
        break;

    }

    if ((0 < FixedLenAttrCount) && (0 < VarLenAttrCount))
    {
        if (SAMP_FIXED_ATTRIBUTES == AttributeGroup)
        {
            NtStatus = SampDsPrepareAttrBlock(
                            ObjectType,
                            FixedLenAttrCount,
                            &SampFixedAttributeInfo[ObjectType][0],
                            0,
                            WhichFields,
                            NULL,
                            AttrBlock);
        }
        else
        {
            NtStatus = SampDsPrepareAttrBlock(
                            ObjectType,
                            0,
                            NULL,
                            VarLenAttrCount,
                            WhichFields,
                            &SampVarAttributeInfo[ObjectType][0],
                            AttrBlock);
        }
    }

    return(NtStatus);
}



NTSTATUS
SampDsConvertReadAttrBlock(
    IN INT ObjectType,
    IN ULONG AttributeGroup,
    IN PDSATTRBLOCK AttrBlock,
    OUT PVOID *SamAttributes,
    OUT PULONG FixedLength,
    OUT PULONG VariableLength
    )

/*++

Description:

    This routine converts an attribute block (DSATTRBLOCK) into a SAM attri-
    bute buffer. This is used to convert the resultant attributes from a DS
    read into the SAM attribute format.

Parameters:

    ObjectType - SAM object ID.

    AttributeGroup - Flag, either SAMP_FIXED_ATTRIBUTES or SAMP_VARIABLE-
        ATTRIBUTES.

    AttrBlock - Pointer, input attribute block.

    SamAttributes - Pointer, returned SAM attributes.

    FixedLength - Pointer, byte count of the fixed-length attributes size.

    VariableLength - Pointer, byte count of the variable-length attributes
        size.

Return Values:

    STATUS_SUCCESS if no error.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampDsConvertReadData");

    // Initialize the returned lengths and buffer.

    *FixedLength = 0;
    *VariableLength = 0;
    *SamAttributes = NULL;

    if (SAMP_FIXED_ATTRIBUTES == AttributeGroup)
    {
        NtStatus = SampConvertAttrBlockToFixedLengthAttributes(
                        ObjectType,
                        AttrBlock,
                        SamAttributes,
                        FixedLength);
    }
    else
    {
        NtStatus = SampConvertAttrBlockToVarLengthAttributes(
                        ObjectType,
                        AttrBlock,
                        (SAMP_VARIABLE_LENGTH_ATTRIBUTE**)SamAttributes,
                        VariableLength);
    }

    return(NtStatus);
}



NTSTATUS
SampDsUpdateContextFixedAttributes(
    IN PSAMP_OBJECT Context,
    IN ULONG FixedLength,
    IN PVOID SamAttributes
    )

/*++

Description:

    This routine updates the SAM context fixed-length attributes if the size
    of the attributes have changed. For fixed-length attributes, this only
    occurs when a revision of the fixed-length data structures has caused a
    size change in the structures.

Parameters:

    Context - Pointer to an object context block.

    FixedLength - Byte count of the fixed-length attributes.

    SamAttributes - Pointer, the SAM fixed-length attributes.


Return Values:

    STATUS_SUCCESS if no error.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG NewLength = 0;
    PBYTE Buffer = NULL;
    PBYTE VariableData = NULL;
    ULONG VariableLength = 0;

    SAMTRACE("SampDsUpdateContextFixedAttributes");

    // The first time through, the variable-buffer length will be zero, so
    // the new length is only the fixed length. Note that OnDiskAllocated is
    // also zero (a global) so don't attempt to use the variable-buffer
    // offset in the calculation.


    NewLength = FixedLength;


    Buffer = RtlAllocateHeap(RtlProcessHeap(), 0, NewLength);

    if (NULL != Buffer)
    {
        // Zero the new buffer and copy the fixed-length attributes into it.

        RtlZeroMemory(Buffer, NewLength);
        RtlCopyMemory(Buffer, SamAttributes, FixedLength);

        if (NULL != Context->OnDisk)
        {
            // Save the current address and length of the variable data, if
            // it exists. The first time through, the variable data is NULL.
            // Release the old buffer.

            VariableData = SampDsVariableBufferAddress(Context);
            VariableLength = SampDsVariableBufferLength(Context);
            RtlCopyMemory(Buffer + FixedLength, VariableData, VariableLength);

            // Free the old OnDisk buffer.

            RtlFreeHeap(RtlProcessHeap(), 0, Context->OnDisk);
        }

        // Reset the context attribute buffer to the new buffer.

        Context->OnDisk = Buffer;

        NtStatus = STATUS_SUCCESS;
    }
    else
    {
        NtStatus = STATUS_NO_MEMORY;
    }

    return(NtStatus);
}



NTSTATUS
SampDsUpdateContextVariableAttributes(
    IN PSAMP_OBJECT Context,
    IN ULONG VariableLength,
    IN PVOID SamAttributes
    )

/*++

Description:

    This routine updates the SAM context variable-length attributes if the
    size of the attributes has changed. Unlike the fixed-length attributes,
    this will occur frequently due to fact that these attributes are vari-
    able length.

Parameters:

    Context - Pointer to an object context block.

    FixedLength - Byte count of the fixed-length attributes.

    SamAttributes - Pointer, the SAM fixed-length attributes.

Return Values:

    STATUS_SUCCESS if no error.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG NewLength = 0;
    PBYTE Buffer = NULL;
    PBYTE FixedData = NULL;
    ULONG FixedLength = 0;

    SAMTRACE("SampDsUpdateContextVariableAttributes");

    // Get the current fixed-buffer length, add the new variable length, and
    // allocate the new buffer.

    NewLength = SampDsFixedBufferLength(Context) + VariableLength;
    Buffer = RtlAllocateHeap(RtlProcessHeap(), 0, NewLength);

    if (NULL != Buffer)
    {
        RtlZeroMemory(Buffer, NewLength);

        // Context->OnDisk should never be NULL in this routine.

        ASSERT(NULL != Context->OnDisk);


        // Get the fixed-length buffer address and length...

        FixedData = SampDsFixedBufferAddress(Context);
        FixedLength = SampDsFixedBufferLength(Context);

        ASSERT(NULL!=FixedData);
        ASSERT(FixedLength>0);


        // Copy the fixed data into the new buffer and append the
        // variable-length data.

        RtlCopyMemory(Buffer, FixedData, FixedLength);

        RtlCopyMemory(Buffer + FixedLength,
                      SamAttributes,
                      VariableLength);

        // Release the old attribute buffer and reset OnDisk to
        // point at the new buffer.

        RtlFreeHeap(RtlProcessHeap(), 0, Context->OnDisk);
        Context->OnDisk = Buffer;

        NtStatus = STATUS_SUCCESS;

    }
    else
    {
        NtStatus = STATUS_NO_MEMORY;
    }

    return(NtStatus);
}



NTSTATUS
SampUpdateOffsets(
    IN PSAMP_OBJECT Context,
    IN BOOLEAN FirstTimeInitialization
    )

/*++

Description:

    This routine updates the buffer (OnDisk) offset and length information
    that is stored in the object information (SAMP_OBJECT_INFORMATION) and
    in the instance information (SAMP_OBJECT), after the attributes have
    been successfully updated.

Parameters:

    Context - Pointer to an object context block.

    AttributeGroup - Flag, either SAMP_FIXED_ATTRIBUTES or SAMP_VARIABLE-
        ATTRIBUTES.

Return Values:

    STATUS_SUCCESS if no error.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    INT ObjectType = Context->ObjectType;
    ULONG FixedDataLength = 0;
    ULONG VariableArrayLength = 0;
    ULONG VariableDataOffset = 0;
    ULONG VariableDataLength = 0;
    ULONG TotalBufferLength = 0;
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE VariableArray = NULL;
    ULONG i = 0;
    ULONG AttributeCount = 0;

    // Determine the SAM object type and compute the length of the fixed-
    // length attributes and the length of the variable-length attribute
    // array, which will be used as buffer offsets.

    SAMTRACE("SampUpdateOffsets");

    switch(ObjectType)
    {

    case SampServerObjectType:

        FixedDataLength = sizeof(SAMP_V1_FIXED_LENGTH_SERVER);
        AttributeCount = SAMP_SERVER_VARIABLE_ATTRIBUTES;
        break;

    case SampDomainObjectType:

        FixedDataLength = sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN);
        AttributeCount = SAMP_DOMAIN_VARIABLE_ATTRIBUTES;
        break;

    case SampGroupObjectType:

        FixedDataLength = sizeof(SAMP_V1_0A_FIXED_LENGTH_GROUP);
        AttributeCount = SAMP_GROUP_VARIABLE_ATTRIBUTES;
        break;

    case SampAliasObjectType:

        FixedDataLength = sizeof(SAMP_V1_FIXED_LENGTH_ALIAS);
        AttributeCount = SAMP_ALIAS_VARIABLE_ATTRIBUTES;
        break;

    case SampUserObjectType:

        FixedDataLength = sizeof(SAMP_V1_0A_FIXED_LENGTH_USER);
        AttributeCount = SAMP_USER_VARIABLE_ATTRIBUTES;
        break;

    default:

        // Invalid object type specified.

        ASSERT(FALSE && "Invalid Object Type");
        NtStatus = STATUS_INTERNAL_ERROR;
        break;

    }

    VariableArrayLength = (AttributeCount *
                           sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE));

    if (NT_SUCCESS(NtStatus))
    {
        // First, update the object information offsets and lengths.

        SampObjectInformation[ObjectType].FixedDsAttributesOffset =
            0;

        SampObjectInformation[ObjectType].FixedDsLengthSize =
            FixedDataLength;

        SampObjectInformation[ObjectType].VariableDsBufferOffset =
            FixedDataLength;

        SampObjectInformation[ObjectType].VariableDsArrayOffset =
            FixedDataLength;

        SampObjectInformation[ObjectType].VariableDsDataOffset =
            FixedDataLength + VariableArrayLength;

        if (FALSE == FirstTimeInitialization)
        {
            // Get a pointer to the array of variable-length information and
            // total up the lengths of these attributes.

            VariableArray = (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)
                            ((PBYTE)(Context->OnDisk) + FixedDataLength);

            for (i = 0; i < AttributeCount; i++)
            {
                VariableDataLength = VariableDataLength + SampDwordAlignUlong(VariableArray[i].Length);
            }
        }
        else
        {
            // The first time through, the attribute buffer only contains
            // the fixed-length attributes, so make sure the lengths for
            // the variable attributes are zero.

            VariableArrayLength = 0;
            VariableDataLength = 0;
        }

        TotalBufferLength = FixedDataLength +
                            VariableArrayLength +
                            VariableDataLength;
    }

    // Finally, update the instance information of the object's context.

    Context->OnDiskAllocated = TotalBufferLength;
    Context->OnDiskUsed = TotalBufferLength;

    // The DS routines do not allocate extra space at the end of the SAM
    // OnDisk buffer, hence OnDiskFree is always zero.

    // BUG: Should allocate extra OnDisk buffer free space for growth.

    Context->OnDiskFree = 0;

    DebugPrint("OnDiskAllocated = %lu\n", Context->OnDiskAllocated);
    DebugPrint("OnDiskUsed = %lu\n", Context->OnDiskUsed);
    DebugPrint("OnDiskFree = %lu\n", Context->OnDiskFree);

    return(NtStatus);
}



NTSTATUS
SampDsUpdateContextAttributes(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeGroup,
    IN PVOID SamAttributes,
    IN ULONG FixedLength,
    IN ULONG VariableLength
    )

/*++

Description:

    This routine updates an object's attribute buffer (OnDisk) for the given
    context. If the new buffer size is the same as the old size, as in the
    case of modifications, then a simple memory copy is performed, otherwise
    helper routines are called to resize the buffer and copy the data. A sub-
    sequent helper routine is called to update the context buffer lengths
    and offsets.

Parameters:

    Context - Pointer to an object context block.

Return Values:

    STATUS_SUCCESS

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    INT ObjectType = Context->ObjectType;
    PBYTE FixedLengthData = NULL;
    PBYTE VariableLengthData = NULL;
    BOOLEAN FirstTimeInitialization = FALSE;

    SAMTRACE("SampDsUpdateContextAttributes");

    // The current version of SAM contains a hack that resets all attributes
    // whenever the variable-length ones are asked for. This allows both the
    // fixed and variable attributes to be set even if FixedStoredSeparately
    // is TRUE. This routine does not maintain that behavior, which may create
    // problems for SAM. If so, the caller of this routine will need to call
    // it twice, once for fixed and once for variable attributes in the cases
    // where FixedStoredSeparately is TRUE.

    if (SAMP_FIXED_ATTRIBUTES == AttributeGroup)
    {
        // Update the fixed-length attributes. The first time through, OnDisk
        // will be NULL.

        //
        // In DS Mode the size of the fixed length attribute structure is
        // constant. There is never a case where less data is returned.
        //

        ASSERT(SampDsFixedBufferLength(Context) == FixedLength);

        if (NULL != Context->OnDisk)
        {
            // The fixed-length data is the same size (i.e. not
            // doing an upgrade), so copy the new attributes and
            // release the buffer.

            FixedLengthData = SampDsFixedBufferAddress(Context);

            RtlCopyMemory(FixedLengthData,
                          (PBYTE)SamAttributes,
                          FixedLength);

            NtStatus = STATUS_SUCCESS;
        }
        else
        {


            // The new attributes are not the same size as the old ones.

            NtStatus = SampDsUpdateContextFixedAttributes(Context,
                                                          FixedLength,
                                                          SamAttributes
                                                          );

            // Fixed-attribute size changes when the context attributes
            // have been set for the first time (i.e. changed from zero to
            // actual sizes), or when the fixed-length structures are
            // changed in an upgrade scenario.

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = SampUpdateOffsets(
                                Context,
                                TRUE //FirstTimeInitialization
                                );


            }
        }

        if(NT_SUCCESS(NtStatus))
        {
            Context->FixedValid = TRUE;
        }
        else
        {
            Context->FixedValid = FALSE;
        }

    }
    else
    {
        //
        // Update the variable-length attributes. In the event that the
        //


        //
        // ASSERT that Context->OnDisk is not NULL. This is because we will
        // always ask for a refresh of the fixed attributes before we refresh
        // the variable attributes.
        //

        ASSERT(NULL!=Context->OnDisk);

        // The new attributes are not the same size as the old
        // ones.

        NtStatus = SampDsUpdateContextVariableAttributes(
                        Context,
                        VariableLength,
                        SamAttributes);

        // Variable-attribute size changes when the context attributes
        // have been set for the first time (i.e. changed from zero to
        // actual sizes), or when the variable-length data has changed
        // size.

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = SampUpdateOffsets(Context, FirstTimeInitialization);
        }

        if(NT_SUCCESS(NtStatus))
        {
            Context->VariableValid = TRUE;
        }
        else
        {
            Context->VariableValid = FALSE;
        }
    }

    return(NtStatus);
}



NTSTATUS
SampValidateDsAttributes(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeGroup
    )

/*++

Description:

    Ensure specified attributes are in-memory. If they are not, then read
    them from the DS backing store. This routine fetches all of the stored
    attributes for a given SAM object. To read a single attribute, or a
    subset of attributes, SampDsRead should be used to selectively fetch
    attributes. Context->OnDisk is updated with the new attributes.

Parameters:

    Context - Pointer to an object context block.

    AttributeGroup - identifies which kind of attributes are being validated
        (SAMP_FIXED_ATTRIBUTES or SAMP_VARIABLE_ATTRIBUTES).

Return Values:

    STATUS_SUCCESS - The attributes are in-memory.

    STATUS_NO_MEMORY - Memory could not be allocated to retrieve the
        attributes.

    Other values as may be returned by registry API trying to retrieve
        the attributes from backing store.
        This routine returns a flag, TRUE if the attributes are in memory, FALSE
        otherwise.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG Flags = 0;
    INT ObjectType = -1;
    DSATTRBLOCK ReadAttrBlock;
    DSATTRBLOCK ResultAttrBlock;
    ULONG FixedLength = 0;
    ULONG VariableLength = 0;
    PVOID SamAttributes = NULL;

    SAMTRACE("SampValidateDsAttributes");

    // The data might already be in memory, so check it out.

    if (!SampDsIsAlreadyValidData(Context, AttributeGroup))
    {
        ASSERT(NULL!=Context->ObjectNameInDs);

        ObjectType = Context->ObjectType;

        RtlZeroMemory(&ReadAttrBlock, sizeof(DSATTRBLOCK));
        RtlZeroMemory(&ResultAttrBlock, sizeof(DSATTRBLOCK));

        // Construct the input ATTRBLOCK used to specify which attributes
        // should be read from the DS.

        NtStatus = SampDsMakeAttrBlock(ObjectType,
                                       AttributeGroup,
                                       0,
                                       &ReadAttrBlock);

        if (NT_SUCCESS(NtStatus))
        {

            ASSERT(NULL != ReadAttrBlock.pAttr);

            // Read the attributes from the DS, flags is currently unused.

            NtStatus = SampDsRead(Context->ObjectNameInDs,
                                  Flags,
                                  ObjectType,
                                  &ReadAttrBlock,
                                  &ResultAttrBlock);

            if (NT_SUCCESS(NtStatus))
            {
                // Convert the ATTRBLOCK into the appropriate SAM attri-
                // butes, returning them in the SamAttributes buffer. Note
                // that the returned lengths are as follows:
                //
                // FixedLength - The byte count of the returned fixed-
                // length buffer
                //
                // VariableLength - The byte count of the returned var-
                // able-length buffer.

                ASSERT(NULL != ResultAttrBlock.pAttr);


                NtStatus = SampDsConvertReadAttrBlock(ObjectType,
                                                      AttributeGroup,
                                                      &ResultAttrBlock,
                                                      &SamAttributes,
                                                      &FixedLength,
                                                      &VariableLength);

                if (NT_SUCCESS(NtStatus))
                {

                    ASSERT(NULL!=SamAttributes);

                    NtStatus = SampDsUpdateContextAttributes(
                                    Context,
                                    AttributeGroup,
                                    SamAttributes,
                                    FixedLength,
                                    VariableLength);

                    RtlFreeHeap(RtlProcessHeap(), 0, SamAttributes);

                }
            }
        }

        RtlFreeHeap(RtlProcessHeap(),0,ReadAttrBlock.pAttr);
    }
    else
    {
        NtStatus = STATUS_SUCCESS;
        ASSERT(NULL!=Context->OnDisk);
    }

    //
    // If we succeeded then Context->OnDisk must not be NULL.
    //

    ASSERT(((NT_SUCCESS(NtStatus)) && (NULL != Context->OnDisk)) ||
           (!NT_SUCCESS(NtStatus)));

    if ((NT_SUCCESS(NtStatus)) && (NULL == Context->OnDisk))
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampValidateDsAttributes status = 0x%lx OnDisk address = 0x%lx\n",
                   NtStatus,
                   Context->OnDisk));

        NtStatus = STATUS_NO_MEMORY;
    }

    return(NtStatus);
}



NTSTATUS
SampValidateRegAttributes(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeGroup
    )

/*++

    Ensure specified attributes are in-memory.
    If they are not, then read them from backing store.



Parameters:

    Context - Pointer to an object context block.

    AttributeGroup - identifies which kind of attributes are being
        validated (SAMP_FIXED_ATTRIBUTES or SAMP_VARIABLE_ATTRIBUTES).



Return Values:

    STATUS_SUCCESS - The attributes are in-memory.

    STATUS_NO_MEMORY - Memory could not be allocated to retrieve the
        attributes.

    Other values as may be returned by registry API trying to retrieve
        the attributes from backing store.

--*/
{
    NTSTATUS
        NtStatus;

    ULONG
        RequiredLength,
        TotalRequiredLength,
        BufferLength;

    PUCHAR
        Buffer;

    PUNICODE_STRING
        KeyAttributeName;

    BOOLEAN
        CreatedObject = FALSE;

    SAMTRACE("SampValidateRegAttributes");


    //
    // The data might already be in memory.
    //

    if (AttributeGroup == SAMP_FIXED_ATTRIBUTES) {
        if (SampFixedAttributesValid( Context )) {
            ASSERT(Context->OnDisk != NULL);
            return(STATUS_SUCCESS);
        }

    } else {

        ASSERT( AttributeGroup == SAMP_VARIABLE_ATTRIBUTES );
        if (SampVariableAttributesValid( Context )) {
            ASSERT(Context->OnDisk != NULL);
            return(STATUS_SUCCESS);
        }
    }



    //
    // Retrieve it from the registry, or allocate it if new.
    //


    NtStatus = SampGetAttributeBufferReadInfo(
                   Context,
                   AttributeGroup,
                   &Buffer,
                   &BufferLength,
                   &KeyAttributeName
                   );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }


    if ( Context->RootKey != INVALID_HANDLE_VALUE ) {

        //
        // Account exists on disk, so read in the attributes.
        //

        NtStatus = SampReadRegistryAttribute( Context->RootKey,
                                              Buffer,
                                              BufferLength,
                                              KeyAttributeName,
                                              &RequiredLength
                                              );

        RequiredLength = SampDwordAlignUlong(RequiredLength);

        if ( ( SampObjectInformation[Context->ObjectType].FixedStoredSeparately ) &&
            ( AttributeGroup == SAMP_VARIABLE_ATTRIBUTES ) ) {

            //
            // RequiredLength was returned to us as the length of the
            // variable attributes on the disk.  However, we're going
            // to be using it to determine the total buffer size as well
            // as to set how much of the buffer is in use, so we must add
            // the size of the fixed stuff that preceeds the variable
            // buffer.
            //

            TotalRequiredLength = RequiredLength +
                                  SampVariableBufferOffset( Context );

        } else {

            //
            // Either the attribute groups are read together, or we're
            // reading in the fixed attribute group.  Either way, we
            // already have the total size we need.
            //

            TotalRequiredLength = RequiredLength;
        }

        if ((NtStatus == STATUS_BUFFER_TOO_SMALL) ||
            ( NtStatus == STATUS_BUFFER_OVERFLOW ) ) {

            NtStatus = SampExtendAttributeBuffer( Context, TotalRequiredLength );
            if (!NT_SUCCESS(NtStatus)) {
                return(NtStatus);
            }

            NtStatus = SampGetAttributeBufferReadInfo(
                           Context,
                           AttributeGroup,
                           &Buffer,
                           &BufferLength,
                           &KeyAttributeName
                           );
            if (!NT_SUCCESS(NtStatus)) {
                return(NtStatus);
            }

            NtStatus = SampReadRegistryAttribute( Context->RootKey,
                                                  Buffer,
                                                  BufferLength,
                                                  KeyAttributeName,
                                                  &RequiredLength
                                                  );

        }

    } else {

        //
        // We're creating a new object.
        //
        // Initialize the requiredlength to the amount of the buffer
        // we have used when we created the empty attributes. This will
        // be the value stored in OnDiskUsed.
        //
        // Note OnDiskUsed is only used by operations on the variable
        // length attributes.
        //

        TotalRequiredLength = SampVariableDataOffset(Context);

        ASSERT(TotalRequiredLength <= Context->OnDiskAllocated);

        CreatedObject = TRUE;
    }



    //
    // if we read something, indicate that the corresponding buffer
    // (and maybe both) are now valid.
    //
    // Also set the used and free information for the buffer if necessary.
    //

    if (NT_SUCCESS(NtStatus)) {
        if (SampObjectInformation[Context->ObjectType].FixedStoredSeparately) {

            //
            // only one attribute group was read in
            //

            if (AttributeGroup == SAMP_FIXED_ATTRIBUTES) {
                Context->FixedValid = TRUE;
                Context->FixedDirty = FALSE;
            } else {

                ASSERT(AttributeGroup == SAMP_VARIABLE_ATTRIBUTES);
                Context->VariableValid = TRUE;
                Context->VariableDirty = FALSE;
                ClearPerAttributeDirtyBits(Context);

                Context->OnDiskUsed = SampDwordAlignUlong(TotalRequiredLength);
                Context->OnDiskFree = Context->OnDiskAllocated -
                                      Context->OnDiskUsed;
            }
        } else {

            //
            // Both attribute groups read in.
            //

            Context->FixedValid = TRUE;
            Context->FixedDirty = FALSE;

            Context->VariableValid = TRUE;
            Context->VariableDirty = FALSE;
            ClearPerAttributeDirtyBits(Context);

            Context->OnDiskUsed = SampDwordAlignUlong(TotalRequiredLength);
            Context->OnDiskFree = Context->OnDiskAllocated -
                                  Context->OnDiskUsed;
        }
    }

    if (NT_SUCCESS(NtStatus) && !CreatedObject) {

        //
        // make any adjustments necessary to bring the data
        // just read in up to current revision format.
        //

        NtStatus = SampUpgradeToCurrentRevision(
                        Context,
                        AttributeGroup,
                        Buffer,
                        RequiredLength,
                        &TotalRequiredLength
                        );
    }

#ifdef SAM_DEBUG_ATTRIBUTES
    if (SampDebugAttributes) {
        DbgPrint("SampValidateAttributes - initialized the context :\n\n");
        SampDumpAttributes(Context);
    }
#endif

    return(NtStatus);
}



NTSTATUS
SampValidateAttributes(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeGroup,
    IN ULONG Attribute,
    IN BOOLEAN SetOperation
    )

/*++

Routine Description:

    This routine determines from the object context whether to validate object
    attributes residing in the registry or in the DS backing store, and then
    calls the appropriate routine to do the work.

Arguments:

    Context - Pointer, the object's SAM context.

    AttributeGroup - identifies which kind of attributes are being validated
        (SAMP_FIXED_ATTRIBUTES or SAMP_VARIABLE_ATTRIBUTES).

Return Value:

    STATUS_SUCCESS - attributes were checked and read from storage if neces-
        sary without a problem, otherwise an error code is returned.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampValidateAttributes");

    if (NULL != Context)
    {
        if (IsDsObject(Context))
        {
            if (NULL != Context->OnDisk)
            {
                // The SAM object attributes have been set atleast once, so
                // update them if needed. If variable attributes are present 
                // and are only partially valid, then we need to go back 
                // and fetch the full set



                if ((Context->AttributesPartiallyValid && SetOperation)
                    || ((SAMP_VARIABLE_ATTRIBUTES==AttributeGroup) &&
                        ( SampIsAttributeInvalid(Context, Attribute) )))
                {
                    //
                    // Context->OnDisk is non NULL but it is unfortunately missing
                    // some attributes. There are 2 cases of this
                    //
                    //  1. We want to read and the attribute that we are interested 
                    //     in has not been prefetched
                    //
                    //  2. We want to write and some attribute has not been prefetched
                    //     Since we do not want to handle the complexity of prefetching
                    //     another attribute, when he have changes in the on disk and
                    //     hence will not be able to discard the on disk, we will
                    //     prefetch again all the attributes.
                    //
                    // We do not discard the OnDisk in the context, right now -- 
                    // would be bad to free the OnDisk as there is plenty of code that
                    // that references and keeps temporary pointers to the ondisk structure
                    // till the context is dereferenced. Note we will never need to buffer
                    // up more than one on disk in the context because when we detect an
                    // attribute to be missing we fetch all attributes
                    //


                    ASSERT(Context->PreviousOnDisk == NULL);

                    if (Context->PreviousOnDisk!=NULL)
                    {
                        MIDL_user_free(Context->PreviousOnDisk);
                        Context->PreviousOnDisk = NULL;
                    }

                    Context->FixedValid = FALSE;
                    Context->VariableValid = FALSE;
                    Context->FixedDirty = FALSE;
                    Context->VariableDirty = FALSE;
                    Context->PreviousOnDisk = Context->OnDisk;
                    Context->OnDisk = NULL;
                    Context->OnDiskAllocated = 0;
                    Context->OnDiskUsed = 0;
                    Context->OnDiskFree = 0;


    #if DBG
                    if ((SAMP_VARIABLE_ATTRIBUTES==AttributeGroup) &&
                            ( SampIsAttributeInvalid(Context, Attribute) ))
                    {
                        ASSERT(FALSE && "Ignorable assert;catches additional DS reads due to incorrect prefetch hints");
                    }
    #endif

                    NtStatus = SampValidateDsAttributes(Context, SAMP_FIXED_ATTRIBUTES);
                    if (NT_SUCCESS(NtStatus))
                    {
                        NtStatus = SampValidateDsAttributes(Context,SAMP_VARIABLE_ATTRIBUTES);
                        if (NT_SUCCESS(NtStatus))
                        {
                            SampMarkPerAttributeInvalidFromWhichFields(Context, 0);
                            Context->AttributesPartiallyValid = FALSE;
                        }
                    }
                }
                else
                {
                    NtStatus = SampValidateDsAttributes(Context,AttributeGroup);
                }
            }
            else if ( SAMP_FIXED_ATTRIBUTES == AttributeGroup)
            {
                //
                // Set the fixed length attributes
                //

                NtStatus = SampValidateDsAttributes(
                                Context,
                                SAMP_FIXED_ATTRIBUTES);

            }
            else
            {
                // The SAM object attributes have never been set because this
                // is a new context. First set the fixed-length attributes and
                // then the variable-length ones.



                // If the OnDisk buffer is NULL, make sure that the fixed-
                // length attributes are loaded first.

                NtStatus = SampValidateDsAttributes(
                                Context,
                                SAMP_FIXED_ATTRIBUTES);

                if (NT_SUCCESS(NtStatus))
                {


                     NtStatus = SampValidateDsAttributes(
                                     Context,
                                     SAMP_VARIABLE_ATTRIBUTES);
                }
            }
        }
        else
        {
            NtStatus = SampValidateRegAttributes(Context, AttributeGroup);
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return(NtStatus);
}



NTSTATUS
SampUpgradeToCurrentRevision(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeGroup,
    IN OUT PUCHAR Buffer,
    IN ULONG  LengthOfDataRead,
    IN OUT PULONG TotalRequiredLength
    )

/*++

    Make any changes necessary bring attributes just read in
    from disk up to the current revision level format.

    When we upgrade our attribute format, we don't bother changing
    all data on disk.  We take a lazy update approach, and only change
    the data as it is changed for other operations.  This means that
    data we read from disk may be from revision 1.  When this is
    detected, the data is copied into a current revision structure,
    and a pointer to that buffer is returned.




    NOTE: For future reference, GROUP and ALIAS objects have
          a revision level stored as a "Qualifier" value associated
          with the security descriptor attribute.  The SERVER object
          stores the revision level in its fixed length attributes.

Parameters:

    Context - Pointer to an object context block.

    AttributeGroup - identifies which kind of attributes are being
        validated (SAMP_FIXED_ATTRIBUTES or SAMP_VARIABLE_ATTRIBUTES).

    Buffer - Pointer to the buffer containing the attributes.

    LengthOfDataRead - This is an important value.  It must be the value
        returned from the registry on the read operation.  This tells us
        exactly how many bytes of data were retrieved from disk.

    TotalRequiredLength - Will be left unchanged if no update was
        was required.  If an updated was made, this will be adjusted
        to reflect the new length of the data.

Return Values:

    None.


--*/

{

    LARGE_INTEGER
        ZeroModifiedCount  = {0,0};
    PULONG
        Pointer;
    NTSTATUS
        NtStatus = STATUS_SUCCESS;

    SAMTRACE("SampUpgradeToCurrentRevision");


    //
    // Note that Buffer points inside a buffer that is
    // hung off the Context block.  We don't need to re-allocate
    // a new attributes buffer because we are only changing
    // fixed-length attributes in this release (and the variable
    // length attributes were placed beyond the end of the new
    // format fixed-length data).
    //
    // The approach we take is to copy the current fixed-length
    // contents into a temporary buffer, and then copy them back
    // into the attribute buffer.  This can be done with stack
    // variables.
    //

    //
    // Switch on the type of objects that have gone through revision
    // changes.
    //

    switch (Context->ObjectType) {
        case SampDomainObjectType:

            //
            // Domain FIXED_LENGTH attributes have had the following
            // revisions:
            //
            //       Revision 0x00010001 -  NT1.0  (Revision NOT stored in  )
            //                                     (record.                 )
            //                                     (Must ascertain revision )
            //                                     (by record length.       )
            //
            //       Revision 0x00010002 -  NT1.0a (Revision is first ULONG )
            //                                     (in record.              )
            //       Revision 0x00010003 -  NT 3.5 - 4.0
            //       Revision 0x00010003 -  NT 4.0 SP3 ( Revision is ascertained
            //                                      by record length ).
            //       Revision 0x00010003 - Win2k ( Revision is ascertained 
            //                                      by record length )
            //

            if (LengthOfDataRead ==
                (sizeof(SAMP_V1_0_FIXED_LENGTH_DOMAIN) +
                 FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)) ) {

                PSAMP_V1_0A_FIXED_LENGTH_DOMAIN
                    V1aFixed;

                SAMP_V1_0_FIXED_LENGTH_DOMAIN
                    V1Fixed, *OldV1Fixed;


                //
                // Update from revision 0x00010001
                //
                // First, copy the current buffer contents into a temporary
                // buffer.
                //

                OldV1Fixed = (PSAMP_V1_0_FIXED_LENGTH_DOMAIN)(Buffer +
                                 FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

                RtlMoveMemory(&V1Fixed, OldV1Fixed, sizeof(SAMP_V1_0_FIXED_LENGTH_DOMAIN));


                //
                // Now copy it back in the new format
                //

                V1aFixed = (PSAMP_V1_0A_FIXED_LENGTH_DOMAIN)OldV1Fixed;

                V1aFixed->CreationTime             = V1Fixed.CreationTime;
                V1aFixed->ModifiedCount            = V1Fixed.ModifiedCount;
                V1aFixed->MaxPasswordAge           = V1Fixed.MaxPasswordAge;
                V1aFixed->MinPasswordAge           = V1Fixed.MinPasswordAge;
                V1aFixed->ForceLogoff              = V1Fixed.ForceLogoff;
                V1aFixed->NextRid                  = V1Fixed.NextRid;
                V1aFixed->PasswordProperties       = V1Fixed.PasswordProperties;
                V1aFixed->MinPasswordLength        = V1Fixed.MinPasswordLength;
                V1aFixed->PasswordHistoryLength    = V1Fixed.PasswordHistoryLength;
                V1aFixed->ServerState              = V1Fixed.ServerState;
                V1aFixed->ServerRole               = V1Fixed.ServerRole;
                V1aFixed->UasCompatibilityRequired = V1Fixed.UasCompatibilityRequired;


                //
                // And initialize fields new for this revision
                //

                V1aFixed->Revision                 = SAMP_REVISION;
                V1aFixed->LockoutDuration.LowPart  = 0xCF1DCC00; // 30 minutes - low part
                V1aFixed->LockoutDuration.HighPart = 0XFFFFFFFB; // 30 minutes - high part
                V1aFixed->LockoutObservationWindow.LowPart  = 0xCF1DCC00; // 30 minutes - low part
                V1aFixed->LockoutObservationWindow.HighPart = 0XFFFFFFFB; // 30 minutes - high part
                V1aFixed->LockoutThreshold         = 0; // Disabled

                // Initialize Session Key Info
                V1aFixed->Unused2[0] = 0;
                V1aFixed->Unused2[1] = 0;
                V1aFixed->Unused2[2] = 0;

                V1aFixed->DomainKeyAuthType = 0;
                V1aFixed->DomainKeyFlags = 0;

                RtlZeroMemory(
                    V1aFixed->DomainKeyInformation,
                    SAMP_DOMAIN_KEY_INFO_LENGTH
                    );

                if (V1aFixed->ServerRole == DomainServerRolePrimary) {
                    V1aFixed->ModifiedCountAtLastPromotion = V1Fixed.ModifiedCount;
                } else {
                    V1aFixed->ModifiedCountAtLastPromotion = ZeroModifiedCount;
                }

                RtlZeroMemory(
                    &V1aFixed->DomainKeyInformationPrevious,
                    SAMP_DOMAIN_KEY_INFO_LENGTH
                    );

                V1aFixed->CurrentKeyId = 1;
                V1aFixed->PreviousKeyId = 0;

            } else if (LengthOfDataRead ==
                (sizeof(SAMP_V1_0A_ORG_FIXED_LENGTH_DOMAIN) +
                 FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)))  {

                PSAMP_V1_0A_FIXED_LENGTH_DOMAIN
                    V1aFixed;

                //
                // Handle the upgrade for NT4 SP3 to include domain key
                // information
                //

                V1aFixed = (PSAMP_V1_0A_FIXED_LENGTH_DOMAIN)(Buffer +
                                 FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

                V1aFixed->Unused2[0] = 0;
                V1aFixed->Unused2[1] = 0;
                V1aFixed->Unused2[2] = 0;
                V1aFixed->DomainKeyAuthType = 0;
                V1aFixed->DomainKeyFlags = 0;
                RtlZeroMemory(
                    V1aFixed->DomainKeyInformation,
                    SAMP_DOMAIN_KEY_INFO_LENGTH
                    );

                RtlZeroMemory(
                    &V1aFixed->DomainKeyInformationPrevious,
                    SAMP_DOMAIN_KEY_INFO_LENGTH
                    );

                V1aFixed->CurrentKeyId = 1;
                V1aFixed->PreviousKeyId = 0;

            } else if (LengthOfDataRead ==
                (sizeof(SAMP_V1_0A_WIN2K_FIXED_LENGTH_DOMAIN) +
                 FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)))  {

                PSAMP_V1_0A_FIXED_LENGTH_DOMAIN
                    V1aFixed;

                //
                // Handle the upgrade for NT4 SP3 to include domain key
                // information
                //

                V1aFixed = (PSAMP_V1_0A_FIXED_LENGTH_DOMAIN)(Buffer +
                                 FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

                RtlZeroMemory(
                    &V1aFixed->DomainKeyInformationPrevious,
                    SAMP_DOMAIN_KEY_INFO_LENGTH
                    );

                V1aFixed->CurrentKeyId = 1;
                V1aFixed->PreviousKeyId = 0;
            }


            break;  //out of switch



        case SampUserObjectType:

            //
            // User FIXED_LENGTH attributes have had the following
            // revisions:
            //
            //       Revision 0x00010001 -  NT1.0  (Revision NOT stored in  )
            //                                     (record.                 )
            //                                     (Must ascertain revision )
            //                                     (by record length.       )
            //
            //       Revision 0x00010002 -  NT1.0a (Revision is first ULONG )
            //                                     (in record.              )
            //       Revision 0x00010002a - NT3.5  (Revision is first ULONG )
            //                                     (in record, still        )
            //                                     (0x00010002.  Must       )
            //                                     (ascertain revison by    )
            //                                     (by record length        )

            if (LengthOfDataRead ==
                (sizeof(SAMP_V1_FIXED_LENGTH_USER) +
                 FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)) ) {

                PSAMP_V1_0A_FIXED_LENGTH_USER
                    V1aFixed;

                SAMP_V1_FIXED_LENGTH_USER
                    V1Fixed, *OldV1Fixed;


                //
                // Update from revision 0x00010001
                //
                // First, copy the current buffer contents into a temporary
                // buffer.
                //

                OldV1Fixed = (PSAMP_V1_FIXED_LENGTH_USER)(Buffer +
                                 FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));
                RtlMoveMemory(&V1Fixed, OldV1Fixed, sizeof(SAMP_V1_FIXED_LENGTH_USER));


                //
                // Now copy it back in the new format
                //

                V1aFixed = (PSAMP_V1_0A_FIXED_LENGTH_USER)OldV1Fixed;


                V1aFixed->LastLogon           = V1Fixed.LastLogon;
                V1aFixed->LastLogoff          = V1Fixed.LastLogoff;
                V1aFixed->PasswordLastSet     = V1Fixed.PasswordLastSet;
                V1aFixed->AccountExpires      = V1Fixed.AccountExpires;
                V1aFixed->UserId              = V1Fixed.UserId;
                V1aFixed->PrimaryGroupId      = V1Fixed.PrimaryGroupId;
                V1aFixed->UserAccountControl  = V1Fixed.UserAccountControl;
                V1aFixed->CountryCode         = V1Fixed.CountryCode;
                V1aFixed->CodePage            = V1Fixed.CodePage;
                V1aFixed->BadPasswordCount    = V1Fixed.BadPasswordCount;
                V1aFixed->LogonCount          = V1Fixed.LogonCount;
                V1aFixed->AdminCount          = V1Fixed.AdminCount;

                //
                // And initialize fields new for this revision
                //

                V1aFixed->Revision            = SAMP_REVISION;
                V1aFixed->LastBadPasswordTime = SampHasNeverTime;
                V1aFixed->OperatorCount       = 0;
                V1aFixed->Unused2             = 0;

            } else if ((LengthOfDataRead ==
                (sizeof(SAMP_V1_0_FIXED_LENGTH_USER) +
                 FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)) ) &&
                 (AttributeGroup == SAMP_FIXED_ATTRIBUTES)) {

                PSAMP_V1_0A_FIXED_LENGTH_USER
                    V1aFixed;

                //
                // Update from revision 0x00010002
                //
                // Just set the added field at the end to 0.
                //

                V1aFixed = (PSAMP_V1_0A_FIXED_LENGTH_USER)(Buffer +
                                 FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

                V1aFixed->OperatorCount       = 0;
                V1aFixed->Unused2             = 0;
            }

            break;  //out of switch

    case SampGroupObjectType:
            //
            // Group FIXED_LENGTH attributes have had the following
            // revisions:
            //
            //       Revision 0x00010001 -  NT1.0  (Revision NOT stored in  )
            //                                     (record.                 )
            //                                     (Must ascertain revision )
            //                                     (by first few ULONGs.    )
            //
            //       Revision 0x00010002 -  NT1.0a (Revision is first ULONG )
            //                                     (in record.              )

            Pointer = (PULONG) (Buffer + FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

            //
            // The old fixed length group had a RID in the first ULONG and
            // an attributes field in the second. The attributes are in the
            // first and last nibble of the field.  Currently, the RID is in
            // the second ULONG. Since all RIDs are more than one nibble,
            // a rid will always have something set in the middle six nibbles.
            //

            if ( ( Pointer[0] != SAMP_REVISION ) &&
                 ( ( Pointer[1] & 0x0ffffff0 ) == 0 ) ) {

                PSAMP_V1_0A_FIXED_LENGTH_GROUP
                    V1aFixed;

                SAMP_V1_FIXED_LENGTH_GROUP
                    V1Fixed, *OldV1Fixed;

                ULONG TotalLengthRequired;

                //
                // Calculate the length required for the new group information.
                // It is the size of the old group plus enough space for the
                // new fields in the new fixed attributes.
                //

                TotalLengthRequired = SampDwordAlignUlong(
                                        LengthOfDataRead +
                                        sizeof(SAMP_V1_0A_FIXED_LENGTH_GROUP) -
                                        sizeof(SAMP_V1_FIXED_LENGTH_GROUP)
                                        );


                NtStatus = SampExtendAttributeBuffer(
                                Context,
                                TotalLengthRequired
                                );

                if (!NT_SUCCESS(NtStatus)) {
                    return(NtStatus);
                }

                //
                // Get the new buffer pointer
                //

                Buffer = Context->OnDisk;

                //
                // Move the variable information up to make space for the
                // fixed information
                //

                RtlMoveMemory(
                    Buffer + SampFixedBufferOffset( Context ) + sizeof(SAMP_V1_0A_FIXED_LENGTH_GROUP),
                    Buffer + SampFixedBufferOffset( Context) + sizeof(SAMP_V1_FIXED_LENGTH_GROUP),
                    LengthOfDataRead - SampFixedBufferOffset( Context) - sizeof(SAMP_V1_FIXED_LENGTH_GROUP)
                    );

                //
                // Update from revision 0x00010001
                //
                // First, copy the current buffer contents into a temporary
                // buffer.
                //

                OldV1Fixed = (PSAMP_V1_FIXED_LENGTH_GROUP)(Buffer +
                                 FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data));

                RtlCopyMemory(&V1Fixed, OldV1Fixed, sizeof(SAMP_V1_FIXED_LENGTH_GROUP));

                //
                // Now copy it back in the new format
                //

                V1aFixed = (PSAMP_V1_0A_FIXED_LENGTH_GROUP)OldV1Fixed;

                V1aFixed->Revision = SAMP_REVISION;
                V1aFixed->Unused1 = 0;
                V1aFixed->RelativeId = V1Fixed.RelativeId;
                V1aFixed->Attributes = V1Fixed.Attributes;
                V1aFixed->AdminCount = (V1Fixed.AdminGroup) ? TRUE : FALSE;
                V1aFixed->OperatorCount = 0;

                //
                // Update the indicator of how long the on disk structure
                // is.
                //

                Context->OnDiskUsed += (sizeof(SAMP_V1_0A_FIXED_LENGTH_GROUP) - sizeof(SAMP_V1_FIXED_LENGTH_GROUP));
                Context->OnDiskFree = Context->OnDiskAllocated - Context->OnDiskUsed;
            }

        break;

        default:

            //
            // The rest of the object types have not changed format
            // and so need not be updated.
            //

            break;  //out of switch

    }

    return(NtStatus);
}


PUCHAR
SampObjectAttributeAddress(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex
    )

/*++

    Retrieve the address of a variable-length attribute. The attributes are
    assumed to already be in-memory. The NT3.51-4.0 SAM stores attribute
    offsets differently from the NT5 SAM. In the earlier versions (which
    exclusively used the registry as the backing store), the attribute offset
    value (in SAMP_VARIABLE_LENGTH_ATTRIBUTE) was self-relative to the end
    of the attribute array. The NT5 version is self-relative from the start
    of the array.

Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be retrieved.

Return Values:

    STATUS_SUCCESS - The attributes are in-memory.

    STATUS_NO_MEMORY - Memory could not be allocated to retrieve the
        attributes.

    Other values as may be returned by registry API trying to retrieve
        the attributes from backing store.

--*/

{
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE AttributeArray;
    PUCHAR AttributeAddress;

    SAMTRACE("SampObjectAttributeAddress");

    ASSERT(SampVariableAttributesValid(Context));

    AttributeArray = (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)
                        SampVariableArrayAddress(Context);

    if (IsDsObject(Context))
    {
        // DS based attribute offsets are relative to the start of the
        // attribute array.

        AttributeAddress = (PUCHAR)Context->OnDisk +
                                (SampVariableBufferOffset(Context) +
                                AttributeArray[AttributeIndex].Offset);
    }
    else
    {
        // Registry based attribute offsets are relative to the end of the
        // attribute array.

        AttributeAddress = (PUCHAR)Context->OnDisk +
                                (SampVariableDataOffset(Context) +
                                AttributeArray[AttributeIndex].Offset);
    }

    return(AttributeAddress);
}



ULONG
SampObjectAttributeLength(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex
    )

/*++

    Retrieve the length of a variable-length attribute.


    The attributes are assumed to already be in-memory.



Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute whose length is to be retrieved.




Return Values:

    The length of the attribute (in bytes).

--*/
{
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE
        AttributeArray;

    SAMTRACE("SampObjectAttributeLength");


    ASSERT( SampVariableAttributesValid( Context ) );

    AttributeArray = (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)
                     SampVariableArrayAddress( Context );

    return( AttributeArray[AttributeIndex].Length );

}


PULONG
SampObjectAttributeQualifier(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex
    )

/*++

    Retrieve the address of the qualifier field of a variable-length
    attribute.

    The attributes are assumed to already be in-memory.



Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute whose qualifier address is to be returned.




Return Values:

    The address of the specifed attribute's qualifier field.

--*/
{
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE
        AttributeArray;

    SAMTRACE("SampObjectAttributeQualifier");


    ASSERT( SampVariableAttributesValid( Context ) );

    AttributeArray = (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)
                     SampVariableArrayAddress( Context );

    return( &(AttributeArray[AttributeIndex].Qualifier) );

}


NTSTATUS
SampGetAttributeBufferReadInfo(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeGroup,
    OUT PUCHAR *Buffer,
    OUT PULONG BufferLength,
    OUT PUNICODE_STRING *KeyAttributeName
    )

/*++

    Get attribute buffer information needed to read data from
    backing store.

    If there is currently no attribute buffer, then allocate one.


Parameters:

    Context - Pointer to an object context block.

    AttributeGroup - Indicates which attribute grouping you are
        interested in.  This is only interesting if the fixed and
        variable-length attributes are stored separately.

    Buffer - Receives a pointer to the beginning of the appropriate
        buffer (fixed or variable).  This will be dword aligned.
        If the attributes are stored together, this will point
        to the beginning of the fixed-length attributes.

    BufferLength - Receives the number of bytes in the buffer.

    KeyAttributeName - Receives a pointer to the unicode name of the
        attribute to read the attributes from.




Return Values:

    STATUS_SUCCESS - The attributes have been read.

    STATUS_NO_MEMORY - Memory could not be allocated to receive the
        data from disk.

    Other values as may be returned reading from disk.


--*/
{
    NTSTATUS
        NtStatus = STATUS_SUCCESS;

    SAMTRACE("SampGetAttributeBufferReadInfo");


    //
    // If the context block currently has no buffer info, then
    // "extend" (create) it so we can return buffer information.
    //

    if (Context->OnDiskAllocated == 0) {

        NtStatus = SampExtendAttributeBuffer(
                       Context,
                       SAMP_MINIMUM_ATTRIBUTE_ALLOC
                       );

        if (!NT_SUCCESS(NtStatus)) {
            return(NtStatus);
        }
    }



    //
    // Get the buffer address and length
    //

    if (SampObjectInformation[Context->ObjectType].FixedStoredSeparately) {

        //
        // stored separately.  Address and length is dependent upon
        // what is being asked for.  Source registry attribute name
        // is also.
        //

        if (AttributeGroup == SAMP_FIXED_ATTRIBUTES) {
            (*Buffer)           = Context->OnDisk;
            (*BufferLength)     = SampVariableBufferOffset( Context );
            (*KeyAttributeName) = &SampFixedAttributeName;
        } else {
            (*Buffer)           = SampVariableBufferAddress( Context );
            (*BufferLength)     = SampVariableBufferLength( Context );
            (*KeyAttributeName) = &SampVariableAttributeName;
        }

    } else {

        //
        // Attributes stored together - doesn't matter which is being
        // asked for.
        //

        (*Buffer)           = Context->OnDisk;
        (*BufferLength)     = Context->OnDiskAllocated;
        (*KeyAttributeName) = &SampCombinedAttributeName;
    }


    return(NtStatus);
}





NTSTATUS
SampExtendAttributeBuffer(
    IN PSAMP_OBJECT Context,
    IN ULONG NewSize
    )


/*++

    This routine extends (or creates) an attribute buffer by allocating
    a larger one.  It then copies the existing buffer's contents into
    the new buffer, if there is an existing buffer.

    If a new buffer can not be allocated, then the context block is
    returned with the old buffer intact.

    If this call succeeds, the buffer will be at least as large as
    that asked for (and perhaps larger).


Parameters:

    Context - Pointer to an object context block.

    NewSize - The number of bytes to allocate for the new buffer.
        This value can not be less than the number of bytes currently
        in use.





Return Values:

    STATUS_SUCCESS - The attributes are in-memory.

    STATUS_NO_MEMORY - Memory could not be allocated to retrieve the
        attributes.

    Other values as may be returned by registry API trying to retrieve
        the attributes from backing store.

--*/

{

    PUCHAR
        OldBuffer;

    ULONG
        AllocationSize;

    SAMTRACE("SampExtendAttributeBuffer");


#if DBG
    if ( Context->VariableValid ) {
        ASSERT(NewSize >= Context->OnDiskUsed);
    }
#endif


    //
    // Is an allocation necessary?
    //

    if (NewSize <= Context->OnDiskAllocated) {
        return(STATUS_SUCCESS);
    }



    OldBuffer = Context->OnDisk;


    //
    // Pad the extend to allow for future edits efficiently.
    //

    AllocationSize = SampDwordAlignUlong(NewSize + SAMP_MINIMUM_ATTRIBUTE_PAD);
    Context->OnDisk = RtlAllocateHeap(
                         RtlProcessHeap(), 0,
                         AllocationSize
                         );

    if (Context->OnDisk == NULL) {
        Context->OnDisk = OldBuffer;
        return(STATUS_NO_MEMORY);
    }


    //
    // Set the new allocated size

    Context->OnDiskAllocated = AllocationSize;

    //
    // If there was no buffer originally, then zero the new buffer, mark
    // it as being invalid, and return.
    //

    if (OldBuffer == NULL) {

        RtlZeroMemory( (PVOID)Context->OnDisk, AllocationSize );

        Context->FixedDirty    = TRUE;
        Context->VariableDirty = TRUE;
        SetAllPerAttributeDirtyBits(Context);

        Context->FixedValid    = FALSE;
        Context->VariableValid = FALSE;

        return(STATUS_SUCCESS);
    }


    //
    // Set the free size.  Note that this information is only set if
    // the variable data is valid.
    // Used size remains the same.
    //

    if (Context->VariableValid == TRUE) {
        Context->OnDiskFree = AllocationSize - Context->OnDiskUsed;
        ASSERT(Context->OnDiskUsed == SampDwordAlignUlong(Context->OnDiskUsed));
    }


    //
    // There was an old buffer (or else we would have exited earlier).
    // If any data in it was valid, copy it to the new buffer.  Free the
    // old buffer.
    //

    if ( Context->FixedValid ) {

        RtlCopyMemory(
            Context->OnDisk,
            OldBuffer,
            SampFixedBufferLength( Context ) + SampFixedBufferOffset( Context )
            );
    }

    //
    // Note: in thise case we may copy the fixed data twice, since if the
    // variable data is not stored separately then SampVariableBufferOffset
    // is zero.
    //

    if ( Context->VariableValid ) {

        RtlCopyMemory(
            SampVariableBufferAddress( Context ),
            OldBuffer + SampVariableBufferOffset( Context ),
            Context->OnDiskUsed - SampVariableBufferOffset( Context )
            );
    }

    RtlFreeHeap( RtlProcessHeap(), 0, OldBuffer );

    return(STATUS_SUCCESS);
}



NTSTATUS
SampReadRegistryAttribute(
    IN HANDLE Key,
    IN PUCHAR Buffer,
    IN ULONG  BufferLength,
    IN PUNICODE_STRING AttributeName,
    OUT PULONG RequiredLength
    )

/*++


    Retrieve the address of a variable-length attribute.

    The attributes are assumed to already be in-memory.



Parameters:

    Key - Handle to the key whose attribute is to be read.

    Buffer - Pointer to the buffer to receive the information.

    BufferLength - Length of the buffer receiving the information.

    AttributeName - The name of the attribute.



Return Values:

    STATUS_SUCCESS - Successful completion.


    STATUS_BUFFER_TOO_SMALL - The data could not be read because the
        buffer was too small.

    Other values as may be returned by registry API trying to retrieve
        the attribute from backing store.

--*/

{
    NTSTATUS
        NtStatus;

    SAMTRACE("SampReadRegistryAttribute");


    //
    // Try to read the attribute
    //

    NtStatus = NtQueryValueKey( Key,
                                AttributeName,              //ValueName,
                                KeyValuePartialInformation, //KeyValueInformationClass
                                (PVOID)Buffer,
                                BufferLength,
                                RequiredLength
                                );

    SampDumpNtQueryValueKey(AttributeName,
                            KeyValuePartialInformation,
                            Buffer,
                            BufferLength,
                            RequiredLength);

    return(NtStatus);

}




NTSTATUS
SampSetVariableAttribute(
    IN PSAMP_OBJECT Context,
    IN ULONG AttributeIndex,
    IN ULONG Qualifier,
    IN PUCHAR Buffer,
    IN ULONG Length
    )


/*++

    This API is used to set a new attribute value.  The new attribute
    value may be longer, shorter, or the same size as the current
    attribute.  The data in the attribute buffer will be shifted to
    make room for a larger attribute value or to fill in room left by
    a smaller attribute value.

    PERFORMANCE CONCERN:  If you have a lot of attributes to set, it
        is worthwhile to start with the smallest indexed attribute
        and work up to the largest indexed attribute.




Parameters:

    Context - Pointer to an object context block.

    AttributeIndex - Indicates the index (into the variable length attribute
        array) of the attribute to be set.  Typically, all attributes beyond
        this one will have their data shifted.

    Buffer - The address of the buffer containing the new attribute value.
        May be NULL if Length is zero.

    Length - The length (in bytes) of the new attribute value.


Return Values:

    STATUS_SUCCESS - The service completed successfully.

    STATUS_NO_MEMORY - Memory to expand the attribute buffer could not
        be allocated.

--*/
{
    NTSTATUS
        NtStatus;


    ULONG
        OriginalAttributeLength,
        AdditionalSpaceNeeded,
        NewBufferLength,
        MaximumAttributeIndex,
        MoveLength,
        i;

    LONG
        OffsetDelta;

    PSAMP_VARIABLE_LENGTH_ATTRIBUTE
        AttributeArray;


    PUCHAR
        NewStart,
        OriginalStart;

    SAMTRACE("SampSetVariableAttribute");

    //
    // Make sure the requested attribute exists for the specified
    // object type.
    //

    SampValidateAttributeIndex( Context, AttributeIndex );



    //
    // Make the data valid
    //

    NtStatus = SampValidateAttributes( Context, SAMP_VARIABLE_ATTRIBUTES, AttributeIndex, TRUE );
    if (!NT_SUCCESS(NtStatus)) {
        return(NtStatus);
    }

    //
    // If the caller want to set User Object's SAMP_USER_PARAMETERS attribute and
    // is not a loopback client. And this is the first time the client tries to set
    // this attribute. we should cache the old UserParms value,
    // We do not cache any inter-update changes.
    //

    OriginalAttributeLength =  SampObjectAttributeLength(Context, AttributeIndex);

    if (SampUserObjectType == Context->ObjectType &&            // User Object
        SAMP_USER_PARAMETERS == AttributeIndex &&               // desired attribute
        !Context->LoopbackClient &&                             // not Loopback client
        !Context->TypeBody.User.CachedOrigUserParmsIsValid)     // First time to set this attribute
    {

        ASSERT(SampCurrentThreadOwnsLock());

        //
        // followings are two cases we will meet:
        // first: OriginalUserParms just does not exist, set the pointer to NULL
        // second: allocate memory to cache the old value
        //
        if (OriginalAttributeLength)
        {
            Context->TypeBody.User.CachedOrigUserParms = MIDL_user_allocate(OriginalAttributeLength);

            if (NULL == Context->TypeBody.User.CachedOrigUserParms)
            {
                return (STATUS_NO_MEMORY);
            }

            RtlZeroMemory(Context->TypeBody.User.CachedOrigUserParms,
                          OriginalAttributeLength
                          );

            RtlCopyMemory(Context->TypeBody.User.CachedOrigUserParms,
                          SampObjectAttributeAddress(Context, AttributeIndex),
                          OriginalAttributeLength
                          );
        }
        else
        {
            Context->TypeBody.User.CachedOrigUserParms = NULL;
        }

        Context->TypeBody.User.CachedOrigUserParmsLength = OriginalAttributeLength;
        Context->TypeBody.User.CachedOrigUserParmsIsValid = TRUE;
    }


    //
    // Allocate a new buffer if necessary
    //


    if (OriginalAttributeLength < Length) {

        AdditionalSpaceNeeded = Length - OriginalAttributeLength;

        if (Context->OnDiskFree < AdditionalSpaceNeeded) {

            NewBufferLength = Context->OnDiskUsed + AdditionalSpaceNeeded;
            ASSERT(NewBufferLength > Context->OnDiskAllocated);

            NtStatus = SampExtendAttributeBuffer( Context, NewBufferLength );
            if (!NT_SUCCESS(NtStatus)) {
                return(NtStatus);
            }
        }
    }

    //
    // Get the address of the attribute array.
    //

    AttributeArray = SampVariableArrayAddress( Context );

    //
    // Now shift following attribute values
    //

    OffsetDelta = (LONG)(SampDwordAlignUlong(Length) -
                         SampDwordAlignUlong(OriginalAttributeLength));

    MaximumAttributeIndex = SampVariableAttributeCount( Context );

    if ((OffsetDelta != 0) && (AttributeIndex+1 < MaximumAttributeIndex)) {

        //
        // Shift all attributes above this one up or down by the OffsetDelta
        //

        if (IsDsObject(Context))
        {
            // DS variable-length attribute offsets are relative to the start
            // of the variable-length array.

            MoveLength = Context->OnDiskUsed -
                         ( SampVariableBufferOffset( Context ) +
                         AttributeArray[AttributeIndex+1].Offset );
        }
        else
        {
            // Registry variable-length attribute offsets are relative to the
            // end of the variable-length array.

            MoveLength = Context->OnDiskUsed -
                         ( SampVariableDataOffset( Context ) +
                         AttributeArray[AttributeIndex+1].Offset );
        }

        //
        // Shift the data (if there is any)
        //

        if (MoveLength != 0) {

            OriginalStart = SampObjectAttributeAddress( Context, AttributeIndex+1);
            NewStart = (PUCHAR)(OriginalStart + OffsetDelta);
            RtlMoveMemory( NewStart, OriginalStart, MoveLength );
        }


        //
        // Adjust the offset pointers
        //

        for ( i=AttributeIndex+1; i<MaximumAttributeIndex; i++) {
            AttributeArray[i].Offset =
                (ULONG)(OffsetDelta + (LONG)(AttributeArray[i].Offset));
        }
    }



    //
    // Now set the length and qualifier, and copy in the new attribute value
    // (if it is non-zero length)
    //

    AttributeArray[AttributeIndex].Length    = Length;
    AttributeArray[AttributeIndex].Qualifier = Qualifier;

    if (Length != 0) {

        RtlCopyMemory( SampObjectAttributeAddress( Context, AttributeIndex ),
                       Buffer,
                       Length
                       );
    }



    //
    // Adjust the Used and Free values
    //
    Context->OnDiskUsed += OffsetDelta;
    Context->OnDiskFree -= OffsetDelta;

    ASSERT(Context->OnDiskFree == Context->OnDiskAllocated - Context->OnDiskUsed);

    //
    // Mark the variable attributes dirty
    //

    Context->VariableDirty = TRUE;

    //
    // Mark the per attribute DirtyBit
    //

    SetPerAttributeDirtyBit(Context,AttributeIndex);




#ifdef SAM_DEBUG_ATTRIBUTES
    if (SampDebugAttributes) {
        DbgPrint("SampSetVariableAttribute %d to length %#x, qualifier %#x:\n", AttributeIndex, Length, Qualifier);
        SampDumpAttributes(Context);
    }
#endif


    return(STATUS_SUCCESS);

}


VOID
SampFreeAttributeBuffer(
    IN PSAMP_OBJECT Context
    )

/*++


    Free the buffer used to keep in-memory copies of the on-disk
    object attributes.


Parameters:

    Context - Pointer to the object context whose buffer is to
        be freed.


Return Values:

    None.

--*/

{
#if DBG
    if ( Context->FixedValid ) { ASSERT(Context->FixedDirty == FALSE); }
    if ( Context->VariableValid) { ASSERT(Context->VariableDirty == FALSE); }
    ASSERT(Context->OnDisk != NULL);
    ASSERT(Context->OnDiskAllocated != 0);
#endif

    SAMTRACE("SampFreeAttributeBuffer");

    MIDL_user_free(Context->OnDisk );

    Context->OnDisk = NULL;
    Context->OnDiskAllocated = 0;

    //
    // Mark all attributes as invalid
    //

    Context->FixedValid = FALSE;
    Context->VariableValid = FALSE;
    Context->FixedDirty = FALSE;
    Context->VariableDirty = FALSE;
    ClearPerAttributeDirtyBits(Context);

    if (Context->PreviousOnDisk!=NULL)
    {
        MIDL_user_free(Context->PreviousOnDisk);
        Context->PreviousOnDisk = NULL;
    }


    return;
}

VOID
SampMarkPerAttributeInvalidFromWhichFields(
    IN PSAMP_OBJECT Context,
    IN ULONG        WhichFields
    )
{
    ULONG AttrCount = 0;
    ULONG i;


    switch(Context->ObjectType)
    {

    case SampServerObjectType:
        AttrCount = SAMP_SERVER_VARIABLE_ATTRIBUTES;
        break;

    case SampDomainObjectType:
        AttrCount = SAMP_DOMAIN_VARIABLE_ATTRIBUTES;
        break;

    case SampGroupObjectType:
        AttrCount = SAMP_GROUP_VARIABLE_ATTRIBUTES;
        break;

    case SampAliasObjectType:
        AttrCount = SAMP_ALIAS_VARIABLE_ATTRIBUTES;
        break;

    case SampUserObjectType:
        AttrCount = SAMP_USER_VARIABLE_ATTRIBUTES;
        break;

    default:

        ASSERT(FALSE && "Invalid SampObjectType");
        break;

    }


    //
    // First Clear all the bits
    //

    RtlClearAllBits(
            &Context->PerAttributeInvalidBits
            );

    //
    // Now mark certain bits invalid per the specified WhichFields.
    //

    for (i=0;i<AttrCount;i++)
    {
        if ((0!=WhichFields)
            && (SampVarAttributeInfo[Context->ObjectType][i].FieldIdentifier!=0)
            && ((SampVarAttributeInfo[Context->ObjectType][i].FieldIdentifier & WhichFields)==0))
        {
            SetPerAttributeInvalidBit(Context,i);
        }
       
    }

}



#ifdef SAM_DEBUG_ATTRIBUTES
VOID
SampDumpAttributes(
    IN PSAMP_OBJECT Context
    )


/*++

    This is a debug-only API to dump out the attributes for a context
    to the kernel debugger.

Parameters:

    Context - Pointer to an object context block.

Return Values:

    None.

--*/
{
    ULONG   Index;
    PSAMP_OBJECT_INFORMATION ObjectTypeInfo = &SampObjectInformation[Context->ObjectType];
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE AttributeArray;

    AttributeArray = (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)
                     SampVariableArrayAddress( Context );


    DbgPrint("Dumping context 0x%x\n", Context);
    DbgPrint("\n");
    DbgPrint("TYPE INFO\n");
    DbgPrint("Object type name = %wZ\n", &ObjectTypeInfo->ObjectTypeName);
    DbgPrint("Fixed stored separately  = %s\n", ObjectTypeInfo->FixedStoredSeparately ? "TRUE" : "FALSE");
    DbgPrint("Fixed attributes offset  = %#x\n", ObjectTypeInfo->FixedAttributesOffset);
    DbgPrint("Fixed attributes size    = %#x\n", ObjectTypeInfo->FixedLengthSize);
    DbgPrint("Variable buffer offset   = %#x\n", ObjectTypeInfo->VariableBufferOffset);
    DbgPrint("Variable array offset    = %#x\n", ObjectTypeInfo->VariableArrayOffset);
    DbgPrint("Variable data offset     = %#x\n", ObjectTypeInfo->VariableDataOffset);
    DbgPrint("Variable attribute count = %d\n", ObjectTypeInfo->VariableAttributeCount);
    DbgPrint("\n");
    DbgPrint("INSTANCE INFO\n");
    DbgPrint("RootName        = %wZ\n", &Context->RootName);
    DbgPrint("Fixed Valid     = %s\n", Context->FixedValid ? "TRUE" : "FALSE");
    DbgPrint("Variable Valid  = %s\n", Context->VariableValid ? "TRUE" : "FALSE");
    DbgPrint("Fixed Dirty     = %s\n", Context->FixedDirty ? "TRUE" : "FALSE");
    DbgPrint("Variable Dirty  = %s\n", Context->VariableDirty ? "TRUE" : "FALSE");
    DbgPrint("OnDiskAllocated = %#x\n", Context->OnDiskAllocated);
    DbgPrint("OnDiskUsed      = %#x\n", Context->OnDiskUsed);
    DbgPrint("OnDiskFree      = %#x\n", Context->OnDiskFree);
    DbgPrint("\n");

    if ( Context->VariableValid ) {

        for (Index = 0; Index < ObjectTypeInfo->VariableAttributeCount; Index ++) {

            DbgPrint("Attr %d: Qualifier = %#6x, Offset = %#6x, Length = %#6x\n",
                                        Index,
                                        AttributeArray[Index].Qualifier,
                                        AttributeArray[Index].Offset,
                                        AttributeArray[Index].Length
                                        );
            SampDumpData(SampObjectAttributeAddress(Context, Index),
                         SampObjectAttributeLength(Context, Index));
        }
    }

    DbgPrint("\n\n");
}


VOID
SampDumpData(
    IN PVOID Buffer,
    IN ULONG Length
    )


/*++

    This is a debug-only API to dump out a buffer in hex

Parameters:

    Buffer - Pointer to data

    Length - number of bytes in data

Return Values:

    None.

--*/
{
    ULONG   Index;

    for (Index = 0; Index < Length; Index ++) {

        ULONG Value = (ULONG)(((PBYTE)Buffer)[Index]);

        if ((Index % 16) == 0) {
            DbgPrint("\n      ");
        }

        DbgPrint("%02x ", Value & 0xff);
    }

    if (Length > 0) {
        DbgPrint("\n\n");
    }
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\credman.cxx ===
//+-----------------------------------------------------------------------
//
// Microsoft Windows
//
// Copyright (c) Microsoft Corporation 1992 - 1996
//
// File:        credman.cxx
//
// Contents:    Scaffolding for credential management APIs built on NT4 sam
//
//
// History:     16-Aug-1996     MikeSw          Created
//              29-Apr-1999     ShaoYin         Changed the way of storing
//                                              0 length Credentials 
//               
//  The New Logic about storing / retrieving zero lenth credentials is 
//  described as followings:
// 
//  Store Credentials:  (Changed)
//      1. Always add the PackageName into PackageList
//      2. If the value of credentials is NULL (or zero length), the do not 
//         store this credentials. Only store this credentials when the value
//         is not NULL
//
//  Retrieve Credentials:   (Changed)
//      1. First get the PackageList from user's SupplementalCredentials 
//         attribute.
//      2. If the PackageName of the desired Credentials presented in the
//         PackageList, then it means our client has store the Credentials
//         at least once. Go to step 3. 
//         Otherwise, if the PackageName is not presented in the PackageName, 
//         then return STATUS_DS_NO_ATTRIBUTE_OR_VALUE immediately.
//      3. If we find the PackageName from the PackageList, then query the
//         Credentials value from this user's SupplementalCredentials attribute
//         according to the PackageName. 
//         If we find the value, return it.
//         If we can't find the value, that means the value of that 
//         credentials is NULL or zero Length. 
//      4. If CLEARTEXT is not allowed. 
//         return STATUS_DS_CLEAR_PWD_NOT_ALLOWED error
//
// Remove Credentials:  (New Function)
//      1. Remove the PackageName from the PackageList
//      2. Remove the Credentials's value from the SupplementalCredentials
//         attribute.
//
//------------------------------------------------------------------------
#include <ntdspchx.h>
#pragma hdrstop

#include <ntlsa.h>
#include <ntsam.h>
#include <samrpc.h>
#include <ntsamp.h>
extern "C"
{

#define SECURITY_WIN32
#define SECURITY_PACKAGE
#include <security.h>
#include <secint.h>
#include <samisrv.h>
#include <samsrvp.h>
#include <dslayer.h>
#include <attids.h>
#include "usrprop.h"
}

#define PACKAGE_LIST L"Packages"
#define PRIMARY_CRED_PREFIX L"Primary:"
#define SUPP_CRED_PREFIX L"Supplemental:"


#include <pshpack1.h>
typedef struct
{
    ULONG  Format;
    ULONG  ActualLength;
    SAMP_SECRET_DATA    SecretData;
} CREDENTIAL_DATA, * PCREDENTIAL_DATA;
#include <poppack.h>

// Definitions for Format
#define SAMP_USER_PARAMETERS_FORMAT 0

//+------------------------------------------------------------------------
//
//  Function   SampEncryptCredentialData
//
//  Synopsis: Encrypts Credetial Data
//
//
//  Effects:
//
//  Arguments:
//
//
//+-------------------------------------------------------------------------
NTSTATUS
SampEncryptCredentialData(
    IN ULONG Format,
    IN ULONG Length,
    IN ULONG Rid,
    IN PVOID Data,
    IN BOOLEAN EncryptForUpgrade,
    OUT PULONG EncryptedLength,
    OUT PCREDENTIAL_DATA *EncryptedData
    )
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    USHORT      KeyId;
    PVOID       PaddedData=NULL;
    ULONG       PaddedLength=0;
    UNICODE_STRING ClearData;
    UNICODE_STRING SecretData;





    KeyId = SampGetEncryptionKeyType();
    RtlZeroMemory(&SecretData,sizeof(UNICODE_STRING));

    if ((SAMP_NO_ENCRYPTION==KeyId) || (EncryptForUpgrade))
    {

        //
        // We hit this case either if we are in DS mode ( ie win2k 
        // domain controller, where the DS performs this encryption
        // or during dcpromo time ( EncryptForUpgrade is true ) where
        // we are righting to a DS that is still in the installation
        // phase. In these cases the DS adds a layer of encryption
        //

        *EncryptedLength= SampSecretDataSize(Length)
            + sizeof(CREDENTIAL_DATA) - SampSecretDataSize(0);

        *EncryptedData= (PCREDENTIAL_DATA) LocalAlloc(0,*EncryptedLength);

        if (NULL==*EncryptedData)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        (*EncryptedData)->Format= Format;
        (*EncryptedData)->ActualLength = Length;
        (*EncryptedData)->SecretData.Flags = 0;
        (*EncryptedData)->SecretData.KeyId = SAMP_NO_ENCRYPTION;
        RtlCopyMemory(&((*EncryptedData)->SecretData.Data),
                        Data,
                        Length);
    }
    else
    {

        //
        // Since the Secret data encryption routines
        // expect the data to encrypt to be an integral
        // multiple of NT_OWF_PASSWORD, pad the data to
        // zero's till it is that length.
        //

        PaddedLength = (Length / ENCRYPTED_LM_OWF_PASSWORD_LENGTH + 1)
                                * ENCRYPTED_LM_OWF_PASSWORD_LENGTH;
        PaddedData = MIDL_user_allocate(PaddedLength);
        if (NULL==PaddedData)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // Copy Over and then Pad the data
        //
        RtlZeroMemory(PaddedData,PaddedLength);
        RtlCopyMemory(PaddedData,Data,Length);

        //
        // Encrypt the Data.
        //

        ClearData.Length = (USHORT)PaddedLength;
        ClearData.MaximumLength = (USHORT)PaddedLength;
        ClearData.Buffer = (USHORT *) PaddedData;

        NtStatus = SampEncryptSecretData(
                        &SecretData,
                        KeyId,
                        MiscCredentialData,
                        &ClearData,
                        Rid
                        );

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        //
        // Alloc Space for the credential Data Header + padded Data
        //

        ASSERT(SecretData.Length==SampSecretDataSize(PaddedLength));
        *EncryptedLength= SecretData.Length + FIELD_OFFSET(CREDENTIAL_DATA,SecretData);
        *EncryptedData= (PCREDENTIAL_DATA) LocalAlloc(0,*EncryptedLength);

        if (NULL==*EncryptedData)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // Set the fields in the Credential Data and Copy over the secret
        // data structure
        //

        (*EncryptedData)->Format= Format;
        (*EncryptedData)->ActualLength = Length;
         RtlCopyMemory(&((*EncryptedData)->SecretData),
                        SecretData.Buffer,
                        SecretData.Length);

    }

Error:

    //
    // Free any Padded Data
    //

    if ((NULL!=PaddedData) && (0!=PaddedLength))
    {
        // Zero out memory, remember this contains clear
        // password
        RtlZeroMemory(PaddedData,PaddedLength);
        MIDL_user_free(PaddedData);
    }


     //
     // Free the Secret Data returned by the Encryption routine
     //

     if (SecretData.Buffer) {
         RtlZeroMemory(SecretData.Buffer, SecretData.MaximumLength);
     }
     SampFreeUnicodeString(&SecretData);


    return NtStatus;
}


NTSTATUS
SampDecryptCredentialData(
    IN ULONG EncryptedLength,
    IN ULONG Rid,
    IN PCREDENTIAL_DATA CredentialData,
    OUT PULONG ActualLength,
    OUT PULONG Format,
    OUT PVOID  *ActualData
    )
{
    NTSTATUS    NtStatus=STATUS_SUCCESS;
    USHORT      KeyId;

   *Format = CredentialData->Format;
    KeyId = CredentialData->SecretData.KeyId;

    if (SAMP_NO_ENCRYPTION==KeyId)
    {
        *ActualLength=CredentialData->ActualLength;
        *ActualData = LocalAlloc(0,*ActualLength);
        if (NULL==*ActualData)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        RtlCopyMemory(*ActualData,&(CredentialData->SecretData.Data),*ActualLength);
    }
    else
    {
        UNICODE_STRING ClearData;
        UNICODE_STRING SecretData;

        SecretData.Length = (USHORT) (EncryptedLength - FIELD_OFFSET(CREDENTIAL_DATA,SecretData));
        SecretData.MaximumLength = (USHORT) (EncryptedLength - FIELD_OFFSET(CREDENTIAL_DATA,SecretData));
        SecretData.Buffer = (USHORT *)&(CredentialData->SecretData);

        NtStatus = SampDecryptSecretData(
                        &ClearData,
                        MiscCredentialData,
                        &SecretData,
                        Rid
                        );
        if (!NT_SUCCESS(NtStatus))
            goto Error;

        ASSERT(CredentialData->ActualLength<=ClearData.Length);
        *ActualLength = CredentialData->ActualLength;
        *ActualData = ClearData.Buffer;
    }
Error:

    return NtStatus;
}


//+-------------------------------------------------------------------------
//
//  Function:   BuildNewPackageList
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


NTSTATUS
BuildNewPackageList(
    IN PUNICODE_STRING OldPackageList,
    IN PUNICODE_STRING PackageName,
    OUT PUNICODE_STRING NewPackageList,
    IN BOOLEAN RemovePackage
    )
{
    ULONG NewPackageLength;
    UNICODE_STRING TempPackageName;
    LPWSTR NewPackageString;
    ULONG Offset;
    UNICODE_STRING OldPackageListNull;

    //
    // Build a null terminated version of the old list
    //

    OldPackageListNull.Buffer = (LPWSTR) LocalAlloc(LMEM_ZEROINIT,OldPackageList->Length + sizeof(WCHAR));
    if (OldPackageListNull.Buffer == NULL)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    RtlCopyMemory(
        OldPackageListNull.Buffer,
        OldPackageList->Buffer,
        OldPackageList->Length
        );
    OldPackageListNull.Length = OldPackageList->Length;
    OldPackageListNull.MaximumLength = sizeof(WCHAR) + OldPackageList->Length;



    //
    // Compute the name of the new package list
    //

    NewPackageLength = OldPackageListNull.Length;

    //
    // add a null separator
    //

    if (NewPackageLength != 0)
    {
        NewPackageLength += sizeof(WCHAR);
    }

    if (RemovePackage)
    {
        NewPackageLength -= PackageName->Length + sizeof(WCHAR);
    }
    else
    {
        NewPackageLength += PackageName->Length + sizeof(WCHAR);
    }

    //
    // If the resulting string is empty, add null terminator
    //

    if (NewPackageLength == 0)
    {
        NewPackageLength += sizeof(WCHAR);
    }
    NewPackageList->Buffer = (LPWSTR) LocalAlloc(0,NewPackageLength);
    if (NewPackageList->Buffer == NULL)
    {
        LocalFree(OldPackageListNull.Buffer);
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    NewPackageList->MaximumLength = (USHORT) NewPackageLength;


    if (!RemovePackage)
    {
        //
        // If we are adding the package, copy the old package list and add
        // the new one.
        //

        if (OldPackageListNull.Length > 0)
        {
            RtlCopyMemory(
                NewPackageList->Buffer,
                OldPackageListNull.Buffer,
                OldPackageListNull.Length
                );
            NewPackageList->Buffer[OldPackageListNull.Length/sizeof(WCHAR)] = L'\0';
            Offset = OldPackageListNull.Length + sizeof(WCHAR);
        }
        else
        {
             Offset = 0;
        }
        RtlCopyMemory(
            NewPackageList->Buffer + Offset/sizeof(WCHAR),
            PackageName->Buffer,
            PackageName->Length
            );
        NewPackageList->Buffer[NewPackageLength/sizeof(WCHAR) - 1] = L'\0';
    }
    else
    {
#if DBG
        BOOLEAN FoundEntry = FALSE;
#endif

        TempPackageName.Buffer = OldPackageListNull.Buffer;

        NewPackageString = NewPackageList->Buffer;

        while (TempPackageName.Buffer < OldPackageListNull.Buffer + OldPackageListNull.Length/sizeof(WCHAR))
        {
            RtlInitUnicodeString(
                &TempPackageName,
                TempPackageName.Buffer
                );

            //
            // If the packageName doesn't match, copy it to the new string.
            //

            // NewPackageString = NewPackageList->Buffer;
            if (!RtlEqualUnicodeString(
                    PackageName,
                    &TempPackageName,
                    TRUE
                    ))
            {
                RtlCopyMemory(
                    NewPackageString,
                    TempPackageName.Buffer,
                    TempPackageName.MaximumLength
                    );
                NewPackageString += TempPackageName.MaximumLength/sizeof(WCHAR);
            }
            else
            {
#if DBG
                FoundEntry = TRUE;
#endif
            }
            TempPackageName.Buffer += TempPackageName.MaximumLength / sizeof(WCHAR);
        }
        ASSERT(FoundEntry);
    }
    NewPackageList->Length = (USHORT) NewPackageLength-sizeof(WCHAR);
    NewPackageList->MaximumLength = (USHORT) NewPackageLength;
    LocalFree(OldPackageListNull.Buffer);
    return(STATUS_SUCCESS);
}


//+-------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------


BOOLEAN
FindPackageName(
    IN PUNICODE_STRING PackageList,
    IN PUNICODE_STRING PackageName
    )
{
    UNICODE_STRING TempString;

    TempString.Buffer = PackageList->Buffer;
    TempString.Length = 0;
    TempString.MaximumLength = PackageList->MaximumLength;

    //
    // Search through looking for '\0'
    //
    while (((TempString.Buffer + (TempString.Length / sizeof(WCHAR))) <
            (PackageList->Buffer + PackageList->Length/sizeof(WCHAR))) &&
            (TempString.Buffer[TempString.Length/sizeof(WCHAR)] != L'\0'))
    {
        TempString.Length += sizeof(WCHAR);

    }



    while (TempString.Buffer < PackageList->Buffer + PackageList->Length/sizeof(WCHAR))
    {
        //
        // If the packageName doesn't match, copy it to the new string.
        //

        if (RtlEqualUnicodeString(
                PackageName,
                &TempString,
                TRUE
                ))
        {
            return(TRUE);
        }

        TempString.Buffer = TempString.Buffer + (TempString.Length/sizeof(WCHAR)) + 1;
        TempString.Length = 0;

        while (((TempString.Buffer + (TempString.Length / sizeof(WCHAR))) <
                (PackageList->Buffer + PackageList->Length/sizeof(WCHAR))) &&
                (TempString.Buffer[TempString.Length/sizeof(WCHAR)] != L'\0'))
        {
            TempString.Length += sizeof(WCHAR);

        }


    }
    return(FALSE);

}

NTSTATUS
SampQueryUserSupplementalCredentials(
    IN PSAMP_OBJECT UserContext,
    OUT PUNICODE_STRING SupplementalCredentials
    )
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       EncryptedSupplementalCredentialLength=0;
    PVOID       EncryptedSupplementalCredentials=NULL;
    ATTRTYP     AttrTyp[] = {SAMP_FIXED_USER_SUPPLEMENTAL_CREDENTIALS};
    ATTRVAL     AttrVals[] = {1, NULL};
    DEFINE_ATTRBLOCK1(AttrsToRead,AttrTyp,AttrVals);
    ATTRBLOCK   ReadAttrs;


    //
    // Parameter Validation
    //

    if (!IsDsObject(UserContext))
         return STATUS_INVALID_PARAMETER;

    //
    // Initialize Return Values
    //

    RtlZeroMemory(SupplementalCredentials,sizeof(UNICODE_STRING));

     //
     // Check the context to see if any supplemental credentials are
     // already cached
     //

     if (UserContext->TypeBody.User.CachedSupplementalCredentialsValid)
     {
         EncryptedSupplementalCredentials =
             UserContext->TypeBody.User.CachedSupplementalCredentials;
         EncryptedSupplementalCredentialLength =
             UserContext->TypeBody.User.CachedSupplementalCredentialLength;
     }
     else
     {
         //
         // Read the Database for the supplemental credentials
         //

        NtStatus = SampDsRead(
                        UserContext->ObjectNameInDs,
                        0,
                        SampUserObjectType,
                        &AttrsToRead,
                        &ReadAttrs
                        );
        if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE==NtStatus)
        {
            //
            // Attribute has never been set, in which case ignore the
            // error
            //

            NtStatus = STATUS_SUCCESS;
            EncryptedSupplementalCredentialLength = 0;
            EncryptedSupplementalCredentials = NULL;
        }
        else if (NT_SUCCESS(NtStatus))
        {
            if ((1==ReadAttrs.attrCount)
                && (NULL!=ReadAttrs.pAttr)
                && (1== ReadAttrs.pAttr[0].AttrVal.valCount)
                && (NULL!=ReadAttrs.pAttr[0].AttrVal.pAVal))
            {
                EncryptedSupplementalCredentials =
                    ReadAttrs.pAttr[0].AttrVal.pAVal[0].pVal;
                EncryptedSupplementalCredentialLength =
                    ReadAttrs.pAttr[0].AttrVal.pAVal[0].valLen;

            }
            else
            {
                NtStatus = STATUS_INTERNAL_ERROR;
            }
        }
     }

     //
     // If we successfully read any supplemental credentials, then
     // decrypt it.
     //

     if ((NT_SUCCESS(NtStatus)) && (EncryptedSupplementalCredentialLength>0))
     {
         ULONG Length;
         ULONG Format;


         NtStatus = SampDecryptCredentialData(
                       EncryptedSupplementalCredentialLength,
                       UserContext->TypeBody.User.Rid,
                       (PCREDENTIAL_DATA)EncryptedSupplementalCredentials,
                       &Length,
                       &Format,
                       (PVOID *) &SupplementalCredentials->Buffer
                       );

         ASSERT(SAMP_USER_PARAMETERS_FORMAT==Format);
         if (!NT_SUCCESS(NtStatus))
         {
             goto Error;
         }

         SupplementalCredentials->Length = (USHORT) Length;
         SupplementalCredentials->MaximumLength = (USHORT) Length;

     }

Error:

     return NtStatus;
}

NTSTATUS
SampSetUserSupplementalCredentials(
    IN PSAMP_OBJECT UserContext,
    IN PUNICODE_STRING SupplementalCredentials
    )
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ATTRTYP     AttrTyp[] = {SAMP_FIXED_USER_SUPPLEMENTAL_CREDENTIALS};
    ATTRVAL     AttrVals[] = {SupplementalCredentials->Length, (UCHAR *)SupplementalCredentials->Buffer};
    DEFINE_ATTRBLOCK1(AttrsToSet,AttrTyp,AttrVals);
    ATTRBLOCK   ReadAttrs;
    ULONG       EncryptedLength;
    PCREDENTIAL_DATA  EncryptedData = NULL;


    //
    // Parameter Validation
    //
     if (!IsDsObject(UserContext))
         return STATUS_INVALID_PARAMETER;

     //
     // Encrypt this Data
     //

     NtStatus = SampEncryptCredentialData(
                    SAMP_USER_PARAMETERS_FORMAT,
                    SupplementalCredentials->Length,
                    UserContext->TypeBody.User.Rid,
                    (PVOID) SupplementalCredentials->Buffer,
                    FALSE,
                    &EncryptedLength,
                    &EncryptedData
                    );

     if (!NT_SUCCESS(NtStatus))
     {
         goto Error;
     }

     //
     // patch up the attr block
     //

     AttrsToSet.pAttr[0].AttrVal.pAVal[0].pVal = (PUCHAR) EncryptedData;
     AttrsToSet.pAttr[0].AttrVal.pAVal[0].valLen = EncryptedLength;



     //
     // Store this in the DS
     //

     NtStatus = SampDsSetAttributes(
                    UserContext->ObjectNameInDs,
                    0,
                    REPLACE_ATT,
                    SampUserObjectType,
                    &AttrsToSet
                    );



Error:

    if (NULL!=EncryptedData) {
        RtlZeroMemory(EncryptedData, EncryptedLength);
        LocalFree(EncryptedData);
    }

    return NtStatus;
}






//+-------------------------------------------------------------------------
//
//  Function:   SamIStorePrimaryCredentials
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

NTSTATUS
SampStoreCredentials(
    IN SAMPR_HANDLE UserHandle,
    IN PSECPKG_SUPPLEMENTAL_CRED Credentials,
    IN BOOLEAN Primary
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING OldPackageList;
    UNICODE_STRING NewPackageList;
    UNICODE_STRING OldUserParameters;
    UNICODE_STRING NewUserParameters;
    UNICODE_STRING UserParameters;
    UNICODE_STRING EmptyString;
    UNICODE_STRING NewCredentials;
    BOOL Update = FALSE;
    WCHAR Flags;
    LPWSTR PackageName = NULL;
    LPWSTR CredentialTag = NULL;

    //
    // Initialize local variables
    // 
    memset(&OldPackageList, 0, sizeof(UNICODE_STRING));
    memset(&NewPackageList, 0, sizeof(UNICODE_STRING));
    memset(&OldUserParameters, 0, sizeof(UNICODE_STRING));
    memset(&NewUserParameters, 0, sizeof(UNICODE_STRING));
    memset(&UserParameters, 0, sizeof(UNICODE_STRING));
    memset(&NewCredentials, 0, sizeof(UNICODE_STRING));

    RtlInitUnicodeString(
        &EmptyString,
        NULL
        );


    //
    // Get the old user parameters
    //


    Status = SampQueryUserSupplementalCredentials(
                (PSAMP_OBJECT) UserHandle,
                &OldUserParameters
                );


    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // Build the package cred tag
    //

    if (Primary)
    {
        PackageName = (LPWSTR) LocalAlloc(0,sizeof(PRIMARY_CRED_PREFIX) + Credentials->PackageName.Length);
        if (PackageName == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            PackageName,
            PRIMARY_CRED_PREFIX,
            sizeof(PRIMARY_CRED_PREFIX) - sizeof(WCHAR)
            );
        RtlCopyMemory(
            PackageName + (sizeof(PRIMARY_CRED_PREFIX) - sizeof(WCHAR)) / sizeof(WCHAR),
            Credentials->PackageName.Buffer,
            Credentials->PackageName.Length
            );
        PackageName[(sizeof(PRIMARY_CRED_PREFIX) + Credentials->PackageName.Length - sizeof(WCHAR)) / sizeof(WCHAR)] = L'\0';
    }
    else
    {
        PackageName = (LPWSTR) LocalAlloc(0,sizeof(SUPP_CRED_PREFIX) + Credentials->PackageName.Length);
        if (PackageName == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            PackageName,
            SUPP_CRED_PREFIX,
            sizeof(SUPP_CRED_PREFIX) - sizeof(WCHAR)
            );
        RtlCopyMemory(
            PackageName + (sizeof(SUPP_CRED_PREFIX) - sizeof(WCHAR)) / sizeof(WCHAR),
            Credentials->PackageName.Buffer,
            Credentials->PackageName.Length
            );
        PackageName[(sizeof(SUPP_CRED_PREFIX) + Credentials->PackageName.Length - sizeof(WCHAR)) / sizeof(WCHAR)] = L'\0';
    }

    //
    // Get the list of package names out of the PrimaryCred value
    //

    Status = QueryUserPropertyWithLength(
                (PUNICODE_STRING) &OldUserParameters,
                PACKAGE_LIST,
                &Flags,
                &OldPackageList
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }


    //
    // Check whether the credentials' Package Name is in the PackagList or not
    // 

    if (!FindPackageName(
            &OldPackageList, 
            &Credentials->PackageName))
    {
        //
        // Package Name not in the PackageList, add it and 
        // store the new PackageList
        // 
        Status = BuildNewPackageList(
                    &OldPackageList, 
                    &Credentials->PackageName, 
                    &NewPackageList, 
                    FALSE
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        Status = SetUserPropertyWithLength(
                    (PUNICODE_STRING) &OldUserParameters, 
                    PACKAGE_LIST, 
                    &NewPackageList, 
                    USER_PROPERTY_TYPE_SET, 
                    &UserParameters.Buffer, 
                    &Update
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        RtlInitUnicodeString(
            &UserParameters, 
            UserParameters.Buffer
            );
    }
    else
    {
        UserParameters = *(PUNICODE_STRING) &OldUserParameters;
    }


    //
    // Now store the new credentials.
    // If the new credentials is NULL or 0 length. Then the worker 
    // routine - SetUserPropertyWithLength() will remove the 
    // Credentials from the intern structure. However, we still 
    // Have the PackageName in the PackageList field. So we know
    // this is a 0 Length value Credentials.
    //

    if (Credentials->CredentialSize > 0xffff)
    {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    NewCredentials.Buffer = (LPWSTR) Credentials->Credentials;
    NewCredentials.Length = NewCredentials.MaximumLength = (USHORT) Credentials->CredentialSize;

    Status = SetUserPropertyWithLength(
                &UserParameters,
                PackageName,
                &NewCredentials,
                USER_PROPERTY_TYPE_ITEM,
                &NewUserParameters.Buffer,
                &Update
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If the parameters changed, write them back to SAM
    //

    if (Update)
    {
        RtlInitUnicodeString(
            &NewUserParameters,
            NewUserParameters.Buffer
            );

        Status = SampSetUserSupplementalCredentials(
                    (PSAMP_OBJECT) UserHandle,
                    &NewUserParameters
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
    }


Cleanup:
    if (OldPackageList.Buffer != NULL)
    {
        LocalFree(OldPackageList.Buffer);
    }
    if (NewPackageList.Buffer != NULL)
    {
        LocalFree(NewPackageList.Buffer);
    }

    if (NewUserParameters.Buffer != NULL)
    {
        RtlZeroMemory(NewUserParameters.Buffer, NewUserParameters.MaximumLength);
        LocalFree(NewUserParameters.Buffer);
    }
    if ((UserParameters.Buffer != NULL) &&
        (UserParameters.Buffer != OldUserParameters.Buffer))

    {
        RtlZeroMemory(UserParameters.Buffer, UserParameters.MaximumLength);
        LocalFree(UserParameters.Buffer);
    }
    if (OldUserParameters.Buffer!=NULL)
    {
        RtlZeroMemory(OldUserParameters.Buffer, OldUserParameters.MaximumLength);
        LocalFree(OldUserParameters.Buffer);
    }

    if (PackageName != NULL)
    {
        LocalFree(PackageName);
    }


    return(Status);
}




NTSTATUS
SampRemoveCredentials(
    IN PUNICODE_STRING SupplementalCredentials,
    IN PUNICODE_STRING PackageName,
    IN BOOLEAN Primary,
    OUT BOOL *Update,
    OUT PUNICODE_STRING NewSupplementalCredentials
    )
{

    NTSTATUS    Status;
    
    UNICODE_STRING  OldPackageList;
    UNICODE_STRING  NewPackageList;
    UNICODE_STRING  EmptyString;
    LPWSTR  CredentialTag = NULL ;
    WCHAR   *Buffer = NULL;
    WCHAR   Flags;


    //
    // Initialize local variables.
    // 
    
    memset(&OldPackageList, 0, sizeof(UNICODE_STRING));
    memset(&NewPackageList, 0, sizeof(UNICODE_STRING));

    RtlInitUnicodeString( &EmptyString, NULL );

    *Update = FALSE;


    //
    // Build the package cred tag
    //

    if (Primary)
    {
        CredentialTag = (LPWSTR) LocalAlloc(0,sizeof(PRIMARY_CRED_PREFIX) + PackageName->Length);
        if (CredentialTag == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            CredentialTag, 
            PRIMARY_CRED_PREFIX,
            sizeof(PRIMARY_CRED_PREFIX) - sizeof(WCHAR)
            );
        RtlCopyMemory(
            CredentialTag + (sizeof(PRIMARY_CRED_PREFIX) - sizeof(WCHAR)) / sizeof(WCHAR),
            PackageName->Buffer,
            PackageName->Length
            );
        CredentialTag[(sizeof(PRIMARY_CRED_PREFIX) + PackageName->Length - sizeof(WCHAR)) / sizeof(WCHAR)] = L'\0';
    }
    else
    {
        CredentialTag = (LPWSTR) LocalAlloc(0,sizeof(SUPP_CRED_PREFIX) + PackageName->Length);
        if (CredentialTag == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            CredentialTag,
            SUPP_CRED_PREFIX,
            sizeof(SUPP_CRED_PREFIX) - sizeof(WCHAR)
            );
        RtlCopyMemory(
            CredentialTag + (sizeof(SUPP_CRED_PREFIX) - sizeof(WCHAR)) / sizeof(WCHAR),
            PackageName->Buffer,
            PackageName->Length
            );
        CredentialTag[(sizeof(SUPP_CRED_PREFIX) + PackageName->Length - sizeof(WCHAR)) / sizeof(WCHAR)] = L'\0';
    }

    //
    // Get the list of package names out of the PrimaryCred value
    //

    Status = QueryUserPropertyWithLength(
                SupplementalCredentials,
                PACKAGE_LIST,
                &Flags,
                &OldPackageList
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Remove the PackageName from the PackageList field, 
    // then store the updated PackageList
    // 
    if (FindPackageName(
            &OldPackageList, 
            PackageName))
    {
        Status = BuildNewPackageList(
                    &OldPackageList, 
                    PackageName, 
                    &NewPackageList, 
                    TRUE        // remove package
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        Status = SetUserPropertyWithLength(
                    SupplementalCredentials, 
                    PACKAGE_LIST, 
                    &NewPackageList, 
                    USER_PROPERTY_TYPE_SET, 
                    &Buffer, 
                    Update
                    );

        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }
        RtlInitUnicodeString(
            NewSupplementalCredentials, 
            Buffer
            );
    }
    else
    {
        //
        // PackageName is not in the PackageList 
        // Nothing further to do.
        // 

        //
        // N.B. When Update is set to FALSE, NewSupplementalCredentials
        // doesn't need to be set.
        //
        *Update = FALSE;
        goto Cleanup;
    }


    //
    // Now remove the value of the Credentials from the 
    // SupplementalCredentials attribute. 
    //

    Status = SetUserPropertyWithLength(
                NewSupplementalCredentials,
                CredentialTag,
                &EmptyString,
                USER_PROPERTY_TYPE_ITEM,
                &NewSupplementalCredentials->Buffer,
                Update
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // If the parameters changed, write them back to SAM
    //

    if (*Update)
    {
        RtlInitUnicodeString(
            NewSupplementalCredentials,
            NewSupplementalCredentials->Buffer
            );

    }


Cleanup:
    if (OldPackageList.Buffer != NULL)
    {
        LocalFree(OldPackageList.Buffer);
    }
    if (NewPackageList.Buffer != NULL)
    {
        LocalFree(NewPackageList.Buffer);
    }

    if (CredentialTag != NULL)
    {
        LocalFree(CredentialTag);
    }

    //
    // N.B. Buffer is freed in SetUserPropertyWithLength if necessary
    //

    return(Status);
}



//+-------------------------------------------------------------------------
//
//  Function:   SamIRetrievePrimaryCredentiala
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Notes:
//
//
//--------------------------------------------------------------------------

extern "C"


NTSTATUS
SampRetrieveCredentials(
    IN SAMPR_HANDLE UserHandle,
    IN PUNICODE_STRING PackageName,
    IN BOOLEAN Primary,
    OUT PVOID * Credentials,
    OUT PULONG CredentialSize
    )
{
    NTSTATUS Status;
    LPWSTR CredentialTag = NULL;
    WCHAR Flags;
    UNICODE_STRING OldUserParameters;
    UNICODE_STRING PackageList;
    UNICODE_STRING PackageCreds;
    UNICODE_STRING ClearTextPackageName;
    PSAMP_OBJECT    AccountContext;
    PSAMP_DEFINED_DOMAINS   Domain;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    BOOLEAN fClearTextRequired = FALSE;


    memset(&OldUserParameters, 0, sizeof(UNICODE_STRING));
    memset(&PackageList, 0, sizeof(UNICODE_STRING));
    memset(&PackageCreds, 0, sizeof(UNICODE_STRING));
    
    RtlInitUnicodeString(&ClearTextPackageName, L"CLEARTEXT");
    fClearTextRequired =  RtlEqualUnicodeString(&ClearTextPackageName, 
                                                 PackageName, 
                                                 TRUE  // Case Insensitive 
                                                 );

    PackageCreds.Buffer = NULL;

    RtlZeroMemory(&OldUserParameters, sizeof(UNICODE_STRING));

    //
    // Build the package cred tag
    //

    if (Primary)
    {
        CredentialTag = (LPWSTR) LocalAlloc(0,sizeof(PRIMARY_CRED_PREFIX) + PackageName->Length);
        if (CredentialTag == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            CredentialTag,
            PRIMARY_CRED_PREFIX,
            sizeof(PRIMARY_CRED_PREFIX) - sizeof(WCHAR)
            );
        RtlCopyMemory(
            CredentialTag + (sizeof(PRIMARY_CRED_PREFIX) - sizeof(WCHAR)) / sizeof(WCHAR),
            PackageName->Buffer,
            PackageName->Length
            );
        CredentialTag[(sizeof(PRIMARY_CRED_PREFIX) + PackageName->Length - sizeof(WCHAR)) / sizeof(WCHAR)] = L'\0';
    }
    else
    {
        CredentialTag = (LPWSTR) LocalAlloc(0,sizeof(SUPP_CRED_PREFIX) + PackageName->Length);
        if (CredentialTag == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }
        RtlCopyMemory(
            CredentialTag,
            SUPP_CRED_PREFIX,
            sizeof(SUPP_CRED_PREFIX) - sizeof(WCHAR)
            );
        RtlCopyMemory(
            CredentialTag + (sizeof(SUPP_CRED_PREFIX) - sizeof(WCHAR)) / sizeof(WCHAR),
            PackageName->Buffer,
            PackageName->Length
            );
        CredentialTag[(sizeof(SUPP_CRED_PREFIX) + PackageName->Length - sizeof(WCHAR)) / sizeof(WCHAR)] = L'\0';
    }


    // check the Domain User settings
    if ( fClearTextRequired )
    {
        AccountContext = (PSAMP_OBJECT)UserHandle;
        Status = SampRetrieveUserV1aFixed(
                        AccountContext,
                        &V1aFixed
                        );
        if (!NT_SUCCESS(Status) )
        {
            goto Cleanup;
        }
    
        Domain = &SampDefinedDomains[ AccountContext->DomainIndex ];

        if ( ((Domain->UnmodifiedFixed.PasswordProperties & DOMAIN_PASSWORD_STORE_CLEARTEXT) == 0) 
             && ((V1aFixed.UserAccountControl & USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED) == 0)) {
            *Credentials = NULL;
            *CredentialSize = 0;
            Status = STATUS_DS_NO_ATTRIBUTE_OR_VALUE;
            goto Cleanup;
        }

    }

    //
    // Get the old supplemental credentials
    //

    Status = SampQueryUserSupplementalCredentials(
                (PSAMP_OBJECT) UserHandle,
                &OldUserParameters
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    //
    // Get the Package List 
    //

    Status = QueryUserPropertyWithLength(
                (PUNICODE_STRING) &OldUserParameters, 
                PACKAGE_LIST, 
                &Flags, 
                &PackageList
                );

    if (!NT_SUCCESS(Status))
    {
        goto Cleanup;
    }

    if (FindPackageName(
            &PackageList, 
            PackageName)
        )
    {
        //
        // Get the credentials from the parameters
        //

        Status = QueryUserPropertyWithLength(
                    (PUNICODE_STRING) &OldUserParameters,
                    CredentialTag,
                    &Flags,
                    &PackageCreds
                    );
        if (!NT_SUCCESS(Status))
        {
            goto Cleanup;
        }

        *Credentials = PackageCreds.Buffer;
        *CredentialSize = PackageCreds.Length;
    }
    else
    {               
        //
        // PackageName is presented in the PackageList, 
        // it means this credentials is not stored previously.
        // 
        *Credentials = NULL;
        *CredentialSize = 0;
        Status = STATUS_DS_NO_ATTRIBUTE_OR_VALUE;
    }

Cleanup:

    if (OldUserParameters.Buffer != NULL)
    {
        RtlZeroMemory(OldUserParameters.Buffer, OldUserParameters.MaximumLength);
        LocalFree(OldUserParameters.Buffer);
    }
    if (PackageList.Buffer != NULL)
    {
        LocalFree(PackageList.Buffer);
    }
    if (CredentialTag != NULL)
    {
        LocalFree(CredentialTag);
    }

    return(Status);
}

NTSTATUS
SamIStoreSupplementalCredentials(
    IN SAMPR_HANDLE UserHandle,
    IN PSECPKG_SUPPLEMENTAL_CRED Credentials
    )
{
  NTSTATUS NtStatus = STATUS_SUCCESS;
  NTSTATUS IgnoreStatus;
  BOOLEAN  fLockAcquired = FALSE;
  BOOLEAN  fDereferenceContext = FALSE;
  SAMP_OBJECT_TYPE  FoundType;

  SAMTRACE("SamIStoreSupplementalCredentials");

  if (!SampUseDsData)
  {
      return(STATUS_NOT_SUPPORTED);
  }

  //
  // Acquire Write Lock
  // 
  NtStatus = SampAcquireWriteLock();
  if (!NT_SUCCESS(NtStatus))
  {
      goto Cleanup;
  }

  fLockAcquired = TRUE;
  
  //
  // Validate the Passed in context
  //

  NtStatus = SampLookupContext(
                (PSAMP_OBJECT) UserHandle, 
                0, 
                SampUserObjectType, 
                &FoundType
                );

  if (!NT_SUCCESS(NtStatus))
  {
      goto Cleanup;
  }

  fDereferenceContext = TRUE;

  NtStatus =  SampStoreCredentials(
                 UserHandle,
                 Credentials,
                 FALSE
                 );

  if (NT_SUCCESS(NtStatus))
  {
      //
      // Commite and release write lock
      // 
      NtStatus = SampReleaseWriteLock(TRUE);
      fLockAcquired = FALSE;
  }

Cleanup:

    if (fDereferenceContext)
    {
        SampDeReferenceContext((PSAMP_OBJECT) UserHandle, FALSE);
    }

    if (fLockAcquired)
    {
        SampReleaseWriteLock(FALSE);
    }

    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return(NtStatus);
}



NTSTATUS
SamIRetrieveSupplementalCredentials(
    IN SAMPR_HANDLE UserHandle,
    IN PUNICODE_STRING PackageName,
    OUT PVOID * Credentials,
    OUT PULONG CredentialSize
    )
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN  fLockAcquired = FALSE;
    BOOLEAN  fContextReferenced = FALSE;
    NTSTATUS IgnoreStatus;
    SAMP_OBJECT_TYPE  FoundType;

    SAMTRACE("SamIRetrieveSupplementalCredentials");

    //
    // Additional Credential types are supported only in DS Mode
    // 

    if (!IsDsObject(((PSAMP_OBJECT) UserHandle)))
    {
        NtStatus = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // Acquire the read lock if necessary
    // 

    SampMaybeAcquireReadLock((PSAMP_OBJECT)UserHandle, 
                             DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                             &fLockAcquired);

    //
    // Lookup the context
    //

    NtStatus = SampLookupContext(
                    (PSAMP_OBJECT) UserHandle, 
                    0, 
                    SampUserObjectType, 
                    &FoundType
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }


    fContextReferenced = TRUE;

    NtStatus = SampRetrieveCredentials(
                 UserHandle,
                 PackageName,
                 FALSE,
                 Credentials,
                 CredentialSize
                 );

Cleanup:

  //
  // Derefence the context
  //

  if (fContextReferenced)
  {
        IgnoreStatus = SampDeReferenceContext((PSAMP_OBJECT)UserHandle, FALSE);
        ASSERT(NT_SUCCESS(IgnoreStatus));
  }

  SampMaybeReleaseReadLock(fLockAcquired);

  SAMTRACE_RETURN_CODE_EX(NtStatus);

  return(NtStatus);
}
                          

NTSTATUS
SamIStorePrimaryCredentials(
    IN SAMPR_HANDLE UserHandle,
    IN PSECPKG_SUPPLEMENTAL_CRED Credentials
    )
{
  NTSTATUS NtStatus = STATUS_SUCCESS;
  BOOLEAN  fLockAcquired = FALSE;
  BOOLEAN  fDereferenceContext = FALSE;
  SAMP_OBJECT_TYPE  FoundType;

  SAMTRACE("SamIStorePriamryCredentials");

  if (!SampUseDsData)
  {
      return(STATUS_NOT_SUPPORTED);
  }

  //
  // Acquire Write Lock
  // 
  NtStatus = SampAcquireWriteLock();
  if (!NT_SUCCESS(NtStatus))
  {
      goto Cleanup;
  }

  fLockAcquired = TRUE;
  
  //
  // Validate the Passed in context
  //

  NtStatus = SampLookupContext(
                (PSAMP_OBJECT) UserHandle, 
                0, 
                SampUserObjectType, 
                &FoundType
                );

  if (!NT_SUCCESS(NtStatus))
  {
      goto Cleanup;
  }

  fDereferenceContext = TRUE;

  NtStatus = SampStoreCredentials(
                UserHandle,
                Credentials,
                TRUE
                );

  if (NT_SUCCESS(NtStatus))
  {
      //
      // Commite and release write lock
      // 
      NtStatus = SampReleaseWriteLock(TRUE);
      fLockAcquired = FALSE;
  }

Cleanup:

    if (fDereferenceContext)
    {
        SampDeReferenceContext((PSAMP_OBJECT) UserHandle, FALSE);
    }

    if (fLockAcquired)
    {
        SampReleaseWriteLock(FALSE);
    }

    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return(NtStatus);
}



NTSTATUS
SamIRetrievePrimaryCredentials(
    IN SAMPR_HANDLE UserHandle,
    IN PUNICODE_STRING PackageName,
    OUT PVOID * Credentials,
    OUT PULONG CredentialSize
    )
{
  NTSTATUS NtStatus = STATUS_SUCCESS;

  BOOLEAN  fLockAcquired = FALSE;
  BOOLEAN  fContextReferenced = FALSE;
  NTSTATUS IgnoreStatus;
  SAMP_OBJECT_TYPE FoundType;

  SAMTRACE("SamIRetrievePrimaryCredentials");

    //
    // Additional credential types are supported only in DS mode.
    //

    if (!IsDsObject(((PSAMP_OBJECT)UserHandle)))
    {
        NtStatus = STATUS_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // Acquire the read lock if necessary
    //

    SampMaybeAcquireReadLock((PSAMP_OBJECT)UserHandle,
                             DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                             &fLockAcquired);

    //
    // Lookup the context
    //

    NtStatus = SampLookupContext(
                    (PSAMP_OBJECT) UserHandle,
                    0,
                    SampUserObjectType,
                    &FoundType
                    );
    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    fContextReferenced = TRUE;

    //
    // Retrieve the credentials
    //

    NtStatus = SampRetrieveCredentials(
                    UserHandle,
                    PackageName,
                    TRUE,
                    Credentials,
                    CredentialSize
                    );


Cleanup:

    //
    // Derefence the context
    //

    if (fContextReferenced)
    {
        IgnoreStatus = SampDeReferenceContext((PSAMP_OBJECT) UserHandle, FALSE);
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }
        
    SampMaybeReleaseReadLock(fLockAcquired);


    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return(NtStatus);
}

NTSTATUS
SamIRetriveAllSupplementalCredentials(
    IN SAMPR_HANDLE UserHandle,
    OUT PSECPKG_SUPPLEMENTAL_CRED * Credentials,
    OUT PULONG CredentialCount
    )
{
    return(STATUS_NOT_IMPLEMENTED);
}


extern "C" 
{

NTSTATUS
SampAddSupplementalCredentials(
    IN PSECPKG_SUPPLEMENTAL_CRED Credential,
    IN PUNICODE_STRING OldUserParameters,
    OUT PUNICODE_STRING NewUserParameters,
    OUT BOOL  * Update
    )
    
/*++

Routine Description:

    This routine add one Credential data to OldUserParameters, return the NewUserParameters.
    
Arguments:
    
    Credential - Pointer, to the supplemental crdentials.
    
    OldUserParameters - Pointer, to the old data.
    
    NewUserParameters - Pointer, return the new data.
    
    Update - Indicate whether the data is changed or not.
    
    
    Note: --- We use OldUserParameters, NewUserParameters, but the actual data in OldUserParameters
              and NewUserParameter is Credential Data ! OldUserParameter is used because of following
              the old naming convention. 

Return Values:

--*/

{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    UNICODE_STRING OldPackageList;
    UNICODE_STRING NewPackageList;
    UNICODE_STRING UserParameters;
    UNICODE_STRING EmptyString;
    UNICODE_STRING NewCredential;
    WCHAR       Flags;
    LPWSTR      PackageName = NULL;
     
    
    SAMTRACE("SampAddSupplementalCredentials");
    
    // 
    // initialize
    // 
    
    *Update = FALSE; 
    memset(&OldPackageList, 0, sizeof(UNICODE_STRING));
    memset(&NewPackageList, 0, sizeof(UNICODE_STRING));
    memset(&UserParameters, 0, sizeof(UNICODE_STRING));
    memset(&NewCredential, 0, sizeof(UNICODE_STRING));
    
    RtlInitUnicodeString(
            &EmptyString,
            NULL
            );
    
    // 
    // Build the package cred tag
    //
    // SAM stored PrimaryCredentials and Supplemental Credentials is one continue 
    // blob. To discriminate Primary and Supplemental credentials, SAM put a tag 
    // of either "Primary" or "Supplemental" before the credential package name to 
    // distinguish them. Thus if you store a credential as primary credentials, it 
    // will show up in the blob as "Primary:Package Name ....". So you won't retrieve 
    // it by issue SamIRetrieveSupplementalCredentials. Client needs to use corresponding 
    // API to retrieve credentials as they store them. 
    // 
    // Think about RAS, they always use SamIRetrievePrimaryCredentials to retrieve 
    // password, so we'd better store any encrypted attribute in Primary credentials. 
    // 
    PackageName = (LPWSTR) LocalAlloc(LPTR, sizeof(PRIMARY_CRED_PREFIX) + Credential->PackageName.Length);
    
    if (NULL == PackageName)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    
    RtlCopyMemory(PackageName, 
                  PRIMARY_CRED_PREFIX,
                  sizeof(PRIMARY_CRED_PREFIX) - sizeof(WCHAR)
                  );
                  
    RtlCopyMemory(PackageName + (sizeof(PRIMARY_CRED_PREFIX) - sizeof(WCHAR)) / sizeof(WCHAR),
                  Credential->PackageName.Buffer,
                  Credential->PackageName.Length
                  );
                  
    PackageName[(sizeof(PRIMARY_CRED_PREFIX) + Credential->PackageName.Length - sizeof(WCHAR)) / sizeof(WCHAR)] = L'\0';
    
    
    //
    // Get the list of package names out the SupplementalCred value
    //
    NtStatus = QueryUserPropertyWithLength(
                        (PUNICODE_STRING) OldUserParameters,
                        PACKAGE_LIST,
                        &Flags,
                        &OldPackageList
                        );
                        
    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }
    
    // 
    // if the buffer of the credential is NULL, then we are deleting 
    // the credential. Otherwise we are adding them.
    //
    
    //
    // Add the package name to the list
    // 
    if (!FindPackageName(
                    &OldPackageList,
                    &Credential->PackageName)
       )
    {
        NtStatus = BuildNewPackageList(
                        &OldPackageList,
                        &Credential->PackageName,
                        &NewPackageList,
                        FALSE                   // Don't remove package
                        );
                            
        if (!NT_SUCCESS(NtStatus))
        {
            goto Cleanup;
        }
            
        NtStatus = SetUserPropertyWithLength(
                        OldUserParameters,
                        PACKAGE_LIST,
                        &NewPackageList,
                        USER_PROPERTY_TYPE_SET,
                        &UserParameters.Buffer,
                        Update
                        );
                                            
        if (!NT_SUCCESS(NtStatus))
        {
            goto Cleanup;
        }
            
        RtlInitUnicodeString(
                &UserParameters,
                UserParameters.Buffer
                );
            
    }
    else
    {
        UserParameters = * OldUserParameters; 
    }
        
    //
    // Now store the new credentials
    //
        
    if (Credential->CredentialSize > 0xffff)
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
        
    NewCredential.Buffer = (LPWSTR) Credential->Credentials;
    NewCredential.Length = (USHORT) Credential->CredentialSize;
    NewCredential.MaximumLength = (USHORT) Credential->CredentialSize;
    
    NtStatus = SetUserPropertyWithLength(
                        &UserParameters,
                        PackageName,
                        &NewCredential,
                        USER_PROPERTY_TYPE_ITEM,
                        &NewUserParameters->Buffer,
                        Update
                        );
        
    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }
    
    
    if (*Update)
    {
        RtlInitUnicodeString(NewUserParameters,
                             NewUserParameters->Buffer
                             );
    }

Cleanup:

    if (NULL != UserParameters.Buffer &&
        UserParameters.Buffer != OldUserParameters->Buffer)
    {
        RtlZeroMemory(UserParameters.Buffer, UserParameters.MaximumLength);
        LocalFree(UserParameters.Buffer);
    }
    
    if (NULL != PackageName)
    {
        LocalFree(PackageName);
    }
    
    
    if (NULL != OldPackageList.Buffer)
    {
        LocalFree(OldPackageList.Buffer);
    }
    
    if (NULL != NewPackageList.Buffer)
    {
        LocalFree(NewPackageList.Buffer);
    }

    
    return NtStatus;

}




NTSTATUS
SampConvertCredentialsToAttr(
    IN PSAMP_OBJECT Context OPTIONAL,
    IN ULONG   Flags,
    IN ULONG   ObjectRid,
    IN PSAMP_SUPPLEMENTAL_CRED SupplementalCredentials,
    OUT ATTR * CredentialAttr 
    )
    
/*++

Routine Description:

    This routine packs all supplemental credentials into single ATTR structure

Arguments:

    Context - Pointer, to SAM User object's context.
    
    Flags - Indicate where during NT4->NT5 upgrade dcpromote or not.
    
    ObjectRid - Object's Relative ID, used to encrypt credential data.
    
    SupplementalCredentials - link list, contains all supplemental credentials to set.
    
    CredentialAttr - Pointer, used to return the single ATTR structure. 

Return Values:

    STATUS_SUCCESS - CredentialAttr will contain the well-constructed ATTR structure to set.
    
    STATUS_NO_MEMORY.

--*/

{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    UNICODE_STRING  UserParameters;
    UNICODE_STRING  TmpUserParameters;
    BOOL            Update = FALSE;
    ULONG             EncryptedLength;
    PCREDENTIAL_DATA  EncryptedData = NULL;
    PSAMP_SUPPLEMENTAL_CRED  Credential = SupplementalCredentials;  
    
    // Note: --- We use OldUserParameters, TmpUserParameters, but the actual data in OldUserParameters
    //           and TmpUserParameter is Credential Data! 
    //           OldUserParameter is used because of following the old naming convention. 
    
    
    SAMTRACE("SampConvertCredentialsToAttr");
    
    ASSERT(ARGUMENT_PRESENT(Context) || (Flags & SAM_USERPARMS_DURING_UPGRADE));
    // 
    // initialize
    //  
    memset(&UserParameters, 0, sizeof(UNICODE_STRING));
    memset(&TmpUserParameters, 0, sizeof(UNICODE_STRING));
    
    //
    // in NT4->NT5 upgrade case the Context is not well-constructed, 
    // and there is not SupplementalCredential attribute in NT4 scenario, so no need to 
    // QueryUserSupplementCredentials
    // 
    if ( !(Flags & SAM_USERPARMS_DURING_UPGRADE) )
    {
        NtStatus = SampQueryUserSupplementalCredentials(
                                Context, 
                                &UserParameters
                                );
        
        if (!NT_SUCCESS(NtStatus))
        {
            goto Cleanup;
        }
        
        Context->TypeBody.User.CachedSupplementalCredentialsValid = FALSE;
    }
    
    
    // 
    // Add Supplemental Credentials one by one
    //
    while (Credential)
    {
        if (Credential->Remove)
        {

            NtStatus = SampRemoveCredentials(
                            &UserParameters,
                            & Credential->SupplementalCred.PackageName,
                            TRUE,
                            &Update,
                            &TmpUserParameters
                            );
        }
        else
        {
            NtStatus = SampAddSupplementalCredentials(&(Credential->SupplementalCred),
                                                  &UserParameters,
                                                  &TmpUserParameters, 
                                                  &Update
                                                  );
        }
                                                    
        if (!NT_SUCCESS(NtStatus))
        {
            goto Cleanup;
        }
        else
        {
            if (Update)
            {
                ASSERT(NULL != TmpUserParameters.Buffer);
                
                if (NULL != UserParameters.Buffer)
                {
                    RtlZeroMemory(UserParameters.Buffer, UserParameters.MaximumLength);
                    LocalFree(UserParameters.Buffer);
                    memset(&UserParameters, 0, sizeof(UNICODE_STRING));
                }
                
                UserParameters = TmpUserParameters;
                memset(&TmpUserParameters, 0, sizeof(UNICODE_STRING));
            }
            else
            {
                if (NULL != TmpUserParameters.Buffer)
                {
                    RtlZeroMemory(TmpUserParameters.Buffer, TmpUserParameters.MaximumLength);
                    LocalFree(TmpUserParameters.Buffer);
                }
                memset(&TmpUserParameters, 0, sizeof(UNICODE_STRING));
            }
        }
    
        Credential = Credential->Next;
    }

    //
    // Encrypt credential data
    //
    NtStatus = SampEncryptCredentialData(
                   SAMP_USER_PARAMETERS_FORMAT,
                   UserParameters.Length,
                   ObjectRid,
                   (PVOID) UserParameters.Buffer,
                   (Flags & SAM_USERPARMS_DURING_UPGRADE)?TRUE:FALSE,
                   &EncryptedLength,
                   &EncryptedData
                   );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    //
    // patch up the attr 
    //
    CredentialAttr->AttrVal.pAVal = (ATTRVAL *) MIDL_user_allocate(sizeof(ATTRVAL)); 
    
    if (NULL == CredentialAttr->AttrVal.pAVal)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    
    RtlZeroMemory(CredentialAttr->AttrVal.pAVal, sizeof(ATTRVAL));
    
    CredentialAttr->attrTyp = ATT_SUPPLEMENTAL_CREDENTIALS;
    CredentialAttr->AttrVal.valCount = 1;
    
    CredentialAttr->AttrVal.pAVal[0].pVal = (PUCHAR) MIDL_user_allocate(EncryptedLength);
    
    if (NULL == CredentialAttr->AttrVal.pAVal[0].pVal)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    
    CredentialAttr->AttrVal.pAVal[0].valLen = EncryptedLength;
    
    RtlZeroMemory(CredentialAttr->AttrVal.pAVal[0].pVal, EncryptedLength);
    
    RtlCopyMemory(CredentialAttr->AttrVal.pAVal[0].pVal, 
                  EncryptedData, 
                  EncryptedLength
                  );


Cleanup:

    if (NULL != UserParameters.Buffer)
    {
        RtlZeroMemory(UserParameters.Buffer, UserParameters.MaximumLength);
        LocalFree(UserParameters.Buffer);
    }

    if (NULL != TmpUserParameters.Buffer)
    {
        RtlZeroMemory(TmpUserParameters.Buffer, TmpUserParameters.MaximumLength);
        LocalFree(TmpUserParameters.Buffer);
    }
    
    if (NULL != EncryptedData)
    {
        RtlZeroMemory(EncryptedData, EncryptedLength);
        LocalFree(EncryptedData);
    }
    
    return NtStatus;    

}


} // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\dbgutil.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    dbgutil.c

Abstract:

    This file contains supplimental debugging and diagnostic routines for SAM.


Author:

    Chris Mayhall (ChrisMay) 04-Apr-1996

Environment:

    User Mode - Win32

Revision History:

    04-Apr-1996 ChrisMay
        Created.
    08-Apr-1996 ChrisMay
        Added enumeration routines.
    15-Apr-1996 ChrisMay
        Added query routines.
    03-Dec-1996 ChrisMay
        Documented how to use trace tags and added global for filtered KD
        output.

--*/

//
// Includes
//

#include <samsrvp.h>


//
// Constants
//

#define DBG_BUFFER_SIZE                     512


//
// Private Helper Routines
//

// Trace table contains the set of flags (masks) that SampTraceFileTags can
// be set to, in order to control the debug verbosity during a call trace.
// To use this facility, the value of SampTraceTags is set to 2 (SAMP_TRACE-
// FILE_BASIS), from the debugger, and SampTraceFileTags is set to one or more
// of the following values depending on which files you want to trace:

TRACE_TABLE_ENTRY TraceTable[] =
{

    {"alias.c",    0x00000001},
    {"almember.c", 0x00000002},
    {"attr.c",     0x00000004},
    {"bldsam3.c",  0x00000008},
    {"close.c",    0x00000010},
    {"context.c",  0x00000020},
    {"dbgutil.c",  0x00000040},
    {"display.c",  0x00000080},
    {"domain.c",   0x00000100},
    {"dslayer.c",  0x00000200},
    {"dsmember.c", 0x00000400},
    {"dsutil.c",   0x00000800},
    {"enum.c",     0x00001000},
    {"gentab2.c",  0x00002000},
    {"global.c",   0x00004000},
    {"group.c",    0x00008000},
    {"notify.c",   0x00010000},
    {"oldstub.c",  0x00020000},
    {"rundown.c",  0x00040000},
    {"samifree.c", 0x00080000},
    {"samrpc_s.c", 0x00100000},
    {"samss.c",    0x00200000},
    {"secdescr.c", 0x00400000},
    {"security.c", 0x00800000},
    {"server.c",   0x01000000},
    {"string.c",   0x02000000},
    {"upgrade.c",  0x04000000},
    {"user.c",     0x08000000},
    {"utility.c",  0x10000000}
};

//
// Tick Stack. This is a stack of tick counts, used to time
// calls when SamTraceTicks is enabled. Define variables and
// macros 
//

#define MAX_TICK_STACK_SIZE     32
ULONG   TickStack[MAX_TICK_STACK_SIZE];
int     TickStackPointer=0;

#define PUSH_TICK_STACK(x)\
        {\
           TickStack[TickStackPointer++]=x;\
           if (TickStackPointer>=MAX_TICK_STACK_SIZE)\
           {\
                TickStackPointer = MAX_TICK_STACK_SIZE-1;\
           }\
        }

#define POP_TICK_STACK()    (TickStack[(TickStackPointer>0)?(--TickStackPointer):0])


LPSTR
GetBaseFileName(
    LPSTR   FileName
    )
/*

  Routine Description:

    This routine removes the path components from the filename

  Arguments:

    FileName - Full File Name

  Return Values

    LPSTR giving just the base file name

*/
{
    LPSTR BaseFileName = FileName;

    if (NULL!=FileName)
    {
        while(0!=*FileName)
        {
            if ('\\'==*FileName)
                BaseFileName= FileName +1;
            FileName ++;
        }
    }

    return BaseFileName;
}


BOOLEAN
SamIsTraceEnabled(
    IN LPSTR FileName,
    IN ULONG TraceLevel
    )
/*

  Routine Description:

    This routine checks wether tracing is enabled
    on a per file name basis.

        This routine uses the Global variable SamTraceLevel
        to check wether or not Tracing is enabled. The Trace
        Table defines the bit that is used to check for tracing
        on that file.

  Parameters:

     FileName -- The filename to check wether tracing is
                 enabled.

     Trace level -- Trace level with which trace was requested

  Return Values

    TRUE - Tracing is enabled
    FALSE - Tracing is disabled
*/
{
    ULONG Index;
    BOOLEAN RetValue = FALSE;
    LPSTR   BaseFileName;


    if ( TraceLevel & SampTraceTag & (~SAM_TRACE_FILE_BASIS))
    {
        //
        // Non file based tracing succeeds
        //

        RetValue = TRUE;
    }
    else if ( TraceLevel & SampTraceTag & SAM_TRACE_FILE_BASIS )
    {

        //
        // Use the Trace Flag to find out if all functions need to br
        // Traced
        //

	BaseFileName = GetBaseFileName(FileName);

        for (Index=0;Index<ARRAY_COUNT(TraceTable);Index++)
        {
            if ((NULL != BaseFileName) && 
                (0==(_stricmp(BaseFileName,TraceTable[Index].FileName))))
            {
                //
                // We have met match
                //

                if (SampTraceFileTag & (TraceTable[Index].TraceBit))
                {
                    //
                    // Tracing is enabled
                    //

                    RetValue = TRUE;
                }
            }
        }
    }

    return RetValue;
}

//
// The following are the tracing routines. Each routine checks whether 
// tracing is enabled and then calls a worker routine ( named xxxActual)
// that will do the actual debug output. This is so that no stack space is
// allocated for the debug buffer when no tracing is enabled. 
//


VOID
SamIDebugOutputActual(
    IN LPSTR FileName,
    IN LPSTR DebugMessage,
    IN ULONG TraceLevel
    )

/*++

Routine Description:

    This routine displays a message on the debugger.
    The File Name paramter is used to check wether tracing
    id enabled for the given File.

Parameters:

    FileName - Pointer to the name of the file
    DebugMessage - Pointer to the message string.
    TraceLevel   - Trace level at which trace needs to emerge

Return Values:

    None.

--*/

{
    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE, "[SAMSS] %-30s", DebugMessage);
    OutputDebugStringA(Buffer);

    if (SampTraceTag & SAM_TRACE_TICKS)
    {
        //
        // Control what may be measuerd
        //

        if (TraceLevel & (SAM_TRACE_DS | SAM_TRACE_EXPORTS))
        {
            ULONG   CurrentTick = GetTickCount();

            PUSH_TICK_STACK(CurrentTick);
        }
    }
        
}


VOID
SamIDebugOutput(
    IN LPSTR FileName,
    IN LPSTR DebugMessage,
    IN ULONG TraceLevel
    )

{
    if (SamIsTraceEnabled(FileName, TraceLevel))
    {
        SamIDebugOutputActual(
            FileName,
            DebugMessage,
            TraceLevel
            );
    }
}



VOID
SamIDebugFileLineOutputActual(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN ULONG TraceLevel
    )
{

    CHAR Buffer[DBG_BUFFER_SIZE];
    
    _snprintf(Buffer,DBG_BUFFER_SIZE, "[File = %s Line = %lu]\n", FileName, LineNumber);
    OutputDebugStringA(Buffer);
   
}


VOID
SamIDebugFileLineOutput(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN ULONG TraceLevel
    )

{
    if (SamIsTraceEnabled(FileName, TraceLevel))
    {
        SamIDebugFileLineOutputActual(
            FileName,
            LineNumber,
            TraceLevel
            );
    }
}


VOID
SamIDebugOutputReturnCodeActual(
    IN  LPSTR   FileName,
    IN  ULONG   ReturnCode,
    IN  ULONG   TraceLevel
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];
   
    if (SampTraceTag & SAM_TRACE_TICKS)
    {
        ULONG   CurrentTickCount = GetTickCount();
        ULONG   TicksConsumed = CurrentTickCount-POP_TICK_STACK();

        _snprintf(Buffer,DBG_BUFFER_SIZE, "[SAMSS] Returned %x, Ticks= %d", ReturnCode,TicksConsumed);
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE, "[SAMSS] Returned %x", ReturnCode);
    }

    OutputDebugStringA(Buffer);
}


VOID
SamIDebugOutputReturnCode(
    IN LPSTR FileName,
    IN ULONG ReturnCode,
    IN ULONG TraceLevel
    )

{
    if (SamIsTraceEnabled(FileName, TraceLevel))
    {
        SamIDebugOutputReturnCodeActual(
            FileName,
            ReturnCode,
            TraceLevel
            );
    }
}


VOID
wcstombsp(
    IN LPSTR Destination,
    IN LPWSTR Source,
    IN ULONG Size
    )
{
    ULONG Index;

    for (Index = 0; Index < Size; Index++)
    {
        if (Source[Index] != L'\0')
        {
            Destination[Index] = (CHAR)(Source[Index]);
        }
    }
    Destination[Size] = '\0';
}


VOID
SampDumpBinaryData(
    PBYTE   pData,
    DWORD   cbData
    )
{
    DWORD i;
    BYTE AsciiLine[16];
    BYTE BinaryLine[16];
    CHAR Buffer[DBG_BUFFER_SIZE];

    if (0 == cbData)
    {
        OutputDebugStringA("Zero-Length Data\n");
        return;
    }

    if (cbData > DBG_BUFFER_SIZE)
    {
        OutputDebugStringA("ShowBinaryData - truncating display to 256 bytes\n");
        cbData = 256;
    }

    for (; cbData > 0 ;)
    {
        for (i = 0; i < 16 && cbData > 0 ; i++, cbData--)
        {
            BinaryLine[i] = *pData;
            (isprint(*pData)) ? (AsciiLine[i] = *pData) : (AsciiLine[i] = '.');
            pData++;
        }

        if (i < 15)
        {
            for (; i < 16 ; i++)
            {
                BinaryLine[i] = ' ';
                AsciiLine[i] = ' ';
            }
        }

        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%02x %02x %02x %02x %02x %02x %02x %02x - %02x %02x %02x %02x %02x %02x %02x %02x\t",
                BinaryLine[0],
                BinaryLine[1],
                BinaryLine[2],
                BinaryLine[3],
                BinaryLine[4],
                BinaryLine[5],
                BinaryLine[6],
                BinaryLine[7],
                BinaryLine[8],
                BinaryLine[9],
                BinaryLine[10],
                BinaryLine[11],
                BinaryLine[12],
                BinaryLine[13],
                BinaryLine[14],
                BinaryLine[15]);

        OutputDebugStringA(Buffer);

        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%c%c%c%c%c%c%c%c - %c%c%c%c%c%c%c%c\n",
                AsciiLine[0],
                AsciiLine[1],
                AsciiLine[2],
                AsciiLine[3],
                AsciiLine[4],
                AsciiLine[5],
                AsciiLine[6],
                AsciiLine[7],
                AsciiLine[8],
                AsciiLine[9],
                AsciiLine[10],
                AsciiLine[11],
                AsciiLine[12],
                AsciiLine[13],
                AsciiLine[14],
                AsciiLine[15]);

        OutputDebugStringA(Buffer);
    }
}


//
// Set Value Key Routines
//

VOID
SamIDumpNtSetValueKey(
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];

    if (NULL != ValueName)
    {
        ANSI_STRING AnsiString;

        RtlUnicodeStringToAnsiString(&AnsiString,
                                     ValueName,
                                     TRUE);

        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%s\n%-30s = %s\n",
                "Set Value Key:",
                "ValueName",
                AnsiString.Buffer);

        RtlFreeAnsiString(&AnsiString);
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%s\n%-30s = %s\n",
                "Set Value Key:",
                "ValueName",
                NULL);
    }

    OutputDebugStringA(Buffer);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n",
            "TitleIndex",
            TitleIndex);

    OutputDebugStringA(Buffer);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n",
            "Type",
            Type);

    OutputDebugStringA(Buffer);

    if (NULL != Data)
    {
        // BUG: Need a display routine for the data.

        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n",
                "Data",
                "BINARY DATA");
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n",
                "Data",
                NULL);
    }

    OutputDebugStringA(Buffer);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n\n",
            "DataSize",
            DataSize);

    OutputDebugStringA(Buffer);
}


VOID
SamIDumpRtlpNtSetValueKey(
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %lu\n",
            "Set Value Key:",
            "Type",
            Type);

    OutputDebugStringA(Buffer);

    if (NULL != Data)
    {
        // BUG: Need a display routine for the data.

        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n",
                "Data",
                "ARRAY OF ULONG");
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n",
                "Data",
                NULL);
    }

    OutputDebugStringA(Buffer);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n\n",
            "DataSize",
            DataSize);

    OutputDebugStringA(Buffer);
}


//
// Query Routines
//

VOID
SamIDumpNtQueryKey(
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    IN PVOID KeyInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];

    // This routine dumps the parameters after returning from the NtQueryKey
    // routine. The KeyInformation is a PVOID buffer that is mapped to one of
    // the KeyInformationClass structures. The case-label values correspond
    // to the values in the KEY_INFORMATION_CLASS enum. Note that the Length
    // parameter is used to specify the buffer length. This is done because
    // the data-length member inside each structure seems to always be set to
    // zero--why?

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %lu\n",
            "Query Key:",
            "KeyInformationClass",
            KeyInformationClass);

    OutputDebugStringA(Buffer);

    if (NULL != KeyInformation)
    {
        CHAR BufferTmp[DBG_BUFFER_SIZE];
        PKEY_BASIC_INFORMATION KeyBasicInformation;
        PKEY_FULL_INFORMATION KeyFullInformation;
        PKEY_NODE_INFORMATION KeyNodeInformation;

        switch(KeyInformationClass)
        {
        case 0: // KeyBasicInformation
            // Basic information's Name member is an array of WCHAR.
            KeyBasicInformation = KeyInformation;
            wcstombsp(BufferTmp,
                     KeyBasicInformation->Name,
                     wcslen(KeyBasicInformation->Name));
            _snprintf(Buffer,DBG_BUFFER_SIZE,
                    "%s\n%-30s = 0x%lx:0x%lx\n%-30s = %lu\n%-30s = %lu\n%-30s\n%-30s\n",
                    "KeyInformation:",
                    "LastWriteTime",
                    KeyBasicInformation->LastWriteTime.HighPart,
                    KeyBasicInformation->LastWriteTime.LowPart,
                    "TitleIndex",
                    KeyBasicInformation->TitleIndex,
                    "NameLength",
                    KeyBasicInformation->NameLength,
                    "Name",
                    // BufferTmp);
                    "BINARY DATA FOLLOWS:");

            // Displaying the data as an LPWSTR doesn't work, so just dump the
            // bytes.

            OutputDebugStringA(Buffer);

            SampDumpBinaryData((PBYTE)KeyBasicInformation->Name,
                               // KeyBasicInformation->NameLength);
                               Length);

            break;

        case 1: // KeyNodeInformation
            // Node information's Name member is an array of WCHAR.
            KeyNodeInformation = KeyInformation;
            wcstombsp(BufferTmp,
                      (LPWSTR)KeyNodeInformation->Name,
                      wcslen((LPWSTR)KeyNodeInformation->Name));
            _snprintf(Buffer,DBG_BUFFER_SIZE,
                    "%s\n%-30s = 0x%lx:0x%lx\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %s\n",
                    "KeyInformation:",
                    "LastWriteTime",
                    KeyNodeInformation->LastWriteTime.HighPart,
                    KeyNodeInformation->LastWriteTime.LowPart,
                    "TitleIndex",
                    KeyNodeInformation->TitleIndex,
                    "ClassOffset",
                    KeyNodeInformation->ClassOffset,
                    "ClassLength",
                    KeyNodeInformation->ClassLength,
                    "NameLength",
                    KeyNodeInformation->NameLength,
                    "Name",
                    // BufferTmp);
                    "BINARY DATA FOLLOWS:");

            // Displaying the data as an LPWSTR doesn't work, so just dump the
            // bytes.

            OutputDebugStringA(Buffer);

            SampDumpBinaryData((PBYTE)KeyNodeInformation->Name,
                               // KeyNodeInformation->NameLength);
                               Length);

            break;

        case 2: // KeyFullInformation

            KeyFullInformation = KeyInformation;

            // Full information's Class member is an array of WCHAR.

            // wcstombsp(BufferTmp,
            //          KeyFullInformation->Class,
            //          wcslen(KeyFullInformation->Class));

            _snprintf(Buffer,DBG_BUFFER_SIZE,
                    "%s\n%-30s = 0x%lx:0x%lx\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %s\n",
                    "KeyInformation:",
                    "LastWriteTime",
                    KeyFullInformation->LastWriteTime.HighPart,
                    KeyFullInformation->LastWriteTime.LowPart,
                    "TitleIndex",
                    KeyFullInformation->TitleIndex,
                    "ClassOffset",
                    KeyFullInformation->ClassOffset,
                    "ClassLength",
                    KeyFullInformation->ClassLength,
                    "SubKeys",
                    KeyFullInformation->SubKeys,
                    "MaxNameLen",
                    KeyFullInformation->MaxNameLen,
                    "MaxClassLen",
                    KeyFullInformation->MaxClassLen,
                    "Values",
                    KeyFullInformation->Values,
                    "MaxValueNameLen",
                    KeyFullInformation->MaxValueNameLen,
                    "MaxValueDataLen",
                    KeyFullInformation->MaxValueDataLen,
                    "Class",
                    // BufferTmp);
                    "BINARY DATA FOLLOWS:");

            // Displaying the data as an LPWSTR doesn't work, so just dump the
            // bytes.

            OutputDebugStringA(Buffer);

            SampDumpBinaryData((PBYTE)KeyFullInformation->Class,
                               // KeyFullInformation->ClassLength);
                               Length);

            break;

        default:
            break;
        }
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n",
                "KeyInformation",
                NULL);

        OutputDebugStringA(Buffer);
    }

    // OutputDebugStringA(Buffer);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n",
            "Length",
            Length);

    OutputDebugStringA(Buffer);

    if (NULL != ResultLength)
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %lu\n\n",
                "ResultLength",
                *ResultLength);
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n\n",
                "ResultLength",
                NULL);
    }

    OutputDebugStringA(Buffer);
}


VOID
SamIDumpNtQueryValueKey(
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];

    // This routine dumps the parameters after returning from NtQueryValueKey
    // routine. The KeyValueInformation is a PVOID buffer that is mapped to
    // one of the KeyInformationClass structures. The case-label values corre-
    // spond to the values in the KEY_VALUE_INFORMATION_CLASS enum.

    if (NULL != ValueName)
    {
        ANSI_STRING AnsiString;

        RtlUnicodeStringToAnsiString(&AnsiString,
                                     ValueName,
                                     TRUE);

        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%s\n%-30s = %s\n",
                "Query Value Key:",
                "ValueName",
                AnsiString.Buffer);

        RtlFreeAnsiString(&AnsiString);
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%s\n%-30s = %s\n",
                "Query Value Key:",
                "ValueName",
                NULL);
    }

    OutputDebugStringA(Buffer);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n",
            "KeyValueInformationClass",
            KeyValueInformationClass);

    OutputDebugStringA(Buffer);

    if (NULL != KeyValueInformation)
    {
        CHAR BufferTmp[DBG_BUFFER_SIZE];
        PKEY_VALUE_BASIC_INFORMATION KeyValueBasicInformation;
        PKEY_VALUE_FULL_INFORMATION KeyValueFullInformation;
        PKEY_VALUE_PARTIAL_INFORMATION KeyValuePartialInformation;

        switch(KeyValueInformationClass)
        {
        case 0: // KeyValueBasicInformation
            // Basic information's Name member is an array of WCHAR.
            KeyValueBasicInformation = KeyValueInformation;
            wcstombsp(BufferTmp,
                     KeyValueBasicInformation->Name,
                     wcslen(KeyValueBasicInformation->Name));
            _snprintf(Buffer,DBG_BUFFER_SIZE,
                    "%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %s\n",
                    "TitleIndex",
                    KeyValueBasicInformation->TitleIndex,
                    "Type",
                    KeyValueBasicInformation->Type,
                    "NameLength",
                    KeyValueBasicInformation->NameLength,
                    "Name",
                    //BufferTmp);
                    "BINARY DATA FOLLOWS:");

            // Displaying the data as an LPWSTR doesn't work, so just dump the
            // bytes.

            OutputDebugStringA(Buffer);
            SampDumpBinaryData((PBYTE)KeyValueBasicInformation->Name,
                               KeyValueBasicInformation->NameLength);
            break;

        case 1: // KeyValueFullInformation
            // Full information's Name member is an array of WCHAR.
            KeyValueFullInformation = KeyValueInformation;
            wcstombsp(BufferTmp,
                     KeyValueFullInformation->Name,
                     wcslen(KeyValueFullInformation->Name));
            _snprintf(Buffer,DBG_BUFFER_SIZE,
                    "%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %s\n",
                    "TitleIndex",
                    KeyValueFullInformation->TitleIndex,
                    "Type",
                    KeyValueFullInformation->Type,
                    "DataOffset",
                    KeyValueFullInformation->DataOffset,
                    "DataLength",
                    KeyValueFullInformation->DataLength,
                    "NameLength",
                    KeyValueFullInformation->NameLength,
                    "Name",
                    //BufferTmp);
                    "BINARY DATA FOLLOWS:");

            // Displaying the data as an LPWSTR doesn't work, so just dump the
            // bytes.

            OutputDebugStringA(Buffer);
            SampDumpBinaryData((PBYTE)KeyValueFullInformation->Name,
                               KeyValueFullInformation->NameLength);
            break;

        case 2: // KeyValuePartialInformation

            KeyValuePartialInformation = KeyValueInformation;

            // Partial information's Data member is an array of UCHAR.

            _snprintf(Buffer,DBG_BUFFER_SIZE,
                    "%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %s\n",
                    "TitleIndex",
                    KeyValuePartialInformation->TitleIndex,
                    "Type",
                    KeyValuePartialInformation->Type,
                    "DataLength",
                    KeyValuePartialInformation->DataLength,
                    "Data",
                    // KeyValuePartialInformation->Data);
                    "BINARY DATA FOLLOWS:");

            OutputDebugStringA(Buffer);

            // First, dump the buffer as a raw byte stream.

            SampDumpBinaryData(KeyValuePartialInformation->Data,
                               KeyValuePartialInformation->DataLength);

            // Then, determine object type and dump the data in SAM struct
            // format.

            switch(KeyValuePartialInformation->Type)
            {

            case 0: // Server Object
                break;

            case 1: // Domain Object
                break;

            case 2: // Group Object
                break;

            case 3: // Alias Object

                // Dump the alias object's fixed attributes.

                // BUG: What about Basic and Full information?

                // SampDumpPSAMP_V1_FIXED_LENGTH_ALIAS(
                //     KeyValuePartialInformation->Data,
                //     0);

                // Dump the alias object's variable attribute array.

                //SampDumpAliasVariableAttributeArray(
                //    KeyValuePartialInformation->Data);

                // Dump the alias object's Variable attributes.


                break;

            case 4: // User Object
                break;

            default: // Unknown Object
                break;

            }

            break;

        default:
            break;
        }
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n",
                "KeyValueInformation",
                NULL);

        OutputDebugStringA(Buffer);
    }

    // OutputDebugStringA(Buffer);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n",
            "Length",
            Length);

    OutputDebugStringA(Buffer);

    if (NULL != ResultLength)
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %lu\n\n",
                "ResultLength",
                *ResultLength);
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n\n",
                "ResultLength",
                NULL);
    }

    OutputDebugStringA(Buffer);
}


VOID
SamIDumpRtlpNtQueryValueKey(
    IN PULONG KeyValueType,
    IN PVOID KeyValue,
    IN PULONG KeyValueLength,
    IN PLARGE_INTEGER LastWriteTime
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];

    if (NULL != KeyValueType)
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%s\n%-30s = 0x%lx\n",
                "Query Value Key:",
                "KeyValueType",
                *KeyValueType);
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%s\n%-30s = %s\n",
                "Query Value Key:",
                "KeyValueType",
                NULL);
    }

    OutputDebugStringA(Buffer);

    if (NULL != KeyValue)
    {
        SampDumpBinaryData((PBYTE)KeyValue, *KeyValueLength);
        OutputDebugStringA("\n");
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n",
                "KeyValue",
                NULL);
    }

    OutputDebugStringA(Buffer);

    if (NULL != KeyValueLength)
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %lu\n",
                "KeyValueLength",
                *KeyValueLength);
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n",
                "KeyValueLength",
                NULL);
    }

    OutputDebugStringA(Buffer);

    if (NULL != LastWriteTime)
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = 0x%lx:0x%lx\n\n",
                "LastWriteTime",
                LastWriteTime->HighPart,
                LastWriteTime->LowPart);
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n\n",
                "LastWriteTime",
                NULL);
    }

    OutputDebugStringA(Buffer);
}


//
// Enumeration Routines
//

VOID
SamIDumpNtEnumerateKey(
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %lu\n",
            "Enumerate Key:",
            "Index",
            Index);

    OutputDebugStringA(Buffer);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n",
            "KeyValueInformationClass",
            KeyValueInformationClass);

    OutputDebugStringA(Buffer);

    if (NULL != KeyValueInformation)
    {
        CHAR BufferTmp[DBG_BUFFER_SIZE];
        PKEY_VALUE_BASIC_INFORMATION KeyValueBasicInformation;
        PKEY_VALUE_FULL_INFORMATION KeyValueFullInformation;
        PKEY_VALUE_PARTIAL_INFORMATION KeyValuePartialInformation;

        switch(KeyValueInformationClass)
        {
        case 0: // KeyValueBasicInformation
            // Full information's Name member is an array of WCHAR.
            KeyValueBasicInformation = KeyValueInformation;
            wcstombsp(BufferTmp,
                     KeyValueBasicInformation->Name,
                     wcslen(KeyValueBasicInformation->Name));
            _snprintf(Buffer,DBG_BUFFER_SIZE,
                    "%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %s\n",
                    "TitleIndex",
                    KeyValueBasicInformation->TitleIndex,
                    "Type",
                    KeyValueBasicInformation->Type,
                    "NameLength",
                    KeyValueBasicInformation->NameLength,
                    "Name",
                    BufferTmp);
            break;

        case 1: // KeyValueFullInformation
            // Full information's Name member is an array of WCHAR.
            KeyValueFullInformation = KeyValueInformation;
            wcstombsp(BufferTmp,
                     KeyValueFullInformation->Name,
                     wcslen(KeyValueFullInformation->Name));
            _snprintf(Buffer,DBG_BUFFER_SIZE,
                    "%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %s\n",
                    "TitleIndex",
                    KeyValueFullInformation->TitleIndex,
                    "Type",
                    KeyValueFullInformation->Type,
                    "DataOffset",
                    KeyValueFullInformation->DataOffset,
                    "DataLength",
                    KeyValueFullInformation->DataLength,
                    "NameLength",
                    KeyValueFullInformation->NameLength,
                    "Name",
                    BufferTmp);
            break;

        case 2: // KeyValuePartialInformation
            // Partial information's Data member is an array of UCHAR.
            KeyValuePartialInformation = KeyValueInformation;

            // BUG: Need a display routine for the data.

            _snprintf(Buffer,DBG_BUFFER_SIZE,
                    "%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %s\n",
                    "TitleIndex",
                    KeyValuePartialInformation->TitleIndex,
                    "Type",
                    KeyValuePartialInformation->Type,
                    "DataLength",
                    KeyValuePartialInformation->DataLength,
                    "Data",
                    // KeyValuePartialInformation->Data);
                    "BINARY DATA FOLLOWS:");
            OutputDebugStringA(Buffer);
            SampDumpBinaryData(KeyValuePartialInformation->Data,
                               KeyValuePartialInformation->DataLength);
            break;

        default:
            break;
        }
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n",
                "KeyValueInformation",
                NULL);

        OutputDebugStringA(Buffer);
    }

    // OutputDebugStringA(Buffer);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n",
            "Length",
            Length);

    OutputDebugStringA(Buffer);

    if (NULL != ResultLength)
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %lu\n\n",
                "ResultLength",
                *ResultLength);
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%-30s = %s\n\n",
                "ResultLength",
                NULL);
    }

    OutputDebugStringA(Buffer);
}


VOID
SamIDumpRtlpNtEnumerateSubKey(
    IN PUNICODE_STRING SubKeyName,
    IN PSAM_ENUMERATE_HANDLE Index,
    IN LARGE_INTEGER LastWriteTime
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];
    ANSI_STRING AnsiString;

    RtlUnicodeStringToAnsiString(&AnsiString,
                                 SubKeyName,
                                 TRUE);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %s\n%-30s = %lu\n%-30s = 0x%lx:0x%lx\n\n",
            "Enumerate SubKey:",
            "SubKeyName",
            AnsiString.Buffer,
            "Index",
            *Index,
            "LastWriteTime",
            LastWriteTime.HighPart,
            LastWriteTime.LowPart);

    OutputDebugStringA(Buffer);

    RtlFreeAnsiString(&AnsiString);
}


//
// Security Descriptor Component Routines
//

VOID
SampDumpSecurityDescriptorSubAuthority(
    IN UCHAR SubAuthorityCount,
    IN ULONG SubAuthority[]
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];
    INT Count = (INT)SubAuthorityCount;
    INT Index = 0;

    for (Index = 0; Index < Count; Index++)
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%s\n%-30s = %lu\n",
                "SubAuthority:",
                "SubAuthority Element",
                SubAuthority[Index]);
    }

    OutputDebugStringA(Buffer);
}


VOID
SampDumpSecurityDescriptorOwner(
    IN PISID Owner
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %du\n%-30s = %du\n%-30s = %du%du%du%du%du%du\n",
            "Owner:",
            "Revision",
            Owner->Revision,
            "SubAuthorityCount",
            Owner->SubAuthorityCount,
            "IdentifierAuthority",
            Owner->IdentifierAuthority.Value[0],
            Owner->IdentifierAuthority.Value[1],
            Owner->IdentifierAuthority.Value[2],
            Owner->IdentifierAuthority.Value[3],
            Owner->IdentifierAuthority.Value[4],
            Owner->IdentifierAuthority.Value[5]);

    OutputDebugStringA(Buffer);

    SampDumpSecurityDescriptorSubAuthority(Owner->SubAuthorityCount,
                                           Owner->SubAuthority);
}


VOID
SampDumpSecurityDescriptorGroup(
    IN PISID Group
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %du\n%-30s = %du\n%-30s = %du%du%du%du%du%du\n",
            "Group:",
            "Revision",
            Group->Revision,
            "SubAuthorityCount",
            Group->SubAuthorityCount,
            "IdentifierAuthority",
            Group->IdentifierAuthority.Value[0],
            Group->IdentifierAuthority.Value[1],
            Group->IdentifierAuthority.Value[2],
            Group->IdentifierAuthority.Value[3],
            Group->IdentifierAuthority.Value[4],
            Group->IdentifierAuthority.Value[5]);

    OutputDebugStringA(Buffer);

    SampDumpSecurityDescriptorSubAuthority(Group->SubAuthorityCount,
                                           Group->SubAuthority);
}


//
// ACL Routines
//

VOID
SampDumpAcl(
    IN PACL Acl
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %du\n%-30s = %du\n%-30s = %du\n%-30s = %du\n%-30s = %du\n",
            "Acl:",
            "AclRevision",
            Acl->AclRevision,
            "Sbz1",
            Acl->Sbz1,
            "ACL Size",
            Acl->AclSize,
            "ACE Count",
            Acl->AceCount,
            "Sbz2",
            Acl->Sbz2);

    OutputDebugStringA(Buffer);
}


//
// Security Descriptor Routines
//

VOID
SampDumpSecurityDescriptor(
    IN PISECURITY_DESCRIPTOR SecurityDescriptor
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];

    if (NULL != SecurityDescriptor)
    {
        // Note that the SECURITY_DESCRIPTOR is intended to be treated as an
        // opaque blob so that future changes are compatible with previous
        // versions.

        // Revision is actually represented as a UCHAR, but it is displayed as
        // a "du" in this routine.

        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%s\n%-30s = %du\n%-30s = %du\n%-30s = %du\n",
                "SecurityDescriptor:",
                "Revision",
                SecurityDescriptor->Revision,
                "Sbz1",
                SecurityDescriptor->Sbz1,
                "Control",
                SecurityDescriptor->Control);

        OutputDebugStringA(Buffer);

        SampDumpSecurityDescriptorOwner(SecurityDescriptor->Owner);
        SampDumpSecurityDescriptorGroup(SecurityDescriptor->Group);
        SampDumpAcl(SecurityDescriptor->Sacl);
        SampDumpAcl(SecurityDescriptor->Dacl);
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE, "%-30s = %s\n", "SecurityDescriptor:", NULL);
        OutputDebugStringA(Buffer);
    }

}


//
// Quality Of Service Routines
//

VOID
SampDumpSecurityQualityOfService(
    IN PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];

    if (NULL != SecurityQualityOfService)
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE,
                "%s\n%-30s = %lu\n%-30s = %du\n%-30s = %du\n%-30s = %du\n",
                "SecurityQualityOfService:",
                "Length",
                SecurityQualityOfService->Length,
                "ImpersonationLevel",
                SecurityQualityOfService->ImpersonationLevel,
                "ContextTrackingMode",
                SecurityQualityOfService->ContextTrackingMode,
                "EffectiveOnly",
                SecurityQualityOfService->EffectiveOnly);
    }
    else
    {
        _snprintf(Buffer,DBG_BUFFER_SIZE, "%-30s = %s\n", "SecurityQualityOfService:", NULL);
    }

    OutputDebugStringA(Buffer);
}


//
// Object Attribute Routines
//

VOID
SampDumpObjectAttributes(
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];
    ANSI_STRING AnsiString;

    RtlUnicodeStringToAnsiString(&AnsiString,
                                 ObjectAttributes->ObjectName,
                                 TRUE);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %lu\n%-30s = %p\n%-30s = %s\n%-30s = 0x%lx\n",
            "ObjectAttributes:",
            "Length",
            ObjectAttributes->Length,
            "RootDirectory Handle",
            ObjectAttributes->RootDirectory,
            "ObjectName",
            AnsiString.Buffer,
            "Attributes",
            ObjectAttributes->Attributes);

    OutputDebugStringA(Buffer);

    RtlFreeAnsiString(&AnsiString);

    SampDumpSecurityDescriptor(ObjectAttributes->SecurityDescriptor);
    SampDumpSecurityQualityOfService(ObjectAttributes->SecurityQualityOfService);
}


//
// Open Key Routines
//

VOID
SamIDumpNtOpenKey(
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG Options
    )
{

    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = 0x%lx\n%-30s = 0x%lx\n",
            "Open Registry Key:",
            "DesiredAccess",
            DesiredAccess,
            "Options",
            Options);

    OutputDebugStringA(Buffer);

    SampDumpObjectAttributes(ObjectAttributes);

    OutputDebugStringA("\n");
}


//
// V1_0A Routines
//

VOID
SampDumpPSAMP_V1_FIXED_LENGTH_SERVER(
    IN PVOID NewValue,
    IN ULONG NewValueLength
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];
    PSAMP_V1_FIXED_LENGTH_SERVER TempBuffer = NewValue;

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %lu\n",
            "SAMP_V1_FIXED_LENGTH_SERVER Buffer:",
            "RevisionLevel",
            TempBuffer->RevisionLevel);

    OutputDebugStringA(Buffer);

    OutputDebugStringA("\n");
}


VOID
SampDumpPSAMP_V1_0A_FIXED_LENGTH_DOMAIN(
    IN PVOID NewValue,
    IN ULONG NewValueLength
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN TempBuffer = NewValue;

    _snprintf(Buffer,DBG_BUFFER_SIZE,

            "%s\n%-30s = %lu\n%-30s = %lu\n%-30s = %ul:%lu\n%-30s = %ul:%lu\n%-30s = %ul:%lu\n%-30s = %ul:%lu\n%-30s = %ul:%lu\n%-30s = %ul:%lu\n%-30s = %ul:%lu\n%-30s = %ul:%lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %du\n\
%-30s = %du\n%-30s = %du\n%-30s = %du\n%-30s = %du\n%-30s = %du\n\n",

            "SAMP_V1_OA_FIXED_LENGTH_DOMAIN Buffer:",

            "Revision",
            TempBuffer->Revision,

            "Unused1",
            TempBuffer->Unused1,

            "Creation Time",
            TempBuffer->CreationTime.HighPart,
            TempBuffer->CreationTime.LowPart,

            "Modified Count",
            TempBuffer->ModifiedCount.HighPart,
            TempBuffer->ModifiedCount.LowPart,

            "MaxPasswordAge",
            TempBuffer->MaxPasswordAge.HighPart,
            TempBuffer->MaxPasswordAge.LowPart,

            "MinPasswordAge",
            TempBuffer->MinPasswordAge.HighPart,
            TempBuffer->MinPasswordAge.LowPart,

            "ForceLogoff",
            TempBuffer->ForceLogoff.HighPart,
            TempBuffer->ForceLogoff.LowPart,

            "LockoutDuration",
            TempBuffer->LockoutDuration.HighPart,
            TempBuffer->LockoutDuration.LowPart,

            "LockoutObservationWindow",
            TempBuffer->LockoutObservationWindow.HighPart,
            TempBuffer->LockoutObservationWindow.LowPart,

            "ModifiedCountAtLastPromotion",
            TempBuffer->ModifiedCountAtLastPromotion.HighPart,
            TempBuffer->ModifiedCountAtLastPromotion.LowPart,

            "NextRid",
            TempBuffer->NextRid,

            "PasswordProperties",
            TempBuffer->PasswordProperties,

            "MinPasswordLength",
            TempBuffer->MinPasswordLength,

            "PasswordHistoryLength",
            TempBuffer->PasswordHistoryLength,

            "LockoutThreshold",
            TempBuffer->LockoutThreshold,

            "ServerState",
            TempBuffer->ServerState,

            "ServerRole",
            TempBuffer->ServerRole,

            "UasCompatibilityRequired",
            TempBuffer->UasCompatibilityRequired);

    OutputDebugStringA(Buffer);
}


//
// Variable Length Attribute Routines
//

VOID
SampDumpSAMP_VARIABLE_LENGTH_ATTRIBUTE(
    IN PVOID NewValue,
    IN ULONG NewValueLength
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];
    BYTE *TempBuffer = NewValue;


    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n\n",
            "NewValueLength",
            NewValueLength);

    OutputDebugStringA(Buffer);
}


//
// Fixed Length Attribute Routines
//

#if 0

VOID
SampDumpPSAMP_V1_FIXED_LENGTH_ALIAS(
    IN PVOID NewValue,
    IN ULONG NewValueLength
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];
    PSAMP_V1_FIXED_LENGTH_ALIAS TempBuffer = NewValue;

    // BUG: NewValueLength is unnecessary for this fixed length attribute.

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %lu\n\n",
            "SAMP_V1_FIXED_LENGTH_ALIAS Buffer:",
            "RelativeId",
            TempBuffer->RelativeId);

    OutputDebugStringA(Buffer);
}

#endif


VOID
SampDumpPSAMP_V1_0A_FIXED_LENGTH_GROUP(
    IN PVOID NewValue,
    IN ULONG NewValueLength
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];
    PSAMP_V1_FIXED_LENGTH_GROUP TempBuffer = NewValue;

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n\n",
            "SAMP_V1_OA_FIXED_LENGTH_GROUP Buffer:",
            "RelativeId",
            TempBuffer->RelativeId,
            "Attributes",
            TempBuffer->Attributes,
            "AdminGroup",
            TempBuffer->AdminGroup);

    OutputDebugStringA(Buffer);
}


VOID
SampDumpPSAMP_V1_0A_FIXED_LENGTH_USER(
    IN PVOID NewValue,
    IN ULONG NewValueLength
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];
    PSAMP_V1_0A_FIXED_LENGTH_USER TempBuffer = NewValue;

    _snprintf(Buffer,DBG_BUFFER_SIZE,

            "%s\n%-30s = %lu\n%-30s = %lu\n%-30s = %ul:%lu\n%-30s = %lu:%lu\n%-30s = %lu:%lu\n%-30s = %lu:%lu\n%-30s = %lu:%lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %du\n%-30s = %du\n\
%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n\n",

            "SAMP_V1_OA_FIXED_LENGTH_USER Buffer:",

            "Revision",
            TempBuffer->Revision,

            "Unused1",
            TempBuffer->Unused1,

            "LastLogon",
            TempBuffer->LastLogon.HighPart,
            TempBuffer->LastLogon.LowPart,

            "LastLogoff",
            TempBuffer->LastLogoff.HighPart,
            TempBuffer->LastLogoff.LowPart,

            "PasswordLastSet",
            TempBuffer->PasswordLastSet.HighPart,
            TempBuffer->PasswordLastSet.LowPart,

            "AccountExpires",
            TempBuffer->AccountExpires.HighPart,
            TempBuffer->AccountExpires.LowPart,

            "LastBadPasswordTime",
            TempBuffer->LastBadPasswordTime.HighPart,
            TempBuffer->LastBadPasswordTime.LowPart,

            "UserId",
            TempBuffer->UserId,

            "PrimaryGroupId",
            TempBuffer->PrimaryGroupId,

            "UserAccountControl",
            TempBuffer->UserAccountControl,

            "CountryCode",
            TempBuffer->CountryCode,

            "CodePage",
            TempBuffer->CodePage,

            "BadPasswordCount",
            TempBuffer->BadPasswordCount,

            "LogonCount",
            TempBuffer->LogonCount,

            "AdminCount",
            TempBuffer->AdminCount,

            "Unused2",
            TempBuffer->Unused2,

            "OperatorCount",
            TempBuffer->OperatorCount);

    OutputDebugStringA(Buffer);
}


VOID
SampDumpSampFixedBufferAddress(
    IN PVOID NewValue,
    IN ULONG NewValueLength
    )
{
    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %p\n%-30s = %lu\n%-30s = %s\n",
            "BufferAddress",
            NewValue,
            "BufferLength",
            NewValueLength,
            "Buffer",
            "BINARY DATA FOLLOWS:");

    OutputDebugStringA(Buffer);

    SampDumpBinaryData((PBYTE)NewValue, NewValueLength);
    OutputDebugStringA("\n");
}


VOID
SampDumpBuffer(
    IN PVOID BufferAddress,
    IN ULONG BufferLength
    )

/*++

Routine Description:

    This routine dumps the address and length of the attribute buffer.

Parameters:

    BufferAddress - self explanatory.

    BufferLength - self explanatory.

Return Values:

    None.

--*/

{
    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %p\n",
            "BufferAddress",
            BufferAddress);

    OutputDebugStringA(Buffer);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n",
            "BufferLength",
            BufferLength);

    OutputDebugStringA(Buffer);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %s\n\n",
            "Buffer Content",
            BufferAddress);

    OutputDebugStringA(Buffer);
}


//
// RXact Routines
//

VOID
SampDumpRXactLog(
    IN PRTL_RXACT_LOG TransactionLog
    )

/*++

Routine Description:

    This routine dumps a (registry) transaction log structure.

Parameters:

    TransactionLog - Pointer to the transaction log.

Return Values:

    None.

--*/

{
    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %lu\n%-30s = %lu\n%-30s = %lu\n",
            "Transaction Log:",
            "OperationCount",
            TransactionLog->OperationCount,
            "LogSize",
            TransactionLog->LogSize,
            "LogSizeInUse",
            TransactionLog->LogSizeInUse);

    OutputDebugStringA(Buffer);
}


VOID
SampDumpRXactContext(
    IN PRTL_RXACT_CONTEXT TransactionContext
    )

/*++

Routine Description:

    This routine dumps a (registry) transaction context.

Parameters:

    TransactionContext - Pointer to the transaction context.

Return Values:

    None.

--*/

{
    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%s\n%-30s = %p\n%-30s = %p\n%-30s = %d\n",
            "Transaction Context:",
            "RootRegistryKey Handle",
            TransactionContext->RootRegistryKey,
            "RXactKey Handle",
            TransactionContext->RXactKey,
            "HandlesValid",
            TransactionContext->HandlesValid);

    OutputDebugStringA(Buffer);

    SampDumpRXactLog(TransactionContext->RXactLog);
}


VOID
SampDumpRXactOperation(
    IN RTL_RXACT_OPERATION Operation
    )

/*++

Routine Description:

    This routine dumps an operation value.

Parameters:

    Operation - The operation value.

Return Values:

    None.

--*/

{
    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n",
            "Operation",
            Operation);

    OutputDebugStringA(Buffer);
}


VOID
SampDumpSubKeyNameAndKey(
    IN PUNICODE_STRING SubKeyName,
    IN HANDLE KeyHandle
    )

/*++

Routine Description:

    This routine dumps the registry root name and root-key handle value.

Parameters:

    SubKeyName - Pointer to a counted string that is the root name.

    KeyHandle - Handle of the registry's root key.

Return Values:

    None.

--*/

{
    CHAR Buffer[DBG_BUFFER_SIZE];
    ANSI_STRING AnsiString;

    RtlUnicodeStringToAnsiString(&AnsiString, SubKeyName, TRUE);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %s\n",
            "SubKeyName",
            AnsiString.Buffer);

    OutputDebugStringA(Buffer);

    RtlFreeAnsiString(&AnsiString);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %p\n",
            "KeyHandle",
            KeyHandle);

    OutputDebugStringA(Buffer);
}


VOID
SampDumpAttributeName(
    IN PUNICODE_STRING AttributeName
    )

/*++

Routine Description:

    This routine dumps a combined-attribute name.

Parameters:

    AttributeName - Pointer to the string containing the name.

Return Values:

    None.

--*/

{
    CHAR Buffer[DBG_BUFFER_SIZE];
    ANSI_STRING AnsiString;

    RtlUnicodeStringToAnsiString(&AnsiString, AttributeName, TRUE);

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %s\n",
            "AttributeName",
            AnsiString.Buffer);

    OutputDebugStringA(Buffer);

    RtlFreeAnsiString(&AnsiString);
}


VOID
SampDumpKeyType(
    IN ULONG RegistryKeyType
    )

/*++

Routine Description:

    This routine dumps a registry key type.

Parameters:

    RegistryKeyType - self explanatory.

Return Values:

    None.

--*/

{
    CHAR Buffer[DBG_BUFFER_SIZE];

    _snprintf(Buffer,DBG_BUFFER_SIZE,
            "%-30s = %lu\n",
            "RegistryKeyType",
            RegistryKeyType);

    OutputDebugStringA(Buffer);
}


VOID
SamIDumpRXact(
    IN PRTL_RXACT_CONTEXT TransactionContext,
    IN RTL_RXACT_OPERATION Operation,
    IN PUNICODE_STRING SubKeyName,
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING AttributeName,
    IN ULONG RegistryKeyType,
    IN PVOID NewValue,
    IN ULONG NewValueLength,
    IN ULONG NewValueType
    )

/*++

Routine Description:

    This routine dumps a (registry) transaction, just before the call to
    RtlAddAttributeActionToRXact.

Parameters:

    (See individual output routines above for the descriptions)

Return Values:

    None.

--*/

{
    SampDumpRXactContext(TransactionContext);
    SampDumpRXactOperation(Operation);
    SampDumpSubKeyNameAndKey(SubKeyName, KeyHandle);
    SampDumpAttributeName(AttributeName);
    SampDumpKeyType(RegistryKeyType);

    switch(NewValueType)
    {
    case FIXED_LENGTH_SERVER_FLAG:
        SampDumpPSAMP_V1_FIXED_LENGTH_SERVER(NewValue, NewValueLength);
        break;

    case FIXED_LENGTH_DOMAIN_FLAG:
        SampDumpPSAMP_V1_0A_FIXED_LENGTH_DOMAIN(NewValue, NewValueLength);
        break;

    case FIXED_LENGTH_ALIAS_FLAG:
        // SampDumpPSAMP_V1_FIXED_LENGTH_ALIAS(NewValue, NewValueLength);
        break;

    case FIXED_LENGTH_GROUP_FLAG:
        SampDumpPSAMP_V1_0A_FIXED_LENGTH_GROUP(NewValue, NewValueLength);
        break;

    case FIXED_LENGTH_USER_FLAG:
        SampDumpPSAMP_V1_0A_FIXED_LENGTH_USER(NewValue, NewValueLength);
        break;

    case VARIABLE_LENGTH_ATTRIBUTE_FLAG:
        SampDumpSAMP_VARIABLE_LENGTH_ATTRIBUTE(NewValue, NewValueLength);
        break;

    case FixedBufferAddressFlag:
        SampDumpSampFixedBufferAddress(NewValue, NewValueLength);
        break;

    default:
        SampDumpBuffer(NewValue, NewValueLength);
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\dsbackup.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dsbackup.c

Abstract:

    This file contains the thread fn to host the DS backup/restore
    interface.


Author:

    R.S. Raghavan    (rsraghav)  04/21/97

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <dslayer.h>
#include <ntdsbsrv.h>

#define RPC_SERVICE "rpcss"

ULONG
SampDSBackupRestoreInit(
    PVOID Ignored
    )
/*++

Routine Description:

    This routine waits for the RPCS service to start and then registers
    DS backup and restore RPC interfaces.

Arguments:

    Ignored - required parameter for starting a thread.

Return Value:

    None.

--*/
{

    HMODULE hModule;
    DWORD dwErr;

    FARPROC BackupRegister = NULL;
    FARPROC BackupUnregister = NULL;
    FARPROC RestoreRegister = NULL;
    FARPROC RestoreUnregister = NULL;
    FARPROC SetNTDSOnlineStatus = NULL;

    KdPrintEx((DPFLTR_SAMSS_ID,
               DPFLTR_INFO_LEVEL,
               "SAM:DSBACKUP: Entered SampDSBackupRestoreInit() thread function\n"));

    if (!DsaWaitUntilServiceIsRunning(RPC_SERVICE))
    {
        dwErr = GetLastError();
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM:DSBACKUP: DsaWaitUntilServerIsRunning(RPC_SERVICE) returned FALSE\n"));

        return dwErr;
    }

    KdPrintEx((DPFLTR_SAMSS_ID,
               DPFLTR_INFO_LEVEL,
               "SAM: DSBACKUP: RPCS service is running\n"));

    if (!(hModule = (HMODULE) LoadLibrary(NTDSBACKUPDLL)))
    {
        dwErr = GetLastError();
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM:DSBACKUP: LoadLibrary() of %s failed with error code %u\n",
                   NTDSBACKUPDLL,
                   dwErr));

        return dwErr;
    }


    BackupRegister = GetProcAddress(hModule, BACKUP_REGISTER_FN);
    BackupUnregister = GetProcAddress(hModule, BACKUP_UNREGISTER_FN);
    RestoreRegister = GetProcAddress(hModule, RESTORE_REGISTER_FN);
    RestoreUnregister = GetProcAddress(hModule, RESTORE_UNREGISTER_FN);
    SetNTDSOnlineStatus = GetProcAddress(hModule, SET_NTDS_ONLINE_STATUS_FN);

    if (!BackupRegister         ||
        !BackupUnregister       ||
        !RestoreRegister        ||
        !RestoreUnregister      ||
        !SetNTDSOnlineStatus)
    {
        dwErr = GetLastError();
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAM:DSBACKUP: GetProcAddress() failed with error code %u\n",
                   dwErr));

        return dwErr;
    }

    // set online status to distinguish between registry booting and DS booting
    SetNTDSOnlineStatus((BOOL) SampUsingDsData());

    // Register the backup and restore interfaces
    BackupRegister();
    RestoreRegister();

    KdPrintEx((DPFLTR_SAMSS_ID,
               DPFLTR_INFO_LEVEL,
               "SAM: DSBACKUP: DS Backup and restore interface registration successful!\n"));

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\display.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    display.c

Abstract:

    This file contains services for maintaining the cached display
    information.

    The information is stored in multiple tables because there are
    multiple formats it must be returned in.  The tables maintained
    include:

            AccountsByRid - includes all user and global group accounts
                by RID.  Aliases may be added to this list at some time
                in the future.

            NormalUsersByName - Normal user accounts, sorted by name.

            MachinesByName - Machine user accounts, sorted by name.

            InterDomainByName - Interdomain trust accounts, sorted by
                name.

            GroupsByName - Global group accounts, sorted by name.


    Any time an entry is placed in or removed from one of "ByName"
    tables, it is also placed in or removed from the "ByRid" table.

    User and machine accounts are added to the display cache in one
    operation.  So, there is a single boolean flag indicating whether
    or not these tables are valid.  The groups are maintained in a
    separate table, and so there is another flag indicating whether
    or not that table is valid.

    The Rid table is only valid if both the group table and the
    user/machine tables are valid.



Author:

    Dave Chalmers   (Davidc)  1-April-1992

Environment:

    User Mode - Win32

Revision History:

    Murlis 12/17/96 - Modified to not use display cache for DS.


--*/


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <dbgutilp.h>
#include <dsdsply.h>
#include <samtrace.h>



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SampCreateDisplayInformation (
    DOMAIN_DISPLAY_INFORMATION DisplayType
    );


VOID
SampDeleteDisplayInformation (
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    SAMP_OBJECT_TYPE ObjectType
    );

NTSTATUS
SampRetrieveDisplayInfoFromDisk(
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    SAMP_OBJECT_TYPE ObjectType
    );

NTSTATUS
SampAddDisplayAccount (
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    SAMP_OBJECT_TYPE ObjectType,
    PSAMP_ACCOUNT_DISPLAY_INFO AccountInfo
    );

NTSTATUS
SampDeleteDisplayAccount (
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    SAMP_OBJECT_TYPE ObjectType,
    PSAMP_ACCOUNT_DISPLAY_INFO AccountInfo
    );

NTSTATUS
SampUpdateDisplayAccount(
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    SAMP_OBJECT_TYPE ObjectType,
    PSAMP_ACCOUNT_DISPLAY_INFO  AccountInfo
    );

NTSTATUS
SampTallyTableStatistics (
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    SAMP_OBJECT_TYPE ObjectType
    );

NTSTATUS
SampEmptyGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    BOOLEAN FreeElements,
    SAMP_OBJECT_TYPE ObjectType OPTIONAL
    );

PVOID
SampGenericTable2Allocate (
    CLONG BufferSize
    );

VOID
SampGenericTable2Free (
    PVOID Buffer
    );

RTL_GENERIC_COMPARE_RESULTS
SampCompareUserNodeByName (
    PVOID Node1,
    PVOID Node2
    );

RTL_GENERIC_COMPARE_RESULTS
SampCompareMachineNodeByName (      // Also used for Interdomain trust accounts
    PVOID Node1,
    PVOID Node2
    );

RTL_GENERIC_COMPARE_RESULTS
SampCompareGroupNodeByName (
    PVOID Node1,
    PVOID Node2
    );

RTL_GENERIC_COMPARE_RESULTS
SampCompareNodeByRid (
    PVOID Node1,
    PVOID Node2
    );


VOID
SampSwapUserInfo(
    PDOMAIN_DISPLAY_USER Info1,
    PDOMAIN_DISPLAY_USER Info2
    );

VOID
SampSwapMachineInfo(            // Also used for Interdomain trust accounts
    PDOMAIN_DISPLAY_MACHINE Info1,
    PDOMAIN_DISPLAY_MACHINE Info2
    );

VOID
SampSwapGroupInfo(
    PDOMAIN_DISPLAY_GROUP Info1,
    PDOMAIN_DISPLAY_GROUP Info2
    );

ULONG
SampBytesRequiredUserNode (
    PDOMAIN_DISPLAY_USER Node
    );

ULONG
SampBytesRequiredMachineNode (  // Also used for Interdomain trust accounts
    PDOMAIN_DISPLAY_MACHINE Node
    );

ULONG
SampBytesRequiredGroupNode (
    PDOMAIN_DISPLAY_GROUP Node
    );

ULONG
SampBytesRequiredOemUserNode (
    PDOMAIN_DISPLAY_OEM_USER Node
    );

ULONG
SampBytesRequiredOemGroupNode (
    PDOMAIN_DISPLAY_OEM_GROUP Node
    );


VOID
SampDisplayDiagnostic( VOID );

VOID
SampDisplayDiagEnumRids( VOID );





//
// Macros for deciding whether an account is:
//
//      A normal user account
//
//      A machine account
//
//      An Interdomain trust account
//
//      Included in the display cache
//
//

#define USER_ACCOUNT(AccountControl) ((AccountControl & \
                                       (USER_NORMAL_ACCOUNT | \
                                       USER_TEMP_DUPLICATE_ACCOUNT)) != 0)

#define MACHINE_ACCOUNT(AccountControl) ((AccountControl & \
                                         (USER_WORKSTATION_TRUST_ACCOUNT | \
                                          USER_SERVER_TRUST_ACCOUNT)) != 0)


#define INTERDOMAIN_ACCOUNT(AccountControl) (((AccountControl) & \
                                   (USER_INTERDOMAIN_TRUST_ACCOUNT)) != 0)


#define DISPLAY_ACCOUNT(AccountControl) (USER_ACCOUNT(AccountControl)    || \
                                         MACHINE_ACCOUNT(AccountControl) || \
                                         INTERDOMAIN_ACCOUNT(AccountControl))



//
// Test to see if Rid table is valid
//
//  BOOLEAN
//  SampRidTableValid( IN ULONG DomainIndex )
//

#define SampRidTableValid(DI)  (  \
    (SampDefinedDomains[DI].DisplayInformation.UserAndMachineTablesValid) &&   \
    (SampDefinedDomains[DI].DisplayInformation.GroupTableValid)                \
    )



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private data types                                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


//
// All entries in the display cache are expected to start with this
// data structure.
//

typedef struct _SAMP_DISPLAY_ENTRY_HEADER {

    //
    // The index field plays two roles.  Within the generic table,
    // it is used to indicate which type of account this is.  The
    // valid types are: SAM_USER_ACCOUNT, SAM_GLOBAL_GROUP_ACCOUNT,
    // or SAM_LOCAL_GROUP_ACCOUNT.
    //
    // Otherwise, this field is filled in just before being returned
    // to query and other client calls.
    //


    ULONG           Index;


    //
    // The RID of the account
    //

    ULONG           Rid;

} SAMP_DISPLAY_ENTRY_HEADER, *PSAMP_DISPLAY_ENTRY_HEADER;


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Module-wide variables                                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


LCID  SampSystemDefaultLCID;



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// RPC exported routines                                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SamrQueryDisplayInformation (
    IN    SAMPR_HANDLE DomainHandle,
    IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    IN    ULONG      Index,
    IN    ULONG      EntriesRequested,
    IN    ULONG      PreferredMaximumLength,
    OUT   PULONG     TotalAvailable,
    OUT   PULONG     TotalReturned,
    OUT   PSAMPR_DISPLAY_INFO_BUFFER Buffer
    )

/*++

Routine Description:

    Thin wrapper around SamrQueryDisplayInformation3().

    Provided for compatibility with down-level clients.

--*/
{
    return( SamrQueryDisplayInformation3(
                    DomainHandle,
                    DisplayInformation,
                    Index,
                    EntriesRequested,
                    PreferredMaximumLength,
                    TotalAvailable,
                    TotalReturned,
                    Buffer
                    ) );
}

NTSTATUS
SamrQueryDisplayInformation2 (
    IN    SAMPR_HANDLE DomainHandle,
    IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    IN    ULONG      Index,
    IN    ULONG      EntriesRequested,
    IN    ULONG      PreferredMaximumLength,
    OUT   PULONG     TotalAvailable,
    OUT   PULONG     TotalReturned,
    OUT   PSAMPR_DISPLAY_INFO_BUFFER Buffer
    )

/*++

Routine Description:

    Thin wrapper around SamrQueryDisplayInformation3().

    Provided for compatibility with down-level clients.

--*/
{
    return( SamrQueryDisplayInformation3(
                    DomainHandle,
                    DisplayInformation,
                    Index,
                    EntriesRequested,
                    PreferredMaximumLength,
                    TotalAvailable,
                    TotalReturned,
                    Buffer
                    ) );
}

NTSTATUS
SamrQueryDisplayInformation3 (
    IN    SAMPR_HANDLE DomainHandle,
    IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    IN    ULONG      Index,
    IN    ULONG      EntriesRequested,
    IN    ULONG      PreferredMaximumLength,
    OUT   PULONG     TotalAvailable,
    OUT   PULONG     TotalReturned,
    OUT   PSAMPR_DISPLAY_INFO_BUFFER Buffer
    )

/*++

Routine Description:

    This routine provides fast return of information commonly
    needed to be displayed in user interfaces.

    NT User Interface has a requirement for quick enumeration of SAM
    accounts for display in list boxes.  (Replication has similar but
    broader requirements.)

    The netui listboxes all contain similar information.  e.g:

      o  AccountControl, the bits that identify the account type,
         eg, HOME, REMOTE, SERVER, WORKSTATION, etc.

      o  Logon name (machine name for computers)

      o  Full name (not used for computers)

      o  Comment (admin comment for users)

    SAM maintains this data locally in two sorted indexed cached
    lists identified by infolevels.

      o DomainDisplayUser:       HOME and REMOTE user accounts only

      o  DomainDisplayMachine:   SERVER and WORKSTATION accounts only

    Note that trust accounts, groups, and aliases are not in either of
    these lists.


    Added for NT1.0A -

        o Group enumeration has been added in NT1.0A
          with the following characteristic:

               We did not change the RPC interface ID.  This allows
               callers to continue to call down-level servers.  However,
               down-level servers will return an error if they passed
               this information level.

        o OEM string info levels were added for jimh (Chicago).  These
          info levels dramatically reduce the memory needed to query
          the limited information that Chicago is interested in.


Parameters:

    DomainHandle - A handle to an open domain for DOMAIN_LIST_ACCOUNTS.

    DisplayInformation - Indicates which information is to be enumerated.

    Index - The index of the first entry to be retrieved.

    PreferedMaximumLength - A recommended upper limit to the number of
        bytes to be returned.  The returned information is allocated by
        this routine.

    TotalAvailable - Total number of bytes availabe in the specified info
        class.

    TotalReturned - Number of bytes actually returned for this call.  Zero
        indicates there are no entries with an index as large as that
        specified.

    ReturnedEntryCount - Number of entries returned by this call.  Zero
        indicates there are no entries with an index as large as that
        specified.


    Buffer - Receives a pointer to a buffer containing a (possibly)
        sorted list of the requested information.  This buffer is
        allocated by this routine and contains the following
        structure:


            DomainDisplayMachine --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_USER.  This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_USER structures.

            DomainDisplayMachine --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_MACHINE.  This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_MACHINE structures.

            DomainDisplayGroup   --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_GROUP.    This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_GROUP structures.

            DomainDisplayOemUser  --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_OEM_USER.  This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_OEM_user structures.

            DomainDisplayOemGroup --> An array of ReturnedEntryCount elements
                                     of type DOMAIN_DISPLAY_OEM_GROUP.  This is
                                     followed by the bodies of the various
                                     strings pointed to from within the
                                     DOMAIN_DISPLAY_OEM_GROUP structures.


Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_ACCESS_DENIED - The specified handle was not opened for
        the necessary access.

    STATUS_INVALID_HANDLE - The specified handle is not that of an
        opened Domain object.

    STATUS_INVALID_INFO_CLASS - The requested class of information
        is not legitimate for this service.





--*/
{
    NTSTATUS
        NtStatus,
        IgnoreStatus;

    PSAMP_OBJECT
        DomainContext;

    SAMP_OBJECT_TYPE
        FoundType;

    PSAMP_DEFINED_DOMAINS
        Domain;

    PSAMPR_DOMAIN_DISPLAY_USER
        UserElement;

    PSAMPR_DOMAIN_DISPLAY_MACHINE
        MachineElement;

    PSAMPR_DOMAIN_DISPLAY_GROUP
        GroupElement;


    ULONG
        ReturnedBytes = 0,
        ReturnedItems = 0;

    PVOID
        RestartKey;

    BOOLEAN ReadLockAcquired = FALSE;
    DECLARE_CLIENT_REVISION(DomainHandle);


    SAMTRACE_EX("SamrQueryDisplayInformation3");


    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidQueryDisplayInformation
                   );

    //
    // Update DS performance statistics
    //

    SampUpdatePerformanceCounters(
        DSSTAT_QUERYDISPLAYS,
        FLAG_COUNTER_INCREMENT,
        0
        );


    //
    // Prepare for failure
    //

    *TotalAvailable = 0;
    *TotalReturned = 0;

    switch (DisplayInformation) {
    case DomainDisplayUser:
        Buffer->UserInformation.EntriesRead = 0;
        Buffer->UserInformation.Buffer = NULL;
        break;

    case DomainDisplayMachine:
        Buffer->MachineInformation.EntriesRead = 0;
        Buffer->MachineInformation.Buffer = NULL;
        break;

    case DomainDisplayServer:
        if ( SampUseDsData ) {
            Buffer->MachineInformation.EntriesRead = 0;
            Buffer->MachineInformation.Buffer = NULL;
            break;
        } else {
            NtStatus = STATUS_INVALID_INFO_CLASS;
            SAMTRACE_RETURN_CODE_EX(NtStatus);
            goto ErrorReturn;
        }

    case DomainDisplayGroup:
        Buffer->GroupInformation.EntriesRead = 0;
        Buffer->GroupInformation.Buffer = NULL;
        break;

    case DomainDisplayOemUser:
        Buffer->OemUserInformation.EntriesRead = 0;
        Buffer->OemUserInformation.Buffer = NULL;
        break;

    case DomainDisplayOemGroup:
        Buffer->OemGroupInformation.EntriesRead = 0;
        Buffer->OemGroupInformation.Buffer = NULL;
        break;

    default:
        NtStatus = STATUS_INVALID_INFO_CLASS;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto ErrorReturn;
    }

    //
    // If they don't want anything, that's what they'll get
    //

    if (EntriesRequested == 0) {
        NtStatus = STATUS_SUCCESS;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto ErrorReturn;
    }

    //
    // Make sure we don't try to allocate too much memory on
    // the user's behalf
    //

    if (EntriesRequested > 5000) {
        EntriesRequested = 5000;
    }

    //
    // Grab the read lock
    //

    SampAcquireReadLock();
    ReadLockAcquired = TRUE;

    //
    // Validate type of, and access to object.
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;
    NtStatus = SampLookupContext(
                   DomainContext,
                   DOMAIN_LIST_ACCOUNTS,
                   SampDomainObjectType,           // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

        if (IsDsObject(DomainContext))
        {
            //
            // I am the only caller of SampDsQueryDisplayInformation()
            // We need to hold SAM lock before calling into the following
            // routing and release lock when we done.
            //

            NtStatus = SampDsQueryDisplayInformation(
                            DomainHandle,
                            DisplayInformation,
                            Index,
                            EntriesRequested,
                            PreferredMaximumLength,
                            TotalAvailable,
                            TotalReturned,
                            Buffer
                            );
        }
        else
        {

            Domain = &SampDefinedDomains[ DomainContext->DomainIndex ];



            //
            // Set up the common loop statistics
            //

            ReturnedBytes = 0;
            ReturnedItems = 0;


            switch (DisplayInformation) {

            case DomainDisplayUser:


                //
                // Recreate our cached data if necessary
                //

                NtStatus = SampCreateDisplayInformation(DomainDisplayUser);

                //
                // Set the Restart Key from the passed in index
                //

                UserElement = RtlRestartKeyByIndexGenericTable2(
                                  &Domain->DisplayInformation.UserTable,
                                  Index,
                                  &RestartKey
                                  );

                if (UserElement == NULL) {
                    NtStatus = STATUS_SUCCESS;
                    Buffer->GroupInformation.EntriesRead = 0;
                    *TotalReturned = 0;
                    *TotalAvailable = 0; // Not supported for this info level
                    break; // out of switch
                }


                //
                // Allocate space for array of elements
                //

                Buffer->UserInformation.Buffer = MIDL_user_allocate(
                       EntriesRequested * sizeof(SAMPR_DOMAIN_DISPLAY_USER));

                if (Buffer->UserInformation.Buffer == NULL) {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    break; // out of switch
                }

                //
                // Prepare default return value
                //

                NtStatus = STATUS_MORE_ENTRIES;

                //
                // Increment the index value for assignment in our return
                // buffer
                //

                Index++;

                do {
                    NTSTATUS TempStatus;

                    //
                    // Store a copy of this element in the return buffer.
                    //

                    TempStatus = SampDuplicateUserInfo(
                                (PDOMAIN_DISPLAY_USER)
                                &(Buffer->UserInformation.Buffer[ReturnedItems]),
                                (PDOMAIN_DISPLAY_USER)UserElement,
                                Index);
                    Index++;

                    if (!NT_SUCCESS(TempStatus)) {

                        //
                        // Free up everything we've allocated so far
                        //

                        while(ReturnedItems > 0) {
                            ReturnedItems --;
                            SampFreeUserInfo((PDOMAIN_DISPLAY_USER)
                                &(Buffer->UserInformation.Buffer[ReturnedItems]));
                        }

                        MIDL_user_free(Buffer->UserInformation.Buffer);
                        Buffer->UserInformation.Buffer = NULL;

                        NtStatus = TempStatus;
                        break; // out of do loop
                    }

                    //
                    // Update loop statistics
                    //

                    ReturnedBytes += SampBytesRequiredUserNode(
                                        (PDOMAIN_DISPLAY_USER)UserElement);
                    ReturnedItems ++;

                    //
                    // Go find the next element
                    //

                    UserElement = RtlEnumerateGenericTable2(
                                      &Domain->DisplayInformation.UserTable,
                                      &RestartKey
                                      );

                    if (UserElement == NULL) {
                        NtStatus = STATUS_SUCCESS;
                        break; // out of do loop
                    }


                } while ( (ReturnedBytes < PreferredMaximumLength) &&
                          (ReturnedItems < EntriesRequested) );

                //
                // Update output parameters
                //

                if (NT_SUCCESS(NtStatus)) {
                    Buffer->UserInformation.EntriesRead = ReturnedItems;
                    *TotalReturned = ReturnedBytes;
                    *TotalAvailable = Domain->DisplayInformation.TotalBytesInUserTable;
                }

                break; // out of switch


            case DomainDisplayMachine:

                //
                // Recreate our cached data if necessary
                //

                NtStatus = SampCreateDisplayInformation(DomainDisplayMachine);

                //
                // Set the Restart Key from the passed in index
                //

                MachineElement = RtlRestartKeyByIndexGenericTable2(
                                  &Domain->DisplayInformation.MachineTable,
                                  Index,
                                  &RestartKey
                                  );

                if (MachineElement == NULL) {
                    NtStatus = STATUS_SUCCESS;
                    Buffer->GroupInformation.EntriesRead = 0;
                    *TotalReturned = 0;
                    *TotalAvailable = 0; // Not supported for this info level
                    break; // out of switch
                }

                //
                // Allocate space for array of elements
                //

                Buffer->MachineInformation.Buffer = MIDL_user_allocate(
                       EntriesRequested * sizeof(SAMPR_DOMAIN_DISPLAY_MACHINE));

                if (Buffer->MachineInformation.Buffer == NULL) {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    break; // out of switch
                }

                //
                // Prepare default return value
                //

                NtStatus = STATUS_MORE_ENTRIES;

                //
                // Increment the index value for assignment in our return
                // buffer
                //

                Index++;

                do {
                    NTSTATUS TempStatus;

                    //
                    // Store a copy of this element in the return buffer.
                    //

                    TempStatus = SampDuplicateMachineInfo(
                                     (PDOMAIN_DISPLAY_MACHINE)
                                     &(Buffer->MachineInformation.Buffer[ReturnedItems]),
                                     (PDOMAIN_DISPLAY_MACHINE)MachineElement,
                                     Index);
                    Index++;

                    if (!NT_SUCCESS(TempStatus)) {

                        //
                        // Free up everything we've allocated so far
                        //

                        while(ReturnedItems > 0) {
                            ReturnedItems--;
                            SampFreeMachineInfo((PDOMAIN_DISPLAY_MACHINE)
                                &(Buffer->MachineInformation.Buffer[ReturnedItems]));
                        }

                        MIDL_user_free(Buffer->MachineInformation.Buffer);
                        Buffer->MachineInformation.Buffer = NULL;

                        NtStatus = TempStatus;
                        break; // out of do loop
                    }

                    //
                    // Update loop statistics
                    //

                    ReturnedBytes += SampBytesRequiredMachineNode(
                                        (PDOMAIN_DISPLAY_MACHINE)MachineElement);
                    ReturnedItems ++;

                    //
                    // Go find the next element
                    //

                    MachineElement = RtlEnumerateGenericTable2(
                                         &Domain->DisplayInformation.MachineTable,
                                         &RestartKey
                                         );

                    if (MachineElement == NULL) {
                        NtStatus = STATUS_SUCCESS;
                        break; // out of do loop
                    }


                } while ( (ReturnedBytes < PreferredMaximumLength) &&
                          (ReturnedItems < EntriesRequested) );

                //
                // Update output parameters
                //

                if (NT_SUCCESS(NtStatus)) {
                    Buffer->MachineInformation.EntriesRead = ReturnedItems;
                    *TotalReturned = ReturnedBytes;
                    *TotalAvailable = Domain->DisplayInformation.TotalBytesInMachineTable;
                }

                break; // out of switch


            case DomainDisplayGroup:


                //
                // Recreate our cached data if necessary
                //

                NtStatus = SampCreateDisplayInformation(DomainDisplayGroup);

                //
                // Set the Restart Key from the passed in index
                //

                GroupElement = RtlRestartKeyByIndexGenericTable2(
                                  &Domain->DisplayInformation.GroupTable,
                                  Index,
                                  &RestartKey
                                  );

                if (GroupElement == NULL) {
                    NtStatus = STATUS_SUCCESS;
                    Buffer->GroupInformation.EntriesRead = 0;
                    *TotalReturned = 0;
                    *TotalAvailable = 0; // Not supported for this info level
                    break; // out of switch
                }

                //
                // Allocate space for array of elements
                //

                Buffer->GroupInformation.Buffer = MIDL_user_allocate(
                       EntriesRequested * sizeof(SAMPR_DOMAIN_DISPLAY_GROUP));

                if (Buffer->GroupInformation.Buffer == NULL) {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    break; // out of switch
                }

                //
                // Prepare default return value
                //

                NtStatus = STATUS_MORE_ENTRIES;

                //
                // Increment the index value for assignment in our return
                // buffer
                //

                Index++;

                do {
                    NTSTATUS TempStatus;

                    //
                    // Store a copy of this element in the return buffer.
                    //

                    TempStatus = SampDuplicateGroupInfo(
                                     (PDOMAIN_DISPLAY_GROUP)
                                     &(Buffer->GroupInformation.Buffer[ReturnedItems]),
                                     (PDOMAIN_DISPLAY_GROUP)GroupElement,
                                     Index);
                    Index++;

                    if (!NT_SUCCESS(TempStatus)) {

                        //
                        // Free up everything we've allocated so far
                        //

                        while(ReturnedItems > 0) {
                            ReturnedItems--;
                            SampFreeGroupInfo((PDOMAIN_DISPLAY_GROUP)
                                &(Buffer->GroupInformation.Buffer[ReturnedItems]));
                        }

                        MIDL_user_free(Buffer->GroupInformation.Buffer);
                        Buffer->GroupInformation.Buffer = NULL;

                        NtStatus = TempStatus;
                        break; // out of do loop
                    }

                    //
                    // Update loop statistics
                    //

                    ReturnedBytes += SampBytesRequiredGroupNode(
                                        (PDOMAIN_DISPLAY_GROUP)GroupElement);
                    ReturnedItems ++;

                    //
                    // Go find the next element
                    //

                    GroupElement = RtlEnumerateGenericTable2(
                                         &Domain->DisplayInformation.GroupTable,
                                         &RestartKey
                                         );

                    if (GroupElement == NULL) {
                        NtStatus = STATUS_SUCCESS;
                        break; // out of do loop
                    }


                } while ( (ReturnedBytes < PreferredMaximumLength) &&
                          (ReturnedItems < EntriesRequested) );

                //
                // Update output parameters
                //

                if (NT_SUCCESS(NtStatus)) {
                    Buffer->GroupInformation.EntriesRead = ReturnedItems;
                    *TotalReturned = ReturnedBytes;
                    *TotalAvailable = Domain->DisplayInformation.TotalBytesInGroupTable;
                }

                break; // out of switch

            case DomainDisplayOemUser:


                //
                // Recreate our cached data if necessary
                //

                NtStatus = SampCreateDisplayInformation(DomainDisplayUser);

                //
                // Set the Restart Key from the passed in index
                //

                UserElement = RtlRestartKeyByIndexGenericTable2(
                                  &Domain->DisplayInformation.UserTable,
                                  Index,
                                  &RestartKey
                                  );

                if (UserElement == NULL) {
                    NtStatus = STATUS_SUCCESS;
                    Buffer->GroupInformation.EntriesRead = 0;
                    *TotalReturned = 0;
                    *TotalAvailable = 0; // Not supported for this info level
                    break; // out of switch
                }


                //
                // Allocate space for array of elements
                //

                Buffer->UserInformation.Buffer = MIDL_user_allocate(
                       EntriesRequested * sizeof(SAMPR_DOMAIN_DISPLAY_OEM_USER));

                if (Buffer->OemUserInformation.Buffer == NULL) {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    break; // out of switch
                }

                //
                // Prepare default return value
                //

                NtStatus = STATUS_MORE_ENTRIES;

                //
                // Increment the index value for assignment in our return
                // buffer
                //

                Index++;

                do {
                    NTSTATUS TempStatus;

                    //
                    // Store a copy of this element in the return buffer.
                    //

                    TempStatus = SampDuplicateOemUserInfo(
                                (PDOMAIN_DISPLAY_OEM_USER)
                                &(Buffer->OemUserInformation.Buffer[ReturnedItems]),
                                (PDOMAIN_DISPLAY_USER)UserElement,
                                Index);
                    Index++;

                    if (!NT_SUCCESS(TempStatus)) {

                        //
                        // Free up everything we've allocated so far
                        //

                        while(ReturnedItems > 0) {
                            ReturnedItems --;
                            SampFreeOemUserInfo((PDOMAIN_DISPLAY_OEM_USER)
                                &(Buffer->UserInformation.Buffer[ReturnedItems]));
                        }

                        MIDL_user_free(Buffer->OemUserInformation.Buffer);
                        Buffer->OemUserInformation.Buffer = NULL;

                        NtStatus = TempStatus;
                        break; // out of do loop
                    }

                    //
                    // Update loop statistics
                    //

                    ReturnedBytes +=
                        SampBytesRequiredOemUserNode(
                            (PDOMAIN_DISPLAY_OEM_USER)
                            &(Buffer->OemUserInformation.Buffer[ReturnedItems]));
                    ReturnedItems ++;

                    //
                    // Go find the next element
                    //

                    UserElement = RtlEnumerateGenericTable2(
                                      &Domain->DisplayInformation.UserTable,
                                      &RestartKey
                                      );

                    if (UserElement == NULL) {
                        NtStatus = STATUS_SUCCESS;
                        break; // out of do loop
                    }


                } while ( (ReturnedBytes < PreferredMaximumLength) &&
                          (ReturnedItems < EntriesRequested) );

                //
                // Update output parameters
                //

                if (NT_SUCCESS(NtStatus)) {
                    Buffer->UserInformation.EntriesRead = ReturnedItems;
                    *TotalReturned = ReturnedBytes;
                    *TotalAvailable = 0; // Not supported for this info level
                }

                break; // out of switch


            case DomainDisplayOemGroup:


                //
                // Recreate our cached data if necessary
                //

                NtStatus = SampCreateDisplayInformation(DomainDisplayGroup);

                //
                // Set the Restart Key from the passed in index
                //

                GroupElement = RtlRestartKeyByIndexGenericTable2(
                                  &Domain->DisplayInformation.GroupTable,
                                  Index,
                                  &RestartKey
                                  );

                if (GroupElement == NULL) {
                    NtStatus = STATUS_SUCCESS;
                    Buffer->GroupInformation.EntriesRead = 0;
                    *TotalReturned = 0;
                    *TotalAvailable = 0; // Not supported for this info level
                    break; // out of switch
                }


                //
                // Allocate space for array of elements
                //

                Buffer->GroupInformation.Buffer = MIDL_user_allocate(
                       EntriesRequested * sizeof(SAMPR_DOMAIN_DISPLAY_OEM_GROUP));

                if (Buffer->OemGroupInformation.Buffer == NULL) {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                    break; // out of switch
                }

                //
                // Prepare default return value
                //

                NtStatus = STATUS_MORE_ENTRIES;

                //
                // Increment the index value for assignment in our return
                // buffer
                //

                Index++;

                do {
                    NTSTATUS TempStatus;

                    //
                    // Store a copy of this element in the return buffer.
                    //

                    TempStatus = SampDuplicateOemGroupInfo(
                                (PDOMAIN_DISPLAY_OEM_GROUP)
                                &(Buffer->OemGroupInformation.Buffer[ReturnedItems]),
                                (PDOMAIN_DISPLAY_GROUP)GroupElement,
                                Index);
                    Index++;

                    if (!NT_SUCCESS(TempStatus)) {

                        //
                        // Free up everything we've allocated so far
                        //

                        while(ReturnedItems > 0) {
                            ReturnedItems --;
                            SampFreeOemGroupInfo((PDOMAIN_DISPLAY_OEM_GROUP)
                                &(Buffer->GroupInformation.Buffer[ReturnedItems]));
                        }

                        MIDL_user_free(Buffer->OemGroupInformation.Buffer);
                        Buffer->OemGroupInformation.Buffer = NULL;

                        NtStatus = TempStatus;
                        break; // out of do loop
                    }

                    //
                    // Update loop statistics
                    //

                    ReturnedBytes +=
                        SampBytesRequiredOemGroupNode(
                            (PDOMAIN_DISPLAY_OEM_GROUP)
                            &(Buffer->OemGroupInformation.Buffer[ReturnedItems]));
                    ReturnedItems ++;

                    //
                    // Go find the next element
                    //

                    GroupElement = RtlEnumerateGenericTable2(
                                      &Domain->DisplayInformation.GroupTable,
                                      &RestartKey
                                      );

                    if (GroupElement == NULL) {
                        NtStatus = STATUS_SUCCESS;
                        break; // out of do loop
                    }


                } while ( (ReturnedBytes < PreferredMaximumLength) &&
                          (ReturnedItems < EntriesRequested) );

                //
                // Update output parameters
                //

                if (NT_SUCCESS(NtStatus)) {
                    Buffer->GroupInformation.EntriesRead = ReturnedItems;
                    *TotalReturned = ReturnedBytes;
                    *TotalAvailable = 0; // Not supported for this info level
                }

                break; // out of switch

            }
        }

        //
        // De-reference the object
        //

        IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE);
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Free the read lock
    //

    if (ReadLockAcquired)
        SampReleaseReadLock();

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

ErrorReturn:

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidQueryDisplayInformation
                   );

    return(NtStatus);
}



NTSTATUS
SamrGetDisplayEnumerationIndex (
      IN    SAMPR_HANDLE      DomainHandle,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    PRPC_UNICODE_STRING Prefix,
      OUT   PULONG            Index
      )

/*++

Routine Description:

    This wrapper around SamrGetDisplayEnumerationIndex2().

    Provided for compatibility with down-level clients.


--*/
{

    return(SamrGetDisplayEnumerationIndex2( DomainHandle,
                                            DisplayInformation,
                                            Prefix,
                                            Index
                                            ) );
}

NTSTATUS
SamrGetDisplayEnumerationIndex2 (
      IN    SAMPR_HANDLE      DomainHandle,
      IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
      IN    PRPC_UNICODE_STRING Prefix,
      OUT   PULONG            Index
      )

/*++

Routine Description:

    This routine returns the index of the entry which alphabetically
    immediatly preceeds a specified prefix.  If no such entry exists,
    then zero is returned as the index.

Parameters:

    DomainHandle - A handle to an open domain for DOMAIN_LIST_ACCOUNTS.

    DisplayInformation - Indicates which sorted information class is
        to be searched.

    Prefix - The prefix to compare.

    Index - Receives the index of the entry of the information class
        with a LogonName (or MachineName) which immediatly preceeds the
        provided prefix string.  If there are no elements which preceed
        the prefix, then zero is returned.


Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_ACCESS_DENIED - The specified handle was not opened for
        the necessary access.

    STATUS_INVALID_HANDLE - The specified handle is not that of an
        opened Domain object.

    STATUS_NO_MORE_ENTRIES - There are no entries for this information class.


--*/
{
    NTSTATUS
        NtStatus,
        IgnoreStatus;

    PSAMP_OBJECT
        DomainContext;

    SAMP_OBJECT_TYPE
        FoundType;

    PSAMP_DEFINED_DOMAINS
        Domain;

    PRTL_GENERIC_TABLE2
        Table = NULL;

    DOMAIN_DISPLAY_USER
        UserElement;

    DOMAIN_DISPLAY_MACHINE
        MachineElement;

    DOMAIN_DISPLAY_GROUP
        GroupElement;

    RTL_GENERIC_COMPARE_RESULTS
        CompareResult;

    PRTL_GENERIC_2_COMPARE_ROUTINE
        CompareRoutine = NULL;

    PVOID
        Element = NULL,
        NextElement = NULL,
        RestartKey = NULL;

    ULONG
        CurrentIndex;

    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrGetDisplayEnumerationIndex2");

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidGetDisplayEnumerationIndex
                   );


    //
    // Check the information class
    //

    if ((DisplayInformation != DomainDisplayUser)    &&
        (DisplayInformation != DomainDisplayMachine) &&
        (DisplayInformation != DomainDisplayGroup)
       ) {

        NtStatus = STATUS_INVALID_INFO_CLASS;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }

    if (  (Prefix == NULL) ||
          ((Prefix->Length > 0) && (Prefix->Buffer == NULL)) ) {

        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;

    }


    //
    // Grab the read lock
    //

    SampAcquireReadLock();



    //
    // Validate type of, and access to object.
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;
    NtStatus = SampLookupContext(
                   DomainContext,
                   DOMAIN_LIST_ACCOUNTS,
                   SampDomainObjectType,           // ExpectedType
                   &FoundType
                   );


    if (NT_SUCCESS(NtStatus)) {

        if (IsDsObject(DomainContext))
        {
            //
            // Begin a Ds transaction
            //

            NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
            if (NT_SUCCESS(NtStatus))
            {
                RESTART * pRestart;

                //
                // Call into the DS to get the Index , value and also a restart
                // structure such the QueryDisplayInformation can restart this
                // search at the object just found, if the returned index was
                // specified in the starting offset.
                //
                NtStatus = SampGetDisplayEnumerationIndex(
                                DomainContext->ObjectNameInDs,
                                DisplayInformation,
                                Prefix,
                                Index,
                                &pRestart
                                );

                if (NT_SUCCESS(NtStatus))
                {
                    if (NULL!=DomainContext->TypeBody.Domain.DsDisplayState.Restart)
                    {
                        MIDL_user_free(DomainContext->TypeBody.Domain.DsDisplayState.Restart);
                        DomainContext->TypeBody.Domain.DsDisplayState.Restart = NULL;
                    }

                    NtStatus = SampCopyRestart(
                                    pRestart,
                                    &(DomainContext->TypeBody.Domain.DsDisplayState.Restart)
                                    );
                    if (NT_SUCCESS(NtStatus))
                    {
                        DomainContext->TypeBody.Domain.DsDisplayState.TotalEntriesReturned = 0;
                        DomainContext->TypeBody.Domain.DsDisplayState.NextStartingOffset
                                = *Index;

                        DomainContext->TypeBody.Domain.DsDisplayState.DisplayInformation
                                = DisplayInformation;
                    }
                    else
                    {
                        *Index = 0;
                        DomainContext->TypeBody.Domain.DsDisplayState.Restart = NULL;
                    }
                }

                //
                // End the DS transaction
                //

                IgnoreStatus = SampMaybeEndDsTransaction(TransactionCommit);
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }


        }
        else
        {


            Domain = &SampDefinedDomains[ DomainContext->DomainIndex ];

            //
            // Set default return value
            //

            (*Index) = 0;

            //
            // Recreate our cached data if necessary
            //

            NtStatus = SampCreateDisplayInformation(DisplayInformation);

            if (NT_SUCCESS(NtStatus)) {

                //
                // Set up
                //          The table to search,
                //          The comparison routine to use,
                //          An appropriate element for the search.
                //

                switch (DisplayInformation) {

                case DomainDisplayUser:

                    Table = &Domain->DisplayInformation.UserTable;
                    CompareRoutine = SampCompareUserNodeByName;

                    Element = (PVOID)&UserElement;
                    UserElement.LogonName = *(PUNICODE_STRING)Prefix;

                    break;  // out of switch

                case DomainDisplayMachine:

                    Table = &Domain->DisplayInformation.MachineTable;
                    CompareRoutine = SampCompareMachineNodeByName;

                    Element = (PVOID)&MachineElement;
                    MachineElement.Machine = *(PUNICODE_STRING)Prefix;

                    break;  // out of switch


                case DomainDisplayGroup:

                    Table = &Domain->DisplayInformation.GroupTable;
                    CompareRoutine = SampCompareGroupNodeByName;

                    Element = (PVOID)&GroupElement;
                    GroupElement.Group = *(PUNICODE_STRING)Prefix;

                    break;  // out of switch
                }


                if (RtlIsGenericTable2Empty(Table)) {

                    NtStatus = STATUS_NO_MORE_ENTRIES;

                } else {

                    //
                    // Now compare each entry until we find the one asked
                    // for.
                    //

                    CurrentIndex = 0;

                    RestartKey = NULL;
                    for (NextElement = RtlEnumerateGenericTable2(Table, &RestartKey);
                        NextElement != NULL;
                        NextElement = RtlEnumerateGenericTable2(Table, &RestartKey)) {

                        //
                        // Compare with passed in element
                        //

                        CompareResult = (*CompareRoutine)( NextElement, Element );
                        if (CompareResult != GenericLessThan) {
                            break;  // break out of for loop
                        }

                        CurrentIndex++;
                    }

                    //
                    // CurrentIndex has the return value in it.
                    //

                    ASSERT( CurrentIndex <= RtlNumberElementsGenericTable2(Table) );

                    (*Index) = CurrentIndex;
                    if (NULL == NextElement)
                    {
                        NtStatus = STATUS_NO_MORE_ENTRIES;
                    }
                    else
                    {
                        NtStatus = STATUS_SUCCESS;
                    }
                }
            }
        }

        //
        // De-reference the object
        //

        IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE);
        ASSERT(NT_SUCCESS(IgnoreStatus));

    }

    //
    // Free the read lock
    //

    SampReleaseReadLock();

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidGetDisplayEnumerationIndex
                   );

    return(NtStatus);
}


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines available to trusted clients in SAM's process                    //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SamIEnumerateAccountRids(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG AccountTypesMask,
    IN  ULONG StartingRid,
    IN  ULONG PreferedMaximumLength,
    OUT PULONG ReturnCount,
    OUT PULONG *AccountRids
    )

/*++

Routine Description:

    Provide a list of account RIDs.  The caller may ask for one or
    more types of account rids in a single call.

    The returned rids are in ascending value order.

        WARNING - This routine is only callable by trusted clients.
                  Therefore, parameter checking is only performed
                  in checked-build systems.

Parameters:

    DomainHandle - handle to the domain whose accounts are to be
        enumerated.

    AccountTypesMask - Mask indicating which types of accounts
        the caller wants enumerated.  These included:

                SAM_USER_ACCOUNT
                SAM_GLOBAL_GROUP_ACCOUNT
                SAM_LOCAL_GROUP_ACCOUNT     (not yet supported)

    StartingRid - A rid that is less than the lowest value rid to be
        included in the enumeration.


    PreferedMaximumLength - Provides a restriction on how much memory
        may be returned in this call.  This is not a hard upper limit,
        but serves as a guideline.

    ReturnCount - Receives a count of the number of rids returned.

    AccountRids - Receives a pointer to an array of rids.  If
        ReturnCount is zero, then this will be returned as NULL.
        Otherwise, it will point to an array containing ReturnCount
        rids.

Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.

    STATUS_MORE_ENTRIES - There are more entries, so call again.
        This is a successful return.

    STATUS_INVALID_INFO_CLASS - The specified AccountTypesMask contained
        unknown or unsupported account types.

    STATUS_NO_MEMORY - Could not allocate pool to complete the call.

--*/
{

    NTSTATUS
        NtStatus,
        IgnoreStatus;

    PSAMP_OBJECT
        DomainContext;

    SAMP_OBJECT_TYPE
        FoundType;

    BOOLEAN
        fSamLockHeld = FALSE;


    SAMTRACE_EX("SamIEnumerateAccountRids");

    //
    // Prepare for failure
    //

    (*ReturnCount) = 0;
    (*AccountRids) = NULL;

#if DBG

    if ( (AccountTypesMask & ~( SAM_USER_ACCOUNT | SAM_GLOBAL_GROUP_ACCOUNT))
         != 0 ) {
        return(STATUS_INVALID_INFO_CLASS);
    }


#endif //DBG


    //
    // Validate type of, and access to object.
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;

    //
    // Acquire the SAM read lock if necessary
    //

    SampMaybeAcquireReadLock(DomainContext, 
                             DOMAIN_OBJECT_DONT_ACQUIRELOCK_EVEN_IF_SHARED,
                             &fSamLockHeld);


    NtStatus = SampLookupContext(
                   DomainContext,
                   0,                              // Trusted clients only
                   SampDomainObjectType,           // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

        if (IsDsObject(DomainContext))
        {
            NtStatus = SampDsEnumerateAccountRids(
                            DomainHandle,
                            AccountTypesMask,
                            StartingRid,
                            PreferedMaximumLength,
                            ReturnCount,
                            AccountRids
                            );
        }
        else
        {
            //
            // Just In case
            //
            ASSERT(FALSE && "No One should call me in Registry Mode\n");
            NtStatus = STATUS_NOT_SUPPORTED;
        }

        //
        // De-reference the object
        //

        IgnoreStatus = SampDeReferenceContext2( DomainContext, FALSE);
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Free the read lock
    //

    SampMaybeReleaseReadLock(fSamLockHeld);

    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return(NtStatus);

}


#if 0

//
// The following routine will not been called in Registry Mode.
// We are using the above routine instead.
// Preserving the old routine just for safe keeping ONLY.
//


NTSTATUS
SamIEnumerateAccountRids(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG AccountTypesMask,
    IN  ULONG StartingRid,
    IN  ULONG PreferedMaximumLength,
    OUT PULONG ReturnCount,
    OUT PULONG *AccountRids
    )

/*++

Routine Description:

    Provide a list of account RIDs.  The caller may ask for one or
    more types of account rids in a single call.

    The returned rids are in ascending value order.

        WARNING - This routine is only callable by trusted clients.
                  Therefore, parameter checking is only performed
                  in checked-build systems.

Parameters:

    DomainHandle - handle to the domain whose accounts are to be
        enumerated.

    AccountTypesMask - Mask indicating which types of accounts
        the caller wants enumerated.  These included:

                SAM_USER_ACCOUNT
                SAM_GLOBAL_GROUP_ACCOUNT
                SAM_LOCAL_GROUP_ACCOUNT     (not yet supported)

    StartingRid - A rid that is less than the lowest value rid to be
        included in the enumeration.


    PreferedMaximumLength - Provides a restriction on how much memory
        may be returned in this call.  This is not a hard upper limit,
        but serves as a guideline.

    ReturnCount - Receives a count of the number of rids returned.

    AccountRids - Receives a pointer to an array of rids.  If
        ReturnCount is zero, then this will be returned as NULL.
        Otherwise, it will point to an array containing ReturnCount
        rids.

Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.

    STATUS_MORE_ENTRIES - There are more entries, so call again.
        This is a successful return.

    STATUS_INVALID_INFO_CLASS - The specified AccountTypesMask contained
        unknown or unsupported account types.

    STATUS_NO_MEMORY - Could not allocate pool to complete the call.

--*/
{

    NTSTATUS
        NtStatus,
        IgnoreStatus;

    PSAMP_OBJECT
        DomainContext;

    SAMP_OBJECT_TYPE
        FoundType;

    PSAMP_DEFINED_DOMAINS
        Domain;

    PRTL_GENERIC_TABLE2
        Table;

    ULONG
        MaxEntries,
        Count,
        AccountType;

    PVOID
        RestartKey;

    PSAMP_DISPLAY_ENTRY_HEADER
        Element;
    BOOLEAN
        fSamLockHeld = FALSE;

    SAMP_DISPLAY_ENTRY_HEADER
        RestartValue;

    SAMTRACE_EX("SamIEnumerateAccountRids");

    //
    // Prepare for failure
    //

    (*ReturnCount) = 0;
    (*AccountRids) = NULL;

#if DBG

    if ( (AccountTypesMask & ~( SAM_USER_ACCOUNT | SAM_GLOBAL_GROUP_ACCOUNT))
         != 0 ) {
        return(STATUS_INVALID_INFO_CLASS);
    }


#endif //DBG

    //
    // Grab the read lock
    //

    SampAcquireReadLock();
    fSamLockHeld = TRUE;

    //
    // Validate type of, and access to object.
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;
    NtStatus = SampLookupContext(
                   DomainContext,
                   0,                              // Trusted clients only
                   SampDomainObjectType,           // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

        if (IsDsObject(DomainContext))
        {
            //
            // We can release the read lock after validating
            // the context as netlogon guarentees us that it
            // will not call a close on the context as long
            // as an active call is being made using it. Since
            // netlogon is the only caller of this API and it
            // is a trusted client we can optimize the lock usage
            // by releasing the read lock
            //

            SampReleaseReadLock();
            fSamLockHeld = FALSE;

            //
            // Since we no longer hold the lock while doing
            // ds operations we should increment the active
            // thread count so that the DS is not shut down
            // while we are still running
            //

            NtStatus = SampIncrementActiveThreads();
            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = SampDsEnumerateAccountRids(
                            DomainHandle,
                            AccountTypesMask,
                            StartingRid,
                            PreferedMaximumLength,
                            ReturnCount,
                            AccountRids
                            );

                SampDecrementActiveThreads();
            }

        }
        else
        {

            Domain = &SampDefinedDomains[ DomainContext->DomainIndex ];
            Table =  &Domain->DisplayInformation.RidTable;

            //
            // If the RID table isn't valid, force it to be made valid.
            //

            if (!SampRidTableValid(DomainContext->DomainIndex)) {
                NtStatus = SampCreateDisplayInformation ( DomainDisplayUser );  //User and machine
                if (NT_SUCCESS(NtStatus)) {
                    NtStatus = SampCreateDisplayInformation ( DomainDisplayGroup );
                }
            }

            if (NT_SUCCESS(NtStatus)) {

                //
                // Allocate a return buffer.
                // Only allocate as much as we can use.
                // This is limited either by PreferedMaximumLength
                // or the number of entries in the table.
                //

                MaxEntries =
                    ( PreferedMaximumLength / sizeof(ULONG) );

                if (MaxEntries == 0) {
                    MaxEntries = 1;  // Always return at least one
                }

                if (MaxEntries > RtlNumberElementsGenericTable2(Table) ) {
                    MaxEntries = RtlNumberElementsGenericTable2(Table);
                }

                PreferedMaximumLength = MaxEntries *
                                        sizeof(SAMP_DISPLAY_ENTRY_HEADER);

                (*AccountRids) = MIDL_user_allocate( PreferedMaximumLength );
                if ((*AccountRids) == NULL) {
                    STATUS_NO_MEMORY;
                }

                //
                // Get the restart key based upon the passed in RID.
                //

                Table = &Domain->DisplayInformation.RidTable;
                RestartValue.Rid = StartingRid;

                Element = RtlRestartKeyByValueGenericTable2(
                              Table,
                              &RestartValue,
                              &RestartKey
                              );

                //
                // Now we may loop obtaining entries until we reach
                // either MaxEntries or the end of the table.
                //
                // WARNING - there is one special case that we have to
                // take care of.  If the returned Element is not null,
                // but the RestartKey is null, then the caller has
                // asked for an enumeration and passed in the last rid
                // defined.  If we aren't careful, this will cause an
                // enumeration to be started from the beginning of the
                // list again.  Instead, return status indicating we have
                // no more entries.
                //

                Count = 0;
                if (((Element != NULL) && (RestartKey == NULL))) {

                    Element = NULL;  // Used to signify no more entries found

                } else {

                    for (Element  = RtlEnumerateGenericTable2(Table, &RestartKey);
                         ( (Element != NULL)  && (Count < MaxEntries) );
                         Element = RtlEnumerateGenericTable2(Table, &RestartKey)) {

                        //
                        // Make sure this is an account that was asked for
                        //

                        AccountType = Element->Index;
                        if ((AccountType & AccountTypesMask) != 0) {
                            (*AccountRids)[Count] = Element->Rid;
                            Count++;
                        }
                    }
                }

                //
                // Now figure out what we have done:
                //
                //      Returned all entries in table => STATUS_SUCCESS
                //      More entries to return => STATUS_MORE_ENTRIES
                //
                //      Count == 0 => free AccountRid array.
                //

                if (Element == NULL) {
                    NtStatus = STATUS_SUCCESS;
                } else {
                    NtStatus = STATUS_MORE_ENTRIES;
                }

                if (Count == 0) {
                    MIDL_user_free( (*AccountRids) );
                    (*AccountRids) = NULL;
                }

                (*ReturnCount) = Count;

            }
        }

        //
        // De-reference the object
        //

        IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE);
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Free the read lock
    //
    if (fSamLockHeld)
    {
        SampReleaseReadLock();
        fSamLockHeld = FALSE;
    }

    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return(NtStatus);


}

#endif // 0



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines available to other SAM modules                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
SampInitializeDisplayInformation (
    ULONG DomainIndex
    )

/*++

Routine Description:

    This routines initializes the display information structure.
    This involves initializing the User, Machine and Group trees (empty),
    and setting the Valid flag to FALSE.

    If this is the account domain, we also create the display information.

Parameters:

    DomainIndex - An index into the DefinedDomains array.  This array
        contains information about the domain being openned,
        including its name.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

--*/
{
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation;

    //
    // This must be initialized before we use SampCompareDisplayStrings().
    //

    SampSystemDefaultLCID = GetSystemDefaultLCID();

    DisplayInformation = &SampDefinedDomains[DomainIndex].DisplayInformation;

    RtlInitializeGenericTable2(
                &DisplayInformation->UserTable,
                SampCompareUserNodeByName,
                SampGenericTable2Allocate,
                SampGenericTable2Free);

    RtlInitializeGenericTable2(
                &DisplayInformation->MachineTable,
                SampCompareMachineNodeByName,
                SampGenericTable2Allocate,
                SampGenericTable2Free);

    RtlInitializeGenericTable2(
                &DisplayInformation->InterdomainTable,
                SampCompareMachineNodeByName,
                SampGenericTable2Allocate,
                SampGenericTable2Free);

    RtlInitializeGenericTable2(
                &DisplayInformation->GroupTable,
                SampCompareGroupNodeByName,
                SampGenericTable2Allocate,
                SampGenericTable2Free);

    RtlInitializeGenericTable2(
                &DisplayInformation->RidTable,
                SampCompareNodeByRid,
                SampGenericTable2Allocate,
                SampGenericTable2Free);

    DisplayInformation->UserAndMachineTablesValid = FALSE;
    DisplayInformation->GroupTableValid = FALSE;

    if ( ( SampProductType == NtProductLanManNt) &&
         ( FALSE == SampUseDsData) &&
         (DomainIndex == SampDefinedDomainsCount - 1 )) {

        //
        // Grab the read lock and indicate which domain the transaction is in
        //

        SampAcquireReadLock();
        SampSetTransactionDomain( DomainIndex );

        //
        // Populate the Display Cache
        //

        SAMTRACE("SAMSS: Attempting to create display information\n");

        (VOID) SampCreateDisplayInformation(DomainDisplayUser);
        (VOID) SampCreateDisplayInformation(DomainDisplayGroup);

        SAMTRACE("SAMSS: Finished creating display information\n");

        //
        // Free the read lock
        //

        SampReleaseReadLock();
    }

    return(STATUS_SUCCESS);

}



VOID
SampDeleteDisplayInformation (
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    SAMP_OBJECT_TYPE ObjectType
    )

/*++

Routine Description:

    This routines frees up any resources used by the display information.


    Note:  It use to be that we could selectively invalidate
            portions of the display cache (e.g., users, or groups).
            With the addition of the RID table, this becomes
            problematic.  So, now the approach is to flush all tables
            for a domain if any the tables in that domain are flushed.


Parameters:

    DisplayInformation - The display information structure to delete.

    ObjectType - Indicates which table to delete the information from.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

--*/
{
    NTSTATUS    NtStatus;


    if (!(IsDsObject(SampDefinedDomains[SampTransactionDomainIndex].Context)))
    {
        //
        // Empty the Rid table and check it really is empty.
        //

        NtStatus = SampEmptyGenericTable2(&DisplayInformation->RidTable,
                                          FALSE,
                                          0);
        ASSERT(NT_SUCCESS(NtStatus));

        ASSERT(RtlIsGenericTable2Empty(&DisplayInformation->RidTable));

        DisplayInformation->TotalBytesInRidTable = 0;


        //
        // Remember that we keep the same account information in two
        // places. One is in the individual table (would be User, Group,
        // Machine, InterDomainTrust), the other is in the Rid Table.
        // So we cannot really delete the actual generic table DATA until
        // this point in this function, otherwise we'll have dangling pointer.
        //

        //
        // But we shouldn't even bother here.
        //

        //
        // Empty the user table and check it really is empty
        //

        NtStatus = SampEmptyGenericTable2(&DisplayInformation->UserTable,
                                          TRUE,
                                          SampUserObjectType);
        ASSERT(NT_SUCCESS(NtStatus));

        ASSERT(RtlIsGenericTable2Empty(&DisplayInformation->UserTable));

        DisplayInformation->TotalBytesInUserTable = 0;



        //
        // Empty the machine table and check it really is empty
        //

        NtStatus = SampEmptyGenericTable2(&DisplayInformation->MachineTable,
                                          TRUE,
                                          SampUserObjectType);
        ASSERT(NT_SUCCESS(NtStatus));

        ASSERT(RtlIsGenericTable2Empty(&DisplayInformation->MachineTable));

        DisplayInformation->TotalBytesInMachineTable = 0;



        //
        // Empty the Interdomain table and check it really is empty
        //

        NtStatus = SampEmptyGenericTable2(&DisplayInformation->InterdomainTable,
                                          TRUE,
                                          SampUserObjectType);
        ASSERT(NT_SUCCESS(NtStatus));

        ASSERT(RtlIsGenericTable2Empty(&DisplayInformation->InterdomainTable));

        DisplayInformation->TotalBytesInInterdomainTable = 0;



        //
        // Empty the Group table and check it really is empty
        //

        NtStatus = SampEmptyGenericTable2(&DisplayInformation->GroupTable,
                                          TRUE,
                                          SampGroupObjectType);
        ASSERT(NT_SUCCESS(NtStatus));

        ASSERT(RtlIsGenericTable2Empty(&DisplayInformation->GroupTable));

        DisplayInformation->TotalBytesInGroupTable = 0;


        //
        // Mark Both UserTable and GroupTable Invalid
        //
        DisplayInformation->UserAndMachineTablesValid = FALSE;
        DisplayInformation->GroupTableValid = FALSE;

    }


}



NTSTATUS
SampMarkDisplayInformationInvalid (
    SAMP_OBJECT_TYPE ObjectType
    )

/*++

Routine Description:

    This routine invalidates any cached display information. This
    causes it to be recreated the next time a client queries it.
    Later we will probably start/restart a thread here and have it
    re-create the display information in the background.

    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().

    Another Note:  It use to be that we could selectively invalidate
            portions of the display cache (e.g., users, or groups).
            With the addition of the RID table, this becomes
            problematic.  So, now the approach is to flush all tables
            for a domain if any the tables in that domain are flushed.


Parameters:

    ObjectType - SampUserObjectType or SampGroupObjectType.  Only the
        appropriate tables will be marked Invalid.  For User type, the
        user and machine tables will be marked Invalid.  For Group type,
        the group table will be marked Invalid.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

--*/
{
    PSAMP_DEFINED_DOMAINS Domain;

    ASSERT(SampTransactionWithinDomain == TRUE);

    if (!(IsDsObject(SampDefinedDomains[SampTransactionDomainIndex].Context)))
    {

        SampDiagPrint(DISPLAY_CACHE,
                     ("SAM: MarkDisplayInformationInvalid : Emptying cache\n"));

        //
        // Get pointer to the current domain structure
        //

        Domain = &SampDefinedDomains[SampTransactionDomainIndex];

        //
        // Delete any cached data
        //

        SampDeleteDisplayInformation(&Domain->DisplayInformation, ObjectType);

        //
        // Set the Valid flag to FALSE
        //

        Domain->DisplayInformation.UserAndMachineTablesValid = FALSE;
        Domain->DisplayInformation.GroupTableValid = FALSE;
    }


    return(STATUS_SUCCESS);

}



NTSTATUS
SampCreateDisplayInformation (
    DOMAIN_DISPLAY_INFORMATION DisplayType
    )

/*++

Routine Description:

    This routine builds the cached display information for the current
    domain.

    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseReadLock().

Parameters:

    DisplayType - Indicates which type of display information is
        being created.  This leads us to the appropriate table(s).

Return Values:

    STATUS_SUCCESS - normal, successful completion.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_DEFINED_DOMAINS Domain;
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation;

    SAMTRACE("SampCreateDisplayInformation");


    ASSERT(SampTransactionWithinDomain == TRUE);

    if (!(IsDsObject(SampDefinedDomains[SampTransactionDomainIndex].Context)))
    {
        //
        // We will build display information only if we boot from registry
        //

        Domain = &SampDefinedDomains[SampTransactionDomainIndex];


        DisplayInformation = &Domain->DisplayInformation;

        switch (DisplayType) {
        case DomainDisplayUser:
        case DomainDisplayMachine:

            //
            // If the cache is valid, nothing to do
            //

            if (DisplayInformation->UserAndMachineTablesValid) {

                SampDiagPrint(DISPLAY_CACHE,
                    ("SAM: CreateDisplayInformation : User/Machine Cache is valid, nothing to do\n"));
                return(STATUS_SUCCESS);
            };


            SampDiagPrint(DISPLAY_CACHE,
                ("SAM: CreateDisplayInformation : Creating user/machine cache...\n"));

            ASSERT(RtlIsGenericTable2Empty(&DisplayInformation->UserTable));
            ASSERT(RtlIsGenericTable2Empty(&DisplayInformation->MachineTable));
            ASSERT(RtlIsGenericTable2Empty(&DisplayInformation->InterdomainTable));


            NtStatus = SampRetrieveDisplayInfoFromDisk( DisplayInformation, SampUserObjectType );
            if (NT_SUCCESS(NtStatus)) {
                NtStatus = SampTallyTableStatistics(DisplayInformation, SampUserObjectType);
            }

            //
            // Clean up on error

            if (!NT_SUCCESS(NtStatus)) {
                SampDiagPrint(DISPLAY_CACHE,
                    ("SAM: CreateDisplayInformation FAILED: 0x%lx\n", NtStatus));

                SampDeleteDisplayInformation(&Domain->DisplayInformation, SampUserObjectType);
            } else {
                Domain->DisplayInformation.UserAndMachineTablesValid = TRUE;
            }

            break;   // out of switch


        case DomainDisplayGroup:

            //
            // If the cache is valid, nothing to do
            //

            if (DisplayInformation->GroupTableValid) {

                SampDiagPrint(DISPLAY_CACHE,
                    ("SAM: CreateDisplayInformation : Group Cache is valid, nothing to do\n"));

                return(STATUS_SUCCESS);
            };


            SampDiagPrint(DISPLAY_CACHE,
                ("SAM: CreateDisplayInformation : Creating group cache...\n"));

            ASSERT(RtlIsGenericTable2Empty(&DisplayInformation->GroupTable));


            NtStatus = SampRetrieveDisplayInfoFromDisk( DisplayInformation, SampGroupObjectType );
            if (NT_SUCCESS(NtStatus)) {
                NtStatus = SampTallyTableStatistics(DisplayInformation, SampGroupObjectType);
            }

            //
            // Clean up on error

            if (!NT_SUCCESS(NtStatus)) {
                SampDiagPrint(DISPLAY_CACHE,
                    ("SAM: CreateDisplayInformation FAILED: 0x%lx\n", NtStatus));
                SampDeleteDisplayInformation(&Domain->DisplayInformation, SampGroupObjectType);
            } else {
                Domain->DisplayInformation.GroupTableValid = TRUE;
            }

            break;   // out of switch
        }
    }

    return(NtStatus);
}

ULONG MaxEnumSize = 10000;


NTSTATUS
SampRetrieveDisplayInfoFromDisk(
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    SAMP_OBJECT_TYPE ObjectType
    )

{
    NTSTATUS NtStatus;
    SAM_ENUMERATE_HANDLE EnumerationContext;
    PSAMPR_ENUMERATION_BUFFER EnumerationBuffer;
    ULONG i;
    ULONG CountReturned;
    BOOLEAN MoreEntries;


    SAMTRACE("SampRetrieveDisplayInfoFromDisk");

    //
    // Enumerate the accounts.
    // For each account, get the relevant information on it,
    // and add to either the UserTable, MachineTable, or GroupTable.
    //

    EnumerationContext = 0;

    do {

        NtStatus = SampEnumerateAccountNames(
                       ObjectType,
                       &EnumerationContext,
                       &EnumerationBuffer,
                       MaxEnumSize,               // PreferedMaximumLength
                       0L,                         // no filter
                       &CountReturned,
                       FALSE                       // trusted client
                       );
        if (!NT_SUCCESS(NtStatus)) {
            SampDiagPrint( DISPLAY_CACHE_ERRORS,
                           ("SAM: Retrieve Info From Disk - "
                            "Error enumerating account names (0x%lx)\n",
                            NtStatus) );
            break;
        }



        //
        // Print Dignostic Message Regarding what is available
        //

        SampDiagPrint(DISPLAY_CACHE,("SAMSS: SampEnumerateAccounNames"
                                        "Enumeration Context = %x"
                                        "Enumeration Buffer  = %p"
                                        "Count Returned = %d"
                                        "Return Value = %x\n",
                                        (ULONG) EnumerationContext,
                                        EnumerationBuffer,
                                        (ULONG) CountReturned,
                                        NtStatus));
        //
        // Make a note if there are more entries
        //

        MoreEntries = (NtStatus == STATUS_MORE_ENTRIES);


        //
        // For each account, get the necessary information for it
        // and add to the appropriate display information table
        //

        for (i = 0; i < EnumerationBuffer->EntriesRead; i++) {

            ULONG                   AccountRid =
                                    EnumerationBuffer->Buffer[i].RelativeId;
            PUNICODE_STRING         AccountName =
                                    (PUNICODE_STRING)&(EnumerationBuffer->Buffer[i].Name);
            SAMP_V1_0A_FIXED_LENGTH_USER UserV1aFixed; // Contains account control
            SAMP_V1_0A_FIXED_LENGTH_GROUP GroupV1Fixed; // Contains attributes
            SAMP_ACCOUNT_DISPLAY_INFO AccountInfo;
            PSAMP_OBJECT            AccountContext;


            //
            // Open a context to the account
            //

            NtStatus = SampCreateAccountContext(
                            ObjectType,
                            AccountRid,
                            TRUE, // Trusted client
                            FALSE,// Loopback client
                            TRUE, // Account exists
                            &AccountContext
                            );

            if (!NT_SUCCESS(NtStatus)) {
                SampDiagPrint( DISPLAY_CACHE_ERRORS,
                               ("SAM: Retrieve Info From Disk - "
                                "Error Creating account context (0x%lx)\n",
                                NtStatus) );
                break; // out of for loop
            }


            //
            // Get the account control information
            //

            switch (ObjectType) {
                case SampUserObjectType:

                    NtStatus = SampRetrieveUserV1aFixed(AccountContext, &UserV1aFixed);
                    if (!NT_SUCCESS(NtStatus)) {
                        SampDeleteContext( AccountContext );
                        SampDiagPrint( DISPLAY_CACHE_ERRORS,
                                   ("SAM: Retrieve USER From Disk - "
                                    "Error getting V1a Fixed (0x%lx)\n",
                                    NtStatus) );
                        break; // out of for loop
                    }


                    //
                    // If this is not an account we're interested in skip it
                    //

                    if (!DISPLAY_ACCOUNT(UserV1aFixed.UserAccountControl)) {
                        SampDeleteContext( AccountContext );
                        continue; // next account
                    }



                    //
                    // Get the admin comment
                    //

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_ADMIN_COMMENT,
                                   FALSE, // Don't make copy
                                   &AccountInfo.Comment
                                   );

                    if (!NT_SUCCESS(NtStatus)) {
                        SampDeleteContext( AccountContext );
                        SampDiagPrint( DISPLAY_CACHE_ERRORS,
                                   ("SAM: Retrieve USER From Disk - "
                                    "Error getting admin comment (0x%lx)\n",
                                    NtStatus) );
                        break; // out of for loop
                    }


                    //
                    // Get the full name
                    //

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_USER_FULL_NAME,
                                   FALSE, // Don't make copy
                                   &AccountInfo.FullName
                                   );

                    if (!NT_SUCCESS(NtStatus)) {
                        SampDeleteContext( AccountContext );
                        SampDiagPrint( DISPLAY_CACHE_ERRORS,
                                   ("SAM: Retrieve USER From Disk - "
                                    "Error getting full name (0x%lx)\n",
                                    NtStatus) );
                        break; // out of for loop
                    }

                    //
                    // Set the  account control
                    //

                    AccountInfo.AccountControl = UserV1aFixed.UserAccountControl;

                    break;  // out of switch

                case SampGroupObjectType:

                    NtStatus = SampRetrieveGroupV1Fixed(AccountContext, &GroupV1Fixed);
                    if (!NT_SUCCESS(NtStatus)) {
                        SampDeleteContext( AccountContext );
                        SampDiagPrint( DISPLAY_CACHE_ERRORS,
                                   ("SAM: Retrieve GROUP From Disk - "
                                    "Error getting V1 fixed (0x%lx)\n",
                                    NtStatus) );
                        break; // out of for loop
                    }

                    //
                    // Get the admin comment
                    //

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_GROUP_ADMIN_COMMENT,
                                   FALSE, // Don't make copy
                                   &AccountInfo.Comment
                                   );
                    if (!NT_SUCCESS(NtStatus)) {
                        SampDeleteContext( AccountContext );
                        SampDiagPrint( DISPLAY_CACHE_ERRORS,
                                   ("SAM: Retrieve GROUP From Disk - "
                                    "Error getting admin comment (0x%lx)\n",
                                    NtStatus) );
                        break; // out of for loop
                    }

                    //
                    // Set the  attributes
                    //

                    AccountInfo.AccountControl = GroupV1Fixed.Attributes;

                    break;  // out of switch
            }


            //
            // Now add this account to the cached data
            //

            AccountInfo.Rid = AccountRid;
            AccountInfo.Name = *((PUNICODE_STRING)(&EnumerationBuffer->Buffer[i].Name));

            NtStatus = SampAddDisplayAccount(DisplayInformation,
                                             ObjectType,
                                             &AccountInfo);

            //
            // We're finished with the account context
            //

            SampDeleteContext( AccountContext );

            //
            // Check the result of adding the account to the cache
            //

            if (!NT_SUCCESS(NtStatus)) {
                break; // out of for loop
            }


        } // end_for


        //
        // Free up the enumeration buffer returned
        //

        SamIFree_SAMPR_ENUMERATION_BUFFER(EnumerationBuffer);

    } while ( MoreEntries );

    return(NtStatus);

}


NTSTATUS
SampUpdateDisplayInformation (
    PSAMP_ACCOUNT_DISPLAY_INFO  OldAccountInfo OPTIONAL,
    PSAMP_ACCOUNT_DISPLAY_INFO  NewAccountInfo OPTIONAL,
    SAMP_OBJECT_TYPE            ObjectType
    )

/*++

Routine Description:

    This routines updates the cached display information to reflect
    changes to a single account.

    If any error occurs, this routine marks the cached information
    Invalid so it will get fixed during re-creation.

    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().

Parameters:

    OldAccountInfo - The old information for this account. If this is NULL
                     then the account is being added.
                     The only fields required in the OldAccountInfo are
                        Name
                        AccountControl
                        Rid

    NewAccountInfo - The new information for this account. If this is NULL
                     then the account is being deleted.


    ObjectType - Indicates whether the account is a user account or
        group account.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_DEFINED_DOMAINS Domain;
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation;
    BOOLEAN DoUpdate;

    ASSERT( ARGUMENT_PRESENT(OldAccountInfo) ||
            ARGUMENT_PRESENT(NewAccountInfo)
            );

    ASSERT( !SampUseDsData );

    ASSERT(SampTransactionWithinDomain == TRUE);


    if (!(IsDsObject(SampDefinedDomains[SampTransactionDomainIndex].Context)))
    {

        Domain = &SampDefinedDomains[SampTransactionDomainIndex];
        DisplayInformation = &Domain->DisplayInformation;


        IF_SAMP_GLOBAL( DISPLAY_CACHE ) {

            if (ARGUMENT_PRESENT(OldAccountInfo) && ARGUMENT_PRESENT(NewAccountInfo)) {
                SampDiagPrint(DISPLAY_CACHE,
                    ("SAM: UpdateDisplayInformation : Updating cache for old account <%wZ>, new <%wZ>\n",
                                &OldAccountInfo->Name, &NewAccountInfo->Name));
            }
            if (!ARGUMENT_PRESENT(OldAccountInfo) && ARGUMENT_PRESENT(NewAccountInfo)) {
                SampDiagPrint(DISPLAY_CACHE,
                    ("SAM: UpdateDisplayInformation : Adding account <%wZ> to cache\n",
                                &NewAccountInfo->Name));
            }
            if (ARGUMENT_PRESENT(OldAccountInfo) && !ARGUMENT_PRESENT(NewAccountInfo)) {
                SampDiagPrint(DISPLAY_CACHE,
                    ("SAM: UpdateDisplayInformation : Deleting account <%wZ> from cache\n",
                                &OldAccountInfo->Name));
            }
        } //end_IF_SAMP_GLOBAL


        switch (ObjectType) {

        case SampUserObjectType:

            //
            // If the cache is Invalid there's nothing to do
            //

            if (!DisplayInformation->UserAndMachineTablesValid) {

                SampDiagPrint(DISPLAY_CACHE,
                    ("SAM: UpdateDisplayInformation : User Cache is Invalid, nothing to do\n"));

                return(STATUS_SUCCESS);
            };


            //
            // If this is an update to an existing account then try
            // to do an inplace update of the cache.
            // If this fails because it's too complex etc, then revert to
            // the less efficient method of deleting the old, then adding the new.
            //

            DoUpdate = FALSE;
            if (ARGUMENT_PRESENT(OldAccountInfo) && ARGUMENT_PRESENT(NewAccountInfo)) {

                //
                // We can only do an update if both old and new accounts
                // are types that we keep in the display cache.
                //

                if ( DISPLAY_ACCOUNT(OldAccountInfo->AccountControl) &&
                     DISPLAY_ACCOUNT(NewAccountInfo->AccountControl) ) {

                    //
                    // We can only do an update if the account is still of
                    // the same type. i.e. it hasn't jumped cache table.
                    //

                    if ( (USER_ACCOUNT(OldAccountInfo->AccountControl) ==
                          USER_ACCOUNT(NewAccountInfo->AccountControl)) &&
                         (MACHINE_ACCOUNT(OldAccountInfo->AccountControl) ==
                          MACHINE_ACCOUNT(NewAccountInfo->AccountControl)) ) {

                        //
                        // We can only do an update if the account name hasn't changed
                        //

                        if (RtlEqualUnicodeString( &OldAccountInfo->Name,
                                                   &NewAccountInfo->Name,
                                                   FALSE // Case sensitive
                                                   )) {
                            //
                            // Everything has been checked out - we can do an update
                            //

                            DoUpdate = TRUE;
                        }
                    }
                }
            }

            break;  // out of switch

        case SampGroupObjectType:

            //
            // If the cache is already Invalid there's nothing to do
            //

            if (!DisplayInformation->GroupTableValid) {

                SampDiagPrint(DISPLAY_CACHE,
                    ("SAM: UpdateDisplayInformation : Group Cache is Invalid, nothing to do\n"));

                return(STATUS_SUCCESS);
            };


            //
            // If this is an update to an existing account then try
            // and do an inplace update of the cache.
            // If this fails because it's too complex etc, then revert to
            // the less efficient method of deleting the old, then adding the new.
            //

            DoUpdate = FALSE;
            if (ARGUMENT_PRESENT(OldAccountInfo) && ARGUMENT_PRESENT(NewAccountInfo)) {

                //
                // We can only do an update if the account name hasn't changed
                //

                if (RtlEqualUnicodeString( &OldAccountInfo->Name,
                                          &NewAccountInfo->Name,
                                          FALSE // Case sensitive
                                          )) {
                    DoUpdate = TRUE;
                }
            }

            break;  // out of switch

        default:

            ASSERT(FALSE && "Invalide SAM ObjectType for DisplayInfo\n");
            return(STATUS_INTERNAL_ERROR);

        }


        //
        // Do an update if possible, otherwise do delete then insert
        //

        if (DoUpdate) {

            NtStatus = SampUpdateDisplayAccount(DisplayInformation,
                                                ObjectType,
                                                NewAccountInfo);

        } else {

            NtStatus = STATUS_SUCCESS;

            //
            // Delete the old account
            //

            if (ARGUMENT_PRESENT(OldAccountInfo)) {
                NtStatus = SampDeleteDisplayAccount(DisplayInformation,
                                                    ObjectType,
                                                    OldAccountInfo);
            }

            //
            // Add the new account
            //

            if (NT_SUCCESS(NtStatus) && ARGUMENT_PRESENT(NewAccountInfo)) {
                NtStatus = SampAddDisplayAccount(DisplayInformation,
                                                 ObjectType,
                                                 NewAccountInfo);
            }

            //
            // Re-tally the cache
            //

            if (NT_SUCCESS(NtStatus)) {
                NtStatus = SampTallyTableStatistics(DisplayInformation, ObjectType);
            }
        }



        if (!NT_SUCCESS(NtStatus)) {

            //
            // Something is messed up.
            // Mark the cache Invalid - it will get rebuilt from scratch
            // at the next query.
            //

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAM: The display cache is inconsistent, forcing rebuild\n"));

            NtStatus = SampMarkDisplayInformationInvalid(ObjectType);
            ASSERT(NT_SUCCESS(NtStatus));

            NtStatus = STATUS_SUCCESS;
        }
    }


    return(NtStatus);
}





///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines available within this module only                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////




NTSTATUS
SampDeleteDisplayAccount (
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    SAMP_OBJECT_TYPE ObjectType,
    PSAMP_ACCOUNT_DISPLAY_INFO AccountInfo
    )

/*++

Routine Description:

    This routines deletes the specified account from the cached display
    information. It is asummed that if this account is a cached type it
    will appear in the appropriate cache table.

Parameters:

    DisplayInformation - Pointer to cached display information

    ObjectType - Indicates which table(s) to look for the account in.

    AccountInfo - The account to be deleted.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_INTERNAL_ERROR - the account is a cached type yet could not be
                            found in the cached data.
--*/
{
    NTSTATUS NtStatus;
    ULONG Control = AccountInfo->AccountControl;
    BOOLEAN Success;

    //
    // We expect the cache to be valid
    //
#if DBG
    switch (ObjectType) {
    case SampUserObjectType:
        ASSERT(DisplayInformation->UserAndMachineTablesValid);
        break;  //out of switch

    case SampGroupObjectType:
        ASSERT(DisplayInformation->GroupTableValid);
        break;  //out of switch
    }
#endif //DBG


    SampDiagPrint(DISPLAY_CACHE,
        ("SAM: DeleteDisplayAccount : Deleting account <%wZ>\n", &AccountInfo->Name));



    switch (ObjectType) {
    case SampUserObjectType:

        if (USER_ACCOUNT(Control)) {

            DOMAIN_DISPLAY_USER LocalUserInfo;
            PDOMAIN_DISPLAY_USER UserInfo;
            PDOMAIN_DISPLAY_USER TempUserInfo = NULL;

            SampDiagPrint(DISPLAY_CACHE,
                ("SAM: DeleteDisplayAccount : Deleting account from user table\n"));

            UserInfo = &LocalUserInfo;
            NtStatus = SampInitializeUserInfo(AccountInfo, &UserInfo, FALSE);
            if (NT_SUCCESS(NtStatus)) {
                //
                //     First, lookup the account from the cached table,
                //     get the reference to the data. If the lookup failed,
                //     that means the account is a cached type, but can not
                //     been found in the table, return STATUS_INTERNAL_wERROR.
                //
                //     If the lookup succeeded, then delete the reference
                //     to the account data from both the user table and Rid
                //     table.
                //
                //     At the end, free the memory of the account data.
                //
                //     (We should do the same thing for other Cached
                //      Display Types.)
                //
                //
                TempUserInfo = RtlLookupElementGenericTable2(
                                &DisplayInformation->UserTable,
                                (PVOID)UserInfo);

                //
                // Delete the account reference from the user table
                //
                Success = RtlDeleteElementGenericTable2(
                                        &DisplayInformation->UserTable,
                                        (PVOID)UserInfo);
                if (!Success) {
                    SampDiagPrint(DISPLAY_CACHE,
                       ("SAM: DeleteDisplayAccount : Failed to delete element from user table\n"));
                    ASSERT(FALSE);
                    NtStatus = STATUS_INTERNAL_ERROR;

                } else {

                    //
                    // Now remove reference from the RID table
                    //

                    Success = RtlDeleteElementGenericTable2(
                                    &DisplayInformation->RidTable,
                                    (PVOID)UserInfo);

                    if (!Success) {
                        SampDiagPrint(DISPLAY_CACHE,
                            ("SAM: DeleteDisplayAccount : Failed to delete element from RID table\n"));
                        NtStatus = STATUS_INTERNAL_ERROR;
                           ASSERT(Success);
                       } else
                    {
                        //
                        // Successfully remove references from both
                        // user table and Rid table, safe to free the
                        // memory.
                        //
                        if (TempUserInfo != NULL)
                        {
                            SampFreeUserInfo(TempUserInfo);
                            MIDL_user_free(TempUserInfo);
                            TempUserInfo = NULL;
                        }
                    }
                }

            }


        } else if (MACHINE_ACCOUNT(Control)) {

            DOMAIN_DISPLAY_MACHINE LocalMachineInfo;
            PDOMAIN_DISPLAY_MACHINE MachineInfo;
            PDOMAIN_DISPLAY_MACHINE TempMachineInfo = NULL;

            SampDiagPrint(DISPLAY_CACHE,
                ("SAM: DeleteDisplayAccount : Deleting account from machine table\n"));

            MachineInfo = &LocalMachineInfo;
            NtStatus = SampInitializeMachineInfo(AccountInfo, &MachineInfo, FALSE);
            if (NT_SUCCESS(NtStatus)) {

                TempMachineInfo = RtlLookupElementGenericTable2(
                                    &DisplayInformation->MachineTable,
                                    (PVOID)MachineInfo);

                //
                // Delete the account from the machine table
                //

                Success = RtlDeleteElementGenericTable2(
                                            &DisplayInformation->MachineTable,
                                            (PVOID)MachineInfo);
                if (!Success) {
                    SampDiagPrint(DISPLAY_CACHE,
                        ("SAM: DeleteDisplayAccount : Failed to delete element from machine table\n"));
                    ASSERT(FALSE);
                    NtStatus = STATUS_INTERNAL_ERROR;
                } else {

                    //
                    // Now remove it to the RID table
                    //

                    Success = RtlDeleteElementGenericTable2(
                                    &DisplayInformation->RidTable,
                                    (PVOID)MachineInfo);
                    if (!Success) {
                        SampDiagPrint(DISPLAY_CACHE,
                            ("SAM: DeleteDisplayAccount : Failed to delete element from RID table\n"));
                        NtStatus = STATUS_INTERNAL_ERROR;
                        ASSERT(Success);
                    } else
                    {
                        if (TempMachineInfo != NULL)
                        {
                            SampFreeMachineInfo( TempMachineInfo );
                            MIDL_user_free( TempMachineInfo );
                            TempMachineInfo = NULL;
                        }
                    }
                }
            }

        } else if (INTERDOMAIN_ACCOUNT(Control)) {

            //
            // Interdomain account
            //

            DOMAIN_DISPLAY_MACHINE LocalInterdomainInfo;
            PDOMAIN_DISPLAY_MACHINE InterdomainInfo;
            PDOMAIN_DISPLAY_MACHINE TempInterdomainInfo = NULL;

            SampDiagPrint(DISPLAY_CACHE,
                ("SAM: DeleteDisplayAccount : Deleting account from Interdomain table\n"));

            InterdomainInfo = &LocalInterdomainInfo;
            NtStatus = SampInitializeMachineInfo(AccountInfo, &InterdomainInfo, FALSE);
            if (NT_SUCCESS(NtStatus)) {

                TempInterdomainInfo = RtlLookupElementGenericTable2(
                                        &DisplayInformation->InterdomainTable,
                                        (PVOID)InterdomainInfo);

                //
                // Delete the account from the Interdomain table
                //

                Success = RtlDeleteElementGenericTable2(
                                            &DisplayInformation->InterdomainTable,
                                            (PVOID)InterdomainInfo);
                if (!Success) {
                    SampDiagPrint(DISPLAY_CACHE,
                        ("SAM: DeleteDisplayAccount : Failed to delete element from Interdomain table\n"));
                    ASSERT(FALSE);
                    NtStatus = STATUS_INTERNAL_ERROR;
                } else {

                    //
                    // Now remove it to the RID table
                    //

                    Success = RtlDeleteElementGenericTable2(
                                    &DisplayInformation->RidTable,
                                    (PVOID)InterdomainInfo);
                    if (!Success) {
                        SampDiagPrint(DISPLAY_CACHE,
                            ("SAM: DeleteDisplayAccount : Failed to delete element from RID table\n"));
                        NtStatus = STATUS_INTERNAL_ERROR;
                        ASSERT(Success);
                    } else
                    {
                        if (TempInterdomainInfo != NULL)
                        {
                            SampFreeMachineInfo( TempInterdomainInfo );
                            MIDL_user_free( TempInterdomainInfo );
                            TempInterdomainInfo = NULL;
                        }
                    }
                }
            }

        } else {

            //
            // This account is not one that we cache - nothing to do
            //

            NtStatus = STATUS_SUCCESS;

            SampDiagPrint(DISPLAY_CACHE,
                ("SAM: DeleteDisplayAccount : Account is not one that we cache, account control = 0x%lx\n", Control));
        }


        break;  //out of switch





    case SampGroupObjectType:

        {

            DOMAIN_DISPLAY_GROUP LocalGroupInfo;
            PDOMAIN_DISPLAY_GROUP GroupInfo;
            PDOMAIN_DISPLAY_GROUP TempGroupInfo = NULL;

            SampDiagPrint(DISPLAY_CACHE,
                ("SAM: DeleteDisplayAccount : Deleting account from Group table\n"));

            GroupInfo = &LocalGroupInfo;
            NtStatus = SampInitializeGroupInfo(AccountInfo, &GroupInfo, FALSE);
            if (NT_SUCCESS(NtStatus)) {

                TempGroupInfo = RtlLookupElementGenericTable2(
                                        &DisplayInformation->GroupTable,
                                        (PVOID)GroupInfo);

                //
                // Delete the account from the Group table
                //

                Success = RtlDeleteElementGenericTable2(
                                            &DisplayInformation->GroupTable,
                                            (PVOID)GroupInfo);
                if (!Success) {
                    SampDiagPrint(DISPLAY_CACHE,
                        ("SAM: DeleteDisplayAccount : Failed to delete element from Group table\n"));
                    ASSERT(FALSE);
                    NtStatus = STATUS_INTERNAL_ERROR;
                } else {

                    //
                    // Now remove it to the RID table
                    //

                    Success = RtlDeleteElementGenericTable2(
                                    &DisplayInformation->RidTable,
                                    (PVOID)GroupInfo);
                    if (!Success) {
                        SampDiagPrint(DISPLAY_CACHE,
                            ("SAM: DeleteDisplayAccount : Failed to delete element from RID table\n"));
                        NtStatus = STATUS_INTERNAL_ERROR;
                        ASSERT(Success);
                    }else
                    {
                        if (TempGroupInfo != NULL)
                        {
                            SampFreeGroupInfo( TempGroupInfo );
                            MIDL_user_free( TempGroupInfo );
                            TempGroupInfo = NULL;
                        }
                    }

                }
            }

            break;  //out of switch
        }

    }


    return(STATUS_SUCCESS);
}



NTSTATUS
SampAddDisplayAccount (
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    SAMP_OBJECT_TYPE ObjectType,
    PSAMP_ACCOUNT_DISPLAY_INFO AccountInfo
    )

/*++

Routine Description:

    This routines adds the specified account to the cached display
    information as appropriate to its type.

Parameters:

    DisplayInformation - Pointer to cached display information

    ObjectType - SampUserObjectType or SampGroupObjectType.  Helps
        determine which table it goes into.

    AccountInfo - The account to be added.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

    STATUS_INTERNAL_ERROR - the account already existed in the cache
--*/
{
    NTSTATUS
        NtStatus;

    ULONG
        Control = AccountInfo->AccountControl;

    BOOLEAN
        NewElement;


    if (ObjectType == SampGroupObjectType) {

        PDOMAIN_DISPLAY_GROUP GroupInfo;

        SampDiagPrint(DISPLAY_CACHE,
            ("SAM: AddDisplayAccount : Adding account to group table\n"));

        NtStatus = SampInitializeGroupInfo(AccountInfo, &GroupInfo, TRUE);
        if (NT_SUCCESS(NtStatus)) {

            //
            // Add the account to the Group table
            //

            (VOID)RtlInsertElementGenericTable2(
                            &DisplayInformation->GroupTable,
                            GroupInfo,
                            &NewElement);
            if (!NewElement) {
                SampDiagPrint(DISPLAY_CACHE_ERRORS,
                    ("SAM: AddDisplayAccount : Account already exists in GROUP table\n"));
                ASSERT(FALSE);
                SampFreeGroupInfo(GroupInfo);
                MIDL_user_free(GroupInfo);
                GroupInfo = NULL;
                NtStatus = STATUS_INTERNAL_ERROR;
            } else {

                //
                // Now add it to the RID table
                //

                (VOID)RtlInsertElementGenericTable2(
                                &DisplayInformation->RidTable,
                                GroupInfo,
                                &NewElement);
                if (!NewElement) {
                    SampDiagPrint(DISPLAY_CACHE_ERRORS,
                        ("SAM: AddDisplayAccount : Account already exists in RID table\n"));
                    NtStatus = STATUS_INTERNAL_ERROR;
                    ASSERT(NewElement);
                }

            }
        }

    } else {

        ASSERT(ObjectType == SampUserObjectType);

        if (USER_ACCOUNT(Control)) {

            PDOMAIN_DISPLAY_USER UserInfo;

            SampDiagPrint(DISPLAY_CACHE,
                ("SAM: AddDisplayAccount : Adding account to user table\n"));

            NtStatus = SampInitializeUserInfo(AccountInfo, &UserInfo, TRUE);
            if (NT_SUCCESS(NtStatus)) {

                //
                // Add the account to the normal user table
                //

                (VOID)RtlInsertElementGenericTable2(
                                &DisplayInformation->UserTable,
                                UserInfo,
                                &NewElement);
                if (!NewElement) {
                    SampDiagPrint(DISPLAY_CACHE_ERRORS,
                        ("SAM: AddDisplayAccount : Account already exists in USER table\n"));
                    ASSERT(FALSE);
                    SampFreeUserInfo(UserInfo);
                    MIDL_user_free(UserInfo);
                    UserInfo = NULL;
                    NtStatus = STATUS_INTERNAL_ERROR;
                } else {

                    //
                    // Now add it to the RID table
                    //

                    (VOID)RtlInsertElementGenericTable2(
                                    &DisplayInformation->RidTable,
                                    UserInfo,
                                    &NewElement);

                    if (!NewElement) {
                        SampDiagPrint(DISPLAY_CACHE_ERRORS,
                            ("SAM: AddDisplayAccount : Account already exists in RID table\n"));
                        NtStatus = STATUS_INTERNAL_ERROR;
                    }

                }
            }

        } else if (MACHINE_ACCOUNT(Control)) {

            PDOMAIN_DISPLAY_MACHINE MachineInfo;

            SampDiagPrint(DISPLAY_CACHE,
                ("SAM: AddDisplayAccount : Adding account to machine table\n"));

            NtStatus = SampInitializeMachineInfo(AccountInfo, &MachineInfo, TRUE);
            if (NT_SUCCESS(NtStatus)) {

                //
                // Add the account to the machine table
                //

                (VOID)RtlInsertElementGenericTable2(
                                &DisplayInformation->MachineTable,
                                MachineInfo,
                                &NewElement);
                if (!NewElement) {
                    SampDiagPrint(DISPLAY_CACHE,
                        ("SAM: AddDisplayAccount : Account already exists in MACHINE table\n"));
                    ASSERT(FALSE);
                    SampFreeMachineInfo(MachineInfo);
                    MIDL_user_free(MachineInfo);
                    MachineInfo = NULL;
                    NtStatus = STATUS_INTERNAL_ERROR;
                } else {

                    //
                    // Now add it to the RID table
                    //

                    (VOID)RtlInsertElementGenericTable2(
                                    &DisplayInformation->RidTable,
                                    MachineInfo,
                                    &NewElement);

                    if (!NewElement) {
                        SampDiagPrint(DISPLAY_CACHE,
                            ("SAM: AddDisplayAccount : Account already exists in RID table\n"));
                        ASSERT(NewElement);
                        NtStatus = STATUS_INTERNAL_ERROR;
                    }

                }
            }
        } else if (INTERDOMAIN_ACCOUNT(Control)) {

            PDOMAIN_DISPLAY_MACHINE InterdomainInfo;

            SampDiagPrint(DISPLAY_CACHE,
                ("SAM: AddDisplayAccount : Adding account to Interdomain table\n"));

            NtStatus = SampInitializeMachineInfo(AccountInfo, &InterdomainInfo, TRUE);
            if (NT_SUCCESS(NtStatus)) {

                //
                // Add the account to the Interdomain table
                //

                (VOID)RtlInsertElementGenericTable2(
                                &DisplayInformation->InterdomainTable,
                                InterdomainInfo,
                                &NewElement);
                if (!NewElement) {
                    SampDiagPrint(DISPLAY_CACHE,
                        ("SAM: AddDisplayAccount : Account already exists in Interdomain table\n"));
                    ASSERT(FALSE);
                    SampFreeMachineInfo(InterdomainInfo);
                    MIDL_user_free(InterdomainInfo);
                    InterdomainInfo = NULL;
                    NtStatus = STATUS_INTERNAL_ERROR;
                } else {

                    //
                    // Now add it to the RID table
                    //

                    (VOID)RtlInsertElementGenericTable2(
                                    &DisplayInformation->RidTable,
                                    InterdomainInfo,
                                    &NewElement);

                    if (!NewElement) {
                        SampDiagPrint(DISPLAY_CACHE,
                            ("SAM: AddDisplayAccount : Account already exists in RID table\n"));
                        ASSERT(NewElement);
                        NtStatus = STATUS_INTERNAL_ERROR;
                    }

                }
            }

        } else {

            //
            // This account is not one that we cache - nothing to do
            //

            SampDiagPrint(DISPLAY_CACHE,
                ("SAM: AddDisplayAccount : Account is not one that we cache, account control = 0x%lx\n", Control));

            NtStatus = STATUS_SUCCESS;
        }
    }

    return(NtStatus);
}



NTSTATUS
SampUpdateDisplayAccount(
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    SAMP_OBJECT_TYPE ObjectType,
    PSAMP_ACCOUNT_DISPLAY_INFO  AccountInfo
    )

/*++

Routine Description:

    This routines attempts to update an account in the display cache.

    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseWriteLock().

Parameters:

    DisplayInformation - Pointer to cached display information

    ObjectType - Indicates whether the account is a user account or
        group account.

    AccountInfo - The new information for this account.

Return Values:

    STATUS_SUCCESS - normal, successful completion.


Notes:

    The account must be a cached type (MACHINE/USER/GROUP)

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    SampDiagPrint(DISPLAY_CACHE,
        ("SAM: UpdateDisplayAccount : Updating cached account <%wZ>\n",
        &AccountInfo->Name));

#if SAMP_DIAGNOSTICS
    {
        UNICODE_STRING
            SampDiagAccountName;

        RtlInitUnicodeString( &SampDiagAccountName, L"SAMP_DIAG" );

        if (RtlEqualUnicodeString(&AccountInfo->Name, &SampDiagAccountName, FALSE)) {
            SampDisplayDiagnostic();
        }

    }
#endif //SAMP_DIAGNOSTICS


    //
    // We should only be called when the cache is valid.
    //

    switch (ObjectType) {
    case SampUserObjectType:

        ASSERT(DisplayInformation->UserAndMachineTablesValid);

        //
        // The account must be one that we cache
        //

        ASSERT( DISPLAY_ACCOUNT(AccountInfo->AccountControl) );

        //
        // Go find the account in the appropriate table and update it's fields.
        //

        if (USER_ACCOUNT(AccountInfo->AccountControl)) {

            PDOMAIN_DISPLAY_USER UserInfo;

            //
            // Allocate space for and initialize the new data
            //

            NtStatus = SampInitializeUserInfo(AccountInfo, &UserInfo, TRUE);
            if (NT_SUCCESS(NtStatus)) {

                PDOMAIN_DISPLAY_USER FoundElement;

                //
                // Search for the account in the user table
                //

                FoundElement = RtlLookupElementGenericTable2(
                                &DisplayInformation->UserTable,
                                UserInfo);

                if (FoundElement == NULL) {
                    SampDiagPrint(DISPLAY_CACHE,
                        ("SAM: UpdateDisplayAccount : Account <%wZ> not found in user table\n", &AccountInfo->Name));
                    ASSERT(FALSE);
                    SampFreeUserInfo(UserInfo);
                    MIDL_user_free(UserInfo);
                    UserInfo = NULL;
                    NtStatus = STATUS_INTERNAL_ERROR;

                } else {

                    //
                    // We found it. Check the old and new match where we expect.
                    // Can't change either the logon name or RID by this routine.
                    //

                    ASSERT(RtlEqualUnicodeString(&FoundElement->LogonName, &UserInfo->LogonName, FALSE));
                    ASSERT(FoundElement->Rid == UserInfo->Rid);

                    //
                    // Free up the existing data in the account element
                    // (all the strings) and replace it with the new data.
                    // Don't worry about the index value.  It isn't
                    // valid in the table.
                    //

                    SampSwapUserInfo(FoundElement, UserInfo);
                    SampFreeUserInfo(UserInfo);
                    MIDL_user_free(UserInfo);
                    UserInfo = NULL;
                }
            }

        } else if (MACHINE_ACCOUNT(AccountInfo->AccountControl)) {

            PDOMAIN_DISPLAY_MACHINE MachineInfo;

            //
            // Allocate space for and initialize the new data
            //

            NtStatus = SampInitializeMachineInfo(AccountInfo, &MachineInfo, TRUE);
            if (NT_SUCCESS(NtStatus)) {

                PDOMAIN_DISPLAY_MACHINE FoundElement;

                //
                // Search for the account in the user table
                //

                FoundElement = RtlLookupElementGenericTable2(
                                &DisplayInformation->MachineTable,
                                MachineInfo);

                if (FoundElement == NULL) {
                    SampDiagPrint(DISPLAY_CACHE,
                        ("SAM: UpdateDisplayAccount : Account <%wZ> not found in machine table\n", &AccountInfo->Name));
                    ASSERT(FALSE);
                    SampFreeMachineInfo(MachineInfo);
                    MIDL_user_free(MachineInfo);
                    MachineInfo = NULL;
                    NtStatus = STATUS_INTERNAL_ERROR;

                } else {

                    //
                    // We found it. Check the old and new match where we expect.
                    // Can't change either the account name or RID by this routine.
                    //

                    ASSERT(RtlEqualUnicodeString(&FoundElement->Machine, &MachineInfo->Machine, FALSE));
                    ASSERT(FoundElement->Rid == MachineInfo->Rid);

                    //
                    // Free up the existing data in the account element
                    // (all the strings) and replace it with the new data.
                    // Don't worry about the index value.  It isn't
                    // valid in the table.
                    //

                    SampSwapMachineInfo(FoundElement, MachineInfo);
                    SampFreeMachineInfo(MachineInfo);
                    MIDL_user_free(MachineInfo);
                    MachineInfo = NULL;
                }
            }

        } else if (INTERDOMAIN_ACCOUNT(AccountInfo->AccountControl)) {

            PDOMAIN_DISPLAY_MACHINE InterdomainInfo;

            //
            // Allocate space for and initialize the new data
            //

            NtStatus = SampInitializeMachineInfo(AccountInfo, &InterdomainInfo, TRUE);
            if (NT_SUCCESS(NtStatus)) {

                PDOMAIN_DISPLAY_MACHINE FoundElement;

                //
                // Search for the account in the user table
                //

                FoundElement = RtlLookupElementGenericTable2(
                                &DisplayInformation->InterdomainTable,
                                InterdomainInfo);

                if (FoundElement == NULL) {
                    SampDiagPrint(DISPLAY_CACHE,
                        ("SAM: UpdateDisplayAccount : Account <%wZ> not found in Interdomain table\n", &AccountInfo->Name));
                    ASSERT(FALSE);
                    SampFreeMachineInfo(InterdomainInfo);
                    MIDL_user_free(InterdomainInfo);
                    InterdomainInfo = NULL;
                    NtStatus = STATUS_INTERNAL_ERROR;

                } else {

                    //
                    // We found it. Check the old and new match where we expect.
                    // Can't change either the account name or RID by this routine.
                    //

                    ASSERT(RtlEqualUnicodeString(&FoundElement->Machine, &InterdomainInfo->Machine, FALSE));
                    ASSERT(FoundElement->Rid == InterdomainInfo->Rid);

                    //
                    // Free up the existing data in the account element
                    // (all the strings) and replace it with the new data.
                    // Don't worry about the index value.  It isn't
                    // valid in the table.
                    //

                    SampSwapMachineInfo(FoundElement, InterdomainInfo);
                    SampFreeMachineInfo(InterdomainInfo);
                    MIDL_user_free(InterdomainInfo);
                    InterdomainInfo = NULL;
                }
            }
        }


        break;  // out of switch

    case SampGroupObjectType:
        {
            PDOMAIN_DISPLAY_GROUP GroupInfo;

            ASSERT(DisplayInformation->GroupTableValid);

            //
            // Allocate space for and initialize the new data
            //

            NtStatus = SampInitializeGroupInfo(AccountInfo, &GroupInfo, TRUE);
            if (NT_SUCCESS(NtStatus)) {

                PDOMAIN_DISPLAY_GROUP FoundElement;

                //
                // Search for the account in the group table
                //

                FoundElement = RtlLookupElementGenericTable2(
                                &DisplayInformation->GroupTable,
                                GroupInfo);

                if (FoundElement == NULL) {
                    SampDiagPrint(DISPLAY_CACHE,
                        ("SAM: UpdateDisplayAccount : Account <%wZ> not found in group table\n", &AccountInfo->Name));
                    ASSERT(FALSE);
                    SampFreeGroupInfo(GroupInfo);
                    MIDL_user_free(GroupInfo);
                    GroupInfo = NULL;
                    NtStatus = STATUS_INTERNAL_ERROR;

                } else {

                    //
                    // We found it. Check the old and new match where we expect.
                    // Can't change either the account name or RID by this routine.
                    //

                    ASSERT(RtlEqualUnicodeString(&FoundElement->Group, &GroupInfo->Group, FALSE));
                    ASSERT(FoundElement->Rid == GroupInfo->Rid);

                    //
                    // Free up the existing data in the account element
                    // (all the strings) and replace it with the new data.
                    // Don't worry about the index value.  It isn't
                    // valid in the table.
                    //

                    SampSwapGroupInfo(FoundElement, GroupInfo);
                    SampFreeGroupInfo(GroupInfo);
                    MIDL_user_free(GroupInfo);
                    GroupInfo = NULL;
                }
            }
        }

        break;  // out of switch

    }  // end_switch



    return(NtStatus);
}



NTSTATUS
SampTallyTableStatistics (
    PSAMP_DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    SAMP_OBJECT_TYPE ObjectType
    )

/*++

Routine Description:

    This routines runs through the cached data tables and totals
    up the number of bytes in all elements of each table and stores
    in the displayinfo.

Parameters:

    DisplayInformation - The display information structure to tally.

    ObjectType - Indicates which table(s) to tally.

Return Values:

    STATUS_SUCCESS - normal, successful completion.

--*/
{
    PVOID Node;
    PVOID RestartKey;


    switch (ObjectType) {
    case SampUserObjectType:

        DisplayInformation->TotalBytesInUserTable = 0;
        RestartKey = NULL;

        for (Node = RtlEnumerateGenericTable2(  &DisplayInformation->UserTable,
                                                &RestartKey);
             Node != NULL;
             Node = RtlEnumerateGenericTable2(  &DisplayInformation->UserTable,
                                                &RestartKey)
            ) {

            DisplayInformation->TotalBytesInUserTable +=
                SampBytesRequiredUserNode((PDOMAIN_DISPLAY_USER)Node);
        }

        DisplayInformation->TotalBytesInMachineTable = 0;
        RestartKey = NULL;

        for (Node = RtlEnumerateGenericTable2(  &DisplayInformation->MachineTable,
                                                &RestartKey);
             Node != NULL;
             Node = RtlEnumerateGenericTable2(  &DisplayInformation->MachineTable,
                                                &RestartKey)
            ) {


            DisplayInformation->TotalBytesInMachineTable +=
                SampBytesRequiredMachineNode((PDOMAIN_DISPLAY_MACHINE)Node);
        }

        break;  // out of switch


    case SampGroupObjectType:

        DisplayInformation->TotalBytesInGroupTable = 0;
        RestartKey = NULL;

        for (Node = RtlEnumerateGenericTable2(  &DisplayInformation->GroupTable,
                                                &RestartKey);
             Node != NULL;
             Node = RtlEnumerateGenericTable2(  &DisplayInformation->GroupTable,
                                                &RestartKey)
            ) {


            DisplayInformation->TotalBytesInGroupTable +=
                SampBytesRequiredGroupNode((PDOMAIN_DISPLAY_GROUP)Node);
        }

        break;  // out of switch

    } // end_switch
    return(STATUS_SUCCESS);
}



NTSTATUS
SampEmptyGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    BOOLEAN FreeElements,
    SAMP_OBJECT_TYPE ObjectType OPTIONAL
    )

/*++

Routine Description:

    This routines deletes all elements in the specified table.

Parameters:

    Table - The table whose elements are to be deleted.

    FreeElements - Indicates whether or not the element bodies
        should also be freed.

    ObjectType -- Indicates the account type. Only used when FreeElements is TRUE

Return Values:

    STATUS_SUCCESS - normal, successful completion.

--*/
{
    BOOLEAN     Deleted;
    PVOID       Element;
    PVOID       RestartKey;

    RestartKey = NULL;  // Always get the first element
    while ((Element = RtlEnumerateGenericTable2( Table, (PVOID *)&RestartKey)) != NULL) {

        Deleted = RtlDeleteElementGenericTable2(Table, Element);
        ASSERT(Deleted);

        if (FreeElements) {

            //
            // If caller asks us to free the Data, we should
            // first free account specified infomation,
            // then free the element structure.
            //

            switch (ObjectType)
            {
            case SampUserObjectType:

                if (USER_ACCOUNT(((PDOMAIN_DISPLAY_USER) Element)->AccountControl) )
                {
                    SampFreeUserInfo(Element);
                }
                else
                {
                    ASSERT( (MACHINE_ACCOUNT(((PDOMAIN_DISPLAY_MACHINE)Element)->AccountControl) ||
                             INTERDOMAIN_ACCOUNT(((PDOMAIN_DISPLAY_MACHINE)Element)->AccountControl)
                            )
                            && "We should not cache this account"
                          );

                    SampFreeMachineInfo(Element);
                }

                break;

            case SampGroupObjectType:

                SampFreeGroupInfo(Element);

                break;

            default:

                ASSERT( FALSE && "We should not cache this account");
            }

            MIDL_user_free(Element);
        }

        RestartKey = NULL;
    }

    return(STATUS_SUCCESS);
}



NTSTATUS
SampInitializeUserInfo(
    PSAMP_ACCOUNT_DISPLAY_INFO AccountInfo,
    PDOMAIN_DISPLAY_USER *UserInfo,
    BOOLEAN CopyData
    )

/*++

Routine Description:

    This routines initializes the passed user info structure from the
    AccountInfo parameter.

Parameters:

    AccountInfo - The account information

    UserInfo - Pointer to the pointer to the user structure to initialize.
        If CopyData is TRUE, then a pointer to the user structure will be
        returned to this argument.

    CopyData - FALSE - the UserInfo structure points to the same data as
                       the AccountInfo structure
               TRUE  - space for the data is allocated and all data copied
                       out of the AccountInfo structure into it.

Return Values:

    STATUS_SUCCESS - UserInfo initialized successfully.

    STATUS_NO_MEMORY - Heap could not be allocated to copy the data.

--*/
{
    NTSTATUS
        NtStatus;

    PDOMAIN_DISPLAY_USER
        UI;

    if (CopyData) {
        (*UserInfo) = MIDL_user_allocate( sizeof(DOMAIN_DISPLAY_USER) );
        if ((*UserInfo) == NULL) {
            SampDiagPrint(DISPLAY_CACHE_ERRORS,
                ("SAM: Init User Info: failed to allocate %d bytes\n",
                 sizeof(DOMAIN_DISPLAY_USER)) );
            return(STATUS_NO_MEMORY);
        }
    }

    UI = (*UserInfo);


    UI->Rid = AccountInfo->Rid;
    UI->AccountControl = AccountInfo->AccountControl;

    if (CopyData) {

        //
        // Set all strings to NULL initially
        //

        RtlInitUnicodeString(&UI->LogonName, NULL);
        RtlInitUnicodeString(&UI->AdminComment, NULL);
        RtlInitUnicodeString(&UI->FullName, NULL);

        //
        // Copy source data into destination
        //

        NtStatus = SampDuplicateUnicodeString(&UI->LogonName,
                                              &AccountInfo->Name);
        if (NT_SUCCESS(NtStatus)) {
            NtStatus = SampDuplicateUnicodeString(&UI->AdminComment,
                                                  &AccountInfo->Comment);
            if (NT_SUCCESS(NtStatus)) {
                NtStatus = SampDuplicateUnicodeString(&UI->FullName,
                                                      &AccountInfo->FullName);
            }
        }

        //
        // Clean up on failure
        //

        if (!NT_SUCCESS(NtStatus)) {
            SampDiagPrint(DISPLAY_CACHE_ERRORS,
                ("SAM: SampInitializeUserInfo failed, status = 0x%lx\n", NtStatus));
            SampFreeUserInfo(UI);
            MIDL_user_free(UI);
            UI = NULL;
        }

    } else {

        //
        // Refer to source data directly
        //

        UI->LogonName = AccountInfo->Name;
        UI->AdminComment = AccountInfo->Comment;
        UI->FullName = AccountInfo->FullName;

        NtStatus = STATUS_SUCCESS;
    }


    //
    // In the Generic Table, the Index field is used to tag the type
    // of account so we can filter enumerations.
    //

    if (NT_SUCCESS(NtStatus))
    {
        UI->Index = SAM_USER_ACCOUNT;
    }

    return(NtStatus);
}



NTSTATUS
SampInitializeMachineInfo(
    PSAMP_ACCOUNT_DISPLAY_INFO AccountInfo,
    PDOMAIN_DISPLAY_MACHINE *MachineInfo,
    BOOLEAN CopyData
    )

/*++

Routine Description:

    This routines initializes the passed machine info structure from the
    AccountInfo parameter.

Parameters:

    AccountInfo - The account information

    MachineInfo - Pointer to the pointer to the Machine structure to initialize.
        If CopyData is TRUE, then a pointer to the structure will be
        returned to this argument.

    CopyData - FALSE - the MachineInfo structure points to the same data as
                       the AccountInfo structure
               TRUE  - space for the data is allocated and all data copied
                       out of the AccountInfo structure into it.

Return Values:

    STATUS_SUCCESS - UserInfo initialized successfully.

--*/
{
    NTSTATUS
        NtStatus;

    PDOMAIN_DISPLAY_MACHINE
        MI;

    if (CopyData) {
        (*MachineInfo) = MIDL_user_allocate( sizeof(DOMAIN_DISPLAY_MACHINE) );
        if ((*MachineInfo) == NULL) {
            SampDiagPrint(DISPLAY_CACHE_ERRORS,
                ("SAM: Init Mach Info: failed to allocate %d bytes\n",
                 sizeof(DOMAIN_DISPLAY_MACHINE)) );
            return(STATUS_NO_MEMORY);
        }
    }

    MI = (*MachineInfo);

    MI->Rid = AccountInfo->Rid;
    MI->AccountControl = AccountInfo->AccountControl;

    if (CopyData) {

        //
        // Set all strings to NULL initially
        //

        RtlInitUnicodeString(&MI->Machine, NULL);
        RtlInitUnicodeString(&MI->Comment, NULL);

        //
        // Copy source data into destination
        //

        NtStatus = SampDuplicateUnicodeString(&MI->Machine,
                                              &AccountInfo->Name);
        if (NT_SUCCESS(NtStatus)) {
            NtStatus = SampDuplicateUnicodeString(&MI->Comment,
                                                  &AccountInfo->Comment);
        }

        //
        // Clean up on failure
        //

        if (!NT_SUCCESS(NtStatus)) {
            SampDiagPrint(DISPLAY_CACHE_ERRORS,
                ("SAM: SampInitializeMachineInfo failed, status = 0x%lx\n", NtStatus));
            SampFreeMachineInfo(MI);
            MIDL_user_free(MI);
            MI = NULL;
        }

    } else {

        //
        // Refer to source data directly
        //

        MI->Machine = AccountInfo->Name;
        MI->Comment = AccountInfo->Comment;

        NtStatus = STATUS_SUCCESS;
    }

    //
    // In the Generic Table, the Index field is used to tag the type
    // of account so we can filter enumerations.
    //

    if (NT_SUCCESS(NtStatus))
    {
        MI->Index = SAM_USER_ACCOUNT;
    }

    return(NtStatus);
}


NTSTATUS
SampInitializeGroupInfo(
    PSAMP_ACCOUNT_DISPLAY_INFO AccountInfo,
    PDOMAIN_DISPLAY_GROUP *GroupInfo,
    BOOLEAN CopyData
    )

/*++

Routine Description:

    This routines initializes the passed Group info structure from the
    AccountInfo parameter.

Parameters:

    AccountInfo - The account information

    GroupInfo - Pointer to the pointer to the Group structure to initialize.
        If CopyData is TRUE, then a pointer to the structure will be
        returned to this argument.

    CopyData - FALSE - the GroupInfo structure points to the same data as
                       the AccountInfo structure
               TRUE  - space for the data is allocated and all data copied
                       out of the AccountInfo structure into it.

Return Values:

    STATUS_SUCCESS - GroupInfo initialized successfully.

--*/
{
    NTSTATUS
        NtStatus;

    PDOMAIN_DISPLAY_GROUP
        GI;

    if (CopyData) {
        (*GroupInfo) = MIDL_user_allocate( sizeof(DOMAIN_DISPLAY_GROUP) );
        if ((*GroupInfo) == NULL) {
            SampDiagPrint(DISPLAY_CACHE_ERRORS,
                ("SAM: Init Group Info: failed to allocate %d bytes\n",
                 sizeof(DOMAIN_DISPLAY_GROUP)) );
            return(STATUS_NO_MEMORY);
        }
    }

    GI = (*GroupInfo);


    GI->Rid = AccountInfo->Rid;
    GI->Attributes = AccountInfo->AccountControl;

    if (CopyData) {

        //
        // Set all strings to NULL initially
        //

        RtlInitUnicodeString(&GI->Group, NULL);
        RtlInitUnicodeString(&GI->Comment, NULL);

        //
        // Copy source data into destination
        //

        NtStatus = SampDuplicateUnicodeString(&GI->Group,
                                              &AccountInfo->Name);
        if (NT_SUCCESS(NtStatus)) {
            NtStatus = SampDuplicateUnicodeString(&GI->Comment,
                                                  &AccountInfo->Comment);
        }

        //
        // Clean up on failure
        //

        if (!NT_SUCCESS(NtStatus)) {
            SampDiagPrint(DISPLAY_CACHE_ERRORS,
                ("SAM: SampInitializeGroupInfo failed, status = 0x%lx\n", NtStatus));
            SampFreeGroupInfo(GI);
            MIDL_user_free(GI);
            GI = NULL;
        }

    } else {

        //
        // Refer to source data directly
        //

        GI->Group = AccountInfo->Name;
        GI->Comment = AccountInfo->Comment;

        NtStatus = STATUS_SUCCESS;
    }

    //
    // In the Generic Table, the Index field is used to tag the type
    // of account so we can filter enumerations.
    //

    if (NT_SUCCESS(NtStatus))
    {
        GI->Index = SAM_GLOBAL_GROUP_ACCOUNT;
    }

    return(NtStatus);
}



NTSTATUS
SampDuplicateUserInfo(
    PDOMAIN_DISPLAY_USER Destination,
    PDOMAIN_DISPLAY_USER Source,
    ULONG                Index
    )

/*++

Routine Description:

    This routine allocates space in the destination and copies over the
    data from the source into it.

Parameters:

    Destination - The structure to copy data into

    Source - The structure containing the data to copy

    Index - This value will be placed in the destination's Index
        field.

Return Values:

    STATUS_SUCCESS - Destination contains a duplicate of the source data.

--*/
{
    NTSTATUS NtStatus;

    Destination->Index = Index;
    Destination->Rid = Source->Rid;
    Destination->AccountControl = Source->AccountControl;

    //
    // Set all strings to NULL initially
    //

    RtlInitUnicodeString(&Destination->LogonName, NULL);
    RtlInitUnicodeString(&Destination->AdminComment, NULL);
    RtlInitUnicodeString(&Destination->FullName, NULL);

    //
    // Copy source data into destination
    //

    NtStatus = SampDuplicateUnicodeString(&Destination->LogonName,
                                          &Source->LogonName);
    if (NT_SUCCESS(NtStatus)) {
        NtStatus = SampDuplicateUnicodeString(&Destination->AdminComment,
                                              &Source->AdminComment);
        if (NT_SUCCESS(NtStatus)) {
            NtStatus = SampDuplicateUnicodeString(&Destination->FullName,
                                                  &Source->FullName);
        }
    }

    //
    // Clean up on failure
    //

    if (!NT_SUCCESS(NtStatus)) {
        SampDiagPrint(DISPLAY_CACHE_ERRORS,
            ("SAM: SampDuplicateUserInfo failed, status = 0x%lx\n", NtStatus));
        SampFreeUserInfo(Destination);

    }

    return(NtStatus);
}



NTSTATUS
SampDuplicateMachineInfo(
    PDOMAIN_DISPLAY_MACHINE Destination,
    PDOMAIN_DISPLAY_MACHINE Source,
    ULONG                   Index
    )

/*++

Routine Description:

    This routine allocates space in the destination and copies over the
    data from the source into it.

Parameters:

    Destination - The structure to copy data into

    Source - The structure containing the data to copy

    Index - This value will be placed in the destination's Index
        field.

Return Values:

    STATUS_SUCCESS - Destination contains a duplicate of the source data.

--*/
{
    NTSTATUS NtStatus;

    Destination->Index = Index;
    Destination->Rid = Source->Rid;
    Destination->AccountControl = Source->AccountControl;

    //
    // Set all strings to NULL initially
    //

    RtlInitUnicodeString(&Destination->Machine, NULL);
    RtlInitUnicodeString(&Destination->Comment, NULL);

    //
    // Copy source data into destination
    //

    NtStatus = SampDuplicateUnicodeString(&Destination->Machine,
                                          &Source->Machine);
    if (NT_SUCCESS(NtStatus)) {
        NtStatus = SampDuplicateUnicodeString(&Destination->Comment,
                                              &Source->Comment);
    }

    //
    // Clean up on failure
    //

    if (!NT_SUCCESS(NtStatus)) {
        SampDiagPrint(DISPLAY_CACHE_ERRORS,
            ("SAM: SampDuplicateMachineInfo failed, status = 0x%lx\n", NtStatus));
        SampFreeMachineInfo(Destination);
    }

    return(NtStatus);
}


NTSTATUS
SampDuplicateGroupInfo(
    PDOMAIN_DISPLAY_GROUP Destination,
    PDOMAIN_DISPLAY_GROUP Source,
    ULONG                 Index
    )

/*++

Routine Description:

    This routine allocates space in the destination and copies over the
    data from the source into it.

Parameters:

    Destination - The structure to copy data into

    Source - The structure containing the data to copy

    Index - This value will be placed in the destination's Index
        field.

Return Values:

    STATUS_SUCCESS - Destination contains a duplicate of the source data.

--*/
{
    NTSTATUS NtStatus;

    Destination->Index = Index;
    Destination->Rid = Source->Rid;
    Destination->Attributes = Source->Attributes;

    //
    // Set all strings to NULL initially
    //

    RtlInitUnicodeString(&Destination->Group, NULL);
    RtlInitUnicodeString(&Destination->Comment, NULL);

    //
    // Copy source data into destination
    //

    NtStatus = SampDuplicateUnicodeString(&Destination->Group,
                                          &Source->Group);
    if (NT_SUCCESS(NtStatus)) {
        NtStatus = SampDuplicateUnicodeString(&Destination->Comment,
                                              &Source->Comment);
    }

    //
    // Clean up on failure
    //

    if (!NT_SUCCESS(NtStatus)) {
        SampDiagPrint(DISPLAY_CACHE_ERRORS,
            ("SAM: SampDuplicateGroupInfo failed, status = 0x%lx\n", NtStatus));
        SampFreeGroupInfo(Destination);
    }

    return(NtStatus);
}



NTSTATUS
SampDuplicateOemUserInfo(
    PDOMAIN_DISPLAY_OEM_USER Destination,
    PDOMAIN_DISPLAY_USER Source,
    ULONG                Index
    )

/*++

Routine Description:

    This routine allocates space in the destination and copies over the
    data from the source into it.

Parameters:

    Destination - The structure to copy data into

    Source - The structure containing the data to copy

    Index - This value will be placed in the destination's Index
        field.

Return Values:

    STATUS_SUCCESS - Destination contains a duplicate of a subset of
        the source data.

--*/
{
    NTSTATUS NtStatus;

    Destination->Index = Index;

    //
    // Set all strings to NULL initially
    //

    RtlInitString(&Destination->User, NULL);


    //
    // Copy source data into destination
    //

    NtStatus = SampUnicodeToOemString(&Destination->User,
                                      &Source->LogonName);

    //
    // Clean up on failure
    //

    if (!NT_SUCCESS(NtStatus)) {
        SampDiagPrint(DISPLAY_CACHE_ERRORS,
            ("SAM: SampDuplicateOemUser failed, status = 0x%lx\n", NtStatus));
        RtlInitString(&Destination->User, NULL);
    }

    return(NtStatus);
}



NTSTATUS
SampDuplicateOemGroupInfo(
    PDOMAIN_DISPLAY_OEM_GROUP Destination,
    PDOMAIN_DISPLAY_GROUP Source,
    ULONG                Index
    )

/*++

Routine Description:

    This routine allocates space in the destination and copies over the
    data from the source into it.

Parameters:

    Destination - The structure to copy data into

    Source - The structure containing the data to copy

    Index - This value will be placed in the destination's Index
        field.

Return Values:

    STATUS_SUCCESS - Destination contains a duplicate of a subset of
        the source data.

--*/
{
    NTSTATUS NtStatus;

    Destination->Index = Index;

    //
    // Set all strings to NULL initially
    //

    RtlInitString(&Destination->Group, NULL);


    //
    // Copy source data into destination
    //

    NtStatus = SampUnicodeToOemString(&Destination->Group,
                                      &Source->Group);

    //
    // Clean up on failure
    //

    if (!NT_SUCCESS(NtStatus)) {
        SampDiagPrint(DISPLAY_CACHE_ERRORS,
            ("SAM: SampDuplicateOemGroup failed, status = 0x%lx\n", NtStatus));
        RtlInitString(&Destination->Group, NULL);
    }

    return(NtStatus);
}



VOID
SampSwapUserInfo(
    PDOMAIN_DISPLAY_USER Info1,
    PDOMAIN_DISPLAY_USER Info2
    )

/*++

Routine Description:

    Swap the field contents of Info1 and Info2.

Parameters:

    Info1 & Info2 - The structures whose contents are to be swapped.


Return Values:

    None

--*/
{

    DOMAIN_DISPLAY_USER
        Tmp;

    Tmp.LogonName      = Info1->LogonName;
    Tmp.AdminComment   = Info1->AdminComment;
    Tmp.FullName       = Info1->FullName;
    Tmp.AccountControl = Info1->AccountControl;

    Info1->LogonName      = Info2->LogonName;
    Info1->AdminComment   = Info2->AdminComment;
    Info1->FullName       = Info2->FullName;
    Info1->AccountControl = Info2->AccountControl;

    Info2->LogonName      = Tmp.LogonName;
    Info2->AdminComment   = Tmp.AdminComment;
    Info2->FullName       = Tmp.FullName;
    Info2->AccountControl = Tmp.AccountControl;

    return;
}


VOID
SampSwapMachineInfo(
    PDOMAIN_DISPLAY_MACHINE Info1,
    PDOMAIN_DISPLAY_MACHINE Info2
    )

/*++

Routine Description:

    Swap the field contents of Info1 and Info2.

Parameters:

    Info1 & Info2 - The structures whose contents are to be swapped.


Return Values:

    None

--*/
{

    DOMAIN_DISPLAY_MACHINE
        Tmp;

    Tmp.Machine        = Info1->Machine;
    Tmp.Comment        = Info1->Comment;
    Tmp.AccountControl = Info1->AccountControl;

    Info1->Machine        = Info2->Machine;
    Info1->Comment        = Info2->Comment;
    Info1->AccountControl = Info2->AccountControl;

    Info2->Machine        = Tmp.Machine;
    Info2->Comment        = Tmp.Comment;
    Info2->AccountControl = Tmp.AccountControl;

    return;
}


VOID
SampSwapGroupInfo(
    PDOMAIN_DISPLAY_GROUP Info1,
    PDOMAIN_DISPLAY_GROUP Info2
    )

/*++

Routine Description:

    Swap the field contents of Info1 and Info2.

Parameters:

    Info1 & Info2 - The structures whose contents are to be swapped.


Return Values:

    None

--*/
{

    DOMAIN_DISPLAY_GROUP
        Tmp;

    Tmp.Group      = Info1->Group;
    Tmp.Comment    = Info1->Comment;
    Tmp.Attributes = Info1->Attributes;

    Info1->Group      = Info2->Group;
    Info1->Comment    = Info2->Comment;
    Info1->Attributes = Info2->Attributes;

    Info2->Group      = Tmp.Group;
    Info2->Comment    = Tmp.Comment;
    Info2->Attributes = Tmp.Attributes;

    return;
}


VOID
SampFreeUserInfo(
    PDOMAIN_DISPLAY_USER UserInfo
    )

/*++

Routine Description:

    Frees data associated with a userinfo structure.

Parameters:

    UserInfo - User structure to free


Return Values:

    None

--*/
{
    SampFreeUnicodeString(&UserInfo->LogonName);
    SampFreeUnicodeString(&UserInfo->AdminComment);
    SampFreeUnicodeString(&UserInfo->FullName);

    return;
}



VOID
SampFreeMachineInfo(
    PDOMAIN_DISPLAY_MACHINE MachineInfo
    )

/*++

Routine Description:

    Frees data associated with a machineinfo structure.

Parameters:

    UserInfo - User structure to free

Return Values:

    None

--*/
{
    SampFreeUnicodeString(&MachineInfo->Machine);
    SampFreeUnicodeString(&MachineInfo->Comment);

    return;
}


VOID
SampFreeGroupInfo(
    PDOMAIN_DISPLAY_GROUP GroupInfo
    )

/*++

Routine Description:

    Frees data associated with a Groupinfo structure.

Parameters:

    UserInfo - User structure to free

Return Values:

    None

--*/
{
    SampFreeUnicodeString(&GroupInfo->Group);
    SampFreeUnicodeString(&GroupInfo->Comment);

    return;
}



VOID
SampFreeOemUserInfo(
    PDOMAIN_DISPLAY_OEM_USER UserInfo
    )

/*++

Routine Description:

    Frees data associated with a UserInfo structure.

Parameters:

    UserInfo - User structure to free


Return Values:

    None

--*/
{
    SampFreeOemString(&UserInfo->User);

    return;
}



VOID
SampFreeOemGroupInfo(
    PDOMAIN_DISPLAY_OEM_GROUP GroupInfo
    )

/*++

Routine Description:

    Frees data associated with a GroupInfo structure.

Parameters:

    GroupInfo - Group structure to free


Return Values:

    None

--*/
{
    SampFreeOemString(&GroupInfo->Group);

    return;
}



ULONG
SampBytesRequiredUserNode (
    PDOMAIN_DISPLAY_USER Node
    )

/*++

Routine Description:

    This routines returns the total number of bytes required to store all
    the elements of the the specified node.

Parameters:

    Node - The node whose size we will return.

Return Values:

    Bytes required by node

--*/
{
    return( sizeof(*Node) +
            Node->LogonName.Length +
            Node->AdminComment.Length +
            Node->FullName.Length
            );
}



ULONG
SampBytesRequiredMachineNode (
    PDOMAIN_DISPLAY_MACHINE Node
    )

/*++

Routine Description:

    This routines returns the total number of bytes required to store all
    the elements of the the specified node.

Parameters:

    Node - The node whose size we will return.

Return Values:

    Bytes required by node

--*/
{
    return( sizeof(*Node) +
            Node->Machine.Length +
            Node->Comment.Length
            );
}


ULONG
SampBytesRequiredGroupNode (
    PDOMAIN_DISPLAY_GROUP Node
    )

/*++

Routine Description:

    This routines returns the total number of bytes required to store all
    the elements of the the specified node.

Parameters:

    Node - The node whose size we will return.

Return Values:

    Bytes required by node

--*/
{
    return( sizeof(*Node) + Node->Group.Length + Node->Comment.Length );
}


ULONG
SampBytesRequiredOemUserNode (
    PDOMAIN_DISPLAY_OEM_USER Node
    )

/*++

Routine Description:

    This routines returns the total number of bytes required to store all
    the elements of the the specified node.

Parameters:

    Node - The node whose size we will return.

Return Values:

    Bytes required by node

--*/
{
    return( sizeof(*Node) + Node->User.Length );
}


ULONG
SampBytesRequiredOemGroupNode (
    PDOMAIN_DISPLAY_OEM_GROUP Node
    )

/*++

Routine Description:

    This routines returns the total number of bytes required to store all
    the elements of the the specified node.

Parameters:

    Node - The node whose size we will return.

Return Values:

    Bytes required by node

--*/
{
    return( sizeof(*Node) + Node->Group.Length );
}



PVOID
SampGenericTable2Allocate (
    CLONG BufferSize
    )

/*++

Routine Description:

    This routine is used by the generic table2 package to allocate
    memory.

Parameters:

    BufferSize - the number of bytes needed.

Return Values:

    Pointer to the allocated memory

--*/
{
    PVOID
        Buffer;

    Buffer = MIDL_user_allocate(BufferSize);
#if DBG
    if (Buffer == NULL) {
        SampDiagPrint( DISPLAY_CACHE_ERRORS,
                       ("SAM: GenTab alloc of %d bytes failed.\n",
                        BufferSize) );
    }
#endif //DBG
    return(Buffer);
}



VOID
SampGenericTable2Free (
    PVOID Buffer
    )

/*++

Routine Description:

    This routines frees memory previously allocated using
    SampGenericTable2Allocate().

Parameters:

    Node - the memory to free.

Return Values:

    None.

--*/
{
    //
    // Free up the base structure
    //

    MIDL_user_free(Buffer);

    return;
}



RTL_GENERIC_COMPARE_RESULTS
SampCompareUserNodeByName (
    PVOID Node1,
    PVOID Node2
    )

/*++

Routine Description:

    This routines compares account name fields of two user nodes.

Parameters:

    Node1, Node2, the nodes to compare

Return Values:

    GenericLessThan         - Node1 < Node2
    GenericGreaterThan      - Node1 > Node2
    GenericEqual            - Node1 == Node2

--*/
{
    PUNICODE_STRING
        NodeName1,
        NodeName2;

    LONG
        NameComparison;

    NodeName1 = &((PDOMAIN_DISPLAY_USER)Node1)->LogonName;
    NodeName2 = &((PDOMAIN_DISPLAY_USER)Node2)->LogonName;

    //
    // Do a case-insensitive comparison of the node names
    //

    NameComparison = SampCompareDisplayStrings(NodeName1, NodeName2, TRUE);

    if (NameComparison > 0) {
        return(GenericGreaterThan);
    }

    if (NameComparison < 0) {
        return(GenericLessThan);
    }

    return(GenericEqual);
}


RTL_GENERIC_COMPARE_RESULTS
SampCompareMachineNodeByName (
    PVOID Node1,
    PVOID Node2
    )

/*++

Routine Description:

    This routines compares account name fields of two machine nodes.

Parameters:

    Node1, Node2, the nodes to compare

Return Values:

    GenericLessThan         - Node1 < Node2
    GenericGreaterThan      - Node1 > Node2
    GenericEqual            - Node1 == Node2

--*/
{
    PUNICODE_STRING
        NodeName1,
        NodeName2;

    LONG
        NameComparison;



    NodeName1 = &((PDOMAIN_DISPLAY_MACHINE)Node1)->Machine;
    NodeName2 = &((PDOMAIN_DISPLAY_MACHINE)Node2)->Machine;


    //
    // Do a case-insensitive comparison of the node names
    //

    NameComparison = SampCompareDisplayStrings(NodeName1, NodeName2, TRUE);

    if (NameComparison > 0) {
        return(GenericGreaterThan);
    }

    if (NameComparison < 0) {
        return(GenericLessThan);
    }

    return(GenericEqual);
}


RTL_GENERIC_COMPARE_RESULTS
SampCompareGroupNodeByName (
    PVOID Node1,
    PVOID Node2
    )

/*++

Routine Description:

    This routines compares account name fields of two group nodes.

Parameters:

    Node1, Node2, the nodes to compare

Return Values:

    GenericLessThan         - Node1 < Node2
    GenericGreaterThan      - Node1 > Node2
    GenericEqual            - Node1 == Node2

--*/
{
    PUNICODE_STRING
        NodeName1,
        NodeName2;

    LONG
        NameComparison;



    NodeName1 = &((PDOMAIN_DISPLAY_GROUP)Node1)->Group;
    NodeName2 = &((PDOMAIN_DISPLAY_GROUP)Node2)->Group;

    //
    // Do a case-insensitive comparison of the node names
    //


    NameComparison = SampCompareDisplayStrings(NodeName1, NodeName2, TRUE);

    if (NameComparison > 0) {
        return(GenericGreaterThan);
    }

    if (NameComparison < 0) {
        return(GenericLessThan);
    }

    return(GenericEqual);
}


RTL_GENERIC_COMPARE_RESULTS
SampCompareNodeByRid (
    PVOID Node1,
    PVOID Node2
    )

/*++

Routine Description:

    This routines compares the RID of two nodes.

Parameters:

    Node1, Node2, the nodes to compare

Return Values:

    GenericLessThan         - Node1 < Node2
    GenericGreaterThan      - Node1 > Node2
    GenericEqual            - Node1 == Node2

--*/
{

    PDOMAIN_DISPLAY_USER
        N1,
        N2;

    //
    // This routine assumes that all nodes have RIDs in the same
    // place, regardless of node type.
    //

    ASSERT(FIELD_OFFSET(DOMAIN_DISPLAY_USER,    Rid) ==
           FIELD_OFFSET(DOMAIN_DISPLAY_MACHINE, Rid));
    ASSERT(FIELD_OFFSET(DOMAIN_DISPLAY_USER,    Rid) ==
           FIELD_OFFSET(DOMAIN_DISPLAY_GROUP,   Rid));

    N1 = Node1;
    N2 = Node2;


    if (N1->Rid < N2->Rid) {
        return(GenericLessThan);
    }

    if (N1->Rid > N2->Rid) {
        return(GenericGreaterThan);
    }

    return(GenericEqual);
}


LONG
SampCompareDisplayStrings(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2,
    IN BOOLEAN IgnoreCase
    )
/*++

Routine Description:

    This routine is a replacement for RtlCompareUnicodeString().
    The difference between RtlCompareUnicodeString() and this routine
    is that this routine takes into account various customer selected
    sort criteria (like, how is "A-MarilF" sorted in comparison to
    "Alfred").  This routine uses CompareStringW() for its comparison
    function.


Parameters:

    String1 - Points to a unicode string to compare.

    String2 - Points to a unicode string to compare.

    IgnoreCase - indicates whether the comparison is to be case
        sensitive (FALSE) or case insensitive (TRUE).

Return Values:


    -1 - String1 is lexically less than string 2.  That is, String1
         preceeds String2 in an ordered list.

     0 - String1 and String2 are lexically equivalent.

    -1 - String1 is lexically greater than string 2.  That is, String1
         follows String2 in an ordered list.


--*/


{

    INT
        CompareResult;

    DWORD
        Options = 0;

    if (IgnoreCase) {
        Options = NORM_IGNORECASE;
    }

    CompareResult = CompareStringW( SampSystemDefaultLCID,
                                     Options,
                                     String1->Buffer,
                                     (String1->Length / sizeof(WCHAR)),
                                     String2->Buffer,
                                     (String2->Length / sizeof(WCHAR))
                                     );

    //
    // Note that CompareStringW() returns values 1, 2, and 3 for
    // string1 less than, equal, or greater than string2 (respectively)
    // So, to obtain the RtlCompareUnicodeString() return values of
    // -1, 0, and 1 for the same meaning, we simply have to subtract 2.
    //

    CompareResult -= 2;

    //
    // CompareStringW has the property that alternate spellings may
    // produce strings that compare identically while the rest of SAM
    // treats the strings as different.  To get around this, if the
    // strings are the same we call RtlCompareUnicodeString to make
    // sure the strings really are the same.
    //

    if (CompareResult == 0) {
        CompareResult = RtlCompareUnicodeString(
                            String1,
                            String2,
                            IgnoreCase
                            );

    }
    return(CompareResult);
}


#if SAMP_DIAGNOSTICS


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Internal diagnostics                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#define SAMP_DISPLAY_DIAG_ENUM_RIDS         (0x00000001)

VOID
SampDisplayDiagnosticSuccess(
    IN  NTSTATUS s,
    IN  BOOLEAN Eol
    )

/*++

Routine Description:

    This routine prints "Success" or "Failure" depending upon the
    the passed in status value.

    If failure, it also prints the status code.


Parameters:

    s - the status value.

    Eol - if TRUE, causes an end of line to also be printed.


Return Values:


--*/
{
    if (NT_SUCCESS(s)) {
        SampDiagPrint(DISPLAY_CACHE, ("Success"));
    } else {
        SampDiagPrint(DISPLAY_CACHE, ("Failure - Status: 0x%lx", s));
    }

    if (Eol) {
        SampDiagPrint(DISPLAY_CACHE, ("\n"));
    }
    return;
}


VOID
SampDisplayDiagnostic(
    VOID
    )

/*++

Routine Description:

    This routine provides internal diagnostics and test capabilities.

    This routine is called whenever an account called SAMP_DIAG is
    modified such that the display cache requires updating.

    This routine breakpoints, allowing diagnostic parameters to be set.


Parameters:

    None.

Return Values:


--*/
{

    ULONG
        DiagnosticRunCount = 0,
        DiagnosticsToRun = 0;

    SampDiagPrint(DISPLAY_CACHE,
                  ("SAM: SampDisplayDiagnostic() called.\n"
                   "     Breakpointing to allow diagnostic parameters to be set.\n"
                   "     Diagnostic Flag Word: 0x%lx\n"
                   "     Diagnostic values: \n"
                   "          SamIEnumerateAccountRids:      0x%lx\n"
                   "\n",
                   &DiagnosticsToRun,
                   SAMP_DISPLAY_DIAG_ENUM_RIDS
                   ) );
    DbgBreakPoint();

    if ((DiagnosticsToRun & SAMP_DISPLAY_DIAG_ENUM_RIDS) != 0) {
        SampDisplayDiagEnumRids();
        DiagnosticRunCount++;
    }


    SampDiagPrint(DISPLAY_CACHE,
                  ("SAM: SampDisplayDiagnostic()  - %d diagnostics run.\n",
                   DiagnosticRunCount) );


    return;
}


VOID
SampDisplayDiagEnumRids(
    VOID
    )

/*++

Routine Description:

    This routine tests the RID table enumeration api
    (SamIEnumerateAccountRids()).


Parameters:

    None.

Return Values:


--*/
{
    NTSTATUS
        NtStatus;

    ULONG
        i,
        ReturnCount,
        LastRid = 0;

    PULONG
        AccountRids;

    SAMPR_HANDLE
        Server,
        Domain;

    SampDiagPrint(DISPLAY_CACHE,
                  ("SAM: Testing SamIEnumerateAccountRids...\n"));


    NtStatus = SamIConnect( L"",        //ServerName
                            &Server,    //ServerHandle
                            0,          //DesiredAccess
                            TRUE        //TrustedClient
                            );
    ASSERT(NT_SUCCESS(NtStatus));

    NtStatus = SamrOpenDomain( Server,
                               0,                           //DesiredAccess
                               SampDefinedDomains[1].Sid,   //DomainId
                               &Domain
                               );
    ASSERT(NT_SUCCESS(NtStatus));



    
    ///////////////////////////////////////////////////////////////////
    //                                                               //
    // Enumerate both USERs and GLOBAL GROUPs                        //
    //                                                               //
    ///////////////////////////////////////////////////////////////////


    SampDiagPrint(DISPLAY_CACHE,
                  ("     Enumerating first three users and global groups...") );
    NtStatus = SamIEnumerateAccountRids( Domain,
                                         SAM_USER_ACCOUNT | SAM_GLOBAL_GROUP_ACCOUNT,
                                         0,                 //StartingRid
                                         3*sizeof(ULONG),   //PreferedMaximumLength
                                         &ReturnCount,
                                         &AccountRids
                                         );

    SampDisplayDiagnosticSuccess( NtStatus, TRUE );
    if (NT_SUCCESS(NtStatus)) {
        SampDiagPrint(DISPLAY_CACHE,
                      ("     %d entries returned.\n", ReturnCount));
        if (ReturnCount > 0) {
            ASSERT(AccountRids != NULL);
            for (i=0; i<ReturnCount; i++) {
                SampDiagPrint(DISPLAY_CACHE,
                              ("     0x%lx\n", AccountRids[i]));
            }
            LastRid = AccountRids[ReturnCount-1];
            MIDL_user_free(AccountRids);
        } else {
            ASSERT(AccountRids == NULL);
        }
    }


    //
    // Now try to continue for another 100 accounts
    //


    SampDiagPrint(DISPLAY_CACHE,
                  ("     Enumerating next 100 users and global groups...") );
    NtStatus = SamIEnumerateAccountRids( Domain,
                                         SAM_USER_ACCOUNT | SAM_GLOBAL_GROUP_ACCOUNT,
                                         LastRid,           //StartingRid
                                         100*sizeof(ULONG), //PreferedMaximumLength
                                         &ReturnCount,
                                         &AccountRids
                                         );

    SampDisplayDiagnosticSuccess( NtStatus, TRUE );
    if (NT_SUCCESS(NtStatus)) {
        SampDiagPrint(DISPLAY_CACHE,
                      ("     %d entries returned.\n", ReturnCount));
        if (ReturnCount > 0) {
            ASSERT(AccountRids != NULL);
            for (i=0; i<ReturnCount; i++) {
                SampDiagPrint(DISPLAY_CACHE,
                              ("     0x%lx\n", AccountRids[i]));
            }
            LastRid = AccountRids[ReturnCount-1];
            MIDL_user_free(AccountRids);
        } else {
            ASSERT(AccountRids == NULL);
        }
    }


    //
    // Now try to continue for another 4000 accounts
    //


    if (NtStatus == STATUS_MORE_ENTRIES) {
        SampDiagPrint(DISPLAY_CACHE,
                      ("     Enumerating next 4000 users and global groups...") );
        NtStatus = SamIEnumerateAccountRids( Domain,
                                             SAM_USER_ACCOUNT | SAM_GLOBAL_GROUP_ACCOUNT,
                                             LastRid,           //StartingRid
                                             400*sizeof(ULONG), //PreferedMaximumLength
                                             &ReturnCount,
                                             &AccountRids
                                             );

        SampDisplayDiagnosticSuccess( NtStatus, TRUE );
        if (NT_SUCCESS(NtStatus)) {
            SampDiagPrint(DISPLAY_CACHE,
                          ("     %d entries returned.\n", ReturnCount));
            if (ReturnCount > 0) {
                ASSERT(AccountRids != NULL);
                i=0;
                if (ReturnCount > 8) {
                    for (i=0; i<ReturnCount-8; i=i+8) {
                        SampDiagPrint(DISPLAY_CACHE,
                            ("     0x%lx  0x%lx  0x%lx  0x%lx  0x%lx  0x%lx  0x%lx  0x%lx\n",
                             AccountRids[i+0], AccountRids[i+1],
                             AccountRids[i+2], AccountRids[i+3],
                             AccountRids[i+4], AccountRids[i+5],
                             AccountRids[i+6], AccountRids[i+7] ));
                    }
                }
                for (i=i; i<ReturnCount; i++) {
                    SampDiagPrint(DISPLAY_CACHE,
                                  ("     0x%lx  ", AccountRids[i]));
                }
                SampDiagPrint(DISPLAY_CACHE, ("\n"));
                LastRid = AccountRids[i];
                MIDL_user_free(AccountRids);
            } else {
                ASSERT(AccountRids == NULL);
            }
        }
    }


    
    ///////////////////////////////////////////////////////////////////
    //                                                               //
    // Now try just USER accounts                                    //
    //                                                               //
    ///////////////////////////////////////////////////////////////////

    SampDiagPrint(DISPLAY_CACHE,
                  ("     Enumerating first three users ...") );
    NtStatus = SamIEnumerateAccountRids( Domain,
                                         SAM_USER_ACCOUNT,
                                         0,                 //StartingRid
                                         3*sizeof(ULONG),   //PreferedMaximumLength
                                         &ReturnCount,
                                         &AccountRids
                                         );

    SampDisplayDiagnosticSuccess( NtStatus, TRUE );
    if (NT_SUCCESS(NtStatus)) {
        SampDiagPrint(DISPLAY_CACHE,
                      ("     %d entries returned.\n", ReturnCount));
        if (ReturnCount > 0) {
            ASSERT(AccountRids != NULL);
            for (i=0; i<ReturnCount; i++) {
                SampDiagPrint(DISPLAY_CACHE,
                              ("     0x%lx\n", AccountRids[i]));
            }
            LastRid = AccountRids[ReturnCount-1];
            MIDL_user_free(AccountRids);
        } else {
            ASSERT(AccountRids == NULL);
        }
    }


    //
    // Now try to continue for another 100 accounts
    //


    SampDiagPrint(DISPLAY_CACHE,
                  ("     Enumerating next 100 users...") );
    NtStatus = SamIEnumerateAccountRids( Domain,
                                         SAM_USER_ACCOUNT,
                                         LastRid,           //StartingRid
                                         100*sizeof(ULONG), //PreferedMaximumLength
                                         &ReturnCount,
                                         &AccountRids
                                         );

    SampDisplayDiagnosticSuccess( NtStatus, TRUE );
    if (NT_SUCCESS(NtStatus)) {
        SampDiagPrint(DISPLAY_CACHE,
                      ("     %d entries returned.\n", ReturnCount));
        if (ReturnCount > 0) {
            ASSERT(AccountRids != NULL);
            for (i=0; i<ReturnCount; i++) {
                SampDiagPrint(DISPLAY_CACHE,
                              ("     0x%lx\n", AccountRids[i]));
            }
            LastRid = AccountRids[ReturnCount-1];
            MIDL_user_free(AccountRids);
        } else {
            ASSERT(AccountRids == NULL);
        }
    }


    //
    // Now try to continue for another 4000 accounts
    //


    if (NtStatus == STATUS_MORE_ENTRIES) {
        SampDiagPrint(DISPLAY_CACHE,
                      ("     Enumerating next 4000 users...") );
        NtStatus = SamIEnumerateAccountRids( Domain,
                                             SAM_USER_ACCOUNT,
                                             LastRid,           //StartingRid
                                             400*sizeof(ULONG), //PreferedMaximumLength
                                             &ReturnCount,
                                             &AccountRids
                                             );

        SampDisplayDiagnosticSuccess( NtStatus, TRUE );
        if (NT_SUCCESS(NtStatus)) {
            SampDiagPrint(DISPLAY_CACHE,
                          ("     %d entries returned.\n", ReturnCount));
            if (ReturnCount > 0) {
                ASSERT(AccountRids != NULL);
                i=0;
                if (ReturnCount > 8) {
                    for (i=0; i<ReturnCount-8; i=i+8) {
                        SampDiagPrint(DISPLAY_CACHE,
                            ("     0x%lx  0x%lx  0x%lx  0x%lx  0x%lx  0x%lx  0x%lx  0x%lx\n",
                             AccountRids[i+0], AccountRids[i+1],
                             AccountRids[i+2], AccountRids[i+3],
                             AccountRids[i+4], AccountRids[i+5],
                             AccountRids[i+6], AccountRids[i+7] ));
                    }
                }
                for (i=i; i<ReturnCount; i++) {
                    SampDiagPrint(DISPLAY_CACHE,
                                  ("     0x%lx  ", AccountRids[i]));
                }
                SampDiagPrint(DISPLAY_CACHE, ("\n"));
                LastRid = AccountRids[i];
                MIDL_user_free(AccountRids);
            } else {
                ASSERT(AccountRids == NULL);
            }
        }
    }

    
    ///////////////////////////////////////////////////////////////////
    //                                                               //
    // Now just try GLOBAL GROUPs                                    //
    //                                                               //
    ///////////////////////////////////////////////////////////////////


    SampDiagPrint(DISPLAY_CACHE,
                  ("     Enumerating first three global groups...") );
    NtStatus = SamIEnumerateAccountRids( Domain,
                                         SAM_GLOBAL_GROUP_ACCOUNT,
                                         0,                 //StartingRid
                                         3*sizeof(ULONG),   //PreferedMaximumLength
                                         &ReturnCount,
                                         &AccountRids
                                         );

    SampDisplayDiagnosticSuccess( NtStatus, TRUE );
    if (NT_SUCCESS(NtStatus)) {
        SampDiagPrint(DISPLAY_CACHE,
                      ("     %d entries returned.\n", ReturnCount));
        if (ReturnCount > 0) {
            ASSERT(AccountRids != NULL);
            for (i=0; i<ReturnCount; i++) {
                SampDiagPrint(DISPLAY_CACHE,
                              ("     0x%lx\n", AccountRids[i]));
            }
            LastRid = AccountRids[ReturnCount-1];
            MIDL_user_free(AccountRids);
        } else {
            ASSERT(AccountRids == NULL);
        }
    }


    //
    // Now try to continue for another 100 accounts
    //


    SampDiagPrint(DISPLAY_CACHE,
                  ("     Enumerating next 100 global groups...") );
    NtStatus = SamIEnumerateAccountRids( Domain,
                                         SAM_GLOBAL_GROUP_ACCOUNT,
                                         LastRid,           //StartingRid
                                         100*sizeof(ULONG), //PreferedMaximumLength
                                         &ReturnCount,
                                         &AccountRids
                                         );

    SampDisplayDiagnosticSuccess( NtStatus, TRUE );
    if (NT_SUCCESS(NtStatus)) {
        SampDiagPrint(DISPLAY_CACHE,
                      ("     %d entries returned.\n", ReturnCount));
        if (ReturnCount > 0) {
            ASSERT(AccountRids != NULL);
            for (i=0; i<ReturnCount; i++) {
                SampDiagPrint(DISPLAY_CACHE,
                              ("     0x%lx\n", AccountRids[i]));
            }
            LastRid = AccountRids[ReturnCount-1];
            MIDL_user_free(AccountRids);
        } else {
            ASSERT(AccountRids == NULL);
        }
    }


    //
    // Now try to continue for another 4000 accounts
    //


    if (NtStatus == STATUS_MORE_ENTRIES) {
        SampDiagPrint(DISPLAY_CACHE,
                      ("     Enumerating next 4000 global groups...") );
        NtStatus = SamIEnumerateAccountRids( Domain,
                                             SAM_GLOBAL_GROUP_ACCOUNT,
                                             LastRid,           //StartingRid
                                             4000*sizeof(ULONG), //PreferedMaximumLength
                                             &ReturnCount,
                                             &AccountRids
                                             );

        SampDisplayDiagnosticSuccess( NtStatus, TRUE );
        if (NT_SUCCESS(NtStatus)) {
            SampDiagPrint(DISPLAY_CACHE,
                          ("     %d entries returned.\n", ReturnCount));
            if (ReturnCount > 0) {
                ASSERT(AccountRids != NULL);
                i=0;
                if (ReturnCount > 8) {
                    for (i=0; i<ReturnCount-8; i=i+8) {
                        SampDiagPrint(DISPLAY_CACHE,
                            ("     0x%lx  0x%lx  0x%lx  0x%lx  0x%lx  0x%lx  0x%lx  0x%lx\n",
                             AccountRids[i+0], AccountRids[i+1],
                             AccountRids[i+2], AccountRids[i+3],
                             AccountRids[i+4], AccountRids[i+5],
                             AccountRids[i+6], AccountRids[i+7] ));
                    }
                }
                for (i=i; i<ReturnCount; i++) {
                    SampDiagPrint(DISPLAY_CACHE,
                                  ("     0x%lx  ", AccountRids[i]));
                }
                SampDiagPrint(DISPLAY_CACHE, ("\n"));
                LastRid = AccountRids[i];
                MIDL_user_free(AccountRids);
            } else {
                ASSERT(AccountRids == NULL);
            }
        }
    }



    //
    // Now try to continue an enumeration from the very last RID.
    // At one point in time, this use to restart the enumeration
    // (which was not correct behaviour).  It should indicate that
    // there are no more entries.
    //

    SampDiagPrint(DISPLAY_CACHE,
                  ("     Enumerating next 5 global groups.."
                   "     (should be none to enumerate)   ...") );
    NtStatus = SamIEnumerateAccountRids( Domain,
                                         SAM_GLOBAL_GROUP_ACCOUNT,
                                         LastRid,           //StartingRid
                                         5*sizeof(ULONG), //PreferedMaximumLength
                                         &ReturnCount,
                                         &AccountRids
                                         );

    SampDisplayDiagnosticSuccess( NtStatus, TRUE );
    if (NT_SUCCESS(NtStatus)) {
        SampDiagPrint(DISPLAY_CACHE,
                      ("     %d entries returned.\n", ReturnCount));
        if (ReturnCount > 0) {
            SampDiagPrint(DISPLAY_CACHE,
                      ("    ERROR - there should be no RIDs returned ! !\n"));
            ASSERT(AccountRids != NULL);
            i=0;
            if (ReturnCount > 8) {
                for (i=0; i<ReturnCount-8; i=i+8) {
                    SampDiagPrint(DISPLAY_CACHE,
                        ("     0x%lx  0x%lx  0x%lx  0x%lx  0x%lx  0x%lx  0x%lx  0x%lx\n",
                         AccountRids[i+0], AccountRids[i+1],
                         AccountRids[i+2], AccountRids[i+3],
                         AccountRids[i+4], AccountRids[i+5],
                         AccountRids[i+6], AccountRids[i+7] ));
                }
            }
            for (i=i; i<ReturnCount; i++) {
                SampDiagPrint(DISPLAY_CACHE,
                              ("     0x%lx  ", AccountRids[i]));
            }
            SampDiagPrint(DISPLAY_CACHE, ("\n"));
            LastRid = AccountRids[i];
            MIDL_user_free(AccountRids);
        } else {
            ASSERT(AccountRids == NULL);
        }
    }





    ///////////////////////////////////////////////////////////////////
    //                                                               //
    // Hmmm, can't close handles because it will conflict            //
    // with the rxact state we already have going.  Bummer.          //
    //                                                               //
    ///////////////////////////////////////////////////////////////////

    //NtStatus = SamrCloseHandle( &Domain ); ASSERT(NT_SUCCESS(NtStatus));
    //NtStatus = SamrCloseHandle( &Server ); ASSERT(NT_SUCCESS(NtStatus));

    return;
}

#endif //SAMP_DIAGNOSTICS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\dsdomain.c ===
/*++

Copyright (c) 1990 - 1996  Microsoft Corporation

Module Name:

    dsdomain.c

Abstract:

    This file contains services related to the SAM "domain" object. The NT5
    SAM stores domain account information in the registry (see domain.c) and
    account information in the directory service (DS). This latter case is
    handled by the routines in this file, which know how to read/write DS
    data. This file also contains routines for dynamic domain creation and
    deletion.

    NOTE: Dynamic domain creation/deletion is work in progress.

Author:

    Chris Mayhall (ChrisMay) 11-Jul-1996

Environment:

    User Mode - Win32

Revision History:

    11-Jul-1996 ChrisMay
        Created initial file.
    25-Jul-1996 ChrisMay
        Added domain initialization and corresponding changes in ntds.exe.
    23-Aug-1996 ChrisMay
        Made domain initialization work for multiple hosted domains and for
        domain information stored in the DS.
    08-Oct-1996 ChrisMay
        Miscellaneous cleanup.
    09-Dec-1996 ChrisMay
        Remove dead/obsolete code, further clean up needed to support mult-
        iple hosted domains.
    31-Jan-1997 ChrisMay
        Added multi-master RID manager routines.

--*/


// Includes

#include <samsrvp.h>
#include "ntlsa.h"
#include "lmcons.h"         // LM20_PWLEN
#include "msaudite.h"
#include <ntlsa.h>
#include <nlrepl.h>         // I_NetNotifyMachineAccount prototype
#include <dslayer.h>        // SampDsCreateObject, etc.
#include <dsutilp.h>
#include <dsdomain.h>
#include <objids.h>
#include <dsconfig.h>
#include <stdlib.h>
#include <ridmgr.h>

// Private (to this file) debug buffer.

#define DBG_BUFFER_SIZE     256



NTSTATUS
SampInitializeWellKnownSids(
    VOID
    );

// Constants (used only in this file)

#define SAMP_DOMAIN_COUNT   2



NTSTATUS
SampDsGetDomainInitInfoEx(
    PSAMP_DOMAIN_INIT_INFO DomainInitInfo
    )

/*++

Routine Description:

    This routine obtains the SAM domain information from the DS for each
    hosted domain. Each hosted domain contains both Builtin and Account
    domains.

Arguments:

    DomainInitInfo - Pointer, domain boostrap information.

Return Value:

    STATUS_SUCCESS - Successful completion.

    STATUS_NO_MEMORY - Insufficient memory available.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_DOMAIN_INFO DomainInfo = NULL;

    ULONG i=0;

    // BUG: How is the count of hosted domains determined from the DS?

    ULONG HostedDomainCount = 1;

    // DomainCount should always equal 2 (Builtin and Account).

    ULONG DomainCount = SAMP_DOMAIN_COUNT;
    ULONG TotalDomainCount = HostedDomainCount * DomainCount;
    ULONG Length = TotalDomainCount * sizeof(SAMP_DOMAIN_INFO);

    static WCHAR SamBuiltinName[] = L"Builtin";
    static WCHAR SamDomainName[]  = L"Account";

    ULONG Size = 0;
    ULONG DirError = 0;

    SAMTRACE("SampDsGetDomainInitInfoEx");

    //
    // Initialize the output parameters.
    //

    DomainInitInfo->DomainCount = 0;
    DomainInitInfo->DomainInfo = NULL;

    // This routine assumes the ROOT_OBJECT has been created
    ASSERT( ROOT_OBJECT );

    SampDiagPrint(INFORM,
                  ("SAMSS: RootDomain Name is %S\n", ROOT_OBJECT->StringName));

    // Allocate space for the domain-information array.

    DomainInfo = RtlAllocateHeap(RtlProcessHeap(), 0, Length);

    if (NULL != DomainInfo)
    {
        RtlZeroMemory(DomainInfo, Length);

        // Initialize the array with each hosted domain's information. Note,
        // each hosted domain contains both Builtin and a Account domains.

        while (i < HostedDomainCount)
        {
            // For each hosted domain, setup the Builtin domain initialization
            // information.

            // DSNameSizeFromLen adds 1 for the NULL
            Size = (ULONG)DSNameSizeFromLen( ROOT_OBJECT->NameLen
                                    + wcslen( SamBuiltinName )
                                    + wcslen( L"CN=," ) );  // the common name part

            DomainInfo[i].DomainDsName = RtlAllocateHeap(RtlProcessHeap(),
                                                         0,
                                                         Size);

            if (NULL != DomainInfo[i].DomainDsName)
            {
                RtlZeroMemory(DomainInfo[i].DomainDsName, Size);

                DirError = AppendRDN( ROOT_OBJECT,
                                      DomainInfo[i].DomainDsName,
                                      Size,
                                      SamBuiltinName,
                                      wcslen(SamBuiltinName),  // don't include the NULL
                                      ATT_COMMON_NAME );

                // DirError is 0 or !0
                ASSERT( 0 == DirError );

                SampDiagPrint(INFORM,
                              ("SAMSS: Builtin Domain Name is %S\n",
                               DomainInfo[i].DomainDsName->StringName));

                DomainInitInfo->DomainCount++;
            }
            else
            {
                NtStatus = STATUS_NO_MEMORY;
                break;
            }

            // BUG: Setting domain display name to internal name.

            // Set the "display name" for the Builtin domain.

            RtlInitUnicodeString(&(DomainInfo[i].DomainName),
                                 SamBuiltinName);

            // Setup the Account domain initialization information.
            Size = ROOT_OBJECT->structLen;

            DomainInfo[i + 1].DomainDsName = RtlAllocateHeap(
                                                        RtlProcessHeap(),
                                                        0,
                                                        Size);

            if (NULL != DomainInfo[i + 1].DomainDsName)
            {
                RtlCopyMemory(DomainInfo[i + 1].DomainDsName, ROOT_OBJECT, Size);

                DomainInitInfo->DomainCount++;
            }
            else
            {
                NtStatus = STATUS_NO_MEMORY;
                break;
            }

            // Set the "display name" for the Account domain.

            RtlInitUnicodeString(&(DomainInfo[i + 1].DomainName),
                                 SamDomainName);

            // Process the next hosted domain, if there is another.

            i++;
        }

        // Set the domain-info pointer. If an error occurred, return the
        // domain information up to that point. The caller should always
        // use DomainCount to determine how many domains were found.

        DomainInitInfo->DomainInfo = DomainInfo;
    }
    else
    {
        NtStatus = STATUS_NO_MEMORY;
    }

    return(NtStatus);
}


NTSTATUS
SampExtendDefinedDomains(
    ULONG DomainCount
    )

/*++

Routine Description:

    This routine grows the SampDefinedDomains array. It is written so that
    a memory allocation failure will not corrupt the original array. If the
    memory cannot be allocated, the original array is left in tact.

Arguments:

    DomainCount - The number of entries to grow the array by.

Return Value:

    STATUS_SUCCESS - Successful completion.

    STATUS_NO_MEMORY - Insufficient memory available.

--*/

{
    SAMTRACE("SampExtendDefinedDomains");

    //
    // N.B.  This routine was originally meant to grow the SampDefinedDomains
    // array to hold the domains held in the ds.  This is a
    // unstable architecture since each existing element in the
    // SampDefinedDomains array would need to be reinitialized.  So, the fix is
    // to simply allocate the amount necessary for the entire array in
    // SampInitializeDomainObject.  It is expected that the number of domains
    // in the ds is only 2 (valid for win2k release: builtin and account
    // domain). If this value changes then we need to change the amount
    // allocated in SampInitializeDomainObject.
    //

    ASSERT( DomainCount == 2 );

    SampDefinedDomainsCount += DomainCount;

    return(STATUS_SUCCESS);
}


NTSTATUS
SampDsSetBuiltinDomainPolicy(
    ULONG Index
    )

/*++

Routine Description:

    This routine sets the names and SIDs for the Builtin domain. The builtin
    account domain has a well known name and SID.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS - successful completion.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo;
    SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;

    SAMTRACE("SampDsSetBuiltinDomainPolicy");

    // BUG: NT5 will need per-hosted domain Builtin policy.

    // Builtin domain - Well-known external name and SID constant internal
    // name. NT4 SAM defined one Builtin domain per DC. The Builtin domain
    // has customarily contained hard-wired, constant SID and name in order
    // to simplify inter-DC communication about changes to Builtin data.
    // This premise may need to change for NT5, as each Builtin will have
    // a different policy per hosted domain.

    RtlInitUnicodeString(&SampDefinedDomains[Index].InternalName, L"Builtin");
    RtlInitUnicodeString(&SampDefinedDomains[Index].ExternalName, L"Builtin");

    SampDefinedDomains[Index].Sid = RtlAllocateHeap(RtlProcessHeap(),
                                                    0,
                                                    RtlLengthRequiredSid(1));

    ASSERT(SampDefinedDomains[Index].Sid != NULL);
    if (NULL==SampDefinedDomains[Index].Sid)
    {
       return(STATUS_INSUFFICIENT_RESOURCES);
    }

    RtlInitializeSid(SampDefinedDomains[Index].Sid, &BuiltinAuthority, 1);

    *(RtlSubAuthoritySid(SampDefinedDomains[Index].Sid, 0)) =
        SECURITY_BUILTIN_DOMAIN_RID;

    SampDefinedDomains[Index].IsBuiltinDomain = TRUE;

    return(NtStatus);
}


NTSTATUS
SampDsGetDomainInfo(
    PPOLICY_DNS_DOMAIN_INFO *PolicyDomainInfo
    )

/*++

Routine Description:

    This routine obtains the domain policy information from LSA.

Arguments:

    PolicyDomainInfo - Pointer, policy information for the domain.

Return Value:

    STATUS_SUCCESS - Successful completion.

    STATUS_INVALID_SID - LSA returned a NULL SID.

    Other codes from LSA.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    NTSTATUS IgnoreStatus = STATUS_INTERNAL_ERROR;
    LSAPR_HANDLE PolicyHandle = NULL;

    SAMTRACE("SampDsGetDomainInfo");

    NtStatus = LsaIOpenPolicyTrusted(&PolicyHandle);

    if (NT_SUCCESS(NtStatus)) {

        // Query the account domain information

        // BUG: Need to get the correct policy information - using "Account Domain" for now.

        // LSA will need to export a routine that allows for the retrieval of
        // per-hosted-domain policy. For now, it is assumed that the returned
        // policy is the only one present on the DC (a.k.a. NT4 policy).

        NtStatus = LsarQueryInformationPolicy(
                       PolicyHandle,
                       PolicyDnsDomainInformation,
                       (PLSAPR_POLICY_INFORMATION *)PolicyDomainInfo);

        SampDiagPrint(INFORM,
                      ("SAMSS: LsaIQueryInformationPolicy status = 0x%lx\n",
                       NtStatus));

        if (NT_SUCCESS(NtStatus))
        {
            if ((*PolicyDomainInfo)->Sid == NULL)
            {
                NtStatus = STATUS_INVALID_SID;
            }
        }

        IgnoreStatus = LsarClose(&PolicyHandle);


    }

    return(NtStatus);
}


NTSTATUS
SampDsSetDomainPolicy(
    PDSNAME DsName,
    ULONG Index
    )

/*++

Routine Description:

    This routine sets the domain SID and name as obtained from LSA.

Arguments:

    DsName - Pointer, DS name of the domain.

    Index - Current entry in the SampDefinedDomains array.

Return Value:

    STATUS_SUCCESS - Successful completion.

    Other error codes from SampDsGetDomainInfo.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    PPOLICY_DNS_DOMAIN_INFO PolicyDomainInfo = NULL;

    SAMTRACE("SampDsSetDomainPolicy");

    NtStatus = SampDsGetDomainInfo(&PolicyDomainInfo);

    if (NT_SUCCESS(NtStatus))
    {
        // Set the domain's SID, internal, and external names. The NT5
        // naming convention must continue to use SAM/LSA names, namely
        // the netbios names that LSA and NetLogon understand, so that
        // actions such as replication continue to work (with down-level
        // BDCs). These names are passed in via the policy information.

        // In addition, SampDefinedDomains contains a SAM context struct
        // which in turn contains the DS distinguished name of the account
        // object. Consequently, all three names (internal, external, and
        // DN) are available via SampDefinedDomains.

        SampDefinedDomains[Index].Sid = PolicyDomainInfo->Sid;
        SampDefinedDomains[Index].IsBuiltinDomain = FALSE;

        RtlInitUnicodeString(&SampDefinedDomains[Index].InternalName,
                             L"Account");

        RtlInitUnicodeString(&SampDefinedDomains[Index].ExternalName,
                             PolicyDomainInfo->Name.Buffer);

        RtlInitUnicodeString(&SampDefinedDomains[Index].DnsDomainName,
                             PolicyDomainInfo->DnsDomainName.Buffer);

        RtlInitUnicodeString(&SampDefinedDomains[Index].DnsForestName,
                             PolicyDomainInfo->DnsForestName.Buffer);
    }

    return(NtStatus);
}


NTSTATUS
SampDsInitializeSingleDomain(
    PDSNAME DsName,
    ULONG Index,
    BOOLEAN MixedDomain,
    ULONG   BehaviorVersion,
    DOMAIN_SERVER_ROLE ServerRole,
    ULONG   LastLogonTimeStampSyncInterval
    )

/*++

Routine Description:

    This routine initializes a Builtin or an Account domain object. A context
    is created for the domain, the fixed-length attributes and the SID for
    the domain are obtained. This information is stored in the SampDefined-
    Domains array. If the domain SID matches the one previously obtained from
    LSA, then the domain security descriptor is setup.

Arguments:

    DsName - Pointer, DS domain name.

    Index - Index into the SampDefinedDomains array.

    MixedDomain - Indicates that the given domain is a Mixed Domain

    ServerRole  Indicates the PDCness / BDCness of this server in the domain

Return Value:

    STATUS_SUCCESS - Successful completion.

    STATUS_INSUFFICIENT_RESOURCES - Insufficient memory, etc.

    STATUS_INVALID_ID_AUTHORITY - ?

    Other return codes from subroutines.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    PSAMP_OBJECT DomainContext = NULL;
    BOOLEAN MakeCopy = FALSE;
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN FixedAttributes = NULL;
    PSID Sid = NULL;

    #if DBG

    SID *Sid1 = NULL, *Sid2 = NULL;

    #endif

    SAMTRACE("SampDsInitializeSingleDomain");


    // Create a context for this domain object. This context is kept around
    // until SAM is shut down. Call with TrustedClient equal TRUE.

    DomainContext = SampCreateContext(SampDomainObjectType, Index, TRUE);

    if (NULL != DomainContext)
    {
        // Store the defined-domains index in the context and set the DS-
        // object flag, indicating that this context corresponds to a DS-
        // domain account object.

        DomainContext->DomainIndex = Index;
        SetDsObject(DomainContext);

        // Set the domain object's DS name in order to lookup the fixed
        // attributes in the DS.

        // BUG: What is the lifetime of the DsName object?

        DomainContext->ObjectNameInDs = DsName;

        SampDiagPrint(INFORM,
                      ("SAMSS: Domain DsName = %ws\n", DsName->StringName));

        // Get the fixed-length data for this domain and store it in the
        // defined-domain structure.

        NtStatus = SampGetFixedAttributes(DomainContext,
                                          MakeCopy,
                                          (PVOID *)&FixedAttributes);

        if (NT_SUCCESS(NtStatus))
        {

            //
            // Get the DS Domain Handle for the Domain
            //

            SampDefinedDomains[Index].DsDomainHandle = DirGetDomainHandle(DsName);

        }
        else
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SAMSS: SampGetFixedAttributes status = 0x%lx\n",
                       NtStatus));
        }

        if (NT_SUCCESS(NtStatus))
        {

            ASSERT(1 < Index);

            //
            // Set the correct Fixed attributes in the defined domains structure
            //

            RtlMoveMemory(&SampDefinedDomains[Index].UnmodifiedFixed,
                          FixedAttributes,
                          sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN));

            RtlMoveMemory(&SampDefinedDomains[Index].CurrentFixed,
                          FixedAttributes,
                          sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN));

            SampDefinedDomains[Index].FixedValid = TRUE;

            //
            // Set the server role
            //

            SampDefinedDomains[Index].ServerRole = ServerRole;


            //
            // Set the mixed domain flag and other domain settings
            //

            SampDefinedDomains[Index].IsMixedDomain = MixedDomain;
            SampDefinedDomains[Index].BehaviorVersion = BehaviorVersion;
            SampDefinedDomains[Index].LastLogonTimeStampSyncInterval = LastLogonTimeStampSyncInterval;


            //
            // Get the SID attribute of the domain
            //

            NtStatus = SampGetSidAttribute(DomainContext,
                                           SAMP_DOMAIN_SID,
                                           MakeCopy,
                                           &Sid);


            SampDiagPrint(INFORM,
                          ("SAMSS: SampGetSidAttribute status = 0x%lx\n",
                           NtStatus));

            SampDefinedDomains[Index ].AliasInformation.MemberAliasList = NULL;
        }
    }
    else
    {
        ASSERT(!SampExistsDsTransaction());
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampCreateContext failed, NULL context returned\n"));

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        return(NtStatus);
    }

    if (NT_SUCCESS(NtStatus))
    {
        // Verify that this domain SID is the same as the one obtained
        // earlier (from LSA policy info) in the defined-domains array.

        if (RtlEqualSid(Sid, SampDefinedDomains[Index].Sid) == TRUE)
        {
            // Build security descriptors for use in user and group account
            // creations in this domain.

            NtStatus = SampInitializeDomainDescriptors(Index);

            if (NT_SUCCESS(NtStatus))
            {
                // Intialize the cached display information

                SampDefinedDomains[Index].Context = DomainContext;
                SampDefinedDomains[Index].AliasInformation.Valid = FALSE;

                NtStatus = SampInitializeDisplayInformation(Index);
            }
            else
            {
                SampDefinedDomains[Index].Context = NULL;
            }
        }
        else
        {
            NtStatus = STATUS_INVALID_ID_AUTHORITY;

            #if DBG

            DbgPrint("SAMSS: Database corruption for %Z Domain.\n",
            &SampDefinedDomains[Index].ExternalName);

            Sid1 = Sid; Sid2 = SampDefinedDomains[Index].Sid;

            DbgPrint("Sid1 Revision = %d\n", Sid1->Revision);
            DbgPrint("Sid1 SubAuthorityCount = %d\n", Sid1->SubAuthorityCount);
            DbgPrint("Sid1 IdentifierAuthority = %d\n", Sid1->IdentifierAuthority.Value[0]);
            DbgPrint("Sid1 IdentifierAuthority = %d\n", Sid1->IdentifierAuthority.Value[1]);
            DbgPrint("Sid1 IdentifierAuthority = %d\n", Sid1->IdentifierAuthority.Value[2]);
            DbgPrint("Sid1 IdentifierAuthority = %d\n", Sid1->IdentifierAuthority.Value[3]);
            DbgPrint("Sid1 IdentifierAuthority = %d\n", Sid1->IdentifierAuthority.Value[4]);
            DbgPrint("Sid1 IdentifierAuthority = %d\n", Sid1->IdentifierAuthority.Value[5]);
            DbgPrint("Sid1 SubAuthority = %lu\n", Sid1->SubAuthority[0]);

            DbgPrint("Sid2 Revision = %d\n", Sid2->Revision);
            DbgPrint("Sid2 SubAuthorityCount = %d\n", Sid2->SubAuthorityCount);
            DbgPrint("Sid2 IdentifierAuthority = %d\n", Sid2->IdentifierAuthority.Value[0]);
            DbgPrint("Sid2 IdentifierAuthority = %d\n", Sid2->IdentifierAuthority.Value[1]);
            DbgPrint("Sid2 IdentifierAuthority = %d\n", Sid2->IdentifierAuthority.Value[2]);
            DbgPrint("Sid2 IdentifierAuthority = %d\n", Sid2->IdentifierAuthority.Value[3]);
            DbgPrint("Sid2 IdentifierAuthority = %d\n", Sid2->IdentifierAuthority.Value[4]);
            DbgPrint("Sid2 IdentifierAuthority = %d\n", Sid2->IdentifierAuthority.Value[5]);
            DbgPrint("Sid2 SubAuthority = %lu\n", Sid2->SubAuthority[0]);

            #endif //DBG
        }
    }

    if (SampDefinedDomains[Index].IsBuiltinDomain) {
        SampDefinedDomains[Index].IsExtendedSidDomain = FALSE;
    } else {
        //
        // Note -- when the extended SID support is complete, this will be
        // replaced with domain wide state, not a registry setting
        //
        SampDefinedDomains[Index].IsExtendedSidDomain = SampIsExtendedSidModeEmulated(NULL);
    }

    //
    // End any Open DS tansaction
    //

    SampMaybeEndDsTransaction(TransactionCommit);

    return(NtStatus);
}


NTSTATUS
SampDsInitializeDomainObject(
    PSAMP_DOMAIN_INFO DomainInfo,
    ULONG Index,
    BOOLEAN MixedDomain,
    IN      ULONG BehaviorVersion,
    DOMAIN_SERVER_ROLE ServerRole,
    ULONG   LastLogonTimeStampSyncInterval
    )

/*++

Routine Description:

    This routine initializes a domain object within a hosted domain by set-
    ting its domain policy information and descriptors.

    Note that NT4 SAM assumes a single domain policy, because there are only
    the Builtin and Account domains per DC. NT5 supports multiple domains
    per DC, hence the need to obtain policy for each hosted domain. Each of
    the hosted domains contains Builtin and Account domains.

Arguments:

    DomainInfo - Pointer, domain information.

    Index - Index into the SampDefinedDomains array.

    MixedDomain -- Indicates that the given domain is a Mixed Domain

    ServerRole  -- Indicates the role of the server in the domain ( PDC/BDC)
Return Value:

    STATUS_SUCCESS - Successful completion.

    Other error codes from the subroutines.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    NTSTATUS IgnoreStatus = STATUS_INTERNAL_ERROR;
    ULONG SampDefinedDomainsIndex = 0;
    PDSNAME DsName = NULL;
    PWCHAR RelativeName = NULL;

    SAMTRACE("SampDsInitializeDomainObject");

    ASSERT(1 < Index);
    ASSERT(NULL != DomainInfo->DomainDsName);

    // Because the first two slots in the SampDefinedDomains array are
    // currently (temporarily) filled with information from the registry,
    // the Index is "off by 2", so subtract 2 in order get the correct
    // index into the DomainInfo array.

    DsName = DomainInfo[Index - 2].DomainDsName;

    if (NULL != DsName)
    {
        // An index value of 0, 2, 4,...correspond to the Builtin domains,
        // while 1, 3, 5,... correspond to the Account domains. Each pair
        // is a single hosted domain.

        if (0 == (Index % 2))
        {
            SampDiagPrint(INFORM,
                          ("SAMSS: Setting Builtin domain policy\n"));

            NtStatus = SampDsSetBuiltinDomainPolicy(Index);

            SampDiagPrint(INFORM,
                          ("SAMSS: SampDsSetBuiltinDomainPolicy status = 0x%lx\n",
                           NtStatus));
        }
        else
        {
            SampDiagPrint(INFORM,
                          ("SAMSS: Setting Account domain policy\n"));

            NtStatus = SampDsSetDomainPolicy(DsName, Index);

            SampDiagPrint(INFORM,
                          ("SAMSS: SampDsSetDomainPolicy status = 0x%lx\n",
                           NtStatus));
        }
    }
    else
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: Null or invalid domain DS name\n"));
    }

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = SampDsInitializeSingleDomain(DsName,
                                                Index,
                                                MixedDomain,
                                                BehaviorVersion,
                                                ServerRole,
                                                LastLogonTimeStampSyncInterval
                                                );

        SampDiagPrint(INFORM,
                      ("SAMSS: SampDsInitializeSingleDomain status = 0x%lx\n",
                       NtStatus));
    }

    return(NtStatus);
}


NTSTATUS
SampStartDirectoryService(
    VOID
    )

/*++

Routine Description:

    This routine starts the Direcotry Service during system initialization on
    a domain controller. This routine should never be called on a workstation
    or member server.

    NOTE: We may want to add code to perform the first-time conversion of NT4
    SAM registry data to NT5 SAM DS data in this routine, so that upgrades
    are made automatically the first time the NT5 DC is booted.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS or RTL error otherwise.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    DWORD StartTime = 0;
    DWORD StopTime = 0;

    SAMTRACE("SampStartDirectoryService");

    // Should only be here if this is a domain controller.

    ASSERT(NtProductLanManNt == SampProductType);


    StartTime = GetTickCount();
    NtStatus = SampDsInitialize(TRUE);      // SAM loopback enabled
    StopTime = GetTickCount();

   

    KdPrintEx((DPFLTR_SAMSS_ID,
               DPFLTR_INFO_LEVEL,
               "SAMSS: SampDsInitialize status = 0x%lx\n",
               NtStatus));

    if (NT_SUCCESS(NtStatus))
    {
        #ifndef USER_MODE_SAM

        SampDiagPrint(INFORM,
                      ("SAMSS: DsInitialize took %lu seconds to complete\n",
                       ((StopTime - StartTime) / 1000)));

        #endif

        if (NT_SUCCESS(NtStatus))
        {
            // BUG: Where is this defined, and what is it used for?

            // DirectoryInitialized = TRUE;
        }
    }

    return(NtStatus);
}


NTSTATUS
SampDsInitializeDomainObjects(
    VOID
    )

/*++

Routine Description:

    This routine is the top-level domain initialization routine for the NT5
    DC. For each domain object, the array SampDefinedDomains is grown and
    corresponding domain information is placed in the array.

    An NT5 DC has the notion of "hosted domains", each of which contains
    two domains (domain objects): the Builtin and the Account domains.

    An NT5 DC can host multiple domains, so there will be pairs of domain
    objects representing each hosted domain. This routine is responsible
    for initializing the hosted domains.

Arguments:

    None.

Return Value:

    TRUE if successful, else FALSE indicating that one or more domains were
    not initialized.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    NTSTATUS IgnoreStatus = STATUS_SUCCESS;
    SAMP_DOMAIN_INIT_INFO DomainInitInfo;
    BOOLEAN MixedDomain = FALSE;
    ULONG i = 0;
    DOMAIN_SERVER_ROLE ServerRole;
    POLICY_LSA_SERVER_ROLE LsaServerRole;
    ULONG              BehaviorVersion;
    ULONG              LastLogonTimeStampSyncInterval;

    // Call the routine to start and initialize the DS bootstrap information
    // needed to start SAM on the DS.

    // BUG: This routine needs to move into LSA initialization.

    // At the point where LSA is converted to use the DS backing store, it
    // will need to call this routine (or similar), hence, should no longer
    // be called from SAM.

    NtStatus = SampStartDirectoryService();

    if (!NT_SUCCESS(NtStatus))
    {
        // If the directory service could not be started for any reason,
        // SAM server assumes that it will not use the DS for account data,
        // and instead fall back to the registry account data to bring the
        // system "back to life".

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampStartDirectoryService status = 0x%lx\n",
                   NtStatus));

        return(NtStatus);
    }

    //
    // Find out the authoritative domain the ds hosts
    //
    NtStatus = SampDsBuildRootObjectName();
    if ( !NT_SUCCESS( NtStatus ) )
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SampDsBuildRootObjectName failed with 0x%x\n",
                   NtStatus));

        return (NtStatus);
    }

    NtStatus = SampInitWellKnownContainersDsName(RootObjectName);
    if ( !NT_SUCCESS( NtStatus ) )
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SampInitWellKnownContainersDsName failed with 0x%x\n",
                   NtStatus));

        return (NtStatus);
    }

    //
    // Get the server role ( PDC/BDC) of this server in the domain
    // We do this by making a call to the DS and looking at the FSMO.
    //

    NtStatus = SampGetServerRoleFromFSMO(&ServerRole);
    if (!NT_SUCCESS(NtStatus))
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampGetServerRole status = 0x%lx\n",
                   NtStatus));

        return(NtStatus);
    }

    //
    // Tell the static half of netlogon regarding the server role.
    //

    switch (ServerRole)
    {
    case DomainServerRolePrimary:
        LsaServerRole=
            PolicyServerRolePrimary;
        break;

    case DomainServerRoleBackup:
         LsaServerRole=
            PolicyServerRoleBackup;
        break;

    default:
        ASSERT(FALSE && "InvalidServerRole");
        return (STATUS_INTERNAL_ERROR);
    }

    IgnoreStatus = I_NetNotifyRole(
                        LsaServerRole
                        );

    //
    // Retrieve domain settings from root domainDNS object. Need information 
    // like IsMixedDomain, DomainBehaviorVersion, LastLogonTimeStampSyncInterval. 
    //


    NtStatus = SampGetDsDomainSettings(&MixedDomain, 
                                       &BehaviorVersion, 
                                       &LastLogonTimeStampSyncInterval
                                       );

    if (!NT_SUCCESS(NtStatus))
    {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampIsMixedDomain status = 0x%lx\n",
                   NtStatus));

        return(NtStatus);
    }

    //
    // Read our DNS domain Name Information
    //

    //                      INITIALIZE NT5 DS DOMAINS
    //
    // If this domain controller hosts multiple domains, continue initializing
    // the defined-domains array with these domains. Start by getting domain
    // information from the DS, corresponding to the remaining domains.
    //
    // During the period of transition from NT4-to-NT5 domain initialization,
    // this overall routine assumes that the original registry-based domains
    // (Builtin and Account) exist and are initialized as in NT4 -- that is
    // what has happened up to this point of execution.
    //
    // The following code continues the initialization process by setting up
    // any further domains that exist in the DS backing store.
    //
    // Conceptually, each hosted domain contains both the Builtin and Account
    // domains in order to faithfully emulate and support the existing SAM and
    // LSA code.

    // BUG: Should this "bootstrap" info come from the registry instead?
    //
    // The NT4 SAM-LSA account and policy information is created by a variety
    // of procedures (setup, bldsam3.c, etc.) and ensure that enough "boot-
    // strap" information is in the database before SAM initialization. The
    // NT5 SAM initialization (and in particular, domain initialization) also
    // requires similar bootstrapping information, which is not yet implement-
    // ed.

    // Get the startup domain-initialization information from the DS.
    //
    // SampDsGetDomainInitInfoEx presumes a DIT created with dsupgrad and also
    // currently assumes /o=Microsoft/cn=BootstrapDomain as the prefix.

    NtStatus = SampDsGetDomainInitInfoEx(&DomainInitInfo);

    if (NT_SUCCESS(NtStatus) && (NULL != DomainInitInfo.DomainInfo))
    {
        if (0 < DomainInitInfo.DomainCount)
        {
            // There are additional domains, grow the defined-domains array.

            NtStatus = SampExtendDefinedDomains(DomainInitInfo.DomainCount);

            if (NT_SUCCESS(NtStatus))
            {
                // The first two domains are the default Builtin and Account
                // domains of NT4, and were initialized previously. Any re-
                // maining domains are discovered in the DS along with their
                // policy.

                // BUG: Need to disable NT4 registry-based initialization.

                // When the DS/schema/data is fully ready to support the NT5
                // DC, then we can disable the registry-based initialization.

                for (i = 2; i < DomainInitInfo.DomainCount + 2; i++)
                {
                    // Set up each additional domain. This loop iterates over
                    // the domains (there are two domains for each hosted do-
                    // main: Builtin and Account).

                    NtStatus = SampDsInitializeDomainObject(
                                    DomainInitInfo.DomainInfo,
                                    i,
                                    MixedDomain,
                                    BehaviorVersion,
                                    ServerRole,
                                    LastLogonTimeStampSyncInterval
                                    );

                    if (!NT_SUCCESS(NtStatus))
                    {
                        // Error initializing one of the domains in the DS.

                        KdPrintEx((DPFLTR_SAMSS_ID,
                                   DPFLTR_INFO_LEVEL,
                                   "SAMSS: SampDsInitializeDomainObject status = 0x%lx\n",
                                   NtStatus));

                        KdPrintEx((DPFLTR_SAMSS_ID,
                                   DPFLTR_INFO_LEVEL,
                                   "SAMSS: Defined domain index = %lu\n",
                                   i));

                        return(NtStatus);
                    }
                }
            }
            else
            {
                return(NtStatus);
            }
            // comment: Should we catch this failure ???
            // SampExtendDefinedDomains
        }

        SampDiagPrint(INFORM,
                      ("SAMSS: Initialized %lu DS domain(s)\n",
                       DomainInitInfo.DomainCount));
    }
    else
    {
        // Even if there are zero domains, shouldn't get NULL domain
        // information.

        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: SampDsGetDomainInitInfo status = 0x%lx\n",
                   NtStatus));

        return(NtStatus);
    }

    return(STATUS_SUCCESS);
}



NTSTATUS
SampGetDsDomainSettings(
    BOOLEAN * MixedDomain,
    ULONG   * BehaviorVersion,
    ULONG   * LastLogonTimeStampSyncInterval
    )
/*++

        This routine checks the Root domain object, to see if
        that it is a mixed NT4 - NT5 Domain

        Parameters:

                None: Today there is only a single hosted domain. When multiple hosted
                domain support is incorporated, then the domain initilization code needs
                to be revisted, to perform mixed domain initialization, appropriately.

        Return Values

                TRUE -- Is a Mixed Domain
                FALE -- Is a pure NT5 or above Domain

--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    NTSTATUS        IgnoreStatus;
    ATTRTYP         MixedDomainAttrTyp[] = { 
                                             ATT_NT_MIXED_DOMAIN, 
                                             ATT_MS_DS_BEHAVIOR_VERSION, 
                                             ATT_MS_DS_LOGON_TIME_SYNC_INTERVAL
                                           };
    ATTRVAL     MixedDomainAttrVal[] = {{ 1, NULL }, {1,NULL}, {1,NULL}};
    DEFINE_ATTRBLOCK3(MixedDomainAttr,MixedDomainAttrTyp,MixedDomainAttrVal);
    ENTINFSEL   EntInf;
    READARG     ReadArg;
    COMMARG     *pCommArg;
    READRES     *pReadRes;
    ULONG       RetValue;
    ULONG       i;


    SAMTRACE("SampGetDsDomainSettings");

    //
    // Initialize Return Values
    //

    *MixedDomain = FALSE;
    *BehaviorVersion = 0;
    *LastLogonTimeStampSyncInterval = SAMP_DEFAULT_LASTLOGON_TIMESTAMP_SYNC_INTERVAL;

    //
    // Begin a Lazy Transactioning
    //

    NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    //
    // Init ReadArg
    //
    RtlZeroMemory(&ReadArg, sizeof(READARG));

    //
    // Setup up the ENTINFSEL structure
    //

    EntInf.attSel = EN_ATTSET_LIST;
    EntInf.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EntInf.AttrTypBlock = MixedDomainAttr;

    //
    // Build the commarg structure
    //

    pCommArg = &(ReadArg.CommArg);
    BuildStdCommArg(pCommArg);

    //
    // Setup the Read Arg Structure
    //

    ReadArg.pObject = ROOT_OBJECT;
    ReadArg.pSel    = & EntInf;

    //
    // Make the DS call
    //

    SAMTRACE_DS("DirRead");

    RetValue = DirRead(& ReadArg, & pReadRes);

    SAMTRACE_RETURN_CODE_DS(RetValue);

    if (NULL==pReadRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetValue,&pReadRes->CommRes);
    }


    //
    // Process Return values from the DS calls
    //

    if (STATUS_SUCCESS==NtStatus)
    {
        //
        // Successful Read
        //

        for (i=0;i<pReadRes->entry.AttrBlock.attrCount;i++)
        {
            if (pReadRes->entry.AttrBlock.pAttr[i].attrTyp == ATT_NT_MIXED_DOMAIN)
            {
                if (*((ULONG *) (pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0].pVal)))
                {
                    *MixedDomain = TRUE;
                }
                else
                {
                    *MixedDomain = FALSE;
                }
            }

            if (pReadRes->entry.AttrBlock.pAttr[i].attrTyp == ATT_MS_DS_BEHAVIOR_VERSION)
            {
                *BehaviorVersion = 
                    (*((ULONG *) (pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0].pVal)));
            }

            if (pReadRes->entry.AttrBlock.pAttr[i].attrTyp == ATT_MS_DS_LOGON_TIME_SYNC_INTERVAL)
            {
                *LastLogonTimeStampSyncInterval = 
                    (*((ULONG *) (pReadRes->entry.AttrBlock.pAttr[i].AttrVal.pAVal[0].pVal)));
            }
        }
    }
    else if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE == NtStatus)
    {
        *MixedDomain = FALSE;
        NtStatus = STATUS_SUCCESS;
    }

    //
    // To prevent data overflow, if the value is greater than 100000. 
    // Set it to 100000 (it is 274 years, customer will not notice that). 
    // 

    if (*LastLogonTimeStampSyncInterval > 100000)
    {
        *LastLogonTimeStampSyncInterval = 100000;
    }


    //
    // Clear any errors
    //

    SampClearErrors();

    //
    // Close the Transaction
    //

    IgnoreStatus = SampMaybeEndDsTransaction(TransactionCommit);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    SampDiagPrint(INFORM,("SAMSS: Query For Mixed NT Domain,Mixed Domain=%d,Error Code=%d\n",
                                                                    *MixedDomain,NtStatus));
#if DBG

    //
    // This is for checked build only. If this regkey is set, 
    // LastLogonTimeStampSyncInterval will be a "unit" by minute instead 
    // of "days", which helps to test this feature.
    // 

    {
        ULONG   WinError = ERROR_SUCCESS;
        HKEY    LsaKey;
        DWORD   dwType, dwSize = sizeof(DWORD), dwValue = 0;

        WinError = RegOpenKey(HKEY_LOCAL_MACHINE,
                              __TEXT("System\\CurrentControlSet\\Control\\Lsa"),
                              &LsaKey
                              );

        if (ERROR_SUCCESS == WinError)
        {
            WinError = RegQueryValueEx(LsaKey,
                                       __TEXT("UpdateLastLogonTSByMinute"),
                                       NULL,
                                       &dwType,
                                       (LPBYTE)&dwValue,
                                       &dwSize
                                       );

            if ((ERROR_SUCCESS == WinError) && 
                (REG_DWORD == dwType) &&
                (1 == dwValue))
            {
                SampLastLogonTimeStampSyncByMinute = TRUE;
            }

            RegCloseKey(LsaKey);
        }
    }
#endif

    return NtStatus;
}


BOOLEAN
SamIMixedDomain(
  IN SAMPR_HANDLE DomainHandle
  )
/*++

    Routine Description

          Tells in process clients wether we are in a mixed domain
          environment. No Validation of the domain handle is performed

    Parameters:

          DomainHandle -- Handle to the Domain

    Return Values

         TRUE means mixed domain
         FALSE means non mixed domain
--*/
{

      if (!SampUseDsData)
      {
         //
         // Registry Mode, we are always mixed domain
         //

         return (TRUE);
      }

      return ( DownLevelDomainControllersPresent(
                  ((PSAMP_OBJECT) DomainHandle)->DomainIndex));
}

NTSTATUS
SamIMixedDomain2(
  IN PSID DomainSid,
  OUT BOOLEAN *MixedDomain
  )
/*++

    Routine Description

          Tells in process clients wether we are in a mixed domain
          environment. No Validation of the domain handle is performed

    Parameters:

          DomainSid -- Sid of the Domain
          MixedDomain --- Result is returned in here. TRUE means the domain
                          is in mixed mode

    Return Values

         STATUS_SUCCESS
         STATUS_INVALID_PARAMETER
         STATUS_NO_SUCH_DOMAIN
--*/
{
      ULONG DomainIndex;

      if (!RtlValidSid(DomainSid))
          return STATUS_INVALID_PARAMETER;

      if (!SampUseDsData)
      {
         //
         // Registry Mode, we are always mixed domain
         //

         *MixedDomain=TRUE;
         return STATUS_SUCCESS;
      }

      for (DomainIndex=SampDsGetPrimaryDomainStart();
                DomainIndex<SampDefinedDomainsCount;DomainIndex++)
      {
        if (RtlEqualSid(SampDefinedDomains[DomainIndex].Sid,
                            DomainSid))
        {
            break;
        }
      }

      if (DomainIndex>=SampDefinedDomainsCount)
          return STATUS_NO_SUCH_DOMAIN;



      if ( DownLevelDomainControllersPresent(
                  DomainIndex))
      {
          *MixedDomain = TRUE;
      }
      else
      {
          *MixedDomain = FALSE;
      }

      return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\dbgutilp.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dbgutilp.h

Abstract:

    This file contains private debugging routines, macros, etc. for the SAM
    server. All debugging utilities should be added to this file, or to the
    dbgutil.c file.

    See below comments for more information on how to use these routines,
    how to add new routines, and how to add or remove them from the build.

    IF DEBUGGING CODE IS NEEDED THAT IS DEPENDENT ON BUILD TYPE, THEN THIS
    CODE SHOULD STRICTLY RELY ON THE DEFINITION OF THE PROJECT-WIDE NT DE-
    BUGGING MACRO "DBG". THIS IS AUTOMATICALLY DEFINED FOR CHECKED BUILDS,
    AND WILL ENABLE THE SamKdPrint or SampDiagPrint MACROS (via NT KdPrint),
    FOR INSTANCE.

    EXAMPLE USAGE:

    if (DBG == 1)
    {
        CHAR DebugBuffer[64] = "Some Debug Message...";
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: %s\n",
                   DebugBuffer));

        SampDiagPrint(INFORM, ("SAMSS: Another Debug Message...\n));
    }

    or

    KdPrintEx((DPFLTR_SAMSS_ID,
               DPFLTR_INFO_LEVEL,
               "SAMSS: Some status message\n"));

    or

    SampDiagPrint(INFORM, ("SAMSS: Another Debug Message...\n));

    Note that output verbosity from SampDiagPrint can be set in the debugger
    by setting the value of SampGlobalFlag to the SAMP_DIAG_ flags defined
    below.

    IF A DEBUGGING MESSAGE IS NEEEDED REGARDLESS OF THE BUILD TYPE, THEN USE
    THE SamOutputDebugString MACRO.

    EXAMPLE USAGE:

    SamOutputDebugString("SAMSS: Mandatory Debug Message...\n");

    Note that all SAM server debug output begins with "SAMSS:" or "[SAMSS]"
    so that the SAM server debug output can be distinguished from the other
    components in the system.

Author:

    Chris Mayhall (ChrisMay)  04-Apr-1996

Environment:

    User Mode - Win32

Revision History:

    04-Apr-1996 ChrisMay
        Created.
    02-Dec-1996 ChrisMay
        Clean up, re-organized, removed obsolete routines, documented how
        to use all this stuff, added filtered KdPrint output.
    05-Dec-1996 ChrisMay
        Moved the SAM diagnostic routines from samsrvp.h to this file.
    07-Feb-1997 ChrisMay
        Added RID manager debug flag.

--*/

#ifndef _DBGUTILP_
#define _DBGUTILP_

// SAM server debugging facility consists of the following macros and compile-
// time flags:
//
// -SampDiagPrint: This macro is enabled in checked builds of the system, and
//  relies on the global variable "SampGlobalFlag" to filter the diagnostic
//  output. In non-checked builds, this code is not included in the server.
//  This macro is intended to be used for informational output that would
//  normally be too verbose by default. Be default, SampGlobalFlag is set
//  to zero, disabling any output to the debugger. See the SAMP_DIAG_ flags
//  defined below for enabling output.
//
// -SAMP_TRACE: Per-routine tracing output to the debugger when this flag is
//  set to 1. This displays the SAM server routine name on the debugger when
//  it is called. This can be enabled in checked or free builds of the ser-
//  ver.
//
// -SAMP_DUMP: A set of routines that will dump registry blobs, security
//  descriptors, ACL's, etc. when this flag is set to 1. This can be enabled
//  in checked or free builds of the server.
//
// These flags are compile-time flags, that when set to 1 include the debug
// code in the build, or when set to 0 do not include the code in the build.
//
// By default, SAMP_DUMP is set to 0 to reduce debugger output, particularly
// on a domain controller.
//
// SAMP_TRACE is set to 1 so that the routines are compiled into the code
// (during development), but note that this debug mechanism also refers to
// runtime variables (set via the debugger) to control how much output is
// sent to the debugger (see below). This allows the developer to dynamically
// filter trace output, while the server is running. No trace output will
// be generated by default, the runtime variables must be set first.
//
// The runtime variables that allow the developer to control how much infor-
// mation is sent to the debugger are "SampTraceTag" and "SampTraceFileTag",
// as defined in dbgutil.c. They can be set from a debugger, as documented
// in dbgutil.c.
//
// Debug output is filtered at two levels: A global level and a component
// specific level.
//
// Each debug output request specifies a component id and a filter level
// or mask. These variables are used to access the debug print filter
// database maintained by the system. The component id selects a 32-bit
// mask value and the level either specified a bit within that mask or is
// as mask value itself.
//
// If any of the bits specified by the level or mask are set in either the
// component mask or the global mask, then the debug output is permitted.
// Otherwise, the debug output is filtered and not printed.
//
// The component mask for filtering the debug output of this component is
// Kd_SAMSS_Mask and may be set via the registry or the kernel debugger.
//
// The global mask for filtering the debug output of all components is
// Kd_WIN2000_Mask and may be set via the registry or the kernel debugger.
//
// The registry key for setting the mask value for this component is:
//
// HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\
//     Session Manager\Debug Print Filter\SAMSS
//
// The key "Debug Print Filter" may have to be created in order to create
// the component key.
//
// A typical debug output request is:
//
//    KdPrintEx((DPFLTR_SAMSS_ID,
//               DPFLTR_INFO_LEVEL,
//               "SAMSS: Some status message\n"));
//

#define SAMP_TRACE      0
#define SAMP_DUMP       0

// These flags are used by the tracing routines to determine what is traced.
// If SampTraceTags is set to 1, then trace SAM server exported routines. If
// SampTraceTags is set to 2, then trace the routines within a specified src
// code file. if trace is 4 then trace all DS calls and their return values
// if trace is 8 output ticks

#define SAM_TRACE_EXPORTS       0x00000001
#define SAM_TRACE_FILE_BASIS    0x00000002
#define SAM_TRACE_DS            0x00000004
#define SAM_TRACE_TICKS         0x00000008


// The src code file is specified via the SampTraceFileTags variable.  The
// value of this variable is based on the TraceTable (refer to dbgutil.c for
// the entries), or if set to 0xffffffff, will trace all SAM server routines.
// As new src code files are added to the project, the list of files in the
// TraceTable should be updated as well.

#define SAM_TRACE_ALL           0xffffffff

//======================SAM SERVER DIAGNOSTIC ROUTINES========================

// The following define controls the diagnostic capabilities that are built
// into SAM. The SampDiagPrint routine should be used whenever informational
// or verbose output is required. This output is only available in checked
// builds, and is settable from the debugger (set SampGlobalFlag).

#if (DBG == 1)

#define SAMP_DIAGNOSTICS 1

#endif // DBG


#if (SAMP_DIAGNOSTICS == 1)

// Test for diagnostics enabled.

#define IF_SAMP_GLOBAL( FlagName ) \
    if (SampGlobalFlag & (SAMP_DIAG_##FlagName))

#define IF_NOT_SAMP_GLOBAL( FlagName ) \
    if ( !(SampGlobalFlag & (SAMP_DIAG_##FlagName)) )

// Diagnostics print statement

#define SampDiagPrint( FlagName, _Text_ )\
    IF_SAMP_GLOBAL( FlagName )\
        DbgPrint _Text_

#else

#define IF_SAMP_GLOBAL( FlagName ) if (FALSE)
#define IF_NOT_SAMP_GLOBAL ( FlagName ) if (TRUE)
#define SampDiagPrint( FlagName, Text ) ;

#endif // SAMP_DIAGNOSTICS


// The following flags enable or disable various diagnostic capabilities
// within SAM.  The value of SampGlobalFlag can be set to one or more of
// these flags from the debugger.
//
//      DISPLAY_CACHE - print diagnostic messages related
//          to the display cache (additions, deletions,
//          modifications, etc).
//
//      DISPLAY_LOCKOUT - print diagnostic messages related
//          to account lockout.
//
//      DISPLAY_ROLE_CHANGES - print diagnostic messages related
//          to primary/backup role changes.
//
//      DISPLAY_CACHE_ERRORS - print diagnostic messages related to
//          errors when manipulating the display cache.
//
//      DISPLAY_STORAGE_FAIL - print diagnostic messages related to
//          backing store failures.
//
//      BREAK_ON_STORAGE_FAIL - breakpoint if an attempt to write
//          to backing store fails.
//
//      CONTEXT_TRACKING - print diagnostic messages related to
//          object context usage (creation / deletion, etc.).
//
//      ACTIVATE_DEBUG_PROC - activate a process for use as a diagnostic
//          aid.  This is expected to be used only during SETUP testing.
//
//      DISPLAY_ADMIN_CHANGES - print diagnostic messages related to
//          changing user account protection to allow or dissallow
//          Account Operator access to admin or normal user accounts.
//
//      LOGON - Traces some of the important activiites that pertain
//          to the logon sequence.
//
//      NT5_ACCESS_CHECKS - Traces and prints some information regarding NT5
//          Access checks.
//
//      SD_DUMP - Dumps out the security descriptor during the check.
//
//      SD_CONVERT - Prints diagnostic messages about security coonversions.
//
//      FORCE_FULL_SD_CONVERSION - Is used to disable the standard ACL recognition
//         mecahnism for NT4 to NT5 security descriptor conversions. This can test
//         the enhanced ACL mechanism efficiently
//
//      SAMP_DIAG_BREAK_ON_CHECK -- Forces a Debug Break, Just before we call access
//         check by type result list. Useful in verifying what the function returned
//
//      PROMOTE -- prints out infomation relating to the promotion or
//                 demotion of a SAM server
//
//      RID_TRACE -- Traces information regarding Rid Allocations.
//
//
//      OBJECT_CONFLICT -- Prints information regarding SAM account Name and
//                         Sid Conflicts
//
//      INFORM - Generic informational flag, used to display verbose or
//          frequently occurring status messages that are not tied to a
//          specific sub-system or component. This is not intended to be
//          used for error reporting, rather for informational status.
//

#define SAMP_DIAG_DISPLAY_CACHE             ((ULONG) 0x00000001L)
#define SAMP_DIAG_DISPLAY_LOCKOUT           ((ULONG) 0x00000002L)
#define SAMP_DIAG_DISPLAY_ROLE_CHANGES      ((ULONG) 0x00000004L)
#define SAMP_DIAG_DISPLAY_CACHE_ERRORS      ((ULONG) 0x00000008L)
#define SAMP_DIAG_DISPLAY_STORAGE_FAIL      ((ULONG) 0x00000010L)
#define SAMP_DIAG_BREAK_ON_STORAGE_FAIL     ((ULONG) 0x00000020L)
#define SAMP_DIAG_CONTEXT_TRACKING          ((ULONG) 0x00000040L)
#define SAMP_DIAG_ACTIVATE_DEBUG_PROC       ((ULONG) 0x00000080L)
#define SAMP_DIAG_DISPLAY_ADMIN_CHANGES     ((ULONG) 0x00000100L)
#define SAMP_DIAG_LOGON                     ((ULONG) 0x00000200L)
#define SAMP_DIAG_NT5_ACCESS_CHECKS         ((ULONG) 0x00000400L)
#define SAMP_DIAG_SD_DUMP                   ((ULONG) 0x00000800L)
#define SAMP_DIAG_SD_CONVERSION             ((ULONG) 0x00001000L)
#define SAMP_DIAG_RID_MANAGER               ((ULONG) 0x00002000L)
#define SAMP_DIAG_FORCE_FULL_SD_CONVERSION  ((ULONG) 0x00004000L)
#define SAMP_DIAG_BREAK_ON_CHECK            ((ULONG) 0x00008000L)
#define SAMP_DIAG_PROMOTE                   ((ULONG) 0x00010000L)
#define SAMP_DIAG_RID_TRACE                 ((ULONG) 0x00020000L)
#define SAMP_DIAG_OBJECT_CONFLICT           ((ULONG) 0x00040000L)

#define SAMP_DIAG_INFORM                    ((ULONG) 0x80000000L)


// Choose a print type appropriate to how we are building.

#ifdef SAMP_BUILD_CONSOLE_PROGRAM

#define BldPrint printf

#else

#define BldPrint DbgPrint

#endif // SAMP_BUILD_CONSOLE_PROGRAM


#if (SAMP_DIAGNOSTICS == 1)

extern ULONG SampGlobalFlag;

#endif // SAMP_DIAGNOSTICS


// Define this symbol to get context tracking messages printed (otherwise,
// comment it out).

//#define SAMP_DBG_CONTEXT_TRACKING

#ifdef SAMP_DBG_CONTEXT_TRACKING

VOID
SampDumpContexts(
    VOID
    );

#endif

//======================SAM SERVER TRACING ROUTINES===========================

#if (SAMP_TRACE == 1)

#define SAMTRACE(a)                    SamIDebugOutput(__FILE__,a,SAM_TRACE_FILE_BASIS);\
                                            SamIDebugFileLineOutput(__FILE__, __LINE__, SAM_TRACE_FILE_BASIS);

#define SAMTRACE_EX(a)                 SamIDebugOutput(__FILE__,a,(SAM_TRACE_EXPORTS|SAM_TRACE_FILE_BASIS));\
                                            SamIDebugFileLineOutput(__FILE__, __LINE__, (SAM_TRACE_EXPORTS|SAM_TRACE_FILE_BASIS));

#define SAMTRACE_DS(a)                 SamIDebugOutput(__FILE__,a,SAM_TRACE_DS);\
                                            SamIDebugFileLineOutput(__FILE__,__LINE__,(SAM_TRACE_DS));

#define SAMTRACE_RETURN_CODE(rc)       SamIDebugOutputReturnCode(__FILE__,rc,SAM_TRACE_FILE_BASIS);\
                                            SamIDebugFileLineOutput(__FILE__, __LINE__|SAM_TRACE_FILE_BASIS);

#define SAMTRACE_RETURN_CODE_EX(rc)    SamIDebugOutputReturnCode(__FILE__,rc,SAM_TRACE_EXPORTS|SAM_TRACE_FILE_BASIS);\
                                            SamIDebugFileLineOutput(__FILE__, __LINE__, (SAM_TRACE_EXPORTS|SAM_TRACE_FILE_BASIS));

#define SAMTRACE_RETURN_CODE_DS(rc)    SamIDebugOutputReturnCode(__FILE__,rc,SAM_TRACE_DS);\
                                            SamIDebugFileLineOutput(__FILE__, __LINE__, (SAM_TRACE_DS));

#else

#define SAMTRACE(a)
#define SAMTRACE_EX(a)
#define SAMTRACE_RETURN_CODE(rc)
#define SAMTRACE_RETURN_CODE_EX(rc)
#define SAMTRACE_DS(a)
#define SAMTRACE_RETURN_CODE_DS(rc)

#endif

// Define the Trace Table structure for tracing on a file by file basis.

typedef struct {
    LPSTR FileName;
    ULONGLONG TraceBit;
} TRACE_TABLE_ENTRY;

//======================SAM SERVER DUMPING ROUTINES===========================

#if (SAMP_DUMP == 1)

#define SampDumpNtSetValueKey(a, b, c, d, e)        SamIDebugFileLineOutput(__FILE__, __LINE__,SAM_TRACE_ALL); SamIDumpNtSetValueKey(a, b, c, d, e)
#define SampDumpRtlpNtSetValueKey(a, b, c)          SamIDebugFileLineOutput(__FILE__, __LINE__,SAM_TRACE_ALL); SamIDumpRtlpNtSetValueKey(a, b, c)
#define SampDumpNtEnumerateKey(a, b, c, d, e)       SamIDebugFileLineOutput(__FILE__, __LINE__,SAM_TRACE_ALL); SamIDumpNtEnumerateKey(a, b, c, d, e)
#define SampDumpRtlpNtEnumerateSubKey(a, b, c)      SamIDebugFileLineOutput(__FILE__, __LINE__,SAM_TRACE_ALL); SamIDumpRtlpNtEnumerateSubKey(a, b, c)
#define SampDumpNtOpenKey(a, b, c)                  SamIDebugFileLineOutput(__FILE__, __LINE__,SAM_TRACE_ALL); SamIDumpNtOpenKey(a, b, c);
#define SampDumpNtQueryKey(a, b, c, d)              SamIDebugFileLineOutput(__FILE__, __LINE__,SAM_TRACE_ALL); SamIDumpNtQueryKey(a, b, c, d)
#define SampDumpNtQueryValueKey(a, b, c, d, e)      SamIDebugFileLineOutput(__FILE__, __LINE__,SAM_TRACE_ALL); SamIDumpNtQueryValueKey(a, b, c, d, e)
#define SampDumpRtlpNtQueryValueKey(a, b, c, d)     SamIDebugFileLineOutput(__FILE__, __LINE__,SAM_TRACE_ALL); SamIDumpRtlpNtQueryValueKey(a, b, c, d)
#define SampDumpRXact(a, b, c, d, e, f, g, h, i)    SamIDebugFileLineOutput(__FILE__, __LINE__,SAM_TRACE_ALL); SamIDumpRXact(a, b, c, d, e, f, g, h, i)

#else

#define SampDumpNtSetValueKey(a, b, c, d, e)
#define SampDumpRtlpNtSetValueKey(a, b, c)
#define SampDumpNtEnumerateKey(a, b, c, d, e)
#define SampDumpRtlpNtEnumerateSubKey(a, b, c)
#define SampDumpNtOpenKey(a, b, c)
#define SampDumpNtQueryKey(a, b, c, d)
#define SampDumpNtQueryValueKey(a, b, c, d, e)
#define SampDumpRtlpNtQueryValueKey(a, b, c, d)
#define SampDumpRXact(a, b, c, d, e, f, g, h, i)

#endif

// These debugging flags are used in the dumping routines to help identify
// what kind of SAM object is being dumped.

#define FIXED_LENGTH_SERVER_FLAG                 0
#define FIXED_LENGTH_DOMAIN_FLAG                 1
#define FIXED_LENGTH_ALIAS_FLAG                  2
#define FIXED_LENGTH_GROUP_FLAG                  3
#define FIXED_LENGTH_USER_FLAG                   4
#define VARIABLE_LENGTH_ATTRIBUTE_FLAG           5
#define FixedBufferAddressFlag                   6

//===============SAM SERVER PRIVATE DEBUG ROUTINE DECLARATIONS================

VOID
SamIDebugOutput(
    IN LPSTR FileName,
    IN LPSTR DebugMessage,
    IN ULONG TraceLevel
    );

VOID
SamIDebugFileLineOutput(
    IN LPSTR FileName,
    IN ULONG LineNumber,
    IN ULONG TraceLevel
    );

VOID
SamIDebugOutputReturnCode(
    IN  LPSTR   FileName,
    IN  ULONG   ReturnCode,
    IN  ULONG   TraceLevel
    );

VOID
SamIDumpNtSetValueKey(
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );

VOID
SamIDumpRtlpNtSetValueKey(
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    );

VOID
SamIDumpNtEnumerateKey(
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    );

VOID
SamIDumpRtlpNtEnumerateSubKey(
    IN PUNICODE_STRING SubKeyName,
    IN PSAM_ENUMERATE_HANDLE Index,
    IN LARGE_INTEGER LastWriteTime
    );

VOID
SamIDumpNtOpenKey(
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG Options
    );

VOID
SamIDumpNtQueryKey(
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    IN PVOID KeyInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    );

VOID
SamIDumpNtQueryValueKey(
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    );

VOID
SamIDumpRtlpNtQueryValueKey(
    IN PULONG KeyValueType,
    IN PVOID KeyValue,
    IN PULONG KeyValueLength,
    IN PLARGE_INTEGER LastWriteTime
    );

VOID
SamIDumpRXact(
    IN PRTL_RXACT_CONTEXT TransactionContext,
    IN RTL_RXACT_OPERATION Operation,
    IN PUNICODE_STRING SubKeyName,
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING AttributeName,
    IN ULONG RegistryKeyType,
    IN PVOID NewValue,
    IN ULONG NewValueLength,
    IN ULONG NewValueType
    );
VOID
SampDumpBinaryData(
    PBYTE   pData,
    DWORD   cbData
    );

#endif  //_DBGUTILP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\domain.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    domain.c

Abstract:

    This file contains services related to the SAM "domain" object.


Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:

    ChrisMay    16-Aug-96
        Added initial code for DS-based domain initialization.
    ChrisMay    08-Oct-96
        Added crash-recovery code.
    ChrisMay    31-Jan-97
        Added multi-master RID management routines for account creation.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include "ntlsa.h"
#include "lmcons.h"                                    // LM20_PWLEN
#include "msaudite.h"
#include <nlrepl.h>                   // I_NetNotifyMachineAccount prototype
#include <ridmgr.h>
#include <enckey.h>
#include <wxlpc.h>
#include <cryptdll.h>
#include "dslayer.h"
#include "attids.h"
#include "filtypes.h"
#include "sdconvrt.h"
#include <dnsapi.h>
#include <samtrace.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SampInitializeSingleDomain(
    ULONG Index
    );

NTSTATUS
SampSetDomainPolicy(
    VOID
    );

NTSTATUS
SampSetDcDomainPolicy(
    VOID
    );

NTSTATUS
SampBuildDomainKeyName(
    OUT PUNICODE_STRING DomainKeyName,
    IN PUNICODE_STRING DomainName OPTIONAL
    );

NTSTATUS
SampDoGroupCreationChecks(
    IN PSAMP_OBJECT DomainContext
    );

NTSTATUS
SampDoAliasCreationChecks(
    IN PSAMP_OBJECT DomainContext
    );

NTSTATUS
SampDoUserCreationChecks(
    IN PSAMP_OBJECT DomainContext,
    IN  ULONG   AccountType,
    OUT BOOLEAN *CreateByPrivilege,
    OUT ULONG   *pAccessRestriction
    );


NTSTATUS
SampCheckForDuplicateSids(
    PSAMP_OBJECT DomainContext,
    ULONG   NewAccountRid
    );

NTSTATUS
SampGetAccountNameFromRid(
    OUT PRPC_UNICODE_STRING AccountName,
    IN ULONG Rid
    );


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// RPC Dispatch routines                                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



NTSTATUS
SamrOpenDomain(
    IN SAMPR_HANDLE ServerHandle,
    IN ACCESS_MASK DesiredAccess,
    IN PRPC_SID DomainId,
    OUT SAMPR_HANDLE *DomainHandle
    )

/*++

Routine Description:

    This service is the RPC dispatch routine for SamrOpenDomain().

Arguments:

    ServerHandle - An active context handle to a Server object.

    Access desired to the domain.

    DomainId - The SID of the domain to open.

    DomainHandle - If successful, will receive the context handle value
        for the newly opened domain.  Otherwise, NULL is returned.

Return Value:

    STATUS_SUCCESS - The object has been successfully openned.

    STATUS_INSUFFICIENT_RESOURCES - The SAM server processes doesn't
        have sufficient resources to process or accept another connection
        at this time.

    Other values as may be returned from:

            NtAccessCheckAndAuditAlarm()


--*/
{
    NTSTATUS            NtStatus, IgnoreStatus;
    PSAMP_OBJECT        DomainContext, ServerContext = (PSAMP_OBJECT)ServerHandle;
    SAMP_OBJECT_TYPE    FoundType;
    BOOLEAN             fLockAcquired = FALSE; 
    DECLARE_CLIENT_REVISION(ServerHandle);

    SAMTRACE_EX("SamrOpenDomain");

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidOpenDomain
                   );

    //
    // Parameter Validation
    //   1. Lookup Context will validate ServerHandle
    //   2. Desired Access need not be validated. Invalid combinations will
    //      be failed by access check
    //       3. DomainId and DomainHandle are validated here
    //

    if (!RtlValidSid(DomainId))
    {
            NtStatus = STATUS_INVALID_PARAMETER;
            SAMTRACE_RETURN_CODE_EX(NtStatus);
            goto Error;
    }



    //
    // Grab a read lock (if necessary). Lock is not required for loopback client
    //
    
    SampMaybeAcquireReadLock(ServerContext, 
                             DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                             &fLockAcquired);


    //
    // Validate type of, and access to server object.
    //

    NtStatus = SampLookupContext(
                   ServerContext,
                   SAM_SERVER_LOOKUP_DOMAIN,       // DesiredAccess
                   SampServerObjectType,           // ExpectedType
                   &FoundType
                   );


    if (NT_SUCCESS(NtStatus)) {

        //
        // Try to create a context for the domain.
        //

        DomainContext = SampCreateContextEx(
                            SampDomainObjectType,
                            ServerContext->TrustedClient,
                            IsDsObject(ServerContext),
                            ServerContext->NotSharedByMultiThreads, 
                            ServerContext->LoopbackClient,
                            FALSE,          // lazy commit
                            FALSE,          // persistaccrosscall
                            FALSE,          // buffered write 
                            FALSE,          // Opened By DCPromo
                            SampDsGetPrimaryDomainStart()
                            );
                    
        if (DomainContext != NULL) {

            //
            // Set the client revision appropriately
            //

            DomainContext->ClientRevision = ServerContext->ClientRevision;

            //
            // Open the specified domain's registry key in Registry mode
            // In DS mode this sets the object's DS Name
            //

            //
            // Do not set transaction in domain for if we in DS mode
            //
            NtStatus = SampOpenDomainKey(
                           DomainContext,
                           DomainId,
                           IsDsObject(ServerContext)?FALSE:TRUE
                           );

            if (NT_SUCCESS(NtStatus)) {


                //
                // Reference the object for the validation
                //

                SampReferenceContext(DomainContext);



                //
                // Validate the caller's access.
                //

                NtStatus = SampValidateObjectAccess(
                               DomainContext,                //Context
                               DesiredAccess,                //DesiredAccess
                               FALSE                         //ObjectCreation
                               );

                if ( NT_SUCCESS(NtStatus) ) {

                    //
                    // Validate the client's ability to understand this domain
                    //
                    if ( SampIsContextFromExtendedSidDomain(DomainContext)
                      && DomainContext->ClientRevision < SAM_NETWORK_REVISION_3 ) {

                        NtStatus = STATUS_NOT_SUPPORTED;
                    }
                }

                //
                // Dereference object, discarding any changes
                //

                if (fLockAcquired)
                {
                    IgnoreStatus = SampDeReferenceContext(DomainContext, FALSE);
                }
                else
                {
                    IgnoreStatus = SampDeReferenceContext2(DomainContext, FALSE);
                }
                ASSERT(NT_SUCCESS(IgnoreStatus));

                //
                // if we didn't pass the access test, then free up the context
                // block and return the error status returned from the access
                // validation routine.  Otherwise, return the context handle
                // value.
                //

                if (!NT_SUCCESS(NtStatus)) {
                    SampDeleteContext( DomainContext );
                } else {
                    (*DomainHandle) = DomainContext;
                }
            } else {
                //
                // SampOpenDomainKey failed
                //

                SampDeleteContext( DomainContext );
            }

        } else {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }


        //
        // De-reference the server object
        //

        IgnoreStatus = SampDeReferenceContext( ServerContext, FALSE );
    }

    //
    // Free the read lock
    //


    SampMaybeReleaseReadLock(fLockAcquired);


    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidOpenDomain
                   );


    return(NtStatus);


}


NTSTATUS
SamrQueryInformationDomain2(
    IN SAMPR_HANDLE DomainHandle,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass,
    OUT PSAMPR_DOMAIN_INFO_BUFFER *Buffer
    )
{
    //
    // This is a thin veil to SamrQueryInformationDomain().
    // This is needed so that new-release systems can call
    // this routine without the danger of passing an info
    // level that release 1.0 systems didn't understand.
    //

    return( SamrQueryInformationDomain(DomainHandle, DomainInformationClass, Buffer ) );
}

NTSTATUS
SamrQueryInformationDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass,
    OUT PSAMPR_DOMAIN_INFO_BUFFER *Buffer
    )

/*++

Routine Description:

    This service retrieves information about a domain object.

Arguments:

    DomainHandle - A handle obtained via a previous call to SamrOpenDomain().

    DomainInformationClass - Indicates the type of information to retrieve.

    Buffer - Receives the requested information.  Several blocks of memory
        will be returned: (one) containing a pointer to the (second) which
        contains the requested information structure.  This block may contain
        pointers, which will point to other blocks of allocated memory, such
        as string buffers.  All of these blocks of memory must be
        (independently) deallocated using MIDL_user_free().

Return Value:


    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_ACCESS_DENIED - Caller's handle does not have the appropriate
        access to the object.


--*/
{

    NTSTATUS                NtStatus, IgnoreStatus;
    PSAMP_OBJECT            DomainContext;
    SAMP_OBJECT_TYPE        FoundType;
    ACCESS_MASK             DesiredAccess;
    PSAMP_DEFINED_DOMAINS   Domain;
    ULONG                   i;


    //
    // Used for tracking allocated blocks of memory - so we can deallocate
    // them in case of error.  Don't exceed this number of allocated buffers.
    //                                      ||
    //                                      vv
    PVOID                   AllocatedBuffer[10];
    ULONG                   AllocatedBufferCount = 0;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrQueryInformationDomain");

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidQueryInformationDomain
                   );


#define RegisterBuffer(Buffer)                               \
    if ((Buffer) != NULL) {                                  \
        ASSERT(AllocatedBufferCount < sizeof(AllocatedBuffer)/sizeof(*AllocatedBuffer)); \
        AllocatedBuffer[AllocatedBufferCount++] = (Buffer);  \
    }

#define AllocateBuffer(BufferPointer, Size)                  \
    (BufferPointer) = MIDL_user_allocate((Size));            \
    RegisterBuffer((BufferPointer));


    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (Buffer != NULL);
    ASSERT ((*Buffer) == NULL);

    if (!((Buffer!=NULL) && (*Buffer==NULL)))
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }

    //
    // Set the desired access based upon the Info class
    //

    switch (DomainInformationClass) {

    case DomainPasswordInformation:
    case DomainLockoutInformation:

        DesiredAccess = DOMAIN_READ_PASSWORD_PARAMETERS;
        break;


    case DomainGeneralInformation:
    case DomainLogoffInformation:
    case DomainOemInformation:
    case DomainNameInformation:
    case DomainServerRoleInformation:
    case DomainReplicationInformation:
    case DomainModifiedInformation:
    case DomainStateInformation:
    case DomainUasInformation:
    case DomainModifiedInformation2:

        DesiredAccess = DOMAIN_READ_OTHER_PARAMETERS;
        break;


    case DomainGeneralInformation2:

        DesiredAccess = DOMAIN_READ_PASSWORD_PARAMETERS |
                        DOMAIN_READ_OTHER_PARAMETERS;
        break;

    default:
        NtStatus = STATUS_INVALID_INFO_CLASS;
        goto Error;
    } // end_switch



    //
    // Allocate the info structure
    //

    AllocateBuffer(*Buffer, sizeof(SAMPR_DOMAIN_INFO_BUFFER) );
    if ((*Buffer) == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    SampAcquireReadLock();


    //
    // Validate type of, and access to object.
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;
    NtStatus = SampLookupContext(
                   DomainContext,
                   DesiredAccess,
                   SampDomainObjectType,           // ExpectedType
                   &FoundType
                   );


    ClientRevision = DomainContext->ClientRevision;

    if (NT_SUCCESS(NtStatus)) {

        Domain = &SampDefinedDomains[ DomainContext->DomainIndex ];


        //
        // case on the type information requested
        //

        switch (DomainInformationClass) {

        case DomainUasInformation:

            (*Buffer)->General.UasCompatibilityRequired =
                Domain->UnmodifiedFixed.UasCompatibilityRequired;

            break;


        case DomainGeneralInformation2:


            (*Buffer)->General2.LockoutDuration =
                Domain->UnmodifiedFixed.LockoutDuration;

            (*Buffer)->General2.LockoutObservationWindow =
                Domain->UnmodifiedFixed.LockoutObservationWindow;

            (*Buffer)->General2.LockoutThreshold =
                Domain->UnmodifiedFixed.LockoutThreshold;



            //
            // WARNING - GeneralInformation2 falls into the
            // GeneralInformation code for the rest of its processing.
            // This action assumes that the beginning of a GeneralInformation2
            // structure is a GeneralInformation structure !!!
            //

            // don't break;

        case DomainGeneralInformation:

            ///////////////////////////////////////////////////////
            //                                                   //
            // Warning, the previous case falls into this case.  //
            // Be aware of this when working on this code.       //
            //                                                   //
            ///////////////////////////////////////////////////////

            (*Buffer)->General.ForceLogoff =
                *((POLD_LARGE_INTEGER)&Domain->UnmodifiedFixed.ForceLogoff);

            (*Buffer)->General.DomainModifiedCount =
                *((POLD_LARGE_INTEGER)&Domain->NetLogonChangeLogSerialNumber);

            (*Buffer)->General.DomainServerState =
                Domain->UnmodifiedFixed.ServerState;

            //
            // In DS case,
            //      UnmodifiedFixed will not correctly reflect the domain role.
            //      because Server Role is not stored in disk. it is being set during
            //      SAM initialization time by looking DS and FSMO
            //
            // In Registry case, both UnmoidiedFixed and Domain->ServerRole are correct,
            //      they are consistent.
            //

            (*Buffer)->General.DomainServerRole =
                Domain->ServerRole;

            (*Buffer)->General.UasCompatibilityRequired =
                Domain->UnmodifiedFixed.UasCompatibilityRequired;


            //
            // Copy the domain name from our in-memory structure.
            //

            NtStatus = STATUS_INSUFFICIENT_RESOURCES;   // Default status if the allocate fails

            AllocateBuffer((*Buffer)->General.DomainName.Buffer,
                            Domain->ExternalName.MaximumLength );

            if ((*Buffer)->General.DomainName.Buffer != NULL) {

                NtStatus = STATUS_SUCCESS;

                (*Buffer)->General.DomainName.Length = Domain->ExternalName.Length;
                (*Buffer)->General.DomainName.MaximumLength = Domain->ExternalName.MaximumLength;

                RtlCopyMemory((*Buffer)->General.DomainName.Buffer,
                              Domain->ExternalName.Buffer,
                              Domain->ExternalName.MaximumLength
                              );

                //
                // Now get copies of the strings we must retrieve from
                // the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               DomainContext,
                               SAMP_DOMAIN_OEM_INFORMATION,
                               TRUE,
                               (PUNICODE_STRING)&((*Buffer)->General.OemInformation)
                               );

                if (NT_SUCCESS(NtStatus)) {
                    RegisterBuffer((*Buffer)->General.OemInformation.Buffer);

                    NtStatus = SampGetUnicodeStringAttribute(
                                   DomainContext,
                                   SAMP_DOMAIN_REPLICA,
                                   TRUE,
                                   (PUNICODE_STRING)&((*Buffer)->General.ReplicaSourceNodeName) // Body
                                   );

                    if (NT_SUCCESS(NtStatus)) {
                        RegisterBuffer((*Buffer)->General.ReplicaSourceNodeName.Buffer);
                    }
                }
            }


            //
            // Get the count of users and groups
            //

            if (NT_SUCCESS(NtStatus)) {
                NtStatus = SampRetrieveAccountCounts(
                               &(*Buffer)->General.UserCount,
                               &(*Buffer)->General.GroupCount,
                               &(*Buffer)->General.AliasCount );
            }



            break;


        case DomainPasswordInformation:

            (*Buffer)->Password.MinPasswordLength       =
                Domain->UnmodifiedFixed.MinPasswordLength;
            (*Buffer)->Password.PasswordHistoryLength   =
                Domain->UnmodifiedFixed.PasswordHistoryLength;
            (*Buffer)->Password.PasswordProperties   =
                Domain->UnmodifiedFixed.PasswordProperties;
            (*Buffer)->Password.MaxPasswordAge          =
                Domain->UnmodifiedFixed.MaxPasswordAge;
            (*Buffer)->Password.MinPasswordAge          =
                Domain->UnmodifiedFixed.MinPasswordAge;

            break;


        case DomainLogoffInformation:

            (*Buffer)->Logoff.ForceLogoff =
                Domain->UnmodifiedFixed.ForceLogoff;

            break;

        case DomainOemInformation:

            RtlZeroMemory(&((*Buffer)->Oem.OemInformation), sizeof(UNICODE_STRING));

            NtStatus = SampGetUnicodeStringAttribute(
                           DomainContext,
                           SAMP_DOMAIN_OEM_INFORMATION,
                           TRUE,
                           (PUNICODE_STRING)&((*Buffer)->Oem.OemInformation)
                           );

            if (!NT_SUCCESS(NtStatus) &&
                (*Buffer)->Oem.OemInformation.Buffer ) {
                RegisterBuffer((*Buffer)->Oem.OemInformation.Buffer);
            }

            break;

        case DomainNameInformation:

            //
            // Copy the domain name from our in-memory structure.
            //

            NtStatus = STATUS_INSUFFICIENT_RESOURCES;   // Default status if the allocate fails

            AllocateBuffer((*Buffer)->Name.DomainName.Buffer,
                           Domain->ExternalName.MaximumLength);

            if ((*Buffer)->Name.DomainName.Buffer != NULL) {

                NtStatus = STATUS_SUCCESS;

                (*Buffer)->Name.DomainName.Length = Domain->ExternalName.Length;
                (*Buffer)->Name.DomainName.MaximumLength = Domain->ExternalName.MaximumLength;

                RtlCopyMemory((*Buffer)->Name.DomainName.Buffer,
                              Domain->ExternalName.Buffer,
                              Domain->ExternalName.MaximumLength
                              );
            }

            break;

        case DomainServerRoleInformation:

            (*Buffer)->Role.DomainServerRole =
                Domain->ServerRole;

            break;

        case DomainReplicationInformation:

            NtStatus = SampGetUnicodeStringAttribute(
                           DomainContext,
                           SAMP_DOMAIN_REPLICA,
                           TRUE,
                           (PUNICODE_STRING)&((*Buffer)->Replication.ReplicaSourceNodeName) // Body
                           );

            if (NT_SUCCESS(NtStatus)) {
                RegisterBuffer((*Buffer)->Replication.ReplicaSourceNodeName.Buffer);
            }

            break;

        case DomainModifiedInformation2:

            (*Buffer)->Modified2.ModifiedCountAtLastPromotion =
                Domain->UnmodifiedFixed.ModifiedCountAtLastPromotion;

            //
            //  This case falls through to DomainModifiedInformation
            //


        case DomainModifiedInformation:

            /////////////////////////////////
            //                             //
            //          WARNING            //
            //                             //
            //  The previous case falls    //
            //  into this one.             //
            //                             //
            /////////////////////////////////

            (*Buffer)->Modified.DomainModifiedCount =
                Domain->NetLogonChangeLogSerialNumber;
            (*Buffer)->Modified.CreationTime =
                Domain->UnmodifiedFixed.CreationTime;

            break;

        case DomainStateInformation:

            (*Buffer)->State.DomainServerState =
                Domain->UnmodifiedFixed.ServerState;

            break;


        case DomainLockoutInformation:

            (*Buffer)->Lockout.LockoutDuration          =
                Domain->UnmodifiedFixed.LockoutDuration;
            (*Buffer)->Lockout.LockoutObservationWindow =
                Domain->UnmodifiedFixed.LockoutObservationWindow;
            (*Buffer)->Lockout.LockoutThreshold         =
                Domain->UnmodifiedFixed.LockoutThreshold;

            break;

        }






        //
        // De-reference the object
        //

        IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE );
    }

    //
    // Free the read lock
    //

    SampReleaseReadLock();



    //
    // If we didn't succeed, free any allocated memory
    //

    if (!NT_SUCCESS(NtStatus)) {
        for ( i=0; i<AllocatedBufferCount ; i++ ) {
            MIDL_user_free( AllocatedBuffer[i] );
        }
        *Buffer = NULL;
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidQueryInformationDomain
                   );


    return(NtStatus);
}

NTSTATUS
SamIDoFSMORoleChange(
 IN SAMPR_HANDLE DomainHandle
 )
/*++

  Routine Description:


   This routine requests the FSMO role change from the PDC

  Return Values

    STATUS_SUCCESS
    Other Error Codes

--*/
{
    OPARG OpArg;
    OPRES *OpRes;
    ULONG RetCode;
    PSID  DomainSid;
    PSAMP_OBJECT DomainContext = (PSAMP_OBJECT)DomainHandle;
    NTSTATUS NtStatus = STATUS_SUCCESS;


    //
    // Return a STATUS_SUCCESS right upfront if we are
    // in registry mode. The LSA might call this function in
    // registry mode
    //

    if (!SampUseDsData)
    {
        return (STATUS_SUCCESS);
    }


    //
    // We must be in DS Mode, not hold sam lock,
    // not having an open transaction.
    //

    ASSERT(IsDsObject(DomainContext));
    ASSERT(!SampCurrentThreadOwnsLock());
    ASSERT(!SampExistsDsTransaction());

    //
    // If it is the builtin domain, then smile and
    // return success
    //

    if (SampDefinedDomains[DomainContext->DomainIndex].IsBuiltinDomain)
    {
        return STATUS_SUCCESS;
    }

    //
    // Create a Thread state in the DS
    //

    RetCode = THCreate( CALLERTYPE_SAM );
    if (0!=RetCode)
    {
       NtStatus = STATUS_INSUFFICIENT_RESOURCES;
       goto Error;
    }

    //
    // Grab the FSMO for promotion
    //

    RtlZeroMemory(&OpArg, sizeof(OPARG));
    OpArg.eOp = OP_CTRL_BECOME_PDC;
    DomainSid =  SampDefinedDomains[DomainContext->DomainIndex].Sid;
    OpArg.pBuf = DomainSid;
    OpArg.cbBuf = RtlLengthSid(DomainSid);

    //
    // When the NT4 tool server manager is used there is a case where 
    // DirOperationControl is failed. This happens if a fresh binding
    // handle needs to be generated. Generating a fresh binding handle
    // requires a fresh authentication to be performed. Server manager 
    // stops the netlogon service on both DC's -- because NT4 DC's could
    // not handle the role change without bouncing the netlogon service.
    // In windows 2000 and above  this stops advertising of the DC's. 
    // Since windows 2000 uses kerberos to authenticate if there are no 
    // other DC's available then the authentication may fail. 
    //
    // This is not a major issue for customers, customers use windows 2000
    // administrative tools to administer windows 2000. Use of NT4 server
    // manager agains windows 2000 and higher DC's is not recommended.
    //

    RetCode = DirOperationControl(&OpArg, &OpRes);

    if (NULL==OpRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetCode,&OpRes->CommRes);
    }


Error:

    //
    // Clean up any open thread states etc.
    //

    ASSERT(!SampExistsDsTransaction());
    THDestroy();

    return NtStatus;

}

NTSTATUS
SamINotifyRoleChange(
    IN PSID   DomainSid,
    IN DOMAIN_SERVER_ROLE NewRole
    )
/*++

    This function is used to set the new role information
    on the server. The role of the server, indicates wether
    the server is a PDC or BDC.

    Parameters

        DomainSid -- The SID of the domain, whose role we want to change
        NewRole   -- The new server role

    Return Values

        STATUS_SUCCESS
        Other Error Codes

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus = STATUS_SUCCESS;
    LSAPR_HANDLE       PolicyHandle=INVALID_HANDLE_VALUE;
    LSAPR_POLICY_INFORMATION PolicyInformation;
    ULONG   DomainIndex;
    LARGE_INTEGER LsaCreationTime;
    LARGE_INTEGER LsaModifiedCount;
    WCHAR   ComputerName[MAX_COMPUTERNAME_LENGTH+2];
    ULONG   ComputerNameLength=0;
    BOOLEAN   CheckAndAddWellKnownAccounts = FALSE;

    //
    // Check the new role parameter
    //

    switch (NewRole)
    {
    case DomainServerRolePrimary:
        PolicyInformation.PolicyServerRoleInfo.LsaServerRole=
            PolicyServerRolePrimary;
        break;

    case DomainServerRoleBackup:
         PolicyInformation.PolicyServerRoleInfo.LsaServerRole=
            PolicyServerRoleBackup;
        break;

    default:
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Error;
    }
    //
    // Lookup the domain SID
    //
    for (DomainIndex=SampDsGetPrimaryDomainStart();
                DomainIndex<SampDefinedDomainsCount;
                    DomainIndex++)
    {
        if (RtlEqualSid(SampDefinedDomains[DomainIndex].Sid,DomainSid))
        {
            break;
        }

    }

    //
    // If specified domain is not in the in-mmeory defined domains
    // return a distinguished error code
    //

    if (DomainIndex>=SampDefinedDomainsCount)
    {
        NtStatus = STATUS_NO_SUCH_DOMAIN;
        goto Error;
    }

    if (SampDefinedDomains[DomainIndex].IsBuiltinDomain)
    {
        //
        // It is useless to specify a builtin domain SID
        // in here
        //

        NtStatus = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    //
    // Set the Role in SAM, First acquire the lock
    //

    SampAcquireWriteLock();

    //
    // Print informative debugger messages about role changes
    //

    if ((SampDefinedDomains[DomainIndex].ServerRole==DomainServerRoleBackup)
        && (NewRole==DomainServerRolePrimary))
    {

         CheckAndAddWellKnownAccounts = TRUE;

         SampDiagPrint( DISPLAY_ROLE_CHANGES,
                               ("SAM: Role Change: Promoting to primary\n")
                            );

    }
    else if ((SampDefinedDomains[DomainIndex].ServerRole==DomainServerRolePrimary)
        && (NewRole==DomainServerRoleBackup))
    {

            SampDiagPrint( DISPLAY_ROLE_CHANGES,
                           ("SAM: Role Change: Demoting to backup\n")
                          );
    }

    //
    // Set the Role on to the account domain
    //

    SampDefinedDomains[DomainIndex].ServerRole = NewRole;
    SampDefinedDomains[DomainIndex].CurrentFixed.ServerRole = NewRole;
    SampDefinedDomains[DomainIndex].UnmodifiedFixed.ServerRole = NewRole;

    //
    // Set the Role onto the corresponding builtin domain
    //

    SampDefinedDomains[DomainIndex-1].ServerRole = NewRole;
    SampDefinedDomains[DomainIndex-1].CurrentFixed.ServerRole = NewRole;
    SampDefinedDomains[DomainIndex-1].UnmodifiedFixed.ServerRole = NewRole;



    SampReleaseWriteLock(FALSE);


    //
    // We are promoted to PDC from BDC, kick off the account upgrade
    // 

    if ( CheckAndAddWellKnownAccounts )
    {
        ASSERT( SampUseDsData );
        LsaIRegisterNotification(
                    SampCheckAndAddWellKnownAccounts,
                    (PVOID) NULL,   // no parameter
                    NOTIFIER_TYPE_IMMEDIATE,
                    0,              // no class
                    NOTIFIER_FLAG_ONE_SHOT,
                    0,              // do it now
                    NULL            // no handle
                    );
    }

    //
    // Force a Full sync of the LSA database
    //

    NtStatus = LsaIOpenPolicyTrusted(&PolicyHandle);
    if (!NT_SUCCESS(NtStatus))
        goto Error;


    //
    // Set the role in the LSA
    //

    NtStatus = NtQuerySystemTime(&LsaCreationTime);
    if (!NT_SUCCESS(NtStatus))
        goto Error;

    LsaModifiedCount.QuadPart = 1;

    NtStatus = LsaISetSerialNumberPolicy(
                    PolicyHandle,
                    &LsaModifiedCount,
                    &LsaCreationTime,
                    TRUE
                    );

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    //
    // Tell Netlogon regarding our server role
    //

    IgnoreStatus = I_NetNotifyRole(
                        PolicyInformation.PolicyServerRoleInfo.LsaServerRole
                        );

    //
    // Finally event log that we are now the PDC
    //
    // Only log this event if we are now the new PDC.
    // Otherwise, we don't say anything so that we do not leave
    // erroneous logs.
    // 

    if ( NewRole == DomainServerRolePrimary )
    {
        ComputerNameLength = sizeof(ComputerName)/sizeof(WCHAR);
        RtlZeroMemory(ComputerName,ComputerNameLength*sizeof(WCHAR));
        if (GetComputerName(ComputerName, &ComputerNameLength))
        {
            PUNICODE_STRING StringsToLog[1];
            UNICODE_STRING ComputerNameU;

            ComputerNameU.Buffer = ComputerName;
            ComputerNameU.Length = ComputerNameU.MaximumLength
                                = (USHORT) ComputerNameLength * sizeof(WCHAR);

            StringsToLog[0]=&ComputerNameU;

            SampWriteEventLog(
                    EVENTLOG_INFORMATION_TYPE,
                    0,
                    SAMMSG_PROMOTED_TO_PDC,
                    NULL,
                    1,
                    0,
                    StringsToLog,
                    NULL
                    );
        }
    }

    LsaINotifyChangeNotification( PolicyNotifyServerRoleInformation );

Error:

    if (INVALID_HANDLE_VALUE!=PolicyHandle)
    {
        LsarClose(&PolicyHandle);
    }

    return NtStatus;
}


NTSTATUS
SamIQueryServerRole(
    IN SAMPR_HANDLE DomainHandle,
    OUT DOMAIN_SERVER_ROLE *ServerRole
    )
/*++

  Routine Description

    This routine queries the server role from the in memory
    variable and returns it to the caller.

  Parameters

    DomainHandle -- Describes the Domain
    ServerRole   -- Out parameter specifies the server role

  Return Values

    STATUS_SUCCESS
--*/
{
    PSAMP_OBJECT DomainContext = (PSAMP_OBJECT)DomainHandle;
    ULONG        DomainIndex;

    //
    // The SAM service must be enabled
    //

    if (SampServiceState == SampServiceTerminating)
    {

        return(STATUS_INVALID_SERVER_STATE);
    }

    //
    // Reference the Context.
    //

    SampReferenceContext(DomainContext);

    DomainIndex = DomainContext->DomainIndex;

    if (IsBuiltinDomain(DomainIndex))
    {
        //
        // Make it point to the corresponding account domain
        //

        DomainIndex++;
    }

    //
    // return the server role
    //

    *ServerRole = SampDefinedDomains[DomainIndex].ServerRole;

    //
    // Dereference the context.
    //

    SampDeReferenceContext2(DomainContext,FALSE);

    return (STATUS_SUCCESS);
}

NTSTATUS
SamIQueryServerRole2(
    IN PSID DomainSid,
    OUT DOMAIN_SERVER_ROLE *ServerRole
    )
/*++

  Routine Description

    This routine queries the server role from the in memory
    variable and returns it to the caller. This is the domain
    SID version of the above call

  Parameters

    DomainSid -- Describes the Domain
    ServerRole   -- Out parameter specifies the server role

  Return Values

    STATUS_SUCCESS
--*/
{
    ULONG   DomainIndex=0;
    BOOLEAN DomainFound = FALSE;

    //
    // The SAM service must be enabled
    //

    if (SampServiceState != SampServiceEnabled)
    {

        return(STATUS_INVALID_SERVER_STATE);
    }


    for (DomainIndex=SampDsGetPrimaryDomainStart();DomainIndex<SampDefinedDomainsCount;DomainIndex++)
    {
        if (RtlEqualSid(SampDefinedDomains[DomainIndex].Sid, DomainSid))
        {
            DomainFound = TRUE;
            break;
        }
    }

    if (!DomainFound)
    {
        return(STATUS_NO_SUCH_DOMAIN);
    }

    if (IsBuiltinDomain(DomainIndex))
    {
        //
        // Make it point to the corresponding account domain
        //

        DomainIndex++;
    }

    //
    // return the server role
    //

    *ServerRole = SampDefinedDomains[DomainIndex].ServerRole;


    return (STATUS_SUCCESS);
}


NTSTATUS SamrSetInformationDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN DOMAIN_INFORMATION_CLASS DomainInformationClass,
    IN PSAMPR_DOMAIN_INFO_BUFFER DomainInformation
    )

/*++

Routine Description:

    This API sets the domain information to the values passed in the
    buffer.


Arguments:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    DomainInformationClass - Class of information desired.  The
        accesses required for each class is shown below:

        Info Level                      Required Access Type
        -------------------------       ----------------------------

        DomainPasswordInformation       DOMAIN_WRITE_PASSWORD_PARAMS

        DomainGeneralInformation        (not setable)

        DomainLogoffInformation         DOMAIN_WRITE_OTHER_PARAMETERS

        DomainOemInformation            DOMAIN_WRITE_OTHER_PARAMETERS

        DomainNameInformation           (Not valid for set operations.)

        DomainServerRoleInformation     DOMAIN_ADMINISTER_SERVER

        DomainReplicationInformation    DOMAIN_ADMINISTER_SERVER

        DomainModifiedInformation       (not valid for set operations)

        DomainStateInformation          DOMAIN_ADMINISTER_SERVER

        DomainUasInformation            DOMAIN_WRITE_OTHER_PARAMETERS

        DomainGeneralInformation2       (not setable)

        DomainLockoutInformation        DOMAIN_WRITE_PASSWORD_PARAMS


    DomainInformation - Buffer where the domain information can be
        found.


Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be disabled before role
        changes can be made.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.



--*/
{
    NTSTATUS                NtStatus, IgnoreStatus;
    PSAMP_OBJECT            DomainContext;
    SAMP_OBJECT_TYPE        FoundType;
    ACCESS_MASK             DesiredAccess;
    PSAMP_DEFINED_DOMAINS   Domain;
    BOOLEAN                 ReplicateImmediately = FALSE;
    ULONG                   DomainIndex;
    LARGE_INTEGER           PromotionIncrement = DOMAIN_PROMOTION_INCREMENT;


#if DBG

    LARGE_INTEGER
        TmpTime;

    TIME_FIELDS
        DT1, DT2, DT3, DT4;

#endif //DBG
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrSetInformationDomain");

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidSetInformationDomain
                   );

    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (DomainInformation != NULL);



    //
    // Set the desired access based upon the Info class
    //

    switch (DomainInformationClass) {

    case DomainPasswordInformation:
    case DomainLockoutInformation:

        ReplicateImmediately = TRUE;
        DesiredAccess = DOMAIN_WRITE_PASSWORD_PARAMS;
        break;


    case DomainLogoffInformation:
    case DomainOemInformation:
    case DomainUasInformation:

        DesiredAccess = DOMAIN_WRITE_OTHER_PARAMETERS;
        break;


    case DomainReplicationInformation:
    case DomainStateInformation:
    case DomainServerRoleInformation:

        DesiredAccess = DOMAIN_ADMINISTER_SERVER;
        break;


    case DomainModifiedInformation:
    case DomainNameInformation:
    case DomainGeneralInformation:
    case DomainGeneralInformation2:
    default:
        NtStatus = STATUS_INVALID_INFO_CLASS;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;

    } // end_switch


    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }


    //
    // Validate type of, and access to object.
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;
    NtStatus = SampLookupContext(
                   DomainContext,
                   DesiredAccess,
                   SampDomainObjectType,           // ExpectedType
                   &FoundType
                   );


    if ( ( NtStatus == STATUS_INVALID_DOMAIN_ROLE ) &&
        ( DomainInformationClass == DomainServerRoleInformation ) ) {


        //
        // Non-trusted client isn't being allowed to write to backup
        // server.  But admin MUST be able to set the server role back
        // to primary.  So temporarily pretend that administering the
        // server isn't a write operation, just long enough for the
        // LookupContext to succeed.
        //
        // Note that before returning INVALID_DOMAIN_ROLE, LookupContext
        // verified that the caller otherwise has proper access - if the
        // caller didn't, then we would have gotten a different error.
        //

        SampObjectInformation[ SampDomainObjectType ].WriteOperations &=
            ~DOMAIN_ADMINISTER_SERVER;

        SampSetTransactionWithinDomain(FALSE);

        NtStatus = SampLookupContext(
                       DomainContext,
                       DesiredAccess,
                       SampDomainObjectType,           // ExpectedType
                       &FoundType
                       );

        SampObjectInformation[ SampDomainObjectType ].WriteOperations |=
            DOMAIN_ADMINISTER_SERVER;
    }


    if (NT_SUCCESS(NtStatus)) {


        ClientRevision = DomainContext->ClientRevision;

        DomainIndex = DomainContext->DomainIndex;
        Domain = &SampDefinedDomains[ DomainIndex ];

        //
        // case on the type information provided
        //

        switch (DomainInformationClass) {

        case DomainPasswordInformation:

            if (
                ( DomainInformation->Password.PasswordHistoryLength >
                SAMP_MAXIMUM_PASSWORD_HISTORY_LENGTH ) ||

                ( DomainInformation->Password.MinPasswordAge.QuadPart > 0) ||

                ( DomainInformation->Password.MaxPasswordAge.QuadPart > 0) ||

                ( DomainInformation->Password.MaxPasswordAge.QuadPart >=
                    DomainInformation->Password.MinPasswordAge.QuadPart) ||

                ( DomainInformation->Password.MinPasswordLength > PWLEN ) ||

                ( ( Domain->UnmodifiedFixed.UasCompatibilityRequired ) &&
                ( DomainInformation->Password.MinPasswordLength > LM20_PWLEN ) )
                ) {

                //
                // One of the following is wrong:
                //
                // 1.  The history length is larger than we can allow (and
                //     still ensure everything will fit in a string)
                // 2.  The MinPasswordAge isn't a delta time
                // 3.  The MaxPasswordAge isn't a delta time
                // 4.  The MaxPasswordAge isn't greater than the
                //     MinPasswordAge (they're negative delta times)
                // 5.  UAS compatibility is required, but MinPasswordLength
                //     is greater than LM's max password length.
                //

                NtStatus = STATUS_INVALID_PARAMETER;

            } else {

                Domain->CurrentFixed.MinPasswordLength      =
                    DomainInformation->Password.MinPasswordLength;

                Domain->CurrentFixed.PasswordHistoryLength  =
                    DomainInformation->Password.PasswordHistoryLength;

                Domain->CurrentFixed.PasswordProperties     =
                    DomainInformation->Password.PasswordProperties;

                Domain->CurrentFixed.MaxPasswordAge         =
                    DomainInformation->Password.MaxPasswordAge;

                Domain->CurrentFixed.MinPasswordAge         =
                    DomainInformation->Password.MinPasswordAge;
            }

            break;


        case DomainLogoffInformation:

            Domain->CurrentFixed.ForceLogoff    =
                DomainInformation->Logoff.ForceLogoff;

            break;

        case DomainOemInformation:

            NtStatus = SampSetUnicodeStringAttribute(
                           DomainContext,
                           SAMP_DOMAIN_OEM_INFORMATION,
                           (PUNICODE_STRING)&(DomainInformation->Oem.OemInformation)
                           );
            break;

        case DomainServerRoleInformation:

            //
            // Perform the role change operation
            //

             //
            // Only NTAS systems can be demoted.
            //

            if (SampProductType != NtProductLanManNt) {

                if ( (DomainInformation->Role.DomainServerRole ==
                     DomainServerRoleBackup)      //Trying to demote
                   ) {

                        NtStatus = STATUS_INVALID_DOMAIN_ROLE;
                        break;

                   }
            }

            //
            // Are we being promoted to primary?
            //

            if ( (Domain->UnmodifiedFixed.ServerRole == DomainServerRoleBackup)
                 && (DomainInformation->Role.DomainServerRole == DomainServerRolePrimary)
               )
            {

                //
                // We are a domain controller, therefore assert that we must be in DS mode
                // Member server's or workstations can never have their server role set to
                // backup, therefore the question of promoting them to domain controller never
                // arises
                //

                ASSERT(IsDsObject(Domain->Context));

                //
                // Close any Open Transactions, and release locks
                //

                IgnoreStatus = SampReleaseWriteLock(FALSE);

                ASSERT(NT_SUCCESS(IgnoreStatus));

                //
                // Do the FSMO operation to grab role ownership
                // if we are a domain controller. Note the behaviour
                // in a NT5 Domain Controller is different than that
                // of NT4, that is the promotion process will not succeed
                // if the old PDC cannot be reached.
                //


                NtStatus = SamIDoFSMORoleChange(DomainHandle);



                //
                // Grab the SAM lock again, only for de reference
                // the domain context. Because SampDeReferenceContext()
                // requires the caller holds the lock.
                //

                SampAcquireSamLockExclusive();

                // Dereference the context and return the status
                // from the FSMO operation

                SampDeReferenceContext(DomainContext,FALSE);

                //
                // Release it immediately.
                //
                SampReleaseSamLockExclusive();


                goto Error;
            }
            else
            {
                //
                // We are being demoted. This means that some one else will be promoted.
                // Just smile and say yes, but don't change anything. When the other PDC, is
                // promoted, he will come around and change our role as part of the FSMO
                // operation
                //
            }

            break;

        case DomainReplicationInformation:

            NtStatus = SampSetUnicodeStringAttribute(
                           DomainContext,
                           SAMP_DOMAIN_REPLICA,
                           (PUNICODE_STRING)&(DomainInformation->Replication.ReplicaSourceNodeName) // Body
                           );
            break;

        case DomainStateInformation:

            //
            // Never let anyone set a disabled state
            //

            Domain->CurrentFixed.ServerState = DomainServerEnabled;

            break;

        case DomainUasInformation:

            Domain->CurrentFixed.UasCompatibilityRequired =
                DomainInformation->General.UasCompatibilityRequired;

            break;

        case DomainLockoutInformation:

            if (
                (DomainInformation->Lockout.LockoutDuration.QuadPart >
                    DomainInformation->Lockout.LockoutObservationWindow.QuadPart ) ||

                ( DomainInformation->Lockout.LockoutDuration.QuadPart > 0) ||

                ( DomainInformation->Lockout.LockoutObservationWindow.QuadPart > 0 )


               ) {

                //
                // One of the following is wrong:
                //
                // 0.  The LockoutDuration is less than the 
                //     LockoutObservationWindows.  
                // 1.  The LockoutDuration isn't a delta time (or zero).
                // 2.  The LockoutObservationWindow isn't a delta time (or zero).
                //

                NtStatus = STATUS_INVALID_PARAMETER;

            } else {

#if DBG
                TmpTime.QuadPart = -Domain->CurrentFixed.LockoutObservationWindow.QuadPart;
                RtlTimeToElapsedTimeFields( &TmpTime, &DT1 );
                TmpTime.QuadPart = -Domain->CurrentFixed.LockoutDuration.QuadPart;
                RtlTimeToElapsedTimeFields( &TmpTime, &DT2 );
                TmpTime.QuadPart = -DomainInformation->Lockout.LockoutObservationWindow.QuadPart;
                RtlTimeToElapsedTimeFields( &TmpTime, &DT3 );
                TmpTime.QuadPart = -DomainInformation->Lockout.LockoutDuration.QuadPart;
                RtlTimeToElapsedTimeFields( &TmpTime, &DT4 );

                SampDiagPrint( DISPLAY_LOCKOUT,
                               ("SAM: SetInformationDomain: Changing Lockout values.\n"
                                "          Old:\n"
                                "              Window   : [0x%lx, 0x%lx] %d:%d:%d\n"
                                "              Duration : [0x%lx, 0x%lx] %d:%d:%d\n"
                                "              Threshold: %ld\n"
                                "          New:\n"
                                "              Window   : [0x%lx, 0x%lx] %d:%d:%d\n"
                                "              Duration : [0x%lx, 0x%lx] %d:%d:%d\n"
                                "              Threshold: %ld\n",
                    Domain->CurrentFixed.LockoutObservationWindow.HighPart,
                    Domain->CurrentFixed.LockoutObservationWindow.LowPart,
                    DT1.Hour, DT1.Minute, DT1.Second,
                    Domain->CurrentFixed.LockoutDuration.HighPart,
                    Domain->CurrentFixed.LockoutDuration.LowPart,
                    DT2.Hour, DT2.Minute, DT2.Second,
                    Domain->CurrentFixed.LockoutThreshold,
                    DomainInformation->Lockout.LockoutObservationWindow.HighPart,
                    DomainInformation->Lockout.LockoutObservationWindow.LowPart,
                    DT3.Hour, DT3.Minute, DT3.Second,
                    DomainInformation->Lockout.LockoutDuration.HighPart,
                    DomainInformation->Lockout.LockoutDuration.LowPart,
                    DT4.Hour, DT4.Minute, DT4.Second,
                    DomainInformation->Lockout.LockoutThreshold)
                            );
#endif //DBG

                Domain->CurrentFixed.LockoutDuration      =
                    DomainInformation->Lockout.LockoutDuration;

                Domain->CurrentFixed.LockoutObservationWindow  =
                    DomainInformation->Lockout.LockoutObservationWindow;

                Domain->CurrentFixed.LockoutThreshold     =
                    DomainInformation->Lockout.LockoutThreshold;

            }

            break;
        }

        //
        // Generate an audit if necessary
        //

        if (NT_SUCCESS(NtStatus) &&
            SampDoAccountAuditing(DomainIndex)) {

            SampAuditDomainPolicyChange(
                STATUS_SUCCESS,
                Domain->Sid,
                &Domain->ExternalName,
                DomainInformationClass
                );
        }




        //
        // Have the changes written out to the RXACT, and
        // de-reference the object.
        //

        if ( NT_SUCCESS( NtStatus ) ) {

            NtStatus = SampDeReferenceContext( DomainContext, TRUE );

        } else {

            IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE );
        }
    }


    //
    // Commit changes, if successful, and notify Netlogon of changes.
    //

    if ( NT_SUCCESS(NtStatus) ) {

        NtStatus = SampCommitAndRetainWriteLock();

        if ( NT_SUCCESS( NtStatus ) ) {

            SampNotifyNetlogonOfDelta(
                SecurityDbChange,
                SecurityDbObjectSamDomain,
                0L,
                (PUNICODE_STRING) NULL,
                (DWORD) ReplicateImmediately,
                NULL            // Delta data
                );
        }
    }

    IgnoreStatus = SampReleaseWriteLock( FALSE );
    ASSERT(NT_SUCCESS(IgnoreStatus));

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidSetInformationDomain
                   );

    return(NtStatus);
}


NTSTATUS
SampCreateGroupInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PRPC_UNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN WriteLockHeld,
    IN BOOLEAN LoopbackClient,
    IN ULONG   GroupType,
    OUT SAMPR_HANDLE *GroupHandle,
    IN OUT PULONG RelativeId
    )

/*++

Routine Description:

    This API creates a new group in the account database.  Initially,
    this group does not contain any users.  Note that creating a group
    is a protected operation, and requires the DOMAIN_CREATE_GROUP
    access type.

    This call returns a handle to the newly created group that may be
    used for successive operations on the group.  This handle may be
    closed with the SamCloseHandle API.

    A newly created group will have the following initial field value
    settings.  If another value is desired, it must be explicitly
    changed using the group object manipulation services.


        Name - The name of the group will be as specified in the
               creation API.

        Attributes - The following attributes will be set:

                                Mandatory
                                EnabledByDefault

        MemberCount - Zero.  Initially the group has no members.

        RelativeId - will be a uniquelly allocated ID.



Arguments:


    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.


    AccountName - Points to the name of the new account.  A case-insensitive
        comparison must not find a group or user with this name already defined.


    DesiredAccess - Is an access mask indicating which access types
        are desired to the group.

    GroupHandle - Receives a handle referencing the newly created
        group.  This handle will be required in successive calls to
        operate on the group.

    RelativeId - Receives the relative ID of the newly created group
        account.  The SID of the new group account is this relative ID
        value prefixed with the domain's SID value.  This RID will be a
        new, uniquely allocated value - unless a non-zero RID was passed
        in, in which case that RID is used (nothing is done if a group
        with that RID already exists).


Return Value:

    STATUS_SUCCESS - The group was added successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_ACCOUNT_NAME - The name was poorly formed, e.g.
        contains non-printable characters.

    STATUS_GROUP_EXISTS - The name is already in use as a group.

    STATUS_USER_EXISTS - The name is already in use as a user.

    STATUS_ALIAS_EXISTS - The name is already in use as an alias.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled before groups
        can be created in it.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.  The domain server must be a primary server to
        create group accounts.




--*/

{
    NTSTATUS                NtStatus = STATUS_SUCCESS, IgnoreStatus;
    PSAMP_OBJECT            DomainContext = (PSAMP_OBJECT) DomainHandle,
                            GroupContext = NULL;
    SAMP_OBJECT_TYPE        FoundType;
    PSAMP_DEFINED_DOMAINS   Domain = NULL;

    ULONG                   NewAccountRid, NewSecurityDescriptorLength;
    UNICODE_STRING          KeyName;
    PSECURITY_DESCRIPTOR    NewSecurityDescriptor;
    SAMP_V1_0A_FIXED_LENGTH_GROUP  V1Fixed;
    PRIVILEGE_SET           PrivilegeSet;
    DSNAME                  *LoopbackName;
    BOOLEAN                 fLockAcquired = FALSE,
                            AccountNameDefaulted = FALSE,
                            RemoveAccountNameFromTable = FALSE;
                            
    SAMTRACE("SampCreateGroupInDomain");

    if (GroupHandle == NULL) {
        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        return(NtStatus);
    }

    //
    // Initialize the privilege set.
    //

    PrivilegeSet.PrivilegeCount = 0;
    PrivilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
    PrivilegeSet.Privilege[0].Luid = RtlConvertLongToLuid(0L);
    PrivilegeSet.Privilege[0].Attributes = 0;

    //
    // Make sure a name was provided. It is legal to request that the account name
    // be defaulted if this were from the DS
    //

    
    if (AccountName == NULL) {
        return(STATUS_INVALID_ACCOUNT_NAME);
    }
    if (AccountName->Length > AccountName->MaximumLength) {
        return(STATUS_INVALID_ACCOUNT_NAME);
    }
    if ((AccountName->Buffer == NULL ) || (AccountName->Length==0)) 
    {

        if (!LoopbackClient)
        {
            return(STATUS_INVALID_ACCOUNT_NAME);
        }
        else
        {
            //
            // For loopback cases passing in a NULL account name
            // requests defaulting of the account name
            //

            AccountNameDefaulted = TRUE;
        }
    }
    
    

    //
    // Do WMI start type event trace
    //

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidCreateGroupInDomain
                   );


    if ( !WriteLockHeld )  {

        NtStatus = SampMaybeAcquireWriteLock( DomainContext, &fLockAcquired );
        if (!NT_SUCCESS(NtStatus)) {
            goto SampCreateGroupInDomainError;
        }
    }


    //
    // Validate the passed in Domain Handle
    //

    GroupContext = NULL;

    //
    // Non trusted clients can not create pricipals in Builtin Domain
    //

    if (IsBuiltinDomain(DomainContext->DomainIndex) &&
        !DomainContext->TrustedClient )
    {
        NtStatus = STATUS_ACCESS_DENIED;
        goto SampCreateGroupInDomainError;
    }

    //
    // Do Any access Checks
    //

    NtStatus = SampDoGroupCreationChecks(DomainContext);

    if (NT_SUCCESS(NtStatus)) {

        Domain = &SampDefinedDomains[ DomainContext->DomainIndex ];

        //
        if (!AccountNameDefaulted)
        {
            //
            // Make sure the name is valid and not already in use before we
            // use it to create the new group.
            //

            NtStatus = SampValidateNewAccountName(
                             DomainContext,
                             (PUNICODE_STRING)AccountName,
                             SampGroupObjectType
                             );

            //
            // RemoveAccountNameFromTable tells us whether
            // the caller (this routine) is responsable 
            // to remove the name from the table. 
            // 

            RemoveAccountNameFromTable = 
                            DomainContext->RemoveAccountNameFromTable;

            //
            // reset 
            //  
            DomainContext->RemoveAccountNameFromTable = FALSE;
        }

        if ( NT_SUCCESS(NtStatus) ) {


            if ( (*RelativeId) == 0 ) {

                //
                // No RID specified, so allocate a new (group) account RID
                //

                if (IsDsObject(DomainContext))
                {
                    // This is a DS domain, so use the multi-master RID
                    // allocator to get the next RID.

                    NtStatus = SampGetNextRid(DomainContext,
                                              &NewAccountRid);
                    SampDiagPrint(INFORM,
                                  ("SAMSS: New Group RID = %lu\n",
                                   NewAccountRid));

                    if (!NT_SUCCESS(NtStatus))
                    {
                        KdPrintEx((DPFLTR_SAMSS_ID,
                                   DPFLTR_INFO_LEVEL,
                                   "SAMSS: SampGetNextRid status = 0x%lx\n",
                                   NtStatus));
                    }

                }
                else
                {
                    // This is not a DS domain, use the registry RID infor-
                    // mation.

                    NewAccountRid = Domain->CurrentFixed.NextRid;
                    Domain->CurrentFixed.NextRid += 1;
                }

                (*RelativeId) = NewAccountRid;

            } else {

                //
                // A RID was passed in, so we want to use that rather than
                // selecting a new one.
                //

                ASSERT(TRUE == Domain->Context->TrustedClient);
                NewAccountRid = (*RelativeId);
            }

            SampDiagPrint(RID_TRACE,("SAMSS RID_TRACE New Rid %d\n",NewAccountRid));

            //
            // Default the account name if necessary
            //

            if ((NT_SUCCESS(NtStatus)) && (AccountNameDefaulted))
            {
                NtStatus = SampGetAccountNameFromRid(AccountName,NewAccountRid);
            }

            //
            // Check For Duplicate Sids. Currently we leave this check on in both
            // the checked as well as the free builds. Sometime in the future we can
            // remove it in the free builds
            //

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = SampCheckForDuplicateSids(
                                DomainContext,
                                NewAccountRid
                                );
            }

            //
            // Increment the group count ONLY in Registry case
            //

            if (NT_SUCCESS(NtStatus) && (!IsDsObject(DomainContext)) )
            {
                NtStatus = SampAdjustAccountCount(SampGroupObjectType, TRUE);
            }

            if ( !IsDsObject(Domain->Context) ) {

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // Create the registry key that has the group's name.
                    // This simply serves as a name to RID mapping.  Save
                    // the name when done; we'll put it in the context.
                    //

                    NtStatus = SampBuildAccountKeyName(
                                   SampGroupObjectType,
                                   &KeyName,
                                   (PUNICODE_STRING)AccountName
                                   );



                    if (NT_SUCCESS(NtStatus)) {

                        NtStatus = RtlAddActionToRXact(
                                       SampRXactContext,
                                       RtlRXactOperationSetValue,
                                       &KeyName,
                                       NewAccountRid,
                                       NULL,
                                       0
                                       );

                        SampFreeUnicodeString(&KeyName);
                    }
                }
            }

            if (NT_SUCCESS(NtStatus)) {

                //
                // Now create a group context block
                //

                NtStatus = SampCreateAccountContext2(
                               DomainContext,
                               SampGroupObjectType,
                               NewAccountRid,
                               NULL,
                               (PUNICODE_STRING)AccountName,
                               DomainContext->ClientRevision,
                               DomainContext->TrustedClient,
                               DomainContext->LoopbackClient,
                               FALSE, // Privileged Machine account create
                               FALSE, // Account exists
                               FALSE, // Override local group check
                               &GroupType,
                               &GroupContext
                               );

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // The existing reference count of 1 is for RPC.
                    // Reference the context again for the writes we're
                    // about to do to initialize it.
                    //

                    SampReferenceContext( GroupContext );

                    //
                    // If MAXIMUM_ALLOWED is requested, add GENERIC_ALL
                    //

                    if (DesiredAccess & MAXIMUM_ALLOWED) {

                        DesiredAccess |= GENERIC_ALL;
                    }

                    //
                    // If ACCESS_SYSTEM_SECURITY is requested and we are
                    // a non-trusted client, check that we have
                    // SE_SECURITY_PRIVILEGE.
                    //

                    if ((DesiredAccess & ACCESS_SYSTEM_SECURITY) &&
                        (!DomainContext->TrustedClient) &&
                        (!DomainContext->LoopbackClient)) {

                        NtStatus = SampRtlWellKnownPrivilegeCheck(
                                       TRUE,
                                       SE_SECURITY_PRIVILEGE,
                                       NULL
                                       );

                        if (!NT_SUCCESS(NtStatus)) {

                            if (NtStatus == STATUS_PRIVILEGE_NOT_HELD) {

                                NtStatus = STATUS_ACCESS_DENIED;
                            }

                        } else {

                            PrivilegeSet.PrivilegeCount = 1;
                            PrivilegeSet.Control = PRIVILEGE_SET_ALL_NECESSARY;
                            PrivilegeSet.Privilege[0].Luid = RtlConvertLongToLuid(SE_SECURITY_PRIVILEGE);
                            PrivilegeSet.Privilege[0].Attributes = 0;
                        }
                    }

                    //
                    // Make sure the caller can be given the requested access
                    // to the new object
                    //

                    if (NT_SUCCESS(NtStatus)) {

                        GroupContext->GrantedAccess = DesiredAccess;

                        RtlMapGenericMask(
                            &GroupContext->GrantedAccess,
                            &SampObjectInformation[SampGroupObjectType].GenericMapping
                            );


                        if ((SampObjectInformation[SampGroupObjectType].InvalidMappedAccess
                            & GroupContext->GrantedAccess) != 0) {

                            NtStatus = STATUS_ACCESS_DENIED;
                        }
                    }

                }
            }



            //
            // Set the V1_fixed attribute
            //

            if (NT_SUCCESS(NtStatus)) {

                //
                // Create the V1_Fixed key
                //

                V1Fixed.RelativeId = NewAccountRid;
                V1Fixed.Attributes = (SE_GROUP_MANDATORY |
                                      SE_GROUP_ENABLED_BY_DEFAULT);
                V1Fixed.AdminCount = 0;
                V1Fixed.OperatorCount = 0;
                V1Fixed.Revision = SAMP_REVISION;

                NtStatus = SampSetFixedAttributes(
                               GroupContext,
                               (PVOID)&V1Fixed
                               );
            }


            //
            // Set the SecurityDescriptor attribute, only in the registry case
            // In the DS case the act of creating the object itself sets the
            // security descriptor on the object. The reason for this is that'
            // the security descriptor has to go through the merge process in the
            // DS and the Ace's from the parent are not inherited during a modify
            // entry
            //

            if (NT_SUCCESS(NtStatus)) {

                if (!IsDsObject(GroupContext))
                {

                      NtStatus = SampGetNewAccountSecurity(
                               SampGroupObjectType,
                               FALSE, // Not member of ADMINISTRATORS alias
                               DomainContext->TrustedClient,
                               FALSE,           //RestrictCreatorAccess
                               NewAccountRid,
                               GroupContext,
                               &NewSecurityDescriptor,
                               &NewSecurityDescriptorLength
                               );

                    if (NT_SUCCESS(NtStatus)) {

                        NtStatus = SampSetAccessAttribute(
                                        GroupContext,
                                        SAMP_GROUP_SECURITY_DESCRIPTOR,
                                        NewSecurityDescriptor,
                                        NewSecurityDescriptorLength
                                        );

                        MIDL_user_free( NewSecurityDescriptor );
                    }
                }
            }


            //
            // Set the NAME attribute
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampSetUnicodeStringAttribute(
                               GroupContext,
                               SAMP_GROUP_NAME,
                               (PUNICODE_STRING)AccountName
                               );
            }



            //
            // Set the AdminComment attribute
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampSetUnicodeStringAttribute(
                               GroupContext,
                               SAMP_GROUP_ADMIN_COMMENT,
                               &SampNullString
                               );
            }


            //
            // Set the MEMBERS attribute (with no members)
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampSetUlongArrayAttribute(
                               GroupContext,
                               SAMP_GROUP_MEMBERS,
                               NULL,
                               0,
                               0
                               );
            }
        }

        IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // If we created an object, dereference it.  Write out its attributes
    // if everything was created OK.
    //

    if (NT_SUCCESS(NtStatus)) {

        //
        // De-reference the object, write out any change to current xaction.
        //

        ASSERT(GroupContext != NULL);
        NtStatus = SampDeReferenceContext( GroupContext, TRUE );

    } else {

        if (GroupContext != NULL) {

            //
            // De-reference the object, ignore changes
            //

            IgnoreStatus = SampDeReferenceContext( GroupContext, FALSE );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }
    }


    //
    // Commit changes and notify netlogon
    //

    if ( NT_SUCCESS(NtStatus) ) {

        NtStatus = SampCommitAndRetainWriteLock();

        if (NT_SUCCESS(NtStatus)) {

            if(!IsDsObject(DomainContext))
            {
                SAMP_ACCOUNT_DISPLAY_INFO AccountInfo;

                //
                // Update the display information
                //

                AccountInfo.Name = *((PUNICODE_STRING)AccountName);
                AccountInfo.Rid = NewAccountRid;
                AccountInfo.AccountControl = V1Fixed.Attributes;
                RtlInitUnicodeString(&AccountInfo.Comment, NULL);
                RtlInitUnicodeString(&AccountInfo.FullName, NULL);

                IgnoreStatus = SampUpdateDisplayInformation(
                                                NULL,
                                                &AccountInfo,
                                                SampGroupObjectType
                                                );
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }

            if (GroupContext->TypeBody.Group.SecurityEnabled)
            {
                SampNotifyNetlogonOfDelta(
                    SecurityDbNew,
                    SecurityDbObjectSamGroup,
                    *RelativeId,
                    (PUNICODE_STRING) NULL,
                    (DWORD) FALSE,  // Replicate immediately
                    NULL            // Delta data
                    );
            }

            //
            // Generate Audit
            //

            if (SampDoAccountAuditing(DomainContext->DomainIndex)) {

                ULONG   AuditId;

                if (GroupContext->TypeBody.Group.SecurityEnabled)
                {
                    if (NT5AccountGroup ==
                        GroupContext->TypeBody.Group.NT5GroupType)
                    {
                        AuditId = SE_AUDITID_GLOBAL_GROUP_CREATED;
                    }
                    else
                    {
                        ASSERT(NT5UniversalGroup ==
                               GroupContext->TypeBody.Group.NT5GroupType);

                        AuditId = SE_AUDITID_SECURITY_ENABLED_UNIVERSAL_GROUP_CREATED;
                    }
                }
                else
                {
                    if (NT5AccountGroup ==
                        GroupContext->TypeBody.Group.NT5GroupType)
                    {
                        AuditId = SE_AUDITID_SECURITY_DISABLED_GLOBAL_GROUP_CREATED;
                    }
                    else
                    {
                        ASSERT(NT5UniversalGroup ==
                               GroupContext->TypeBody.Group.NT5GroupType);

                        AuditId = SE_AUDITID_SECURITY_DISABLED_UNIVERSAL_GROUP_CREATED;
                    }
                }

                SampAuditAnyEvent(
                    GroupContext,
                    STATUS_SUCCESS,
                    AuditId,       // AuditId
                    Domain->Sid,                           // Domain SID
                    NULL,                                  // Additional Info
                    NULL,                                  // Member Rid (not used)
                    NULL,                                  // Member Sid (not used)
                    (PUNICODE_STRING) AccountName,         // Account Name
                    &Domain->ExternalName,                 // Domain
                    &GroupContext->TypeBody.Group.Rid,      // Account Rid
                    &PrivilegeSet                          // Privileges used
                    );
            }
        }
    }

    //
    // Return the context handle on success
    // Delete the context block and return a NULL handle on failure
    //

    if (NT_SUCCESS(NtStatus)) {

        ASSERT(GroupContext != NULL);
        (*GroupHandle) = GroupContext;

    } else {

        if (GroupContext != NULL) {
            SampDeleteContext(GroupContext);
        }

        (*GroupHandle) = (SAMPR_HANDLE)0;
    }

SampCreateGroupInDomainError:

    //
    // cleanup the account name table
    // 

    if (RemoveAccountNameFromTable)
    {
        IgnoreStatus = SampDeleteElementFromAccountNameTable(
                            (PUNICODE_STRING)AccountName,
                            SampGroupObjectType
                            );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    if ((AccountNameDefaulted) && (NULL!=AccountName->Buffer))
    {
        MIDL_user_free(AccountName->Buffer);
    }

    //
    // Release the lock
    //

    if ( (!WriteLockHeld) ) {
        IgnoreStatus = SampMaybeReleaseWriteLock( fLockAcquired, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }


    //
    // Do a WMI end type event trace
    //

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidCreateGroupInDomain
                   );

    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return(NtStatus);
}


NTSTATUS
SamrCreateGroupInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PRPC_UNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    OUT SAMPR_HANDLE *GroupHandle,
    OUT PULONG RelativeId
    )

/*++

Routine Description:

    This is just a wrapper for SampCreateGroupInDomain() that ensures that
    RelativeId points to a RID of zero first.

    A non-zero RID means that SampCreateGroupInDomain() was called by
    SamICreateAccountByRid(), which specifies a RID to be used.

Parameters:

    Same as SampCreateGroupInDomain().

Return Values:

    Same as SampCreateGroupInDomain().

--*/

{
    NTSTATUS NtStatus;
    ULONG    GroupType =  GROUP_TYPE_SECURITY_ENABLED|GROUP_TYPE_ACCOUNT_GROUP;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrCreateGroupInDomain");

    //
    // Perform a parameter validation
    //  1. Domain Handle is Validated by LookupContext in SampCreateGroupInDomain
    //  2. Desired Access requires no validation
    //

    if ((NULL==AccountName) || (NULL==AccountName->Buffer))
    {
            NtStatus = STATUS_INVALID_ACCOUNT_NAME;
            goto Error;
    }

    if (NULL==GroupHandle)
    {
            NtStatus = STATUS_INVALID_PARAMETER;
            goto Error;
    }

    if (NULL==RelativeId)
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    (*RelativeId) = 0;

    NtStatus = SampCreateGroupInDomain(
                   DomainHandle,
                   AccountName,
                   DesiredAccess,
                   FALSE,
                   FALSE,   // not loopback client
                   GroupType,
                   GroupHandle,
                   RelativeId
                   );

Error:

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return( NtStatus );
}



NTSTATUS SamrEnumerateGroupsInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )

/*++

Routine Description:

    This API lists all the groups defined in the account database.
    Since there may be more groups than can fit into a buffer, the
    caller is provided with a handle that can be used across calls to
    the API.  On the initial call, EnumerationContext should point to a
    SAM_ENUMERATE_HANDLE variable that is set to 0.

    If the API returns STATUS_MORE_ENTRIES, then the API should be
    called again with EnumerationContext.  When the API returns
    STATUS_SUCCESS or any error return, the context becomes invalid for
    future use.

    This API requires DOMAIN_LIST_GROUPS access to the Domain object.

Arguments:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    EnumerationContext - API specific handle to allow multiple calls
        (see below).  This is a zero based index.

    Buffer - Receives a pointer to the buffer containing the
        requested information.  The information returned is
        structured as an array of SAM_RID_ENUMERATION data
        structures.  When this information is no longer needed, the
        buffer must be freed using SamFreeMemory().

    PreferedMaximumLength - Prefered maximum length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves
        as a guide to the server.  Due to data conversion between
        systems with different natural data sizes, the actual amount
        of data returned may be greater than this value.

    CountReturned - Number of entries returned.


Return Value:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no addition entries.

    STATUS_MORE_ENTRIES - There are more entries, so call again.
        This is a successful return.

    STATUS_ACCESS_DENIED - Caller does not have privilege required to
        request that data.

    STATUS_INVALID_HANDLE - The handle passed is invalid.


--*/
{

    NTSTATUS                    NtStatus;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrEnumerateGroupsInDomain");

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidEnumerateGroupsInDomain
                   );

    NtStatus = SampEnumerateAccountNamesCommon(
                  DomainHandle,
                  SampGroupObjectType,
                  EnumerationContext,
                  Buffer,
                  PreferedMaximumLength,
                  0L,  // no filter
                  CountReturned
                  );

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidEnumerateGroupsInDomain
                   );

    return(NtStatus);

}



NTSTATUS
SampCreateAliasInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PRPC_UNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN WriteLockHeld,
    IN BOOLEAN LoopbackClient,
    IN ULONG   GroupType,
    OUT SAMPR_HANDLE *AliasHandle,
    IN OUT PULONG RelativeId
    )

/*++

Routine Description:

    This API creates a new alias in the account database.  Initially,
    this alias does not contain any users.  Note that creating a alias
    is a protected operation, and requires the DOMAIN_CREATE_ALIAS
    access type.

    This call returns a handle to the newly created alias that may be
    used for successive operations on the alias.  This handle may be
    closed with the SamCloseHandle API.

    A newly created alias will have the following initial field value
    settings.  If another value is desired, it must be explicitly
    changed using the alias object manipulation services.


        Name - The name of the alias will be as specified in the
               creation API.

        MemberCount - Zero.  Initially the alias has no members.

        RelativeId - will be a uniquelly allocated ID.



Arguments:


    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.


    AccountName - Points to the name of the new account.  A case-insensitive
        comparison must not find an alias or user with this name already defined.


    DesiredAccess - Is an access mask indicating which access types
        are desired to the alias.

    AliasHandle - Receives a handle referencing the newly created
        alias.  This handle will be required in successive calls to
        operate on the alias.

    RelativeId - Receives the relative ID of the newly created alias
        account.  The SID of the new alias account is this relative
        ID value prefixed with the domain's SID value.



Return Value:

    STATUS_SUCCESS - The alias was added successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_ACCOUNT_NAME - The name was poorly formed, e.g.
        contains non-printable characters.

    STATUS_GROUP_EXISTS - The name is already in use as a group.

    STATUS_USER_EXISTS - The name is already in use as a user.

    STATUS_ALIAS_EXISTS - The name is already in use as an alias.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled before aliases
        can be created in it.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.  The domain server must be a primary server to
        create alias accounts.



--*/
{
    NTSTATUS                NtStatus = STATUS_SUCCESS, IgnoreStatus;
    PSAMP_OBJECT            DomainContext = (PSAMP_OBJECT) DomainHandle, 
                            AliasContext = NULL;
    SAMP_OBJECT_TYPE        FoundType;
    PSAMP_DEFINED_DOMAINS   Domain = NULL;
    ULONG                   NewAccountRid, NewSecurityDescriptorLength;
    UNICODE_STRING          KeyName;
    PSECURITY_DESCRIPTOR    NewSecurityDescriptor;
    SAMP_V1_FIXED_LENGTH_ALIAS V1Fixed;
    PRIVILEGE_SET           Privileges;
    DSNAME                  *LoopbackName;
    BOOLEAN                 fLockAcquired = FALSE,
                            AccountNameDefaulted = FALSE,
                            RemoveAccountNameFromTable = FALSE;

    SAMTRACE_EX("SampCreateAliasInDomain");

    if (AliasHandle == NULL) {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Initialize the privilege set.
    //

    Privileges.PrivilegeCount = 0;
    Privileges.Control = PRIVILEGE_SET_ALL_NECESSARY;
    Privileges.Privilege[0].Luid = RtlConvertLongToLuid(0L);
    Privileges.Privilege[0].Attributes = 0;

    //
    // Make sure a name was provided
    //

    
    if (AccountName == NULL) {
        return(STATUS_INVALID_ACCOUNT_NAME);
    }
    if (AccountName->Length > AccountName->MaximumLength) {
        return(STATUS_INVALID_ACCOUNT_NAME);
    }
    if ((AccountName->Buffer == NULL ) || (AccountName->Length==0)) 
    {

        if (!LoopbackClient)
        {
            return(STATUS_INVALID_ACCOUNT_NAME);
        }
        else
        {
            //
            // For loopback cases passing in a NULL account name
            // requests defaulting of the account name
            //

            AccountNameDefaulted = TRUE;
        }
    }
    
    //
    // Do a start type WMI event trace
    //

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidCreateAliasInDomain
                   );


    if ( !WriteLockHeld ) {

        NtStatus = SampMaybeAcquireWriteLock(DomainContext, &fLockAcquired);
        if (!NT_SUCCESS(NtStatus)) {
            goto SampCreateAliasInDomainError;
        }
    }


    //
    // Validate the domain handle
    //

    AliasContext = NULL;

    //
    // Non trusted clients can not create pricipals in Builtin Domain
    //

    if (IsBuiltinDomain(DomainContext->DomainIndex) &&
        !DomainContext->TrustedClient )
    {
        NtStatus = STATUS_ACCESS_DENIED;
        goto SampCreateAliasInDomainError;
    }

    //
    // Perform Any Access Checks
    //

    NtStatus = SampDoAliasCreationChecks(DomainContext);




    if (NT_SUCCESS(NtStatus)) {


        Domain = &SampDefinedDomains[ DomainContext->DomainIndex ];

        if (!AccountNameDefaulted)
        {
            //
            // Make sure the name is valid and not already in use before we
            // use it to create the new alias.
            //

            NtStatus = SampValidateNewAccountName(
                            DomainContext,
                            (PUNICODE_STRING)AccountName,
                            SampAliasObjectType
                            );
            //
            // RemoveAccountNameFromTable tells us whether
            // the caller (this routine) is responsable 
            // to remove the name from the table. 
            // 

            RemoveAccountNameFromTable = 
                            DomainContext->RemoveAccountNameFromTable;

            //
            // reset 
            //  
            DomainContext->RemoveAccountNameFromTable = FALSE;
        }

        if ( NT_SUCCESS(NtStatus) ) {


            if ( (*RelativeId) == 0 ) {

                //
                // Allocate a new (alias) account RID
                //

                if (IsDsObject(DomainContext))
                {
                    // This is a DS domain, so use the multi-master RID
                    // allocator to get the next RID.

                    NtStatus = SampGetNextRid(DomainContext,
                                              &NewAccountRid);
                    SampDiagPrint(INFORM,
                                  ("SAMSS: New Alias RID = %lu\n",
                                   NewAccountRid));

                    if (!NT_SUCCESS(NtStatus))
                    {
                        KdPrintEx((DPFLTR_SAMSS_ID,
                                   DPFLTR_INFO_LEVEL,
                                   "SAMSS: SampGetNextRid status = 0x%lx\n",
                                   NtStatus));
                    }

                }
                else
                {
                    // This is not a DS domain, use the registry RID infor-
                    // mation.

                    NewAccountRid = Domain->CurrentFixed.NextRid;
                    Domain->CurrentFixed.NextRid += 1;
                }

                (*RelativeId) = NewAccountRid;

            } else {

                //
                // Use the RID that was passed in.
                //

                ASSERT(TRUE == Domain->Context->TrustedClient);
                NewAccountRid = (*RelativeId);
            }

            SampDiagPrint(RID_TRACE,("SAMSS RID_TRACE New Rid %d\n",NewAccountRid));


            if ((NT_SUCCESS(NtStatus)) && (AccountNameDefaulted))
            {
                NtStatus = SampGetAccountNameFromRid(AccountName,NewAccountRid);
            }

            //
            // Check For Duplicate Sids. Currently we leave this check on in both
            // the checked as well as the free builds. Sometime in the future we can
            // remove it in the free builds
            //

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = SampCheckForDuplicateSids(
                                DomainContext,
                                NewAccountRid
                                );
            }

            //
            // Increment the alias count ONLY in Registry case.
            //

            if (NT_SUCCESS(NtStatus) && (!IsDsObject(DomainContext)) )
            {
                NtStatus = SampAdjustAccountCount(SampAliasObjectType, TRUE);
            }


            if ( !IsDsObject(Domain->Context)) {

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // Create the registry key that has the alias's name.
                    // This simply serves as a name to RID mapping.  Save
                    // the name when done; we'll put it in the context.
                    //

                    NtStatus = SampBuildAccountKeyName(
                                   SampAliasObjectType,
                                   &KeyName,
                                   (PUNICODE_STRING)AccountName
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        NtStatus = RtlAddActionToRXact(
                                       SampRXactContext,
                                       RtlRXactOperationSetValue,
                                       &KeyName,
                                       NewAccountRid,
                                       NULL,
                                       0
                                       );

                        SampFreeUnicodeString(&KeyName);
                    }
                }

            }

            if (NT_SUCCESS(NtStatus)) {

                //
                // Now create an alias context block
                //

                NtStatus = SampCreateAccountContext2(
                                   DomainContext,
                                   SampAliasObjectType,
                                   NewAccountRid,
                                   NULL,
                                   (PUNICODE_STRING)AccountName,
                                   DomainContext->ClientRevision,
                                   DomainContext->TrustedClient,
                                   DomainContext->LoopbackClient,
                                   FALSE,  // Privileged Machine Account Create
                                   FALSE,  // Account exists
                                   FALSE,  // Override Local Group Check
                                   &GroupType,
                                   &AliasContext
                                   );

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // The existing reference count of 1 is for RPC.
                    // Reference the context again for the writes we're
                    // about to do to initialize it.
                    //

                    SampReferenceContext( AliasContext );

                    //
                    // If MAXIMUM_ALLOWED is requested, add GENERIC_ALL
                    //

                    if (DesiredAccess & MAXIMUM_ALLOWED) {

                        DesiredAccess |= GENERIC_ALL;
                    }

                    //
                    // If ACCESS_SYSTEM_SECURITY is requested and we are
                    // a non-trusted client, check that we have
                    // SE_SECURITY_PRIVILEGE.
                    //

                    if ((DesiredAccess & ACCESS_SYSTEM_SECURITY) &&
                        (!DomainContext->TrustedClient) &&
                        (!DomainContext->LoopbackClient)) {

                        NtStatus = SampRtlWellKnownPrivilegeCheck(
                                       TRUE,
                                       SE_SECURITY_PRIVILEGE,
                                       NULL
                                       );

                        if (!NT_SUCCESS(NtStatus)) {

                            if (NtStatus == STATUS_PRIVILEGE_NOT_HELD) {

                                NtStatus = STATUS_ACCESS_DENIED;
                            }

                        } else {

                            Privileges.PrivilegeCount = 1;
                            Privileges.Control = PRIVILEGE_SET_ALL_NECESSARY;
                            Privileges.Privilege[0].Luid = RtlConvertLongToLuid(SE_SECURITY_PRIVILEGE);
                            Privileges.Privilege[0].Attributes = 0;
                        }
                    }

                    //
                    // Make sure the caller can be given the requested access
                    // to the new object
                    //

                    if (NT_SUCCESS(NtStatus)) {

                        AliasContext->GrantedAccess = DesiredAccess;

                        RtlMapGenericMask(
                            &AliasContext->GrantedAccess,
                            &SampObjectInformation[SampAliasObjectType].GenericMapping
                            );


                        if ((SampObjectInformation[SampAliasObjectType].InvalidMappedAccess &
                            AliasContext->GrantedAccess) != 0) {
                            NtStatus = STATUS_ACCESS_DENIED;
                        }
                    }

                }
            }


            //
            // Set the V1_fixed attribute
            //

            if (NT_SUCCESS(NtStatus)) {

                V1Fixed.RelativeId = NewAccountRid;

                NtStatus = SampSetFixedAttributes(
                               AliasContext,
                               (PVOID )&V1Fixed
                               );
            }

            //
            // Set the SECURITY DESCRIPTOR attribute
            //
            // Set the SecurityDescriptor attribute, only in the registry case
                        // In the DS case the act of creating the object itself sets the
                        // security descriptor on the object. The reason for this is that'
                        // the security descriptor has to go through the merge process in the
                        // DS and the Ace's from the parent are not inherited during a modify
                        // entry
            //

            if (NT_SUCCESS(NtStatus)) {

                                if (!IsDsObject(DomainContext))
                                {
                                        NtStatus = SampGetNewAccountSecurity(
                                                                   SampAliasObjectType,
                                                                   FALSE, // Not member of ADMINISTRATORS alias
                                                                   DomainContext->TrustedClient,
                                                                   FALSE,           //RestrictCreatorAccess
                                                                   NewAccountRid,
                                                                   AliasContext,
                                                                   &NewSecurityDescriptor,
                                                                   &NewSecurityDescriptorLength
                                                                   );

                                        if (NT_SUCCESS(NtStatus)) {

                                                NtStatus = SampSetAccessAttribute(
                                                                           AliasContext,
                                                                           SAMP_ALIAS_SECURITY_DESCRIPTOR,
                                                                           NewSecurityDescriptor,
                                                                           NewSecurityDescriptorLength
                                                                           );

                                                MIDL_user_free( NewSecurityDescriptor );
                                        }
                                }
                        }


            //
            // Set the NAME attribute
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampSetUnicodeStringAttribute(
                               AliasContext,
                               SAMP_ALIAS_NAME,
                               (PUNICODE_STRING)AccountName
                               );
            }


            //
            // Set the AdminComment attribute
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampSetUnicodeStringAttribute(
                               AliasContext,
                               SAMP_ALIAS_ADMIN_COMMENT,
                               &SampNullString
                               );
            }


            //
            // Set the MEMBERS attribute (with no members)
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampSetUlongArrayAttribute(
                               AliasContext,
                               SAMP_ALIAS_MEMBERS,
                               NULL,
                               0,
                               0
                               );
            }
        }


        IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // If we created an object, dereference it.  Write out its attributes
    // if everything was created OK.
    //

    if (NT_SUCCESS(NtStatus)) {

        //
        // De-reference the object, write out any change to current xaction.
        //

        ASSERT(AliasContext != NULL);
        NtStatus = SampDeReferenceContext( AliasContext, TRUE );

    } else {

        if (AliasContext != NULL) {

            //
            // De-reference the object, ignore changes
            //

            IgnoreStatus = SampDeReferenceContext( AliasContext, FALSE );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }
    }



    //
    // Commit changes and notify netlogon
    //

    if ( NT_SUCCESS(NtStatus) ) {

        NtStatus = SampCommitAndRetainWriteLock();

        if (NT_SUCCESS(NtStatus)) {

            if (AliasContext->TypeBody.Alias.SecurityEnabled)
            {
                SampNotifyNetlogonOfDelta(
                    SecurityDbNew,
                    SecurityDbObjectSamAlias,
                    *RelativeId,
                    (PUNICODE_STRING) NULL,
                    (DWORD) FALSE,  // Replicate immediately
                    NULL            // Delta data
                    );
            }

            //
            // Generate audit here for local group creation
            // here.
            //

            if (SampDoAccountAuditing(DomainContext->DomainIndex)) {

                ULONG   AuditId;

                if (AliasContext->TypeBody.Alias.SecurityEnabled)
                {
                    AuditId = SE_AUDITID_LOCAL_GROUP_CREATED;
                }
                else
                {
                    AuditId = SE_AUDITID_SECURITY_DISABLED_LOCAL_GROUP_CREATED;
                }

                SampAuditAnyEvent(
                    AliasContext,
                    STATUS_SUCCESS,
                    AuditId,                             // AuditId
                    Domain->Sid,                         // Domain SID
                    NULL,                                // Additional Info
                    NULL,                                // Member Rid (not used)
                    NULL,                                // Member Sid (not used)
                    (PUNICODE_STRING)AccountName,        // Account Name
                    &Domain->ExternalName,               // Domain
                    &AliasContext->TypeBody.Alias.Rid,    // Account Rid
                    &Privileges                          // Privileges used
                    );
            }
        }
    }

    //
    // Return the context handle on success
    // Delete the context block and return a NULL handle on failure
    //

    if (NT_SUCCESS(NtStatus)) {

        ASSERT(AliasContext != NULL);
        (*AliasHandle) = AliasContext;

    } else {

        if (AliasContext != NULL) {
            SampDeleteContext(AliasContext);
        }

        (*AliasHandle) = (SAMPR_HANDLE)0;
    }

SampCreateAliasInDomainError:

    //
    // clean up the account name table
    // 
    if (RemoveAccountNameFromTable)
    {
        IgnoreStatus = SampDeleteElementFromAccountNameTable(
                            (PUNICODE_STRING)AccountName,
                            SampAliasObjectType
                            );
        ASSERT(NT_SUCCESS(IgnoreStatus));
        RemoveAccountNameFromTable = FALSE;
    }

    if ((AccountNameDefaulted) && (NULL!=AccountName->Buffer))
    {
        MIDL_user_free(AccountName->Buffer);
    }


    //
    // Release the lock
    //

    if ( (!WriteLockHeld) ) {
        IgnoreStatus = SampMaybeReleaseWriteLock( fLockAcquired, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Do a End type WMI event trace
    //

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidCreateAliasInDomain
                   );

    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return(NtStatus);
}



NTSTATUS
SamrCreateAliasInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PRPC_UNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    OUT SAMPR_HANDLE *AliasHandle,
    OUT PULONG RelativeId
    )

/*++

Routine Description:

    This is just a wrapper for SampCreateAliasInDomain() that ensures that
    RelativeId points to a RID of zero first.

    A non-zero RID means that SampCreateAliasInDomain() was called by
    SamICreateAccountByRid(), which specifies a RID to be used.

Parameters:

    Same as SampCreateAliasInDomain().

Return Values:

    Same as SampCreateAliasInDomain().

--*/

{
    NTSTATUS NtStatus;
    ULONG    GroupType = GROUP_TYPE_SECURITY_ENABLED|GROUP_TYPE_RESOURCE_GROUP;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrCreateAliasInDomain");

    //
    // Perform a parameter validation
    //  1. Domain Handle is Validated by LookupContext in SampCreateGroupInDomain
    //  2. Desired Access requires no validation
    //

    if ((NULL==AccountName) || (NULL==AccountName->Buffer))
    {
            NtStatus = STATUS_INVALID_ACCOUNT_NAME;
            goto Error;
    }

    if (NULL==AliasHandle)
    {
            NtStatus = STATUS_INVALID_PARAMETER;
            goto Error;
    }

    if (NULL==RelativeId)
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    (*RelativeId) = 0;

    NtStatus = SampCreateAliasInDomain(
                   DomainHandle,
                   AccountName,
                   DesiredAccess,
                   FALSE,
                   FALSE,   // not loopback client
                   GroupType,
                   AliasHandle,
                   RelativeId
                   );
Error:

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    return( NtStatus );
}



NTSTATUS SamrEnumerateAliasesInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )

/*++

Routine Description:

    This API lists all the aliases defined in the account database.
    Since there may be more aliass than can fit into a buffer, the
    caller is provided with a handle that can be used across calls to
    the API.  On the initial call, EnumerationContext should point to a
    SAM_ENUMERATE_HANDLE variable that is set to 0.

    If the API returns STATUS_MORE_ENTRIES, then the API should be
    called again with EnumerationContext.  When the API returns
    STATUS_SUCCESS or any error return, the context becomes invalid for
    future use.

    This API requires DOMAIN_LIST_ALIASES access to the Domain object.

Arguments:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    EnumerationContext - API specific handle to allow multiple calls
        (see below).  This is a zero based index.

    Buffer - Receives a pointer to the buffer containing the
        requested information.  The information returned is
        structured as an array of SAM_RID_ENUMERATION data
        structures.  When this information is no longer needed, the
        buffer must be freed using SamFreeMemory().

    PreferedMaximumLength - Prefered maximum length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves
        as a guide to the server.  Due to data conversion between
        systems with different natural data sizes, the actual amount
        of data returned may be greater than this value.

    CountReturned - Number of entries returned.


Return Value:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no addition entries.

    STATUS_MORE_ENTRIES - There are more entries, so call again.
        This is a successful return.

    STATUS_ACCESS_DENIED - Caller does not have privilege required to
        request that data.

    STATUS_INVALID_HANDLE - The handle passed is invalid.


--*/
{

    NTSTATUS NtStatus;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrEnumerateAliasesInDomain");

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidEnumerateAliasesInDomain
                   );

    NtStatus = SampEnumerateAccountNamesCommon(
                  DomainHandle,
                  SampAliasObjectType,
                  EnumerationContext,
                  Buffer,
                  PreferedMaximumLength,
                  0L, // no filter
                  CountReturned
                  );

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidEnumerateAliasesInDomain
                   );

    return(NtStatus);

}



NTSTATUS SamrRemoveMemberFromForeignDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PRPC_SID MemberId
    )

/*++

Routine Description:

    This routine removes an account (group or user) from all aliases in
    the given domain.  It is meant to be called in domains OTHER than
    domain in which the account was created.

    This is typically called just before deleting the account from the
    domain in which it was created.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    MemberId - The SID of the account being removed.


Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_SPECIAL_ACCOUNT - This operation may not be performed on
        builtin accounts.


--*/

{
    NTSTATUS         NtStatus, IgnoreStatus;
    SAMP_OBJECT_TYPE FoundType;
    PSAMP_OBJECT     DomainContext = NULL;
    PULONG           Membership = NULL;
    PSID             DomainSid = NULL;
    ULONG            MembershipCount, MemberRid, i;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrRemoveMemberFromForiegnDomain");

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidRemoveMemberFromForeignDomain
                   );

    if (!RtlValidSid(MemberId))
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }

    NtStatus = SampAcquireWriteLock();

    if ( !NT_SUCCESS( NtStatus ) ) {

        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }

    //
    // Validate type of, and access to domain object.
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;

    NtStatus = SampLookupContext(
                   DomainContext,
                   DOMAIN_LOOKUP,                   // DesiredAccess
                   SampDomainObjectType,            // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

        //
        // Remove Member from Foriegn Domain Is Called by the Net API to
        // remove memberships from the aliases in the builtin domain while
        // deleting users or groups. This functionality is not required in
        // the DS case, because the Link Table maintains consistency automatically
        // Therefore Do Nothing and Just Return a Status Success.
        //

        if (IsDsObject(DomainContext))
        {
            NtStatus = STATUS_SUCCESS;
            SampDeReferenceContext(DomainContext,FALSE);
            goto Finish;
        }

        if ( !DomainContext->TrustedClient ) {

            //
            // Return error if the SID passed in is for a builtin account.
            // This may seem overly restrictive, but this API is meant to
            // be called before deleting a user, and since deleting
            // builtin accounts isn't allowed, it makes sense for this to
            // fail too.
            //

            NtStatus = SampSplitSid(
                           MemberId,
                           &DomainSid,
                           &MemberRid );

            if ( NT_SUCCESS( NtStatus ) ) {

                MIDL_user_free( DomainSid );
                DomainSid = NULL;

                NtStatus = SampIsAccountBuiltIn( MemberRid );
            }
        }

        if (NT_SUCCESS(NtStatus)) {

             NtStatus = SampRemoveAccountFromAllAliases(
                            MemberId,
                            NULL,
                            TRUE,    // verify caller is allowed to do this
                            DomainHandle,
                            &MembershipCount,
                            &Membership
                            );

        }

        IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE );
    }

    if (NT_SUCCESS(NtStatus)) {

        IgnoreStatus = STATUS_SUCCESS;

        for ( i = 0;
            ( ( i < MembershipCount ) && ( NT_SUCCESS( IgnoreStatus ) ) );
            i++ ) {

            //
            // Notify netlogon once for each alias that the account was
            // removed from.  Netlogon requires that ModifiedCount be
            // incremented each time; Commit increments ModifiedCount,
            // so we do each notification after a commit.
            //

            NtStatus = SampCommitAndRetainWriteLock();
            if (!NT_SUCCESS(NtStatus))
            {
                goto Finish;
            }

            if ( i == 0 ) {

                //
                // The first commit is the one that commits all the
                // important changes, so we'll save it's status to return
                // to the caller.
                //

                NtStatus = IgnoreStatus;

                //
                // Update the Cached Alias Information if necessary in Registry Mode.
                // In DS Mode, we can invalidate Alias Information by SampNotifyRepicatedInChange
                //

                if (!IsDsObject(DomainContext))
                {
                    IgnoreStatus = SampAlRemoveAccountFromAllAliases(
                                       MemberId,
                                       FALSE,
                                       DomainHandle,
                                       NULL,
                                       NULL
                                       );
                }
            }

            if ( NT_SUCCESS( IgnoreStatus ) ) {

                //
                // Notify if we were able to increment the modified count
                // (which is done by SampCommitAndRetainWriteLock()).
                //

                SAM_DELTA_DATA DeltaData;

                //
                // Fill in id of member being removed
                //

                DeltaData.AliasMemberId.MemberSid = MemberId;

                SampNotifyNetlogonOfDelta(
                    SecurityDbChangeMemberDel,
                    SecurityDbObjectSamAlias,
                    Membership[i],
                    (PUNICODE_STRING) NULL,
                    (DWORD) FALSE,  // Replicate immediately
                    &DeltaData
                    );
            }
        }
    }


Finish:

    if ( Membership != NULL ) {

        MIDL_user_free( Membership );
    }



    IgnoreStatus = SampReleaseWriteLock( FALSE );

    SAMTRACE_RETURN_CODE_EX(NtStatus);
    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);

Error:

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidRemoveMemberFromForeignDomain
                   );

    return( NtStatus );
}


NTSTATUS
SampCreateUserInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PRPC_UNICODE_STRING AccountName,
    IN ULONG AccountType,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN WriteLockHeld,
    IN BOOLEAN LoopbackClient,
    OUT SAMPR_HANDLE *UserHandle,
    OUT PULONG GrantedAccess,
    IN OUT PULONG RelativeId
    )

/*++

Routine Description:

    This API adds a new user to the account database.  The account is
    created in a disabled state.  Default information is assigned to all
    fields except the account name.  A password must be provided before
    the account may be enabled, unless the PasswordNotRequired control
    field is set.

    This api may be used in either of two ways:

        1) An administrative utility may use this api to create
           any type of user account.  In this case, the DomainHandle
           is expected to be open for DOMAIN_CREATE_USER access.

        2) A non-administrative user may use this api to create
           a machine account.  In this case, the caller is expected
           to have the SE_CREATE_MACHINE_ACCOUNT_PRIV privilege
           and the DomainHandle is expected to be open for DOMAIN_LOOKUP
           access.


    For the normal administrative model ( #1 above), the creator will
    be assigned as the owner of the created user account.  Furthermore,
    the new account will be give USER_WRITE access to itself.

    For the special machine-account creation model (#2 above), the
    "Administrators" will be assigned as the owner of the account.
    Furthermore, the new account will be given NO access to itself.
    Instead, the creator of the account will be give USER_WRITE and
    DELETE access to the account.


    This call returns a handle to the newly created user that may be
    used for successive operations on the user.  This handle may be
    closed with the SamCloseHandle() API.  If a machine account is
    being created using model #2 above, then this handle will have
    only USER_WRITE and DELETE access.  Otherwise, it will be open
    for USER_ALL_ACCESS.


    A newly created user will automatically be made a member of the
    DOMAIN_USERS group.

    A newly created user will have the following initial field value
    settings.  If another value is desired, it must be explicitly
    changed using the user object manipulation services.

        UserName - the name of the account will be as specified in the
             creation API.

        FullName - will be null.

        UserComment - will be null.

        Parameters - will be null.

        CountryCode - will be zero.

        UserId - will be a uniquelly allocated ID.

        PrimaryGroupId - Will be DOMAIN_USERS.

        PasswordLastSet - will be the time the account was created.

        HomeDirectory - will be null.

        HomeDirectoryDrive - will be null.

        UserAccountControl - will have the following flags set:

              UserAccountDisable,
              UserPasswordNotRequired,
              and the passed account type.


        ScriptPath - will be null.

        WorkStations - will be null.

        CaseInsensitiveDbcs - will be null.

        CaseSensitiveUnicode - will be null.

        LastLogon - will be zero delta time.

        LastLogoff - will be zero delta time

        AccountExpires - will be very far into the future.

        BadPasswordCount - will be negative 1 (-1).

        LastBadPasswordTime - will be SampHasNeverTime ( [High,Low] = [0,0] ).

        LogonCount - will be negative 1 (-1).

        AdminCount - will be zero.

        AdminComment - will be null.

        Password - will be "".


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    AccountName - Points to the name of the new account.  A case-insensitive
        comparison must not find a group or user with this name already defined.

    AccountType - Indicates what type of account is being created.
        Exactly one account type must be provided:

              USER_INTERDOMAIN_TRUST_ACCOUNT
              USER_WORKSTATION_TRUST_ACCOUNT
              USER_SERVER_TRUST_ACCOUNT
              USER_TEMP_DUPLICATE_ACCOUNT
              USER_NORMAL_ACCOUNT
              USER_MACHINE_ACCOUNT_MASK


    DesiredAccess - Is an access mask indicating which access types
        are desired to the user.

    UserHandle - Receives a handle referencing the newly created
        user.  This handle will be required in successive calls to
        operate on the user.

    GrantedAccess - Receives the accesses actually granted to via
        the UserHandle.

    RelativeId - Receives the relative ID of the newly created user
        account.  The SID of the new user account is this relative ID
        value prefixed with the domain's SID value.



Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_GROUP_EXISTS - The name is already in use as a group.

    STATUS_USER_EXISTS - The name is already in use as a user.

    STATUS_ALIAS_EXISTS - The name is already in use as an alias.

    STATUS_INVALID_ACCOUNT_NAME - The name was poorly formed, e.g.
        contains non-printable characters.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled before users
        can be created in it.

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.  The domain server must be a primary server to
        create user accounts.



--*/

{
    NTSTATUS
        NtStatus,
        IgnoreStatus;

    PSAMP_OBJECT
        DomainContext = (PSAMP_OBJECT)DomainHandle,
        UserContext,
        GroupContext;

    SAMP_OBJECT_TYPE
        FoundType;

    PSAMP_DEFINED_DOMAINS
        Domain = NULL;

    SAMP_V1_0A_FIXED_LENGTH_GROUP
        GroupV1Fixed;

    ULONG
        DomainIndex = 0,
        NewAccountRid = 0,
        NewSecurityDescriptorLength;

    UNICODE_STRING
        KeyName;

    PSECURITY_DESCRIPTOR
        NewSecurityDescriptor;

    SAMP_V1_0A_FIXED_LENGTH_USER
        V1aFixed;

    GROUP_MEMBERSHIP
        DomainUsersMember;

    BOOLEAN
        DomainPasswordInformationAccessible = FALSE,
        PrivilegedMachineAccountCreate = FALSE,
        LockAttempted = FALSE,
        AccountNameDefaulted = FALSE,
        RemoveAccountNameFromTable = FALSE;

    PRIVILEGE_SET
        Privileges;

    PPRIVILEGE_SET
        PPrivileges = NULL;     // No privileges in audit by default


    ACCESS_MASK
        AccessRestriction = USER_ALL_ACCESS |
                            ACCESS_SYSTEM_SECURITY;  // No access restrictions by default

    DSNAME  *LoopbackName;
    UNICODE_STRING  TempString;

    SAMTRACE("SampCreateUserInDomain");



    DomainUsersMember.RelativeId = DOMAIN_GROUP_RID_USERS;
    DomainUsersMember.Attributes = (SE_GROUP_MANDATORY |
                                    SE_GROUP_ENABLED |
                                    SE_GROUP_ENABLED_BY_DEFAULT);


    if (UserHandle == NULL) {
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Make sure a name was provided
    //

    
    if (AccountName == NULL) {
        return(STATUS_INVALID_ACCOUNT_NAME);
    }
    if (AccountName->Length > AccountName->MaximumLength) {
        return(STATUS_INVALID_ACCOUNT_NAME);
    }
    if ((AccountName->Buffer == NULL) || (AccountName->Length==0)) 
    {

        if (!LoopbackClient)
        {
            return(STATUS_INVALID_ACCOUNT_NAME);
        }
        else
        {
            //
            // For loopback cases passing in a NULL account name
            // requests defaulting of the account name
            //

            AccountNameDefaulted = TRUE;
        }
    }
    

    //
    // do a WMI event (start) trace. don't forget do a END type event trace
    // at the end of this routine.
    //

    if (AccountType & USER_MACHINE_ACCOUNT_MASK)
    {
        SampTraceEvent(EVENT_TRACE_TYPE_START,
                       SampGuidCreateComputerInDomain
                       );
    }
    else
    {
        SampTraceEvent(EVENT_TRACE_TYPE_START,
                       SampGuidCreateUserInDomain
                       );
    }

    SampUpdatePerformanceCounters(
        ( AccountType & USER_MACHINE_ACCOUNT_MASK ) ?
            DSSTAT_CREATEMACHINETRIES :
            DSSTAT_CREATEUSERTRIES,
        FLAG_COUNTER_INCREMENT,
        0
        );

    if ( !WriteLockHeld ) {

        NtStatus = SampMaybeAcquireWriteLock(DomainContext, &LockAttempted);
        if (!NT_SUCCESS(NtStatus)) {
            goto SampCreateUserInDomainError;
        }
    }


    //
    // Validate the handle to the Domain Object that is passed in by the client.
    // We do different access checks depending upon DS mode or registry mode. In
    // DS mode we do not require create access on the Domain Handle, but rather let
    // the DS do the access check. In Registry Mode we will do access checks , just
    // the way NT4 Sam used to do access checks
    //

    UserContext = NULL;

    //
    // Non trusted clients can not create pricipals in Builtin Domain
    //

    if (IsBuiltinDomain(DomainContext->DomainIndex) &&
        !DomainContext->TrustedClient )
    {
        NtStatus = STATUS_ACCESS_DENIED;
        goto SampCreateUserInDomainError;
    }

    //
    // This is a valid Context handle. Do appropriate access checks
    //

    NtStatus = SampDoUserCreationChecks(
                DomainContext,
                AccountType,
                &PrivilegedMachineAccountCreate,
                &AccessRestriction
                );

    if (NT_SUCCESS(NtStatus)) {

        //
        // If the domain handle allows reading the password parameters,
        // note that now (best to call LookupContext early because of
        // side effects; data will be copied to the user's context later)
        // to make life easy for SampGetUserDomainPasswordInformation().
        //

        //
        // Don't need to set TransactionWithinDomain to FALSE, 
        // because we will do it in SampLookupContext conditionally.
        // 
        IgnoreStatus = SampLookupContext(
                           DomainHandle,
                           DOMAIN_READ_PASSWORD_PARAMETERS, // DesiredAccess
                           SampDomainObjectType,            // ExpectedType
                           &FoundType
                           );

        if ( NT_SUCCESS( IgnoreStatus ) ) {

            DomainIndex = DomainContext->DomainIndex;

            DomainPasswordInformationAccessible = TRUE;

            IgnoreStatus = SampDeReferenceContext( DomainHandle, FALSE );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }


        Domain = &SampDefinedDomains[ DomainContext->DomainIndex ];

        if (!AccountNameDefaulted)
        {
            //
            // Make sure the name is valid and not already in use before we
            // use it to create the new alias.
            //

            NtStatus = SampValidateNewAccountName(
                        DomainContext,
                        (PUNICODE_STRING)AccountName,
                        SampUserObjectType
                        );

            //
            // RemoveAccountNameFromTable tells us whether
            // the caller (this routine) is responsable 
            // to remove the name from the table. 
            // 

            RemoveAccountNameFromTable = 
                            DomainContext->RemoveAccountNameFromTable;

            //
            // reset 
            //  
            DomainContext->RemoveAccountNameFromTable = FALSE;
        }


        if ( NT_SUCCESS(NtStatus) ) {

            if ( (*RelativeId) == 0 ) {

                //
                // Allocate a new (user) account RID
                //

                if (IsDsObject(DomainContext))
                {
                    // This is a DS domain, so use the multi-master RID
                    // allocator to get the next RID.

                    NtStatus = SampGetNextRid(DomainContext,
                                              &(NewAccountRid));
                    SampDiagPrint(INFORM,
                                  ("SAMSS: New User RID = %lu\n",
                                   NewAccountRid));

                    if (!NT_SUCCESS(NtStatus))
                    {
                        KdPrintEx((DPFLTR_SAMSS_ID,
                                   DPFLTR_INFO_LEVEL,
                                   "SAMSS: SampGetNextRid status = 0x%lx\n",
                                   NtStatus));
                    }

                }
                else
                {
                    // This is not a DS domain, use the registry RID infor-
                    // mation.

                    NewAccountRid = Domain->CurrentFixed.NextRid;
                    Domain->CurrentFixed.NextRid += 1;
                }

                (*RelativeId) = NewAccountRid;

            } else {

                //
                // A RID was passed in, so we want to use that rather than
                // select a new one.
                //

                ASSERT(TRUE == Domain->Context->TrustedClient);
                NewAccountRid = (*RelativeId);
            }

            SampDiagPrint(RID_TRACE,("SAMSS RID_TRACE New Rid %d\n",NewAccountRid));

            if ((NT_SUCCESS(NtStatus)) && (AccountNameDefaulted))
            {
                NtStatus = SampGetAccountNameFromRid(AccountName,NewAccountRid);
            }

            //
            // Check For Duplicate Sids. Currently we leave this check on in both
            // the checked as well as the free builds. Sometime in the future we can
            // remove it in the free builds
            //

            if (NT_SUCCESS(NtStatus))
            {

                NtStatus = SampCheckForDuplicateSids(
                                DomainContext,
                                NewAccountRid
                                );
            }

            //
            // Increment the User count ONLY in Registry case
            //

            if (NT_SUCCESS(NtStatus) && (!IsDsObject(DomainContext)) )
            {
                NtStatus = SampAdjustAccountCount(SampUserObjectType, TRUE);
            }

            if ( !IsDsObject(Domain->Context) ) {

                if (NT_SUCCESS(NtStatus)) {

                //
                // Create the registry key that has the User's name.
                // This simply serves as a name to RID mapping.  Save
                // the name when finished; we'll put it in the context.
                //

                    NtStatus = SampBuildAccountKeyName(
                                   SampUserObjectType,
                                   &KeyName,
                                   (PUNICODE_STRING)AccountName
                                   );



                    if (NT_SUCCESS(NtStatus)) {

                        NtStatus = RtlAddActionToRXact(
                                       SampRXactContext,
                                       RtlRXactOperationSetValue,
                                       &KeyName,
                                       NewAccountRid,
                                       NULL,
                                       0
                                       );

                        SampFreeUnicodeString(&KeyName);
                    }
                }
            }

            if (NT_SUCCESS(NtStatus)) {

                //
                // Now create a User context block
                //

                NtStatus = SampCreateAccountContext2(
                                   DomainContext,
                                   SampUserObjectType,
                                   NewAccountRid,
                                   &AccountType,
                                   (PUNICODE_STRING)AccountName,
                                   DomainContext->ClientRevision,
                                   DomainContext->TrustedClient,
                                   DomainContext->LoopbackClient,
                                   PrivilegedMachineAccountCreate,
                                   FALSE, // Account exists
                                   FALSE, // Override Local Group Check
                                   NULL,
                                   &UserContext
                                   );

                if (NT_SUCCESS(NtStatus)) {

                    //
                    // The existing reference count of 1 is for RPC.
                    // Reference the context again for the writes we're
                    // about to do to initialize it.
                    //

                    SampReferenceContext( UserContext );

                    //
                    // Stash away the password info accessible flag
                    //

                    UserContext->TypeBody.User.DomainPasswordInformationAccessible =
                        DomainPasswordInformationAccessible;

                    //
                    // If MAXIMUM_ALLOWED is requested, add GENERIC_ALL
                    //

                    if (DesiredAccess & MAXIMUM_ALLOWED) {

                        DesiredAccess |= GENERIC_ALL;
                    }

                    //
                    // If ACCESS_SYSTEM_SECURITY is requested and we are
                    // a non-trusted client, check that we have
                    // SE_SECURITY_PRIVILEGE.
                    //

                    if ((DesiredAccess & ACCESS_SYSTEM_SECURITY) &&
                        (!DomainContext->TrustedClient)&&
                        (!DomainContext->LoopbackClient)) {

                        NtStatus = SampRtlWellKnownPrivilegeCheck(
                                       TRUE,
                                       SE_SECURITY_PRIVILEGE,
                                       NULL
                                       );

                        if (!NT_SUCCESS(NtStatus)) {

                            if (NtStatus == STATUS_PRIVILEGE_NOT_HELD) {

                                NtStatus = STATUS_ACCESS_DENIED;
                            }
                        }
                    }

                    //
                    // Make sure the caller can be given the requested access
                    // to the new object
                    //

                    if (NT_SUCCESS(NtStatus)) {

                        UserContext->GrantedAccess = DesiredAccess;

                        RtlMapGenericMask(
                            &UserContext->GrantedAccess,
                            &SampObjectInformation[SampUserObjectType].GenericMapping
                            );

                        //
                        // Grant the attribute level rights
                        //
                        SampNt4AccessToWritableAttributes(SampUserObjectType,
                                                          UserContext->GrantedAccess,
                                                         &UserContext->WriteGrantedAccessAttributes);


                        if ((SampObjectInformation[SampUserObjectType].InvalidMappedAccess
                            & UserContext->GrantedAccess) != 0) {

                            NtStatus = STATUS_ACCESS_DENIED;
                        } else {

                            //
                            // Restrict access if necessary
                            //

                            UserContext->GrantedAccess &= AccessRestriction;
                            (*GrantedAccess) = UserContext->GrantedAccess;
                        }
                    }

                }
            }

            //
            // If the GROUP we're going to put this user in
            // is part of an ADMIN alias, we must set the ACL
            // on this user account to disallow access by
            // account operators.  Get group info to determine
            // whether it's in an ADMIN alias or not. DS mode does not
            // require any special ACLs based on Admin or Non Admin. Therefore
            // this operation need not be performed on DS mode and the
            // the CreateAccountContext call can be saved.
            //


            if ((NT_SUCCESS(NtStatus)) && (!IsDsObject(DomainContext))) {

                NtStatus = SampCreateAccountContext(
                                   SampGroupObjectType,
                                   DOMAIN_GROUP_RID_USERS,
                                   TRUE, // TrustedClient,
                                   FALSE,// Loopback Client
                                   TRUE, // Account exists
                                   &GroupContext
                                   );

                if ( NT_SUCCESS( NtStatus ) ) {

                    NtStatus = SampRetrieveGroupV1Fixed(
                                   GroupContext,
                                   &GroupV1Fixed
                                   );

                    SampDeleteContext(GroupContext);
                }
            }


            //
            // Set the V1_fixed attribute
            //

            if (NT_SUCCESS(NtStatus)) {

                V1aFixed.Revision            = SAMP_REVISION;

                V1aFixed.CountryCode         = 0;
                V1aFixed.CodePage            = 0;
                V1aFixed.BadPasswordCount    = 0;
                V1aFixed.LogonCount          = 0;
                V1aFixed.AdminCount          = 0;
                V1aFixed.OperatorCount       = 0;
                V1aFixed.Unused1             = 0;
                V1aFixed.Unused2             = 0;
                V1aFixed.UserAccountControl  = (USER_PASSWORD_NOT_REQUIRED |
                                                AccountType);
                //
                // Disable the account unless this is a special creation
                // in which the creator won't be able to enable the account.
                //

                if (!UserContext->TypeBody.User.PrivilegedMachineAccountCreate) {
                    V1aFixed.UserAccountControl |= USER_ACCOUNT_DISABLED;
                }

                V1aFixed.UserId              = NewAccountRid;

                //
                // For Computers set the primary group id to DOMAIN_GROUP_RID_COMPUTERS
                // For others this should be DOMAIN_GROUP_RID_USERS
                //

                V1aFixed.PrimaryGroupId = SampDefaultPrimaryGroup(
                                                UserContext,
                                                AccountType
                                                );



                V1aFixed.LastLogon           = SampHasNeverTime;
                V1aFixed.LastLogoff          = SampHasNeverTime;
                V1aFixed.PasswordLastSet     = SampHasNeverTime;
                V1aFixed.AccountExpires      = SampWillNeverTime;
                V1aFixed.LastBadPasswordTime = SampHasNeverTime;

                NtStatus = SampSetFixedAttributes(
                               UserContext,
                               (PVOID )&V1aFixed
                               );
            }

            //
            // Set the SECURITY_DESCRIPTOR attribute
            //
            // Set the SecurityDescriptor attribute, only in the registry case
            // In the DS case the act of creating the object itself sets the
            // security descriptor on the object. The reason for this is that'
            // the security descriptor has to go through the merge process in the
            // DS and the Ace's from the parent are not inherited during a modify
            // entry
            //

            if (NT_SUCCESS(NtStatus)) {

                //
                // Build a security descriptor to protect the User.
                //

                if (!IsDsObject(DomainContext))
                {
                    NtStatus = SampGetNewAccountSecurity(
                                    SampUserObjectType,
                                    (BOOLEAN) ((GroupV1Fixed.AdminCount == 0) ? FALSE : TRUE),
                                    DomainContext->TrustedClient,
                                    UserContext->TypeBody.User.PrivilegedMachineAccountCreate,
                                    NewAccountRid,
                                    UserContext,
                                    &NewSecurityDescriptor,
                                    &NewSecurityDescriptorLength
                                    );

                    if (NT_SUCCESS(NtStatus)) {

                        NtStatus = SampSetAccessAttribute(
                                       UserContext,
                                       SAMP_USER_SECURITY_DESCRIPTOR,
                                       NewSecurityDescriptor,
                                       NewSecurityDescriptorLength
                                      );

                        MIDL_user_free( NewSecurityDescriptor );

                    }
                }
            }


            //
            // Set the ACCOUNT_NAME attribute
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampSetUnicodeStringAttribute(
                               UserContext,
                               SAMP_USER_ACCOUNT_NAME,
                               (PUNICODE_STRING)AccountName
                               );
            }


            //
            // Don't set these attribute in loopback case
            // 

            if (NT_SUCCESS(NtStatus) &&
                !UserContext->LoopbackClient)
            {
                //
                // Set the FULL_NAME attribute
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_FULL_NAME,
                                   &SampNullString
                                   );
                }


                //
                // Set the AdminComment attribute
                //

                if (NT_SUCCESS(NtStatus)) {
        
                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_ADMIN_COMMENT,
                                   &SampNullString
                                   );
                }


                //
                // Set the UserComment attribute
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_USER_COMMENT,
                                   &SampNullString
                                   );
                }


                //
                // Set the Parameters attribute
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_PARAMETERS,
                                   &SampNullString
                                   );
                }


                //
                // Set the HomeDirectory attribute
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_HOME_DIRECTORY,
                                   &SampNullString
                                   );
                }


                //
                // Set the HomeDirectoryDrive attribute
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_HOME_DIRECTORY_DRIVE,
                                   &SampNullString
                                   );
                }


                //
                // Set the ScriptPath attribute
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_SCRIPT_PATH,
                                   &SampNullString
                                   );
                }


                //
                // Set the ProfilePath attribute
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_PROFILE_PATH,
                                   &SampNullString
                                   );
                }


                //
                // Set the WorkStations attribute
                //

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_WORKSTATIONS,
                                   &SampNullString
                                   );
                }
            }


            //
            // Set the LogonHours attribute
            //

            if (NT_SUCCESS(NtStatus)) {

                LOGON_HOURS LogonHours;

                LogonHours.UnitsPerWeek = 0;
                LogonHours.LogonHours = NULL;

                NtStatus = SampSetLogonHoursAttribute(
                               UserContext,
                               SAMP_USER_LOGON_HOURS,
                               &LogonHours
                               );
            }


            //
            // Set the Groups attribute (with membership in DomainUsers only)
            //

            if ((NT_SUCCESS(NtStatus)) && (!IsDsObject(UserContext))) {

                NtStatus = SampSetLargeIntArrayAttribute(
                               UserContext,
                               SAMP_USER_GROUPS,
                               (PLARGE_INTEGER)&DomainUsersMember,
                               1
                               );
            }

            //
            // Set the CaseInsensitiveDbcs attribute
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampEncryptSecretData(
                               &TempString,
                               SampGetEncryptionKeyType(),
                               LmPassword,
                               &SampNullString,
                               NewAccountRid
                               );
                if (NT_SUCCESS(NtStatus)) {
                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_DBCS_PWD,
                                   &TempString
                                   );
                    SampFreeUnicodeString(&TempString);
                }
            }


            //
            // Create the CaseSensitiveUnicode key
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampEncryptSecretData(
                               &TempString,
                               SampGetEncryptionKeyType(),
                               NtPassword,
                               &SampNullString,
                               NewAccountRid
                               );
                if (NT_SUCCESS(NtStatus)) {
                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_UNICODE_PWD,
                                   &TempString
                                   );
                    SampFreeUnicodeString(&TempString);
                }
            }


            //
            // Set the NtPasswordHistory attribute
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampEncryptSecretData(
                               &TempString,
                               SampGetEncryptionKeyType(),
                               NtPasswordHistory,
                               &SampNullString,
                               NewAccountRid
                               );
                if (NT_SUCCESS(NtStatus)) {
                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_NT_PWD_HISTORY,
                                   &TempString
                                   );
                    SampFreeUnicodeString(&TempString);
                }
            }


            //
            // Set the LmPasswordHistory attribute
            //

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampEncryptSecretData(
                               &TempString,
                               SampGetEncryptionKeyType(),
                               LmPasswordHistory,
                               &SampNullString,
                               NewAccountRid
                               );

                if (NT_SUCCESS(NtStatus)) {
                    NtStatus = SampSetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_LM_PWD_HISTORY,
                                   &TempString
                                   );
                    SampFreeUnicodeString(&TempString);
                }
            }



            //
            // Add this new user to the DomainUsers group
            //

            if ((NT_SUCCESS(NtStatus)) && (!(IsDsObject(UserContext)))) {

                //
                // This addition is done only in the registry case. In the DS case,
                // membership in the primary group is maintained implicitly in the
                // primary group Id property.
                //

                NtStatus = SampAddUserToGroup(
                                    DomainContext,
                                    DOMAIN_GROUP_RID_USERS, 
                                    NewAccountRid
                                    );
            }



        }

        IgnoreStatus = SampDeReferenceContext(DomainContext, FALSE);

        ASSERT(NT_SUCCESS(IgnoreStatus));

    }



    //
    // If we created an object, dereference it.  Write out its attributes
    // if everything was created OK.
    //

    if (NT_SUCCESS(NtStatus)) {

        //
        // De-reference the object, write out any change to current xaction.
        //

        ASSERT(UserContext != NULL);
        NtStatus = SampDeReferenceContext( UserContext, TRUE );

    } else {

        if (UserContext != NULL) {

            //
            // De-reference the object, ignore changes
            //

            IgnoreStatus = SampDeReferenceContext( UserContext, FALSE );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }
    }




    //
    // Commit changes and notify netlogon
    //

    if ( NT_SUCCESS(NtStatus) ) {

        //
        // Commit the changes; hold on to the write lock for now.
        //

        NtStatus = SampCommitAndRetainWriteLock();

        //
        // If we can't commit the mess for some reason, then delete
        // the new context block and return null for the context handle.
        //

        if (NT_SUCCESS(NtStatus)) {


            if (!IsDsObject(UserContext))
            {
                SAMP_ACCOUNT_DISPLAY_INFO AccountInfo;

                //
                // Update the display information
                //

                AccountInfo.Name = *((PUNICODE_STRING)AccountName);
                AccountInfo.Rid = NewAccountRid;
                AccountInfo.AccountControl = V1aFixed.UserAccountControl;
                RtlInitUnicodeString(&AccountInfo.Comment, NULL);
                RtlInitUnicodeString(&AccountInfo.FullName, NULL);

                IgnoreStatus = SampUpdateDisplayInformation(
                                                NULL,
                                                &AccountInfo,
                                                SampUserObjectType
                                                );
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }
            //
            // Audit the creation before we free the write lock
            // so that we have access to the context block.
            //

            if (SampDoAccountAuditing(UserContext->DomainIndex)) {

                ULONG   AuditId;

                if (UserContext->TypeBody.User.PrivilegedMachineAccountCreate) {

                    //
                    // Set up the privilege set for auditing
                    //


                    Privileges.PrivilegeCount = 1;
                    Privileges.Control = 0;
                    ASSERT(ANYSIZE_ARRAY >= 1);
                    Privileges.Privilege[0].Attributes = SE_PRIVILEGE_USED_FOR_ACCESS;
                    Privileges.Privilege[0].Luid = RtlConvertUlongToLuid( SE_MACHINE_ACCOUNT_PRIVILEGE);
                    PPrivileges = &Privileges;
                }

                if (V1aFixed.UserAccountControl &
                    USER_MACHINE_ACCOUNT_MASK )
                {
                    AuditId = SE_AUDITID_COMPUTER_CREATED;
                }
                else
                {
                    AuditId = SE_AUDITID_USER_CREATED;
                }


                SampAuditAnyEvent(
                    UserContext,
                    STATUS_SUCCESS,
                    AuditId,                        // AuditId
                    Domain->Sid,                    // Domain SID
                    NULL,                           // Additional Info
                    NULL,                           // Member Rid (not used)
                    NULL,                           // Member Sid (not used)
                    (PUNICODE_STRING)AccountName,   // Account Name
                    &Domain->ExternalName,          // Domain
                    &NewAccountRid,                 // Account Rid
                    PPrivileges                     // Privileges used
                    );
            }

            //
            // Notify netlogon if a machine account was created.
            //

            if ( ( V1aFixed.UserAccountControl &
                USER_MACHINE_ACCOUNT_MASK ) != 0 ) {

                //
                // This was a machine account.  Let
                // NetLogon know of the change.
                //

                IgnoreStatus = I_NetNotifyMachineAccount(
                                   NewAccountRid,
                                   SampDefinedDomains[DomainIndex].Sid,
                                   0,
                                   V1aFixed.UserAccountControl,
                                   (PUNICODE_STRING)AccountName
                                   );
            }

            //
            // Notify netlogon of changes
            //

            SampNotifyNetlogonOfDelta(
                SecurityDbNew,
                SecurityDbObjectSamUser,
                *RelativeId,
                (PUNICODE_STRING) NULL,
                (DWORD) FALSE,  // Replicate immediately
                NULL            // Delta data
                );

        }

    }



    //
    // Return the context handle on success
    // Delete the context block and return a NULL handle on failure
    //

    if (NT_SUCCESS(NtStatus)) {

        ASSERT(UserContext != NULL);
        (*UserHandle) = UserContext;

        SampUpdatePerformanceCounters(
           ( AccountType & USER_MACHINE_ACCOUNT_MASK ) ?
                DSSTAT_CREATEMACHINESUCCESSFUL :
                DSSTAT_CREATEUSERSUCCESSFUL,
            FLAG_COUNTER_INCREMENT,
            0
            );

    } else {

        if (UserContext != NULL) {
            SampDeleteContext(UserContext);
        }

        (*UserHandle) = (SAMPR_HANDLE)0;
    }


SampCreateUserInDomainError:

    //
    // clean up the account name table
    // 

    if (RemoveAccountNameFromTable)
    {
        IgnoreStatus = SampDeleteElementFromAccountNameTable(
                            (PUNICODE_STRING)AccountName,
                            SampUserObjectType
                            );
        ASSERT(NT_SUCCESS(IgnoreStatus));
        RemoveAccountNameFromTable = FALSE;
    }

    if ((AccountNameDefaulted) && (NULL!=AccountName->Buffer))
    {
        MIDL_user_free(AccountName->Buffer);
    }


    //
    // Release the lock
    //

    if ( !WriteLockHeld ) {
        IgnoreStatus = SampMaybeReleaseWriteLock( LockAttempted, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Do a WMI event (END type) trace
    //

    if (AccountType & USER_MACHINE_ACCOUNT_MASK)
    {
        SampTraceEvent(EVENT_TRACE_TYPE_END,
                       SampGuidCreateComputerInDomain
                       );
    }
    else
    {
        SampTraceEvent(EVENT_TRACE_TYPE_END,
                       SampGuidCreateUserInDomain 
                       );
    }

    return(NtStatus);
}


NTSTATUS
SamrCreateUser2InDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PRPC_UNICODE_STRING AccountName,
    IN ULONG AccountType,
    IN ACCESS_MASK DesiredAccess,
    OUT SAMPR_HANDLE *UserHandle,
    OUT PULONG GrantedAccess,
    OUT PULONG RelativeId
    )

/*++

Routine Description:

    This is just a wrapper for SampCreateUserInDomain() that ensures
    RelativeId points to a RID of zero first.  It also guarantees
    that AccountType is valid.

    A non-zero RID means that SampCreateUserInDomain() was called by
    SamICreateAccountByRid(), which specifies a RID to be used.

Parameters:

    Same as SampCreateUserInDomain() except AccountType maps to
    AccountControl.

Return Values:

    Same as SampCreateUserInDomain().

--*/

{
    NTSTATUS NtStatus;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrCreateUser2InDomain");


    //
    // Perform a parameter validation
    //  1. Domain Handle is Validated by LookupContext in SampCreateGroupInDomain
    //  2. Desired Access requires no validation
    //

    if ((NULL==AccountName) || (NULL==AccountName->Buffer))
    {
            NtStatus = STATUS_INVALID_ACCOUNT_NAME;
            goto Error;
    }

    if (NULL==UserHandle)
    {
            NtStatus = STATUS_INVALID_PARAMETER;
            goto Error;
    }

    if (NULL==RelativeId)
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    (*RelativeId) = 0;

    //
    // Make sure one, and only one, account type flag is set.
    //

    switch (AccountType) {

        case USER_NORMAL_ACCOUNT            :
        case USER_WORKSTATION_TRUST_ACCOUNT :
        case USER_INTERDOMAIN_TRUST_ACCOUNT :
        case USER_SERVER_TRUST_ACCOUNT      :
        case USER_TEMP_DUPLICATE_ACCOUNT    :

            //
            // AccountType is valid
            //

            break;

        default :

            //
            // Bad account type value specified
            //

            NtStatus = STATUS_INVALID_PARAMETER;
            SAMTRACE_RETURN_CODE_EX(NtStatus);
            return( NtStatus );
    }




    NtStatus = SampCreateUserInDomain(
                   DomainHandle,
                   AccountName,
                   AccountType,
                   DesiredAccess,
                   FALSE,
                   FALSE,   // not loopback client
                   UserHandle,
                   GrantedAccess,
                   RelativeId
                   );

Error:

    SAMTRACE_RETURN_CODE_EX(NtStatus);
    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);

    return( NtStatus );
}


NTSTATUS SamrCreateUserInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PRPC_UNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    OUT SAMPR_HANDLE *UserHandle,
    OUT PULONG RelativeId
    )

/*++

Routine Description:

    This is just a wrapper for SampCreateUserInDomain() that ensures that
    RelativeId points to a RID of zero first.

    A non-zero RID means that SampCreateUserInDomain() was called by
    SamICreateAccountByRid(), which specifies a RID to be used.

Parameters:

    Same as SampCreateUserInDomain() except AccountType is NORMAL_USER.

Return Values:

    Same as SampCreateUserInDomain().

--*/

{
    NTSTATUS
        NtStatus;

    ULONG
        GrantedAccess;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrCreateUserInDomain");

    //
    // Perform a parameter validation
    //  1. Domain Handle is Validated by LookupContext in SampCreateGroupInDomain
    //  2. Desired Access requires no validation
    //

    if ((NULL==AccountName) || (NULL==AccountName->Buffer))
    {
            NtStatus = STATUS_INVALID_ACCOUNT_NAME;
            goto Error;
    }

    if (NULL==UserHandle)
    {
            NtStatus = STATUS_INVALID_PARAMETER;
            goto Error;
    }

    if (NULL==RelativeId)
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    (*RelativeId) = 0;

    NtStatus = SampCreateUserInDomain(
                   DomainHandle,
                   AccountName,
                   USER_NORMAL_ACCOUNT,
                   DesiredAccess,
                   FALSE,
                   FALSE,   // not loopback client
                   UserHandle,
                   &GrantedAccess,
                   RelativeId
                   );

Error:
    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);
    return( NtStatus );
}



NTSTATUS SamrEnumerateUsersInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    IN ULONG UserAccountControl,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    OUT PULONG CountReturned
    )

/*++

Routine Description:

    This API lists all the users defined in the account database.  Since
    there may be more users than can fit into a buffer, the caller is
    provided with a handle that can be used across calls to the API.  On
    the initial call, EnumerationContext should point to a
    SAM_ENUMERATE_HANDLE variable that is set to 0.

    If the API returns STATUS_MORE_ENTRIES, then the API should be
    called again with EnumerationContext.  When the API returns
    STATUS_SUCCESS or any error return, the handle becomes invalid for
    future use.

    This API requires DOMAIN_LIST_USERS access to the Domain object.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    EnumerationContext - API specific handle to allow multiple calls.
        This is a zero based index.

    UserAccountControl - Provides enumeration filtering information.  Any
        characteristics specified here will cause that type of User account
        to be included in the enumeration process.

    Buffer - Receives a pointer to the buffer containing the
        requested information.  The information returned is
        structured as an array of SAM_RID_ENUMERATION data
        structures.  When this information is no longer needed, the
        buffer must be freed using SamFreeMemory().

    PreferedMaximumLength - Prefered maximum length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves
        as a guide to the server.  Due to data conversion between
        systems with different natural data sizes, the actual amount
        of data returned may be greater than this value.

    CountReturned - Number of entries returned.

Return Values:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.

    STATUS_MORE_ENTRIES - There are more entries, so call again.
        This is a successful return.

    STATUS_ACCESS_DENIED - Caller does not have privilege required to
        request that data.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

--*/

{

    NTSTATUS                    NtStatus;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrEnumerateUsersInDomain");

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidEnumerateUsersInDomain
                   );

    NtStatus = SampEnumerateAccountNamesCommon(
                  DomainHandle,
                  SampUserObjectType,
                  EnumerationContext,
                  Buffer,
                  PreferedMaximumLength,
                  UserAccountControl,
                  CountReturned
                  );

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    //
    // WMI Event Trace
    // 

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidEnumerateUsersInDomain
                   );

    return(NtStatus);
}





NTSTATUS SamrLookupNamesInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN ULONG Count,
    IN RPC_UNICODE_STRING Names[],
    OUT PSAMPR_ULONG_ARRAY RelativeIds,
    OUT PSAMPR_ULONG_ARRAY Use
    )

/*++

Routine Description:

    This API attempts to find relative IDs corresponding to name
    strings.  If a name can not be mapped to a relative ID, a zero is
    placed in the corresponding relative ID array entry, and translation
    continues.

    DOMAIN_LOOKUP access to the domain is needed to use this service.


Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    Count - Number of names to translate.

    Names - Pointer to an array of Count UNICODE_STRINGs that contain
        the names to map to relative IDs.  Case-insensitive
        comparisons of these names will be performed for the lookup
        operation.

    RelativeIds - Receives an array of Count Relative IDs.
        The relative ID of the nth name will be the nth entry in this
        array.  Any names that could not be translated will have a
        zero relative ID.

    RelativeIds - Receives a pointer to a SAMPR_RETURNED_ULONG_ARRAY structure.
        The nth entry in the array associated with this structure
        contains the RID of the nth name looked up.
        When this information is no longer needed, the caller is responsible
        for deallocating each returned block (including the
        SAMPR_ULONG_ARRAY structure itself) using SamFreeMemory().

    Use - Receives a pointer to a SAMPR_RETURNED_ULONG_ARRAY structure.
        The nth entry in the array associated with this structure
        contains the SID_NAME_USE of the nth name looked up.
        When this information is no longer needed, the caller is responsible
        for deallocating each returned block (including the
        SAMPR_ULONG_ARRAY structure itself) using SamFreeMemory().



Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The domain handle passed is invalid.

    STATUS_SOME_NOT_MAPPED - Some of the names provided could not be
        mapped.  This is a successful return.

    STATUS_NONE_MAPPED - No names could be mapped.  This is an error
        return.

--*/
{
    NTSTATUS                NtStatus, IgnoreStatus;
    UNICODE_STRING          KeyName;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    PSAMP_OBJECT            DomainContext;
    SAMP_OBJECT_TYPE        FoundType;
    HANDLE                  TempHandle;
    LARGE_INTEGER           IgnoreTimeStamp;
    ULONG                   i, KeyValueLength, UnMappedCount;
    ULONG                   ApproximateTotalLength;
    BOOLEAN                 fLockAcquired = FALSE;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrLookupNamesInDomain");

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidLookupNamesInDomain
                   );


    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (Use != NULL);
    ASSERT (Use->Element == NULL);
    ASSERT (RelativeIds != NULL);
    ASSERT (RelativeIds->Element == NULL);

    if (!((Use!=NULL) && (Use->Element==NULL)
            && (RelativeIds != NULL) && (RelativeIds->Element == NULL)))
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto EndOfTrace;
    }

    Use->Count           = 0;
    RelativeIds->Count   = 0;


    if (Count == 0) {
        NtStatus = STATUS_SUCCESS;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto EndOfTrace;
    }


    //
    // Make sure the parameter values are within reasonable bounds
    //

    if (Count > SAM_MAXIMUM_LOOKUP_COUNT) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto EndOfTrace;
    }

    //
    // Validate all the names that are passed in to us
    //

    for (i=0;i<Count;i++)
    {
        if (NULL==Names[i].Buffer)
        {
            NtStatus = STATUS_INVALID_ACCOUNT_NAME;
            SAMTRACE_RETURN_CODE_EX(NtStatus);
            goto EndOfTrace;
        }
    }


    ApproximateTotalLength = (Count*(sizeof(ULONG) + sizeof(SID_NAME_USE)));

    //
    // Do the return test inside this loop to avoid overflow problems
    // summing up the name lengths.
    //

    for ( i=0; i<Count; i++) {
        ApproximateTotalLength += (ULONG)Names[i].MaximumLength;
        if ( ApproximateTotalLength > SAMP_MAXIMUM_MEMORY_TO_USE ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            SAMTRACE_RETURN_CODE_EX(NtStatus);
            goto EndOfTrace;
        }
    }



    //
    // Allocate the return buffers
    //

    Use->Element = MIDL_user_allocate( Count * sizeof(ULONG) );
    if (Use->Element == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto EndOfTrace;
    }

    RelativeIds->Element = MIDL_user_allocate( Count * sizeof(ULONG) );
    if (RelativeIds->Element == NULL) {
        MIDL_user_free( Use->Element);
        Use->Element = NULL;  // required to RPC doesn't free it again.
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto EndOfTrace;
    }


    Use->Count         = Count;
    RelativeIds->Count = Count;


    //
    // Acquire the READ lock if necessary
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;

    SampMaybeAcquireReadLock(DomainContext,
                             DOMAIN_OBJECT_DONT_ACQUIRELOCK_EVEN_IF_SHARED,
                             &fLockAcquired);


    //
    // Validate type of, and access to object.
    //


    NtStatus = SampLookupContext(
                   DomainContext,
                   DOMAIN_LOOKUP,
                   SampDomainObjectType,           // ExpectedType
                   &FoundType
                   );


    if (NT_SUCCESS(NtStatus)) {

        UnMappedCount = Count;
        for ( i=0; i<Count; i++) {


            if (IsDsObject(DomainContext))
            {

                NtStatus = SampLookupAccountRid(
                                DomainContext,
                                SampUnknownObjectType,
                                (PUNICODE_STRING)&(Names[i]),
                                STATUS_OBJECT_NAME_NOT_FOUND,
                                &(RelativeIds->Element[i]),
                                (PSID_NAME_USE)&(Use->Element[i])
                                );


                if (NT_SUCCESS(NtStatus))
                {
                    UnMappedCount -=1;
                }
                else if (NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {

                    //
                    // This is fine.  It just means that we don't
                    // have an account with the name being looked up.
                    //

                    Use->Element[i]         = SidTypeUnknown;
                    RelativeIds->Element[i] = 0;
                    SampDiagPrint(LOGON,("[SAMSS] Name Not Found %S \n",Names[i].Buffer));
                    NtStatus = STATUS_SUCCESS;
                }
                else if (!NT_SUCCESS(NtStatus))
                {
                    SampDiagPrint(LOGON,("[SAMSS] Looking up Name %S Unexpected Error %d\n",
                                            Names[i].Buffer,
                                            NtStatus));
                    goto unexpected_error;
                }

            }
            else
            {

                //
                // Registry Case
                //

                //
                // Search the groups for a match
                //

                NtStatus = SampBuildAccountKeyName(
                               SampGroupObjectType,
                               &KeyName,
                               (PUNICODE_STRING)&Names[i]
                               );
                if (NT_SUCCESS(NtStatus)) {

                    InitializeObjectAttributes(
                        &ObjectAttributes,
                        &KeyName,
                        OBJ_CASE_INSENSITIVE,
                        SampKey,
                        NULL
                        );

                    SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

                    NtStatus = RtlpNtOpenKey(
                                   &TempHandle,
                                   (KEY_READ),
                                   &ObjectAttributes,
                                   0
                                   );
                    SampFreeUnicodeString( &KeyName );

                    if (NT_SUCCESS(NtStatus)) {

                        UnMappedCount  -= 1;
                        Use->Element[i] = SidTypeGroup;
                        KeyValueLength  = 0;
                        NtStatus = RtlpNtQueryValueKey(
                                       TempHandle,
                                       &RelativeIds->Element[i],
                                       NULL,
                                       &KeyValueLength,
                                       &IgnoreTimeStamp
                                       );

                        SampDumpRtlpNtQueryValueKey(&RelativeIds->Element[i],
                                                    NULL,
                                                    &KeyValueLength,
                                                    &IgnoreTimeStamp);

                        IgnoreStatus = NtClose( TempHandle );
                        ASSERT( NT_SUCCESS(IgnoreStatus) );
                        if (!NT_SUCCESS(NtStatus)) {
                            goto unexpected_error;
                        }
                        ASSERT(KeyValueLength == 0);


                    } else {

                        //
                        // Search the aliases for a match
                        //

                        NtStatus = SampBuildAccountKeyName(
                                       SampAliasObjectType,
                                       &KeyName,
                                       (PUNICODE_STRING)&Names[i]
                                       );
                        if (NT_SUCCESS(NtStatus)) {

                            InitializeObjectAttributes(
                                &ObjectAttributes,
                                &KeyName,
                                OBJ_CASE_INSENSITIVE,
                                SampKey,
                                NULL
                                );

                            SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

                            NtStatus = RtlpNtOpenKey(
                                           &TempHandle,
                                           (KEY_READ),
                                           &ObjectAttributes,
                                           0
                                           );
                            SampFreeUnicodeString( &KeyName );

                            if (NT_SUCCESS(NtStatus)) {

                                UnMappedCount  -= 1;
                                Use->Element[i] = SidTypeAlias;
                                KeyValueLength  = 0;
                                NtStatus = RtlpNtQueryValueKey(
                                               TempHandle,
                                               &RelativeIds->Element[i],
                                               NULL,
                                               &KeyValueLength,
                                               &IgnoreTimeStamp
                                               );

                                SampDumpRtlpNtQueryValueKey(&RelativeIds->Element[i],
                                                    NULL,
                                                    &KeyValueLength,
                                                    &IgnoreTimeStamp);

                                IgnoreStatus = NtClose( TempHandle );
                                ASSERT( NT_SUCCESS(IgnoreStatus) );
                                if (!NT_SUCCESS(NtStatus)) {
                                    goto unexpected_error;
                                }
                                ASSERT(KeyValueLength == 0);


                            } else {

                                //
                                // Search the user for a match
                                //

                                NtStatus = SampBuildAccountKeyName(
                                               SampUserObjectType,
                                               &KeyName,
                                               (PUNICODE_STRING)&Names[i]
                                               );
                                if (NT_SUCCESS(NtStatus)) {

                                    InitializeObjectAttributes(
                                        &ObjectAttributes,
                                        &KeyName,
                                        OBJ_CASE_INSENSITIVE,
                                        SampKey,
                                        NULL
                                        );


                                    SampDumpNtOpenKey((KEY_READ),
                                                      &ObjectAttributes,
                                                      0);

                                    NtStatus = RtlpNtOpenKey(
                                                   &TempHandle,
                                                   (KEY_READ),
                                                   &ObjectAttributes,
                                                   0
                                                   );
                                    SampFreeUnicodeString( &KeyName );

                                    if (NT_SUCCESS(NtStatus)) {

                                        UnMappedCount  -= 1;
                                        Use->Element[i] = SidTypeUser;
                                        KeyValueLength  = 0;
                                        NtStatus = RtlpNtQueryValueKey(
                                                       TempHandle,
                                                       &RelativeIds->Element[i],
                                                       NULL,
                                                       &KeyValueLength,
                                                       &IgnoreTimeStamp
                                                       );

                                        SampDumpRtlpNtQueryValueKey(&RelativeIds->Element[i],
                                                    NULL,
                                                    &KeyValueLength,
                                                    &IgnoreTimeStamp);

                                        IgnoreStatus = NtClose( TempHandle );
                                        ASSERT( NT_SUCCESS(IgnoreStatus) );
                                        if (!NT_SUCCESS(NtStatus)) {
                                            goto unexpected_error;
                                        }
                                        ASSERT(KeyValueLength == 0);

                                    } else if(NtStatus == STATUS_OBJECT_NAME_NOT_FOUND) {

                                        //
                                        // This is fine.  It just means that we don't
                                        // have an account with the name being looked up.
                                        //

                                        Use->Element[i]         = SidTypeUnknown;
                                        RelativeIds->Element[i] = 0;
                                        NtStatus = STATUS_SUCCESS;

                                    }

                                }
                            }
                        }
                    }
                }
            } // End of Registry Case


            if (!NT_SUCCESS(NtStatus) &&
                NtStatus != STATUS_INVALID_ACCOUNT_NAME) {
                goto unexpected_error;
            }

        } // end_for


        //
        // De-reference the object
        //

        IgnoreStatus = SampDeReferenceContext2( DomainContext, FALSE );

        if (UnMappedCount == Count) {
            NtStatus = STATUS_NONE_MAPPED;
        } else {
            if (UnMappedCount > 0) {
                NtStatus = STATUS_SOME_NOT_MAPPED;
            } else {
                NtStatus = STATUS_SUCCESS;
            }
        }
    }

    //
    // Free the read lock
    //

    SampMaybeReleaseReadLock(fLockAcquired);


    //
    // If the status isn't one of the expected return values,
    // then deallocate the return memory block
    //

    if ( ( NtStatus != STATUS_SUCCESS )         &&
         ( NtStatus != STATUS_SOME_NOT_MAPPED ) ) {

        Use->Count = 0;
        MIDL_user_free( Use->Element );
        Use->Element = NULL;
        RelativeIds->Count = 0;
        MIDL_user_free( RelativeIds->Element );
        RelativeIds->Element = NULL;
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);
    goto EndOfTrace;


unexpected_error:

    //
    // De-reference the object
    //

    IgnoreStatus = SampDeReferenceContext2( DomainContext, FALSE );

    //
    // Free the read lock
    //

    SampMaybeReleaseReadLock(fLockAcquired);


    //
    // Don't return any memory
    //

    Use->Count = 0;
    MIDL_user_free( Use->Element );
    Use->Element = NULL;  // Required so RPC doesn't try to free the element
    RelativeIds->Count = 0;
    MIDL_user_free( RelativeIds->Element );
    RelativeIds->Element = NULL;  // Required so RPC doesn't try to free the element

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

EndOfTrace:

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidLookupNamesInDomain
                   );

    return( NtStatus );

}



NTSTATUS SamrLookupIdsInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN ULONG Count,
    IN PULONG RelativeIds,
    OUT PSAMPR_RETURNED_USTRING_ARRAY Names,
    OUT PSAMPR_ULONG_ARRAY Use
    )


/*++

Routine Description:

    This API maps a number of relative IDs to their corresponding names.
    If a relative ID can not be mapped, a NULL value is placed in the slot
    for the UNICODE_STRING, and STATUS_SOME_NOT_MAPPED is returned.
    If none of the IDs can be mapped, then all array entries will contain
    NULL values and STATUS_NONE_MAPPED is returned.

    DOMAIN_LOOKUP access to the domain is needed to use this service.



Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    Count - Provides the number of relative IDs to translate.

    RelativeIds - Array of Count relative IDs to be mapped.

    Names - Receives a pointer to an allocated SAMPR_UNICODE_STRING_ARRAY.
        The nth entry in the array of names pointed to by this structure
        corresonds to the nth relative id looked up.
        Each name string buffer will be in a separate block of memory
        allocated by this routine.  When these names are no longer
        needed, the caller is responsible for deallocating each
        returned block (including the SAMPR_RETURNED_USTRING_ARRAY structure
        itself) using SamFreeMemory().

    Use - Receives a pointer to a SAMPR_ULONG_ARRAY structure.
        The nth entry in the array associated with this structure
        contains the SID_NAME_USE of the nth relative ID looked up.
        When this information is no longer needed, the caller is responsible
        for deallocating this memory using SamFreeMemory().

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The domain handle passed is invalid.

    STATUS_SOME_NOT_MAPPED - Some of the names provided could not be
        mapped.  This is a successful return.

    STATUS_NONE_MAPPED - No names could be mapped.  This is an error
        return.


--*/
{

    NTSTATUS                    NtStatus, IgnoreStatus;
    SAMP_OBJECT_TYPE            ObjectType;
    PSAMP_OBJECT                DomainContext;
    PSAMP_DEFINED_DOMAINS       Domain;
    SAMP_OBJECT_TYPE            FoundType;
    ULONG                       i, UnMappedCount;
    ULONG                       TotalLength;
    PSAMP_MEMORY                NextMemory;
    SAMP_MEMORY                 MemoryHead;
    PSID                        DomainSid;
    BOOLEAN                     fReadLockAcquired = FALSE;
    BOOLEAN                     LengthLimitReached = FALSE;
    ULONG                       DomainIndex=0;

    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrLookupIdsInDomain");

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidLookupIdsInDomain
                   );

    //
    // Used for tracking allocated memory so we can deallocate it on
    // error
    //

    MemoryHead.Memory = NULL;
    MemoryHead.Next   = NULL;


    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (RelativeIds != NULL);
    ASSERT (Use != NULL);
    ASSERT (Use->Element == NULL);
    ASSERT (Names != NULL);
    ASSERT (Names->Element == NULL);

    if (!((RelativeIds!=NULL)&&(Use!=NULL)
            && (Use->Element==NULL) && (Names!=NULL)
            && (Names->Element == NULL)))
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto EndOfTrace;
    }

    Use->Count     = 0;
    Names->Count   = 0;

    if (Count == 0) {
        NtStatus = STATUS_SUCCESS;
        goto EndOfTrace;
    }

    TotalLength = (Count*(sizeof(ULONG) + sizeof(UNICODE_STRING)));

    if ( TotalLength > SAMP_MAXIMUM_MEMORY_TO_USE ) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto EndOfTrace;
    }

    //
    // Allocate the return buffers
    //

    Use->Element = MIDL_user_allocate( Count * sizeof(ULONG) );
    if (Use->Element == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto EndOfTrace;
    }
    RtlZeroMemory(Use->Element, Count * sizeof(ULONG) );


    Names->Element = MIDL_user_allocate( Count * sizeof(UNICODE_STRING) );
    if (Names->Element == NULL) {
        MIDL_user_free( Use->Element);
        Use->Element = NULL;
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto EndOfTrace;
    }
    RtlZeroMemory(Names->Element, Count * sizeof(UNICODE_STRING) );


    Use->Count = Count;
    Names->Count = Count;


    //
    // Acquire the READ Lock if necessary
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;

    SampMaybeAcquireReadLock(DomainContext,
                             DOMAIN_OBJECT_DONT_ACQUIRELOCK_EVEN_IF_SHARED,
                             &fReadLockAcquired);


    //
    // Validate type of, and access to object.
    //


    NtStatus = SampLookupContext(
                   DomainContext,
                   DOMAIN_LOOKUP,
                   SampDomainObjectType,           // ExpectedType
                   &FoundType
                   );


    if ( !NT_SUCCESS( NtStatus ) ) {

        goto unexpected_error;

    }

    //
    // Grab the Domain SID. Note a given Domain's domain SID will never change
    // therefore safe to just refer to the pointer in SampDefinedDomains.
    //

    DomainSid = SampDefinedDomains[DomainContext->DomainIndex].Sid;
    DomainIndex = DomainContext->DomainIndex;

    //
    // We are done with the context; therefore de reference it
    //

    IgnoreStatus = SampDeReferenceContext2( DomainContext, FALSE );



    UnMappedCount = Count;
    for ( i=0; i<Count; i++) {

        //
        // allocate a block to track a name allocated for this mapping
        //

        NextMemory = MIDL_user_allocate( sizeof(SAMP_MEMORY) );
        if (NextMemory == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto unexpected_error;
        }


        //
        // Lookup the SID.
        //

        NtStatus = SampLookupAccountName(
                        DomainIndex,
                        RelativeIds[i],
                        (PUNICODE_STRING)&Names->Element[i],
                        &ObjectType
                        );
        

        if (!NT_SUCCESS(NtStatus)) {
            //
            // Free the memory that we just allocated.
            //

            MIDL_user_free(NextMemory);
            NextMemory = NULL;
            goto unexpected_error;
        }


        switch (ObjectType) {

        case SampUserObjectType:
        case SampGroupObjectType:
        case SampAliasObjectType:

            //
            // We found the account
            //

            UnMappedCount -= 1;

            NextMemory->Memory = (PVOID)&Names->Element[i].Buffer;
            NextMemory->Next = MemoryHead.Next;
            MemoryHead.Next = NextMemory;

            switch (ObjectType) {

            case SampUserObjectType:
                Use->Element[i] = SidTypeUser;
                break;

            case SampGroupObjectType:
                Use->Element[i] = SidTypeGroup;
                break;

            case SampAliasObjectType:
                Use->Element[i] = SidTypeAlias;
                break;
            }

            break;


        case SampUnknownObjectType:

            //
            // NT4 and earlier versions of samsrv.dll used to be able
            // to perform a check whether the SID was a deleted account
            // or unknown. They did this by assuming that the RID range
            // was continuously allocated and therefore a RID value below
            // the domain RID high water mark would represent a deleted
            // account. In NT5 RID allocation is non monotonic hence this
            // assumption is no longer correct. We therefore simply return
            // SidTypeUnknown

            Use->Element[i]                 = SidTypeUnknown;


            Names->Element[i].Length        = 0;
            Names->Element[i].MaximumLength = 0;
            Names->Element[i].Buffer        = NULL;
            MIDL_user_free( NextMemory );

            break;

        default:

            ASSERT(FALSE); // unexpected object type returned
            break;
        }

    } // end_for




    if (UnMappedCount == Count) {
        NtStatus = STATUS_NONE_MAPPED;
    } else {
        if (UnMappedCount > 0) {
            NtStatus = STATUS_SOME_NOT_MAPPED;
        } else {
            NtStatus = STATUS_SUCCESS;
        }
    }

    //
    // Free the read lock
    //

    SampMaybeReleaseReadLock(fReadLockAcquired);


    //
    // Free all the memory tracking blocks
    //

    NextMemory = MemoryHead.Next;
    while ( NextMemory != NULL ) {
        MemoryHead.Next = NextMemory->Next;
        MIDL_user_free( NextMemory );
        NextMemory = MemoryHead.Next;
    }


    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);
    goto EndOfTrace;


unexpected_error:



    //
    // Free the read lock
    //


    SampMaybeReleaseReadLock(fReadLockAcquired);



    //
    // Free all the memory tracking blocks - and the memory they point to.
    //

    Use->Count = 0;
    Names->Count = 0;
    MIDL_user_free( Use->Element );
    Use->Element = NULL;
    MIDL_user_free( Names->Element );
    Names->Element = NULL;
    NextMemory = MemoryHead.Next;
    while ( NextMemory != NULL ) {
        if (NextMemory->Memory != NULL) {
            MIDL_user_free( NextMemory->Memory );
        }
        MemoryHead.Next = NextMemory->Next;
        MIDL_user_free( NextMemory );
        NextMemory = MemoryHead.Next;
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);



EndOfTrace:

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidLookupIdsInDomain
                   );

    return( NtStatus );
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private services                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SampOpenDomainKey(
    IN PSAMP_OBJECT DomainContext,
    IN PRPC_SID DomainId,
    IN BOOLEAN SetTransactionDomain
    )

/*++

Routine Description:

    This service attempts to open the root registry key of the domain with
    the specified SID. The root name and key handle are put in the
    passed domain context.


    If successful, and the domain key is opened, then the opened domain is
    established as the transaction domain (using SampSetTransactionDomain()).

    THIS SERVICE MUST BE CALLED WITH THE SampLock() HELD FOR READ OR
    WRITE ACCESS.

Arguments:

    DomainContext - Context in which root namd and handle are stored.

    DomainId - Specifies the SID of the domain to open.

Return Value:

    STATUS_SUCCESS - The domain has been openned.

    STATUS_NO_SUCH_DOMAIN - The domain object could not be found.

    STATUS_INSUFFICIENT_RESOURCES - The domain object could not be openned
       due to the lack of some resource (probably memory).

    STATUS_INVALID_SID - The sid provided as the domain identifier is not
        a valid SID structure.

    Other errors that might be returned are values returned by:

--*/
{
    NTSTATUS    NtStatus;
    ULONG       i;
    ULONG       DomainStart;



    SAMTRACE("SampOpenDomainKey");

    //
    // Get the start domain in the defined domains structure.
    //

    DomainStart = SampDsGetPrimaryDomainStart();

    //
    // Make sure the SID provided is legitimate...
    //

    if ( !RtlValidSid(DomainId)) {
        NtStatus = STATUS_INVALID_SID;
    } else {

        //
        // Set our default completion status
        //

        NtStatus = STATUS_NO_SUCH_DOMAIN;


        //
        // Search the list of defined domains for a match.
        //

        //
        // Use the Variable SampDomainStart. This is used to offset the
        // defined domains structure by 2, when the DS domain intializes
        //

        for (i = DomainStart; i<SampDefinedDomainsCount; i++ ) {

             if (RtlEqualSid( DomainId, SampDefinedDomains[i].Sid)) {


                 if (IsDsObject(SampDefinedDomains[i].Context))
                 {
                     //
                     // Copy Object Flags and Object Name in DS
                     //
                     //

                     DomainContext->ObjectNameInDs =
                                    SampDefinedDomains[i].Context->ObjectNameInDs;
                     DomainContext->ObjectFlags =
                                    SampDefinedDomains[i].Context->ObjectFlags;
                 }
                 else
                 {
                     //
                     // Copy the found name and handle into the context
                     // Note we reference the key handle in the defined_domains
                     // structure directly since it is not closed
                     // when the context is deleted.
                     //

                     DomainContext->RootKey  = SampDefinedDomains[i].Context->RootKey;
                     DomainContext->RootName = SampDefinedDomains[i].Context->RootName;
                 }

                 DomainContext->DomainIndex = i;

                 //
                 // Set the transaction domain to the one found
                 //

                if (SetTransactionDomain) {
                    SampSetTransactionDomain( i );
                }


                 NtStatus = STATUS_SUCCESS;
                 break; // out of for
             }
        }
    }


    return(NtStatus);
}



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Routines available to other SAM modules                                   //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


BOOLEAN
SampInitializeDomainObject( VOID )

/*++

Routine Description:

    This service performs initialization functions related to the Domain
    object class.

    This involves:

        1) Openning the DOMAINS registry key.

        2) Obtaining the name of each domain (builtin and account)
           and opening that domain.

Arguments:

    None.

Return Value:

    TRUE - Indicates initialization was performed successfully.

    FALSE - Indicates initialization was not performed successfully.


--*/

{

    NTSTATUS        NtStatus;
    ULONG           DefinedDomainsSize, i, j, k;
    BOOLEAN         ReturnStatus = TRUE;


    SAMTRACE("SampInitializeDomainObject");

    // Open all domains and keep information about each in memory for some-
    // what fast processing and less complicated code strewn throughout.

    // SAM's domain array, SampDefinedDomains, is initially set up with two
    // elements: the registry-based Builtin and Account domains. In the case
    // of a workstation or server, these elements contain the account infor-
    // mation for those domains. In the case of a domain controller, these
    // two elements contain the "crash-recovery" accounts, which are also
    // persistently stored in the registry instead of the DS. It is assumed
    // that the crash will prevent the DS from starting or properly running,
    // hence the need to store the data in the registry.
    //
    // The crash-recovery accounts are always setup on a DC. Disabling this
    // initialization may lead to problems later in the domain initialization
    // sequence.

    SampDefinedDomainsCount = 2;

    if ( NtProductLanManNt == SampProductType ) {

        //
        // We are going to need another 2 later when initializing the
        // ds domains,  so allocate now
        //
        DefinedDomainsSize = (SampDefinedDomainsCount + 2) * sizeof(SAMP_DEFINED_DOMAINS);

    } else {

        DefinedDomainsSize = SampDefinedDomainsCount * sizeof(SAMP_DEFINED_DOMAINS);

    }

    SampDefinedDomains = MIDL_user_allocate( DefinedDomainsSize );
    if (NULL==SampDefinedDomains)
    {
       return(FALSE);
    }

    //
    // Zero out the defined domains field, so that any fields that are important for
    // DS mode only do not remain uninitialized
    //

    RtlZeroMemory(SampDefinedDomains,DefinedDomainsSize);

    //
    // Get the BUILTIN and ACCOUNT domain information from the LSA
    //

    if (NtProductLanManNt == SampProductType)
    {
        // BUG: Need to call SampSetDcDomainPolicy for multiple hosted Builtin domains.

        // NtStatus = SampSetDcDomainPolicy();

        NtStatus = SampSetDomainPolicy();
    }
    else
    {
        NtStatus = SampSetDomainPolicy();
    }

    if (!NT_SUCCESS(NtStatus)) {
        return(FALSE);
    }

    //
    // Now prepare each of these domains
    //

    i = 0;      // Index into DefinedDomains array

    // BUG: Need to do both so that Account domain reg key is set for logon.

    // If the domain reg key is not set, MsvpSamValidate will fault during the
    // logon sequence.

    k = SampDefinedDomainsCount;

    for (j=0; j<k; j++) {

        NtStatus = SampInitializeSingleDomain( i );

        if (NT_SUCCESS(NtStatus)) {

            i++;

        } else {

            //
            // If a domain didn't initialize, shift the last
            // domain into its slot (assuming this isn't the last
            // domain).  Don't try to free the name buffers on error.
            // The builtin domain's name is not in an allocated buffer.
            //
            //

            if (i != (SampDefinedDomainsCount-1)) {

                SampDefinedDomains[i] =
                    SampDefinedDomains[SampDefinedDomainsCount-1];

                SampDefinedDomains[SampDefinedDomainsCount-1].ExternalName.Buffer = NULL;
                SampDefinedDomains[SampDefinedDomainsCount-1].InternalName.Buffer = NULL;
                SampDefinedDomains[SampDefinedDomainsCount-1].Sid  = NULL;
            }

            //
            // And reduce the number of defined domains we have
            //

            SampDefinedDomainsCount --;
        }
    }

    return(TRUE);

}


NTSTATUS
SampInitializeSingleDomain(
    ULONG Index
    )

/*++

Routine Description:

    This service opens a single domain that is expected to be in the
    SAM database.

    The name and SID of the DefinedDomains array entry are expected
    to be filled in by the caller.

Arguments:

    Index - An index into the DefinedDomains array.  This array
        contains information about the domain being openned,
        including its name.  The remainder of this array entry
        is filled in by this routine.


Return Value:



--*/
{
    NTSTATUS        NtStatus, IgnoreStatus;
    PSAMP_OBJECT    DomainContext;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PSID            Sid;
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN V1aFixed;

#if DBG
    SID *Sid1, *Sid2;
#endif

    SAMTRACE("SampInitializeSingleDomain");


    //
    // Initialize everything we might have to cleanup on error
    //

    DomainContext = NULL;


    //
    // Create a context for this domain object.
    // We'll keep this context around until SAM is shutdown
    // We store the context handle in the defined_domains structure.
    //

    DomainContext = SampCreateContext( SampDomainObjectType, Index, TRUE);

    if ( DomainContext == NULL ) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto error_cleanup;
    }

    DomainContext->DomainIndex = Index;

    //
    // Create the name of the root key name of this domain in the registry.
    //

    NtStatus = SampBuildDomainKeyName(
                   &DomainContext->RootName,
                   &SampDefinedDomains[Index].InternalName
                   );

    if (!NT_SUCCESS(NtStatus)) {
        DomainContext->RootName.Buffer = NULL;
        goto error_cleanup;
    }


    //
    // Open the root key and store the handle in the context
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &DomainContext->RootName,
        OBJ_CASE_INSENSITIVE,
        SampKey,
        NULL
        );

    SampDumpNtOpenKey((KEY_READ | KEY_WRITE), &ObjectAttributes, 0);

    NtStatus = RtlpNtOpenKey(
                   &DomainContext->RootKey,
                   (KEY_READ | KEY_WRITE),
                   &ObjectAttributes,
                   0
                   );

    if (!NT_SUCCESS(NtStatus)) {
#if DBG
        DbgPrint("SAMSS: Failed to open %Z Domain.\n",
             &SampDefinedDomains[Index].ExternalName);
#endif //DBG
        DomainContext->RootKey = INVALID_HANDLE_VALUE;
        return(NtStatus);
    }


    //
    // Get the fixed length data for the domain and store in
    // the defined_domain structure
    //

    NtStatus = SampGetFixedAttributes(
                   DomainContext,
                   FALSE, // Don't make copy
                   (PVOID *)&V1aFixed
                   );

    if (!NT_SUCCESS(NtStatus)) {
#if DBG
        DbgPrint("SAMSS: Failed to get fixed attributes for %Z Domain.\n",
            &SampDefinedDomains[Index].ExternalName);
#endif //DBG

        goto error_cleanup;
    }


    RtlMoveMemory(
        &SampDefinedDomains[Index].UnmodifiedFixed,
        V1aFixed,
        sizeof(*V1aFixed)
        );

    RtlCopyMemory(
        &SampDefinedDomains[Index].CurrentFixed,
        &SampDefinedDomains[Index].UnmodifiedFixed,
        sizeof(SampDefinedDomains[Index].UnmodifiedFixed)
        );


    //
    // Marked the Fixed Length Data as Valid
    //

    SampDefinedDomains[Index].FixedValid = TRUE;

    //
    // Mark the server role information in the defined domain structure
    //

    SampDefinedDomains[Index].ServerRole =
           SampDefinedDomains[Index].UnmodifiedFixed.ServerRole;

    //
    //
    // Get the sid attribute of the domain
    //

    NtStatus = SampGetSidAttribute(
                   DomainContext,
                   SAMP_DOMAIN_SID,
                   FALSE,
                   &Sid
                   );

    if (!NT_SUCCESS(NtStatus)) {
#if DBG
        DbgPrint("SAMSS: Failed to get SID attribute for %Z Domain.\n",
            &SampDefinedDomains[Index].ExternalName);
#endif //DBG
        goto error_cleanup;
    }


    //
    // Make sure this sid agrees with the one we were passed
    //

    if (RtlEqualSid(Sid, SampDefinedDomains[Index].Sid) != TRUE) {

        //
        // Ok, the LSA is out of sorts.  We've got to set it straight
        //

        //
        // Note: SampDefinedDomains[Index].Sid points to memory allocated
        // from the LSA which is never freed.  We could theoretically free
        // it now, but the struct from which it was packaged is long gone.
        //
        // Sid is a copy of the sid from the domain context which is never
        // released either.
        //
        SampDefinedDomains[Index].Sid = Sid;

        NtStatus = SampSetAccountDomainPolicy( &SampDefinedDomains[Index].ExternalName,
                                               SampDefinedDomains[Index].Sid );

        if ( !NT_SUCCESS( NtStatus ) ) {

            //
            // This is fatal
            //
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                        "SAMSS: SampSetAccountDomainPolicy failed with 0x%x\n",
                        NtStatus));

            NtStatus = STATUS_INVALID_ID_AUTHORITY;
            goto error_cleanup;
        }

    }


    //
    // Build security descriptors for use in user and group account creations
    // in this domain.
    //

    NtStatus = SampInitializeDomainDescriptors( Index );
    if (!NT_SUCCESS(NtStatus)) {
        goto error_cleanup;
    }

    //
    // Intialize the cached display information
    //

    // MURLIS 6/11/96 -- Store the Context handle in the
    // defined domains structure, before calling Initialize Display
    // information as Enumerate Account Names will need this information
    // to make the decision wether the domain is in the DS or in
    // Registry.

    SampDefinedDomains[Index].Context = DomainContext;

    NtStatus = SampInitializeDisplayInformation( Index );



    if (!NT_SUCCESS(NtStatus)) {

        //
        // NULL out the context handle in the defined_domain structure
        //

        SampDefinedDomains[Index].Context = NULL;
        goto error_cleanup;
    }

    if (SampDefinedDomains[Index].IsBuiltinDomain) {
        SampDefinedDomains[Index].IsExtendedSidDomain = FALSE;
    } else {
        //
        // Note -- when the extended SID support is complete, this will be
        // replaced with domain wide state, not a registry setting
        //
        SampDefinedDomains[Index].IsExtendedSidDomain = SampIsExtendedSidModeEmulated(NULL);
    }


    return(NtStatus);


error_cleanup:

#if DBG
    DbgPrint("       Status is 0x%lx \n", NtStatus);
#endif //DBG


    if (DomainContext != 0) {

        SampFreeUnicodeString(&DomainContext->RootName);

        if (DomainContext->RootKey != INVALID_HANDLE_VALUE) {

            IgnoreStatus = NtClose(DomainContext->RootKey);
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }
    }

    return(NtStatus);

}



NTSTATUS
SampSetDomainPolicy(
    )
/*++


Routine Description:

    This routine sets the names and SIDs for the builtin and account domains.
    The builtin account domain has a well known name and SID.
    The account domain has these stored in the Policy database.


    It places the information for the builtin domain in
    SampDefinedDomains[0] and the information for the account
    domain in SampDefinedDomains[1].


Arguments:

    None.

Return Value:



--*/
{
    NTSTATUS NtStatus;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo;
    SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;

    SAMTRACE("SampSetDomainPolicy");

    //
    // Builtin domain - Well-known External Name and SID
    //                  Constant Internal Name

    RtlInitUnicodeString( &SampDefinedDomains[0].InternalName, L"Builtin");
    RtlInitUnicodeString( &SampDefinedDomains[0].ExternalName, L"Builtin");

    SampDefinedDomains[0].Sid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 1 ));
    ASSERT( SampDefinedDomains[0].Sid != NULL );
    if (NULL==SampDefinedDomains[0].Sid)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
    RtlInitializeSid(
     SampDefinedDomains[0].Sid,   &BuiltinAuthority, 1 );
    *(RtlSubAuthoritySid( SampDefinedDomains[0].Sid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;

    SampDefinedDomains[0].IsBuiltinDomain = TRUE;
 
    //
    // Account domain - Configurable External Name and Sid
    //                  The External Name is held in the LSA Policy
    //                  Database.  It is equal to the Domain Name for DC's
    //                  or the Computer Name for Workstations.
    //                  Constant Internal Name
    //

    NtStatus = SampGetAccountDomainInfo( &PolicyAccountDomainInfo );

    if (NT_SUCCESS(NtStatus)) {

        ULONG len = DNS_MAX_NAME_BUFFER_LENGTH+1;
        WCHAR tmpBuffer[DNS_MAX_NAME_BUFFER_LENGTH+1];
        ULONG BufLength = 0;

        //
        // copy account Domain SID
        //
        BufLength = RtlLengthSid( PolicyAccountDomainInfo->DomainSid );
        SampDefinedDomains[1].Sid = RtlAllocateHeap( RtlProcessHeap(), 0, BufLength );
        if (NULL == SampDefinedDomains[1].Sid)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }
        RtlZeroMemory(SampDefinedDomains[1].Sid, BufLength);
        RtlCopyMemory(SampDefinedDomains[1].Sid, PolicyAccountDomainInfo->DomainSid, BufLength);
        
        //
        // copy Account Domain Name 
        // 
        BufLength = PolicyAccountDomainInfo->DomainName.MaximumLength;
        SampDefinedDomains[1].ExternalName.Buffer = RtlAllocateHeap(RtlProcessHeap(), 0, BufLength );
        if (NULL == SampDefinedDomains[1].ExternalName.Buffer)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }
        RtlZeroMemory(SampDefinedDomains[1].ExternalName.Buffer, BufLength);
        RtlCopyMemory(SampDefinedDomains[1].ExternalName.Buffer, 
                      PolicyAccountDomainInfo->DomainName.Buffer,
                      PolicyAccountDomainInfo->DomainName.Length
                      );
        SampDefinedDomains[1].ExternalName.Length = PolicyAccountDomainInfo->DomainName.Length;
        SampDefinedDomains[1].ExternalName.MaximumLength = PolicyAccountDomainInfo->DomainName.MaximumLength;
        

        RtlInitUnicodeString( &SampDefinedDomains[1].InternalName, L"Account");

        //
        // Set the DNS domain name to be as returned by GetComputerNameEx
        //

        if ( !GetComputerNameExW(
                    ComputerNameDnsFullyQualified,
                    tmpBuffer,
                    &len) ) 
        {

            len = 0; // for the NULL terminator
            tmpBuffer[0] = L'\0';
        }

        // Add 1 for the NULL terminator
        len++;

        SampDefinedDomains[1].DnsDomainName.Buffer 
                       = RtlAllocateHeap(RtlProcessHeap(), 0, len * sizeof(WCHAR));
        if (NULL==SampDefinedDomains[1].DnsDomainName.Buffer)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }


        RtlCopyMemory(SampDefinedDomains[1].DnsDomainName.Buffer,
                                      tmpBuffer,len*sizeof(WCHAR));
        SampDefinedDomains[1].DnsDomainName.Length = 
                                     (USHORT) (len -1) * sizeof(WCHAR);
        SampDefinedDomains[1].DnsDomainName.MaximumLength = 
                                     (USHORT) (len -1) * sizeof(WCHAR);
        


    } 

    SampDefinedDomains[1].IsBuiltinDomain = FALSE;

Error:

    if (NULL != PolicyAccountDomainInfo)
    {
        LsaFreeMemory( PolicyAccountDomainInfo );
    }

    return(NtStatus);;
}


NTSTATUS
SampSetDcDomainPolicy(
    )

/*++

Routine Description:

    This routine sets the names and SIDs for the builtin domain. The builtin
    account domain has a well known name and SID. The account domain has these
    stored in the Policy database.

    It places the information for the builtin domain in SampDefinedDomains[0].

Arguments:

    None.

Return Value:

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo;
    SID_IDENTIFIER_AUTHORITY BuiltinAuthority = SECURITY_NT_AUTHORITY;

    // BUG: This routine assumes the same Builtin domain for each hosted dom.

    // The purpose of this routine is to separate out the Builtin domain
    // policy initialization from the Account domain initialization. Because
    // each hosted domain will have a different Builtin policy, this routine
    // should be called from SampDsInitializeDomainObjects.

    SAMTRACE("SampSetDcDomainPolicy");

    //
    // Builtin domain - Well-known External Name and SID
    //                  Constant Internal Name

    RtlInitUnicodeString( &SampDefinedDomains[0].InternalName, L"Builtin");
    RtlInitUnicodeString( &SampDefinedDomains[0].ExternalName, L"Builtin");

    SampDefinedDomains[0].Sid  = RtlAllocateHeap(RtlProcessHeap(), 0,RtlLengthRequiredSid( 1 ));
    ASSERT( SampDefinedDomains[0].Sid != NULL );
    if (NULL==SampDefinedDomains[0].Sid)
    {
       return(STATUS_INSUFFICIENT_RESOURCES);
    }
    RtlInitializeSid(
     SampDefinedDomains[0].Sid,   &BuiltinAuthority, 1 );
    *(RtlSubAuthoritySid( SampDefinedDomains[0].Sid,  0 )) = SECURITY_BUILTIN_DOMAIN_RID;

    return(NtStatus);;
}


NTSTATUS
SampReInitializeSingleDomain(
    ULONG Index
    )

/*++

Routine Description:

    This service reinitializes a single domain after a registry hive refresh.

Arguments:

    Index - An index into the DefinedDomains array.

Return Value:

    STATUS_SUCCESS : The domain was re-initialized successfully.

    Other failure codes.

--*/
{
    NTSTATUS        NtStatus;
    PSAMP_DEFINED_DOMAINS Domain;
    PSAMP_OBJECT    DomainContext;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN V1aFixed;

    SAMTRACE("SampReinitializeSingleDomain");

    ASSERT(SampCurrentThreadOwnsLock());

    Domain = &SampDefinedDomains[Index];

    //
    // Create a context for this domain object.
    // We'll keep this context around until SAM is shutdown
    // We store the context handle in the defined_domains structure.
    //

    DomainContext = SampCreateContext( SampDomainObjectType, Index, TRUE );

    if ( DomainContext == NULL ) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto error_cleanup;
    }

    DomainContext->DomainIndex = Index;

    //
    // Create the name of the root key name of this domain in the registry.
    //

    NtStatus = SampBuildDomainKeyName(
                   &DomainContext->RootName,
                   &SampDefinedDomains[Index].InternalName
                   );

    if (!NT_SUCCESS(NtStatus)) {
        RtlInitUnicodeString(&DomainContext->RootName, NULL);
        goto error_cleanup;
    }


    //
    // Open the root key and store the handle in the context
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        &DomainContext->RootName,
        OBJ_CASE_INSENSITIVE,
        SampKey,
        NULL
        );

    SampDumpNtOpenKey((KEY_READ | KEY_WRITE), &ObjectAttributes, 0);

    NtStatus = RtlpNtOpenKey(
                   &DomainContext->RootKey,
                   (KEY_READ | KEY_WRITE),
                   &ObjectAttributes,
                   0
                   );

    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: Failed to open %Z Domain.\n",
                   &SampDefinedDomains[Index].ExternalName));

        DomainContext->RootKey = INVALID_HANDLE_VALUE;
        goto error_cleanup;
    }

    KdPrintEx((DPFLTR_SAMSS_ID,
               DPFLTR_INFO_LEVEL,
               "SAMSS: SAM New domain %d key : 0x%lx\n",
               Index,
               DomainContext->RootKey));

    //
    // Get the fixed length data for the domain and store in
    // the defined_domain structure
    //

    NtStatus = SampGetFixedAttributes(
                   DomainContext,
                   FALSE, // Don't make copy
                   (PVOID *)&V1aFixed
                   );

    if (!NT_SUCCESS(NtStatus)) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SAMSS: Failed to get fixed attributes for %Z Domain.\n",
                   &SampDefinedDomains[Index].ExternalName));

        goto error_cleanup;
    }

    //
    // Copy the fixed-length data into our in-memory data area for this domain.
    //

    RtlMoveMemory(
        &SampDefinedDomains[Index].UnmodifiedFixed,
        V1aFixed,
        sizeof(*V1aFixed)
        );


    //
    // Delete any cached display information
    //

    {
        ULONG OldTransactionDomainIndex = SampTransactionDomainIndex;
        SampTransactionDomainIndexGlobal = Index;

        NtStatus = SampMarkDisplayInformationInvalid(SampUserObjectType);
        NtStatus = SampMarkDisplayInformationInvalid(SampGroupObjectType);

        SampTransactionDomainIndexGlobal = OldTransactionDomainIndex;
    }



    if (NT_SUCCESS(NtStatus)) {

        //
        // Store the context handle in the defined_domain structure
        //

        SampDeleteContext(Domain->Context);
        Domain->Context = DomainContext;

    }


    return(NtStatus);


error_cleanup:

    KdPrintEx((DPFLTR_SAMSS_ID,
               DPFLTR_INFO_LEVEL,
               "       Status is 0x%lx \n",
               NtStatus));

    if (DomainContext != NULL) {
        SampDeleteContext(DomainContext);
    }

    return(NtStatus);

}


NTSTATUS
SampCollisionError(
    IN SAMP_OBJECT_TYPE ObjectType
    )

/*++

Routine Description:

    This routine is called by SamICreateAccountByRid when there is a
    name or RID collision.  It accepts the type of account which caused
    the collision, and returns the appropriate error status.

Arguments:

    ObjectType - The type of account that has the same Rid or Name (but
        not both) as the account that was to be created.

Return Value:

    STATUS_USER_EXISTS - An object with the specified name could not be
        created because a User account with that name or RID already exists.

    STATUS_GROUP_EXISTS - An object with the specified name could not be
        created because a Group account with that name or RID already exists.

    STATUS_ALIAS_EXISTS - An object with the specified name could not be
        created because an Alias account with that name or RID already exists.

--*/
{

    SAMTRACE("SampCollisionError");

    //
    // Name collision.  Return offending RID and appropriate
    // error code.
    //

    switch ( ObjectType ) {

        case SampAliasObjectType: {

            return STATUS_ALIAS_EXISTS;
        }

        case SampGroupObjectType: {

            return STATUS_GROUP_EXISTS;
        }

        case SampUserObjectType: {

            return STATUS_USER_EXISTS;
        }
    }
    return STATUS_USER_EXISTS;
}



NTSTATUS
SamICreateAccountByRid(
    IN SAMPR_HANDLE DomainHandle,
    IN SAM_ACCOUNT_TYPE AccountType,
    IN ULONG RelativeId,
    IN PRPC_UNICODE_STRING AccountName,
    IN ACCESS_MASK DesiredAccess,
    OUT SAMPR_HANDLE *AccountHandle,
    OUT ULONG *ConflictingAccountRid
    )

/*++

Routine Description:

    This service creates a user, group or alias account with a specific
    RID value.


Arguments:

    DomainHandle - A handle to an open domain.

    AccountType - Specifies which type of account is being created.

    RelativeId - The relative ID to be assigned to the account.  If an
        account of the specified type and specified RID value and
        specified name already exists, then it will be opened.  If an
        account exists with any of this information in conflict, then an
        error will be returned indicating what the problem is.

    AccountName - The name to assign to the account.  If an account of
        the specified type and specified RID value and specified name
        already exists, then it will be opened.  If an account exists with
        any of this information in conflict, then an error will be returned
        indicating what the problem is.

    DesiredAccess - Specifies the accesses desired to the account object.

    AccountHandle - Recieves a handle to the account object.

    ConflictingAccountRid - If another account with the same name or RID
        prevents this account from being created, then this will receive
        the RID of the conflicting account (in the case of conflicting
        RIDs, this means that we return the RID that was passed in).
        The error value indicates the type of the account.


Return Value:

    STATUS_SUCCESS - The object has been successfully opened or created.

    STATUS_OBJECT_TYPE_MISMATCH - The specified object type did not match
        the type of the object found with the specified RID.

    STATUS_USER_EXISTS - An object with the specified name could not be
        created because a User account with that name already exists.

    STATUS_GROUP_EXISTS - An object with the specified name could not be
        created because a Group account with that name already exists.

    STATUS_ALIAS_EXISTS - An object with the specified name could not be
        created because an Alias account with that name already exists.


--*/
{
    PSAMP_OBJECT            DomainContext;
    SAMP_OBJECT_TYPE        FoundType;
    UNICODE_STRING          KeyName;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    SAM_ACCOUNT_TYPE        ObjectType, SecondObjectType, ThirdObjectType;
    SID_NAME_USE            SidNameUse;
    HANDLE                  KeyHandle;
    NTSTATUS                NtStatus, IgnoreStatus,
                            NotFoundStatus, FoundButWrongStatus;
    ACCESS_MASK             GrantedAccess;
    ULONG                   LocalGroupType =  GROUP_TYPE_SECURITY_ENABLED|GROUP_TYPE_RESOURCE_GROUP;
    ULONG                   GlobalGroupType =  GROUP_TYPE_SECURITY_ENABLED|GROUP_TYPE_ACCOUNT_GROUP;

    SAMTRACE("SamICreateAccountByRid");

    ASSERT( RelativeId != 0 );

    switch ( AccountType ) {

        case SamObjectUser: {

            ObjectType = SampUserObjectType;
            SecondObjectType = SampAliasObjectType;
            ThirdObjectType = SampGroupObjectType;
            NotFoundStatus = STATUS_NO_SUCH_USER;
            FoundButWrongStatus = STATUS_USER_EXISTS;
            break;
        }

        case SamObjectGroup: {

            ObjectType = SampGroupObjectType;
            SecondObjectType = SampAliasObjectType;
            ThirdObjectType = SampUserObjectType;
            NotFoundStatus = STATUS_NO_SUCH_GROUP;
            FoundButWrongStatus = STATUS_GROUP_EXISTS;
            break;
        }

        case SamObjectAlias: {

            ObjectType = SampAliasObjectType;
            SecondObjectType = SampGroupObjectType;
            ThirdObjectType = SampUserObjectType;
            NotFoundStatus = STATUS_NO_SUCH_ALIAS;
            FoundButWrongStatus = STATUS_ALIAS_EXISTS;
            break;
        }

        default: {

            return( STATUS_INVALID_PARAMETER );
        }
    }

    //
    // See if the account specified already exists.
    //

    NtStatus = SampAcquireWriteLock();

    if ( !NT_SUCCESS( NtStatus ) ) {

        return( NtStatus );
    }

    //
    // Validate type of, and access to object.
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;
    NtStatus = SampLookupContext(
                   DomainContext,
                   0,
                   SampDomainObjectType,           // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampLookupAccountRid(
                       DomainContext,
                       ObjectType,
                       (PUNICODE_STRING)AccountName,
                       NotFoundStatus,
                       ConflictingAccountRid,
                       &SidNameUse
                       );

        if ( NT_SUCCESS( NtStatus ) ) {

            //
            // The NAME exists; now we have to check the RID.
            //

            if ( (*ConflictingAccountRid) == RelativeId ) {

                //
                // The correct account already exists, so just open it.
                //

                SampSetTransactionWithinDomain(FALSE);

                NtStatus = SampOpenAccount(
                               ObjectType,
                               DomainHandle,
                               DesiredAccess,
                               RelativeId,
                               TRUE,    //we already have the lock
                               AccountHandle
                               );

                 goto Done;

            } else {

                //
                // An account with the given name, but a different RID, exists.
                // Return error.
                //

                NtStatus = FoundButWrongStatus;
            }

        } else {

            if ( NtStatus == NotFoundStatus ) {

                //
                // Account doesn't exist, that's good
                //

                NtStatus = STATUS_SUCCESS;
            }
        }

        if (NT_SUCCESS(NtStatus)) {

            //
            // Check for name collision with 2nd object type
            //

            NtStatus = SampLookupAccountRid(
                           DomainContext,
                           SecondObjectType,
                           (PUNICODE_STRING)AccountName,
                           STATUS_UNSUCCESSFUL,
                           ConflictingAccountRid,
                           &SidNameUse
                           );

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // The name was found; return an error.
                //

                NtStatus = SampCollisionError( SecondObjectType );

            } else {

                if ( NtStatus == STATUS_UNSUCCESSFUL ) {

                    //
                    // Account doesn't exist, that's good
                    //

                    NtStatus = STATUS_SUCCESS;
                }
            }
        }


        if (NT_SUCCESS(NtStatus)) {

            //
            // Check for name collision with 3rd object type
            //

            NtStatus = SampLookupAccountRid(
                           DomainContext,
                           ThirdObjectType,
                           (PUNICODE_STRING)AccountName,
                           STATUS_UNSUCCESSFUL,
                           ConflictingAccountRid,
                           &SidNameUse
                           );

            if ( NT_SUCCESS( NtStatus ) ) {

                NtStatus = SampCollisionError( ThirdObjectType );

            } else {

                if ( NtStatus == STATUS_UNSUCCESSFUL ) {

                    //
                    // Account doesn't exist, that's good
                    //

                    NtStatus = STATUS_SUCCESS;
                }
            }
        }


        if (NT_SUCCESS(NtStatus))
        {
            SAMP_OBJECT_TYPE FoundObjectType;


            //
            // We didn't find the name as an alias, group or user.
            // Now, check to see if the RID is already in use.
            //

            NtStatus = SampLookupAccountName(
                                DomainContext->DomainIndex,
                                RelativeId,
                                NULL,
                                &FoundObjectType
                                );
            if (NT_SUCCESS(NtStatus))
            {
                if (SampUnknownObjectType!=FoundObjectType)
                {
                    NtStatus = SampCollisionError(FoundObjectType);
                    *ConflictingAccountRid = RelativeId;
                }
            }

        }


        if (NT_SUCCESS(NtStatus)) {

            //
            // We haven't found a conflicting account, so go ahead
            // and create this one with the name and RID specified.
            //

            switch ( AccountType ) {

                case SamObjectUser: {

                    SampSetTransactionWithinDomain(FALSE);

                    NtStatus = SampCreateUserInDomain(
                                   DomainHandle,
                                   AccountName,
                                   USER_NORMAL_ACCOUNT,
                                   DesiredAccess,
                                   TRUE,
                                   FALSE,       // not loopback client
                                   AccountHandle,
                                   &GrantedAccess,
                                   &RelativeId
                                   );

                    break;
                }

                case SamObjectGroup: {

                    SampSetTransactionWithinDomain(FALSE);

                    NtStatus = SampCreateGroupInDomain(
                                   DomainHandle,
                                   AccountName,
                                   DesiredAccess,
                                   TRUE,
                                   FALSE, // not loopback client
                                   GlobalGroupType,
                                   AccountHandle,
                                   &RelativeId
                                   );
                    break;
                }

                case SamObjectAlias: {

                    SampSetTransactionWithinDomain(FALSE);

                    NtStatus = SampCreateAliasInDomain(
                                   DomainHandle,
                                   AccountName,
                                   DesiredAccess,
                                   TRUE,
                                   FALSE, // not loopback client
                                   LocalGroupType,
                                   AccountHandle,
                                   &RelativeId
                                   );
                    break;
                }
            }


            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // We may have created a new account.  Set the domain's RID
                // marker, if necessary, to make sure we don't re-use the
                // RID we just created.
                //

                PSAMP_DEFINED_DOMAINS Domain = &SampDefinedDomains[ DomainContext->DomainIndex ];

                if ( RelativeId >= Domain->CurrentFixed.NextRid ) {
                    Domain->CurrentFixed.NextRid = RelativeId + 1;
                }
            }
        }


Done:
        //
        // De-reference the domain object
        //

        IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }


    if ( NT_SUCCESS( NtStatus ) ) {

        SampSetTransactionWithinDomain(FALSE);
        NtStatus = SampReleaseWriteLock( TRUE );

    } else {

        IgnoreStatus = SampReleaseWriteLock( FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    return( NtStatus );
}




NTSTATUS
SamIGetSerialNumberDomain(
    IN SAMPR_HANDLE DomainHandle,
    OUT PLARGE_INTEGER ModifiedCount,
    OUT PLARGE_INTEGER CreationTime
    )

/*++

Routine Description:

    This routine retrieves the creation time and modified count of the
    domain.  This information is used as a serial number for the domain.

Arguments:

    DomainHandle - Handle to the domain being replicated.

    ModifiedCount - Retrieves the current count of modifications to the
        domain.

    CreationTime - Receives the date/time the domain was created.

Return Value:

    STATUS_SUCCESS - The service has completed successfully.

--*/
{
    PSAMP_DEFINED_DOMAINS   Domain;
    PSAMP_OBJECT            DomainContext;
    SAMP_OBJECT_TYPE        FoundType;
    NTSTATUS                NtStatus;
    NTSTATUS                IgnoreStatus;

    SAMTRACE("SamIGetSerialNumberDomain");

    SampAcquireReadLock();

    //
    // Validate type of, and access to object.
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;

    NtStatus = SampLookupContext(
                   DomainContext,
                   0L,
                   SampDomainObjectType,           // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

        Domain = &SampDefinedDomains[ DomainContext->DomainIndex ];

        (*ModifiedCount) = Domain->NetLogonChangeLogSerialNumber;
        (*CreationTime) = Domain->UnmodifiedFixed.CreationTime;

        //
        // De-reference the domain object
        //

        IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    SampReleaseReadLock();

    return( NtStatus );
}



NTSTATUS
SamISetSerialNumberDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN PLARGE_INTEGER ModifiedCount,
    IN PLARGE_INTEGER CreationTime,
    IN BOOLEAN StartOfFullSync
    )

/*++

Routine Description:

    This routine causes the creation time and modified count of the
    domain to be replaced.  This information is used as a serial number
    for the domain.

Arguments:

    DomainHandle - Handle to the domain being replicated.

    ModifiedCount - Provides the current count of modifications to the
        domain.

    CreationTime - Provides the date/time the domain was created.

    StartOfFullSync - This boolean indicates whether a full sync is being
        initiated.  If this is TRUE, then a full sync is to follow and
        all existing domain information may be discarded.  If this is
        FALSE, then only specific domain information is to follow and all
        changes must not violate statndard SAM operation behaviour.

Return Value:

    STATUS_SUCCESS - The service has completed successfully.

    Other failures may be returned from SampReleaseWriteLock().

--*/
{
    LARGE_INTEGER           LargeOne, AdjustedModifiedCount;
    NTSTATUS                NtStatus, TmpStatus, IgnoreStatus;
    PSAMP_DEFINED_DOMAINS   Domain;
    PSAMP_OBJECT            DomainContext;
    SAMP_OBJECT_TYPE        FoundType;

    UNREFERENCED_PARAMETER( StartOfFullSync );

    SAMTRACE("SamISetSerialNumberDomain");

    NtStatus = SampAcquireWriteLock();

    if ( !NT_SUCCESS( NtStatus ) ) {

        return(NtStatus);
    }

    //
    // Validate type of, and access to object.
    //

    DomainContext = (PSAMP_OBJECT)DomainHandle;

    NtStatus = SampLookupContext(
                   DomainContext,
                   0L,
                   SampDomainObjectType,           // ExpectedType
                   &FoundType
                   );

    if (NT_SUCCESS(NtStatus)) {

        Domain = &SampDefinedDomains[ DomainContext->DomainIndex ];

        //
        // Now set the Domain's ModifiedCount and CreationTime to the values
        // specified.
        //

        Domain->CurrentFixed.CreationTime = (*CreationTime);

        if ( SampDefinedDomains[SampTransactionDomainIndex].CurrentFixed.ServerRole
            == DomainServerRoleBackup ) {

            //
            // Go ahead and use the ModifiedCount that was passed in.
            // Since this is a BDC, the commit code will not increment
            // the ModifiedCount.
            //

            Domain->NetLogonChangeLogSerialNumber = (*ModifiedCount);

        } else {

            //
            // This is a PDC, so the commit code will increment the
            // ModifiedCount before using it.  So decrement
            // it here so that it ends up at the right value.
            //


            AdjustedModifiedCount.QuadPart = ModifiedCount->QuadPart - 1 ;

            Domain->NetLogonChangeLogSerialNumber = AdjustedModifiedCount;
        }

        //
        // Update the "disk mirror" copy of the Modified Count. This ensures
        // that this will be written immediately rather than be lazy flushed.
        //

        Domain->CurrentFixed.ModifiedCount =(*ModifiedCount);

        if ( !( ModifiedCount->QuadPart == 0) ||
             !StartOfFullSync ) {

            //
            // If ModifiedCount is non-zero, we must be ending a full
            // or partial replication of the database...or perhaps we've
            // just finished a 128k chunk over a WAN or somesuch.  Let's
            // ask to flush this stuff out to disk right away, rather
            // than waiting for the flush thread to get around to it.
            //

            FlushImmediately = TRUE;
        }




        SampDiagPrint( DISPLAY_ROLE_CHANGES,
                       ("SAM: SamISetSerialNumberDomain\n"
                        "                  Old ModifiedId: [0x%lx, 0x%lx]\n"
                        "                  New ModifiedId: [0x%lx, 0x%lx]\n",
                        Domain->UnmodifiedFixed.ModifiedCount.HighPart,
                        Domain->UnmodifiedFixed.ModifiedCount.LowPart,
                        Domain->CurrentFixed.ModifiedCount.HighPart,
                        Domain->CurrentFixed.ModifiedCount.LowPart )
                      );


        //
        // De-reference the domain object
        // Don't save changes - the domain fixed info will be written
        // out when the write lock is released.
        //

        IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));


        NtStatus = SampReleaseWriteLock( TRUE );

    } else {

        TmpStatus = SampReleaseWriteLock( FALSE );
    }

    return( NtStatus );
}

NTSTATUS
SampGetPrivateUserData(
    PSAMP_OBJECT UserContext,
    OUT PULONG DataLength,
    OUT PVOID *Data
    )

/*++

Routine Description:

    This service is used during replication of private user
    type-specific information.  It reads the private user information from
    the registry, and adjusts it if necessary (ie if the password history
    value is smaller than it used to be).

Arguments:

    UserContext - A handle to a User.

    DataLength - The length of the data returned.

    Data - Receives a pointer to a buffer of length DataLength allocated
        and returned by SAM.  The buffer must be freed to the process
        heap when it is no longer needed.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_INVALID_PARAMETER_1 - The object type of the provided handle
        does not support this operation.


--*/
{
    NTSTATUS                NtStatus;
    UNICODE_STRING          TempString;
    UNICODE_STRING          StoredBuffer;
    PSAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE PasswordData;
    PSAMP_DEFINED_DOMAINS   Domain;
    PVOID BufferPointer;
    ULONG PasswordHistoryLength;

    Domain = &SampDefinedDomains[ UserContext->DomainIndex ];
    PasswordHistoryLength = Domain->UnmodifiedFixed.PasswordHistoryLength;

    //
    // Keep a history of at least 2 for krbtgt account
    //

    if ((UserContext->TypeBody.User.Rid == DOMAIN_USER_RID_KRBTGT) &&
        ( PasswordHistoryLength<SAMP_KRBTGT_PASSWORD_HISTORY_LENGTH))
    {
        PasswordHistoryLength = SAMP_KRBTGT_PASSWORD_HISTORY_LENGTH;
    }

    *Data = NULL;
    //
    // Return data length as the maximum possible for this domain
    // - the size of the structure, plus the maximum size of the
    // NT and LM password histories.
    //

    *DataLength = ( ( PasswordHistoryLength )
        * ENCRYPTED_NT_OWF_PASSWORD_LENGTH ) +
        ( ( PasswordHistoryLength ) *
        ENCRYPTED_LM_OWF_PASSWORD_LENGTH ) +
        sizeof( SAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE );

    *Data = MIDL_user_allocate( *DataLength );

    if ( *Data == NULL ) {

        NtStatus = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        PasswordData = (PSAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE)*Data;
        PasswordData->DataType = 0;  // set correctly when we're done

        NtStatus = SampGetUnicodeStringAttribute(
                       UserContext,
                       SAMP_USER_DBCS_PWD,
                       FALSE,
                       &StoredBuffer
                       );

        if ( NT_SUCCESS( NtStatus ) ) {
            if (SampIsDataEncrypted(&StoredBuffer)) {
                NtStatus = SampDecryptSecretData(
                                &TempString,
                                LmPassword,
                                &StoredBuffer,
                                UserContext->TypeBody.User.Rid
                                );
            } else {
                TempString = StoredBuffer;
            }
        }

        if (NT_SUCCESS(NtStatus)) {

            PasswordData->CaseInsensitiveDbcs.Length = TempString.Length;
            PasswordData->CaseInsensitiveDbcs.MaximumLength = TempString.MaximumLength;
            PasswordData->CaseInsensitiveDbcs.Buffer = 0;

            RtlCopyMemory(
                &(PasswordData->CaseInsensitiveDbcsBuffer),
                TempString.Buffer,
                TempString.Length );

            if (TempString.Buffer != StoredBuffer.Buffer) {
                SampFreeUnicodeString(&TempString);
            }

            NtStatus = SampGetUnicodeStringAttribute(
                           UserContext,
                           SAMP_USER_UNICODE_PWD,
                           FALSE,
                           &StoredBuffer
                           );
            if ( NT_SUCCESS( NtStatus ) ) {
                if (SampIsDataEncrypted(&StoredBuffer)) {
                    NtStatus = SampDecryptSecretData(
                                    &TempString,
                                    NtPassword,
                                    &StoredBuffer,
                                    UserContext->TypeBody.User.Rid
                                    );
                } else {
                    TempString = StoredBuffer;
                }
            }

            if ( NT_SUCCESS( NtStatus ) ) {

                PasswordData->CaseSensitiveUnicode.Length = TempString.Length;
                PasswordData->CaseSensitiveUnicode.MaximumLength = TempString.MaximumLength;
                PasswordData->CaseSensitiveUnicode.Buffer = 0;

                RtlCopyMemory(
                    &(PasswordData->CaseSensitiveUnicodeBuffer),
                    TempString.Buffer,
                    TempString.Length );

                if (TempString.Buffer != StoredBuffer.Buffer) {
                    SampFreeUnicodeString(&TempString);
                }

                NtStatus = SampGetUnicodeStringAttribute(
                               UserContext,
                               SAMP_USER_NT_PWD_HISTORY,
                               FALSE,
                               &StoredBuffer
                               );

                if ( NT_SUCCESS( NtStatus ) ) {
                    if (SampIsDataEncrypted(&StoredBuffer)) {
                        NtStatus = SampDecryptSecretData(
                                        &TempString,
                                        NtPasswordHistory,
                                        &StoredBuffer,
                                        UserContext->TypeBody.User.Rid
                                        );
                    } else {
                        TempString = StoredBuffer;
                    }
                }

                if ( NT_SUCCESS( NtStatus ) ) {

                    //
                    // If history is too long, must shorten here
                    //

                    PasswordData->NtPasswordHistory.Length = TempString.Length;
                    PasswordData->NtPasswordHistory.MaximumLength = TempString.MaximumLength;
                    PasswordData->NtPasswordHistory.Buffer = 0;

                    if ( PasswordData->NtPasswordHistory.Length > (USHORT)
                        ( PasswordHistoryLength
                        * ENCRYPTED_NT_OWF_PASSWORD_LENGTH ) ) {

                        PasswordData->NtPasswordHistory.Length = (USHORT)
                            ( PasswordHistoryLength
                            * ENCRYPTED_NT_OWF_PASSWORD_LENGTH );
                    }

                    //
                    // Put the body of the Nt password history
                    // immediately following the structure.
                    //

                    BufferPointer = (PVOID)(((PCHAR)PasswordData) +
                        sizeof( SAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE ) );

                    RtlCopyMemory(
                        BufferPointer,
                        TempString.Buffer,
                        PasswordData->NtPasswordHistory.Length );

                    if (TempString.Buffer != StoredBuffer.Buffer) {
                        SampFreeUnicodeString(&TempString);
                    }


                    NtStatus = SampGetUnicodeStringAttribute(
                                   UserContext,
                                   SAMP_USER_LM_PWD_HISTORY,
                                   FALSE,
                                   &StoredBuffer
                                   );

                    if ( NT_SUCCESS( NtStatus ) ) {
                        if (SampIsDataEncrypted(&StoredBuffer)) {
                            NtStatus = SampDecryptSecretData(
                                            &TempString,
                                            LmPasswordHistory,
                                            &StoredBuffer,
                                            UserContext->TypeBody.User.Rid
                                            );
                        } else {
                            TempString = StoredBuffer;
                        }
                    }

                    if ( NT_SUCCESS( NtStatus ) ) {

                        PasswordData->LmPasswordHistory.Length = TempString.Length;
                        PasswordData->LmPasswordHistory.MaximumLength = TempString.MaximumLength;
                        PasswordData->LmPasswordHistory.Buffer = 0;

                        if ( PasswordData->LmPasswordHistory.Length > (USHORT)
                            ( PasswordHistoryLength
                            * ENCRYPTED_LM_OWF_PASSWORD_LENGTH ) ) {

                            PasswordData->LmPasswordHistory.Length = (USHORT)
                                ( PasswordHistoryLength
                                * ENCRYPTED_LM_OWF_PASSWORD_LENGTH );
                        }

                        //
                        // Put the body of the Lm password history
                        // immediately following the Nt password
                        // history.
                        //

                        BufferPointer = (PVOID)(((PCHAR)(BufferPointer)) +
                            PasswordData->NtPasswordHistory.Length );

                        RtlCopyMemory(
                            BufferPointer,
                            TempString.Buffer,
                            PasswordData->LmPasswordHistory.Length );

                        PasswordData->DataType = SamPrivateDataPassword;

                        if (TempString.Buffer != StoredBuffer.Buffer) {
                            SampFreeUnicodeString(&TempString);
                        }

                    }
                }
            }
        }
    }

    if  ((!NT_SUCCESS(NtStatus)) && (NULL!=*Data))
    {
        MIDL_user_free(*Data);
        *Data = NULL;
    }

    return( NtStatus );
}

VOID
SampGetSerialNumberDomain2(
    IN PSID DomainSid,
    OUT LARGE_INTEGER * SamSerialNumber,
    OUT LARGE_INTEGER * SamCreationTime,
    OUT LARGE_INTEGER * BuiltinSerialNumber,
    OUT LARGE_INTEGER * BuiltinCreationTime
    )
/*++

    This routine retreives the modified count of the domain. This is used
    by ntdsa.dll. This routine does no database access, and does not acquire
    SAM lock. It returns the information from the in - memory structures


    Parameters

        DomainSid -- Sid specifying the domain
        SamSerialNumber -- The account database serial number is returned in here
        BuiltinSerialNumber -- The builtin database serial number is returned in here

    Return Values

        Void Function
--*/
{
    ULONG DomainIndex,
          BuiltinDomainIndex;

    for (DomainIndex=SampDsGetPrimaryDomainStart();
                DomainIndex<SampDefinedDomainsCount;DomainIndex++)
    {
        if (RtlEqualSid(SampDefinedDomains[DomainIndex].Sid, DomainSid))
        {
            break;
        }
    }

    ASSERT(DomainIndex<SampDefinedDomainsCount);

    BuiltinDomainIndex = DomainIndex-1;

    *SamSerialNumber = SampDefinedDomains[DomainIndex].NetLogonChangeLogSerialNumber;
    *SamCreationTime = SampDefinedDomains[DomainIndex].UnmodifiedFixed.CreationTime;
    *BuiltinSerialNumber =
        SampDefinedDomains[BuiltinDomainIndex].NetLogonChangeLogSerialNumber;
    *BuiltinCreationTime =
        SampDefinedDomains[BuiltinDomainIndex].UnmodifiedFixed.CreationTime;
}


NTSTATUS
SampSetSerialNumberDomain2(
    IN PSID DomainSid,
    OUT LARGE_INTEGER * SamSerialNumber,
    OUT LARGE_INTEGER * SamCreationTime,
    OUT LARGE_INTEGER * BuiltinSerialNumber,
    OUT LARGE_INTEGER * BuiltinCreationTime
    )
/*++

    This routine sets the modified count of the domain. This is used
    by ntdsa.dll.


    Parameters

        DomainSid -- Sid specifying the domain
        SamSerialNumber -- The account database serial number is returned in here
        BuiltinSerialNumber -- The builtin database serial number is returned in here

    Return Values

        Void Function
--*/
{
    ULONG DomainIndex,
          BuiltinDomainIndex;
    NTSTATUS NtStatus = STATUS_SUCCESS;


    //
    // This routine can be called from within SAM/ntdsa, with
    // the sam lock held.
    //

    ASSERT(SampCurrentThreadOwnsLock());


    for (DomainIndex=SampDsGetPrimaryDomainStart();
            DomainIndex<SampDefinedDomainsCount;DomainIndex++)
    {
        if (RtlEqualSid(SampDefinedDomains[DomainIndex].Sid, DomainSid))
        {
            break;
        }
    }

    ASSERT(DomainIndex<SampDefinedDomainsCount);

    BuiltinDomainIndex = DomainIndex-1;

    NtStatus = SampValidateDomainCache();
    if (!NT_SUCCESS(NtStatus))
        goto Error;


    SampSetTransactionDomain(DomainIndex);

    SampDefinedDomains[DomainIndex].NetLogonChangeLogSerialNumber
            = *SamSerialNumber;
    SampDefinedDomains[DomainIndex].CurrentFixed.CreationTime
            = *SamCreationTime;

    SampDefinedDomains[DomainIndex].CurrentFixed.ModifiedCount
            = *SamSerialNumber;

    NtStatus = SampCommitChanges();
    if (!NT_SUCCESS(NtStatus))
        goto Error;

    SampSetTransactionWithinDomain(FALSE);

    //
    // Validate the domain cache again, as commit changes can affect
    // it's status
    //

    NtStatus = SampValidateDomainCache();
    if (!NT_SUCCESS(NtStatus))
        goto Error;

    SampSetTransactionDomain(BuiltinDomainIndex);

    SampDefinedDomains[BuiltinDomainIndex].NetLogonChangeLogSerialNumber
            = *BuiltinSerialNumber;
    SampDefinedDomains[BuiltinDomainIndex].CurrentFixed.CreationTime
            = *BuiltinCreationTime;

    SampDefinedDomains[BuiltinDomainIndex].CurrentFixed.ModifiedCount
            = *BuiltinSerialNumber;

    NtStatus = SampCommitChanges();
    if (!NT_SUCCESS(NtStatus))
        goto Error;



Error:

    SampSetTransactionWithinDomain(FALSE);

    return NtStatus;
}



NTSTATUS
SamIGetPrivateData(
    IN SAMPR_HANDLE SamHandle,
    IN PSAMI_PRIVATE_DATA_TYPE PrivateDataType,
    OUT PBOOLEAN SensitiveData,
    OUT PULONG DataLength,
    OUT PVOID *Data
    )

/*++

Routine Description:

    This service is used to replicate private object type-specific
    information.  This information must be replicated for each instance
    of the object type that is replicated.

Arguments:

    SamHandle - A handle to a Domain, User, Group or Alias.

    PrivateDataType - Indicates which private data is being retrieved.
        The data type must correspond to the type of object that the
        handle is to.

    SensitiveData - Indicates that the data returned must be encrypted
        before being sent anywhere.

    DataLength - The length of the data returned.

    Data - Receives a pointer to a buffer of length DataLength allocated
        and returned by SAM.  The buffer must be freed to the process
        heap when it is no longer needed.

Return Value:

    STATUS_SUCCESS - Indicates the service completed successfully.

    STATUS_INVALID_PARAMETER_1 - The object type of the provided handle
        does not support this operation.


--*/
{

    NTSTATUS                NtStatus, IgnoreStatus;
    SAMP_OBJECT_TYPE        FoundType;
    PSAMP_DEFINED_DOMAINS   Domain;

    SAMTRACE("SamIGetPrivateData");

    SampAcquireReadLock();

    switch ( *PrivateDataType ) {

    case SamPrivateDataNextRid: {

        PSAMP_OBJECT            DomainContext;

        //
        // Validate type of, and access to object.
        //

        DomainContext = (PSAMP_OBJECT)SamHandle;
        NtStatus = SampLookupContext(
                       DomainContext,
                       0L,
                       SampDomainObjectType,           // ExpectedType
                       &FoundType
                       );

        if (NT_SUCCESS(NtStatus)) {

            PSAMI_PRIVATE_DATA_NEXTRID_TYPE NextRidData;

            //
            // Return the domain's NextRid.
            //

            Domain = &SampDefinedDomains[ DomainContext->DomainIndex ];

            *Data = MIDL_user_allocate( sizeof( SAMI_PRIVATE_DATA_NEXTRID_TYPE ) );

            if ( *Data == NULL ) {

                NtStatus = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                NextRidData = (PSAMI_PRIVATE_DATA_NEXTRID_TYPE)*Data;
                NextRidData->NextRid = Domain->CurrentFixed.NextRid;
                NextRidData->DataType = SamPrivateDataNextRid;
            }

            *DataLength = sizeof( SAMI_PRIVATE_DATA_NEXTRID_TYPE );

            *SensitiveData = FALSE;

            //
            // De-reference the object
            //

            IgnoreStatus = SampDeReferenceContext( DomainContext, FALSE );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }

        break;
    }

    case SamPrivateDataPassword: {

        PSAMP_OBJECT            UserContext;

        //
        // Validate type of, and access to object.
        //

        UserContext = (PSAMP_OBJECT)SamHandle;
        NtStatus = SampLookupContext(
                       UserContext,
                       0L,
                       SampUserObjectType,           //ExpectedType
                       &FoundType
                       );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampGetPrivateUserData(
                           UserContext,
                           DataLength,
                           Data
                           );

            *SensitiveData = TRUE;

            //
            // De-reference the object
            //

            IgnoreStatus = SampDeReferenceContext( UserContext, FALSE );
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }

        break;
    }

    default: {

        //
        // Since caller is trusted, assume we've got a version mismatch
        // or somesuch.
        //

        NtStatus = STATUS_NOT_IMPLEMENTED;

        break;
    }
    }

    //
    // Free the read lock
    //

    SampReleaseReadLock();

    return( NtStatus );
}



NTSTATUS
SampSetPrivateUserData(
    PSAMP_OBJECT UserContext,
    IN ULONG DataLength,
    IN PVOID Data
    )

/*++

Routine Description:

    This service is used to replicate private user type-specific
    information.  It writes the private data (passwords and password
    histories) to the registry.


Arguments:

    UserContext - Handle to a User object.

    DataLength - The length of the data being set.

    Data - A pointer to a buffer of length DataLength containing the
        private data.


Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_INVALID_PARAMETER_1 - The object type of the provided handle
        does not support this operation.


--*/
{
    NTSTATUS                NtStatus;
    UNICODE_STRING          StoredBuffer;
    SAMI_PRIVATE_DATA_PASSWORD_TYPE Buffer;
    PSAMI_PRIVATE_DATA_PASSWORD_TYPE PasswordData = &Buffer;
    PSAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE PasswordDataRelative;
    BOOLEAN                 ReplicateImmediately = FALSE;

    ASSERT( Data != NULL );

    if ( ( Data != NULL ) &&
        ( DataLength >= sizeof(SAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE) ) ) {

        PasswordDataRelative = (PSAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE)Data;

        PasswordData->CaseInsensitiveDbcs.Length = PasswordDataRelative->CaseInsensitiveDbcs.Length;
        PasswordData->CaseInsensitiveDbcs.MaximumLength = PasswordDataRelative->CaseInsensitiveDbcs.MaximumLength;
        PasswordData->CaseInsensitiveDbcs.Buffer = (PWSTR)
            (&(PasswordDataRelative->CaseInsensitiveDbcsBuffer));

        NtStatus = SampEncryptSecretData(
                        &StoredBuffer,
                        SampGetEncryptionKeyType(),
                        LmPassword,
                        &(PasswordData->CaseInsensitiveDbcs),
                        UserContext->TypeBody.User.Rid
                        );

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampSetUnicodeStringAttribute(
                            UserContext,
                            SAMP_USER_DBCS_PWD,
                            &StoredBuffer
                            );

            SampFreeUnicodeString(&StoredBuffer);
        }

        if ( NT_SUCCESS( NtStatus ) ) {

            PasswordData->CaseSensitiveUnicode.Length = PasswordDataRelative->CaseSensitiveUnicode.Length;
            PasswordData->CaseSensitiveUnicode.MaximumLength = PasswordDataRelative->CaseSensitiveUnicode.MaximumLength;
            PasswordData->CaseSensitiveUnicode.Buffer = (PWSTR)
                (&(PasswordDataRelative->CaseSensitiveUnicodeBuffer));

            NtStatus = SampEncryptSecretData(
                            &StoredBuffer,
                            SampGetEncryptionKeyType(),
                            NtPassword,
                            &(PasswordData->CaseSensitiveUnicode),
                            UserContext->TypeBody.User.Rid
                            );

            if (NT_SUCCESS(NtStatus)) {

                //
                // If NT Password is present then try to update the password
                // for interdomain trust accounts in the LSA
                //
                NtStatus = SampSyncLsaInterdomainTrustPassword(
                                    UserContext,
                                    &(PasswordData->CaseSensitiveUnicode)
                                    );


                //
                // Update it locally
                //

                if (NT_SUCCESS(NtStatus))
                {
                     NtStatus = SampSetUnicodeStringAttribute(
                                UserContext,
                                SAMP_USER_UNICODE_PWD,
                                &StoredBuffer
                                );

                    SampFreeUnicodeString(&StoredBuffer);

                }
            }


            if ( NT_SUCCESS( NtStatus ) ) {

                PasswordData->NtPasswordHistory.Length = PasswordDataRelative->NtPasswordHistory.Length;
                PasswordData->NtPasswordHistory.MaximumLength = PasswordDataRelative->NtPasswordHistory.MaximumLength;
                PasswordData->NtPasswordHistory.Buffer =
                    (PWSTR)(((PCHAR)PasswordDataRelative) +
                    sizeof( SAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE ) );

                NtStatus = SampEncryptSecretData(
                                &StoredBuffer,
                                SampGetEncryptionKeyType(),
                                NtPasswordHistory,
                                &(PasswordData->NtPasswordHistory),
                                UserContext->TypeBody.User.Rid
                                );

                if (NT_SUCCESS(NtStatus)) {

                    NtStatus = SampSetUnicodeStringAttribute(
                                    UserContext,
                                    SAMP_USER_NT_PWD_HISTORY,
                                    &StoredBuffer
                                    );

                    SampFreeUnicodeString(&StoredBuffer);
                }



                if ( NT_SUCCESS( NtStatus ) ) {

                    PasswordData->LmPasswordHistory.Length = PasswordDataRelative->LmPasswordHistory.Length;
                    PasswordData->LmPasswordHistory.MaximumLength = PasswordDataRelative->LmPasswordHistory.MaximumLength;
                    PasswordData->LmPasswordHistory.Buffer =
                        (PWSTR)(((PCHAR)PasswordDataRelative) +
                        sizeof( SAMI_PRIVATE_DATA_PASSWORD_RELATIVE_TYPE )
                     +  PasswordDataRelative->NtPasswordHistory.Length  );

                    NtStatus = SampEncryptSecretData(
                                    &StoredBuffer,
                                    SampGetEncryptionKeyType(),
                                    LmPasswordHistory,
                                    &(PasswordData->LmPasswordHistory),
                                    UserContext->TypeBody.User.Rid
                                    );

                    if (NT_SUCCESS(NtStatus)) {

                        NtStatus = SampSetUnicodeStringAttribute(
                                        UserContext,
                                        SAMP_USER_LM_PWD_HISTORY,
                                        &StoredBuffer
                                        );

                        SampFreeUnicodeString(&StoredBuffer);
                    }


                }
            }
        }

    } else {

        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return(NtStatus);
}


NTSTATUS
SamISetPrivateData(
    IN SAMPR_HANDLE SamHandle,
    IN ULONG DataLength,
    IN PVOID Data
    )

/*++

Routine Description:

    This service is used to replicate private object type-specific
    information.  This information must be replicated for each instance
    of the object type that is replicated.


Arguments:

    SamHandle - Handle to a Domain, User, Group or Alias object.  See
        SamIGetPrivateInformation() for a list of supported object
        types.

    DataLength - The length of the data being set.

    Data - A pointer to a buffer of length DataLength containing the
        private data.


Return Value:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_INVALID_PARAMETER_1 - The object type of the provided handle
        does not support this operation.


--*/
{
    NTSTATUS                NtStatus, IgnoreStatus;
    SAMP_OBJECT_TYPE        FoundType;
    BOOLEAN                 ReplicateImmediately = FALSE;

    SAMTRACE("SamISetPrivateData");

    ASSERT( Data != NULL );

    NtStatus = SampAcquireWriteLock();

    if ( !NT_SUCCESS( NtStatus ) ) {

        return( NtStatus );
    }

    switch ( *((PSAMI_PRIVATE_DATA_TYPE)(Data)) ) {

    case SamPrivateDataNextRid: {

        PSAMP_OBJECT            DomainContext;
        PSAMP_DEFINED_DOMAINS   Domain;

        //
        // Validate type of, and access to object.
        //

        DomainContext = (PSAMP_OBJECT)SamHandle;
        NtStatus = SampLookupContext(
                       DomainContext,
                       0L,
                       SampDomainObjectType,           // ExpectedType
                       &FoundType
                       );

        if (NT_SUCCESS(NtStatus)) {

            //
            // Set the domain's NextRid.
            //

            Domain = &SampDefinedDomains[ DomainContext->DomainIndex ];

            if ( ( Data != NULL ) &&
                ( DataLength == sizeof(SAMI_PRIVATE_DATA_NEXTRID_TYPE) ) ) {

                PSAMI_PRIVATE_DATA_NEXTRID_TYPE NextRidData;

                //
                // We can trust Data to be a valid pointer; since our
                // caller is trusted.
                //

                NextRidData = (PSAMI_PRIVATE_DATA_NEXTRID_TYPE)Data;

                //
                // We used to set the domain's NextRid here.  But we've
                // decided that, rather than trying to replicate an exact
                // copy of the database, we're going to try to patch any
                // problems as we replicate.  To ensure that we don't
                // create any problems on the way, we want to make sure
                // that the NextRid value on a BDC is NEVER decreased.
                // Not that it matters; nobody calls this anyway.  So the
                // Get/SetPrivateData code for domains could be removed.
                //

                // Domain->CurrentFixed.NextRid = NextRidData->NextRid;

            } else {

                NtStatus = STATUS_INVALID_PARAMETER;
            }

            //
            // De-reference the object
            //

            if ( NT_SUCCESS( NtStatus ) ) {

                NtStatus = SampDeReferenceContext(
                               DomainContext,
                               TRUE
                               );
            } else {

                IgnoreStatus = SampDeReferenceContext(
                                   DomainContext,
                                   FALSE
                                   );
            }
        }

        break;
    }

    case SamPrivateDataPassword: {

        PSAMP_OBJECT            UserContext;

        //
        // Validate type of, and access to object.
        //

        UserContext = (PSAMP_OBJECT)SamHandle;
        NtStatus = SampLookupContext(
                       UserContext,
                       0L,
                       SampUserObjectType,           // ExpectedType
                       &FoundType
                       );

        if ( NT_SUCCESS( NtStatus ) ) {

            NtStatus = SampSetPrivateUserData(
                           UserContext,
                           DataLength,
                           Data
                           );
            //
            // De-reference the object, adding attribute changes to the
            // RXACT if everything went OK.
            //

            if ( NT_SUCCESS( NtStatus ) ) {

                NtStatus = SampDeReferenceContext(
                           UserContext,
                           TRUE
                           );

            } else {

                IgnoreStatus = SampDeReferenceContext(
                               UserContext,
                               FALSE
                               );
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }
        }

        break;
    }

    default: {

        //
        // We've either got a version mismatch, or the caller passed us
        // bad data, or SamIGetPrivateData() never finished getting the
        // data into the buffer.
        //

        NtStatus = STATUS_INVALID_PARAMETER;

        break;
    }
    }


    //
    // Release the write lock - commit only if successful.
    //

    if ( NT_SUCCESS(NtStatus) ) {

        NtStatus = SampReleaseWriteLock( TRUE );

        //
        // No need to call SampNotifyNetlogonOfDelta, since the replicator
        // is the one that made this call.
        //

    } else {

        IgnoreStatus = SampReleaseWriteLock( FALSE );
    }

    return(NtStatus);
}

NTSTATUS
SampConvertToUniversalGroup(
    IN PSAMP_OBJECT DomainContext,
    IN ULONG        GroupRid
    )
/*++

    This routine converts the specified group, specified by GroupRid
    to be a universal group. This is used by SamISetMixedDomainFlag
    below.

    Arguments

    DomainContext -- Identifies the domain
    GroupRid      -- Identifies the group


    Return Values

    STATUS_SUCCESS
    Other error codes to indicate various failures

--*/
{
     SAMPR_HANDLE        GroupHandle=NULL;
     NTSTATUS            NtStatus = STATUS_SUCCESS;


     NtStatus = SamrOpenGroup(
                    DomainContext,
                    GROUP_ALL_ACCESS,
                    GroupRid,
                    &GroupHandle
                    );

    if (NT_SUCCESS(NtStatus))
    {
        //
        // O.K we opened the account
        //

        NtStatus = SampWriteGroupType(
                        GroupHandle,
                        GROUP_TYPE_UNIVERSAL_GROUP|GROUP_TYPE_SECURITY_ENABLED,
                        TRUE // mixed domain bit is not set as yet
                        );

        //
        // Close the Handle
        //

        SamrCloseHandle(&GroupHandle);


    }


    return(NtStatus);
}



NTSTATUS
SamISetMixedDomainFlag(
    IN SAMPR_HANDLE DomainHandle
    )

/*++

Routine Description:


    This routine modify the group type of enterprise admins 
    and schema admins groups to be a universal group.

    It will NOT modify the in memory MixedDomain Flag, because

    1. we don't hold SAM lock
    2. the transaction is not committed yet.
    
    Finally, when the loopback transaction committed, 
    SampNotifyReplicatedInChange() will do the job for us.
   

    This Routine does not yet still handle multiple hosted domains

Arguments:

    None.

Return Value:

    STATUS_SUCCESS - Currently always returned from this routine.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG DomainIndex = DOMAIN_START_DS;
    PSAMP_OBJECT        DomainContext = (PSAMP_OBJECT) DomainHandle;


    //
    // Modify the group type of the enterprise admins group
    // to be a universal group.
    //

    NtStatus = SampConvertToUniversalGroup(
                     DomainContext,
                     DOMAIN_GROUP_RID_ENTERPRISE_ADMINS
                     );

    if (STATUS_NO_SUCH_GROUP==NtStatus)
    {
        //
        // Quite O.K to not have the group, we need not be root domain
        //

        NtStatus = STATUS_SUCCESS;
    }


    if (!NT_SUCCESS(NtStatus))
        goto Error;

    //
    // Modify the group type of the schema admins group
    // to be a universal group.
    //

    NtStatus = SampConvertToUniversalGroup(
                     DomainContext,
                     DOMAIN_GROUP_RID_SCHEMA_ADMINS
                     );

    if (STATUS_NO_SUCH_GROUP==NtStatus)
    {
        //
        // Quite O.K to not have the group, we need not be root domain
        //

        NtStatus = STATUS_SUCCESS;
    }

    if (!NT_SUCCESS(NtStatus))
       goto Error;


Error:

    return(NtStatus);
}



NTSTATUS
SamrTestPrivateFunctionsDomain(
    IN SAMPR_HANDLE DomainHandle
    )

/*++

Routine Description:

    This service is called to test functions that are normally only
    accessible inside the security process.


Arguments:

    DomainHandle - Handle to the domain being tested.

Return Value:

    STATUS_SUCCESS - The tests completed successfully.

    Any errors are as propogated from the tests.


--*/
{
#if SAM_SERVER_TESTS

    LARGE_INTEGER ModifiedCount1;
    LARGE_INTEGER CreationTime1;
    PSAMP_DEFINED_DOMAINS   Domain;
    NTSTATUS NtStatus, TmpStatus;
    SAMI_PRIVATE_DATA_TYPE DataType = SamPrivateDataNextRid;
    SAMI_PRIVATE_DATA_NEXTRID_TYPE LocalNextRidData;
    PSAMI_PRIVATE_DATA_NEXTRID_TYPE NextRidData1 = NULL;
    PSAMI_PRIVATE_DATA_NEXTRID_TYPE NextRidData2 = NULL;
    PVOID   NextRidDataPointer = NULL;
    ULONG   DataLength = 0;
    BOOLEAN SensitiveData = TRUE;

    SAMTRACE("SamrTestPrivateFunctionsDomain");

    Domain = &SampDefinedDomains[ ((PSAMP_OBJECT)DomainHandle)->DomainIndex ];

    //
    // Test SamIGetSerialNumberDomain().  Just do a GET to make sure we
    // don't blow up.
    //

    NtStatus = SamIGetSerialNumberDomain(
                   DomainHandle,
                   &ModifiedCount1,
                   &CreationTime1 );

    //
    // Test SamISetSerialNumberDomain().
    //

    if ( NT_SUCCESS( NtStatus ) ) {

        LARGE_INTEGER ModifiedCount2;
        LARGE_INTEGER ModifiedCount3;
        LARGE_INTEGER CreationTime2;
        LARGE_INTEGER CreationTime3;

        //
        // Try a simple SET to make sure we don't blow up.
        //

        ModifiedCount2.HighPart = 7;
        ModifiedCount2.LowPart = 4;
        CreationTime2.HighPart = 6;
        CreationTime2.LowPart = 9;

        NtStatus = SamISetSerialNumberDomain(
                       DomainHandle,
                       &ModifiedCount2,
                       &CreationTime2,
                       FALSE );

        if ( NT_SUCCESS( NtStatus ) ) {

            //
            // Now do a GET to see if our SET worked.
            //

            NtStatus = SamIGetSerialNumberDomain(
                           DomainHandle,
                           &ModifiedCount3,
                           &CreationTime3 );

            if ( ( CreationTime2.HighPart != CreationTime3.HighPart ) ||
                ( CreationTime2.LowPart != CreationTime3.LowPart ) ) {

                NtStatus = STATUS_DATA_ERROR;
            }

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // Do another SET to put CreationTime back where it should
                // be.  ModifiedCount will be 1 too big, so what.
                //

                NtStatus = SamISetSerialNumberDomain(
                               DomainHandle,
                               &ModifiedCount1,
                               &CreationTime1,
                               FALSE );
            }
        }
    }

    //
    // Test SamIGetPrivateData().
    //

    if ( NT_SUCCESS( NtStatus ) ) {

        NtStatus = SamIGetPrivateData(
                       DomainHandle,
                       &DataType,
                       &SensitiveData,
                       &DataLength,
                       &NextRidDataPointer );

        if ( NT_SUCCESS( NtStatus ) ) {

            NextRidData1 = (PSAMI_PRIVATE_DATA_NEXTRID_TYPE)NextRidDataPointer;

            if ( ( DataLength != sizeof( SAMI_PRIVATE_DATA_NEXTRID_TYPE ) ) ||
                ( SensitiveData != FALSE ) ||
                ( NextRidData1->DataType != SamPrivateDataNextRid ) ||
                ( NextRidData1->NextRid != Domain->CurrentFixed.NextRid ) ) {

                NtStatus = STATUS_DATA_ERROR;
            }
        }
    }

//    //
//    // Test SamISetPrivateData().
//    //
//    // NO, don't test it, since it no longer does anything.  We don't
//    // ever want NextRid to get set, because we never want it to get
//    // smaller.
//
//    if ( NT_SUCCESS( NtStatus ) ) {
//
//        //
//        // First do a random domain set to make sure we don't blow up.
//        //
//
//        LocalNextRidData.DataType = SamPrivateDataNextRid;
//        LocalNextRidData.NextRid = 34567;
//
//        NtStatus = SamISetPrivateData(
//                       DomainHandle,
//                       sizeof( SAMI_PRIVATE_DATA_NEXTRID_TYPE ),
//                       &LocalNextRidData
//                       );
//
//        if ( NT_SUCCESS( NtStatus ) ) {
//
//            //
//            // Now do a domain get to make sure our set worked.
//            //
//
//            NtStatus = SamIGetPrivateData(
//                           DomainHandle,
//                           &DataType,
//                           &SensitiveData,
//                           &DataLength,
//                           &NextRidDataPointer );
//
//            if ( NT_SUCCESS( NtStatus ) ) {
//
//                //
//                // Verify the data is as we set it.
//                //
//
//                NextRidData2 = (PSAMI_PRIVATE_DATA_NEXTRID_TYPE)NextRidDataPointer;
//
//                if ( NextRidData2->NextRid != LocalNextRidData.NextRid ) {
//
//                    NtStatus = STATUS_DATA_ERROR;
//                }
//
//                //
//                // Now do a domain set to restore things to their original state.
//                //
//
//                TmpStatus = SamISetPrivateData(
//                               DomainHandle,
//                               sizeof( SAMI_PRIVATE_DATA_NEXTRID_TYPE ),
//                               NextRidData1
//                               );
//
//                if ( NT_SUCCESS( NtStatus ) ) {
//
//                    NtStatus = TmpStatus;
//                }
//            }
//        }
//
//        if ( NextRidData1 != NULL ) {
//
//            MIDL_user_free( NextRidData1 );
//        }
//
//        if ( NextRidData2 != NULL ) {
//
//            MIDL_user_free( NextRidData2 );
//        }
//    }

    //
    // Test SamICreateAccountByRid().
    //

    if ( NT_SUCCESS( NtStatus ) ) {

        RPC_UNICODE_STRING  AccountNameU;
        RPC_UNICODE_STRING  AccountName2U;
        SAMPR_HANDLE UserAccountHandle;
        SAMPR_HANDLE BadAccountHandle;
        SAMPR_HANDLE GroupAccountHandle;
        NTSTATUS TmpStatus;
        ULONG RelativeId = 1111;
        ULONG ConflictingAccountRid;
        BOOLEAN AllTestsCompleted = FALSE;

        //
        // Create a unique account - a user with a known name and RID.
        //

        RtlInitUnicodeString( &AccountNameU, L"USER1SRV" );
        RtlInitUnicodeString( &AccountName2U, L"USER2SRV" );

        NtStatus = SamICreateAccountByRid(
                       DomainHandle,
                       SamObjectUser,
                       RelativeId,
                       &AccountNameU,
                       USER_ALL_ACCESS,
                       &UserAccountHandle,
                       &ConflictingAccountRid );

        if ( NT_SUCCESS( NtStatus ) ) {

            //
            // User is open.  Close it, and make the same call as above to
            // make sure that the user gets opened.  We'll need it open
            // later to delete it anyway.
            //

            TmpStatus = SamrCloseHandle( &UserAccountHandle );
            ASSERT( NT_SUCCESS( TmpStatus ) );

            NtStatus = SamICreateAccountByRid(
                           DomainHandle,
                           SamObjectUser,
                           RelativeId,
                           &AccountName,
                           USER_ALL_ACCESS,
                           &UserAccountHandle,
                           &ConflictingAccountRid );

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // Make same call as above, but with a different RID.
                // Should get an error because of the name collision.
                //

                NtStatus = SamICreateAccountByRid(
                               DomainHandle,
                               SamObjectUser,
                               RelativeId + 1,
                               &AccountName,
                               0L,
                               &BadAccountHandle,
                               &ConflictingAccountRid );

                if ( NtStatus == STATUS_USER_EXISTS ) {

                    //
                    // Make same call as above, but with a different name.  Should
                    // get an error because of the RID collision.
                    //

                    NtStatus = SamICreateAccountByRid(
                                   DomainHandle,
                                   SamObjectUser,
                                   RelativeId,
                                   &AccountName2,
                                   0L,
                                   &BadAccountHandle,
                                   &ConflictingAccountRid );

                    if ( NtStatus == STATUS_USER_EXISTS ) {

                        //
                        // Create a different type - a group - with the
                        // user's RID.  Should get an error because of
                        // the RID collision.
                        //

                        NtStatus = SamICreateAccountByRid(
                                       DomainHandle,
                                       SamObjectGroup,
                                       RelativeId,
                                       &AccountName,
                                       0L,
                                       &BadAccountHandle,
                                       &ConflictingAccountRid );

                        if ( NtStatus == STATUS_USER_EXISTS ) {

                            //
                            // Try a different type - a group - with a
                            // different name, but still the same RID.
                            // This should still fail due to the RID
                            // collision.
                            //

                            NtStatus = SamICreateAccountByRid(
                                           DomainHandle,
                                           SamObjectGroup,
                                           RelativeId,
                                           &AccountName2,
                                           0L,
                                           &BadAccountHandle,
                                           &ConflictingAccountRid );

                            if ( NtStatus == STATUS_USER_EXISTS ) {

                                //
                                // Create a group with the user's name, but
                                // a different RID.  This should fail
                                // because of the name collision.
                                //

                                NtStatus = SamICreateAccountByRid(
                                               DomainHandle,
                                               SamObjectGroup,
                                               RelativeId + 1,
                                               &AccountName,
                                               GROUP_ALL_ACCESS,
                                               &GroupAccountHandle,
                                               &ConflictingAccountRid );

                                if ( NT_SUCCESS( NtStatus ) ) {

                                    //
                                    // Ack!  This shouldn't have happened.
                                    // Close and delete the group we just created.
                                    //

                                    TmpStatus = SamrDeleteGroup( &GroupAccountHandle );
                                    ASSERT( NT_SUCCESS( TmpStatus ) );
                                    NtStatus = STATUS_UNSUCCESSFUL;

                                }  else {

                                    if ( NtStatus == STATUS_USER_EXISTS ) {

                                        NtStatus = STATUS_SUCCESS;
                                        AllTestsCompleted = TRUE;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            //
            // Now delete the user.
            //

            TmpStatus = SamrDeleteUser( &UserAccountHandle );
            ASSERT( NT_SUCCESS( TmpStatus ) );
        }

        if ( ( !AllTestsCompleted ) && ( NtStatus == STATUS_SUCCESS ) ) {

            //
            // STATUS_SUCCESS means everything succeeded (it was set after
            // the last one succeeded) or a test that was supposed to fail
            // didn't.  If the former, set an error.
            //

            NtStatus = STATUS_UNSUCCESSFUL;
        }
    }

    return( NtStatus );

#else

    return( STATUS_NOT_IMPLEMENTED );

#endif  // SAM_SERVER_TESTS

}



NTSTATUS
SamrTestPrivateFunctionsUser(
    IN SAMPR_HANDLE UserHandle
    )

/*++

Routine Description:

    This service is called to test functions that are normally only
    accessible inside the security process.


Arguments:

    UserHandle - Handle to the user being tested.

Return Value:

    STATUS_SUCCESS - The tests completed successfully.

    Any errors are as propogated from the tests.


--*/
{

#if SAM_SERVER_TESTS

    UNICODE_STRING WorkstationsU, LogonWorkstationU;
    LOGON_HOURS LogonHours;
    PVOID LogonHoursPointer, WorkstationsPointer;
    LARGE_INTEGER LogoffTime, KickoffTime;
    NTSTATUS NtStatus, TmpStatus;
    SAMI_PRIVATE_DATA_TYPE DataType = SamPrivateDataPassword;
    PVOID   PasswordDataPointer = NULL;
    PCHAR   BufferPointer;
    ULONG   OriginalDataLength = 0;
    ULONG   DataLength = 0;
    USHORT  i;
    BOOLEAN SensitiveData = FALSE;
    SAMI_PRIVATE_DATA_PASSWORD_TYPE LocalPasswordData;
    PSAMI_PRIVATE_DATA_PASSWORD_TYPE PasswordData1;
    PSAMI_PRIVATE_DATA_PASSWORD_TYPE PasswordData2;
    PUSER_ALL_INFORMATION All = NULL;
    PUSER_ALL_INFORMATION All2 = NULL;

    SAMTRACE("SamrTestPrivateFunctionsUser");

    // --------------------------------------------------------------
    // Test Query and SetInformationUser for UserAllInformation level
    //
    // The handle is passed to us from user space.  Make it look like
    // a trusted handle so we can test the trusted stuff.
    //

    ((PSAMP_OBJECT)(UserHandle))->TrustedClient = TRUE;

    NtStatus = SamrQueryInformationUser(
                   UserHandle,
                   UserAllInformation,
                   (PSAMPR_USER_INFO_BUFFER *)&All
                   );

    if ( NT_SUCCESS( NtStatus ) ) {

        //
        // Now change some of the data, and set it
        //

        RtlInitUnicodeString( (PUNICODE_STRING)(&All->FullName), L"FullName" );

        RtlInitUnicodeString( (PUNICODE_STRING)(&All->HomeDirectory), L"HomeDirectory" );

        RtlInitUnicodeString(
            (PUNICODE_STRING)(&All->HomeDirectoryDrive),
            L"HomeDirectoryDrive"
            );

        RtlInitUnicodeString(
            (PUNICODE_STRING)(&All->ScriptPath),
            L"ScriptPath"
            );

        RtlInitUnicodeString(
            (PUNICODE_STRING)(&All->ProfilePath),
            L"ProfilePath"
            );

        RtlInitUnicodeString(
            (PUNICODE_STRING)(&All->AdminComment),
            L"AdminComment"
            );

        RtlInitUnicodeString(
            (PUNICODE_STRING)(&All->WorkStations),
            L"WorkStations"
            );

        RtlInitUnicodeString(
            (PUNICODE_STRING)(&All->UserComment),
            L"UserComment"
            );

        RtlInitUnicodeString(
            (PUNICODE_STRING)(&All->Parameters),
            L"Parameters"
            );

        RtlInitUnicodeString(
            (PUNICODE_STRING)(&All->NtPassword),
            L"12345678"
            );

        RtlInitUnicodeString(
            (PUNICODE_STRING)(&All->LmPassword),
            L"87654321"
            );

        All->BadPasswordCount = 5;
        All->LogonCount = 6;
        All->CountryCode = 7;
        All->CodePage = 8;

        All->PasswordExpired = TRUE;
        All->NtPasswordPresent = TRUE;
        All->LmPasswordPresent = TRUE;

        All->LogonHours.UnitsPerWeek = 7;

        All->WhichFields =
                            USER_ALL_FULLNAME |
                            USER_ALL_HOMEDIRECTORY |
                            USER_ALL_HOMEDIRECTORYDRIVE |
                            USER_ALL_SCRIPTPATH |
                            USER_ALL_PROFILEPATH |
                            USER_ALL_ADMINCOMMENT |
                            USER_ALL_WORKSTATIONS |
                            USER_ALL_USERCOMMENT |
                            USER_ALL_PARAMETERS |
                            USER_ALL_BADPASSWORDCOUNT |
                            USER_ALL_LOGONCOUNT |
                            USER_ALL_COUNTRYCODE |
                            USER_ALL_CODEPAGE |
                            USER_ALL_PASSWORDEXPIRED |
                            USER_ALL_LMPASSWORDPRESENT |
                            USER_ALL_NTPASSWORDPRESENT |
                            USER_ALL_LOGONHOURS;

        NtStatus = SamrSetInformationUser(
                       UserHandle,
                       UserAllInformation,
                       (PSAMPR_USER_INFO_BUFFER)All
                       );

        if ( NT_SUCCESS( NtStatus ) ) {

            NtStatus = SamrQueryInformationUser(
                           UserHandle,
                           UserAllInformation,
                           (PSAMPR_USER_INFO_BUFFER *)&All2
                           );

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // Verify that queried info is as we set it
                //

                if (

                    //
                    // Fields that we didn't touch.  Note that private
                    // data and PasswordMustChange will change anyway
                    // due to password changes.
                    //

                    ( All2->WhichFields != (USER_ALL_READ_GENERAL_MASK    |
                                           USER_ALL_READ_LOGON_MASK       |
                                           USER_ALL_READ_ACCOUNT_MASK     |
                                           USER_ALL_READ_PREFERENCES_MASK |
                                           USER_ALL_READ_TRUSTED_MASK) ) ||
                    ( !(All->LastLogon.QuadPart == All2->LastLogon.QuadPart) ) ||
                    ( !(All->LastLogoff.QuadPart == All2->LastLogoff.QuadPart) ) ||
                    ( !(All->PasswordLastSet.QuadPart == All2->PasswordLastSet.QuadPart) ) ||
                    ( !(All->AccountExpires.QuadPart == All2->AccountExpires.QuadPart) ) ||
                    ( !(All->PasswordCanChange.QuadPart == All2->PasswordCanChange.QuadPart) ) ||
                    (  (All->PasswordMustChange.QuadPart == All2->PasswordMustChange.QuadPart) ) ||
                    (RtlCompareUnicodeString(
                        &(All->UserName),
                        &(All2->UserName),
                        FALSE) != 0) ||
                    (RtlCompareUnicodeString(
                        &(All->PrivateData),
                        &(All2->PrivateData),
                        FALSE) == 0) ||
                    ( All->SecurityDescriptor.Length !=
                        All2->SecurityDescriptor.Length ) ||
                    ( All->UserId != All2->UserId ) ||
                    ( All->PrimaryGroupId != All2->PrimaryGroupId ) ||
                    ( All->UserAccountControl != All2->UserAccountControl ) ||
                    ( All->PrivateDataSensitive !=
                        All2->PrivateDataSensitive ) ||

                    // Fields that we changed

                    (RtlCompareUnicodeString(
                        &(All->FullName),
                        &(All2->FullName),
                        FALSE) != 0) ||
                    (RtlCompareUnicodeString(
                        &(All->HomeDirectory),
                        &(All2->HomeDirectory),
                        FALSE) != 0) ||
                    (RtlCompareUnicodeString(
                        &(All->HomeDirectoryDrive),
                        &(All2->HomeDirectoryDrive),
                        FALSE) != 0) ||
                    (RtlCompareUnicodeString(
                        &(All->ScriptPath),
                        &(All2->ScriptPath),
                        FALSE) != 0) ||
                    (RtlCompareUnicodeString(
                        &(All->ProfilePath),
                        &(All2->ProfilePath),
                        FALSE) != 0) ||
                    (RtlCompareUnicodeString(
                        &(All->AdminComment),
                        &(All2->AdminComment),
                        FALSE) != 0) ||
                    (RtlCompareUnicodeString(
                        &(All->WorkStations),
                        &(All2->WorkStations),
                        FALSE) != 0) ||
                    (RtlCompareUnicodeString(
                        &(All->UserComment),
                        &(All2->UserComment),
                        FALSE) != 0) ||
                    (RtlCompareUnicodeString(
                        &(All->Parameters),
                        &(All2->Parameters),
                        FALSE) != 0) ||
                    ( All->BadPasswordCount != All2->BadPasswordCount ) ||
                    ( All->LogonCount != All2->LogonCount ) ||
                    ( All->CountryCode != All2->CountryCode ) ||
                    ( All->CodePage != All2->CodePage ) ||
                    ( All->PasswordExpired != All2->PasswordExpired ) ||
                    ( All->LmPasswordPresent != All2->LmPasswordPresent ) ||
                    ( All->NtPasswordPresent != All2->NtPasswordPresent ) ||
                    ( All->LogonHours.UnitsPerWeek !=
                        All2->LogonHours.UnitsPerWeek )
                    ) {

                    NtStatus = STATUS_DATA_ERROR;
                }

                MIDL_user_free( All2 );
            }
        }

        MIDL_user_free( All );
    }

    if ( !NT_SUCCESS( NtStatus ) ) {

        return( NtStatus );
    }

    // --------------------------------------------------------------
    // Test SamIAccountRestrictions
    // NOTE: We really should have more tests for this
    //

    RtlInitUnicodeString( &WorkstationsU, L"machine1,CHADS2   chads1" );

    NtStatus = SamrSetInformationUser(
                   UserHandle,
                   UserWorkStationsInformation,
                   (PSAMPR_USER_INFO_BUFFER) &WorkstationsU
                   );
    ASSERT( NT_SUCCESS( NtStatus ) ) ;

    LogonHours.UnitsPerWeek = 168;
    LogonHours.LogonHours = MIDL_user_allocate( 21 );
    ASSERT( LogonHours.LogonHours != NULL );

    for ( i = 0; i < 21; i++ ) {

        LogonHours.LogonHours[i] = 0xa1;
    }

    NtStatus = SamrSetInformationUser(
                   UserHandle,
                   UserLogonHoursInformation,
                   (PSAMPR_USER_INFO_BUFFER)&LogonHours
                   );
    ASSERT( NT_SUCCESS( NtStatus ) ) ;

    LogonHoursPointer = NULL;

    NtStatus = SamrQueryInformationUser(
                   UserHandle,
                   UserLogonHoursInformation,
                   (PSAMPR_USER_INFO_BUFFER *)&LogonHoursPointer
                   );
    ASSERT( NT_SUCCESS( NtStatus ) ) ;

    WorkstationsPointer = NULL;

    NtStatus = SamrQueryInformationUser(
                   UserHandle,
                   UserWorkStationsInformation,
                   (PSAMPR_USER_INFO_BUFFER *)&WorkstationsPointer
                   );
    ASSERT( NT_SUCCESS( NtStatus ) ) ;

    RtlInitUnicodeString( &WorkstationsU, L"ChadS2" );

    NtStatus = SamIAccountRestrictions(
                   UserHandle,
                   &LogonWorkstation,
                   WorkstationsPointer,
                   LogonHoursPointer,
                   &LogoffTime,
                   &KickoffTime
                   );

    if ( NtStatus == STATUS_INVALID_LOGON_HOURS ) {

        //
        // We hate to use 0xff all the time as a test value, but using
        // 0xA1 as a test value means that this test may fail depending
        // on when it runs.  So only IF we get this error, will we try
        // again with 0xff as the logon hours.
        //

        LogonHours.UnitsPerWeek = 168;

        for ( i = 0; i < 21; i++ ) {

            LogonHours.LogonHours[i] = 0xff;
        }

        NtStatus = SamrSetInformationUser(
                       UserHandle,
                       UserLogonHoursInformation,
                       (PSAMPR_USER_INFO_BUFFER)&LogonHours
                       );
        ASSERT( NT_SUCCESS( NtStatus ) ) ;

        MIDL_user_free( LogonHoursPointer );
        LogonHoursPointer = NULL;

        NtStatus = SamrQueryInformationUser(
                       UserHandle,
                       UserLogonHoursInformation,
                       (PSAMPR_USER_INFO_BUFFER *)&LogonHoursPointer
                       );
        ASSERT( NT_SUCCESS( NtStatus ) ) ;

        NtStatus = SamIAccountRestrictions(
                       UserHandle,
                       &LogonWorkstationU,
                       WorkstationsPointer,
                       LogonHoursPointer,
                       &LogoffTime,
                       &KickoffTime
                       );
    }

    MIDL_user_free( LogonHours.LogonHours );

    MIDL_user_free( LogonHoursPointer );
    MIDL_user_free( WorkstationsPointer );

    if ( !NT_SUCCESS( NtStatus ) ) {

        return( NtStatus );
    }

#if 0

    //
    // SamISetPrivateData/SamTGetPrivateData is broken in that the structure it
    // expects is not marshalled with respect to different platforms
    //

    // --------------------------------------------------------------
    // Test SamIGetPrivateData
    //

    NtStatus = SamIGetPrivateData(
                   UserHandle,
                   &DataType,
                   &SensitiveData,
                   &OriginalDataLength,
                   &PasswordDataPointer );

    if ( NT_SUCCESS( NtStatus ) ) {

        PasswordData1 = (PSAMI_PRIVATE_DATA_PASSWORD_TYPE)PasswordDataPointer;

        if ( ( !( OriginalDataLength >= sizeof( SAMI_PRIVATE_DATA_PASSWORD_TYPE ) ) ) ||
            ( SensitiveData != TRUE ) ||
            ( PasswordData1->DataType != SamPrivateDataPassword ) ) {

            NtStatus = STATUS_DATA_ERROR;
        }
    }



    // --------------------------------------------------------------
    // Now test SamISetPrivateData() for user objects.
    //

    if ( NT_SUCCESS( NtStatus ) ) {

        //
        // First do a random user set to make sure we don't blow up.
        //

        LocalPasswordData.DataType = SamPrivateDataPassword;

        LocalPasswordData.CaseInsensitiveDbcs.Length = ENCRYPTED_LM_OWF_PASSWORD_LENGTH;
        LocalPasswordData.CaseInsensitiveDbcs.MaximumLength = ENCRYPTED_LM_OWF_PASSWORD_LENGTH;
        LocalPasswordData.CaseInsensitiveDbcs.Buffer = (PWSTR)&(LocalPasswordData.CaseInsensitiveDbcsBuffer);

        BufferPointer = (PCHAR)&(LocalPasswordData.CaseInsensitiveDbcsBuffer);

        for ( i = 0; i < ENCRYPTED_LM_OWF_PASSWORD_LENGTH; i++ ) {

            *BufferPointer++ = (CHAR)(i + 12);
        }

        LocalPasswordData.CaseSensitiveUnicode.Length = ENCRYPTED_NT_OWF_PASSWORD_LENGTH;
        LocalPasswordData.CaseSensitiveUnicode.MaximumLength = ENCRYPTED_NT_OWF_PASSWORD_LENGTH;
        LocalPasswordData.CaseSensitiveUnicode.Buffer = (PWSTR)&(LocalPasswordData.CaseSensitiveUnicodeBuffer);

        BufferPointer = (PCHAR)(&LocalPasswordData.CaseSensitiveUnicodeBuffer);

        for ( i = 0; i < ENCRYPTED_NT_OWF_PASSWORD_LENGTH; i++ ) {

            *BufferPointer++ = (CHAR)(i + 47);
        }

        LocalPasswordData.LmPasswordHistory.Length = 0;
        LocalPasswordData.LmPasswordHistory.MaximumLength = 0;
        LocalPasswordData.LmPasswordHistory.Buffer = (PWSTR)
            ( &LocalPasswordData + sizeof( SAMI_PRIVATE_DATA_PASSWORD_TYPE ) );

        LocalPasswordData.NtPasswordHistory.Length = 0;
        LocalPasswordData.NtPasswordHistory.MaximumLength = 0;
        LocalPasswordData.NtPasswordHistory.Buffer = (PWSTR)
            ( &LocalPasswordData + sizeof( SAMI_PRIVATE_DATA_PASSWORD_TYPE ) );

        NtStatus = SamISetPrivateData(
                       UserHandle,
                       sizeof( LocalPasswordData ),
                       &LocalPasswordData
                       );

        if ( NT_SUCCESS( NtStatus ) ) {

            //
            // Now do a user get to make sure our set worked.
            //

            NtStatus = SamIGetPrivateData(
                           UserHandle,
                           &DataType,
                           &SensitiveData,
                           &DataLength,
                           &PasswordDataPointer );

            if ( NT_SUCCESS( NtStatus ) ) {

                //
                // Verify the data is as we set it.
                //

                PasswordData2 = (PSAMI_PRIVATE_DATA_PASSWORD_TYPE)PasswordDataPointer;

                if ( ( PasswordData2->DataType != LocalPasswordData.DataType ) ||

                    ( PasswordData2->CaseInsensitiveDbcs.Length != LocalPasswordData.CaseInsensitiveDbcs.Length ) ||

                    ( PasswordData2->CaseSensitiveUnicode.Length != LocalPasswordData.CaseSensitiveUnicode.Length ) ||

                    ( PasswordData2->LmPasswordHistory.Length != LocalPasswordData.LmPasswordHistory.Length ) ||

                    ( PasswordData2->NtPasswordHistory.Length != LocalPasswordData.NtPasswordHistory.Length ) ||

                    ( RtlCompareMemory(
                          &LocalPasswordData.CaseInsensitiveDbcsBuffer,
                          &(PasswordData2->CaseInsensitiveDbcsBuffer),
                          ENCRYPTED_LM_OWF_PASSWORD_LENGTH) != ENCRYPTED_LM_OWF_PASSWORD_LENGTH ) ||

                    ( RtlCompareMemory(
                          &LocalPasswordData.CaseSensitiveUnicodeBuffer,
                          &(PasswordData2->CaseSensitiveUnicodeBuffer),
                          ENCRYPTED_NT_OWF_PASSWORD_LENGTH) != ENCRYPTED_NT_OWF_PASSWORD_LENGTH )

                    ) {

                    NtStatus = STATUS_DATA_ERROR;
                }

                //
                // Now do a user set to restore things to their original state.
                //

                TmpStatus = SamISetPrivateData(
                               UserHandle,
                               OriginalDataLength,
                               PasswordData1
                               );

                if ( NT_SUCCESS( NtStatus ) ) {

                    NtStatus = TmpStatus;
                }
            }
        }

        if ( PasswordData1 != NULL ) {

            MIDL_user_free( PasswordData1 );
        }

        if ( PasswordData2 != NULL ) {

            MIDL_user_free( PasswordData2 );
        }
    }

    return( NtStatus );

#endif

#else

    return( STATUS_NOT_IMPLEMENTED );

#endif  // SAM_SERVER_TESTS

}



NTSTATUS
SampBuildDomainKeyName(
    OUT PUNICODE_STRING DomainKeyName,
    IN PUNICODE_STRING DomainName OPTIONAL
    )

/*++

Routine Description:

    This routine builds the name of a domain registry key.
    The name produced is relative to the SAM root and will be the name of
    key whose name is the name of the domain.

    The name built up is comprized of the following components:

        1) The constant named domain parent key name ("DOMAINS").

        2) A backslash

        3) The name of the domain.


    For example, given a DomainName of "ABC_DOMAIN" this would
    yield a resultant DomainKeyName of "DOMAINS\ABC_DOMAIN"



    All allocation for this string will be done using MIDL_user_allocate.
    Any deallocations will be done using MIDL_user_free.



Arguments:

    DomainKeyName - The address of a unicode string whose buffer is to be
        filled in with the full name of the registry key.  If successfully
        created, this string must be released with SampFreeUnicodeString()
        when no longer needed.


    DomainName - The name of the domain.  This string is not modified.


Return Value:

    STATUS_SUCCESS - DomainKeyName points at the full key name.

--*/
{
    NTSTATUS NtStatus;
    USHORT TotalLength, DomainNameLength;

    SAMTRACE("SampBuildDomainKeyName");

    //
    // Allocate a buffer large enough to hold the entire name.
    // Only count the domain name if it is passed.
    //

    DomainNameLength = 0;
    if (ARGUMENT_PRESENT(DomainName)) {
        DomainNameLength = DomainName->Length + SampBackSlash.Length;
    }

    TotalLength =   SampNameDomains.Length          +
                    DomainNameLength               +
                    (USHORT)(sizeof(UNICODE_NULL)); // for null terminator

    NtStatus = SampInitUnicodeString( DomainKeyName, TotalLength );
    if (NT_SUCCESS(NtStatus)) {

        //
        // "DOMAINS"
        //

        NtStatus = SampAppendUnicodeString( DomainKeyName, &SampNameDomains);
        if (NT_SUCCESS(NtStatus)) {

            if (ARGUMENT_PRESENT(DomainName)) {

                //
                // "DOMAINS\"
                //

                NtStatus = SampAppendUnicodeString( DomainKeyName, &SampBackSlash );
                if (NT_SUCCESS(NtStatus)) {

                    //
                    // "DOMAINS\(domain name)"
                    //

                    NtStatus = SampAppendUnicodeString(
                                   DomainKeyName,
                                   DomainName
                                   );
                }
            }
        }
    }


    //
    // Clean-up on failure
    //

    if (!NT_SUCCESS(NtStatus)) {
        SampFreeUnicodeString( DomainKeyName );
    }

    return(NtStatus);

}

//
// SampDsGetPrimaryDomainStart is used to correctly set the starting index in the
// SampDefinedDomains array whenever it is accessed in the SAM code. In the
// case of an NT workstation or member server, the first two entries of the
// array correspond to registry data, hence the index is started at zero. In
// the case of a domain controller, the DS-based data is not stored in the
// first two elements (those may be used for crash-recovery data, still ob-
// tained from the registry), but rather in subsequent array elements, hence
// is start at index DOMAIN_START_DS.
//

ULONG
SampDsGetPrimaryDomainStart(VOID)
{
    ULONG   DomainStart = DOMAIN_START_REGISTRY;

    if (TRUE == SampUseDsData)
    {
        // Domain Controller
        DomainStart = DOMAIN_START_DS;
    }

    return DomainStart;
}


NTSTATUS
SampSetMachineAccountOwnerDuringDCPromo(
    IN PDSNAME pDsName,
    IN PSID    NewOwner
    )
/*++
Routine Description:

    This routine does

    1. Set the Owner of the Machine Account to Domain Administrators Group
    2. Add ms-ds-CreatorSid attribute to this machine account. The creator
       SID indicates the real creator of this machine.

    Should Only been called for machine account created by privilege.

Parameters:

    pDsName -- Object DS Name

    NewOwner -- New Owner in the Security descriptor

Return Values:

    STATUS_SUCCESS
    STATUS_INTERNAL_ERROR
    or other DS returned error

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    ATTRTYP  AttrTypToRead[] = {SAMP_USER_SECURITY_DESCRIPTOR};
    ATTRVAL  AttrValsToRead[] = {0, NULL};
    DEFINE_ATTRBLOCK1(AttrsToRead, AttrTypToRead, AttrValsToRead);
    ATTRBLOCK   ReadAttrs;

    ATTRTYP  AttrTypToSet[] = {SAMP_USER_SECURITY_DESCRIPTOR, SAMP_USER_CREATOR_SID};
    ATTRVAL  AttrValsToSet[] = { {0, NULL}, {0, NULL} };
    DEFINE_ATTRBLOCK2(AttrsToSet, AttrTypToSet, AttrValsToSet);

    PSID    CreatorOwner = NULL;
    PSID    Group = NULL;
    PACL    Dacl = NULL;
    PACL    Sacl = NULL;
    PSECURITY_DESCRIPTOR OldDescriptor = NULL;
    PSECURITY_DESCRIPTOR NewDescriptor = NULL;
    ULONG   NewDescriptorLength = 0;


    //
    // Retrieve the old security descriptor
    //
    NtStatus = SampDsRead(pDsName,
                          0,
                          SampUserObjectType,
                          &AttrsToRead,
                          &ReadAttrs
                          );

    if (NT_SUCCESS(NtStatus))
    {
        if ((1==ReadAttrs.attrCount) &&
            (NULL != ReadAttrs.pAttr) &&
            (1==ReadAttrs.pAttr[0].AttrVal.valCount) &&
            (NULL!=ReadAttrs.pAttr[0].AttrVal.pAVal) )
        {
            OldDescriptor = (PSECURITY_DESCRIPTOR)ReadAttrs.pAttr[0].AttrVal.pAVal[0].pVal;

            CreatorOwner = GetOwner(OldDescriptor);
            Group = GetGroup(OldDescriptor);
            Sacl = GetSacl(OldDescriptor);
            Dacl = GetDacl(OldDescriptor);

            if (CreatorOwner && Group && Sacl && Dacl)
            {
                //
                // Construct new security descriptor with the desired Owner
                //
                NtStatus = SampMakeNewSelfRelativeSecurityDescriptor(
                                    NewOwner,
                                    Group,
                                    Dacl,
                                    Sacl,
                                    &NewDescriptorLength,
                                    &NewDescriptor
                                    );

                if (NT_SUCCESS(NtStatus))
                {
                    //
                    // Set the New Security Descriptor
                    //
                    AttrsToSet.pAttr[0].AttrVal.pAVal[0].pVal = (PUCHAR) NewDescriptor;
                    AttrsToSet.pAttr[0].AttrVal.pAVal[0].valLen = NewDescriptorLength;

                    //
                    // Add ms-ds-CreatorSid attribute
                    //
                    AttrsToSet.pAttr[1].AttrVal.pAVal[0].pVal = (PUCHAR) CreatorOwner;
                    AttrsToSet.pAttr[1].AttrVal.pAVal[0].valLen = RtlLengthSid(CreatorOwner);

                    //
                    // Call into DS api with SAM_LAZY_COMMIT flag
                    //
                    NtStatus = SampDsSetAttributes(
                                        pDsName,
                                        SAM_LAZY_COMMIT,    // during DCPromo,
                                        REPLACE_ATT,
                                        SampUserObjectType,
                                        &AttrsToSet
                                        );
                }
            }
            else
            {
                NtStatus = STATUS_INTERNAL_ERROR;
            }
        }
    }

    //
    // Free memory if necessary
    //
    if (NULL != NewDescriptor)
    {
        MIDL_user_free(NewDescriptor);
    }

    return NtStatus;
}


VOID
SampDenyDeletion(
    IN PSID OldOwner,
    IN OUT PACL DAcl
    )
/*++
Routine Description:

    Users can create machine account in domain if they have the
    privilege. The default security descriptor will grant deletion
    right to the creator owner. Since deleted machine accounts
    (tombstone) are no longer counted during MachineAccountQuota
    calculation, we need to make sure the privileged machine
    account creator owner can not delete the machine account.

    This routine scans the DACL on the machine object, remove
    the deletion access from any GRANT aces in the DACL that
    have the OldOwner SID in the ACE.


Arguments:

    OldOwner - Indicator the SID the ACE should be applied to.

    DAcl - pointer to DACL

Return Value:

    None.

--*/
{
    ACE     *pAce = NULL;
    PSID    pSid = NULL;
    ULONG   i;

    for (i = 0; i < DAcl->AceCount; i++)
    {
        // get the i'st ACE
        pAce = GetAcePrivate(DAcl, i);

        if (NULL == pAce)
        {
            continue;
        }

        //
        // we did not check ACCESS_ALLOWED_OBJECT_ACE because
        //
        // 1. change the default schema is a rare operation
        //    we don't expect to happen so often.
        //
        // 2. Even we check ACCESS_ALLOWED_OBJECT_ACE, administrators
        //    can still grant other access to the trustee (SID inside
        //    the ACE), such as create child access right, which will
        //    introduce the similar deny service attack
        //

        if (IsAccessAllowedAce(pAce) &&
            !(INHERIT_ONLY_ACE & ((PACE_HEADER)pAce)->AceFlags))
        {
            pSid = SidFromAce(pAce);

            if ((NULL!=pSid) && 
                (RtlEqualSid(OldOwner, pSid)))
            {
                ACCESS_MASK * AccessMask;

                AccessMask = &(((ACCESS_ALLOWED_ACE*)pAce)->Mask);
                (*AccessMask) &= (~(ACTRL_DS_DELETE_TREE|DELETE));

                continue;
            }
        }
    }

    return;
}




NTSTATUS
SampSetMachineAccountOwner(
    IN PSAMP_OBJECT UserContext,
    IN PSID NewOwner
    )
/*++
Routine Description:

    This routine sets the Owner in the passed in User's Security
    Descriptor.

Parameters:

    UserContext -- User Context

    NewOwner -- Pointer to a SID (new owner)

Return Values:

    NTSTATUS Code - STATUS_SUCCESS or other if error

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PSECURITY_DESCRIPTOR OldDescriptor = NULL;
    PSECURITY_DESCRIPTOR NewDescriptor = NULL;
    ULONG   NewDescriptorLength = 0;
    PSID    OldOwner = NULL;
    PSID    Group = NULL;
    PACL    Dacl = NULL;
    PACL    Sacl = NULL;
    ULONG   Revision;

    //
    // Get the current security descriptor so we can
    // change the owner field.
    //

    NtStatus = SampGetAccessAttribute(
                            UserContext,
                            SAMP_USER_SECURITY_DESCRIPTOR,
                            FALSE,   // don't make copy
                            &Revision,
                            &OldDescriptor
                            );

    if (NT_SUCCESS(NtStatus))
    {
        OldOwner = GetOwner(OldDescriptor);
        Group = GetGroup(OldDescriptor);
        Sacl = GetSacl(OldDescriptor);
        Dacl = GetDacl(OldDescriptor);


        if (OldOwner && Dacl)
        {
            SampDenyDeletion(OldOwner, Dacl);
        }

        if (Group && Sacl && Dacl)
        {
            //
            // Construct the new Security Descriptor using
            // the Administrators Alias SID as the owner
            //
            NtStatus = SampMakeNewSelfRelativeSecurityDescriptor(
                                    NewOwner,
                                    Group,
                                    Dacl,
                                    Sacl,
                                    &NewDescriptorLength,
                                    &NewDescriptor
                                    );

        }
        else
        {
            NtStatus = STATUS_INTERNAL_ERROR;
        }
    }

    if ( NT_SUCCESS( NtStatus ) )
    {
        //
        // Write the new security descriptor into the object
        //
        NtStatus = SampSetAccessAttribute(
                            UserContext,
                            SAMP_USER_SECURITY_DESCRIPTOR,
                            NewDescriptor,
                            NewDescriptorLength
                            );
    }

    if (NULL != NewDescriptor)
    {
        MIDL_user_free(NewDescriptor);
    }

    return NtStatus;
}



NTSTATUS
SampCheckQuotaForPrivilegeMachineAccountCreation(
    VOID
    )
/*++
Routine Description

    First, this routine reads value of attribute (ms-ds-MachineAccountQuota)
    from Domain Object.

    Second, search how many machine accounts have been created by the current
    logged on user.

    Based on per-Domain Quota and used quota, figure out whether there is quota
    left or not.

Parameter

    None

Return Value

    STATUS_SUCCESS -- There is quota left.

    error

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       MachineAccountQuota = 0;
    ULONG       UsedQuota = 0;
    PTOKEN_OWNER    Owner = NULL;
    PTOKEN_PRIMARY_GROUP    PrimaryGroup = NULL;
    ATTRTYP     AttrTypToRead[] = {SAMP_DOMAIN_MACHINE_ACCOUNT_QUOTA};
    ATTRVAL     AttrValsToRead[] = {0, NULL};
    DEFINE_ATTRBLOCK1(AttrsToRead, AttrTypToRead, AttrValsToRead);
    ATTRBLOCK   ReadAttrs;
    PULONG  FilterValue = NULL;


    ASSERT(SampUseDsData);
    if (!SampUseDsData)
    {
        return NtStatus;
    }

    //
    // set fDSA, otherwise, the client might be denied for reading
    // the Domain Object or searching deleted object.
    //
    SampSetDsa(TRUE);

    //
    // Read the highest Quota from the Domain Object.
    // This value could be changed by Administrator etc.
    //

    NtStatus = SampDsRead(ROOT_OBJECT,          // object
                          0,                    // Flags
                          SampDomainObjectType, // SAM object type
                          &AttrsToRead,         // attribute to read
                          &ReadAttrs            // result
                          );

    if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE == NtStatus)
    {
        //
        // per-domain Quota is not set yet.
        // Maybe administrator does not want to enforce the quota.
        //
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "Read Machine Account Quota Failed. Machine Quota may not be set yet.\n"));

        return STATUS_SUCCESS;
    }
    else if (NT_SUCCESS(NtStatus))
    {
        //
        // Machine Account Quota has been set. retrieve the value
        //
        ASSERT(1 == ReadAttrs.attrCount);
        ASSERT(NULL != ReadAttrs.pAttr);
        ASSERT(1 == ReadAttrs.pAttr[0].AttrVal.valCount);
        ASSERT(NULL != ReadAttrs.pAttr[0].AttrVal.pAVal);


        if ((1 == ReadAttrs.attrCount) &&
            (NULL != ReadAttrs.pAttr) &&
            (1 == ReadAttrs.pAttr[0].AttrVal.valCount) &&
            (NULL != ReadAttrs.pAttr[0].AttrVal.pAVal) )
        {
            // retrieve the machineAccoutQuota
            MachineAccountQuota = * ((ULONG *)ReadAttrs.pAttr[0].AttrVal.pAVal[0].pVal);
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "Machine Account Quota is %d\n", MachineAccountQuota));
        }
    }

    //
    // Figure out the quota consumed.
    //
    if (NT_SUCCESS(NtStatus))
    {
        FILTER  DsFilter;
        ULONG   SamAccountTypeLo, SamAccountTypeHi;
        ULONG   MaximumNumberOfEntries;
        SEARCHRES   *SearchRes = NULL;
        ATTRTYP AttrTypesToSrch[] = { SAMP_FIXED_USER_ACCOUNT_CONTROL };
        ATTRVAL AttrValsToSrch[] = {0, NULL};
        DEFINE_ATTRBLOCK1(AttrsToSrch, AttrTypesToSrch, AttrValsToSrch);

        //
        // Get the current client's Self SID from client token
        //
        NtStatus = SampGetCurrentOwnerAndPrimaryGroup(
                                 &Owner,
                                 &PrimaryGroup
                                 );
        if (!NT_SUCCESS(NtStatus))
            goto Error;

        //
        // build DS Filter
        //
        RtlZeroMemory(&DsFilter, sizeof(FILTER));

        DsFilter.choice = FILTER_CHOICE_ITEM;
        DsFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
        DsFilter.FilterTypes.
            Item.FilTypes.ava.type = ATT_MS_DS_CREATOR_SID;
        DsFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = RtlLengthSid(Owner->Owner);


        //
        // Copy Self SID
        //
        FilterValue = MIDL_user_allocate(RtlLengthSid(Owner->Owner));
        if (NULL == FilterValue)
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Error;
        }

        RtlZeroMemory(FilterValue, RtlLengthSid(Owner->Owner));
        RtlCopyMemory(FilterValue, Owner->Owner, RtlLengthSid(Owner->Owner));

        DsFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (UCHAR *)FilterValue;


        //
        // Call SampDsDoSearch(); do NOT include deleted objects
        //
        NtStatus = SampDsDoSearch2(0,
                                   NULL,
                                   ROOT_OBJECT,
                                   &DsFilter,
                                   0,
                                   SampUserObjectType,
                                   &AttrsToSrch,
                                   (0 == MachineAccountQuota) ? 2: MachineAccountQuota + 1,
                                   0,
                                   &SearchRes
                                   );

        //
        // Get Used Quota
        //
        if ( !NT_SUCCESS(NtStatus) || (NULL == SearchRes) )
        {
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "SampDsDoSearch2 Failed NtStatus ==> %x\n",
                       NtStatus));

            goto Error;
        }

        ASSERT(NULL != SearchRes);
        UsedQuota = SearchRes->count;
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "Used Quota is %d\n",
                   UsedQuota));
    }

    //
    // Check whether the creator still have quota or not
    //
    if (NT_SUCCESS(NtStatus))
    {
        if (UsedQuota >= MachineAccountQuota)
        {
            NtStatus = STATUS_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED;
            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "Machine Account Quota Exceeded\n"));
        }
    }

Error:

    if (FilterValue)
    {
        MIDL_user_free(FilterValue);
    }

    if (Owner)
    {
        MIDL_user_free(Owner);
    }

    if (PrimaryGroup)
    {
        MIDL_user_free(PrimaryGroup);
    }

    return NtStatus;
}



NTSTATUS
SampDoUserCreationChecks(
    IN PSAMP_OBJECT DomainContext,
    IN  ULONG   AccountType,
    OUT BOOLEAN *CreateByPrivilege,
    OUT ULONG   *pAccessRestriction
    )
/*++

    This Routine Does the Appropriate Sam Access Checks for creating Users.
    Access checks done are different for DS and Registry Mode. In DS mode
    fDSA is typically reset, so that the DS does the appropriate access check,
    except for the case where a machine account is created through privileges.


    DomainContext -- Pointer to the Domain Object Context
    AccountType   -- Specifies the account type field
    fCreateByPrivilege -- Indicates that a machine account creation is proceeding by
                          privilege

    Return Values:

        STATUS_SUCCESS
        STATUS_ACCESS_DENIED
        STATUS_INVALID_DOMAIN_ROLE

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    NTSTATUS    IgnoreStatus;
    SAMP_OBJECT_TYPE FoundType;

    *CreateByPrivilege = FALSE;


    if (IsDsObject(DomainContext))
    {
        //
        // Don't need to set TransactionWithinDomain to FALSE, 
        // because we will do it in SampLookupContext as needed
        // 

        NtStatus = SampLookupContext(
                        DomainContext,
                        0, // No Accesses are required, Core DS will check access
                        SampDomainObjectType,
                        &FoundType
                        );

        //
        // In the DS case do the following
        //
        // 1. Trusted Clients always have access provided they opened the domain handle
        //    with the required access
        //
        // 2. Check if a machine account is being created, and if so then
        //    wether you have the privilege. If you have the privilege, then
        //    you create using the privilege. fDSA is set to true in this case
        //
        // 3. If you do not have the privilege then you may try your luck with the
        //    core DS. fDSA is set to false,the DS will do the access check and may
        //    return an access denied.
        //
        //    The way the access ck works is tat DOMIN_CREATE* access is always granted
        //    Here we test the mask to ensure that DOMAIN_CREATE was asked for while
        //    opening the handle. If the caller is not trusted we would set fDSA to false
        //    in order to delegate the ck to the core DS.
        //
        // 4. We do not apply the Privilege Test during Loopback cases. This is because
        //    we always want the DS access check to happen, as non SAM properties may be
        //    passed in and we do not know how to check these. Also note that the privilege
        //    definition is join workstations to domain, which technically speaking is
        //    different from creating a machine account through LDAP
        //
        // 5. InterDomain trust accounts are created only by trusted callers. Therefore enforce
        //    that the context is a trusted client if the account type is an intedomain trust
        //    account.
        //


        if (NT_SUCCESS(NtStatus))
        {
            //
            // Check the granted access field in the context
            //

            NtStatus = (DomainContext->GrantedAccess & DOMAIN_CREATE_USER)
                            ?STATUS_SUCCESS:STATUS_ACCESS_DENIED;

            //
            // Interdomain trust accounts can be created only by trusted callers
            //

            if ((NT_SUCCESS(NtStatus))
                && (AccountType==USER_INTERDOMAIN_TRUST_ACCOUNT)
                && (!DomainContext->TrustedClient))
            {
                NtStatus = STATUS_ACCESS_DENIED;
            }

            //
            // check whether the client has the right to create a Domain Controller
            // account.
            //

            //
            // the right required on the domain NC head to replicate is tested
            // at here
            //

            if ((NT_SUCCESS(NtStatus)) &&
                (!DomainContext->TrustedClient) &&
                (USER_SERVER_TRUST_ACCOUNT == AccountType))
            {
                NtStatus = SampValidateDomainControllerCreation(DomainContext);
            }

            if (NT_SUCCESS(NtStatus))
            {
                DSNAME  * LoopbackObject;




                if (!SampExistsDsLoopback(&LoopbackObject))
                {
                    //
                    // Apply the access and Privilege Checks as described above.
                    //

                    if (USER_WORKSTATION_TRUST_ACCOUNT==AccountType)
                    {
                        //
                        // Case of a Machine Account, Check to see if we have
                        // privileges to do so
                        //

                        NtStatus = SampRtlWellKnownPrivilegeCheck(
                                    TRUE,       // ImpersonateClient
                                    SE_MACHINE_ACCOUNT_PRIVILEGE,
                                    NULL        // ClientId - optional
                                    );

                        if (STATUS_PRIVILEGE_NOT_HELD==NtStatus)
                        {
                            //
                            // We do not have the privilege; Reset the status code
                            // to STATUS_SUCCESS. The DS may allow the creation if
                            // the caller had the right access
                            //

                            NtStatus = STATUS_SUCCESS;



                        }
                        else
                        {
                            //
                            // We are creating accounts, with the privilege. Turn off DS access
                            // checks. Note Access Restrictions do not apply in DS mode. We always
                            // obtain the security descriptor from the schema, and set owner and
                            // group appropriately
                            //

                            *CreateByPrivilege = TRUE;
                        }
                    }
                }
            }

            //
            // Dereference domain context when failure
            //
            if (!NT_SUCCESS(NtStatus))
            {
                IgnoreStatus = SampDeReferenceContext(DomainContext, FALSE);

                ASSERT(NT_SUCCESS(IgnoreStatus));
            }
        }
    }
    else
    {
        //
        // Registry Case. In this case first do the access check
        //

        SampSetTransactionWithinDomain(FALSE);

        NtStatus = SampLookupContext(
                        DomainContext,
                        DOMAIN_CREATE_USER,             // DesiredAccess
                        SampDomainObjectType,           // ExpectedType
                        &FoundType
                        );

        //
        // if we don't have DOMAIN_CREATE_USER access, then see
        // if we are creating a machine account and try for DOMAIN_LOOKUP.
        // If this works, then we can see if the client has
        // SE_CREATE_MACHINE_ACCOUNT_PRIVILEGE.
        //

        if ( (NtStatus == STATUS_ACCESS_DENIED) &&
             (AccountType == USER_WORKSTATION_TRUST_ACCOUNT) )
        {

            SampSetTransactionWithinDomain(FALSE);

            NtStatus = SampLookupContext(
                           DomainContext,
                           DOMAIN_LOOKUP,                   // DesiredAccess
                           SampDomainObjectType,            // ExpectedType
                           &FoundType
                           );

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = SampRtlWellKnownPrivilegeCheck(
                                    TRUE,       // ImpersonateClient
                                    SE_MACHINE_ACCOUNT_PRIVILEGE,
                                    NULL       // ClientId - optional
                                    );
                if (NtStatus == STATUS_PRIVILEGE_NOT_HELD)
                {
                    NtStatus = STATUS_ACCESS_DENIED;
                }

                if (NT_SUCCESS(NtStatus))
                {

                    //
                    // Tell our caller that we are creating by Privilege
                    //

                    *CreateByPrivilege = TRUE;
                    *pAccessRestriction = DELETE |
                                          USER_WRITE |
                                          USER_FORCE_PASSWORD_CHANGE;
                }
            }
        }
    }

    return NtStatus;
}

NTSTATUS
SampDoGroupCreationChecks(
    IN PSAMP_OBJECT DomainContext
    )
/*++

    This Routine Does the Appropriate Sam Access Checks for creating Groups
    Access checks done are different for DS and Registry Mode. In DS mode
    fDSA is typically reset, so that the DS does the appropriate access check,
    except for the case where a machine account is created through privileges.


    DomainContext -- Pointer to the Domain Object Context

        STATUS_SUCCESS
        STATUS_ACCESS_DENIED
        STATUS_INVALID_DOMAIN_ROLE

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    NTSTATUS    IgnoreStatus;
    SAMP_OBJECT_TYPE FoundType;


    if (IsDsObject(DomainContext))
    {

        //
        // Don't need to set TransactionWithinDomain to FALSE, 
        // because we will do it in SampLookupContext as needed
        // 

        NtStatus = SampLookupContext(
                        DomainContext,
                        0, // No Accesses are required, Core DS will check access
                        SampDomainObjectType,
                        &FoundType
                        );

        //
        // In the DS case do the following
        //
        // 1. Trusted Clients always have access. Check the domain handle and if
        //    its opened with the right access, they can sail through. The creation
        //    will then proceed with fDSA set.
        //
        // 2. Else fDSA will be set to false,the DS will do the access check and may
        //    return an access denied.
        //    The way the access ck works is tat DOMIN_CREATE* access is always granted
        //    Here we test the mask to ensure that DOMAIN_CREATE was asked for while
        //    opening the handle. If the caller is not trusted we would set fDSA to false
        //    in order to delegate the ck to the core DS.
        //



        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = (DomainContext->GrantedAccess & DOMAIN_CREATE_GROUP)
                        ?STATUS_SUCCESS:STATUS_ACCESS_DENIED;
        }

    }
    else
    {
        //
        // Registry Case. In this case first do the access check
        //

        SampSetTransactionWithinDomain(FALSE);

        NtStatus = SampLookupContext(
                        DomainContext,
                        DOMAIN_CREATE_GROUP,             // DesiredAccess
                        SampDomainObjectType,           // ExpectedType
                        &FoundType
                        );

    }

    return NtStatus;
}

NTSTATUS
SampDoAliasCreationChecks(
    IN PSAMP_OBJECT DomainContext
    )
/*++

    This Routine Does the Appropriate Sam Access Checks for creating Groups
    Access checks done are different for DS and Registry Mode. In DS mode
    fDSA is typically reset, so that the DS does the appropriate access check,
    except for the case where a machine account is created through privileges.


    DomainContext -- Pointer to the Domain Object Context

        STATUS_SUCCESS
        STATUS_ACCESS_DENIED
        STATUS_INVALID_DOMAIN_ROLE

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    NTSTATUS    IgnoreStatus;
    SAMP_OBJECT_TYPE FoundType;




    if (IsDsObject(DomainContext))
    {

        //
        // Don't need to set TransactionWithinDomain to FALSE, 
        // because we will do it in SampLookupContext as needed
        // 

        NtStatus = SampLookupContext(
                        DomainContext,
                        0, // No Accesses are required, Core DS will check access
                        SampDomainObjectType,
                        &FoundType
                        );

        //
        // In the DS case do the following
        //
        // 1. Trusted Clients always have access. Check the domain handle and if
        //    its opened with the right access, they can sail through. The creation
        //    will then proceed with fDSA set.
        //
        // 2. Else fDSA will be set to false,the DS will do the access check and may
        //    return an access denied.
        //    The way the access ck works is tat DOMIN_CREATE* access is always granted
        //    Here we test the mask to ensure that DOMAIN_CREATE was asked for while
        //    opening the handle. If the caller is not trusted we would set fDSA to false
        //    in order to delegate the ck to the core DS.


        if (NT_SUCCESS(NtStatus))
        {
             NtStatus = (DomainContext->GrantedAccess & DOMAIN_CREATE_ALIAS)
                            ?STATUS_SUCCESS:STATUS_ACCESS_DENIED;

        }

    }
    else
    {
        //
        // Registry Case. In this case first do the access check
        //

        SampSetTransactionWithinDomain(FALSE);

        NtStatus = SampLookupContext(
                        DomainContext,
                        DOMAIN_CREATE_ALIAS,             // DesiredAccess
                        SampDomainObjectType,           // ExpectedType
                        &FoundType
                        );


    }

    return NtStatus;
}



NTSTATUS
SampCheckForDuplicateSids(
    PSAMP_OBJECT DomainContext,
    ULONG   NewAccountRid
    )
/*++

    Routine Description
        This routine checks for the existance of an object with a RID that is
        about to be issued, in a seperate newly begun transaction. The purpose
        of the routine is for error checking only.

    Parameter:

        DomainContext -- The domain context in which to locate the RID

        NewAccountRid --- Rid of the new account

    Return Values

        STATUS_SUCCESS
        STATUS_INTERNAL_ERROR

  --*/
{
    PVOID   ExistingThreadState = NULL;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DSNAME  * ConflictingObject = NULL;

#if DBG
    #define ENABLE_DUPLICATE_SID_CHECKS 1
#endif
#ifdef ENABLE_DUPLICATE_SID_CHECKS

    if (TRUE==SampUseDsData)
    {
        //
        // In DS mode check for duplicates
        //
        //
        // Save the thread state.
        //

        ExistingThreadState = THSave();


        NtStatus = SampDsLookupObjectByRid(
                    SampDefinedDomains[DomainContext->DomainIndex].Context->ObjectNameInDs,
                    NewAccountRid,
                    &ConflictingObject
                    );

        if (NT_SUCCESS(NtStatus))
        {
            //
            // We Found an Object, Too Bad, we are about to issue a duplicate Sid
            //

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "About to Issue a Duplicate Sid. This condition should never "
                       "Legally occur and points to either a timing or transactioning "
                       "Problem \n"));

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "NewRid = %x\n",
                       NewAccountRid));

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "Conflicting Object = %x\n",ConflictingObject));

            KdPrintEx((DPFLTR_SAMSS_ID,
                       DPFLTR_INFO_LEVEL,
                       "Existing Thread State = %x\n",
                       ExistingThreadState));

            if ( IsDebuggerPresent())
               DebugBreak();
            NtStatus = STATUS_INTERNAL_ERROR;

            MIDL_user_free(ConflictingObject);
        }
        else
        {
            // We don't expect duplicate Sids

            NtStatus = STATUS_SUCCESS;
        }

        SampMaybeEndDsTransaction(TransactionCommit);

        THRestore(ExistingThreadState);
    }
    else
    {
        //
        // No Duplicate Sid detection in Registry Mode
        //
        NtStatus = STATUS_SUCCESS;
    }

#endif

    return NtStatus;
}

ULONG
SampDefaultPrimaryGroup(
    PSAMP_OBJECT    UserContext,
    ULONG           AccountType
    )
/*++

    Routine Description

        Returns the Default Primary Group given the User account
        control and the context

    Parameters

          UserContext -- The Context of the User
          AccountType -- The User account Control

    Return Values

          The Rid of the Primary Group
--*/
{

    //
    // Support for domain Computers and Domain Controllers is not yet
    // enabled. When this support is enabled the code in the #if 0 will
    // activated
    //


    if ((IsDsObject(UserContext))
                      && (AccountType & USER_WORKSTATION_TRUST_ACCOUNT))
    {
        return DOMAIN_GROUP_RID_COMPUTERS;
    }
    else if ((IsDsObject(UserContext))
          && (AccountType & USER_SERVER_TRUST_ACCOUNT))
    {
        return DOMAIN_GROUP_RID_CONTROLLERS;
    }
    else
    {
        return DOMAIN_GROUP_RID_USERS;
    }

    return (DOMAIN_GROUP_RID_USERS);

}



NTSTATUS
SamIDsCreateObjectInDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PRPC_UNICODE_STRING  AccountName,
    IN ULONG UserAccountType, 
    IN ULONG GroupType,
    IN ACCESS_MASK  DesiredAccess,
    OUT SAMPR_HANDLE *AccountHandle,
    OUT PULONG  GrantedAccess,
    IN OUT PULONG RelativeId
    )
/*++
Routine Description:

    This routine is used by DS (Loopback client) to create account in domain 

Parameters:

Return Values:

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    SAMTRACE("SamIDsCreateObjectInDomain");

    //
    // verify the object type, should be the one we know
    // 
    ASSERT((SampUserObjectType == ObjectType) ||
           (SampGroupObjectType == ObjectType) ||
           (SampAliasObjectType == ObjectType));


    switch (ObjectType)
    {
    case SampUserObjectType:

        ASSERT(0 != UserAccountType);

        NtStatus = SampCreateUserInDomain(
                                DomainHandle,       // DomainHandle
                                AccountName,        // AccountName
                                UserAccountType,    // User account type
                                DesiredAccess,      // Desired Access
                                FALSE,              // Write Lock Held
                                TRUE,               // Loopback Client
                                AccountHandle,      // Account Handle
                                GrantedAccess,      // GrantedAccess
                                RelativeId          // Object Rid
                                );
        break;

    case SampGroupObjectType:

        ASSERT(0 != GroupType);

        NtStatus = SampCreateGroupInDomain(
                                DomainHandle,       // DomainHandle
                                AccountName,        // Account Name
                                DesiredAccess,      // Desired Access
                                FALSE,              // Write Lock Held
                                TRUE,               // Loopback Client
                                GroupType,          // GroupType
                                AccountHandle,      // AccountHandle
                                RelativeId          // Object Rid
                                );

        break;

    case SampAliasObjectType:

        ASSERT(0 != GroupType);

        NtStatus = SampCreateAliasInDomain(
                                DomainHandle,       // DomainHandle
                                AccountName,        // AccountName
                                DesiredAccess,      // DesiredAccess
                                FALSE,              // WriteLockHeld
                                TRUE,               // Loopback Client
                                GroupType,          // Group Type
                                AccountHandle,      // AccountHandle
                                RelativeId          // Object Rid
                                );

        break;

    default:

        ASSERT(FALSE && "Wrong Object Type!");
        NtStatus = STATUS_INVALID_PARAMETER;
        break;
    }


    return( NtStatus );

}

WCHAR AccountNameEncodingTable[32] = {
L'0',L'1',L'2',L'3',L'4',L'5',L'6',L'7',
L'8',L'9',L'A',L'B',L'C',L'D',L'E',L'F',
L'G',L'H',L'I',L'J',L'K',L'L',L'M',L'N',
L'O',L'P',L'Q',L'R',L'S',L'T',L'U',L'V' };

NTSTATUS
SampGetAccountNameFromRid(
    OUT PRPC_UNICODE_STRING AccountName,
    IN ULONG Rid
    )
{
    ULONG i;
    LARGE_INTEGER Random;

    //
    // Generate a 64 bit random quantity
    //

    if (!CDGenerateRandomBits((PUCHAR) &Random.QuadPart, sizeof(Random.QuadPart)))
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }
     

    //
    // The account name that we generate will be 20 Chars long
    //

    AccountName->Length = 20 * sizeof(WCHAR);
    AccountName->MaximumLength = AccountName->Length;

    AccountName->Buffer = MIDL_user_allocate(AccountName->Length);
    if (NULL==AccountName->Buffer)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    //
    // The first character in the account name is a $ sign 
    //

    AccountName->Buffer[0] = L'$';

    //
    // The next 6 chars are the least 30 bits of the RID that are base 32 encoded
    //

    for (i=1;i<=6;i++)
    {

         //
         // Lookup the char corresponding to the last 5 bits of the RID
         //

         AccountName->Buffer[i] = AccountNameEncodingTable[(Rid & 0x1F)];

         //
         // Shift the RID right by 5 places
         //

         Rid = Rid >> 5;
    }

    //
    // The next char is a "-" to make the name more readable
    //
 
    AccountName->Buffer[7] = L'-';

    //
    // The next 12 chars are formed by base 32 encoding the last 60
    // bits of random bits. 
    //

    for (i=8;i<=19;i++)
    {
         //
         // Lookup the char corresponding to the last 5 bits 
         //

         AccountName->Buffer[i] = AccountNameEncodingTable[(Random.QuadPart & 0x1F)];

         //
         // Shift  right by 5 places
         //
         Random.QuadPart = Random.QuadPart >> 5;
    }



    return(STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\dsdsply.h ===
/*++
Copyright (c) 1996 Microsoft Corporation

Module Name:

    dsdsply.h

Abstract:

    Header file for SAM Private API Routines to access the DS
    for display information. This file contains prototypes of
    the routines that implement display API for the DS case

Author:
    MURLIS

Revision History

    12-18-96 Murlis Created

--*/

#ifndef DSDSPLY_H

#define DSDSPLY_H

#include <samsrvp.h>
#include <dslayer.h>



//////////////////////////////////////////////////////////////////////
//
//
//  Functions Prototypes
//
//
//
//////////////////////////////////////////////////////////////////////




NTSTATUS
SampDsEnumerateAccountRids(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG AccountTypesMask,
    IN  ULONG StartingRid,
    IN  ULONG PreferedMaximumLength,
    OUT PULONG ReturnCount,
    OUT PULONG *AccountRids
    );


NTSTATUS
SampDsQueryDisplayInformation (
    IN    SAMPR_HANDLE DomainHandle,
    IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    IN    ULONG      Index,
    IN    ULONG      EntriesRequested,
    IN    ULONG      PreferredMaximumLength,
    OUT   PULONG     TotalAvailable,
    OUT   PULONG     TotalReturned,
    OUT   PSAMPR_DISPLAY_INFO_BUFFER Buffer
    );

NTSTATUS
SampInitializeUserInfo(
    PSAMP_ACCOUNT_DISPLAY_INFO AccountInfo,
    PDOMAIN_DISPLAY_USER *UserInfo,
    BOOLEAN CopyData
    );

NTSTATUS
SampInitializeMachineInfo(          // Also used for Interdomain trust accounts
    PSAMP_ACCOUNT_DISPLAY_INFO AccountInfo,
    PDOMAIN_DISPLAY_MACHINE *MachineInfo,
    BOOLEAN CopyData
    );

NTSTATUS
SampInitializeGroupInfo(
    PSAMP_ACCOUNT_DISPLAY_INFO AccountInfo,
    PDOMAIN_DISPLAY_GROUP *GroupInfo,
    BOOLEAN CopyData
    );

NTSTATUS
SampDuplicateUserInfo(
    PDOMAIN_DISPLAY_USER Destination,
    PDOMAIN_DISPLAY_USER Source,
    ULONG                Index
    );

NTSTATUS
SampDuplicateMachineInfo(           // Also used for Interdomain trust accounts
    PDOMAIN_DISPLAY_MACHINE Destination,
    PDOMAIN_DISPLAY_MACHINE Source,
    ULONG                   Index

    );

NTSTATUS
SampDuplicateGroupInfo(
    PDOMAIN_DISPLAY_GROUP Destination,
    PDOMAIN_DISPLAY_GROUP Source,
    ULONG                 Index
    );

NTSTATUS
SampDuplicateOemUserInfo(
    PDOMAIN_DISPLAY_OEM_USER Destination,
    PDOMAIN_DISPLAY_USER Source,
    ULONG                Index
    );

NTSTATUS
SampDuplicateOemGroupInfo(
    PDOMAIN_DISPLAY_OEM_GROUP Destination,
    PDOMAIN_DISPLAY_GROUP Source,
    ULONG                 Index
    );


VOID
SampFreeUserInfo(
    PDOMAIN_DISPLAY_USER UserInfo
    );

VOID
SampFreeMachineInfo(
    PDOMAIN_DISPLAY_MACHINE MachineInfo
    );

VOID
SampFreeGroupInfo(
    PDOMAIN_DISPLAY_GROUP GroupInfo
    );

VOID
SampFreeOemUserInfo(
    PDOMAIN_DISPLAY_OEM_USER UserInfo
    );

VOID
SampFreeOemGroupInfo(
    PDOMAIN_DISPLAY_OEM_GROUP GroupInfo
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\dsdsply.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dsdsply.c

Abstract:

    This file contains services for  implementing the Display Information
    API from the DS.

    

Author:

    Murli Satagopan   (Murlis)  17 December 1996

Environment:

    User Mode - Win32

Revision History:
    


--*/


#include <samsrvp.h>
#include <dslayer.h>
#include <filtypes.h>
#include <dsdsply.h>
#include <lmaccess.h>


#define MAX_ENTRIES_TO_QUERY_FROM_DS    100
#define MAX_ENTRIES_TO_RETURN_TO_CLIENT 100
#define MAX_ENTRIES_TO_RETURN_TO_TRUSTED_CLIENTS 131072
#define MAX_RID 0x7FFFFFFF


//
// Prototypes of functions used in this file only
//

NTSTATUS
SampDsBuildAccountRidFilter(
    PSID    StartingSid,
    PSID    EndingSid,
    ULONG   AccountType,
    FILTER  * Filter                
    );

NTSTATUS
SampDsBuildQDIFilter(
    DOMAIN_DISPLAY_INFORMATION  DisplayInformation,
    FILTER  *QDIFilter                
    );

VOID
SampDsFreeAccountRidFilter(
    FILTER * Filter
    );

VOID
SampDsFreeQDIFilter(
    FILTER * QDIFilter
    );

NTSTATUS
SampDsCleanQDIBuffer(
  DOMAIN_DISPLAY_INFORMATION    DisplayInformation,
  PSAMPR_DISPLAY_INFO_BUFFER     Buffer
  );

VOID
SampDsGetLastEntryIndex(
    DOMAIN_DISPLAY_INFORMATION  DisplayInformation,
    PSAMPR_DISPLAY_INFO_BUFFER  Buffer,
    PULONG                      LastEntryIndex,
    PULONG                      EntriesRead 
    );

NTSTATUS
SampDsPackQDI(
    SEARCHRES   * SearchRes,
    DOMAIN_DISPLAY_INFORMATION  DisplayInformation,
    ULONG       StartingIndex,
    ULONG       DomainIndex,
    PSAMPR_DISPLAY_INFO_BUFFER Buffer,
    PRESTART * RestartToUse,
    PULONG     EntriesReturned
    );

NTSTATUS
SampPackUserDisplayInformation(
    ULONG       StartingIndex,
    ULONG       DomainIndex,
    SEARCHRES   *SearchRes,
    PULONG      EntriesReturned,
    PSAMPR_DISPLAY_INFO_BUFFER Buffer
    );

NTSTATUS
SampPackMachineDisplayInformation(
    ULONG       StartingIndex,
    ULONG       DomainIndex,
    SEARCHRES   *SearchRes,
    DOMAIN_DISPLAY_INFORMATION DisplayType,
    PULONG      EntriesReturned,
    PSAMPR_DISPLAY_INFO_BUFFER Buffer
    );

NTSTATUS
SampPackGroupDisplayInformation(
    ULONG       StartingIndex,
    ULONG       DomainIndex,
    SEARCHRES   *SearchRes,
    PULONG      EntriesReturned,
    PSAMPR_DISPLAY_INFO_BUFFER Buffer
    );

NTSTATUS
SampPackOemUserDisplayInformation(
    ULONG       StartingIndex,
    ULONG       DomainIndex,
    SEARCHRES   *SearchRes,
    PULONG      EntriesReturned,
    PSAMPR_DISPLAY_INFO_BUFFER Buffer
    );

NTSTATUS
SampPackOemGroupDisplayInformation(
    ULONG       StartingIndex,
    ULONG       DomainIndex,
    SEARCHRES   *SearchRes,
    PULONG      EntriesReturned,
    PSAMPR_DISPLAY_INFO_BUFFER Buffer
    );

NTSTATUS
SampDsCheckDisplayAttributes(
     ATTRBLOCK * DsAttrs,
     DOMAIN_DISPLAY_INFORMATION  DisplayInformation,
     PULONG     ObjectNameOffset,
     PULONG     UserAccountControlOffset,
     PULONG     UserAcctCtrlComputedOffset,
     PULONG     FullNameOffset,
     PULONG     AdminCommentOffset,
     BOOLEAN    * FullNamePresent,
     BOOLEAN    * AdminCommentPresent
     );

NTSTATUS
DsValToUnicodeString(
    PUNICODE_STRING UnicodeString,
    ULONG   Length,
    PVOID   pVal
    );

NTSTATUS
DsValToOemString(
    OEM_STRING *OemString,
    ULONG   Length,
    PVOID   pVal
    );


NTSTATUS
SampGetQDIAvailable(
    PSAMP_OBJECT    DomainContext,
    DOMAIN_DISPLAY_INFORMATION  DisplayInformation,
    ULONG   *TotalAvailable
    );

NTSTATUS
SampDsEnumerateAccountRidsWorker(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG AccountType,
    IN  ULONG StartingRid,
    IN  ULONG EndingRid,
    IN  ULONG PreferedMaximumLength,
    OUT PULONG ReturnCount,
    OUT PULONG *AccountRids
    );

NTSTATUS
SampDsEnumerateAccountRidsWorker(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG AccountType,
    IN  ULONG StartingRid,
    IN  ULONG EndingRid,
    IN  ULONG PreferedMaximumLength,
    OUT PULONG ReturnCount,
    OUT PULONG *AccountRids
    )
/*++

    This is the DS version of Enumerate Account Rid API for Net logon

    Parameters:

        Domain Handle - Handle to the domain object
        AccountType   - Specifies the type of account to use
        StartingRid   - The starting Rid
        EndingRid     - The ending Rid
        PreferedMaximumLength - The maximum length supplied by the client
        ReturnCount   - The Count of accounts returned
        AccountRids   - Array of account Rids

    Return Values

        STATUS_SUCCESS for successful completion
        Other Error codes under error conditions

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    //
    // Declare the attributes that we want the search to return. Note that we obtain
    // the Rid by parsing the SID in the returned DSName. We therefore need only the
    // SAM account Type
    //
    ATTRTYP         AttrTypes[]=
                    {
                        SAMP_UNKNOWN_ACCOUNT_TYPE
                    };
    
    ATTRVAL         AttrVals[]=
                    {
                        {0,NULL}
                    };
                  
    DEFINE_ATTRBLOCK1(
                      AttrsToRead,
                      AttrTypes,
                      AttrVals
                      );

    BOOLEAN         MoreEntriesPresent = FALSE;
    FILTER          DsFilter;
    SEARCHRES       *SearchRes;
    PSAMP_OBJECT    DomainContext = (PSAMP_OBJECT)DomainHandle;
    PSID            StartingSid = NULL;
    PSID            EndingSid = NULL;
    PSID            DomainSid = SampDefinedDomains[DomainContext->DomainIndex].Sid;
    ULONG           MaximumEntriesToReturn = PreferedMaximumLength/ sizeof(ULONG);
    ULONG           AccountTypeLo = 0;
    ULONG           AccountTypeHi = 0;
    ENTINFLIST      *CurrentEntInf;
  
    //
    // Compute the starting and ending Sid Ranges
    //
    *AccountRids = NULL;
    NtStatus = SampCreateFullSid(
                    DomainSid,
                    StartingRid,
                    &StartingSid
                    );

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    NtStatus = SampCreateFullSid(
                    DomainSid,
                    EndingRid,
                    &EndingSid
                    );

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    
    //
    // Allocate memory for the Rids to be returned
    // allocate one more and so that the very last entry ( not included in the
    // count has a 0x7FFFFFFF ( MAX_RID ). This will be valuable when we merge
    // sorted lists in SampDsEnumerateAccountRids

    *AccountRids = MIDL_user_allocate(sizeof(ULONG)* (MaximumEntriesToReturn+1));
   
    if (NULL==*AccountRids)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }


    //
    // Build a filter structure for searching
    //
    //

    NtStatus = SampDsBuildAccountRidFilter(
                    StartingSid,
                    EndingSid,
                    AccountType,
                    &DsFilter
                    );

    if (!NT_SUCCESS(NtStatus))
        goto Error;


    //
    // Now keep querying from DS till we hit either preferred Maximum length
    // entries or have completed the query. We prefer to query the DS by doing small
    // transactions and retrieving small number of objects every time. This is because
    // the DS never frees any memory, till the transaction is terminated and our memory
    // usage becomes pegged at abnormally high levels by doing long transactions. 
    //

    *ReturnCount = 0;
       
    NtStatus = SampDoImplicitTransactionStart(TransactionRead);
    if (!NT_SUCCESS(NtStatus))
        goto Error;


    //
    // Set the index ranges from the starting Sid to the Ending Sid. We filter on
    // on just Sid >= Starting Sid in the DS. Setting the index range ensures that
    // we will not need to look at object with a Sid greater than our ending Sid.
    //
    NtStatus = SampSetIndexRanges(
                    SAM_SEARCH_NC_ACCTYPE_SID , // Use NC ACCTYPE SID Index
                    sizeof(ULONG),
                    &AccountType,
                    RtlLengthSid(StartingSid),
                    StartingSid,
                    sizeof(ULONG),
                    &AccountType,
                    RtlLengthSid(EndingSid),
                    EndingSid,
                    FALSE
                    );

    if (!NT_SUCCESS(NtStatus))
        goto Error;

    //
    //  Perform the DS search.
    //

    NtStatus = SampDsDoSearch(
                    NULL,
                    DomainContext->ObjectNameInDs,
                    &DsFilter,
                    0,          // Starting Index
                    SampUnknownObjectType,
                    &AttrsToRead,
                    MaximumEntriesToReturn,
                    &SearchRes
                    );

    SampDiagPrint(DISPLAY_CACHE,("[SAMSS]SamIEnumerateAccountRids"));
    SampDiagPrint(DISPLAY_CACHE,("Returned From DS, Count=%d,Restart=%x\n",
                                        SearchRes->count, SearchRes->PagedResult.pRestart));
    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Pack the results
    //

    for (CurrentEntInf = &(SearchRes->FirstEntInf);
            ((CurrentEntInf!=NULL)&&(SearchRes->count>0));
            CurrentEntInf=CurrentEntInf->pNextEntInf)

    {
        ULONG   Rid;
        PSID    ReturnedSid = NULL;
        PSID    DomainSidOfCurrentEntry = NULL;
        PULONG  SamAccountType;

        //
        // Assert that the Attrblock returned is what we expected
        //
        ASSERT(CurrentEntInf->Entinf.AttrBlock.attrCount==1);
        ASSERT(CurrentEntInf->Entinf.AttrBlock.pAttr);

        ASSERT(CurrentEntInf->Entinf.AttrBlock.pAttr[0].AttrVal.valCount==1);
        ASSERT(CurrentEntInf->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal->pVal);
        ASSERT(CurrentEntInf->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal->valLen);
        
        
        //
        // Get the Sid and subsequently the Rid of the entry
        //

        ReturnedSid = &(CurrentEntInf->Entinf.pName->Sid);
        
        NtStatus = SampSplitSid(
                    ReturnedSid,
                    &DomainSidOfCurrentEntry,
                    &Rid
                    );

        if (!NT_SUCCESS(NtStatus))
            goto Error;

#if DBG

        //
        // For debug builds print out the last Rid that was returned
        //

        if (NULL==CurrentEntInf->pNextEntInf)
        {
            SampDiagPrint(DISPLAY_CACHE,("[SAMSS]\t Last Rid=%d\n",Rid));
        }
#endif


        
        //
        // Check wether the returned Sid belongs to the Domain
        //

        if (!RtlEqualSid(DomainSid,DomainSidOfCurrentEntry))
        {
           //
           // Skip this entry as this does not belong to the domain
           //

            MIDL_user_free(DomainSidOfCurrentEntry);
            DomainSidOfCurrentEntry = NULL;
            continue;
        }

        MIDL_user_free(DomainSidOfCurrentEntry);
        DomainSidOfCurrentEntry = NULL;

        //
        // Check the Account type. If user object are asked and account type is user object,
        // or if group objects are asked for and account type is group object then  Fill in
        // the Rid. Else skip this object and continue to the next object
        //

        (*AccountRids)[(*ReturnCount)++] = Rid;

        SamAccountType = (PULONG) CurrentEntInf->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal->pVal;
        ASSERT(*SamAccountType==AccountType);


    }

   ASSERT((*ReturnCount)<=MaximumEntriesToReturn);

   //
   // Mark the end ( not included in the count, with MAX RID. This will prove
   // valuable later when merging the sorted lists
   //

   (*AccountRids)[(*ReturnCount)] = MAX_RID;

    //
    // Process search continuation
    //

    if ((SearchRes->PagedResult.pRestart) && (SearchRes->count>0))
    {            
        //
        // Restart structure was returned. More entries are still present
        //

        MoreEntriesPresent = TRUE;
    }

Error:

    if (StartingSid)
        MIDL_user_free(StartingSid);

    if (EndingSid)
        MIDL_user_free(EndingSid);

    if (NT_SUCCESS(NtStatus) && (MoreEntriesPresent))
    {
        NtStatus = STATUS_MORE_ENTRIES;
    }

    if (!NT_SUCCESS(NtStatus))
    {
       if (*AccountRids)
           MIDL_user_free(*AccountRids);
    }
       
    SampDsFreeAccountRidFilter(&DsFilter);


    SampDiagPrint(DISPLAY_CACHE,("[SAMSS]SamIEnumerateAccountRids, StartingRid=%d, AccountTypesMask= %d,ReturnCount=%d, ReturnCode=%x\n",
        StartingRid, AccountType, *ReturnCount, NtStatus));

    return NtStatus;
}


NTSTATUS
SampDsEnumerateAccountRids(
    IN  SAMPR_HANDLE DomainHandle,
    IN  ULONG AccountTypesMask,
    IN  ULONG StartingRid,
    IN  ULONG PreferedMaximumLength,
    OUT PULONG ReturnCount,
    OUT PULONG *AccountRids
    )
{

    ULONG   EndingRid = MAX_RID; // set to max rid
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PULONG UserList, MachineList, TrustList;

    UserList = MachineList = TrustList = NULL;

    //
    // Look at the account types mask and get the correct
    // account type to set.
    //

    if (AccountTypesMask & SAM_GLOBAL_GROUP_ACCOUNT)
    {
      NtStatus = SampDsEnumerateAccountRidsWorker(
                    DomainHandle,
                    SAM_GROUP_OBJECT,
                    StartingRid,
                    EndingRid,
                    PreferedMaximumLength,
                    ReturnCount,
                    AccountRids
                    );
    }
    else if (AccountTypesMask & SAM_LOCAL_GROUP_ACCOUNT)
    {
        NtStatus = SampDsEnumerateAccountRidsWorker(
                    DomainHandle,
                    SAM_ALIAS_OBJECT,
                    StartingRid,
                    EndingRid,
                    PreferedMaximumLength,
                    ReturnCount,
                    AccountRids
                    );
    }
    else if (AccountTypesMask & SAM_USER_ACCOUNT)
    {
        ULONG EndingRidUser,EndingRidMachine,EndingRidTrust;
        ULONG  UserCount, MachineCount, TrustCount,LastRidToReturn;
        NTSTATUS StatusUser,StatusMachine,StatusTrust;
        ULONG u,m,t;

        EndingRidUser = EndingRidMachine = EndingRidTrust = EndingRid;
    
        UserCount = MachineCount = TrustCount = 0;
        LastRidToReturn = MAX_RID-1;

        //
        // Start with normal users, and then enumerate
        // machines and trusts and then merge the sorted
        // list of RIDs into a single sorted list
        //

        NtStatus = SampDsEnumerateAccountRidsWorker(
                    DomainHandle,
                    SAM_NORMAL_USER_ACCOUNT,
                    StartingRid,
                    EndingRidUser,
                    PreferedMaximumLength,
                    &UserCount,
                    &UserList
                    );

        // Bail on error
        if (!NT_SUCCESS(NtStatus))
            goto Error;

        StatusUser = NtStatus;

        if (STATUS_MORE_ENTRIES == NtStatus)
        {
            //
            // There are more users in the database than we
            // can return. Constrain  the searches for machines
            // and trusts to within the last RID returned by the
            // user enumeration
            //

            ASSERT(NULL!=UserList);
            ASSERT(UserCount>0);

            EndingRidMachine = EndingRidTrust = UserList[UserCount-1]-1;
        }

        //
        // Enumerate the machines in the domain. This time we will walk a
        // different part of the index range and generate a list of RIDs
        // corresponding to the machines
        //

        NtStatus = SampDsEnumerateAccountRidsWorker(
                    DomainHandle,
                    SAM_MACHINE_ACCOUNT,
                    StartingRid,
                    EndingRidMachine,
                    PreferedMaximumLength,
                    &MachineCount,
                    &MachineList
                    );

        // Bail on error
        if (!NT_SUCCESS(NtStatus))
            goto Error;

        StatusMachine = NtStatus;

        if (STATUS_MORE_ENTRIES == NtStatus)
        {
            //
            // Even within the constrained Rid range that we
            // specified for machines, we have more machines than
            // we can return. The RID of the last machine returned
            // must be less than the RID of the last user returned,
            // as the index range for machines has been further constrained.
            // Therefore for trusts, further constrain the index range
            // to be within the last Machine RID returned
            //

            ASSERT(NULL!=MachineList);
            ASSERT(MachineCount>0);
            if (UserCount>0 && (STATUS_MORE_ENTRIES == StatusUser))
            {
                ASSERT(UserList[UserCount-1]>MachineList[MachineCount-1]);

            }

            EndingRidTrust = MachineList[MachineCount-1]-1;

        }

        //
        // Enumerate the trust accounts in the domain
        //

       NtStatus = SampDsEnumerateAccountRidsWorker(
                        DomainHandle,
                        SAM_TRUST_ACCOUNT,
                        StartingRid,
                        EndingRidTrust,
                        PreferedMaximumLength,
                        &TrustCount,
                        &TrustList
                        );

       if (!NT_SUCCESS(NtStatus))
            goto Error;

       StatusTrust = NtStatus;

       if (StatusTrust==STATUS_MORE_ENTRIES)
       {
           //
           // We found more trust accounts, inspite of the index
           // range limitation. In this case return all the trust
           // accounts found plus all the machine accounts with rids
           // less than the last trust account and all user accounts with
           // rids less than the last trust account
           //

           ASSERT(TrustCount>0);
           LastRidToReturn = TrustList[TrustCount-1];
           NtStatus = STATUS_MORE_ENTRIES;
       }
       else if (StatusMachine == STATUS_MORE_ENTRIES)
       {
           //
           // We found more machines than users inspite of the index range
           // limitation on machines. In this case return all the machine
           // accounts found plus all the user and trust accounts with rids
           // less than the last machine account.
           //

           LastRidToReturn = MachineList[MachineCount-1];
           NtStatus = STATUS_MORE_ENTRIES;
       }
       else if (StatusUser == STATUS_MORE_ENTRIES)
       {
           //
           // We found more users than anything else. In this case return all
           // the machine and trust accounts found plus all the users
           //

           LastRidToReturn = UserList[UserCount-1];
           NtStatus = STATUS_MORE_ENTRIES;
       }
       else
       {
           //
           // We did not get StatusMore entries from users enumeration, or from
           // machine enumeration. Return all the rids found so far, and return
           // a status success
           //

           LastRidToReturn = MAX_RID-1;
           NtStatus = STATUS_SUCCESS;
       }

       //
       // Now you have an 3 sorted arrays of Rids. Create a single sorted array
       // containing all the 3 rids upto and including the LastRidToReturn.
       //
        
       *AccountRids = MIDL_user_allocate(sizeof(ULONG) * (UserCount+MachineCount+TrustCount));
       if (NULL==*AccountRids)
           goto Error;

       u=m=t=0;

       for ((*ReturnCount)=0;
                (*ReturnCount)<UserCount+MachineCount+TrustCount;
                        (*ReturnCount)++)
       {
           ULONG NextRid;

           if ((UserList[u]<MachineList[m]) && (UserList[u]<TrustList[t]) 
               && (UserList[u]<=LastRidToReturn))
           {
               ASSERT(u<UserCount); 
               (*AccountRids)[(*ReturnCount)] = UserList[u];
               u++;
              
           }
           else if  ((MachineList[m]<UserList[u]) && (MachineList[m]<TrustList[t]) 
               && (MachineList[m]<=LastRidToReturn))
           {
               ASSERT(m<MachineCount);
               (*AccountRids)[(*ReturnCount)] = MachineList[m];
               m++;
           }
           else if ((TrustList[t]<UserList[u]) && (TrustList[t]<MachineList[m]) 
               && (TrustList[t]<=LastRidToReturn))
           {
               ASSERT(t<TrustCount);
               (*AccountRids)[(*ReturnCount)] = TrustList[t];
               t++;
           }
           else
           {
               //
               // We have reached the point where we can return no more Rids
               // break out of the loop
               //

               break;
           }
       }
    }


Error:

    if (NULL!=UserList)
        MIDL_user_free(UserList);

    if (NULL!=MachineList)
        MIDL_user_free(MachineList);

    if (NULL!=TrustList)
        MIDL_user_free(TrustList);

    //
    // End the current transaction. 
    //

    SampMaybeEndDsTransaction(TransactionCommit);

    return(NtStatus);
}


NTSTATUS
SampDsBuildAccountRidFilter(
    PSID    StartingSid,
    PSID    EndingSid,
    ULONG   AccountType,
    FILTER  * Filter                
    )
/*++

    Builds a Filter for use by SampDsEnumerateAccountRids.

    Parameters:

        StartingSid        -- The starting Sid that we are interseted in
        EndingSid          -- The ending Sid that we are interested in
        AccountTypesMask   -- The account types that were requested

    Return Values:

        STATUS_SUCCESS
--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;


    //
    // In building DS filters a tradeoff exists between the complextity of the filter
    // and the number of objects that the filter limits the search too. After some 
    // empirical studies it was found that it is more beneficial to use a fairly simple
    // filter alongwith some manual filtering, than supply a complex filter to the DS.
    // Hence this filter is just set simply to TRUE.
    //
    //

    RtlZeroMemory(Filter,sizeof(FILTER));
    Filter->pNextFilter = NULL;
    Filter->choice = FILTER_CHOICE_ITEM;
    Filter->FilterTypes.Item.choice = FI_CHOICE_TRUE;
    
    return Status;
}

VOID
SampDsFreeAccountRidFilter(FILTER * Filter)
/*++

  Routine Description

    This frees any memory allocated in the filter structure 
    built by SampDsBuildAccountRidFilter

  Paramters:

    Filter -- The Filter structure
--*/
{
    //
    // This is a place holder routine, to free any memory allocated in the Filter.
    // this must be kept in sync with the SampDsBuildAccountRidFilter
    //
}





NTSTATUS
SampDsQueryDisplayInformation (
    IN    SAMPR_HANDLE DomainHandle,
    IN    DOMAIN_DISPLAY_INFORMATION DisplayInformation,
    IN    ULONG      StartingOffset,
    IN    ULONG      EntriesRequested,
    IN    ULONG      PreferredMaximumLength,
    OUT   PULONG     TotalAvailable,
    OUT   PULONG     TotalReturned,
    OUT   PSAMPR_DISPLAY_INFO_BUFFER Buffer
    )
/*++

  This routine implements the Query of Display information from the DS. The
  SAM global lock is assumed to be held at this time.


  Since user manager behavior is to download everything upon startup, this routine
  is heavily optimized for that case. It relies upon the new compund indices to sort
  the results in the order of account Name. 

  Paramters:

        Same as SamrQueryDisplayInformation3
  Return Values

        Same as SamrQueryDisplayInformation3

++*/
{
    ULONG               SamAccountTypeLo;
    ULONG               SamAccountTypeHi;
    ULONG               IndexToUse = SAM_SEARCH_NC_ACCTYPE_NAME;
    NTSTATUS            NtStatus = STATUS_SUCCESS, IgnoreStatus;
    FILTER              QDIFilter;
    PSAMP_OBJECT        DomainContext = (PSAMP_OBJECT)DomainHandle;
    SAMP_OBJECT_TYPE    ObjectTypeForConversion;
    ULONG               NumEntriesToReturn = 0;
    ULONG               NumEntriesAlreadyReturned = 0;
    ULONG               NumEntriesToQueryFromDs = 0;
    ULONG               LastEntryIndex = 0;
    ULONG               EntriesRead = 0;
    BOOLEAN             fReadLockReleased = FALSE;
    BOOLEAN             fThreadCountIncremented = FALSE;

    //
    // Declare the attrTypes that we need. Again note that we will obtain the Rid by
    // using the Sid in the object name field.
    //

    ATTRTYP         UserAttrTypes[]=
                    {
                        SAMP_FIXED_USER_ACCOUNT_CONTROL,
                        SAMP_FIXED_USER_ACCOUNT_CONTROL_COMPUTED,
                        SAMP_USER_ACCOUNT_NAME,
                        SAMP_USER_ADMIN_COMMENT,
                        SAMP_USER_FULL_NAME
                    };
    
    ATTRVAL         UserAttrVals[]=
                    {
                        {0,NULL},
                        {0,NULL},
                        {0,NULL},
                        {0,NULL},
                        {0,NULL}
                    };
                  
    DEFINE_ATTRBLOCK5(
                      UserAttrs,
                      UserAttrTypes,
                      UserAttrVals
                      );

    ATTRTYP         GroupAttrTypes[]=
                    {
                        SAMP_GROUP_NAME,
                        SAMP_GROUP_ADMIN_COMMENT
                    };
    
    ATTRVAL         GroupAttrVals[]=
                    {
                        {0,NULL},
                        {0,NULL}
                    };
                  
    DEFINE_ATTRBLOCK2(
                      GroupAttrs,
                      GroupAttrTypes,
                      GroupAttrVals
                      );
    ATTRBLOCK       * QDIAttrs;

    PRESTART        RestartToUse = NULL; 
    SEARCHRES       *SearchRes;
    BOOLEAN         CanQueryEntireDomain = TRUE;
    BOOLEAN         MoreEntries = TRUE; 
    BOOLEAN         NewSearch = FALSE;
    int             DeltaToUse = 0;

    #define LIMIT_ENTRIES(X,Limit) ((X>Limit)?Limit:X)
    #define DISPLAY_ENTRY_SIZE  32

    RtlZeroMemory(&QDIFilter,sizeof(FILTER));
                                        
    //
    // Do the number of entries returned arithmetic
    //
    //  Many NT4 Clients download the entire database
    //  upon startup, rather than go to the server for queries.
    //  This can potentially require very long transactions. Additionally
    //  due to the nature of the core DS memory allocation scheme, this will
    //  result in a huge memory consumption on the part of the server. Solution
    //  approaches are
    // 
    //  1. We can artificially limit the number of objects that we will 
    //  return in a single query display. This will result in a lot of network traffic
    //  when the NT4 client comes up as they will make many small queries
    //
    //  2. We can conduct many small searches, stuff the results in for NT4 clients
    //  and return a fairly large number of results.  
    //
    //  Current implementation implements solution approach 2.
    //
    //      
    //
    //

    NumEntriesToReturn = EntriesRequested;
    NumEntriesToReturn = LIMIT_ENTRIES(NumEntriesToReturn,PreferredMaximumLength/DISPLAY_ENTRY_SIZE);
    NumEntriesToReturn = LIMIT_ENTRIES(NumEntriesToReturn,MAX_ENTRIES_TO_RETURN_TO_CLIENT);
    if (NumEntriesToReturn < 1)
    {
        NumEntriesToReturn = 1;
    }


    //
    // Get index ranges to set based on the search type
    // and allocate space for array of elements
    //

    switch (DisplayInformation)
    {
    case DomainDisplayUser:
        
        SamAccountTypeLo = SAM_NORMAL_USER_ACCOUNT;
        SamAccountTypeHi = SAM_NORMAL_USER_ACCOUNT;
        QDIAttrs = &UserAttrs;
        ObjectTypeForConversion = SampUserObjectType;

        if (NULL==Buffer->UserInformation.Buffer)
        {

            Buffer->UserInformation.Buffer = MIDL_user_allocate(
               NumEntriesToReturn * sizeof(SAMPR_DOMAIN_DISPLAY_USER));

            if (NULL==Buffer->UserInformation.Buffer) 
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }
            RtlZeroMemory(Buffer->UserInformation.Buffer,
                NumEntriesToReturn * sizeof(SAMPR_DOMAIN_DISPLAY_USER));
            Buffer->UserInformation.EntriesRead=0;
        }

        break;

    case DomainDisplayOemUser:
        
        SamAccountTypeLo = SAM_NORMAL_USER_ACCOUNT;
        SamAccountTypeHi = SAM_NORMAL_USER_ACCOUNT;
        QDIAttrs = &UserAttrs;
        ObjectTypeForConversion = SampUserObjectType;

        if (NULL==Buffer->OemUserInformation.Buffer)
        {

            Buffer->OemUserInformation.Buffer = MIDL_user_allocate(
               NumEntriesToReturn * sizeof(SAMPR_DOMAIN_DISPLAY_OEM_USER));

            if (NULL==Buffer->OemUserInformation.Buffer) 
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }
            RtlZeroMemory(Buffer->OemUserInformation.Buffer,
                NumEntriesToReturn * sizeof(SAMPR_DOMAIN_DISPLAY_OEM_USER));
            Buffer->OemUserInformation.EntriesRead=0;
        }

        break;
        
    case DomainDisplayMachine:
        
        SamAccountTypeLo = SAM_MACHINE_ACCOUNT;
        SamAccountTypeHi = SAM_MACHINE_ACCOUNT;
        ObjectTypeForConversion = SampUserObjectType;
        QDIAttrs = &UserAttrs;

        if (NULL==Buffer->MachineInformation.Buffer)
        {

            Buffer->MachineInformation.Buffer = MIDL_user_allocate(
               NumEntriesToReturn * sizeof(SAMPR_DOMAIN_DISPLAY_MACHINE));

            if (NULL==Buffer->MachineInformation.Buffer) 
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }
            RtlZeroMemory(Buffer->MachineInformation.Buffer,
                NumEntriesToReturn * sizeof(SAMPR_DOMAIN_DISPLAY_MACHINE));
            Buffer->MachineInformation.EntriesRead=0;
        }

        break;

    case DomainDisplayServer:

        //
        // Since all domain controllers have DOMAIN_GROUP_RID_CONTROLLERS as 
        // their primary group ID. So using PRIMARY_GROUP_ID as Index will 
        // result much faster query.
        // 
        IndexToUse = SAM_SEARCH_PRIMARY_GROUP_ID;
        SamAccountTypeLo = DOMAIN_GROUP_RID_CONTROLLERS; 
        SamAccountTypeHi = DOMAIN_GROUP_RID_CONTROLLERS;
        ObjectTypeForConversion = SampUserObjectType;
        QDIAttrs = &UserAttrs;

        if (NULL==Buffer->MachineInformation.Buffer)
        {

            Buffer->MachineInformation.Buffer = MIDL_user_allocate(
               NumEntriesToReturn * sizeof(SAMPR_DOMAIN_DISPLAY_MACHINE));

            if (NULL==Buffer->MachineInformation.Buffer) 
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }
            RtlZeroMemory(Buffer->MachineInformation.Buffer,
                NumEntriesToReturn * sizeof(SAMPR_DOMAIN_DISPLAY_MACHINE));
            Buffer->MachineInformation.EntriesRead=0;
        }

        break;

    case DomainDisplayGroup:

        SamAccountTypeLo = SAM_GROUP_OBJECT;
        SamAccountTypeHi = SAM_GROUP_OBJECT;
        ObjectTypeForConversion = SampGroupObjectType;
        QDIAttrs = &GroupAttrs;

        if (NULL==Buffer->GroupInformation.Buffer)
        {

            Buffer->GroupInformation.Buffer = MIDL_user_allocate(
               NumEntriesToReturn * sizeof(SAMPR_DOMAIN_DISPLAY_GROUP));

            if (NULL==Buffer->GroupInformation.Buffer) 
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }
            Buffer->GroupInformation.EntriesRead=0;
            RtlZeroMemory(Buffer->GroupInformation.Buffer,
                NumEntriesToReturn * sizeof(SAMPR_DOMAIN_DISPLAY_GROUP));
        }

        break;

    case DomainDisplayOemGroup:

        SamAccountTypeLo = SAM_GROUP_OBJECT;
        SamAccountTypeHi = SAM_GROUP_OBJECT;
        ObjectTypeForConversion = SampGroupObjectType;
        QDIAttrs = &GroupAttrs;

        if (NULL==Buffer->OemGroupInformation.Buffer)
        {

            Buffer->OemGroupInformation.Buffer = MIDL_user_allocate(
               NumEntriesToReturn * sizeof(SAMPR_DOMAIN_DISPLAY_OEM_GROUP));

            if (NULL==Buffer->OemGroupInformation.Buffer) 
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }
            RtlZeroMemory(Buffer->OemGroupInformation.Buffer,
                NumEntriesToReturn * sizeof(SAMPR_DOMAIN_DISPLAY_OEM_GROUP));
            Buffer->OemGroupInformation.EntriesRead=0;
        }

        break;

    default:
        return (STATUS_INVALID_PARAMETER);
    }

    //
    // Check if the query can be restarted by state stored in domain context
    //

    //
    // As mentioned before User manager and various net API try to download the entire
    // display information in one stroke. In case of a large number of accounts user manager
    // will call the query display information API many times. Each time the starting offset
    // will be set to indicate the next object that is needed. A straigforward implementation,
    // just specifying the starting offset to the DS search routine will result in manual skipping
    // of that many objects by using JetMove's. To speed this up, therefore we maintain state,
    // telling us the offset of the last object that we returned, the type of display information,
    // and a restart structure, allowing for easy positioning on the object.
    //
    // Currently, there are two APIs using this rouinte. 
    // 1. SAM API, the client using the same Domain Handle in different calls, thus 
    //    we can use the restart search which is cached in the Domain Context.
    //    The extra benefit is that the caller of SAM API can even manipulate the returned 
    //    index, do certain kind of arithmetic.
    //
    // 2. NET API. that poorly designed API create/use a new Domain Handle when calling
    //    SamrQueryDisplayInformation(). Thus they lose all cached restart infomation.
    //    To handle this case correctly, SAM actully return Object's DNT as index to caller.
    //    When our client sends back the last object's DNT, we can position on the last 
    //    entry quickly by using the DNT, then start from it.
    //

    if (0 == StartingOffset)
    {
        //
        // StartingOffset is 0 means caller wants to begin a new query. 
        // Clean up the cached restart info if any
        // 
        if (DomainContext->TypeBody.Domain.DsDisplayState.Restart)
        {
            MIDL_user_free(DomainContext->TypeBody.Domain.DsDisplayState.Restart);
        }

        DomainContext->TypeBody.Domain.DsDisplayState.Restart = NULL;
        DomainContext->TypeBody.Domain.DsDisplayState.NextStartingOffset = 0;
        DomainContext->TypeBody.Domain.DsDisplayState.TotalEntriesReturned = 0;
        DomainContext->TypeBody.Domain.DsDisplayState.DisplayInformation = DisplayInformation;

        //
        // Set local variables accordingly 
        // 
        DeltaToUse = 0;
        RestartToUse = NULL;
        NewSearch = TRUE;
    }
    else if (NULL != DomainContext->TypeBody.Domain.DsDisplayState.Restart)
    {
        // we have the restart info. This client must call SAM API
        if (DisplayInformation == 
            DomainContext->TypeBody.Domain.DsDisplayState.DisplayInformation)
        {
            //
            // StartingOffset is not Zero. 
            // If the Domain Context caches the restart info and the DisplayInformation matched.
            // Then we can do a restart search. 
            // 
            ULONG   NextStartingOffset;

            NextStartingOffset = DomainContext->TypeBody.Domain.DsDisplayState.NextStartingOffset;

            if (StartingOffset == NextStartingOffset)
            {
                //
                // Starting Offset matches the restartable state
                // and client is using the Index we returned to them. (correct usage) 
                //

                RestartToUse = DomainContext->TypeBody.Domain.DsDisplayState.Restart;
                DeltaToUse = 0;
            }
            else if (StartingOffset == DomainContext->TypeBody.Domain.DsDisplayState.TotalEntriesReturned)
            {
                //
                // client assumes the value of total returned entries is the index. 
                // (this is a wrong usage of the index). but since this kind of client
                // exists since NT4, so we have to patch this special case.
                // here is what we do for them:
                // 1. TotalEntriesReturned is used in the Domain Context to track how many entries returned already
                // 2. Once we detect that the client is using the wrong index. 
                //    (whether StartingOffset equal to TotalEntriesReturned or not).
                //    we need to pick the restart structure and with 0 delta
                //
                RestartToUse = DomainContext->TypeBody.Domain.DsDisplayState.Restart;
                DeltaToUse = 0;
            }
            else if ((ABSOLUTE_VALUE((int)((int)StartingOffset - (int)NextStartingOffset)))
                        < ((int)StartingOffset))
            {
                //
                // We will need to walk much less number of object's by using the restart
                //

                RestartToUse = DomainContext->TypeBody.Domain.DsDisplayState.Restart;
                DeltaToUse = (int)((int) StartingOffset - (int) NextStartingOffset);

            }
            else
            {
                //
                // We are better off walking from the top of the Table
                //

                RestartToUse = NULL;
                DeltaToUse = (int)StartingOffset;
            }

        }
        else
        {
            //
            // Restart is not NULL, StartingOffset is not 0, but another
            // Information Class. Try our best
            // 
            PRESTART Restart = NULL;

            MIDL_user_free(DomainContext->TypeBody.Domain.DsDisplayState.Restart);
            DomainContext->TypeBody.Domain.DsDisplayState.Restart = NULL;
            DomainContext->TypeBody.Domain.DsDisplayState.NextStartingOffset = StartingOffset;
            DomainContext->TypeBody.Domain.DsDisplayState.TotalEntriesReturned = 0;
            DomainContext->TypeBody.Domain.DsDisplayState.DisplayInformation = DisplayInformation;

            NtStatus = SampGetQDIRestart(DomainContext->ObjectNameInDs,
                                         DisplayInformation,
                                         StartingOffset,        // Last returned entry DNT
                                         &Restart
                                         );
            
            if (STATUS_NO_MORE_ENTRIES == NtStatus)
            {
                MoreEntries = FALSE;
                NtStatus = STATUS_SUCCESS;
                goto Error;
            }

            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }


            if (NULL != Restart)
            {
                NtStatus = SampCopyRestart(Restart, &RestartToUse);

                if (!NT_SUCCESS(NtStatus))
                    goto Error;
            }

            DeltaToUse = 0;

        }
    }
    else
    {
        // StartingOffest is not ZERO. But restart is NULL. 
        // there are two of cases will lead us falling into this situation: 
        // 
        // 1. NET API using a brand new Domain Handle each every time they call 
        //    this routine. So no cached info available. In this case,  
        //    the StartingOffset should be the last returned entry's DNT. 
        //    And since this is a new Domain Context, so the cached
        //    DisplayInformation should be 0.
        // 
        // 2. Client is using SAM API. We can tell it if the DomainContext->
        //    DisplayInformation is not 0. In this case, Restart == NULL means
        //    there is no more entry available, we have already returned all
        //    entried in previous calls. StartingOffset could be anything.
        //    Return success immediately with 0 entry.
        //
        // For case 1, SAM will re-position in the table based on the passed in Index - which is
        // the last entry's DNT (we returned to caller previously), then restart from there.
        // Because no previous restart cached, so no Index arithmetic allowed.
        // 

        if (DisplayInformation == DomainContext->TypeBody.Domain.DsDisplayState.DisplayInformation)
        {
            // Case 2. I don't care about the StartingOffset anymore.
            MoreEntries = FALSE;
            NtStatus = STATUS_SUCCESS;
            goto Error;
        }                                    
        else
        {
            // Case 1.
            //
            // Query Server Info should NOT fall into this case. Because:
            // 1. NET API is not allowed to query server info. ONLY SAM API can do that.
            //    Thus, we should always have restart cached in the domain handle.
            // 2. In this case, we will re-create the new restart using NcAccTypeName index,
            //    but for server info, we do really want to use PRIMARY_GROUP_ID index.
            // 
            PRESTART Restart = NULL;

            ASSERT(DomainDisplayServer != DisplayInformation);

            // start a ds transaction
            NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
            if (!NT_SUCCESS(NtStatus))
                goto Error;

            //
            //  Get a Restart Structure from the passed in Index.
            //  the Index is actually the DNT of the last returned object
            // 
            NtStatus = SampGetQDIRestart(DomainContext->ObjectNameInDs,
                                         DisplayInformation,
                                         StartingOffset,        // Last returned entry DNT
                                         &Restart
                                         );
            
            if (STATUS_NO_MORE_ENTRIES == NtStatus)
            {
                MoreEntries = FALSE;
                NtStatus = STATUS_SUCCESS;
                goto Error;
            }

            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }


            if (NULL != Restart)
            {
                NtStatus = SampCopyRestart(Restart, &RestartToUse);

                if (!NT_SUCCESS(NtStatus))
                    goto Error;
            }

            DeltaToUse = 0;
        }
    }
    

    //
    // Get the approximate total number available in the specified info class
    //

    *TotalAvailable = 0;
    if (DomainContext->TypeBody.Domain.DsDisplayState.TotalAvailable)
    {
        //
        // use the cached information if we have
        //

        *TotalAvailable = DomainContext->TypeBody.Domain.DsDisplayState.TotalAvailable;
    }
     
    //
    // Loop through and query entries in the DS.
    //

    NumEntriesAlreadyReturned = 0;
    NumEntriesToQueryFromDs = LIMIT_ENTRIES((NumEntriesToReturn - NumEntriesAlreadyReturned),
                                        MAX_ENTRIES_TO_QUERY_FROM_DS);

    //
    // we will search the Ds directly. Release the Read Lock
    // as we no longer need access to any variable in Domain Context.
    // Since this Domain Context can be shared by multiple threads, 
    // we have to hold the read lock until now.
    //

    ASSERT(SampCurrentThreadOwnsLock());
    SampReleaseReadLock();
    fReadLockReleased = TRUE;

    //
    // Since we do not hold SAM lock, increment the active thread count
    // while doing ds operations.
    // 
    NtStatus = SampIncrementActiveThreads();

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }
    else
    {
        fThreadCountIncremented = TRUE;
    }
    //
    // If we did not get the cached total available information from the
    // handle, initiate a count of indices to get an estimate of the total
    // number of available items
    //

    if (0 == *TotalAvailable)
    {
        NtStatus = SampGetQDIAvailable(
                    DomainContext,
                    DisplayInformation,
                    TotalAvailable
                    );

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        //
        // End the transaction
        //

        IgnoreStatus = SampMaybeEndDsTransaction(TransactionCommit);
        ASSERT(NT_SUCCESS(IgnoreStatus));

    }

    //
    // Run special check (introduced for Windows 2000 SP2).
    // 
    // The goal is to stop enumerate everyone behaviour. This hotfix
    // allows an administrator to shut down this API's alone to everyone
    // except a subset of people. 
    // 

    if (SampDoExtendedEnumerationAccessCheck)
    {
        NtStatus = SampExtendedEnumerationAccessCheck( &CanQueryEntireDomain );

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }
    }


    while (NumEntriesToQueryFromDs && MoreEntries)
    {
        ULONG   EntriesReturned = 0;
        BOOLEAN DidSearch = FALSE;

        //
        // Begin a transaction
        //

        NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        //
        // Build the appropriate Filter
        //

        NtStatus = SampDsBuildQDIFilter(
                    DisplayInformation,
                    &QDIFilter
                    );
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }


        //
        //  Set Index Type and Ranges
        //

        NtStatus =  SampSetIndexRanges(
                        IndexToUse,
                        sizeof(SamAccountTypeLo),
                        &SamAccountTypeLo,
                        0,NULL,
                        sizeof(SamAccountTypeHi),
                        &SamAccountTypeHi,
                        0,NULL,
                        TRUE
                        );

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        //
        // Turn off the DSA flag for a non trusted client
        //

        if (!DomainContext->TrustedClient)
        {
             SampSetDsa(FALSE);
        }

        //
        // Call the Ds Search. Don't allow restarted searches if
        // if client cannot enumerate entire domain.
        //

        if (( NewSearch || CanQueryEntireDomain))
        {

            NtStatus = SampDsDoSearch2(
                          0,
                          RestartToUse, 
                          DomainContext->ObjectNameInDs, 
                          &QDIFilter,
                          DeltaToUse,
                          ObjectTypeForConversion,
                          QDIAttrs,
                          NumEntriesToQueryFromDs,
                          (DomainContext->TrustedClient)?0:1*60*1000,
                          &SearchRes
                          );

            DidSearch = TRUE;
        }

        SampSetDsa(TRUE);


        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        SampDsFreeQDIFilter(&QDIFilter);

        //
        // Check if any objects are returned
        //

        if ((DidSearch ) && (SearchRes->count>0))
        {
            //
            // Yep, Pack the results into the buffer. Also obtain any restart structure
            // that was returned. SampDsPackQDI copies the restart structure in thread
            // local memory returned by the DS into MIDL memory.
            //

            NtStatus = SampDsPackQDI(
                          SearchRes,
                          DisplayInformation,
                          DomainContext->DomainIndex,
                          StartingOffset+NumEntriesAlreadyReturned,
                          Buffer,
                          &RestartToUse,
                          &EntriesReturned
                          );

            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }

        }

        //
        // Try to determine if there are more entries. If some objects were returned
        // in this search, and a restart structure was also returned then there are 
        // more entries present.  
        // 

        if ((DidSearch) && (SearchRes->count > 0)&&(RestartToUse!=NULL)&&(CanQueryEntireDomain))
        {
            MoreEntries = TRUE;
        }
        else
        {
            MoreEntries = FALSE;
        }


        //
        // End the transaction
        //

        NtStatus = SampMaybeEndDsTransaction(TransactionCommit);
        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        //
        // Compute entries returned so far, and number of more entries to 
        // query from DS.
        //

        NumEntriesAlreadyReturned+=EntriesReturned;
        NumEntriesToQueryFromDs = LIMIT_ENTRIES((NumEntriesToReturn - NumEntriesAlreadyReturned),
                                            MAX_ENTRIES_TO_QUERY_FROM_DS);

    }

    if (fThreadCountIncremented)
    {
        SampDecrementActiveThreads();
        fThreadCountIncremented = FALSE;
    }

    if (fReadLockReleased)
    {
        SampAcquireReadLock();
        fReadLockReleased = FALSE;
    }

    //
    // Set the state in the domain context such as the the restart mechanism may be used
    // to speed up clients which want to download the display information in one stroke
    //
    SampDsGetLastEntryIndex(DisplayInformation, 
                            Buffer, 
                            &LastEntryIndex, 
                            &EntriesRead
                            );

    DomainContext->TypeBody.Domain.DsDisplayState.Restart = RestartToUse;
    DomainContext->TypeBody.Domain.DsDisplayState.DisplayInformation = DisplayInformation;
    DomainContext->TypeBody.Domain.DsDisplayState.TotalEntriesReturned += EntriesRead;
    if (0 == EntriesRead)
    {
        DomainContext->TypeBody.Domain.DsDisplayState.NextStartingOffset = StartingOffset; 
    }
    else
    {
        DomainContext->TypeBody.Domain.DsDisplayState.NextStartingOffset = LastEntryIndex; 
    }


Error:

    //
    // Cleanup before returning
    //

    if (!NT_SUCCESS(NtStatus))
    {
        IgnoreStatus = SampMaybeEndDsTransaction(TransactionCommit);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        if (Buffer)
        {

            //
            // We could have errored out in the middle of a query, where we have
            // some objects already allocated, and are now going to return an error
            // to the client. We need to walk through the buffer freeing all the
            // information.
            //

            IgnoreStatus = SampDsCleanQDIBuffer(DisplayInformation,Buffer);
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }
    }
    else
    {
        // Make sure any transactions are commited        
        IgnoreStatus = SampMaybeEndDsTransaction(TransactionCommit);
        ASSERT(NT_SUCCESS(IgnoreStatus));

        *TotalReturned = NumEntriesAlreadyReturned * DISPLAY_ENTRY_SIZE;
        if (MoreEntries)
        {
            NtStatus = STATUS_MORE_ENTRIES;
        }
     
    }

    SampDsFreeQDIFilter(&QDIFilter);

    if (fThreadCountIncremented)
    {
        SampDecrementActiveThreads();
        fThreadCountIncremented = FALSE;
    }

    if (fReadLockReleased)
    {
        SampAcquireReadLock();
        fReadLockReleased = FALSE;
    }

    return(NtStatus);
}



VOID
SampDsGetLastEntryIndex(
    DOMAIN_DISPLAY_INFORMATION    DisplayInformation,
    PSAMPR_DISPLAY_INFO_BUFFER    Buffer,
    PULONG                        LastEntryIndex,
    PULONG                        EntriesRead 
    )
{
    *LastEntryIndex = 0;
    *EntriesRead = 0;

    switch (DisplayInformation) {
    case DomainDisplayUser:
        *EntriesRead = Buffer->UserInformation.EntriesRead;
        if (*EntriesRead > 0)
        {
            *LastEntryIndex = Buffer->UserInformation.Buffer[*EntriesRead - 1].Index;
        }
        break;

    case DomainDisplayMachine:
    case DomainDisplayServer: 
        *EntriesRead = Buffer->MachineInformation.EntriesRead;
        if (*EntriesRead > 0)
        {
            *LastEntryIndex = Buffer->MachineInformation.Buffer[*EntriesRead - 1].Index;
        }
        break;

    case DomainDisplayGroup: 
        *EntriesRead = Buffer->GroupInformation.EntriesRead;
        if (*EntriesRead > 0)
        {
            *LastEntryIndex = Buffer->GroupInformation.Buffer[*EntriesRead - 1].Index;
        }
        break;

    case DomainDisplayOemUser: 
        *EntriesRead = Buffer->OemUserInformation.EntriesRead;
        if (*EntriesRead > 0)
        {
            *LastEntryIndex = Buffer->OemUserInformation.Buffer[*EntriesRead - 1].Index;
        }
        break;

    case DomainDisplayOemGroup: 
        *EntriesRead = Buffer->OemGroupInformation.EntriesRead;
        if (*EntriesRead > 0)
        {
            *LastEntryIndex = Buffer->GroupInformation.Buffer[*EntriesRead - 1].Index;
        }
        break;

    default:
        break; 
    }

    return;
}



NTSTATUS
SampDsCleanQDIBuffer(
  DOMAIN_DISPLAY_INFORMATION    DisplayInformation,
  PSAMPR_DISPLAY_INFO_BUFFER     Buffer
  )
/*++

  Routine Description:

    This routine cleans out the Query Display information buffer.

  Parameters:

    DisplayInformation -- Specifies the type of display information
    Buffer             -- The Buffer to clean out

--*/
{
    ULONG ReturnedItems;
    
    switch(DisplayInformation)
    {
    case DomainDisplayUser:
    
         ReturnedItems = Buffer->UserInformation.EntriesRead;
         while(ReturnedItems > 0) 
         {
            ReturnedItems --;
            SampFreeUserInfo((PDOMAIN_DISPLAY_USER)
                &(Buffer->UserInformation.Buffer[ReturnedItems]));
        }

        MIDL_user_free(Buffer->UserInformation.Buffer);
        Buffer->UserInformation.Buffer = NULL;
        break;

    case DomainDisplayGroup:
         ReturnedItems = Buffer->GroupInformation.EntriesRead;
         while(ReturnedItems > 0) 
         {
            ReturnedItems --;
            SampFreeGroupInfo((PDOMAIN_DISPLAY_GROUP)
                &(Buffer->GroupInformation.Buffer[ReturnedItems]));
        }

        MIDL_user_free(Buffer->GroupInformation.Buffer);
        Buffer->GroupInformation.Buffer = NULL;
        break;

    case DomainDisplayMachine:
    case DomainDisplayServer:
          
         ReturnedItems = Buffer->MachineInformation.EntriesRead;
         while(ReturnedItems > 0) 
         {
            ReturnedItems --;
            SampFreeMachineInfo((PDOMAIN_DISPLAY_MACHINE)
                &(Buffer->MachineInformation.Buffer[ReturnedItems]));
        }

        MIDL_user_free(Buffer->MachineInformation.Buffer);
        Buffer->MachineInformation.Buffer = NULL;
        break;

    case DomainDisplayOemUser:
         ReturnedItems = Buffer->UserInformation.EntriesRead;
         while(ReturnedItems > 0) 
         {
            ReturnedItems --;
            SampFreeOemUserInfo((PDOMAIN_DISPLAY_OEM_USER)
                &(Buffer->UserInformation.Buffer[ReturnedItems]));
        }

        MIDL_user_free(Buffer->UserInformation.Buffer);
        Buffer->UserInformation.Buffer = NULL;
        break;

    case DomainDisplayOemGroup:
         ReturnedItems = Buffer->GroupInformation.EntriesRead;
         while(ReturnedItems > 0) 
         {
            ReturnedItems --;
            SampFreeOemGroupInfo((PDOMAIN_DISPLAY_OEM_GROUP)
                &(Buffer->GroupInformation.Buffer[ReturnedItems]));
        }

        MIDL_user_free(Buffer->GroupInformation.Buffer);
        Buffer->GroupInformation.Buffer = NULL;
        break;

    default:

        ASSERT(FALSE && "Unknown Object Type");
        break;
    }
        
    return STATUS_SUCCESS;
}

NTSTATUS
SampDsBuildQDIFilter(
    DOMAIN_DISPLAY_INFORMATION  DisplayInformation,
    FILTER  *QDIFilter                
    )
/*++

    Builds a Filter for query of Display Information

    Parameters:

        DisplayInformation -- Display information type
        QDIFilter          -- Pointer to a filter structure
                              where the filter is builtin

    Return Values:

        STATUS_SUCCESS  - upon successfully building the filter
        STATUS_INSUFFICIENT_RESOURCES - upon memory alloc failures
        STATUS_INVALID_PARAMETER - Upon a junk Display Information type

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       SamAccountType;

    RtlZeroMemory(QDIFilter, sizeof(FILTER));

    if (DomainDisplayServer==DisplayInformation)
    {
        //
        // If backup domain controllers were required then
        // then request only user account control bit
        //

        QDIFilter->choice = FILTER_CHOICE_ITEM;
        QDIFilter->FilterTypes.Item.choice = FI_CHOICE_GREATER_OR_EQ;
        QDIFilter->FilterTypes.Item.FilTypes.ava.type = 
                SampDsAttrFromSamAttr(
                    SampUserObjectType,
                    SAMP_FIXED_USER_ACCOUNT_CONTROL
                    );

        QDIFilter->FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(ULONG);
        QDIFilter->FilterTypes.Item.FilTypes.ava.Value.pVal = 
                MIDL_user_allocate(sizeof(ULONG));
    
        if (NULL==QDIFilter->FilterTypes.Item.FilTypes.ava.Value.pVal)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        *((ULONG *)(QDIFilter->FilterTypes.Item.FilTypes.ava.Value.pVal))=
                               UF_SERVER_TRUST_ACCOUNT;
    }
    else
    {

        switch(DisplayInformation)
        {
        case DomainDisplayUser:
        case DomainDisplayOemUser:
            SamAccountType = SAM_NORMAL_USER_ACCOUNT;
            break;
    
        case DomainDisplayMachine:
            SamAccountType = SAM_MACHINE_ACCOUNT;
            break;

        case DomainDisplayGroup:
        case DomainDisplayOemGroup:
            SamAccountType = SAM_GROUP_OBJECT;
            break;

        default:
            return (STATUS_INVALID_PARAMETER);
        }

        QDIFilter->choice = FILTER_CHOICE_ITEM;
        QDIFilter->FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
        QDIFilter->FilterTypes.Item.FilTypes.ava.type = SampDsAttrFromSamAttr(
                                                           SampUnknownObjectType,
                                                           SAMP_UNKNOWN_ACCOUNT_TYPE
                                                           );

        QDIFilter->FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(ULONG);
        QDIFilter->FilterTypes.Item.FilTypes.ava.Value.pVal = 
                    MIDL_user_allocate(sizeof(ULONG));
    
        if (NULL==QDIFilter->FilterTypes.Item.FilTypes.ava.Value.pVal)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        *((ULONG *)(QDIFilter->FilterTypes.Item.FilTypes.ava.Value.pVal))=
                                   SamAccountType;
    }

Error:

    return Status;
}

VOID
SampDsFreeQDIFilter(
    FILTER  * QDIFilter
    )
/*++
    
      Routine Description
        
            This routine frees the filter built in the SampDSbuildQDIFilter
            routine. This routine must be kept in sync with the SampDSbuildQDIFilter
            rotuine
      Parameters:

        QDIFilter -- Filter that needs to be freed.

      Return Values -- None
--*/
{
    if (QDIFilter->FilterTypes.Item.FilTypes.ava.Value.pVal)
    {
        MIDL_user_free(
            QDIFilter->FilterTypes.Item.FilTypes.ava.Value.pVal);
    }

    QDIFilter->FilterTypes.Item.FilTypes.ava.Value.pVal=NULL;
}




NTSTATUS
SampDsPackQDI(
    SEARCHRES   *SearchRes,
    DOMAIN_DISPLAY_INFORMATION  DisplayInformation,
    ULONG       DomainIndex,
    ULONG       StartingIndex,
    PSAMPR_DISPLAY_INFO_BUFFER Buffer,
    PRESTART    *RestartToUse,
    PULONG      EntriesReturned
    )
/*++

    This routine Takes a DS search result and then packs it into a SAM display
    information structure. It uses the routines in display.c, originally developed
    to support NT4 style display cache structures to pack the results

    Parameters:
        
         SearchRes -- Search Results as returned by the DS.

         DisplayInformation   -- The type of Display Information
         Buffer               --  Buffer that stores the display information
         RestartToUse         --  If the DS returned a restart , then the restart structure
                                  is returned in here

    Return Values

        STATUS_SUCCESS for successful return
        Other Error codes upon Failure
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;


  
    //
    // Free the old restart structure
    //

    if (NULL!=*RestartToUse)
    {
        MIDL_user_free(*RestartToUse);
        *RestartToUse = NULL;
    }

    //
    // Copy in the newly returned restart structure
    //

    if (SearchRes->PagedResult.pRestart!=NULL)
    {

        NtStatus = SampCopyRestart(
                        SearchRes->PagedResult.pRestart,
                        RestartToUse
                        );
        if (!NT_SUCCESS(NtStatus))
            goto Error;
    }

    //
    // Pack in the results in the buffer provided
    //

    switch (DisplayInformation) {
    case DomainDisplayUser:
        NtStatus = SampPackUserDisplayInformation(
                        StartingIndex,
                        DomainIndex,
                        SearchRes,
                        EntriesReturned,
                        Buffer
                        );
        break;

    case DomainDisplayMachine:
    case DomainDisplayServer:
        NtStatus = SampPackMachineDisplayInformation(
                        StartingIndex,
                        DomainIndex,
                        SearchRes,
                        DisplayInformation,
                        EntriesReturned,
                        Buffer
                        );
        break;

    case DomainDisplayGroup:
        NtStatus = SampPackGroupDisplayInformation(
                        StartingIndex,
                        DomainIndex,
                        SearchRes,
                        EntriesReturned,
                        Buffer
                        );
        break;

    case DomainDisplayOemUser:
        NtStatus = SampPackOemUserDisplayInformation(
                        StartingIndex,
                        DomainIndex,
                        SearchRes,
                        EntriesReturned,
                        Buffer
                        );
        break;

    case DomainDisplayOemGroup:
        NtStatus = SampPackOemGroupDisplayInformation(
                        StartingIndex,
                        DomainIndex,
                        SearchRes,
                        EntriesReturned,
                        Buffer
                        );
        break;

    default:
        NtStatus = STATUS_INVALID_INFO_CLASS;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        return(NtStatus);
    }

    
Error:

    //
    // Cleanup on Error
    //

    if (!NT_SUCCESS(NtStatus))
    {
        if (NULL!=*RestartToUse)
        {
            MIDL_user_free(*RestartToUse);
            *RestartToUse = NULL;
        }
    }

    return NtStatus;
}

  
    
NTSTATUS
SampPackUserDisplayInformation(
    ULONG       StartingIndex,
    ULONG       DomainIndex,
    SEARCHRES   *SearchRes,
    PULONG      EntriesReturned,
    PSAMPR_DISPLAY_INFO_BUFFER Buffer
    )
/*++

    Routine Description:

        This routine packs the returned DS search results into the buffer
        if User Display information was requested.

    Parameters;

        Starting Index -- the starting offset that the first entry in the
                          DS search results should correspond to.
        SearchRes      -- The DS search results

        Buffer         -- The buffer in which the display information need to
                          be packed.

    Return Values

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES
--*/
{
    NTSTATUS    NtStatus=STATUS_SUCCESS;
    ENTINFLIST  *CurrentEntInf;
    ULONG       Index = StartingIndex;
    ULONG       ReturnedItems=Buffer->UserInformation.EntriesRead;

    
    //
    // Walk through the Search Res, adding each object to the buffer
    //

    *EntriesReturned = 0;
    for (CurrentEntInf = &(SearchRes->FirstEntInf);
                CurrentEntInf!=NULL;
                CurrentEntInf=CurrentEntInf->pNextEntInf)
        {
          PSID                  DomainSid = NULL;
          PSID                  ReturnedSid;
          ULONG                 AccountControlValue;
          DOMAIN_DISPLAY_USER   DisplayElement;
          BOOLEAN               FullNamePresent = FALSE;
          BOOLEAN               AdminCommentPresent=FALSE;
          ULONG                 NameOffset, AccCntrlOffset,
                                AccCntrlComputedOffset,
                                FullNameOffset, AdminCommentOffset;
          ULONG                 Rid;

          // 
          //  Check that the count of Attrs is normal. If Not
          //  Fail the Call if the returned count is not the 
          //  Same as Expected Count
          //
          //

          NtStatus = SampDsCheckDisplayAttributes(
                        &(CurrentEntInf->Entinf.AttrBlock),
                        DomainDisplayUser,
                        &NameOffset,
                        &AccCntrlOffset,
                        &AccCntrlComputedOffset,
                        &FullNameOffset,
                        &AdminCommentOffset,
                        &FullNamePresent,
                        &AdminCommentPresent
                        );
          if (!NT_SUCCESS(NtStatus))
          {
              //
              // This amounts to the fact that required properties such as
              // SID , account control, account Name etc are absent. We will
              // assert and then skip the current object and continue processing
              // from the next object onwards.
              //

              NtStatus = STATUS_SUCCESS;
              continue;
          }


          //
          // Get the Index
          //

          DisplayElement.Index = Index+1;

          //
          // Get the RID, Remember DS returns us a SID, so get the Rid Part out.
          // Also check that the object belongs to the requested domain
          //

          
          ReturnedSid = &(CurrentEntInf->Entinf.pName->Sid);
          NtStatus = SampSplitSid(
                        ReturnedSid,
                        &DomainSid,
                        &Rid
                        );
          if (NT_SUCCESS(NtStatus))
          {
              if (!RtlEqualSid(
                     DomainSid,SampDefinedDomains[DomainIndex].Sid))
              {                 
                 MIDL_user_free(DomainSid);
                 DomainSid = NULL;
                 continue;
              }
              MIDL_user_free(DomainSid);
              DomainSid = NULL;
          }
          else
              goto Error;

          DisplayElement.Rid = Rid;
          DisplayElement.AccountControl = * ((ULONG *)
                CurrentEntInf->Entinf.AttrBlock.pAttr[AccCntrlOffset].AttrVal.pAVal->pVal);

          DisplayElement.AccountControl |= * ((ULONG *)
                CurrentEntInf->Entinf.AttrBlock.pAttr[AccCntrlComputedOffset].AttrVal.pAVal->pVal);



          //
          // Copy the Name
          //

          NtStatus = DsValToUnicodeString(
                        &(DisplayElement.LogonName),
                        CurrentEntInf->Entinf.AttrBlock.pAttr[NameOffset].AttrVal.pAVal->valLen,
                        CurrentEntInf->Entinf.AttrBlock.pAttr[NameOffset].AttrVal.pAVal->pVal
                        );
          if (!NT_SUCCESS(NtStatus))
          {
              goto Error;
          }

          //
          // Copy the Admin Comment
          //

          if (AdminCommentPresent)
          {
            NtStatus = DsValToUnicodeString(
                            &(DisplayElement.AdminComment),
                            CurrentEntInf->Entinf.AttrBlock.pAttr[AdminCommentOffset].AttrVal.pAVal->valLen,
                            CurrentEntInf->Entinf.AttrBlock.pAttr[AdminCommentOffset].AttrVal.pAVal->pVal
                            );
            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }
          }
          else
          {
              DisplayElement.AdminComment.Length=0;
              DisplayElement.AdminComment.MaximumLength = 0;
              DisplayElement.AdminComment.Buffer = NULL;
          }


          //
          // Copy the Full Name portion
          //

          if (FullNamePresent)
          {
            NtStatus = DsValToUnicodeString(
                            &(DisplayElement.FullName),
                            CurrentEntInf->Entinf.AttrBlock.pAttr[FullNameOffset].AttrVal.pAVal->valLen,
                            CurrentEntInf->Entinf.AttrBlock.pAttr[FullNameOffset].AttrVal.pAVal->pVal
                            );
            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }
          }
          else
          {
              DisplayElement.FullName.Length=0;
              DisplayElement.FullName.MaximumLength = 0;
              DisplayElement.FullName.Buffer = NULL;
          }


          //
          // Add the Element to the Buffer
          // 
          NtStatus = SampDuplicateUserInfo(
                        (PDOMAIN_DISPLAY_USER) 
                                &(Buffer->UserInformation.Buffer[ReturnedItems]),
                        (PDOMAIN_DISPLAY_USER) &DisplayElement,
                        DNTFromShortDSName(CurrentEntInf->Entinf.pName)  // use this entry's DNT as Index 
                        );

          if (!NT_SUCCESS(NtStatus))
          {
              goto Error;
          }

          Index++;
          ReturnedItems++;
          (*EntriesReturned)++;

        }

        //
        // End of For Loop
        //    
    
Error:
   
        Buffer->UserInformation.EntriesRead = ReturnedItems;
        

    return NtStatus;

 }


NTSTATUS
SampPackMachineDisplayInformation(
    ULONG       StartingIndex,
    ULONG       DomainIndex,
    SEARCHRES   *SearchRes,
    DOMAIN_DISPLAY_INFORMATION DisplayType,
    PULONG      EntriesReturned,
    PSAMPR_DISPLAY_INFO_BUFFER Buffer
    )
/*++

    Routine Description:

        This routine packs the returned DS search results into the buffer
        if Machine Display information was requested.

    Parameters;

        Starting Index -- the starting offset that the first entry in the
                          DS search results should correspond to.
        SearchRes      -- The DS search results

        DisplayType    -- If DomainDisplayServer was specified then this discards
                          any entries not having a user account control of
                          USER_SERVER_TRUST_ACCOUNT

        Buffer         -- The buffer in which the display information need to
                          be packed.

    Return Values

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES
--*/

{
    NTSTATUS    NtStatus=STATUS_SUCCESS;
    ENTINFLIST  *CurrentEntInf;
    ULONG       Index = StartingIndex;
    ULONG       ReturnedItems=Buffer->MachineInformation.EntriesRead;

    
    //
    // Walk through the Search Res, adding each object to the buffer
    //

    *EntriesReturned = 0;
    for (CurrentEntInf = &(SearchRes->FirstEntInf);
                CurrentEntInf!=NULL;
                CurrentEntInf=CurrentEntInf->pNextEntInf)
        {
          PSID                  DomainSid = NULL;
          PSID                  ReturnedSid;
          ULONG                 AccountControlValue;
          DOMAIN_DISPLAY_MACHINE DisplayElement;
          BOOLEAN               FullNamePresent;
          BOOLEAN               AdminCommentPresent;
          ULONG                 NameOffset, AccCntrlOffset,
                                AccCntrlComputedOffset,
                                FullNameOffset, AdminCommentOffset;
          ULONG                 Rid;

          // 
          //  Check that the count of Attrs is normal. If Not
          //  Fail the Call if the returned count is not the 
          //  Same as Expected Count
          //
          //

          NtStatus = SampDsCheckDisplayAttributes(
                        &(CurrentEntInf->Entinf.AttrBlock),
                        DomainDisplayMachine,
                        &NameOffset,
                        &AccCntrlOffset,
                        &AccCntrlComputedOffset,
                        &FullNameOffset,
                        &AdminCommentOffset,
                        &FullNamePresent,
                        &AdminCommentPresent
                        );
          if (!NT_SUCCESS(NtStatus))
          {
              //
              // This amounts to the fact that required properties such as
              // SID , account control, account Name etc are absent. We will
              // assert and then skip the current object and continue processing
              // from the next object onwards.
              //

              NtStatus = STATUS_SUCCESS;
              continue;
          }


          //
          // Get the Index
          //

          DisplayElement.Index = Index+1;

          //
          // Get the account control
          //

           DisplayElement.AccountControl = * ((ULONG *)
                CurrentEntInf->Entinf.AttrBlock.pAttr[AccCntrlOffset].AttrVal.pAVal->pVal);

           DisplayElement.AccountControl |= * ((ULONG *)
                 CurrentEntInf->Entinf.AttrBlock.pAttr[AccCntrlComputedOffset].AttrVal.pAVal->pVal);


          //
          // Manually Filter on User account control if server's were specified as
          // the display type
          //

          if (DomainDisplayServer==DisplayType)
          {
              if (!(DisplayElement.AccountControl & USER_SERVER_TRUST_ACCOUNT))
              {
                  continue;
              }
          }

          //
          // Get the RID, Remember DS returns us a SID, so get the Rid Part out.
          // Also check that the object belongs to the requested domain
          //

          
          ReturnedSid = &(CurrentEntInf->Entinf.pName->Sid);
          NtStatus = SampSplitSid(
                        ReturnedSid,
                        &DomainSid,
                        &Rid
                        );
          if (NT_SUCCESS(NtStatus))
          {
              if (!RtlEqualSid(
                     DomainSid,SampDefinedDomains[DomainIndex].Sid))
              {                 
                 MIDL_user_free(DomainSid);
                 DomainSid = NULL;
                 continue;
              }
              MIDL_user_free(DomainSid);
              DomainSid = NULL;
          }
          else
              goto Error;

          DisplayElement.Rid = Rid;
         

          //
          // Copy the Name
          //

          NtStatus = DsValToUnicodeString(
                        &(DisplayElement.Machine),
                        CurrentEntInf->Entinf.AttrBlock.pAttr[NameOffset].AttrVal.pAVal->valLen,
                        CurrentEntInf->Entinf.AttrBlock.pAttr[NameOffset].AttrVal.pAVal->pVal
                        );
          if (!NT_SUCCESS(NtStatus))
          {
              goto Error;
          }

          //
          // Copy the Admin Comment
          //

          if (AdminCommentPresent)
          {
            NtStatus = DsValToUnicodeString(
                            &(DisplayElement.Comment),
                            CurrentEntInf->Entinf.AttrBlock.pAttr[AdminCommentOffset].AttrVal.pAVal->valLen,
                            CurrentEntInf->Entinf.AttrBlock.pAttr[AdminCommentOffset].AttrVal.pAVal->pVal
                            );
            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }
          }
          else
          {
              DisplayElement.Comment.Length=0;
              DisplayElement.Comment.MaximumLength = 0;
              DisplayElement.Comment.Buffer = NULL;
          }


          //
          // Add the Element to the Buffer
          // 
          NtStatus = SampDuplicateMachineInfo(
                        (PDOMAIN_DISPLAY_MACHINE) 
                                &(Buffer->MachineInformation.Buffer[ReturnedItems]),
                        (PDOMAIN_DISPLAY_MACHINE) &DisplayElement,
                        DNTFromShortDSName(CurrentEntInf->Entinf.pName)  // use this entry's DNT as Index 
                        );

          if (!NT_SUCCESS(NtStatus))
          {
              goto Error;
          }

          Index++;
          ReturnedItems++;
          (*EntriesReturned)++;

        }

        //
        // End of For Loop
        //    
    
Error:
        
    Buffer->MachineInformation.EntriesRead = ReturnedItems;
        

    return NtStatus;

 }

NTSTATUS
SampPackGroupDisplayInformation(
    ULONG       StartingIndex,
    ULONG       DomainIndex,
    SEARCHRES   *SearchRes,
    PULONG      EntriesReturned,
    PSAMPR_DISPLAY_INFO_BUFFER Buffer
    )
/*++

    Routine Description:

        This routine packs the returned DS search results into the buffer
        if Group Display information was requested.

    Parameters;

        Starting Index -- the starting offset that the first entry in the
                          DS search results should correspond to.
        SearchRes      -- The DS search results

        Buffer         -- The buffer in which the display information need to
                          be packed.

    Return Values

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES
--*/

{
    NTSTATUS    NtStatus=STATUS_SUCCESS;
    ENTINFLIST  *CurrentEntInf;
    ULONG       Index = StartingIndex;
    ULONG       ReturnedItems=Buffer->GroupInformation.EntriesRead;

    
    //
    // Walk through the Search Res, adding each object to the buffer
    //

    *EntriesReturned = 0;
    for (CurrentEntInf = &(SearchRes->FirstEntInf);
                CurrentEntInf!=NULL;
                CurrentEntInf=CurrentEntInf->pNextEntInf)
        {
          PSID                  DomainSid = NULL;
          PSID                  ReturnedSid;
          ULONG                 AccountControlValue;
          DOMAIN_DISPLAY_GROUP  DisplayElement;
          BOOLEAN               FullNamePresent;
          BOOLEAN               AdminCommentPresent;
          ULONG                 NameOffset, AccCntrlOffset,
                                AccCntrlComputedOffset,
                                FullNameOffset, AdminCommentOffset;
          ULONG                 Rid;

          // 
          //  Check that the count of Attrs is normal. If Not
          //  Fail the Call if the returned count is not the 
          //  Same as Expected Count
          //
          //

          NtStatus = SampDsCheckDisplayAttributes(
                        &(CurrentEntInf->Entinf.AttrBlock),
                        DomainDisplayGroup,
                        &NameOffset,
                        &AccCntrlOffset,
                        &AccCntrlComputedOffset,
                        &FullNameOffset,
                        &AdminCommentOffset,
                        &FullNamePresent,
                        &AdminCommentPresent
                        );

          if (!NT_SUCCESS(NtStatus))
          {
              //
              // This amounts to the fact that required properties such as
              // SID , account control, account Name etc are absent. We will
              // assert and then skip the current object and continue processing
              // from the next object onwards.
              //

              NtStatus = STATUS_SUCCESS;
              continue;
          }


          //
          // Get the Index
          //

          DisplayElement.Index = Index+1;

          //
          // Get the RID, Remember DS returns us a SID, so get the Rid Part out.
          // Also check that the object belongs to the requested domain
          //

          
          ReturnedSid = &(CurrentEntInf->Entinf.pName->Sid);
          NtStatus = SampSplitSid(
                        ReturnedSid,
                        &DomainSid,
                        &Rid
                        );

          if (NT_SUCCESS(NtStatus))
          {
              if (!RtlEqualSid(
                     DomainSid,SampDefinedDomains[DomainIndex].Sid))
              {                 
                 MIDL_user_free(DomainSid);
                 DomainSid = NULL;
                 continue;
              }
              MIDL_user_free(DomainSid);
              DomainSid = NULL;
          }
          else
              goto Error;

          DisplayElement.Rid = Rid;
          
          //
          // Copy the Name
          //

          NtStatus = DsValToUnicodeString(
                        &(DisplayElement.Group),
                        CurrentEntInf->Entinf.AttrBlock.pAttr[NameOffset].AttrVal.pAVal->valLen,
                        CurrentEntInf->Entinf.AttrBlock.pAttr[NameOffset].AttrVal.pAVal->pVal
                        );

          if (!NT_SUCCESS(NtStatus))
          {
              goto Error;
          }

          //
          // Copy the Admin Comment
          //

          if (AdminCommentPresent)
          {
            NtStatus = DsValToUnicodeString(
                            &(DisplayElement.Comment),
                            CurrentEntInf->Entinf.AttrBlock.pAttr[AdminCommentOffset].AttrVal.pAVal->valLen,
                            CurrentEntInf->Entinf.AttrBlock.pAttr[AdminCommentOffset].AttrVal.pAVal->pVal
                            );
            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }
          }
          else
          {
              DisplayElement.Comment.Length=0;
              DisplayElement.Comment.MaximumLength = 0;
              DisplayElement.Comment.Buffer = NULL;
          }

          //
          // Add the Element to the Buffer
          //
          
          NtStatus = SampDuplicateGroupInfo(
                        (PDOMAIN_DISPLAY_GROUP) 
                                &(Buffer->GroupInformation.Buffer[ReturnedItems]),
                        (PDOMAIN_DISPLAY_GROUP) &DisplayElement,
                        DNTFromShortDSName(CurrentEntInf->Entinf.pName)  // use this entry's DNT as Index 
                        );

          if (!NT_SUCCESS(NtStatus))
          {
              goto Error;
          }

          Index++;
          ReturnedItems++;
          (*EntriesReturned)++;

        }

        //
        // End of For Loop
        //    
    
Error:

        Buffer->GroupInformation.EntriesRead = ReturnedItems;
   

    return NtStatus;

 }

NTSTATUS
SampPackOemGroupDisplayInformation(
    ULONG       StartingIndex,
    ULONG       DomainIndex,
    SEARCHRES   *SearchRes,
    PULONG      EntriesReturned,
    PSAMPR_DISPLAY_INFO_BUFFER Buffer
    )
/*++

    Routine Description:

        This routine packs the returned DS search results into the buffer
        if OemGroup Display information was requested.

    Parameters;

        Starting Index -- the starting offset that the first entry in the
                          DS search results should correspond to.
        SearchRes      -- The DS search results

        Buffer         -- The buffer in which the display information need to
                          be packed.

    Return Values

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES
--*/
{
    NTSTATUS    NtStatus=STATUS_SUCCESS;
    ENTINFLIST  *CurrentEntInf;
    ULONG       Index = StartingIndex;
    ULONG       ReturnedItems=Buffer->OemGroupInformation.EntriesRead;

    
    //
    // Walk through the Search Res, adding each object to the buffer
    //

    *EntriesReturned = 0;
    for (CurrentEntInf = &(SearchRes->FirstEntInf);
                CurrentEntInf!=NULL;
                CurrentEntInf=CurrentEntInf->pNextEntInf)
        {
          PSID                      DomainSid = NULL;
          PSID                      ReturnedSid;
          ULONG                     AccountControlValue;
          DOMAIN_DISPLAY_GROUP      DisplayElement;
          BOOLEAN                   FullNamePresent;
          BOOLEAN                   AdminCommentPresent;
          ULONG                     NameOffset, AccCntrlOffset,
                                    AccCntrlComputedOffset,
                                    FullNameOffset, AdminCommentOffset;
          ULONG                     Rid;

          // 
          //  Check that the count of Attrs is normal. If Not
          //  Fail the Call if the returned count is not the 
          //  Same as Expected Count
          //
          //

          NtStatus = SampDsCheckDisplayAttributes(
                        &(CurrentEntInf->Entinf.AttrBlock),
                        DomainDisplayOemGroup,
                        &NameOffset,
                        &AccCntrlOffset,
                        &AccCntrlComputedOffset,
                        &FullNameOffset,
                        &AccCntrlOffset,
                        &FullNamePresent,
                        &AdminCommentPresent
                        );

          if (!NT_SUCCESS(NtStatus))
          {
              //
              // This amounts to the fact that required properties such as
              // SID , account control, account Name etc are absent. We will
              // assert and then skip the current object and continue processing
              // from the next object onwards.
              //

              NtStatus = STATUS_SUCCESS;
              continue;
          }


          //
          // Get the Index
          //

          DisplayElement.Index = Index+1;

          
          //
          // Copy the Name
          //

          NtStatus = DsValToUnicodeString(
                        &(DisplayElement.Group),
                        CurrentEntInf->Entinf.AttrBlock.pAttr[NameOffset].AttrVal.pAVal->valLen,
                        CurrentEntInf->Entinf.AttrBlock.pAttr[NameOffset].AttrVal.pAVal->pVal
                        );

          if (!NT_SUCCESS(NtStatus))
          {
              goto Error;
          }

          
          //
          // Add the Element to the Buffer
          // 
          NtStatus = SampDuplicateOemGroupInfo(
                        (PDOMAIN_DISPLAY_OEM_GROUP) 
                                &(Buffer->OemGroupInformation.Buffer[ReturnedItems]),
                        (PDOMAIN_DISPLAY_GROUP) &DisplayElement,
                        DNTFromShortDSName(CurrentEntInf->Entinf.pName)  // use this entry's DNT as Index 
                        );

          if (!NT_SUCCESS(NtStatus))
          {
              goto Error;
          }

          Index++;
          ReturnedItems++;
          (*EntriesReturned)++;

        }

        //
        // End of For Loop
        //    
    
Error:
        
        Buffer->OemGroupInformation.EntriesRead = ReturnedItems;
        

    return NtStatus;

 }

NTSTATUS
SampPackOemUserDisplayInformation(
    ULONG       StartingIndex,
    ULONG       DomainIndex,
    SEARCHRES   *SearchRes,
    PULONG      EntriesReturned,
    PSAMPR_DISPLAY_INFO_BUFFER Buffer
    )
/*++

    Routine Description:

        This routine packs the returned DS search results into the buffer
        if Oem User Display information was requested.

    Parameters;

        Starting Index -- the starting offset that the first entry in the
                          DS search results should correspond to.
        SearchRes      -- The DS search results

        Buffer         -- The buffer in which the display information need to
                          be packed.

    Return Values

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES
--*/
{
    NTSTATUS    NtStatus=STATUS_SUCCESS;
    ENTINFLIST  *CurrentEntInf;
    ULONG       Index = StartingIndex;
    ULONG       ReturnedItems=Buffer->OemUserInformation.EntriesRead;

    
    //
    // Walk through the Search Res, adding each object to the buffer
    //

    *EntriesReturned = 0;
    for (CurrentEntInf = &(SearchRes->FirstEntInf);
                CurrentEntInf!=NULL;
                CurrentEntInf=CurrentEntInf->pNextEntInf)
        {
          PSID                      DomainSid = NULL;
          PSID                      ReturnedSid;
          ULONG                     AccountControlValue;
          DOMAIN_DISPLAY_USER       DisplayElement;
          BOOLEAN                   FullNamePresent;
          BOOLEAN                   AdminCommentPresent;
          ULONG                     NameOffset, AccCntrlOffset,
                                    AccCntrlComputedOffset,
                                    FullNameOffset, AdminCommentOffset;
          ULONG                     Rid;

          // 
          //  Check that the count of Attrs is normal. If Not
          //  Fail the Call if the returned count is not the 
          //  Same as Expected Count
          //
          //

          NtStatus = SampDsCheckDisplayAttributes(
                        &(CurrentEntInf->Entinf.AttrBlock),
                        DomainDisplayOemUser,
                        &NameOffset,
                        &AccCntrlOffset,
                        &AccCntrlComputedOffset,
                        &FullNameOffset,
                        &AccCntrlOffset,
                        &FullNamePresent,
                        &AdminCommentPresent
                        );

          if (!NT_SUCCESS(NtStatus))
          {
              //
              // This amounts to the fact that required properties such as
              // SID , account control, account Name etc are absent. We will
              // assert and then skip the current object and continue processing
              // from the next object onwards.
              //

              NtStatus = STATUS_SUCCESS;
              continue;
          }


          //
          // Get the Index
          //

          DisplayElement.Index = Index+1;

          
          //
          // Copy the Name
          //

          NtStatus = DsValToUnicodeString(
                        &(DisplayElement.LogonName),
                        CurrentEntInf->Entinf.AttrBlock.pAttr[NameOffset].AttrVal.pAVal->valLen,
                        CurrentEntInf->Entinf.AttrBlock.pAttr[NameOffset].AttrVal.pAVal->pVal
                        );

          if (!NT_SUCCESS(NtStatus))
          {
              goto Error;
          }

          
          //
          // Add the Element to the Buffer
          // 
          NtStatus = SampDuplicateOemUserInfo(
                        (PDOMAIN_DISPLAY_OEM_USER) 
                                &(Buffer->OemUserInformation.Buffer[ReturnedItems]),
                        (PDOMAIN_DISPLAY_USER) &DisplayElement,
                        DNTFromShortDSName(CurrentEntInf->Entinf.pName)  // use this entry's DNT as Index 
                        );

          if (!NT_SUCCESS(NtStatus))
          {
              goto Error;
          }

          Index++;
          ReturnedItems++;
          (*EntriesReturned)++;

        }

        //
        // End of For Loop
        //    
    
Error:
           
        Buffer->OemUserInformation.EntriesRead = ReturnedItems;
        
    return NtStatus;

 }


 NTSTATUS
 SampDsCheckDisplayAttributes(
     ATTRBLOCK * DsAttrs,
     DOMAIN_DISPLAY_INFORMATION  DisplayInformation,
     PULONG     ObjectNameOffset,
     PULONG     UserAccountControlOffset,
     PULONG     UserAcctCtrlComputedOffset,
     PULONG     FullNameOffset,
     PULONG     AdminCommentOffset,
     BOOLEAN    * FullNamePresent,
     BOOLEAN    * AdminCommentPresent
     )
/*++
  
    Routine Description:

      This routine Validates the attribute block returned by the DS for each 
      entry in the search results. For the attribute block to be valid required
      entries such as account name must be present. Further this routine will also
      compute the offset of both required and optional attributes returned by the DS
      in the attribute block. It will also indicate if the optional attributes are
      present or absent. Further This routine will translate from the Flags values 
      stored in the DS to user account control values used by SAM

    Parameters:

       DsAttrs   -- Attribute block returned by the DS
       DisplayInformation -- The type of display information the caller is interested in
       ObjectNameOffset -- The offset of the SAM account name property in the attribute
                            block
       UserAccountControlOffset -- The offset of the user account control field if present 
       FullNameOffset   --  The offset of the full name field if present
       AdminCommentOffset -- The offset of the admin comment attribute if present

       FullNamePresent   -- Indicates that the full name attribute is present
       AdminCommentPresent -- Indicates the at the admin comment attribute is present

    Return Values


        STATUS_SUCCESS -- If the attribute block was correctly validated
        STATUS_INTERNAL_ERROR - Otherwise
--*/
 {
     ULONG  i;
     BOOLEAN    NameFound = FALSE;
     BOOLEAN    AccountControlFound = FALSE;
     BOOLEAN    AccountControlComputedFound = FALSE;
     NTSTATUS   NtStatus = STATUS_INTERNAL_ERROR;

     //
     // Every Attrblock must have a SID, and an account Name
     //

     *FullNamePresent = FALSE;
     *AdminCommentPresent = FALSE;

     for (i=0;i<DsAttrs->attrCount;i++)
     {
         
         if (DsAttrs->pAttr[i].attrTyp 
                == SampDsAttrFromSamAttr(SampUnknownObjectType,SAMP_UNKNOWN_OBJECTNAME))
         {
             *ObjectNameOffset = i;
             NameFound = TRUE;
         }

         if (DsAttrs->pAttr[i].attrTyp 
                == SampDsAttrFromSamAttr(SampUserObjectType,SAMP_FIXED_USER_ACCOUNT_CONTROL))
         {
             NTSTATUS IgnoreStatus;

             *UserAccountControlOffset = i;
             AccountControlFound = TRUE;

             ASSERT(NULL!=DsAttrs->pAttr[i].AttrVal.pAVal);
             ASSERT(1==DsAttrs->pAttr[i].AttrVal.valCount);
             ASSERT(NULL!=DsAttrs->pAttr[i].AttrVal.pAVal[0].pVal);

             // Transalte this from Flags to account Control 
             IgnoreStatus = SampFlagsToAccountControl(
                                *((ULONG*)(DsAttrs->pAttr[i].AttrVal.pAVal[0].pVal)),
                                (ULONG *)DsAttrs->pAttr[i].AttrVal.pAVal[0].pVal
                                );

             // Flags better be right
             ASSERT(NT_SUCCESS(IgnoreStatus));
                                
         }

         if (DsAttrs->pAttr[i].attrTyp 
                == SampDsAttrFromSamAttr(SampUserObjectType,SAMP_FIXED_USER_ACCOUNT_CONTROL_COMPUTED))
         {
             NTSTATUS IgnoreStatus;

             *UserAcctCtrlComputedOffset = i;
             AccountControlComputedFound = TRUE;

             ASSERT(NULL!=DsAttrs->pAttr[i].AttrVal.pAVal);
             ASSERT(1==DsAttrs->pAttr[i].AttrVal.valCount);
             ASSERT(NULL!=DsAttrs->pAttr[i].AttrVal.pAVal[0].pVal);

             // Transalte this from Flags to account Control 
             IgnoreStatus = SampFlagsToAccountControl(
                                *((ULONG*)(DsAttrs->pAttr[i].AttrVal.pAVal[0].pVal)),
                                (ULONG *)DsAttrs->pAttr[i].AttrVal.pAVal[0].pVal
                                );

             // Flags better be right
             ASSERT(NT_SUCCESS(IgnoreStatus));
                                
         }


         if (DsAttrs->pAttr[i].attrTyp
                == SampDsAttrFromSamAttr(SampUserObjectType,SAMP_USER_ADMIN_COMMENT))
         {
             *AdminCommentOffset = i;
             *AdminCommentPresent= TRUE;
         }

         if (DsAttrs->pAttr[i].attrTyp
                == SampDsAttrFromSamAttr(SampUserObjectType,SAMP_USER_FULL_NAME))
         {
             *FullNameOffset = i;
             *FullNamePresent= TRUE;
         }
     }

     //
     // Check for presence of attributes
     //

     switch(DisplayInformation)
     {
     case DomainDisplayUser:
     case DomainDisplayMachine:
     case DomainDisplayOemUser:
     case DomainDisplayServer:

         if ((NameFound) && (AccountControlFound) && (AccountControlComputedFound))
             NtStatus = STATUS_SUCCESS;
         break;

     case DomainDisplayGroup:
     case DomainDisplayOemGroup:
         if (NameFound)
             NtStatus = STATUS_SUCCESS;
         break;
     default:
         break;
     }

         
     return NtStatus;
         
 }


NTSTATUS
SampGetQDIAvailable(
    PSAMP_OBJECT    DomainContext,
    DOMAIN_DISPLAY_INFORMATION  DisplayInformation,
    ULONG   *TotalAvailable
    )
/*++

    Routine Description:

        NT4 Display API allows the client to query the number of display 
        information bytes that are available in the server. Apparently this
        is only supported for DisplayInformation type of user. Unfortunately
        this short sighted API is impossible to implement correctly in the DS
        case. Doing so requires that we walk through every user object in the DS,
        evaluate the sum total of display attribute data in them and return this
        value to the client. Therefore this routine aims at returning only a very
        approximate total count.

    Parameters:

        DomainContext -- SAM handle to the domain object.
        DisplayInformation -- The type of display information
        TotalAvailable -- Bytes available are returned here

    Return values

        STATUS_SUCCESS
        Other Errors upon failure
--*/
{
    NTSTATUS NtStatus;
    ULONG    UserCount;
    ULONG    GroupCount;
    ULONG    AliasCount;

    *TotalAvailable = 0;

    NtStatus = SampRetrieveAccountCountsDs(
                    DomainContext,
                    TRUE,           // get approximate value
                    &UserCount,
                    &GroupCount,
                    &AliasCount
                    );
    if (NT_SUCCESS(NtStatus))
    {
        switch(DisplayInformation)
        {
        case DomainDisplayUser:

                //
                // Compute a very approximate total. User count includes
                // count of machines also, but who cares ?
                //

                *TotalAvailable = UserCount * DISPLAY_ENTRY_SIZE;
                DomainContext->TypeBody.Domain.DsDisplayState.TotalAvailable
                        = *TotalAvailable;
                break;
        default:
            //
            // Not supported for other information types. In these
            // cases an acceptable return value is 0
            //
            break;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
DsValToUnicodeString(
    PUNICODE_STRING UnicodeString,
    ULONG   Length,
    PVOID   pVal
    )
/*++
    Routine Description

        Small helper routine to convert a DS val to unicode string

--*/
{
    UnicodeString->Length = (USHORT) Length;
    UnicodeString->MaximumLength = (USHORT) Length;
    UnicodeString->Buffer = pVal;

    return STATUS_SUCCESS;
}

NTSTATUS
DsValToOemString(
    OEM_STRING  *OemString,
    ULONG       Length,
    PVOID       pVal
    )
/*++
    Routine Description

        Small helper routine to convert a DS val to a OEM string

--*/
{
    UNICODE_STRING TmpUnicodeString;
    NTSTATUS       NtStatus;

    TmpUnicodeString.Length = (USHORT) Length;
    TmpUnicodeString.MaximumLength = (USHORT) Length;
    TmpUnicodeString.Buffer = pVal;

    NtStatus = SampUnicodeToOemString(OemString,
                                      &TmpUnicodeString);

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\dsdomain.h ===
typedef struct _SAMP_DOMAIN_INFO
{
    // BUG: work in progress - what else should be stored here?

    UNICODE_STRING DomainName;                  // Domain display name
    PDSNAME DomainDsName;                       // Domain DS name
} SAMP_DOMAIN_INFO, *PSAMP_DOMAIN_INFO;

typedef struct _SAMP_DOMAIN_INIT_INFO
{
    ULONG DomainCount;                          // Count of returned domains
    PSAMP_DOMAIN_INFO DomainInfo;               // Array of domain information
} SAMP_DOMAIN_INIT_INFO, *PSAMP_DOMAIN_INIT_INFO;

NTSTATUS
SampExtendDefinedDomains(
    ULONG DomainCount
    );

NTSTATUS
SampDsInitializeDomainObject(
    PSAMP_DOMAIN_INFO DomainInfo,
    ULONG Index,
	BOOLEAN MixedDomain,
    ULONG   BehaviorVersion,
    DOMAIN_SERVER_ROLE ServerRole, 
    ULONG   LastLogonTimeStampSyncInterval
    );

NTSTATUS
SampDsInitializeDomainObjects(
    VOID
    );

NTSTATUS
SampDsGetDomainInitInfo(
    PSAMP_DOMAIN_INIT_INFO DomainInitInfo
    );

NTSTATUS
SamrCreateDomain(
    IN PWCHAR DomainName,
    IN ULONG DomainNameLength,
    IN BOOLEAN WriteLockHeld,
    OUT SAMPR_HANDLE *DomainHandle
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\dsmember.c ===
/*++
Copyright (c) 1996 Microsoft Corporation

Module Name:

    dsmember.c

Abstract:

    This file contains SAM private API Routines that manipulate
    membership related things in the DS.

Author:
    MURLIS

Revision History

    7-2-96 Murlis Created

--*/

#include <samsrvp.h>
#include <attids.h>
#include <dslayer.h>
#include <filtypes.h>
#include <dsmember.h>
#include <dsdsply.h>
#include <sdconvrt.h>
#include <malloc.h>



NTSTATUS
SampDsCreateForeignSecurityPrincipal(
    IN PSID pSid,
    IN DSNAME * DomainObjectName,
    OUT DSNAME **ppDsName
    );

NTSTATUS
SampDsCreateForeignContainer(
    IN DSNAME * DomainObjectName,
    OUT DSNAME ** ppContainerName
    );


VOID
SampDsFreeCachedMembershipOperationsList(
    IN PSAMP_OBJECT Context
    )
/*++

Routine Description:

    This routine will release the memory used to buffer membership operations for 
    group or alias. 

Parameters:

    Context -- Pointer to Object Context.

Return Values:

    None.

--*/

{
    ULONG  Index = 0;
    ULONG  *MaxLength = NULL;
    ULONG  *Count = NULL;
    PSAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY * MembershipOperationsList = NULL;
    
    SAMTRACE("SampDsFreeCachedMembershipOperationsList");
    
    if (SampGroupObjectType == Context->ObjectType)
    {
        MembershipOperationsList = & (Context->TypeBody.Group.CachedMembershipOperationsList);
        Count = & (Context->TypeBody.Group.CachedMembershipOperationsListLength);
        MaxLength = & (Context->TypeBody.Group.CachedMembershipOperationsListMaxLength);
    }
    else
    {
        ASSERT(SampAliasObjectType == Context->ObjectType);
        
        MembershipOperationsList = & (Context->TypeBody.Alias.CachedMembershipOperationsList);
        Count = & (Context->TypeBody.Alias.CachedMembershipOperationsListLength);
        MaxLength = & (Context->TypeBody.Alias.CachedMembershipOperationsListMaxLength);
    }
    
    if (NULL != *MembershipOperationsList)
    {
        for (Index = 0; Index < *MaxLength; Index++)
        {
            if (NULL != (*MembershipOperationsList)[Index].MemberDsName)
            {
                MIDL_user_free( (*MembershipOperationsList)[Index].MemberDsName );
            }
        }
        
        MIDL_user_free(*MembershipOperationsList);
        
        *MembershipOperationsList = NULL;
    }
    
    (*Count) = 0;
    (*MaxLength) = 0;

    return;    
}



NTSTATUS                        
SampDsFlushCachedMembershipOperationsList(
    IN PSAMP_OBJECT Context
)
/*++

Routine Description:

    This routine will write all buffered group / alias membership operations to DS
    After everything is done, this routine will zero the memory. 

Parameters:

    Context -- Pointer to group/alias object context.

Return Values:

    NTSTATUS -- STATUS_NO_MEMORY   
                ..

--*/

{
    NTSTATUS  NtStatus = STATUS_SUCCESS;
    ULONG     Index;
    ULONG     *MaxLength = NULL;
    ULONG     *Count = NULL;
    PSAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY * MembershipOperationsList = NULL;
    ATTRMODLIST * AttrModList = NULL;
    MODIFYARG   ModifyArg;
    MODIFYRES   *pModifyRes = NULL;
    ATTRMODLIST * CurrentMod = NULL, * NextMod = NULL, * LastMod = NULL;
    COMMARG     * pCommArg = NULL;
    ULONG       MembershipAttrType; 
    ULONG       RetValue;
    
    SAMTRACE("SampDsFlushCachedMembershipOperationsList");


    if (SampGroupObjectType == Context->ObjectType)
    {
        MembershipOperationsList = & (Context->TypeBody.Group.CachedMembershipOperationsList);
        Count = & (Context->TypeBody.Group.CachedMembershipOperationsListLength);
        MaxLength = & (Context->TypeBody.Group.CachedMembershipOperationsListMaxLength);
        MembershipAttrType = SampDsAttrFromSamAttr(
                                    SampGroupObjectType,
                                    SAMP_GROUP_MEMBERS
                                    );
    }
    else
    {
        ASSERT(SampAliasObjectType == Context->ObjectType);
        
        MembershipOperationsList = & (Context->TypeBody.Alias.CachedMembershipOperationsList);
        Count = & (Context->TypeBody.Alias.CachedMembershipOperationsListLength);
        MaxLength = & (Context->TypeBody.Alias.CachedMembershipOperationsListMaxLength);
        MembershipAttrType = SampDsAttrFromSamAttr(
                                    SampAliasObjectType, 
                                    SAMP_ALIAS_MEMBERS
                                    );
    }
    
    ASSERT(*Count);
    
    NtStatus = SampDoImplicitTransactionStart(TransactionWrite);
    
    if (STATUS_SUCCESS != NtStatus)
    {
        goto Error;
    }
    
    
    // 
    // allocate memory to hold all membership operations (add / remove) 
    // "*Count - 1" is because of FirstMod in ModifyArg can host one operation
    //
    // Using thread memory, because DirModifyEntry will merge the link-list
    // in DirModifyEntry. 
    // 
    if (*Count > 1)
    {
        AttrModList = (ATTRMODLIST *) DSAlloc( (*Count - 1) * sizeof(ATTRMODLIST) );
    
        if (NULL == AttrModList)
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Error;
        }
        
        memset(AttrModList, 0, (*Count - 1) * sizeof(ATTRMODLIST));
    }
    
    memset( &ModifyArg, 0, sizeof(ModifyArg) );
    CurrentMod = &(ModifyArg.FirstMod);
    NextMod = AttrModList;
    LastMod = NULL;
    
    for (Index = 0; Index < (*Count); Index++)
    {
        if ( ADD_VALUE == (*MembershipOperationsList)[Index].OpType)
        {
            CurrentMod->choice = AT_CHOICE_ADD_VALUES;
        }
        else 
        {
            ASSERT( REMOVE_VALUE == (*MembershipOperationsList)[Index].OpType);
            CurrentMod->choice = AT_CHOICE_REMOVE_VALUES;
        }
        
        CurrentMod->AttrInf.attrTyp = MembershipAttrType;
        
        CurrentMod->AttrInf.AttrVal.valCount = 1;
        CurrentMod->AttrInf.AttrVal.pAVal = DSAlloc(sizeof(ATTRVAL));
        
        if (NULL == CurrentMod->AttrInf.AttrVal.pAVal)
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Error; 
        }
        
        memset(CurrentMod->AttrInf.AttrVal.pAVal, 0, sizeof(ATTRVAL));
        
        CurrentMod->AttrInf.AttrVal.pAVal[0].valLen = 
                (*MembershipOperationsList)[Index].MemberDsName->structLen;
        
        CurrentMod->AttrInf.AttrVal.pAVal[0].pVal = 
                (PUCHAR) (*MembershipOperationsList)[Index].MemberDsName;
                
        LastMod = CurrentMod;
        CurrentMod->pNextMod = NextMod;
        CurrentMod = CurrentMod->pNextMod;
        NextMod = NextMod + 1;
        
    }
    
    if (LastMod)
    {
        LastMod->pNextMod = NULL;
    }
    else
    {
        // this should not happen
        ASSERT(FALSE && "NULL == LastMod");
    }
    
    pCommArg = &(ModifyArg.CommArg);
    BuildStdCommArg(pCommArg);
    
    ModifyArg.pObject = Context->ObjectNameInDs;
    ModifyArg.count = (USHORT) *Count;
    
    SAMTRACE_DS("DirModifyEntry\n");
    
    RetValue = DirModifyEntry(&ModifyArg, &pModifyRes);
    
    SAMTRACE_RETURN_CODE_DS(RetValue);
    
    if (NULL == pModifyRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetValue, &pModifyRes->CommRes);
    }
    
    if (STATUS_DS_ATTRIBUTE_OR_VALUE_EXISTS==NtStatus)
    {
        NtStatus = STATUS_MEMBER_IN_ALIAS;
    }
    else 
    {
        if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE==NtStatus)
        {
            NtStatus = STATUS_MEMBER_NOT_IN_ALIAS;
        }
    }
    
Error:    

    // 
    // Clear any error
    //
    SampClearErrors();
    
    //
    // Turn the fDSA flag back on as in loopback cases this can get reset
    //
    SampSetDsa(TRUE);
    
    // 
    // release memory occupied by MemberDsName
    // 
    for (Index = 0; Index < (*Count); Index++)
    {
        if (NULL != (*MembershipOperationsList)[Index].MemberDsName)
        {
            MIDL_user_free( (*MembershipOperationsList)[Index].MemberDsName );
        }
        
    }
    
    RtlZeroMemory(*MembershipOperationsList,
                  (*MaxLength) * sizeof(SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY)
                  );
    
    *Count = 0;
    
    return NtStatus;
}



NTSTATUS
SampDsAddMembershipOperationToCache(
    IN PSAMP_OBJECT Context, 
    IN ULONG        OperationType,
    IN DSNAME       * MemberDsName
)
/*++

Routine Description:

    This routine adds one membership operation (add/remove) to the context's buffer. 
    At the very beginning, it will allocate INIT_MEMBERSHIP_OPERATION_NUMBER slots for 
    membership operations. If more membership operations need to be buffered, this 
    routine will extend the buffer to MAX_MEMBERSHIP_OPERATION_NUMBER. 
    
    When buffered operations fill the buffer, we will flush all these operaions to DS.
    
    If any error occurs, this routine will discard already buffered membership operations.       
    
Parameters:

    Context -- Pointer to Object's Context
    
    OperationType -- ADD_VALUE or REMOVE_VALUE, specify the membership operation.
    
    MemberDsName -- Pointer to the DSNAME, which should be added to or removed from the 
                    group/alias Member Attribute.

Return Values:

    NTSTATUS - STATUS_NO_MEMORY, 
               or return value from SampDsFlushCachedMembershipOperationsList().

--*/ 

{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       Index;
    ULONG       *MaxLength = NULL;
    ULONG       *Count = NULL;
    SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY ** MembershipOperationsList = NULL;
    SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY * TmpMembershipOperationsList = NULL; 
    
    SAMTRACE("SampDsAddMembershipOperationToCache");
    
    ASSERT(NULL != Context);
    ASSERT(ADD_VALUE == OperationType || REMOVE_VALUE == OperationType);
    ASSERT(NULL != MemberDsName);
    
    if (SampGroupObjectType == Context->ObjectType)
    {
        MembershipOperationsList = & (Context->TypeBody.Group.CachedMembershipOperationsList);
        Count = & (Context->TypeBody.Group.CachedMembershipOperationsListLength);
        MaxLength = & (Context->TypeBody.Group.CachedMembershipOperationsListMaxLength);
    }
    else
    {
        ASSERT(SampAliasObjectType == Context->ObjectType);
        
        MembershipOperationsList = & (Context->TypeBody.Alias.CachedMembershipOperationsList);
        Count = & (Context->TypeBody.Alias.CachedMembershipOperationsListLength);
        MaxLength = & (Context->TypeBody.Alias.CachedMembershipOperationsListMaxLength);
    }
    
    // 
    // Allocate small amount of memory at beginning.
    //     
    
    if (NULL == *MembershipOperationsList)
    {
        *MembershipOperationsList =  
            MIDL_user_allocate(INIT_MEMBERSHIP_OPERATION_NUMBER * sizeof(SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY));
        
        if (NULL == *MembershipOperationsList)
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Error;
        }
        
        RtlZeroMemory(*MembershipOperationsList, 
                      INIT_MEMBERSHIP_OPERATION_NUMBER * sizeof(SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY));
        
        (*Count) = 0;
        
        (*MaxLength) = INIT_MEMBERSHIP_OPERATION_NUMBER;
    }
    
    //
    // Extend memory if necessary
    //    
    
    if ((INIT_MEMBERSHIP_OPERATION_NUMBER <= *Count) &&
        (INIT_MEMBERSHIP_OPERATION_NUMBER == *MaxLength) )
    {
        
        TmpMembershipOperationsList = 
            MIDL_user_allocate(MAX_MEMBERSHIP_OPERATION_NUMBER * sizeof(SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY));
        
        if (NULL == TmpMembershipOperationsList)
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Error;
        }
        
        RtlZeroMemory(TmpMembershipOperationsList, 
                      MAX_MEMBERSHIP_OPERATION_NUMBER * sizeof(SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY)
                      );
        
        RtlCopyMemory(TmpMembershipOperationsList, 
                      *MembershipOperationsList, 
                      INIT_MEMBERSHIP_OPERATION_NUMBER * sizeof(SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY)
                      );
        
        MIDL_user_free(*MembershipOperationsList);
        
        *MembershipOperationsList = TmpMembershipOperationsList;
        TmpMembershipOperationsList = NULL;
        
        (*MaxLength) = MAX_MEMBERSHIP_OPERATION_NUMBER;
    }
    
    //
    // Fill one membership operation slot
    //     
    
    (*MembershipOperationsList)[*Count].OpType = OperationType;
    (*MembershipOperationsList)[*Count].MemberDsName = MIDL_user_allocate(MemberDsName->structLen); 
                                            
    if (NULL == (*MembershipOperationsList)[*Count].MemberDsName)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Error;
    }
    
    RtlZeroMemory((*MembershipOperationsList)[*Count].MemberDsName, 
                  MemberDsName->structLen
                  );
                  
    RtlCopyMemory((*MembershipOperationsList)[*Count].MemberDsName, 
                  MemberDsName, 
                  MemberDsName->structLen
                  );
    
    (*Count) ++;
    
    // 
    // Flush the buffered membership operations if we reach upper limit. 
    // and SampDsFlushCachedMembershipOperaionsList will do the cleanup work and reset Count
    // 
    
    if (MAX_MEMBERSHIP_OPERATION_NUMBER <= *Count)
    {
        NtStatus = SampDsFlushCachedMembershipOperationsList(Context);
    }
    
    return NtStatus;
    
Error: 

    // 
    // If any error occured, cleanup everything. 
    // Discard all buffered operations.
    // Reset Count 
    // 

    if (NULL != *MembershipOperationsList)
    {
        for (Index = 0; Index < *Count; Index++)
        {
            if (NULL != (*MembershipOperationsList)[Index].MemberDsName)
            {
                MIDL_user_free( (*MembershipOperationsList)[Index].MemberDsName );
            }
        }
        
        RtlZeroMemory(*MembershipOperationsList, 
                      (*MaxLength) * sizeof(SAMP_MEMBERSHIP_OPERATIONS_LIST_ENTRY)
                      );
    }
    
    (*Count) = 0;

    return NtStatus;
}


NTSTATUS
SampDsGetAliasMembershipOfAccount(
    IN DSNAME       *DomainDn,
    IN DSNAME       *AccountDn,
    OUT PULONG      MemberCount OPTIONAL,
    IN OUT PULONG   BufferSize  OPTIONAL,
    OUT PULONG      Buffer      OPTIONAL
    )
/*++

  Routine Description:

        This routine gives the alias membership list of a given
        account SID, in the domain speicified by DomainObjectName,
        in the DS. This list is used in computing the given user's
        Token.

  Arguments:

        DomainDn         -- DSNAME of the Domain, in which evaluation is done.
        AccountDn        -- DSNAME of the Account
        MemberCount      -- List of Aliases this is a member of
        BufferSize       -- Passed in by caller if he has already allocated a Buffer
        Buffer           -- Buffer to hold things in, Pointer can hold
                            NULL, if caller wants us to allocate

  Return Values

        STATUS_SUCCESS
        Other Error codes From DS Layer.
--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       cSid;
    PDSNAME     * rpDsNames = NULL;
    ULONG       BufferReqd;
    BOOLEAN     BufferAllocated = FALSE;
    ULONG       Index;





    ASSERT(ARGUMENT_PRESENT(MemberCount));

    *MemberCount = 0;

    //
    // Look at the DS object
    //

    if (NULL==AccountDn)
    {
        //
        // Do not fail the call. Return 0 member count
        //

        if (ARGUMENT_PRESENT(BufferSize))
            *BufferSize = 0;
        Status = STATUS_SUCCESS;
        return(Status);
    }


    // Perform lazy thread and transaction initialization.
    Status = SampMaybeBeginDsTransaction(SampDsTransactionType);

    if (Status!= STATUS_SUCCESS)
        goto Error;

    //
    // Get the reverse membership list
    //

    Status = SampGetMemberships(
                &AccountDn,
                1,
                DomainDn,
                RevMembGetAliasMembership,
                &cSid,
                &rpDsNames,
                NULL,
                NULL,
                NULL
                );

    if (!NT_SUCCESS(Status))
        goto Error;


    BufferReqd = cSid * sizeof(ULONG);
    *MemberCount = cSid;

    if (ARGUMENT_PRESENT(Buffer)&&(*MemberCount>0))
    {

        //
        // Buffer size must be provided.
        //

        if (!ARGUMENT_PRESENT(BufferSize))
        {
           Status = STATUS_INVALID_PARAMETER;
           goto Error;
        }

        if (NULL == Buffer)
        {
            //
            // Buffer size must be provided and equal to 0
            //

            if (0!=*BufferSize)
            {

                Status = STATUS_INVALID_PARAMETER;
                goto Error;
            }
            else
            {
                //
                // Allocate buffer
                //

                Buffer = MIDL_user_allocate(BufferReqd);
                if (NULL== Buffer)
                {
                    Status = STATUS_NO_MEMORY;
                    goto Error;
                }

                *BufferSize = BufferReqd;
                BufferAllocated = TRUE;
            }
        }
        else
        {
            if (*BufferSize < BufferReqd)
            {
                //
                // Less buffer than what is required
                //

                Status = STATUS_BUFFER_OVERFLOW;
                goto Error;
            }

            *BufferSize = BufferReqd;
        }

        //
        // Copy in the memberships
        //

        for (Index=0;Index<cSid;Index++)
        {
          ASSERT(rpDsNames[Index]->SidLen>0);

          Status = SampSplitSid(
                        &((rpDsNames[Index])->Sid),
                        NULL,
                        & (Buffer[Index])
                        );

          if (!NT_SUCCESS(Status))
                goto Error;
        }
    }
    else if (ARGUMENT_PRESENT(BufferSize))
    {
        *BufferSize = BufferReqd;
    }


Error:

    //
    // Cleanup on errors
    //


    if (!NT_SUCCESS(Status))
    {
        if (BufferAllocated)
        {
             MIDL_user_free(Buffer);
             Buffer = NULL;
        }
    }

    return Status;
}



NTSTATUS
SampDsGetGroupMembershipOfAccount(
    IN DSNAME * DomainDn,
    IN DSNAME * AccountObject,
    OUT  PULONG MemberCount,
    OUT PGROUP_MEMBERSHIP *Membership OPTIONAL
    )
/*

  Routine Description:

        This routine gets the reverse group membership list of the given Account,
        in the domain, specified by DomainObjectName. The Account is specified
        by the account Rid.

            DomainDn         -- DSNAME of Domain, where search needs to be limited to.
            AccountObject    -- DSName of the Account whose reverse membership needs
                                to be computed.
            MemberCount      -- Count of Members.
            Membership       -- Returned group membership list
*/
{
    NTSTATUS    Status;
    ULONG       cSid;
    PDSNAME     * rpDsNames=NULL;
    ULONG       Index;


    // Perform lazy thread and transaction initialization.
    Status = SampMaybeBeginDsTransaction(SampDsTransactionType);

    if (Status!= STATUS_SUCCESS)
        goto Error;

    Status = SampGetMemberships(
                &AccountObject,
                1,
                DomainDn,
                RevMembGetGroupsForUser,
                &cSid,
                &rpDsNames,
                NULL,
                NULL,
                NULL
                );

    if (NT_SUCCESS(Status))
    {
        *MemberCount = cSid;

        if (ARGUMENT_PRESENT(Membership))
        {
            //
            // Alloc one more for the user's primary group
            //

            *Membership = MIDL_user_allocate((cSid+1) * sizeof(GROUP_MEMBERSHIP));
            if (NULL==*Membership)
            {
                Status = STATUS_NO_MEMORY;
                goto Error;
            }

            for (Index=0;Index<cSid;Index++)
            {
                ASSERT(rpDsNames[Index]->SidLen>0);

                Status = SampSplitSid(
                            &(rpDsNames[Index]->Sid),
                            NULL,
                            &(((*Membership)[Index]).RelativeId)
                            );
                if (!NT_SUCCESS(Status))
                    goto Error;

                ((*Membership)[Index]).Attributes = SE_GROUP_MANDATORY |
                            SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_ENABLED;

            }
        }
    }

Error:

    //
    // Cleanup on return
    //

    if (!NT_SUCCESS(Status))
    {
        if (ARGUMENT_PRESENT(Membership) && (NULL!=*Membership))
        {
            MIDL_user_free(*Membership);
            *Membership= NULL;
        }
    }

    return Status;
}


NTSTATUS
SampDsAddMembershipAttribute(
    IN DSNAME * GroupObjectName,
    IN SAMP_OBJECT_TYPE SamObjectType,
    IN DSNAME * MemberName
    )
/*++
 Routine Description:

        This routine adds a Member To a Group or Alias Object

 Arguments:
        GroupObjectName -- DS Name of the Group or Alias
        MemberName      -- DS Name of the Member to be added

 Return Values:
        STATUS_SUCCESS
        Other Error codes from DS Layer
--*/
{
    ATTRVAL MemberVal;
    ATTR    MemberAttr;
    ATTRBLOCK AttrsToAdd;
    ULONG   MembershipAttrType;
    NTSTATUS NtStatus = STATUS_SUCCESS;


    //
    // Get the membership attribute for the SAM object in question
    //
    //

    switch( SamObjectType )
    {
    case SampGroupObjectType:
            MembershipAttrType = SAMP_GROUP_MEMBERS;
            break;

    case SampAliasObjectType:
            MembershipAttrType = SAMP_ALIAS_MEMBERS;
            break;

    default:

            ASSERT(FALSE&&"Unknown ObjectType");

            NtStatus = STATUS_UNSUCCESSFUL;
            goto Error;
    }

    //
    // Build the Attr Val adding the membership attr
    //

    MemberVal.valLen = MemberName->structLen;
    MemberVal.pVal = (UCHAR *) MemberName;
    MemberAttr.attrTyp = MembershipAttrType;
    MemberAttr.AttrVal.valCount = 1;
    MemberAttr.AttrVal.pAVal = & MemberVal;


    //
    // Build the AttrBlock
    //

    AttrsToAdd.attrCount = 1;
    AttrsToAdd.pAttr = & MemberAttr;

    //
    // Add the Value
    //

    NtStatus = SampDsSetAttributes(
                    GroupObjectName, // Object
                    0,               // Flags
                    ADD_VALUE,       // Operation
                    SamObjectType,   // ObjectType
                    &AttrsToAdd      // AttrBlock
                    );

Error:

    return NtStatus;
}

NTSTATUS
SampDsAddMultipleMembershipAttribute(
    IN DSNAME*          GroupObjectName,
    IN SAMP_OBJECT_TYPE SamObjectType,
    IN DWORD            Flags,
    IN DWORD            MemberCount,
    IN DSNAME*          MemberName[]
    )
/*++

 Routine Description:

        This routine adds a multiple members to a group or alias object

 Arguments:

        GroupObjectName -- DS Name of the Group or Alias
        SamObjectType   -- group or alias
        Flags           -- SAM_LAZY_COMMIT, etc.
        MemberCount     -- number of elements in MemberName
        MemberName      -- array of dsnames

 Return Values:

        STATUS_SUCCESS

        Other Error codes from DS Layer
--*/
{
    NTSTATUS  NtStatus;


    ULONG     MembershipAttrType;
    ATTRVAL  *MemberVal = NULL;
    ATTR     *MemberAttr = NULL;
    ATTRBLOCK AttrsToAdd;

    ULONG     i;


    if ( MemberCount < 1 )
    {
        return STATUS_SUCCESS;
    }

    //
    // Get the membership attribute for the SAM object in question
    //
    switch( SamObjectType )
    {
        case SampGroupObjectType:

            MembershipAttrType = SAMP_GROUP_MEMBERS;
            break;

        case SampAliasObjectType:

            MembershipAttrType = SAMP_ALIAS_MEMBERS;
            break;

        default:

            ASSERT( !"Unknown ObjectType" );
            return STATUS_UNSUCCESSFUL;

    }

    //
    // Build the Attr Val adding the membership attr
    //
    MemberVal = ( ATTRVAL* ) RtlAllocateHeap( RtlProcessHeap(),
                                              0,
                                              MemberCount * sizeof( ATTRVAL ) );
    if ( !MemberVal )
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    MemberAttr = ( ATTR* ) RtlAllocateHeap( RtlProcessHeap(),
                                            0,
                                            MemberCount * sizeof(ATTR) );
    if ( !MemberAttr )
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }


    for ( i = 0; i < MemberCount; i++ )
    {
        MemberVal[i].valLen            = MemberName[i]->structLen;
        MemberVal[i].pVal              = (UCHAR*) MemberName[i];
        MemberAttr[i].attrTyp          = MembershipAttrType;
        MemberAttr[i].AttrVal.valCount = 1;
        MemberAttr[i].AttrVal.pAVal    = &MemberVal[i];
    }

    //
    // Build the AttrBlock
    //
    AttrsToAdd.attrCount = MemberCount;
    AttrsToAdd.pAttr = &MemberAttr[0];

    //
    // Add the Value
    //
    NtStatus = SampDsSetAttributes( GroupObjectName,
                                    Flags,
                                    ADD_VALUE,
                                    SamObjectType,
                                    &AttrsToAdd  );

Cleanup:

    if ( MemberVal )
    {
        RtlFreeHeap( RtlProcessHeap(), 0, MemberVal );
    }

    if ( MemberAttr )
    {
        RtlFreeHeap( RtlProcessHeap(), 0, MemberAttr );
    }

    return NtStatus;

}

NTSTATUS
SampDsRemoveMembershipAttribute(
    IN DSNAME * GroupObjectName,
    IN SAMP_OBJECT_TYPE SamObjectType,
    IN DSNAME * MemberName
    )
/*++
Routine Description:

        This Routine Removes a Member from a Group or Alias Object

Arguments:

        GroupObjectName -- DS Name of the Group or Alias
        MemberName      -- DS Name of the Member to be added

 Return Values:
        STATUS_SUCCESS
        Other Error codes from DS Layer
--*/
{
    ATTRVAL MemberVal;
    ATTR    MemberAttr;
    ATTRBLOCK AttrsToRemove;
    ULONG   MembershipAttrType;
    NTSTATUS NtStatus = STATUS_SUCCESS;


    //
    // Get the membership attribute for the SAM object in question
    //
    //

    switch( SamObjectType )
    {

    case SampGroupObjectType:

            MembershipAttrType = SAMP_GROUP_MEMBERS;
            break;

    case SampAliasObjectType:

            MembershipAttrType = SAMP_ALIAS_MEMBERS;
            break;

    default:

            ASSERT(FALSE);

            NtStatus = STATUS_UNSUCCESSFUL;
            goto Error;
    }

    //
    // Build the Attr Val adding the membership attr
    //

    MemberVal.valLen = MemberName->structLen;
    MemberVal.pVal = (UCHAR *) MemberName;
    MemberAttr.attrTyp = MembershipAttrType;
    MemberAttr.AttrVal.valCount = 1;
    MemberAttr.AttrVal.pAVal = & MemberVal;

    //
    // Build the AttrBlock
    //

    AttrsToRemove.attrCount = 1;
    AttrsToRemove.pAttr = & MemberAttr;

    //
    // Remove the Value
    //

    NtStatus = SampDsSetAttributes(
                    GroupObjectName, // Object
                    0,               // Flags
                    REMOVE_VALUE,    // Operation
                    SamObjectType,   // ObjectType
                    &AttrsToRemove   // AttrBlock
                    );

Error:

    return NtStatus;

}



NTSTATUS
SampDsGetGroupMembershipList(
    IN DSNAME * DomainObject,
    IN DSNAME * GroupName,
    IN ULONG    GroupRid,
    IN PULONG  *Members OPTIONAL,
    IN PULONG MemberCount
    )
/*++

  Routine Description:

    This Routine Gets a Group Membership as an array of Rid's as required
    by SAM.
    
    NOTE (by ShaoYin): I modified this routine to query Group Members 
        in increments rather that as a whole. The reason is: when the
        Group hosts tons of thousands members, SAM will consume large
        amounts of memory to query members by using single DirRead. 
        After the change, this routine queried Group Memmbers in a 
        incremental fashion through everything is still in the same 
        transaction. By segmenting read member operation to several 
        DirRead(s), SAM will do better job. 
        
        But because all the DirRead(s) are still in one transaction, 
        actually we do not have much memory gain. 
        
        Probably, the right thing we need to do to relieve memory usage
        is segment the transaction. 
        
        The original code is commented at the end of this routine.
        Same for SampDsGetAliasMembershipsList()

  Arguments

    GroupName -- DSNAME of the concerned group object
    Members   -- Array of Rids will be passed in here
    MemberCount -- Count of Rids

  Return Values:
        STATUS_SUCCESS
        STATUS_NO_MEMORY
        Return Codes from DS Layer
--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       PrimaryMemberCount;
    PULONG      PrimaryMembers = NULL;
    PULONG      TmpMembers = NULL; 
    
    READARG     ReadArg;
    READRES     * pReadRes = NULL;
    COMMARG     * pCommArg = NULL;
    ATTR        MemberAttr;
    ENTINFSEL   EntInf;
    RANGEINFOITEM RangeInfoItem;
    RANGEINFSEL RangeInf;
    DWORD       LowerLimit = 0;
    ULONG       RetValue = 0;


    //
    //  Asserts
    //

    ASSERT(MemberCount);

    //
    // Initialize Members field
    //

    *MemberCount = 0;

    if (ARGUMENT_PRESENT(Members))
        *Members = NULL;

    //
    // First check for any members that are present by virtue of the fact
    // that their primary group Id property indicates this group
    //

    Status = SampDsGetPrimaryGroupMembers(
                    DomainObject,
                    GroupRid,
                    &PrimaryMemberCount,
                    &PrimaryMembers
                    );

    if (!NT_SUCCESS(Status))
    {
        goto Error;
    }
    
    *MemberCount = PrimaryMemberCount;
    if (ARGUMENT_PRESENT(Members))
    {
        *Members = PrimaryMembers;
        PrimaryMembers = NULL;
    }
    
    //
    // init arguments 
    //
    memset(&EntInf,   0, sizeof(ENTINFSEL));
    memset(&RangeInf, 0, sizeof(RANGEINFSEL)); 
    memset(&ReadArg,  0, sizeof(READARG));
        
    MemberAttr.AttrVal.valCount = 0;
    MemberAttr.AttrVal.pAVal = NULL;
    MemberAttr.attrTyp = SampDsAttrFromSamAttr(
                                   SampGroupObjectType, 
                                   SAMP_GROUP_MEMBERS
                                   );
        
    EntInf.AttrTypBlock.attrCount = 1;
    EntInf.AttrTypBlock.pAttr = &MemberAttr;
    EntInf.attSel = EN_ATTSET_LIST;
    EntInf.infoTypes = EN_INFOTYPES_SHORTNAMES;
        
    RangeInfoItem.AttId = MemberAttr.attrTyp;
    RangeInfoItem.lower = LowerLimit;           // 0 is the begin of index.
    RangeInfoItem.upper = -1;                   // means the end of values
        
    RangeInf.valueLimit = SAMP_READ_GROUP_MEMBERS_INCREMENT;
    RangeInf.count = 1;
    RangeInf.pRanges = &RangeInfoItem;
        
    ReadArg.pObject = GroupName;
    ReadArg.pSel = &EntInf;
    ReadArg.pSelRange = &RangeInf;
        
    pCommArg = &(ReadArg.CommArg);
    BuildStdCommArg(pCommArg);
    
    do
    {
        ATTRBLOCK   AttrsRead;
        
        RangeInfoItem.lower = LowerLimit;
        
        Status = SampDoImplicitTransactionStart(TransactionRead);
        
        if (STATUS_SUCCESS != Status)
        {
            goto Error;
        }
        
        SAMTRACE_DS("DirRead");
        
        RetValue = DirRead(&ReadArg, &pReadRes);
        
        SAMTRACE_RETURN_CODE_DS(RetValue);
        
        if (NULL==pReadRes)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            Status = SampMapDsErrorToNTStatus(RetValue, &pReadRes->CommRes);
        }
        
        SampClearErrors();
        
        SampSetDsa(TRUE);
        
        if (NT_SUCCESS(Status))
        {
            AttrsRead = pReadRes->entry.AttrBlock;
            ASSERT(AttrsRead.pAttr);
            
            //
            // Set the value for Lower index, used by next dirread
            //
            LowerLimit = RangeInfoItem.lower + AttrsRead.pAttr->AttrVal.valCount;
            
            if (AttrsRead.pAttr)
            {
                ULONG   Count = 0;
                ULONG   Index;
                ULONG   Rid;
                PSID    MemberSid = NULL;
                DSNAME  * MemberName = NULL;
                
                Count = AttrsRead.pAttr->AttrVal.valCount;
                
                if (ARGUMENT_PRESENT(Members))
                {
                    // 
                    // extend memory to hold more member's RID
                    //
                    TmpMembers = MIDL_user_allocate((*MemberCount + Count) * sizeof(ULONG));
                    
                    if (NULL == TmpMembers)
                    {
                        Status = STATUS_NO_MEMORY;
                        goto Error;
                    }
                    
                    RtlZeroMemory(TmpMembers, (*MemberCount + Count)*sizeof(ULONG));
                    RtlCopyMemory(TmpMembers, (*Members), (*MemberCount)*sizeof(ULONG));
                    
                    if (*Members)
                    {
                        MIDL_user_free(*Members);
                    }
                    
                    *Members = TmpMembers;
                    
                    TmpMembers = NULL; 
                }
                    
                for (Index = 0; Index < Count; Index ++)
                {
                    //
                    // retrieve each member's RID
                    //
                    MemberName = (DSNAME *)AttrsRead.pAttr->AttrVal.pAVal[Index].pVal;
                       
                    if (MemberName->SidLen > 0)
                        MemberSid = &(MemberName->Sid);
                    else
                        MemberSid = SampDsGetObjectSid(MemberName);
                       
                    if (NULL == MemberSid)
                    {
                        // 
                        // Not a Secrutiy Principal, SKip.
                        //
                        continue;
                    }
                        
                    Status = SampSplitSid(MemberSid, NULL, &Rid);
                        
                    if (!NT_SUCCESS(Status))
                        goto Error;
                            
                    if (ARGUMENT_PRESENT(Members))
                    {
                        (*Members)[*MemberCount] = Rid;
                    }
                    
                    (*MemberCount)++;
                }
            }
        }
        
        //
        // pReadRes->range.pRanges[0].upper == -1 means the last value has been reached.
        //
    } while (NT_SUCCESS(Status) && (-1 != pReadRes->range.pRanges[0].upper));
    
    if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE == Status)
    {
        Status = STATUS_SUCCESS;
    }
    
Error:

    if (!NT_SUCCESS(Status))
    {
        //
        // Set Error Return
        //

        if ((ARGUMENT_PRESENT(Members) ) && (*Members))
        {
            MIDL_user_free(*Members);
            *Members = NULL;
        }
        
        *MemberCount = 0;
    }

    if (NULL!=PrimaryMembers)
    {
        MIDL_user_free(PrimaryMembers);
        PrimaryMembers = NULL;
    }

    return Status;
    
}



NTSTATUS
SampDsGetAliasMembershipList(
    IN DSNAME *AliasName,
    IN PULONG MemberCount,
    IN PSID   **Members OPTIONAL
    )
/*++

  Routine Description:

    This Routine Gets a Alias Membership as an array of Sid's as required
    by SAM.
    
    NOTE (by ShaoYin): I modified this routine to query Alias Members 
        in increments rather that as a whole. The reason is: when the
        Alias hosts tons of thousands members, SAM will consume large
        amounts of memory to query members by using single DirRead. 
        After the change, this routine queried Alias Memmbers in a 
        incremental fashion through everything is still in the same 
        transaction. By segmenting read member operation to several 
        DirRead(s), SAM will do better job. 
        
        But because all the DirRead(s) are still in one transaction, 
        actually we do not have much memory gain. 
        
        Probably, the right thing we need to do to relieve memory usage
        is segment the transaction. 
        
        The original code is commented at the end of this routine.

  Arguments

    AliasName -- DSNAME of the concerned Alias object
    Members   -- Array of Rids will be passed in here
    MemberCount -- Count of Sids

  Return Values:
        STATUS_SUCCESS
        STATUS_NO_MEMORY
        Return Codes from DS Layer
--*/

{

    NTSTATUS    Status = STATUS_SUCCESS;
    PSID        * TmpMembers = NULL;
    
    READARG     ReadArg;
    READRES     * pReadRes = NULL;
    COMMARG     * pCommArg = NULL;
    ATTR        MemberAttr;
    ENTINFSEL   EntInf;
    RANGEINFOITEM RangeInfoItem;
    RANGEINFSEL RangeInf;
    DWORD       LowerLimit = 0;
    ULONG       RetValue = 0;
    
    //
    // Asserts
    //
    
    ASSERT(MemberCount);
    
    //
    // Initialize Members field
    //
    
    *MemberCount = 0;
    if (ARGUMENT_PRESENT(Members))
        *Members = NULL;
    
    //
    // Initialize all arguments
    //
    
    memset(&EntInf,   0, sizeof(ENTINFSEL));
    memset(&RangeInf, 0, sizeof(RANGEINFSEL));
    memset(&ReadArg,  0, sizeof(READARG));
    
    MemberAttr.AttrVal.valCount = 0;
    MemberAttr.AttrVal.pAVal = NULL;
    MemberAttr.attrTyp = SampDsAttrFromSamAttr(
                                   SampAliasObjectType, 
                                   SAMP_ALIAS_MEMBERS
                                   );
                                   
    EntInf.AttrTypBlock.attrCount = 1;
    EntInf.AttrTypBlock.pAttr = &MemberAttr;
    EntInf.attSel = EN_ATTSET_LIST;
    EntInf.infoTypes = EN_INFOTYPES_SHORTNAMES;
    
    RangeInfoItem.AttId = MemberAttr.attrTyp;
    RangeInfoItem.lower = LowerLimit;             // 0 is the beginning of values
    RangeInfoItem.upper = -1;                     // -1 means the enf of values;
    
    RangeInf.valueLimit = SAMP_READ_ALIAS_MEMBERS_INCREMENT;
    RangeInf.count = 1;
    RangeInf.pRanges = &RangeInfoItem;             
    
    ReadArg.pObject = AliasName; 
    ReadArg.pSel = &EntInf;
    ReadArg.pSelRange = &RangeInf;
    
    pCommArg = &(ReadArg.CommArg);
    BuildStdCommArg(pCommArg);
    
    do
    {
        ATTRBLOCK   AttrsRead;
        
        RangeInfoItem.lower = LowerLimit;
        
        Status = SampDoImplicitTransactionStart(TransactionRead);
        
        if (STATUS_SUCCESS != Status)
        {
            goto Error;
        }
        
        SAMTRACE_DS("DirRead");
        
        RetValue = DirRead(&ReadArg, &pReadRes);
        
        SAMTRACE_RETURN_CODE_DS(RetValue);
        
        if (NULL == pReadRes)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            Status = SampMapDsErrorToNTStatus(RetValue, &pReadRes->CommRes);
        }
        
        SampClearErrors();
        
        SampSetDsa(TRUE);
        
        if (NT_SUCCESS(Status))
        {
            AttrsRead = pReadRes->entry.AttrBlock;
            ASSERT(AttrsRead.pAttr);
            
            //
            // Re-Set the Lower Index, used by next dirread
            //
            LowerLimit = RangeInfoItem.lower + AttrsRead.pAttr->AttrVal.valCount;
            
            if (AttrsRead.pAttr)
            {
                ULONG   Count;
                ULONG   Index;
                ULONG   TmpIndex;
                ULONG   BufferSize; 
                DSNAME  * MemberName = NULL;
                PSID    MemberSid = NULL;
                NT4SID  * SidArray = NULL;
                
                //
                // Get the Member Count from the nearest DirRead call
                //
                
                Count = AttrsRead.pAttr->AttrVal.valCount;
                
                if (ARGUMENT_PRESENT(Members))
                {
                    // 
                    // allocate or extend the buffer
                    //
                    BufferSize = ((*MemberCount) + Count) * sizeof(PSID) +
                                 ((*MemberCount) + Count) * sizeof(NT4SID);
                                 
                    TmpMembers = MIDL_user_allocate( BufferSize );
                    
                    if (NULL == TmpMembers)
                    {
                        Status = STATUS_NO_MEMORY;
                        goto Error;
                    }
                    
                    RtlZeroMemory(TmpMembers, BufferSize);
                    
                    SidArray = (NT4SID *) (((PSID *) TmpMembers) + (*MemberCount) + Count);
                    
                    // 
                    // Copy any previous retrieved SID(s) to new location.
                    //  
                    
                    if (*MemberCount)
                    {
                        ASSERT(*Members);
                        
                        RtlCopyMemory(SidArray, 
                                      ((PSID *)(*Members)) + (*MemberCount), 
                                      (*MemberCount) * sizeof(NT4SID)
                                      );
                                      
                        //
                        // Set the pointer (to SID) to the right place 
                        // 
                        
                        for (TmpIndex = 0; TmpIndex < (*MemberCount); TmpIndex++)
                        {
                            TmpMembers[TmpIndex] = SidArray++;
                        }
                        
                    }
                    
                    if (*Members)
                    {
                        MIDL_user_free(*Members);
                    }
                    
                    *Members = TmpMembers;
                    TmpMembers = NULL;
                }
                
                // 
                // Loop Through each entry looking at the Sids 
                //
                
                for (Index = 0; Index < Count; Index++ )
                {
                    MemberName = (DSNAME *) AttrsRead.pAttr->AttrVal.pAVal[Index].pVal;
                    
                    if (MemberName->SidLen > 0)
                        MemberSid = &(MemberName->Sid);
                    else
                        MemberSid = SampDsGetObjectSid(MemberName);
                        
                    if (NULL == MemberSid)
                    {
                        // 
                        // Not a Security Principal, Skip
                        // 
                        
                        continue;
                    }
                    
                    if (ARGUMENT_PRESENT(Members))
                    {
                        // 
                        // Copy the new SID in the right place
                        // 
                        
                        (*Members)[*MemberCount] = SidArray ++;
                        
                        ASSERT(RtlLengthSid(MemberSid) <= sizeof(NT4SID));
                        
                        RtlCopyMemory((*Members)[*MemberCount],
                                      MemberSid, 
                                      RtlLengthSid(MemberSid)
                                      );
                    }
                    
                    // 
                    // Increment Count
                    // 
                    (*MemberCount)++;
                }
            }
        }
        //
        // (-1 == pReadRes->range.pRanges[0].upper) means the last values has been reached.
        // 
    } while (NT_SUCCESS(Status) && (-1 != pReadRes->range.pRanges[0].upper));
    
    
    if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE == Status)
    {
        Status = STATUS_SUCCESS;
    }

Error:

    if (!NT_SUCCESS(Status))
    {
        // 
        // Set Error Return
        // 
        
        if (ARGUMENT_PRESENT(Members) && (*Members))
        {
            MIDL_user_free((*Members));
            *Members = NULL;
        }
        
        *MemberCount = 0;
    }
    
    return Status;

}

NTSTATUS
SampDsGetPrimaryGroupMembers(
    DSNAME * DomainObject,
    ULONG   GroupRid,
    PULONG  PrimaryMemberCount,
    PULONG  *PrimaryMembers
    )
/*++

    Routine Description:

        SampDsGetPrimaryGroupMemberse obtains the members of the group by virtue of the
        Primary Group Id property. It searches the DS database looking for users whose
        primary group id is equal to the Rid of the users.

    Parameters:

        DomainObject -- The DS Name of the Domain Object
        GroupRid     -- The Rid of the group
        PrimaryMemberCount -- The number of users that are members by virtue of the primary
                              group id property is returned in here.
        PrimaryMembers  -- The Rids of all such users are returned in here.

    Return Values:

        STATUS_SUCCESS
        Other error codes depending upon failure mode
--*/
{
    NTSTATUS        Status = STATUS_SUCCESS;
    ULONG           EntriesToQueryFromDs = 100; // Query just 100 entries at a time
    BOOLEAN         MoreEntriesPresent = TRUE;
    FILTER          DsFilter;
    SEARCHRES       *SearchRes;
    PRESTART        RestartToUse = NULL;

    ATTRTYP         AttrTypes[]=
                    {
                        SAMP_UNKNOWN_OBJECTSID,
                    };

    ATTRVAL         AttrVals[]=
                    {
                        {0,NULL}
                    };

    DEFINE_ATTRBLOCK1(
                      AttrsToRead,
                      AttrTypes,
                      AttrVals
                      );
    ULONG           BufferGrowthSize = 16 * 1024;  // allocate 16K entries at a time
    ULONG           CurrentBufferSize = 0;         // Note buffer sizes are in terms of
                                                   // number of entries

    //
    // Initialize our return values
    //

    *PrimaryMemberCount = 0;
    *PrimaryMembers = NULL;

    //
    // Build a filter structure for searching
    //
    memset (&DsFilter, 0, sizeof (DsFilter));
    DsFilter.pNextFilter = NULL;
    DsFilter.choice = FILTER_CHOICE_ITEM;
    DsFilter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    DsFilter.FilterTypes.Item.FilTypes.ava.type = SampDsAttrFromSamAttr(
                                                       SampUserObjectType,
                                                       SAMP_FIXED_USER_PRIMARY_GROUP_ID
                                                       );

    DsFilter.FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(ULONG);
    DsFilter.FilterTypes.Item.FilTypes.ava.Value.pVal = (UCHAR *)&GroupRid;


    //
    // Now keep querying from DS till we have exhausted our query
    //


    while (MoreEntriesPresent)
    {
        ENTINFLIST  *CurrentEntInf;
        PULONG       NewMemory;

        //
        // Search the DS for objects with the given primary group Id
        //


        MoreEntriesPresent = FALSE;

        Status = SampMaybeBeginDsTransaction(TransactionRead);
        if (!NT_SUCCESS(Status))
            goto Error;

        Status = SampDsDoSearch(
                        RestartToUse,
                        DomainObject,
                        &DsFilter,
                        0,          // Starting Index
                        SampUnknownObjectType,
                        &AttrsToRead,
                        EntriesToQueryFromDs,
                        &SearchRes
                        );

        if (!NT_SUCCESS(Status))
        {
            goto Error;
        }

        if (SearchRes->count)
        {
            //
            // Allocate / Grow memory if required
            //

            if ((SearchRes->count+(*PrimaryMemberCount))>CurrentBufferSize)
            {

                NewMemory = MIDL_user_allocate(
                                    (CurrentBufferSize+BufferGrowthSize) * sizeof(ULONG));
                if (NULL== NewMemory)
                {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto Error;
                }

                CurrentBufferSize+=BufferGrowthSize;

                //
                // Copy in into the new buffer
                //
                //

                if (NULL!=*PrimaryMembers)
                {
                    RtlCopyMemory(NewMemory,*PrimaryMembers, sizeof(ULONG)*(*PrimaryMemberCount));
                    MIDL_user_free(*PrimaryMembers);
                }
                *PrimaryMembers = NewMemory;
            }

            //
            // Pack the results
            //

            for (CurrentEntInf = &(SearchRes->FirstEntInf);
                    CurrentEntInf!=NULL;
                    CurrentEntInf=CurrentEntInf->pNextEntInf)

            {
                ULONG   Rid;
                PSID    ReturnedSid = NULL;
                PSID    DomainSidOfCurrentEntry = NULL;
                PULONG  SamAccountType;

                ASSERT(CurrentEntInf->Entinf.AttrBlock.attrCount==1);
                ASSERT(CurrentEntInf->Entinf.AttrBlock.pAttr);

                ASSERT(CurrentEntInf->Entinf.AttrBlock.pAttr[0].AttrVal.valCount==1);
                ASSERT(CurrentEntInf->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal->pVal);
                ASSERT(CurrentEntInf->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal->valLen);


                ReturnedSid = CurrentEntInf->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal->pVal;

                Status = SampSplitSid(
                            ReturnedSid,
                            NULL,
                            &Rid
                            );
                if (!NT_SUCCESS(Status))
                    goto Error;

                (*PrimaryMembers)[(*PrimaryMemberCount)++] = Rid;

            }

            //
            // Free the old restart structure
            //

            if (NULL!=RestartToUse)
            {
                MIDL_user_free(RestartToUse);
                RestartToUse = NULL;
            }

            //
            // Process search continuation
            //

            if (SearchRes->PagedResult.pRestart)
            {
                //
                // Restart structure was returned. More entries are still present
                //

                Status = SampCopyRestart(
                                SearchRes->PagedResult.pRestart,
                                &RestartToUse
                                );

                if (!NT_SUCCESS(Status))
                    goto Error;

                MoreEntriesPresent = TRUE;
            }
        }


        SampMaybeEndDsTransaction(TransactionCommit);

    }


Error:


    if (NULL!=RestartToUse)
    {
        MIDL_user_free(RestartToUse);
        RestartToUse = NULL;
    }


    SampMaybeEndDsTransaction(TransactionCommit);


    if (!NT_SUCCESS(Status))
    {
        if (NULL!=*PrimaryMembers)
        {
            MIDL_user_free(*PrimaryMembers);
            *PrimaryMembers=NULL;
        }
        *PrimaryMemberCount = 0;
    }

    return Status;
}

NTSTATUS
SampDsGetReverseMemberships(
    DSNAME * pObjName,
    ULONG    Flags,
    ULONG    *pcSids,
    PSID     **prpSids
   )
{
    NTSTATUS NtStatus;

    NtStatus = SampGetGroupsForToken(pObjName,
                                 Flags,
                                 pcSids,
                                 prpSids);

    return NtStatus;

}

NTSTATUS
SampDsResolveSidsWorker(
    IN  PSID    * rgSids,
    IN  ULONG   cSids,
    IN  PSID    *rgDomainSids,
    IN  ULONG   cDomainSids,
    IN  PSID    *rgEnterpriseSids,
    IN  ULONG   cEnterpriseSids,
    IN  ULONG   Flags,
    OUT DSNAME  ***rgDsNames
    )
/*++

    This is the worker routine for Resolve Sids.
    This is Resolves a Set of Sids Passed to it to obtain the DS Names
    of the Sids. Resolve Sids Does the Following

    1. Checks to see if the SID corresponds to Sids in the account domain.
    2. For Sids, for whom matches do not turn up, 
       this routine checks to see if they a foriegn security principal.
       For them a new object is created.
    3. For Sids that are not foregn security principal 
       this routine checks to see if they are present at a G.C

    4. Well Known SIDs and Builtin Domain SIDs. The Default behaviour for a
       WellKnown SID  ( e.g Everyone ) is to create a foriegn Security 
       Principal Object for the Well Known SID, if one did not exist and
       return the DSNAME corresponding to that. The default behaviour for
       Builtin Domain SID is to not resolve it. This corresponds to the Design
       of allowing SIDs like "everyone" in local groups but not SIDs like
       "Administratrators".

    Any Unresolved Sid will be returned with a NULL pointer for the DS Name.



    Parameters:

        rgSids -- The array of Sids that need to be passed in.
        cSids  -- The count of Sids
        Flags  -- Used to control the operation of the routine

                    RESOLVE_SIDS_ADD_FORIEGN_SECURITY_PRINCIPAL
                    -- Automatically Adds the foreign domain security principal to the DS.

                    RESOLVE_SIDS_VALIDATE_AGAINST_GC
                    -- Goes to the G.C if required

                    RESOLVE_SIDS_SID_ONLY_NAMES_OK
                    -- Constructs the DS Name with only a SID for all 
                       passed in SIDs. No validation is performed.

                    RESOLVE_SIDS_SID_ONLY_DOMAIN_SIDS_OK
                    -- Constructs the DS Name with only a SID for all passed
                       in SIDs, provided the SID is a SID in the domain

        rgDsNames -- Will MIDL_user alloc an array of DS Names 
                     back to the caller. Caller
                     is responsible for freeing them

    Return Values:

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL


    WARNING -- When running from SAM as part of regular SAM operations, this routine should be called
    with no locks held and no open transactions. Further this routine should not be
    called from the loopback case. The loopback call does its own validation ( GC / shim lookup )

  --*/
 {
    NTSTATUS         NtStatus = STATUS_SUCCESS;
    ULONG            i;
    DSNAME           *pLoopBackObject;
    SAMP_OBJECT_TYPE FoundType;
    BOOLEAN          fSamLockAcquired = FALSE,
                     DsContext = FALSE;
    PULONG           rgGcSidIndices=NULL;
    PSID             *rgGcSids=NULL;
    ULONG            cGcSids = 0;
    NTSTATUS         IgnoreStatus;
    ULONG            DsErr = 0;
    DSNAME           **GcDsNames=NULL;



    *rgDsNames = NULL;

    //
    // Allocate enough space for the array of DS Names
    //

    *rgDsNames = MIDL_user_allocate(cSids * sizeof(PDSNAME));
    if (NULL==*rgDsNames)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    //
    // Zero out the space
    //

    RtlZeroMemory(*rgDsNames, cSids * sizeof(PDSNAME));


    //
    // Alloc space from HEAP (instead of from stack) 
    // for the array of Sids which we will need
    // to remote to G.C ( Potentially every Sid is a G.C Sid ).
    //

    rgGcSids = MIDL_user_allocate(cSids * sizeof(PSID));
    
    if (NULL == rgGcSids)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }
    
    RtlZeroMemory(rgGcSids, cSids * sizeof(PSID));
    
    
    rgGcSidIndices  = MIDL_user_allocate(cSids * sizeof(ULONG));
    
    if (NULL == rgGcSidIndices)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }
    
    RtlZeroMemory(rgGcSidIndices, cSids * sizeof(ULONG));


    //
    // Walk through the Passed in Array of Sids, walking Sid by Sid
    //

    for (i=0;i<cSids;i++)
    {
        BOOLEAN     WellKnownSid = FALSE,
                    LocalSid = TRUE,
                    ForeignSid = FALSE,
                    EnterpriseSid = FALSE,
                    BuiltinDomainSid = FALSE;



        if (!(Flags & RESOLVE_SIDS_SID_ONLY_NAMES_OK))
        {
            //
            // Check Sid Type, if SID_ONLY_NAMES are requested,
            // then this check can be skipped as we simply will
            // construct a DSNAME with just the SID field filled
            // in. 
            //

            NtStatus = SampDsCheckSidType(
                            rgSids[i],
                            cDomainSids,
                            rgDomainSids,
                            cEnterpriseSids,
                            rgEnterpriseSids,
                            &WellKnownSid,
                            &BuiltinDomainSid,
                            &LocalSid,
                            &ForeignSid,
                            &EnterpriseSid
                            );

            if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }
        }


        //
        // Firewall against any Sids that
        // we do not understand
        //

        if ( (RtlLengthSid(rgSids[i])) >sizeof(NT4SID) )
        {
            continue;
        }

        if ((WellKnownSid) && (Flags & RESOLVE_SIDS_FAIL_WELLKNOWN_SIDS))
        {

            //
            // Caller asked us to fail the call if a SID like "EveryOne" were
            // present
            //
           
                NtStatus = STATUS_UNSUCCESSFUL;
                goto Error;
        }
        else if ((BuiltinDomainSid) && (Flags & RESOLVE_SIDS_FAIL_BUILTIN_DOMAIN_SIDS))
        {
            //
            // Caller asked us to fail the call if a SID like "Administrators" 
            // were present
            //
            
                NtStatus = STATUS_UNSUCCESSFUL;
                goto Error;
        }
        else if ((Flags& RESOLVE_SIDS_SID_ONLY_NAMES_OK)
                || ((Flags & RESOLVE_SIDS_SID_ONLY_DOMAIN_SIDS_OK)
                    && (LocalSid)))
         {
            //
            // Caller asked us to do this , so we just construct a
            // Sid Only Name. This is used by second phase of logon,
            // coming in through SamrGetAliasMembership. The Ds
            // reverse membership evaluation routines have the
            // intelligence to find a name just by SID, so this results
            // in a significant performance improvement, rather than
            // just searching or validating against G.C
            //
            DSNAME * SidOnlyDsName = NULL;

            // Construct a Sid Only DS Name
            SidOnlyDsName = MIDL_user_allocate(sizeof(DSNAME));
            if (NULL==SidOnlyDsName)
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                goto Error;
            }

            BuildDsNameFromSid(
                rgSids[i],
                SidOnlyDsName
                );

            (*rgDsNames)[i] = SidOnlyDsName;
        }
        else if (LocalSid || ForeignSid || WellKnownSid || BuiltinDomainSid)
        {

            //
            // Try to resolve the SID to a DS Name by looking up the object
            // locally. LocalSid Implies local account domain security principal,
            // Foreign SID implies that we  may resolve to an FPO, same is true
            // for WellKnownSid and for BuiltinDomainSId, we will resolve to the
            // appropriate Builtin Domain Object
            //

            //
            // Begin A transaction, if there is not one
            //


            NtStatus = SampMaybeBeginDsTransaction(TransactionRead);
            if (!NT_SUCCESS(NtStatus))
                goto Error;

            //
            // Try to Resolve the Sid Locally.
            //

            NtStatus = SampDsObjectFromSid(rgSids[i],&((*rgDsNames)[i]));

            if (STATUS_NOT_FOUND==NtStatus)
            {


              NtStatus = STATUS_SUCCESS;
              (*rgDsNames)[i] = NULL;

              if ((ForeignSid || WellKnownSid)
                    && (Flags & RESOLVE_SIDS_ADD_FORIEGN_SECURITY_PRINCIPAL))
              {
                  //
                  // Foreign Sid Create Object if necessary
                  //

                  NtStatus = SampDsCreateForeignSecurityPrincipal(
                                    rgSids[i],
                                    ROOT_OBJECT,
                                    &((*rgDsNames)[i])
                                    );

                  if (!NT_SUCCESS(NtStatus))
                  {
                      goto Error;
                  }
              }
            }
            else if (!NT_SUCCESS(NtStatus))
            {
                goto Error;
            }
        }
        else
        {

            ASSERT(EnterpriseSid==TRUE);

            //
            // Mark the Sid as a G.C Sid
            // Note its index in the original array as
            // we will have to merge in the DS names returned
            // by the G.C
            //


            rgGcSids[cGcSids]=rgSids[i];
            rgGcSidIndices[cGcSids] = i;
            cGcSids++;
        }
    }


    //
    // Commit any open transaction that we may  have as we prepare
    // to go to the G.C
    //

    SampMaybeEndDsTransaction(TransactionCommit);

    //
    // At this point we have resolved what can be done locally.
    // we have also a built a list of Sids that we thing may require
    // reference to the G.C.
    //

    if (cGcSids && (Flags & RESOLVE_SIDS_VALIDATE_AGAINST_GC))
    {

        ASSERT(!SampCurrentThreadOwnsLock());
        ASSERT(!SampExistsDsTransaction());
        ASSERT(!SampExistsDsLoopback(&pLoopBackObject));

       //
       // Create a Thread State so that SampVerifySids may operate
       //

       DsErr = THCreate( CALLERTYPE_SAM );
       if (0!=DsErr)
       {
           NtStatus = STATUS_INSUFFICIENT_RESOURCES;
           goto Error;
       }

       SampSetDsa(TRUE);
       SampSetSam(TRUE);

       DsErr = SampVerifySids(
                    cGcSids,
                    rgGcSids,
                    &GcDsNames
                    );

       // Morph Any errors in verification to  STATUS_DS_GC_NOT_AVAILABLE.
       if (0!=DsErr)
       {
           NtStatus = STATUS_DS_GC_NOT_AVAILABLE;
           goto Error;
       }

       //
       // Patch up the original array. Copy the DsNames passed from thread
       // memory
       //

       for (i=0;i<cGcSids;i++)
       {
          if (NULL!=GcDsNames[i])
          {
              (*rgDsNames)[rgGcSidIndices[i]] = MIDL_user_allocate(GcDsNames[i]->structLen);
              if (NULL==(*rgDsNames)[rgGcSidIndices[i]])
              {
                  NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                  goto Error;
              }

              RtlCopyMemory(
                  (*rgDsNames)[rgGcSidIndices[i]],
                  GcDsNames[i],
                  GcDsNames[i]->structLen
                  );
          }
       }


     //
     // Leave the thread state hanging in the system as it is.
     // This thread state holds the verified Ds Names.
     //

    }



Error:

    if (rgGcSids)
    {
        MIDL_user_free(rgGcSids);
    }
    
    if (rgGcSidIndices)
    {
        MIDL_user_free(rgGcSidIndices);
    }

    return NtStatus;
}



NTSTATUS
SampDsCheckSidType(
    IN  PSID    Sid,
    IN  ULONG   cDomainSids,
    IN  PSID    *rgDomainSids,
    IN  ULONG   cEnterpriseSids,
    IN  PSID    *rgEnterpriseSids,
    OUT BOOLEAN * WellKnownSid,
    OUT BOOLEAN * BuiltinDomainSid,
    OUT BOOLEAN * LocalSid,
    OUT BOOLEAN * ForeignSid,
    OUT BOOLEAN * EnterpriseSid
    )
/*++

    Routine Description

        Check the Sid and find out wether it is a candidate for a local Sid,
        a foriegn Sid or a candidate for  the G.C

    Parameters:

        Sid  - The Sid to be checked out

        cDomainSids - The count of domain Sids,that represent the 
                      domains hosted locally 

        rgDomainSids - The array of domain Sids of the domains that 
                       are hosted locally 

        WellKnownSid - TRUE indicates that the Sid is a well known Sid
                       e.g EveryOne

        BuiltinDomainSid - TRUE indicates that the SID is from the builtin 
                       domain, e.g Administrators

        LocalSid     - TRUE indicates that the Sid is a Sid that is from a 
                       domain that is hosted on this DC. 
                   
        ForiegnSid   - TRUE indicates that the Sid is not from a domain that is
                       not in the forest.
 
        EnterpriseSid - TRUE indicates that the SId belongs to a domain that is
                       in the forest

    Return Values:

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       i;
    PSID        DomainPrefix=NULL;


  //
  //  Initialize Return Values
  //

  *WellKnownSid = FALSE;
  *BuiltinDomainSid = FALSE;
  *LocalSid = FALSE;
  *ForeignSid = FALSE;
  *EnterpriseSid = FALSE;

  //
  //  Validate the Sid
  //

  if ((NULL==Sid) || (!(RtlValidSid(Sid)))
      || ((RtlLengthSid(Sid))>sizeof(NT4SID)))
  {
      NtStatus = STATUS_INVALID_PARAMETER;
      goto Error;
  }

  //
  //  Check for well known Sids
  //

  if (SampIsWellKnownSid(Sid))
  {
      //
      // Well known Sid.
      //

      *WellKnownSid = TRUE;
  }
  else if (SampIsMemberOfBuiltinDomain(Sid))
  {
      //
      // Builtin Domain SID
      //
      *BuiltinDomainSid = TRUE;
  }
  else
  {

      ULONG Rid;

      //
      // Get the Domain Prefix
      //

      NtStatus = SampSplitSid(
                    Sid,
                    &DomainPrefix,
                    &Rid
                    );
      if (!NT_SUCCESS(NtStatus))
      {
          goto Error;
      }

      //
      // Compare the Domain Prefixes
      //

      //
      // Check for local Sid
      //

      for (i=0;i<cDomainSids;i++)
      {
          if ((RtlEqualSid(DomainPrefix,rgDomainSids[i])) ||
               (RtlEqualSid(Sid,rgDomainSids[i])))
          {
              *LocalSid = TRUE;
              break;
          }
      }


      if (!(*LocalSid))
      {
          //
          // Check for Enterprise Sid
          //

          for (i=0;i<cEnterpriseSids;i++)
          {
              if ((RtlEqualSid(DomainPrefix,rgEnterpriseSids[i]))||
                  (RtlEqualSid(Sid,rgEnterpriseSids[i])))
              {
                  *EnterpriseSid = TRUE;
                  break;
              }
          }

        if (!(*EnterpriseSid))
        {
            *ForeignSid = TRUE;
        }
      }
  }

Error:

      if  (DomainPrefix)
      {
          MIDL_user_free(DomainPrefix);
          DomainPrefix = NULL;
      }

      return NtStatus;
}


NTSTATUS
SampDsCreateForeignSecurityPrincipal(
    IN PSID pSid,
    IN DSNAME * DomainObjectName,
    OUT DSNAME ** ppDsName
    )
/*++

    Routine Description:

        This creates a foriegn security principal object that is a
        member of the corresponding domain.


        This routine specifies DS Classes/ Atttributes and makes direct
        Dir API calls rather than go through the DS layer / mappings.c
        process. This is because Mappings works only for the predefined
        object types SAM object types.

    Parameters:

        pSid -- Sid for whom the object is to be created.
        DomainObjectName -- The Name of the Domain Object.
        ppDsName -- DSName of the object to be created is returned in here

    Return Values:

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES

--*/

{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       ObjectClass = CLASS_FOREIGN_SECURITY_PRINCIPAL;
    ATTRTYP      NewObjectAttrs[] =
                {
                    ATT_OBJECT_SID,
                    ATT_OBJECT_CLASS,
                    ATT_NT_SECURITY_DESCRIPTOR
                };

    ATTRVAL     NewObjectVals[] =
                {
                    {RtlLengthSid(pSid),pSid},
                    {sizeof(ULONG),(UCHAR *)&ObjectClass},
                    {0,NULL}
                };

    DEFINE_ATTRBLOCK3(AttrBlockToSet,NewObjectAttrs,NewObjectVals);

    ULONG           RetCode;
    ADDARG          AddArg;
    ADDRES          *pAddRes;
    COMMARG         *pCommArg;
    DSNAME          *ObjectName = NULL;
    DSNAME          *ContainerName = NULL;
    UNICODE_STRING  SidName;
    PSECURITY_DESCRIPTOR SecurityDescriptor=NULL;
    ULONG                SecurityDescriptorLength;

    //
    // Initialize the return values
    //

    *ppDsName = NULL;
    SidName.Buffer = NULL;

    //
    // Get the Security Descriptor Attribute
    //

    NtStatus = SampGetDefaultSecurityDescriptorForClass(
                    ObjectClass,
                    &SecurityDescriptorLength,
                    TRUE,
                    &SecurityDescriptor
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    ASSERT(NULL!=SecurityDescriptor);
    AttrBlockToSet.pAttr[2].AttrVal.pAVal[0].pVal = SecurityDescriptor;
    AttrBlockToSet.pAttr[2].AttrVal.pAVal[0].valLen = SecurityDescriptorLength;

    //
    // Build the  Name
    //

    RtlZeroMemory(&SidName, sizeof(UNICODE_STRING));
    NtStatus = RtlConvertSidToUnicodeString(&SidName, pSid, TRUE);

    if (!NT_SUCCESS(NtStatus))
    {
        SidName.Buffer=NULL;
        goto Error;
    }


    //
    // Create container if required
    //

    NtStatus = SampDsCreateForeignContainer(DomainObjectName,&ContainerName);
    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }


    //
    // Create the Ds Name
    //
    NtStatus = SampDsCreateDsName2(ContainerName,&SidName,SAM_NO_LOOPBACK_NAME,&ObjectName);
    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    memset( &AddArg, 0, sizeof( AddArg ) );
    pCommArg = &(AddArg.CommArg);
    BuildStdCommArg(pCommArg);

    //
    // Setup the AddArg structure
    //

    AddArg.pObject = ObjectName;
    AddArg.AttrBlock = AttrBlockToSet;

    //
    // Make the DS call
    //

    SAMTRACE_DS("DirAddEntry\n");

    RetCode = DirAddEntry(&AddArg, &pAddRes);

    SAMTRACE_RETURN_CODE_DS(RetCode);

    //
    // Map the return code to an NT status
    //

    if (NULL==pAddRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetCode,&pAddRes->CommRes);
    }


    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    *ppDsName = ObjectName;

Error:

    if (ContainerName)
    {
        MIDL_user_free(ContainerName);
    }

    if (!NT_SUCCESS(NtStatus))
    {
        if (ObjectName)
            MIDL_user_free(ObjectName);
    }


    if (NULL!=SecurityDescriptor)
        MIDL_user_free(SecurityDescriptor);

    if (NULL!=SidName.Buffer)
    {
        RtlFreeHeap(RtlProcessHeap(),0,SidName.Buffer);
    }


    //
    // Clear any errors
    //

    SampClearErrors();

    //
    // Turn the fDSA flag back on as in loopback cases this can get reset
    //

    SampSetDsa(TRUE);


    return NtStatus;

}


NTSTATUS
SampDsCreateForeignContainer(
    IN DSNAME * DomainObjectName,
    OUT DSNAME ** ppContainerName
    )
/*++

    Routine Description:

        This routine creates a container object for holding foreign security prinicipals

    Parameters:

        DomainObjectName  -- DS name of the domain object.
        ppContainerName   -- DS name of the container is returned in here

    Return Values:

        STATUS_SUCCESS
        Other Error codes

--*/
{
    NTSTATUS    NtStatus;
    ULONG       ObjectClass = CLASS_CONTAINER;
    ULONG       SystemFlags = FLAG_DOMAIN_DISALLOW_RENAME |
                              FLAG_DOMAIN_DISALLOW_MOVE |
                              FLAG_DISALLOW_DELETE ;

    ATTRTYP     NewObjectAttrs[] =
                {
                    ATT_OBJECT_CLASS,
                    ATT_NT_SECURITY_DESCRIPTOR,
                    ATT_SYSTEM_FLAGS
                };

    ATTRVAL     NewObjectVals[] =
                {
                    {sizeof(ULONG),(UCHAR *)&ObjectClass},
                    {0,NULL},
                    {sizeof(ULONG),(UCHAR *)&SystemFlags}
                };

    DEFINE_ATTRBLOCK3(AttrBlockToSet,NewObjectAttrs,NewObjectVals);

    ULONG           RetCode;
    ADDARG          AddArg;
    ADDRES          *pAddRes;
    COMMARG         *pCommArg;
    DSNAME          *ObjectName = NULL;
    PSECURITY_DESCRIPTOR SecurityDescriptor=NULL;
    ULONG                SecurityDescriptorLength;

    //
    // BUGBUG this container name in here should not be hard coded but be
    // localized. Also need logic for dealing with conflicts with existing
    // user names.
    //

    WCHAR           ContainerNameBuffer[]=L"ForeignSecurityPrincipals";
    UNICODE_STRING  ContainerName;


    //
    // Get the Security Descriptor Attribute
    //

    NtStatus = SampGetDefaultSecurityDescriptorForClass(
                    ObjectClass,
                    &SecurityDescriptorLength,
                    TRUE,
                    &SecurityDescriptor
                    );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    ASSERT(NULL!=SecurityDescriptor);
    AttrBlockToSet.pAttr[1].AttrVal.pAVal[0].pVal = SecurityDescriptor;
    AttrBlockToSet.pAttr[1].AttrVal.pAVal[0].valLen = SecurityDescriptorLength;


    //
    // Create the DS Name
    //

    *ppContainerName = NULL;
    ContainerName.Length = sizeof(ContainerNameBuffer)-sizeof(WCHAR);
    ContainerName.MaximumLength = sizeof(ContainerNameBuffer)-sizeof(WCHAR);
    ContainerName.Buffer = ContainerNameBuffer;

    NtStatus = SampDsCreateDsName2(DomainObjectName,&ContainerName,SAM_NO_LOOPBACK_NAME,&ObjectName);
    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    memset( &AddArg, 0, sizeof( AddArg ) );
    pCommArg = &(AddArg.CommArg);
    BuildStdCommArg(pCommArg);

    //
    // Setup the AddArg structure
    //

    AddArg.pObject = ObjectName;
    AddArg.AttrBlock = AttrBlockToSet;

    //
    // Make the DS call
    //

    SAMTRACE_DS("DirAddEntry\n");

    RetCode = DirAddEntry(&AddArg, &pAddRes);

    SAMTRACE_RETURN_CODE_DS(RetCode);

    //
    // Map the return code to an NT status
    //

    if (NULL==pAddRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetCode,&pAddRes->CommRes);
    }

    if (!NT_SUCCESS(NtStatus))
    {

        NtStatus = STATUS_SUCCESS;
    }

    if (NT_SUCCESS(NtStatus))
    {
        *ppContainerName = ObjectName;
    }

Error:

    if (!NT_SUCCESS(NtStatus))
    {
        if (ObjectName)
            MIDL_user_free(ObjectName);
    }

    if (NULL!=SecurityDescriptor)
        MIDL_user_free(SecurityDescriptor);

    //
    // Clear any errors
    //

    SampClearErrors();

    //
    // Turn the fDSA flag back on as in loopback cases this can get reset
    //

    SampSetDsa(TRUE);


    return NtStatus;

}


NTSTATUS
SampDsResolveSidsForDsUpgrade(
    IN  PSID    DomainSid,
    IN  PSID    * rgSids,
    IN  ULONG   cSids,
    IN  ULONG   Flags,
    OUT DSNAME  ***rgDsNames
    )
/*++

    This is the flavour of Resolve Sids for DS upgrade. In the upgrade case
    all Sids not in the DS are treated as Foriegn Security Principals. This simplifies
    the upgrade process and does not require the availability of a G.C in order to perform
    the upgrade itself.

    Parameters:

        DomainSid -- The Sid of the domain that we are upgrading. Will be passed down to the
        SampCheckSidType to figure out wether the passed in Sid is belongs to the domain.

        rgSids    -- The set of Sids that we want to resolve.
        cSids     -- Number of Sids for above.
        Flags     -- Flags to be passed in for rgDsNames
        rgDsNames -- Array of DsNames.

    Return Values:

       STATUS_SUCCESS
       Other Error codes from SampResolveSidsWorker

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;


    NtStatus = SampDsBuildRootObjectName();
    if ( !NT_SUCCESS( NtStatus ) )
    {
        return NtStatus;
    }

    return ( SampDsResolveSidsWorker(
                rgSids,
                cSids,
                &DomainSid,
                1,
                NULL,
                0,
                Flags|RESOLVE_SIDS_SID_ONLY_DOMAIN_SIDS_OK,
                rgDsNames));
}


const SID_IDENTIFIER_AUTHORITY    WellKnownIdentifierAuthorities[] = {
                                    SECURITY_NULL_SID_AUTHORITY,
                                    SECURITY_WORLD_SID_AUTHORITY,
                                    SECURITY_LOCAL_SID_AUTHORITY,
                                    SECURITY_CREATOR_SID_AUTHORITY,
                                    SECURITY_NON_UNIQUE_AUTHORITY
                                 };


BOOLEAN SampIsWellKnownSid(
    IN PSID Sid
    )
/*++

  Routine Description

    This function checks to see if a Sid is a well known SID.

  Parameters:

        Sid  -- Sid to be checked out

  Return Values:


    TRUE if well known Sid
    FALSE if not

--*/
{

    BOOLEAN     RetValue = FALSE;
    PSID_IDENTIFIER_AUTHORITY   SidIdentifierAuthority;
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;
    ULONG   Index, 
            i = 0, 
            SubAuthCount = 0,
            FirstSubAuth = 0;


    
    SidIdentifierAuthority = RtlIdentifierAuthoritySid(Sid);

    for (Index=0;
            Index< ARRAY_COUNT(WellKnownIdentifierAuthorities);
                Index++)
    {
        if ((memcmp(
                &(WellKnownIdentifierAuthorities[Index]),
                SidIdentifierAuthority,
                sizeof(SID_IDENTIFIER_AUTHORITY)))==0)
        {
            RetValue = TRUE;
            break;
        }
        else if (memcmp(&NtAuthority, 
                        SidIdentifierAuthority,
                        sizeof(SID_IDENTIFIER_AUTHORITY)
                        ) == 0
                )
        {
            // SID belongs to Nt Authority
            SubAuthCount = *RtlSubAuthorityCountSid(Sid);

            if (SubAuthCount == 0)
            {
                // ONLY NT Authority SID has no sub auth's
                RetValue = TRUE;
            }
            else
            {

                //
                // Any Sid within builtin domain and account domain 
                // are not considered as well known SID in this routine,
                // because there is a real object in the backing store.
                //
                // For example  Builtin Domain itself, 
                //              Administrators Alias, 
                //              Domain Users Group are NOT well known here
                // 
                // Only those SIDs, which there is no real object to present 
                // them, are considered Well Known in SAM.
                //      
                // For Example  Anonymous Logon SID
                //              Dialup SID
                //              Network Service SID are well known SIDs. 
                // 

                FirstSubAuth = *RtlSubAuthoritySid(Sid, 0);

                if ((FirstSubAuth != SECURITY_BUILTIN_DOMAIN_RID) &&
                    (FirstSubAuth != SECURITY_NT_NON_UNIQUE))
                {
                    RetValue = TRUE;
                }
            }

            break;
        }
    }

    return RetValue;

}

NTSTATUS
SampDsGetSensitiveSidList(
    IN DSNAME *DomainObjectName,
    IN PULONG pcSensSids,
    IN PSID   **pSensSids
        )
/*++

    Routine Description:

        This routine retrieves the set of sensitive Sids given the name of
        the domain object.

    Parameters:

       DomainObjectName -- DS Name of the domain object
       pcSensSids       -- The count of Sids
       pSensSids        -- The List of sensitive Sids.

    Return Values:

        STATUS_SUCCESS
        STATUS_INSUFFICIENT_RESOURCES
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    //
    //
    // Today the list is hard coded to ADMINISTRATORS till
    // there is final decision on how this will be represented
    //

    *pcSensSids = 1;
    *pSensSids = ADMINISTRATOR_SID;
    return NtStatus;

}

BOOLEAN
SampCurrentThreadOwnsLock(
    VOID
    )
/*++

  Routine Description

        Tests wether the current thread owns the lock

--*/
{
    ULONG_PTR ExclusiveOwnerThread = (ULONG_PTR) SampLock.ExclusiveOwnerThread;
    ULONG_PTR CurrentThread = (ULONG_PTR) (NtCurrentTeb())->ClientId.UniqueThread;

    if ((SampLock.NumberOfActive <0) && (ExclusiveOwnerThread==CurrentThread))
        return TRUE;

    return FALSE;
}



NTSTATUS
SampDsExamineSid(
    IN PSID Sid,
    OUT BOOLEAN * WellKnownSid,
    OUT BOOLEAN * BuiltinDomainSid,
    OUT BOOLEAN * LocalSid,
    OUT BOOLEAN * ForeignSid,
    OUT BOOLEAN * EnterpriseSid
    )
/*++

    Routine Description

        Given a SID crack it to see what it represents

    Parameters:

        Sid the Sid
        WellKnownSid  -- The sid represents a security prinicipal like "EveryOne"
        LocalSid      -- Belongs to a domain that we host locally
        ForeignSid    -- Belongs to a domain unknown to the enterprise
        EnterpriseSid -- Belongs to a domain that is known to the enterprise but
                         not known to use
    Return Values

        Any resource failures
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PSID        *rgDomainSids = NULL;
    PSID        *rgEnterpriseSids = NULL;
    ULONG       cDomainSids=0;
    ULONG       cEnterpriseSids=0;

    //
    // Get the list of domain sids that we know about
    //

    NtStatus = SampGetDomainSidListForSam(
                &cDomainSids,
                &rgDomainSids,
                &cEnterpriseSids,
                &rgEnterpriseSids
                );

    if (!NT_SUCCESS(NtStatus))
     goto Error;

    //
    // Check the SID type
    //

    NtStatus = SampDsCheckSidType(
                Sid,
                cDomainSids,
                rgDomainSids,
                cEnterpriseSids,
                rgEnterpriseSids,
                WellKnownSid,
                BuiltinDomainSid,
                LocalSid,
                ForeignSid,
                EnterpriseSid
                );

Error:

    if (NULL!=rgDomainSids)
        MIDL_user_free(rgDomainSids);

    if (NULL!=rgEnterpriseSids)
        MIDL_user_free(rgEnterpriseSids);

    return NtStatus;
}

NTSTATUS
SampGetDomainSidListForSam(
    PULONG pcDomainSids,
    PSID   **rgDomainSids,
    PULONG pcEnterpriseSids,
    PSID   **rgEnterpriseSids
   )
/*++

    This routine obtains the List of Domain Sids for the domains hosted
    in this DC, by SAM. It also obtains the list of Sids for all the domains
    in the enterprise.

    Parameters

        pcDomainSids     -- Number of DomainSids is returned in here
        rgDomainSids     -- the Domain Sids themselves are returned in here.
        pcEnterpriseSids -- The Count of the domains in the enterprise minus the
                            domains hosted in here.
        rgEnterpriseSids -- The list of domain Sids of all the domains in the enterprise
                            This includes the Domain Sids of the domains hosted in this
                            domain controller also, but the domains check is applied
                            first.

   Return Values:

    STATUS_SUCCESS
    STATUS_INSUFFICIENT_RESOURCES
--*/
{

    ULONG i;
    ULONG DomainStart;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN  fLockAcquired = FALSE;



    DomainStart   = SampDsGetPrimaryDomainStart();
    *pcDomainSids = SampDefinedDomainsCount - DomainStart;
    *rgDomainSids = MIDL_user_allocate((*pcDomainSids) * sizeof(PSID));
    if (NULL==*rgDomainSids)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    //
    // Acquire the SAM lock before accessing globals. Do not
    // recursively acquire the lock
    //

    if (!SampCurrentThreadOwnsLock())
    {
        SampAcquireSamLockExclusive();
        fLockAcquired = TRUE;
    }

    //
    // Loop through defined domains array
    //

    for (i=0;i<*pcDomainSids;i++)
    {

        (*rgDomainSids)[i] = SampDefinedDomains[i+DomainStart].Sid;
    }

    //
    // Release the lock as soon as possible. We no longer need it
    //

    if (fLockAcquired)
    {
        SampReleaseSamLockExclusive();
        fLockAcquired = FALSE;
    }


    //
    // Query Number of Enterprise Sids
    //

    SampGetEnterpriseSidList(pcEnterpriseSids, NULL);

    if (*pcEnterpriseSids > 0)
    {
        //
        // Allocate memory for the Enterprise Sid Buffer
        //

        *rgEnterpriseSids = MIDL_user_allocate(*pcEnterpriseSids * sizeof(PSID));
        if (NULL==*rgEnterpriseSids)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }

        //
        // Get the Sids
        //

        SampGetEnterpriseSidList(pcEnterpriseSids,*rgEnterpriseSids);


    }


Error:

    if (!NT_SUCCESS(NtStatus))
    {
        if (NULL!=*rgDomainSids)
        {
            MIDL_user_free(*rgDomainSids);
            *rgDomainSids = NULL;
        }

        if (NULL!=*rgEnterpriseSids)
        {
            MIDL_user_free(*rgEnterpriseSids);
            *rgEnterpriseSids = NULL;
        }
    }

    if (fLockAcquired)
    {
        SampReleaseSamLockExclusive();
        fLockAcquired = FALSE;
    }

    return NtStatus;
}

NTSTATUS
SampDsResolveSids(
    IN  PSID    * rgSids,
    IN  ULONG   cSids,
    IN  ULONG   Flags,
    OUT DSNAME  ***rgDsNames
    )
/*++

    This is the Resolve Sids routine that is called from SAM. This routine calls the
    worker routine after some preprocessing.

  Parameters:

        rgSids -- The array of Sids that need to be passed in.
        cSids  -- The count of Sids
        Flags  -- Used to control the operation of the routine

                    RESOLVE_SIDS_ADD_FORIEGN_SECURITY_PRINCIPAL
                    -- Automatically Adds the foreign domain security principal to the DS.

                    RESOLVE_SIDS_FAIL_WELLKNOWN_SIDS
                    -- Fails the call if well known Sids are present in the array

                    RESOLVE_SIDS_VALIDATE_AGAINST_GC
                    -- Goes to the G.C if required

        rgDsNames -- Will MIDL_user alloc an array of DS Names back to the caller. Caller
                     is responsible for freeing them

    Return Values:

        STATUS_SUCCESS
        STATUS_UNSUCCESSFUL


    WARNING -- This Routine must be called with no Locks Held. Further this routine should not be
    called from the loopback case. The loopback call does its own validation ( GC / shim lookup )
    Further no open transaction must exist when DsResolveSids is called.

    It might seem unusual that this routine is called in the registry case also. The reason is that
    there should be no locks and no open transactions, while calling this routine and to ensure that
    the safest thing to do is to make it the first call in a Samr* call. This will cause this routine
    to be executed in the registry case also, but in reality this is a no Op in the registry case

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    PSID        *rgDomainSids = NULL;
    PSID        *rgEnterpriseSids = NULL;
    ULONG       cDomainSids;
    ULONG       cEnterpriseSids;
    DSNAME      *pLoopBackObject;


    //
    // Increment Active Thread Count. This routine Makes Ds Calls
    // without
    //

    NtStatus = SampIncrementActiveThreads();
    if (!NT_SUCCESS(NtStatus))
        return NtStatus;


    //
    // Check if are ds Case
    //

    if (SampUseDsData)
    {
        ASSERT(!SampCurrentThreadOwnsLock());
        ASSERT(!SampExistsDsTransaction());
        ASSERT(!SampExistsDsLoopback(&pLoopBackObject));

        if (Flags & RESOLVE_SIDS_SID_ONLY_NAMES_OK)
        {
            rgDomainSids = NULL;
            cDomainSids  = 0;
            rgEnterpriseSids = NULL;
            cEnterpriseSids = 0;
        }
        else
        {
             NtStatus = SampGetDomainSidListForSam(
                            &cDomainSids,
                            &rgDomainSids,
                            &cEnterpriseSids,
                            &rgEnterpriseSids
                            );
        }

        if (NT_SUCCESS(NtStatus))
        {


                NtStatus = SampDsResolveSidsWorker(
                            rgSids,
                            cSids,
                            rgDomainSids,
                            cDomainSids,
                            rgEnterpriseSids,
                            cEnterpriseSids,
                            Flags,
                            rgDsNames
                            );

        }
    }

    //
    // Free the array of Sids.
    //

    if (NULL!=rgDomainSids)
        MIDL_user_free(rgDomainSids);
    if (NULL!=rgEnterpriseSids)
        MIDL_user_free(rgEnterpriseSids);

    SampDecrementActiveThreads();

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\dslayer.h ===
/*++
Copyright (c) 1996 Microsoft Corporation

Module Name:

    dslayer.h

Abstract:

    Header file for SAM Private API Routines to access the DS
    These API provide a simplified API, and hide most of the
    underlying complexity to set up the parameters to a DS call
    and parse the resulting result. They also provide an abstraction
    by which we can create a simple layer, to unit test SAM without
    actually running the DS.

Author:
    MURLIS

Revision History

    5-14-96 Murlis Created
    11-Jul-1996 ChrisMay
        Added DEFINE_ATTRBLOCK5, 6.

--*/

#ifndef __DSLAYER_H__
#define __DSLAYER_H__

#include <samsrvp.h>
#include <ntdsa.h>
#include <scache.h>
#include <dbglobal.h>
#include <mdglobal.h>
#include <dsatools.h>
#include <wxlpc.h>

// Size Limit for DS operations
#define SAMP_DS_SIZE_LIMIT 100000


//
// Some defines for Error codes returned by Ds Layer calls.
//



///////////////////////////////////////////////////////////////////
//                                                               //
// Macros for defining Local arrays of Attributes                //
//                                                               //
///////////////////////////////////////////////////////////////////

//Need some preprocessor support to do this a variable number of times


//*****     ATTRBLOCK1
#define DEFINE_ATTRBLOCK1(_Name_, _AttrTypes_,_AttrValues_)\
ATTR    _AttrList_##_Name_[]=\
{\
    {_AttrTypes_[0], {1,&_AttrValues_[0]}}\
};\
ATTRBLOCK _Name_=\
{\
    sizeof(_AttrTypes_)/sizeof(_AttrTypes_[0]),\
    _AttrList_##_Name_\
}


//*****     ATTRBLOCK2
#define DEFINE_ATTRBLOCK2(_Name_, _AttrTypes_,_AttrValues_)\
ATTR    _AttrList_##_Name_[]=\
{\
    {_AttrTypes_[0], {1,&_AttrValues_[0]}},\
    {_AttrTypes_[1], {1,&_AttrValues_[1]}}\
};\
ATTRBLOCK _Name_=\
{\
    sizeof(_AttrTypes_)/sizeof(_AttrTypes_[0]),\
    _AttrList_##_Name_\
}


//*****    ATTRBLOCK3
#define DEFINE_ATTRBLOCK3(_Name_, _AttrTypes_,_AttrValues_)\
ATTR    _AttrList_##_Name_[]=\
{\
    {_AttrTypes_[0], {1,&_AttrValues_[0]}},\
    {_AttrTypes_[1], {1,&_AttrValues_[1]}},\
    {_AttrTypes_[2], {1,&_AttrValues_[2]}}\
};\
ATTRBLOCK _Name_=\
{\
    sizeof(_AttrTypes_)/sizeof(_AttrTypes_[0]),\
    _AttrList_##_Name_\
}


//*****    ATTRBLOCK4
#define DEFINE_ATTRBLOCK4(_Name_, _AttrTypes_,_AttrValues_)\
ATTR    _AttrList_##_Name_[]=\
{\
    {_AttrTypes_[0], {1,&_AttrValues_[0]}},\
    {_AttrTypes_[1], {1,&_AttrValues_[1]}},\
    {_AttrTypes_[2], {1,&_AttrValues_[2]}},\
    {_AttrTypes_[3], {1,&_AttrValues_[3]}}\
};\
ATTRBLOCK _Name_=\
{\
    sizeof(_AttrTypes_)/sizeof(_AttrTypes_[0]),\
    _AttrList_##_Name_\
}

//*****    ATTRBLOCK5
#define DEFINE_ATTRBLOCK5(_Name_, _AttrTypes_,_AttrValues_)\
ATTR    _AttrList_##_Name_[]=\
{\
    {_AttrTypes_[0], {1,&_AttrValues_[0]}},\
    {_AttrTypes_[1], {1,&_AttrValues_[1]}},\
    {_AttrTypes_[2], {1,&_AttrValues_[2]}},\
    {_AttrTypes_[3], {1,&_AttrValues_[3]}},\
    {_AttrTypes_[4], {1,&_AttrValues_[4]}}\
};\
ATTRBLOCK _Name_=\
{\
    sizeof(_AttrTypes_)/sizeof(_AttrTypes_[0]),\
    _AttrList_##_Name_\
}

//*****    ATTRBLOCK6
#define DEFINE_ATTRBLOCK6(_Name_, _AttrTypes_,_AttrValues_)\
ATTR    _AttrList_##_Name_[]=\
{\
    {_AttrTypes_[0], {1,&_AttrValues_[0]}},\
    {_AttrTypes_[1], {1,&_AttrValues_[1]}},\
    {_AttrTypes_[2], {1,&_AttrValues_[2]}},\
    {_AttrTypes_[3], {1,&_AttrValues_[3]}},\
    {_AttrTypes_[4], {1,&_AttrValues_[4]}},\
    {_AttrTypes_[5], {1,&_AttrValues_[5]}}\
};\
ATTRBLOCK _Name_=\
{\
    sizeof(_AttrTypes_)/sizeof(_AttrTypes_[0]),\
    _AttrList_##_Name_\
}

//*****    ATTRBLOCK7
#define DEFINE_ATTRBLOCK7(_Name_, _AttrTypes_,_AttrValues_)\
ATTR    _AttrList_##_Name_[]=\
{\
    {_AttrTypes_[0], {1,&_AttrValues_[0]}},\
    {_AttrTypes_[1], {1,&_AttrValues_[1]}},\
    {_AttrTypes_[2], {1,&_AttrValues_[2]}},\
    {_AttrTypes_[3], {1,&_AttrValues_[3]}},\
    {_AttrTypes_[4], {1,&_AttrValues_[4]}},\
    {_AttrTypes_[5], {1,&_AttrValues_[5]}},\
    {_AttrTypes_[6], {1,&_AttrValues_[6]}}\
};\
ATTRBLOCK _Name_=\
{\
    sizeof(_AttrTypes_)/sizeof(_AttrTypes_[0]),\
    _AttrList_##_Name_\
}

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// private structure used by Duplicate SAM Account Name Routine            //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


//
// used to pass the dupliate objects DSNAME to the asynchronous routine to rename
// those duplicate accounts.
// 

typedef struct _SAMP_RENAME_DUP_ACCOUNT_PARM   {
    ULONG           Count;
    PDSNAME         * DuplicateAccountDsNames; 
} SAMP_RENAME_DUP_ACCOUNT_PARM, *PSAMP_RENAME_DUP_ACCOUNT_PARM;




/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// DS DLL initialize exports. This is here only temporarily. Should remove //
// this and create a header file that has all the exports together         //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////



BOOLEAN
DsaWaitUntilServiceIsRunning(
    CHAR *ServiceName
    );

WX_AUTH_TYPE
DsGetBootOptions(VOID);

NTSTATUS
DsChangeBootOptions(
    WX_AUTH_TYPE    BootOption,
    ULONG           Flags,
    PVOID           NewKey,
    ULONG           cbNewKey
    );


///////////////////////////////////////////////////////////////////////
//                                                                   //
// DS Operation Routines and macros implemented in dslayer.c         //
//                                                                   //
///////////////////////////////////////////////////////////////////////


//
// Flag Values for All DS Layer Calls.
// The Flags use the Upper 16 bits of the DWORD. The lower 16 bit half is
// used by the mapping flags.
//

#define SAM_MAKE_DEL_AVAILABLE                  0x010000
#define SAM_UNICODE_STRING_MANUAL_COMPARISON    0x020000
#define SAM_LAZY_COMMIT                         0x040000
#define SAM_RESET_DSA_FLAG                      0x080000
#define SAM_NO_LOOPBACK_NAME                    0x100000
#define SAM_URGENT_REPLICATION                  0x200000
#define SAM_USE_OU_FOR_CN                       0x400000
#define SAM_ALLOW_REORDER                       0x800000
#define SAM_DELETE_TREE                        0x1000000
#define SAM_UPGRADE_FROM_REGISTRY              0x2000000

NTSTATUS
SampDsInitialize(
    BOOL fSamLoopback);

NTSTATUS
SampDsUninitialize();

NTSTATUS
SampDsRead(
            IN DSNAME * Object,
            IN ULONG    Flags,
            IN SAMP_OBJECT_TYPE ObjectType,
            IN ATTRBLOCK * AttributesToRead,
            OUT ATTRBLOCK * AttributeValues
          );


//
// Operatin Values for Set Attributes
//

#define REPLACE_ATT ((ULONG) 0)
#define ADD_ATT     ((ULONG) 1)
#define REMOVE_ATT  ((ULONG) 2)
#define ADD_VALUE   ((ULONG) 3)
#define REMOVE_VALUE ((ULONG) 4)



NTSTATUS
SampDsSetAttributes(
    IN DSNAME * Object,
    IN ULONG  Flags,
    IN ULONG  Operation,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ATTRBLOCK * AttributeList
    );

NTSTATUS
SampDsSetAttributesEx(
    IN DSNAME * Object,
    IN ULONG  Flags,
    IN ULONG  *Operation,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ATTRBLOCK * AttributeList
    );

NTSTATUS
SampDsCreateObjectActual(
    IN   DSNAME         *Object,
    IN   ULONG          Flags,
    SAMP_OBJECT_TYPE    ObjectType,
    IN   ATTRBLOCK      *AttributesToSet,
    IN   OPTIONAL PSID  DomainSid
    );



NTSTATUS
SampDsCreateObject(
    IN DSNAME * Object,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ATTRBLOCK * AttributesToSet,
    IN PSID DomainSid
    );

NTSTATUS
SampDsCreateInitialAccountObject(
    IN   PSAMP_OBJECT    Object,
    IN   ULONG           Flags,
    IN   ULONG           AccountRid,
    IN   PUNICODE_STRING AccountName,
    IN   PSID            CreatorSid OPTIONAL,
    IN   PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    IN   PULONG          UserAccountControl OPTIONAL,
    IN   PULONG          GroupType
    );


NTSTATUS
SampDsCreateBuiltinDomainObject(
    IN   DSNAME         *Object,
    IN   ATTRBLOCK      *AttributesToSet
    );

NTSTATUS
SampDsDeleteObject(
            IN DSNAME * Object,
            IN ULONG    Flags
            );

NTSTATUS
SampDsChangeAccountRDN(
    IN PSAMP_OBJECT Context,
    IN PUNICODE_STRING NewAccountName
    );

///////////////////////////////////////////////////////////////////
//                                                               //
//                                                               //
//    DS Search Routines                                         //
//                                                               //
//                                                               //
//                                                               //
///////////////////////////////////////////////////////////////////


#define SampDsDoSearch(r, dom, df, delta, otype, attr, max, search) \
        SampDsDoSearch2(0, r, dom, df, delta, otype, attr, max, 0, search) 


NTSTATUS
SampDsDoSearch2(
                ULONG    Flags,
                RESTART *Restart,
                DSNAME  *DomainObject,
                FILTER  *DsFilter,
                int      Delta,
                SAMP_OBJECT_TYPE ObjectTypeForConversion,
                ATTRBLOCK * AttrsToRead,
                ULONG   MaxMemoryToUse,
                ULONG   TimeLimit,
                SEARCHRES **SearchRes
                );



NTSTATUS
SampDsDoUniqueSearch(
             ULONG  Flags,
             IN DSNAME * ContainerObject,
             IN ATTR * AttributeToMatch,
             OUT DSNAME **Object
             );


NTSTATUS
SampDsLookupObjectByName(
            IN DSNAME * DomainObject,
            IN SAMP_OBJECT_TYPE ObjectType,
            IN PUNICODE_STRING ObjectName,
            OUT DSNAME ** Object
            );

NTSTATUS
SampDsLookupObjectByRid(
            IN DSNAME * DomainObject,
            ULONG ObjectRid,
            DSNAME **Object
            );

////////////////////////////////////////////////////////////////////
//                                                                //
//                                                                //
//     Object To Sid Mappings                                     //
//                                                                //
//                                                                //
////////////////////////////////////////////////////////////////////

NTSTATUS
SampDsObjectFromSid(
    IN PSID Sid,
    OUT DSNAME ** DsName
    );

PSID
SampDsGetObjectSid(
    IN  DSNAME * Object
    );



/////////////////////////////////////////////////////////////////////
//                                                                 //
//   Some Utility Routines in Dslayer.c                            //
//                                                                 //
//                                                                 //
/////////////////////////////////////////////////////////////////////

#define SampDsCreateDsName(d,a,n) SampDsCreateDsName2(d,a,0,n)

NTSTATUS
SampDsCreateDsName2(
            IN DSNAME * DomainObject,
            IN PUNICODE_STRING AccountName,
            IN ULONG           Flags,
            IN OUT DSNAME ** NewObject
            );


VOID
SampInitializeDsName(
            DSNAME * pDsName,
            WCHAR * NamePrefix,
            ULONG   NamePrefixLen,
            WCHAR * ObjectName,
            ULONG NameLen
            );



NTSTATUS
SampDsCreateAccountObjectDsName(
    IN  DSNAME *DomainObject,
    IN  PSID    DomainSid OPTIONAL,
    IN  SAMP_OBJECT_TYPE ObjectType,
    IN  PUNICODE_STRING AccountName,
    IN  PULONG  AccountRid OPTIONAL,
    IN  PULONG  UserAccountControl OPTIONAL,
    IN  BOOLEAN BuiltinDomain,
    OUT DSNAME **AccountObject
    );

NTSTATUS
SampDsBuildRootObjectName(
    VOID
    );
    
NTSTATUS
SampDsGetWellKnownContainerDsName(
    IN  DSNAME  *DomainObject,
    IN  GUID    *WellKnownGuid,
    OUT DSNAME  **ContainerObject
    );

NTSTATUS
SampInitWellKnownContainersDsName(
    IN DSNAME *DomainObject 
    );    

NTSTATUS
SampCopyRestart(
    IN  PRESTART OldRestart,
    OUT PRESTART *NewRestart
    );


// Miscellaneous routines accessed from other SAM source files.

PVOID
DSAlloc(
    IN ULONG Length
    );

NTSTATUS
SampMapDsErrorToNTStatus(
    ULONG RetValue,
    COMMRES *ComRes
    );


void
BuildStdCommArg(
    IN OUT COMMARG * pCommArg
    );

VOID
BuildDsNameFromSid(
    PSID Sid,
    DSNAME * DsName
    );

NTSTATUS
SampDoImplicitTransactionStart(
    SAMP_DS_TRANSACTION_CONTROL LocalTransactionType
    );


/////////////////////////////////////////////////////////////////////
//                                                                 //
//  ATTRBLOCK conversion routines. These Routines convert back     //
//  and forth between SAM and DS ATTRBLOCKS. The type of conversion//
//  depends upon the Flags Conversion Flags that are passed in.    //
//                                                                 //
//                                                                 //
/////////////////////////////////////////////////////////////////////


//
// Conversion Flag Definitions  for SampSamToDsAttrBlock. These
// Flags always occupy the lower 16 bits of the DWORD. The upper
// 16 bit of the DWORD is reserved for generic dslayer flags.
//

#define ALREADY_MAPPED_ATTRIBUTE_TYPES    ((ULONG)0x1)
#define REALLOC_IN_DSMEMORY               ((ULONG)0x2)
#define ADD_OBJECT_CLASS_ATTRIBUTE        ((ULONG)0x4)
#define MAP_RID_TO_SID                    ((ULONG)0x8)
#define DOMAIN_TYPE_DOMAIN                ((ULONG)0x10)
#define DOMAIN_TYPE_BUILTIN               ((ULONG)0x20)
#define IGNORE_GROUP_UNUSED_ATTR          ((ULONG)0x40)
#define SUPPRESS_GROUP_TYPE_DEFAULTING    ((ULONG)0x80)
#define SECURITY_DISABLED_GROUP_ADDITION  ((ULONG)0x100)
#define ADVANCED_VIEW_ONLY                ((ULONG)0x200)
#define FORCE_NO_ADVANCED_VIEW_ONLY       ((ULONG)0x400)

//
// Function Declaration
//

NTSTATUS
SampSamToDsAttrBlock(
            IN SAMP_OBJECT_TYPE ObjectType,
            IN ATTRBLOCK  *AttrBlockToConvert,
            IN ULONG      ConversionFlags,
            IN PSID       DomainSid,
            OUT ATTRBLOCK * ConvertedAttrBlock
            );

//
// Conversion Flag Definitions For SampDsToSamAttrBlock
//

// #define MAP_ATTRIBUTE_TYPES        0x1
#define MAP_SID_TO_RID             0x2

NTSTATUS
SampDsToSamAttrBlock(
            IN SAMP_OBJECT_TYPE ObjectType,
            IN ATTRBLOCK * AttrBlockToConvert,
            IN ULONG     ConversionFlags,
            OUT ATTRBLOCK * ConvertedAttrBlock
            );

ATTR *
SampDsGetSingleValuedAttrFromAttrBlock(
    IN ATTRTYP attrTyp,
    IN ATTRBLOCK * AttrBlock
    );


VOID
SampMapSamAttrIdToDsAttrId(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN OUT ATTRBLOCK * AttributeBlock
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\dsmodify.c ===
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <dsutilp.h>
#include <dslayer.h>
#include <dsmember.h>
#include <attids.h>
#include <mappings.h>
#include <ntlsa.h>
#include <nlrepl.h>
#include <msaudite.h>
#include <sdconvrt.h>
#include <ridmgr.h>
#include <malloc.h>
#include <setupapi.h>
#include <crypt.h>
#include <wxlpc.h>
#include <rc4.h>
#include <md5.h>
#include <enckey.h>
#include <rng.h>



NTSTATUS
SampInitUnicodeStringFromAttrVal(
    UNICODE_STRING  *pUnicodeString,
    ATTRVAL         *pAttrVal)

/*++

Routine Description:

    Initializes a RPC_UNICODE_STRING from an ATTRVAL.

Arguments:

    pUnicodeString - pointer to RPC_UNICODE_STRING to initialize.

    pAttrVal - pointer to ATTRVAL providing initialization value.

Return Value:

    None.

--*/

{
    if ( 0 == pAttrVal->valLen )
    {
        pUnicodeString->Length = 0;
        pUnicodeString->MaximumLength = 0;
        pUnicodeString->Buffer = NULL;
    }
    else if (pAttrVal->valLen > UNICODE_STRING_MAX_BYTES)
    {
        return(RPC_NT_STRING_TOO_LONG);
    }
    else
    {
        pUnicodeString->Length = (USHORT) pAttrVal->valLen;
        pUnicodeString->MaximumLength = (USHORT) pAttrVal->valLen;
        pUnicodeString->Buffer = (PWSTR) pAttrVal->pVal;
    }

    return (STATUS_SUCCESS);
}


NTSTATUS
SampGetUnicodeStringFromAttrVal(
    IN ULONG        iAttr,
    IN SAMP_CALL_MAPPING *rCallMap,
    IN BOOLEAN      fRemoveAllowed,
    OUT UNICODE_STRING  * pUnicodeString
    )
/*++

Routine Description:
    
    This routine get the unicode string attribute from a cell of 
    SAM_CALL_MAPPING

Parameters:

    iAttr - indicate the i'th attribute in the array

    rCallMap - pointer to the array
    
    fRemoveAllowed - indicate whether remove attribute is allowed
   
    pUnicodeString - string to return  

Return Values:    

    none

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    RtlInitUnicodeString(pUnicodeString, 
                         NULL
                         );

    if ((AT_CHOICE_REPLACE_ATT == rCallMap[iAttr].choice) && 
        (1 == rCallMap[iAttr].attr.AttrVal.valCount) )
    {
        Status = SampInitUnicodeStringFromAttrVal(
                        pUnicodeString,
                        rCallMap[iAttr].attr.AttrVal.pAVal
                        );
        return(Status);
    }

    ASSERT(fRemoveAllowed && 
           (AT_CHOICE_REMOVE_ATT == rCallMap[iAttr].choice) && 
           (0 == rCallMap[iAttr].attr.AttrVal.valCount) );

    return(Status);

}


VOID
SampGetUlongFromAttrVal(
    IN ULONG        iAttr,
    IN SAMP_CALL_MAPPING *rCallMap,
    IN BOOLEAN      fRemoveAllowed,
    OUT ULONG       *UlongValue
    )
/*++

Routine Description:
    
    This routine get the value of ULONG attribute from a cell of 
    SAM_CALL_MAPPING

Parameters:

    iAttr - indicate the i'th attribute in the array

    rCallMap - pointer to the array
    
    fRemoveAllowed - indicate whether remove attribute is allowed
   
    ULongValue - value to return  

Return Values:    

    none

--*/
{

    *UlongValue = 0;
    if ((AT_CHOICE_REPLACE_ATT == rCallMap[iAttr].choice) && 
        (1 == rCallMap[iAttr].attr.AttrVal.valCount) &&
        (sizeof(ULONG) == rCallMap[iAttr].attr.AttrVal.pAVal[0].valLen)
       )
    {
        *UlongValue = 
            * (ULONG *) rCallMap[iAttr].attr.AttrVal.pAVal[0].pVal;

        return;
    }
    ASSERT(fRemoveAllowed && 
           (AT_CHOICE_REMOVE_ATT == rCallMap[iAttr].choice) && 
           (0 == rCallMap[iAttr].attr.AttrVal.valCount) );

}


VOID
SampGetUShortFromAttrVal(
    IN ULONG        iAttr,
    IN SAMP_CALL_MAPPING *rCallMap,
    IN BOOLEAN      fRemoveAllowed,
    OUT USHORT       *UShortValue
    )
/*++

Routine Description:
    
    This routine get the value of USHORT attribute from a cell of 
    SAM_CALL_MAPPING

Parameters:

    iAttr - indicate the i'th attribute in the array

    rCallMap - pointer to the array
    
    fRemoveAllowed - indicate whether remove attribute is allowed
   
    UShortValue - value to return  

Return Values:    

    none

--*/
{

    *UShortValue = 0;
    if ((AT_CHOICE_REPLACE_ATT == rCallMap[iAttr].choice) && 
        (1 == rCallMap[iAttr].attr.AttrVal.valCount) &&
        (sizeof(SYNTAX_INTEGER) == rCallMap[iAttr].attr.AttrVal.pAVal[0].valLen)
       )
    {
        *UShortValue = 
            * (USHORT *) rCallMap[iAttr].attr.AttrVal.pAVal[0].pVal;

        return;
    }
    ASSERT(fRemoveAllowed && 
           (AT_CHOICE_REMOVE_ATT == rCallMap[iAttr].choice) && 
           (0 == rCallMap[iAttr].attr.AttrVal.valCount));

}

VOID
SampGetBooleanFromAttrVal(
    IN ULONG        iAttr,
    IN SAMP_CALL_MAPPING *rCallMap,
    IN BOOLEAN      fRemoveAllowed,
    OUT BOOLEAN       *BooleanValue
    )
/*++

Routine Description:
    
    This routine get the value of BOOLEAN attribute from a cell of 
    SAM_CALL_MAPPING

Parameters:

    iAttr - indicate the i'th attribute in the array

    rCallMap - pointer to the array
    
    fRemoveAllowed - indicate whether remove attribute is allowed
   
    BooleanValue - value to return  

Return Values:    

    none

--*/
{

    *BooleanValue = FALSE;
    if ((AT_CHOICE_REPLACE_ATT == rCallMap[iAttr].choice) && 
        (1 == rCallMap[iAttr].attr.AttrVal.valCount) &&
        (sizeof(ULONG) == rCallMap[iAttr].attr.AttrVal.pAVal[0].valLen)
       )
    {
        *BooleanValue = 
             ((*((ULONG *) rCallMap[iAttr].attr.AttrVal.pAVal[0].pVal)) != 0);

        return;
    }
    ASSERT(fRemoveAllowed && 
           (AT_CHOICE_REMOVE_ATT == rCallMap[iAttr].choice) && 
           (0 == rCallMap[iAttr].attr.AttrVal.valCount) );
}



VOID
SampGetLargeIntegerFromAttrVal(
    IN ULONG        iAttr,
    IN SAMP_CALL_MAPPING *rCallMap,
    IN BOOLEAN      fRemoveAllowed,
    OUT LARGE_INTEGER   *LargeIntegerValue
    )
/*++

Routine Description:
    
    This routine get the value of a LargeInteger attribute from a cell of 
    SAM_CALL_MAPPING

Parameters:

    iAttr - indicate the i'th attribute in the array

    rCallMap - pointer to the array
    
    fRemoveAllowed - indicate whether remove attribute is allowed
   
    LargeIntegerValue - value to return  

Return Values:    

    none

--*/
{

    LargeIntegerValue->LowPart = 0;
    LargeIntegerValue->HighPart = 0;

    if ((AT_CHOICE_REPLACE_ATT == rCallMap[iAttr].choice) && 
        (1 == rCallMap[iAttr].attr.AttrVal.valCount) &&
        (sizeof(LARGE_INTEGER) == rCallMap[iAttr].attr.AttrVal.pAVal[0].valLen)
       )
    {
        *LargeIntegerValue = * (LARGE_INTEGER *) 
                    rCallMap[iAttr].attr.AttrVal.pAVal[0].pVal;
        return;
    }
    ASSERT(fRemoveAllowed && 
           (AT_CHOICE_REMOVE_ATT == rCallMap[iAttr].choice) && 
           (0 == rCallMap[iAttr].attr.AttrVal.valCount) );

}



NTSTATUS
SampGetNewUnicodePasswordFromAttrVal(
    ULONG               iAttr,
    SAMP_CALL_MAPPING   *rCallMap,
    UNICODE_STRING      *NewPassword
    )
/*++

Routine Description:

    This routine retrieve Clear Text New Password from call_mapping

Parameters:

    iAttr - index of password attribute in the array
    
    rCallMap - attributes array
    
    NewPassword - return New Password
    
Return Values:

--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    UNICODE_STRING  PasswordInQuote;
    ATTR            *pAttr = &rCallMap[iAttr].attr;
    WCHAR           *pUnicodePwd;
    ULONG           cUnicodePwd, cb, i;


    if ( !( (AT_CHOICE_REPLACE_ATT == rCallMap[iAttr].choice) &&
            (1 == pAttr->AttrVal.valCount)) )
    {
        return( STATUS_UNSUCCESSFUL );
    }

    // 
    // Verify that this is a secure enough connection - one of the 
    // requirements for accepting passwords sent over the wire.
    //  
    if (!SampIsSecureLdapConnection())
    {
        return( STATUS_UNSUCCESSFUL );
    }


    // 
    // Verify that the password is enclosed in quotes.
    // 

    pUnicodePwd = (WCHAR *)pAttr->AttrVal.pAVal[0].pVal;
    cb = pAttr->AttrVal.pAVal[0].valLen;
    cUnicodePwd = cb / sizeof(WCHAR);
    if (     (cb < (2 * sizeof(WCHAR)))
          || (cb % sizeof(WCHAR))
          || (L'"' != pUnicodePwd[0])
          || (L'"' != pUnicodePwd[cUnicodePwd - 1])
       )
    {
        return( STATUS_UNSUCCESSFUL );
    }

    // Strip the quotes off of the password.
    pAttr->AttrVal.pAVal[0].valLen -= (2 * sizeof(WCHAR));
    for (i = 0; i < (cUnicodePwd - 2); i++) {
        pUnicodePwd[i] = pUnicodePwd[i+1];
    }
    
    NtStatus = SampInitUnicodeStringFromAttrVal(
                            NewPassword,
                            pAttr->AttrVal.pAVal);

    return( NtStatus );
}


NTSTATUS
SampGetNewUTF8PasswordFromAttrVal(
    ULONG               iAttr,
    SAMP_CALL_MAPPING   *rCallMap,
    UNICODE_STRING      *NewPassword
    )
/*++

Routine Description:

    This routine retrieve Clear Text New Password from call_mapping

Parameters:

    iAttr - index of password attribute in the array

    rCallMap - attributes array

    NewPassword - return New Password

Return Values:

--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS;
    UNICODE_STRING  PasswordInQuote;
    ATTR            *pAttr = &rCallMap[iAttr].attr;
    OEM_STRING      OemPassword;
    ULONG           WinError =0;
    ULONG           Length = 0;


    if ( AT_CHOICE_REPLACE_ATT != rCallMap[iAttr].choice )
    {
        return( STATUS_UNSUCCESSFUL );
    }

    //
    // Verify that this is a secure enough connection - one of the
    // requirements for accepting passwords sent over the wire.
    //
    if (!SampIsSecureLdapConnection())
    {
        return( STATUS_UNSUCCESSFUL );
    }


    //
    // retrieve passed in password 
    // 

    if (0 == pAttr->AttrVal.valCount)
    {
        OemPassword.Length = OemPassword.MaximumLength = 0;
        OemPassword.Buffer = NULL;
    }
    else
    {
        OemPassword.Length = OemPassword.MaximumLength = 
                (USHORT) pAttr->AttrVal.pAVal[0].valLen;
        OemPassword.Buffer = pAttr->AttrVal.pAVal[0].pVal;
    }

    //
    // The empty password is a special case
    //

    if (0==OemPassword.Length)
    {
        NewPassword->Length = NewPassword->MaximumLength = 0;
        NewPassword->Buffer = NULL;

        return(STATUS_SUCCESS);
    }

    Length =  MultiByteToWideChar(
                   CP_UTF8,
                   0,
                   OemPassword.Buffer,
                   OemPassword.Length,
                   NULL,
                   0
                   );


    if ((0==Length) || (Length > PWLEN))
    {
        //
        // Indicates that the function failed in some way
        // or that the password is too long
        //

        NtStatus = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    else
    {

        NewPassword->Length = (USHORT) Length * sizeof(WCHAR);
        NewPassword->Buffer = MIDL_user_allocate(NewPassword->Length);
        if (NULL==NewPassword->Buffer)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Cleanup;
        }

        NewPassword->MaximumLength = NewPassword->Length;

        if (!MultiByteToWideChar(
                    CP_UTF8,
                    0,
                    OemPassword.Buffer,
                    OemPassword.Length,
                    NewPassword->Buffer,
                    Length
                    ))
        {
            //
            // Some error occured in the conversion. Return
            // invalid parameter for now.
            //

            NtStatus = STATUS_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

Cleanup:

    return( NtStatus );
}

NTSTATUS
SampWriteDomainNtMixedDomain(
    SAMPR_HANDLE        hObj,
    ULONG               iAttr,
    DSNAME              *pObject,
    SAMP_CALL_MAPPING   *rCallMap
    )
/*++

Routine Description:

    This routine resets the Mixed Domain Flag to FALSE, coverting 
    this domain from mixed mode to native mode. 
    
    Note: This operation is not reversable !!!
    
Arguments:

    hObj - SAM handle of the domain object 

    iAttr - indicate the i'th attribute in the array

    pObject - pointer to the object DSNAME

    rCallMap - pointer to the attributes array
    

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS                        NtStatus = STATUS_SUCCESS;
    SAMPR_DOMAIN_INFO_BUFFER        *pInfo=NULL;
    ATTR                            *pAttr = &rCallMap[iAttr].attr;
    NT_PRODUCT_TYPE                 NtProductType;
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN pFixedAttrs = NULL;
    PSAMP_DEFINED_DOMAINS           pDomain = NULL;
    BOOLEAN                         NewNtMixedDomainValue = TRUE; 

    //
    // double check the attr, we should check it already in loopback.c
    // 
    ASSERT( ( (AT_CHOICE_REPLACE_ATT == rCallMap[iAttr].choice) &&
            (1 == pAttr->AttrVal.valCount) &&
            (sizeof(BOOL) == (pAttr->AttrVal.pAVal[0].valLen)) ) 
          );

    //
    // get the new value
    // 
    SampGetBooleanFromAttrVal(
                    iAttr,
                    rCallMap,
                    FALSE,  // remove is not allowed
                    &NewNtMixedDomainValue
                    );

    // Whenever the NT-Mixed-Domain attribute is changed, this routine is
    // called. Setting NT-Mixed-Domain from 1 to 0 causes the RID Manager
    // creation code to be called. The RID Manager object is created and
    // initial RID pools are allocated to the DC.

    // First, get the product type and server role in order to verify that
    // this is a domain controller and that it is the NT4 PDC. RID Manager
    // creation occurs when the NT-Mixed-Domain flag is set from 1 to 0 and
    // only on an NT4 PDC to prevent multiple instances of the RID Manager
    // from getting created on several different DC's. Only one is created,
    // then replicated to other DC's.

    RtlGetNtProductType(&NtProductType);



    // Make sure this only occurs on an NT4 PDC (and not a BDC), and that the
    // change is going from mixed domain to non-mixed domain only.

    if ((NtProductLanManNt == NtProductType) &&
        (SamIMixedDomain(hObj)))
    {
        MODIFYARG ModArg;
        MODIFYRES *pModRes = NULL;
        COMMARG *pCommArg = NULL;
        ATTR Attr;
        ATTRVALBLOCK AttrValBlock;
        ATTRVAL AttrVal;
        ULONG err = 0;
        ULONG NtMixedMode = 0;


        if (NewNtMixedDomainValue)
        {
            //
            // we are still in Mixed Domain state, and the caller wants
            // to stay with that, smile and turn around
            // 
            return( STATUS_SUCCESS );
        }


        // reset ATT_NT_MIXED_DOMAIN to zero, 
        // indicating that the system is going from mixed NT4-NT5
        // DC's to only NT5 DC's. Note, ATT_NT_MIXED_DOMAIN once set to 0
        // should never be reset to 1.


        RtlZeroMemory(&ModArg, sizeof(ModArg));

        ModArg.pObject = pObject;
        ModArg.FirstMod.pNextMod = NULL;
        ModArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;

        // By default, when the system is installed, the value of the attr-
        // ibute ATT_NT_MIXED_DOMAIN is one. This remains at one until the DC
        // is upgraded to NT5 and the Administrator resets the value to zero.
        // From then on, the value of ATT_NT_MIXED_DOMAIN must remain zero,
        // otherwise numerous operations on the DC will fail, such as account
        // creation. Note also, that it can only be set once. Subsequent
        // attempts to reset the value will error out.

        AttrVal.valLen = sizeof(ULONG);
        AttrVal.pVal = (PUCHAR)(&NtMixedMode);

        AttrValBlock.valCount = 1;
        AttrValBlock.pAVal = &AttrVal;

        Attr.attrTyp = ATT_NT_MIXED_DOMAIN;
        Attr.AttrVal = AttrValBlock;

        ModArg.FirstMod.AttrInf = Attr;
        ModArg.count = 1;

        pCommArg = &(ModArg.CommArg);
        InitCommarg(pCommArg);

        err = DirModifyEntry(&ModArg, &pModRes);

        //
        // Map the return code to an NT status
        //

        if (err)
        {
            KdPrint(("SAMSS: DirModifyEntry status = %d in SampWriteDomainNtMixedDomain\n", err));

            if (NULL==pModRes)
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {
                NtStatus = SampMapDsErrorToNTStatus(err,&pModRes->CommRes);
            }
        }

        // Given that the flag was reset, call the SAM routine that will
        // create the RID Manager object and initialize the RID pools on
        // the RID object (currently the NTDS-DSA object) with default
        // values.

        if (0 == err)
        {

            // Set the in-memory mixed-domain flag in SAM so that operations
            // still referencing this flag work as they should.

            NtStatus = SamISetMixedDomainFlag( hObj );

            // 
            // No error so far, event log the change.
            //

            SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,    // Event type
                              0,                            // Category
                              SAMMSG_CHANGE_TO_NATIVE_MODE, // MessageId
                              NULL,                         // User Sid
                              0,                            // Num of strings
                              0,                            // Data Size
                              NULL,                         // String
                              NULL                          // Data
                              );
        }
    }
    else
    {
        KdPrint(("SAMSS: Attempt to set NT-Mixed-Domain flag failed\n"));
        NtStatus = STATUS_UNSUCCESSFUL;
    }

    return(NtStatus);
}





NTSTATUS
SampValidatePrimaryGroupId(
    IN PSAMP_OBJECT AccountContext,
    IN SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed,
    IN ULONG PrimaryGroupId
    )
/*++
Routine Description:

    This routine validates the new primary group ID

Parameters: 
    
    AccountContext - object context
    
    V1aFixed - Fixed attributes
    
    PrimaryGroupId - New primary group ID to be set    

Return Value:

    NTSTATUS code
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    if ((V1aFixed.UserAccountControl & USER_SERVER_TRUST_ACCOUNT) &&
        (V1aFixed.PrimaryGroupId == DOMAIN_GROUP_RID_CONTROLLERS)
       ) 
    {
        // 
        // Domain Controller's Primary Group should ALWAYS be
        // DOMAIN_GROUP_RID_CONTROLLERS
        //

        if (DOMAIN_GROUP_RID_CONTROLLERS == PrimaryGroupId)
        {
            // no change
            NtStatus = STATUS_SUCCESS;
        }
        else
        {
            NtStatus = STATUS_DS_CANT_MOD_PRIMARYGROUPID;
        }
    }
    else
    {
        //
        // Make sure the primary group is legitimate
        // (it must be one the user is a member of)
        //

        NtStatus = SampAssignPrimaryGroup(
                            AccountContext,
                            PrimaryGroupId
                            );
    }

    return( NtStatus );
}


NTSTATUS
SampValidateUserAccountExpires(
    IN PSAMP_OBJECT AccountContext,
    IN LARGE_INTEGER    AccountExpires
    )
/*++

Routine Description:

    This routine checks whether the caller can set Account Expires
    on this account
    
Parameters:

    AccountContext - object context
    
    AccountExpires - new value of Account Expires attribute
    
Return Value:

    STATUS_SPECIAL_ACCOUNT
    
    STATUS_SUCCESS

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    if ( (!(AccountContext->TrustedClient)) && 
         (DOMAIN_USER_RID_ADMIN == AccountContext->TypeBody.User.Rid)
       )
    {
        LARGE_INTEGER   AccountNeverExpires;

        AccountNeverExpires = RtlConvertUlongToLargeInteger(
                                    SAMP_ACCOUNT_NEVER_EXPIRES
                                    );

        if (!(AccountExpires.QuadPart == AccountNeverExpires.QuadPart))
        {
            NtStatus = STATUS_SPECIAL_ACCOUNT;
        }
    }

    return( NtStatus );
}



NTSTATUS
SampValidateUserPwdLastSet(
    IN PSAMP_OBJECT AccountContext,
    IN LARGE_INTEGER TimeSupplied,
    OUT BOOLEAN     *PasswordExpired
    )
/*++

Routine Description:

    This routine determines the password should be expired or re-enabled. 
    
Parameters: 

    AccountContext - object context 
    
    TimeSupplied - Time provided by caller

                   Valid Values:
                   
                   0 - expire
                   
                   Max - re-enable password
                   
    PasswordExpired - Indicate whether the caller requests the password
                   to expire or not. 
    
Return Values  

    STATUS_SUCCESS
    STATUS_INVALID_PARAMETER

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    LARGE_INTEGER   ZeroTime, MaxTime;

    //
    // validate Parameters.
    // If Client passes in a 0 time, expire password.
    // Max Time re-enables Password
    //

    MaxTime.LowPart  = 0xFFFFFFFF;
    MaxTime.HighPart = 0xFFFFFFFF;

    if (TimeSupplied.QuadPart == 0i64)
    {
        *PasswordExpired = TRUE;
    }
    else if (TimeSupplied.QuadPart == MaxTime.QuadPart)
    {
        *PasswordExpired = FALSE;
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return( NtStatus );
}

NTSTATUS
SampWriteLockoutTime(
    IN PSAMP_OBJECT UserContext,
    IN PSAMP_V1_0A_FIXED_LENGTH_USER    V1aFixed,
    IN LARGE_INTEGER LockoutTime
    )
/*++

Routine Description:

    Called during loopback, this routine validates and then writes the lockout
    to the ds.

Parameters:

    UserHandle - a valid user context

    LockoutTime - the user specified lockout time

Return Values:

    STATUS_SUCCESS; STATUS_INVALID_PARAMETER
    other ds resource errors

--*/
{
    NTSTATUS         NtStatus  = STATUS_SUCCESS;


    //
    // Users can only write a zero value to lockout time, so
    // bail right away if this is the case
    //
    if ( !( LockoutTime.QuadPart == 0i64 ) )
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Ok, set the lockout time
    //
    RtlZeroMemory( &UserContext->TypeBody.User.LockoutTime,
                   sizeof( LARGE_INTEGER ) );

    NtStatus = SampDsUpdateLockoutTime( UserContext );

    //
    // Set the Bad Password count to zero
    //
    if ( NT_SUCCESS( NtStatus ) )
    {
        V1aFixed->BadPasswordCount = 0;

        NtStatus = SampSetFixedAttributes( UserContext,
                                           V1aFixed );
    }

    if ( NT_SUCCESS( NtStatus ) &&
         SampDoAccountAuditing(UserContext->DomainIndex)
         )
    {
        NTSTATUS        TmpNtStatus = STATUS_SUCCESS;
        UNICODE_STRING  UserAccountName;
        PSAMP_DEFINED_DOMAINS   Domain = NULL;

        TmpNtStatus = SampGetUnicodeStringAttribute(
                            UserContext,
                            SAMP_USER_ACCOUNT_NAME,
                            FALSE,      // Don't make copy
                            &UserAccountName
                            );

        if (NT_SUCCESS(TmpNtStatus))
        {

            Domain = &SampDefinedDomains[ UserContext->DomainIndex ]; 
            //
            // audit this event
            //
        
            SampAuditAnyEvent(
                UserContext,
                STATUS_SUCCESS,                         
                SE_AUDITID_ACCOUNT_UNLOCKED,        // Audit ID
                Domain->Sid,                        // Domain SID
                NULL,                               // Additional Info
                NULL,                               // Member Rid (unused)
                NULL,                               // Member Sid (unused)
                &UserAccountName,                   // Account Name
                &Domain->ExternalName,              // Domain Name
                &UserContext->TypeBody.User.Rid,    // Account Rid
                NULL                                // Privilege
                );
        }
    }


    return NtStatus;

}




NTSTATUS
SampWriteGroupMembers(
    IN SAMPR_HANDLE GroupHandle,
    IN DSNAME       *pObject,
    IN ULONG        iAttr,
    IN SAMP_CALL_MAPPING    *rCallMap
    )
/*++

Routine Description:

    This routine modifies the member attribute of group object
    
Parameters: 

    GroupHandle - SAM Handle of the group object
    
    pObject - object DSNAME

    iAttr - index of member attribute in the array
    
    rCallMap - attributes array

Returne Value:

    NTSTATUS code
    
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ATTR        *pAttr = &rCallMap[iAttr].attr;
    ULONG       i;
    ATTRBLOCK   AttrsRead;
    BOOLEAN     fValueExists = TRUE;

    // For expediency, we only allow adding / removing of values
    // and replacing of the whole attribute.

    if ( (AT_CHOICE_ADD_VALUES != rCallMap[iAttr].choice) &&
         (AT_CHOICE_REMOVE_VALUES != rCallMap[iAttr].choice) &&
         (AT_CHOICE_REPLACE_ATT != rCallMap[iAttr].choice) &&
         (AT_CHOICE_REMOVE_ATT != rCallMap[iAttr].choice) )
    {
        return( STATUS_INVALID_PARAMETER );
    }

    if ((AT_CHOICE_REPLACE_ATT == rCallMap[iAttr].choice) || 
        (AT_CHOICE_REMOVE_ATT == rCallMap[iAttr].choice) )
    {
        READARG     ReadArg;
        READRES     * pReadRes = NULL;
        COMMARG     * pCommArg = NULL;
        ATTR        MemberAttr;
        ENTINFSEL   EntInf;
        ULONG       err;

        //
        // first get all values in the member attribute by doing a DirRead
        // 

        memset(&EntInf, 0, sizeof(ENTINFSEL));
        memset(&ReadArg, 0, sizeof(READARG));

        MemberAttr.AttrVal.valCount = 0;
        MemberAttr.AttrVal.pAVal = NULL;
        MemberAttr.attrTyp = SampDsAttrFromSamAttr(
                                    SampGroupObjectType,
                                    SAMP_GROUP_MEMBERS
                                    );

        EntInf.AttrTypBlock.attrCount = 1;
        EntInf.AttrTypBlock.pAttr = &MemberAttr;
        EntInf.attSel = EN_ATTSET_LIST;
        EntInf.infoTypes = EN_INFOTYPES_SHORTNAMES;

        ReadArg.pObject = pObject;
        ReadArg.pSel = &EntInf;
        pCommArg = &(ReadArg.CommArg);
        BuildStdCommArg(pCommArg);

        err = DirRead(&ReadArg, &pReadRes);

        if (err)
        {
            if (NULL == pReadRes)
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {
                NtStatus = SampMapDsErrorToNTStatus(err, &pReadRes->CommRes);
            }

            //
            // if member attribute doesn't exist, that's ok
            // 
            if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE == NtStatus)
            {
                fValueExists = FALSE;
                SampClearErrors();
                NtStatus = STATUS_SUCCESS; 
            }
            else
            {
                return( NtStatus );
            }
        }

        //
        // remove all existing values if they exist
        // 
        if (fValueExists)
        {
            AttrsRead = pReadRes->entry.AttrBlock;

            if (AttrsRead.attrCount && AttrsRead.pAttr)
            {
                // only one attribute (members) should be returned
                ASSERT(1 == AttrsRead.attrCount);

                for (i = 0; i < AttrsRead.pAttr->AttrVal.valCount; i++)
                {
                    if (0 != AttrsRead.pAttr->AttrVal.pAVal[i].valLen)
                    {
                        NtStatus = SamIRemoveDSNameFromGroup(
                                       GroupHandle,
                                       (DSNAME *)AttrsRead.pAttr->AttrVal.pAVal[i].pVal
                                            );

                        if (!NT_SUCCESS(NtStatus))
                        {
                            return( NtStatus );
                        }
                    }
                }
            }
        }

        // We should have removed all the old values already, 
        // Now, start adding new values. 

        if (AT_CHOICE_REPLACE_ATT == rCallMap[iAttr].choice)
        {
            for (i = 0; i < pAttr->AttrVal.valCount; i++)
            {
                if (0 != pAttr->AttrVal.pAVal[i].valLen)
                {
                    NtStatus = SamIAddDSNameToGroup(
                                    GroupHandle, 
                                    (DSNAME *)pAttr->AttrVal.pAVal[i].pVal );

                    if (!NT_SUCCESS(NtStatus))
                    {
                        return (NtStatus);
                    }
                }
            }
        }
    }
    else
    {
        // 
        // add value or remove value, process them one by one
        // 
        for ( i = 0; i < pAttr->AttrVal.valCount; i++ )
        {
            if ( 0 != pAttr->AttrVal.pAVal[i].valLen )
            {
                if ( AT_CHOICE_ADD_VALUES == rCallMap[iAttr].choice )
                {
                    NtStatus = SamIAddDSNameToGroup(
                                    GroupHandle,
                                    (DSNAME *) pAttr->AttrVal.pAVal[i].pVal);
                }
                else
                {
                    NtStatus = SamIRemoveDSNameFromGroup(
                                    GroupHandle,
                                    (DSNAME *) pAttr->AttrVal.pAVal[i].pVal);
                }

                if ( !NT_SUCCESS(NtStatus) )
                {
                    return(NtStatus);
                }
            }       
        }
    }

    return( NtStatus );

}




NTSTATUS
SampWriteAliasMembers(
    IN SAMPR_HANDLE AliasHandle,
    IN DSNAME       *pObject,
    IN ULONG        iAttr,
    IN SAMP_CALL_MAPPING    *rCallMap
    )
/*++
Routine Description:

    This routine modifies the member attribute of an alias object
    
Parameters: 

    AliasHandle - SAM Handle of the Alias object
    
    pObject - object DSNAME

    iAttr - index of member attribute in the array
    
    rCallMap - attributes array

Returne Value:

    NTSTATUS code
    
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ATTR        *pAttr = &rCallMap[iAttr].attr;
    ULONG       i;
    ATTRBLOCK   AttrsRead;
    BOOLEAN     fValueExists = TRUE;

    // For expediency, we only allow adding / removing of values
    // and replacing of the whole attribute.

    if ( (AT_CHOICE_ADD_VALUES != rCallMap[iAttr].choice) &&
         (AT_CHOICE_REMOVE_VALUES != rCallMap[iAttr].choice) &&
         (AT_CHOICE_REPLACE_ATT != rCallMap[iAttr].choice) &&
         (AT_CHOICE_REMOVE_ATT != rCallMap[iAttr].choice) )
    {
        return( STATUS_INVALID_PARAMETER );
    }

    if ((AT_CHOICE_REPLACE_ATT == rCallMap[iAttr].choice) || 
        (AT_CHOICE_REMOVE_ATT == rCallMap[iAttr].choice) )
    {
        READARG     ReadArg;
        READRES     * pReadRes = NULL;
        COMMARG     * pCommArg = NULL;
        ATTR        MemberAttr;
        ENTINFSEL   EntInf;
        ULONG       err;

        //
        // first get all values in the member attribute by doing a DirRead
        // 

        memset(&EntInf, 0, sizeof(ENTINFSEL));
        memset(&ReadArg, 0, sizeof(READARG));

        MemberAttr.AttrVal.valCount = 0;
        MemberAttr.AttrVal.pAVal = NULL;
        MemberAttr.attrTyp = SampDsAttrFromSamAttr(
                                    SampGroupObjectType,
                                    SAMP_ALIAS_MEMBERS
                                    );

        EntInf.AttrTypBlock.attrCount = 1;
        EntInf.AttrTypBlock.pAttr = &MemberAttr;
        EntInf.attSel = EN_ATTSET_LIST;
        EntInf.infoTypes = EN_INFOTYPES_SHORTNAMES;

        ReadArg.pObject = pObject;
        ReadArg.pSel = &EntInf;
        pCommArg = &(ReadArg.CommArg);
        BuildStdCommArg(pCommArg);

        err = DirRead(&ReadArg, &pReadRes);

        if (err)
        {
            if (NULL == pReadRes)
            {
                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            }
            else
            {
                NtStatus = SampMapDsErrorToNTStatus(err, &pReadRes->CommRes);
            }

            //
            // if member attribute doesn't exist, that's ok
            // 
            if (STATUS_DS_NO_ATTRIBUTE_OR_VALUE == NtStatus)
            {
                fValueExists = FALSE;
                SampClearErrors();
                NtStatus = STATUS_SUCCESS; 
            }
            else
            {
                return( NtStatus );
            }
        }


        //
        // remove all existing values if they exist 
        // 
        if (fValueExists)
        {
            AttrsRead = pReadRes->entry.AttrBlock;

            if (AttrsRead.attrCount && AttrsRead.pAttr)
            {
                // only one attribute (members) should be returned
                ASSERT(1 == AttrsRead.attrCount);

                for (i = 0; i < AttrsRead.pAttr->AttrVal.valCount; i++)
                {
                    if (0 != AttrsRead.pAttr->AttrVal.pAVal[i].valLen)
                    {
                        NtStatus = SamIRemoveDSNameFromAlias(
                                       AliasHandle,
                                       (DSNAME *)AttrsRead.pAttr->AttrVal.pAVal[i].pVal
                                        );

                        if (!NT_SUCCESS(NtStatus))
                        {
                            return( NtStatus );
                        }
                    }
                }
            }
        }

        // We should have removed all the old values already, 
        // Now, start adding new values. 

        if (AT_CHOICE_REPLACE_ATT == rCallMap[iAttr].choice)
        {
            for (i = 0; i < pAttr->AttrVal.valCount; i++)
            {
                if (0 != pAttr->AttrVal.pAVal[i].valLen)
                {
                    NtStatus = SamIAddDSNameToAlias(
                                    AliasHandle, 
                                    (DSNAME *)pAttr->AttrVal.pAVal[i].pVal );

                    if (!NT_SUCCESS(NtStatus))
                    {
                        return (NtStatus);
                    }
                }
            }
        }
    }
    else
    {
        // 
        // add value or remove value, process them one by one
        // 
        for ( i = 0; i < pAttr->AttrVal.valCount; i++ )
        {
            if ( 0 != pAttr->AttrVal.pAVal[i].valLen )
            {
                if ( AT_CHOICE_ADD_VALUES == rCallMap[iAttr].choice )
                {
                    NtStatus = SamIAddDSNameToAlias(
                                    AliasHandle,
                                    (DSNAME *) pAttr->AttrVal.pAVal[i].pVal);

                }
                else
                {
                    NtStatus = SamIRemoveDSNameFromAlias(
                                    AliasHandle,
                                    (DSNAME *) pAttr->AttrVal.pAVal[i].pVal);
                }

                if ( !NT_SUCCESS(NtStatus) )
                {
                    return(NtStatus);
                }
            }       
        }
    }

    return( NtStatus );

}


NTSTATUS
SampWriteSidHistory(
    SAMPR_HANDLE        hObj,
    ULONG               iAttr,
    DSNAME              *pObject,
    ULONG               cCallMap,
    SAMP_CALL_MAPPING   *rCallMap
    )

/*++

Routine Description:

    Generic routine to write the sid history attribute

Arguments:

    hObj - SAMPR_HANDLE of open SAM object.

    iAttr - Index into SAMP_CALL_MAPPING holding new security descriptor.

    pObject - pointer to DSNAME of object being modified.

    cCallMap - number of elements in SAMP_CALL_MAPPING.

    rCallMap - address of SAMP_CALL_MAPPING array representing all
        attributes being modified by the high level Dir* call.

Return Value:

    NTSTATUS code

--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_OBJECT    AccountContext = (PSAMP_OBJECT) hObj;
    MODIFYARG ModifyArg;
    MODIFYRES *pModifyRes;
    ULONG RetCode=0;
    
    //
    // Non trusted client can ONLY remove values. 
    //
    // TrustedClient is turned on if pTHS->fCrossDomainMove is set
    // 

    if (!AccountContext->TrustedClient && 
        (AT_CHOICE_REMOVE_VALUES != rCallMap[iAttr].choice) )
    {
        return( STATUS_ACCESS_DENIED );
    }

    //
    // If cross domain move is set or if its a remove
    // value operation then proceed on modifying the object.
    //

    memset( &ModifyArg, 0, sizeof( ModifyArg ) );
    ModifyArg.FirstMod.AttrInf = rCallMap[iAttr].attr;
    InitCommarg(&(ModifyArg.CommArg));
    ModifyArg.FirstMod.choice = rCallMap[iAttr].choice;
    ModifyArg.pObject = pObject;
    ModifyArg.count = (USHORT) 1;

    RetCode = DirModifyEntry(&ModifyArg,&pModifyRes);

    if (RetCode)
    {
        if (NULL==pModifyRes)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            NtStatus = SampMapDsErrorToNTStatus(RetCode,&pModifyRes->CommRes);
        }
    }

    return(NtStatus);

}

NTSTATUS
SampValidateSiteAffinity(
    ATTRVAL      *SiteAffinityAttrVal
    )
/*++

Routine Description:

    This routine determines if SiteAffinityAttrVal points to a value that is a
    valid site affinity.
    
    The checks performed are:
    
    1) the site guid (the first 16 bytes) refer to an object that is site object
    (ie the object class contains the CLASS_SITE class
    2) the time stamp (the next 8 bytes) is zero

Arguments:

    SiteAffinityAttrVal -- a proposed site affinity value

Return Value:

    STATUS_SUCCESS,
    STATUS_INVALID_PARAMETER, if a bogus SA
    a resource error otherwise                 

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_SITE_AFFINITY SiteAffinity;
    SAMP_SITE_AFFINITY NullAffinity = {0};
    ULONG DirError;
    READARG ReadArg;
    READRES *ReadResult = NULL;
    ENTINFSEL EntInfSel; 
    ATTR      Attr;
    DSNAME  *SiteCandidate;
    BOOLEAN fSiteObject;

    if (SiteAffinityAttrVal->valLen < sizeof(SAMP_SITE_AFFINITY))
    {
        //
        // Wrong size; note that this accepts site affinities
        // that are of larger size in the future.
        //
        return STATUS_INVALID_PARAMETER;
    }
    SiteAffinity = (PSAMP_SITE_AFFINITY) SiteAffinityAttrVal->pVal;

    if (memcmp(&SiteAffinity->TimeStamp, 
               &NullAffinity.TimeStamp,
               sizeof(NullAffinity.TimeStamp)))
    {

        //
        // Time value is not zero
        //
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Try to find a site object that matches the GUID
    //
    SiteCandidate = alloca(DSNameSizeFromLen(0));
    RtlZeroMemory(SiteCandidate, DSNameSizeFromLen(0));
    SiteCandidate->structLen = DSNameSizeFromLen(0);
    RtlCopyMemory(&SiteCandidate->Guid, &SiteAffinity->SiteGuid, sizeof(GUID));

    RtlZeroMemory(&Attr, sizeof(Attr));
    Attr.attrTyp = ATT_OBJECT_CLASS;

    RtlZeroMemory(&EntInfSel, sizeof(EntInfSel));
    EntInfSel.AttrTypBlock.attrCount = 1;
    EntInfSel.AttrTypBlock.pAttr = &Attr;
    EntInfSel.attSel = EN_ATTSET_LIST;
    EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;

    RtlZeroMemory(&ReadArg, sizeof(READARG));
    ReadArg.pObject = SiteCandidate;
    ReadArg.pSel = &EntInfSel;
    InitCommarg(&ReadArg.CommArg);

    //
    // Issue the read
    //
    DirError = DirRead(&ReadArg, &ReadResult);

    if (NULL == ReadResult)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(DirError, &ReadResult->CommRes);
    }
    THClearErrors();

    if (STATUS_OBJECT_NAME_NOT_FOUND == NtStatus)
    {
        //
        // Couldn't find the object?
        //
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        //
        // Fatal resource error
        //
        goto Cleanup;
    }

    //
    // Look for the object class of CLASS_SITE; note that object class is
    // a multivalued attribute and this logic has to work for classes 
    // derived from CLASS_SITE as well.
    //
    fSiteObject = FALSE;
    if ((ReadResult->entry.AttrBlock.attrCount == 1)
     && (ReadResult->entry.AttrBlock.pAttr[0].attrTyp == ATT_OBJECT_CLASS))
    {
        ULONG i;

        for (i = 0; 
                i < ReadResult->entry.AttrBlock.pAttr[0].AttrVal.valCount;
                    i++) {

            ULONG Class;
            ATTRVAL *pAV;

            pAV = &ReadResult->entry.AttrBlock.pAttr[0].AttrVal.pAVal[i];
            if (pAV->valLen == sizeof(ULONG)) {
                Class = *((ULONG*)pAV->pVal);
                if (Class == CLASS_SITE) {
                    fSiteObject = TRUE;
                    break;
                }
            }
        }
    }

    if (!fSiteObject)
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }


Cleanup:

    if (ReadResult)
    {
        THFree(ReadResult);
    }

    return NtStatus;

}

NTSTATUS
SampWriteNoGCLogonAttrs(
    SAMPR_HANDLE        hObj,
    ULONG               AttrName,
    ULONG               iAttr,
    DSNAME              *pObject,
    ULONG               cCallMap,
    SAMP_CALL_MAPPING   *rCallMap
    )

/*++

Routine Description:

    Generic routine to write the no gc logon attributes

Arguments:

    hObj - SAMPR_HANDLE of open SAM object.
    
    AttrName - the SAM attribute

    iAttr - Index into SAMP_CALL_MAPPING holding new security descriptor.

    pObject - pointer to DSNAME of object being modified.

    cCallMap - number of elements in SAMP_CALL_MAPPING.

    rCallMap - address of SAMP_CALL_MAPPING array representing all
        attributes being modified by the high level Dir* call.

Return Value:

    NTSTATUS code

--*/
{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_OBJECT    AccountContext = (PSAMP_OBJECT) hObj;
    MODIFYARG ModifyArg;
    MODIFYRES *pModifyRes;
    ULONG RetCode=0;
    ULONG i;

    if ( (AttrName == SAMP_FIXED_USER_SITE_AFFINITY) 
        && ( (rCallMap[iAttr].choice == AT_CHOICE_ADD_ATT)
          || (rCallMap[iAttr].choice == AT_CHOICE_ADD_VALUES)))
    {
        //
        // The caller is writing the site affinity; we need to do 
        // validation checks
        // 
        for (i = 0; i < rCallMap[iAttr].attr.AttrVal.valCount; i++)
        {
            NtStatus = SampValidateSiteAffinity(&rCallMap[iAttr].attr.AttrVal.pAVal[i]);
            if (!NT_SUCCESS(NtStatus))
            {
                goto Cleanup;
            }
        }

    }
    else
    {
        //
        // Clients can only remove values; this should have been
        // checked in the loopback layer
        //
        if ( (AT_CHOICE_REMOVE_VALUES != rCallMap[iAttr].choice)
          && (AT_CHOICE_REMOVE_ATT    != rCallMap[iAttr].choice) )
        {
            ASSERT( FALSE && "Invalid call to SampWriteNoGcLogonAttrs -- review code" );
            NtStatus = STATUS_ACCESS_DENIED;
            goto Cleanup;
        }
    }
    
    
    memset( &ModifyArg, 0, sizeof( ModifyArg ) );
    ModifyArg.FirstMod.AttrInf = rCallMap[iAttr].attr;
    InitCommarg(&(ModifyArg.CommArg));
    ModifyArg.FirstMod.choice = rCallMap[iAttr].choice;
    ModifyArg.pObject = pObject;
    ModifyArg.count = (USHORT) 1;

    RetCode = DirModifyEntry(&ModifyArg,&pModifyRes);

    if (RetCode)
    {
        if (NULL==pModifyRes)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            NtStatus = SampMapDsErrorToNTStatus(RetCode,&pModifyRes->CommRes);
        }
    }

Cleanup:

    return(NtStatus);

}



NTSTATUS
SampMaintainPrimaryGroupIdChange(
    IN PSAMP_OBJECT AccountContext,
    IN ULONG        NewPrimaryGroupId,
    IN ULONG        OldPrimaryGroupId,
    IN BOOLEAN      KeepOldPrimaryGroupMembership
    )
/*++
    //
    // If the primary group Id has been changed then explicitly modify the
    // user's membership to include the old primary group as a member. This
    // is because in the DS case the membership in the primary group is not
    // stored explicitly, but is rather implicit in the primary group-id property.
    //
    // We will do two things:
    // 1. Always remove user from the New Primary Group. Thus eliminate duplicate
    //    membership in all scenarios.
    //    Case 1: client explicity changes the PrimaryGroupId, then the
    //            user must a member of the New Primary Group
    //    Case 2: System changes PrimaryGroupId when the account morphed,
    //            then the user may or may be a member of the New Primary Group.
    //
    // 2. When KeepOldPrimaryGroupMembership == TRUE, then add the user as a
    //    member in the Old Primary Group.
    //    KeepOldPrimaryGroupMembership will be set to TRUE whenever:
    //          a) PrimaryGroupId explicitly changed    OR
    //          b) PrimaryGroupId has been changed due to Domain Controller's
    //             PrimaryGroudId enforcement and the old Primary Group ID is
    //             not the default one.
    //

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS, IgnoreStatus;

    if (NewPrimaryGroupId != OldPrimaryGroupId)
    {
        //
        // STATUS_MEMBER_NOT_IN_GROUP is an expected error, that
        // is because the user is not necessary to be a member of the
        // new Primary Group in the case of the account getting morphed,
        // which triggers the PrimaryGroupId change.
        //
        IgnoreStatus = SampRemoveUserFromGroup(
                            AccountContext,
                            NewPrimaryGroupId,
                            AccountContext->TypeBody.User.Rid
                            );

        if (KeepOldPrimaryGroupMembership)
        {
            NtStatus =  SampAddUserToGroup(
                            AccountContext,
                            OldPrimaryGroupId,
                            AccountContext->TypeBody.User.Rid
                            );

            if (STATUS_NO_SUCH_GROUP==NtStatus)
            {
                //
                // Could be because the group has been deleted using
                // the tree delete mechanism. Reset status code to success
                //
                NtStatus = STATUS_SUCCESS;
            }
        }

    }

    return( NtStatus );
}





NTSTATUS
SampDsSetInformationDomain(
    IN SAMPR_HANDLE DomainHandle,
    IN DSNAME       *pObject,
    IN ULONG        cCallMap,
    IN SAMP_CALL_MAPPING *rCallMap,
    IN SAMP_ATTRIBUTE_MAPPING *rSamAttributeMap 
    )
/*++

Routine Description:

    This routine is called by loopback client to set domain object
    information.

Parameters:

    DomainHandle - Domain Context
    
    pObject - Domain Object DS Name
    
    cCallMap - number of attributes 
    
    rCallMap - contains attribute blocks
    
    rSamAttributeMap - SAM attribute mapping table

Return Value:

    STATUS_SUCCESS  success
    other value - failed

--*/

{
    NTSTATUS        NtStatus = STATUS_SUCCESS, IgnoreStatus;
    PSAMP_OBJECT    DomainContext = (PSAMP_OBJECT)DomainHandle; 
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN V1aFixed = NULL;
    SAMP_OBJECT_TYPE    FoundType;
    ACCESS_MASK     DesiredAccess = 0;
    BOOLEAN         fLockAcquired = FALSE;   
    BOOLEAN         FixedAttrChanged = FALSE,
                    OldUasCompat;
    ULONG           i, TempIntegerValue;
    BOOLEAN         fPasswordAgePolicyChanged = FALSE;
    BOOLEAN         fLockoutPolicyChanged = FALSE;


    //
    // Increment the active thread count, so we will consider this
    // thread at shutdown time
    // 
    NtStatus = SampIncrementActiveThreads();
    if (!NT_SUCCESS(NtStatus))
    {
        return( NtStatus );
    }

    //
    // Set the desired access based upon the attributes
    // 

    for ( i = 0; i < cCallMap; i++ )
    {
        if ( !rCallMap[i].fSamWriteRequired || rCallMap[i].fIgnore)
        {
            continue;
        }

        switch (rSamAttributeMap[ rCallMap[i].iAttr ].SamAttributeType)
        {
        case SAMP_FIXED_DOMAIN_FORCE_LOGOFF:
        case SAMP_FIXED_DOMAIN_UAS_COMPAT_REQUIRED:

            DesiredAccess |= DOMAIN_WRITE_OTHER_PARAMETERS; 
            break;

        case SAMP_FIXED_DOMAIN_MAX_PASSWORD_AGE:
        case SAMP_FIXED_DOMAIN_MIN_PASSWORD_AGE:
        case SAMP_FIXED_DOMAIN_LOCKOUT_DURATION:
        case SAMP_FIXED_DOMAIN_LOCKOUT_OBSERVATION_WINDOW:
        case SAMP_FIXED_DOMAIN_PWD_PROPERTIES:
        case SAMP_FIXED_DOMAIN_MIN_PASSWORD_LENGTH:
        case SAMP_FIXED_DOMAIN_PASSWORD_HISTORY_LENGTH:
        case SAMP_FIXED_DOMAIN_LOCKOUT_THRESHOLD:

            DesiredAccess |= DOMAIN_WRITE_PASSWORD_PARAMS;
            break;

        default:
            break;
        }
    }

    //
    // Validate type of, and access to object
    // 

    NtStatus = SampLookupContext(DomainContext,
                                 DesiredAccess,
                                 SampDomainObjectType,
                                 &FoundType
                                 );

    if (NT_SUCCESS(NtStatus))
    {
        //
        // Get the fixed length data for the domain object 
        // 

        NtStatus = SampGetFixedAttributes(DomainContext,
                                          FALSE,     //  Don't Make Copy
                                          (PVOID *)&V1aFixed
                                          );

        if (NT_SUCCESS(NtStatus))
        {
            OldUasCompat = V1aFixed->UasCompatibilityRequired;

            for ( i = 0; i < cCallMap; i++ )
            {
                ATTR    *pAttr = NULL;

                if ( !rCallMap[i].fSamWriteRequired || rCallMap[i].fIgnore )
                {
                    continue;
                }

                //
                // get the attr address
                // 
                pAttr = &(rCallMap[i].attr);

                switch (rSamAttributeMap[ rCallMap[i].iAttr ].SamAttributeType)
                {
                case SAMP_FIXED_DOMAIN_MAX_PASSWORD_AGE:

                    SampGetLargeIntegerFromAttrVal(i, rCallMap, FALSE, 
                                                   &(V1aFixed->MaxPasswordAge) ); 

                    if (V1aFixed->MaxPasswordAge.QuadPart > 0) 
                    {

                        // the max password age isn't a delta time

                        NtStatus = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        FixedAttrChanged = TRUE;
                        fPasswordAgePolicyChanged = TRUE;
                    }

                    break;

                case SAMP_FIXED_DOMAIN_MIN_PASSWORD_AGE:

                    SampGetLargeIntegerFromAttrVal(i, rCallMap, FALSE,
                                        &(V1aFixed->MinPasswordAge) );

                    if (V1aFixed->MinPasswordAge.QuadPart > 0)
                    {

                        // the min password age isn't a delta time

                        NtStatus = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        FixedAttrChanged = TRUE;
                        fPasswordAgePolicyChanged = TRUE;
                    }

                    break;

                case SAMP_FIXED_DOMAIN_FORCE_LOGOFF:

                    SampGetLargeIntegerFromAttrVal( i, rCallMap, FALSE,
                                        &(V1aFixed->ForceLogoff) );

                    FixedAttrChanged = TRUE;

                    break;

                case SAMP_FIXED_DOMAIN_LOCKOUT_DURATION:

                    SampGetLargeIntegerFromAttrVal( i, rCallMap, FALSE,
                                        &(V1aFixed->LockoutDuration) );

                    if (V1aFixed->LockoutDuration.QuadPart > 0)
                    {

                        // the lock out duration isn't a delta time

                        NtStatus = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        FixedAttrChanged = TRUE;
                        fLockoutPolicyChanged = TRUE;
                    }

                    break;

                case SAMP_FIXED_DOMAIN_LOCKOUT_OBSERVATION_WINDOW:

                    SampGetLargeIntegerFromAttrVal( i, rCallMap, FALSE,
                                        &(V1aFixed->LockoutObservationWindow) );

                    if (V1aFixed->LockoutObservationWindow.QuadPart > 0)
                    {

                        // the lock out oberservation isn't a delta time

                        NtStatus = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        FixedAttrChanged = TRUE;
                        fLockoutPolicyChanged = TRUE;
                    }

                    break;

                case SAMP_FIXED_DOMAIN_PWD_PROPERTIES:

                    SampGetUlongFromAttrVal( i, rCallMap, FALSE,
                                        &(V1aFixed->PasswordProperties) );

                    FixedAttrChanged = TRUE;

                    break;

                case SAMP_FIXED_DOMAIN_MIN_PASSWORD_LENGTH:

                    SampGetUShortFromAttrVal( i, rCallMap, FALSE,
                                        &(V1aFixed->MinPasswordLength) );
                    
                    if (V1aFixed->MinPasswordLength > PWLEN)
                    {
                        //
                        // Password should be less then PWLEN - 256
                        // or Mix Password Length should be larger
                        // than that.
                        // 

                        NtStatus = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        FixedAttrChanged = TRUE;
                    }

                    break;

                case SAMP_FIXED_DOMAIN_PASSWORD_HISTORY_LENGTH:

                    SampGetUShortFromAttrVal( i, rCallMap, FALSE,
                                        &(V1aFixed->PasswordHistoryLength) );

                    if (V1aFixed->PasswordHistoryLength >
                        SAMP_MAXIMUM_PASSWORD_HISTORY_LENGTH)
                    {
                        // the history length is larger than we can 
                        // allow 

                        NtStatus = STATUS_INVALID_PARAMETER;
                    }
                    else
                    {
                        FixedAttrChanged = TRUE;
                    }

                    break;

                case SAMP_FIXED_DOMAIN_LOCKOUT_THRESHOLD:

                    SampGetUShortFromAttrVal( i, rCallMap, FALSE,
                                        &(V1aFixed->LockoutThreshold) );

                    FixedAttrChanged = TRUE;

                    break;

                case SAMP_FIXED_DOMAIN_UAS_COMPAT_REQUIRED:

                    //
                    // We will drop support for UAS compatibility 
                    // 

                    NtStatus = STATUS_INVALID_PARAMETER;

                    break;

                case SAMP_DOMAIN_MIXED_MODE:

                    //
                    // Call the worker routine in DS
                    // 

                    NtStatus = SampWriteDomainNtMixedDomain(
                                                DomainHandle,
                                                i,
                                                pObject,
                                                rCallMap
                                                ); 

                    break;

                default:

                    ASSERT(FALSE && "Logic Error, invalide SAM attr type");
                    break;
                }   // switch

                if (!NT_SUCCESS(NtStatus))
                    break;

            }// for
        }

        //
        // Do combination checks
        //
        if (NT_SUCCESS(NtStatus)
        &&  fPasswordAgePolicyChanged
        && (V1aFixed->MaxPasswordAge.QuadPart >= V1aFixed->MinPasswordAge.QuadPart)  ) {

            //
            // Can't have a minimum age longer than a maximum age
            //

            NtStatus = STATUS_INVALID_PARAMETER;
        }

        if (NT_SUCCESS(NtStatus)
        &&  fLockoutPolicyChanged
        && (V1aFixed->LockoutDuration.QuadPart > 
            V1aFixed->LockoutObservationWindow.QuadPart)) {

            //
            // Infeasible to have a duration shorter than the observation
            // window; note these values are negative.
            //

            NtStatus = STATUS_INVALID_PARAMETER;
        }

        if (NT_SUCCESS(NtStatus) && FixedAttrChanged)
        {
            NtStatus = SampSetFixedAttributes(
                                DomainContext,
                                V1aFixed
                                );
        }

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampDeReferenceContext(DomainContext, TRUE);
        }
        else {

            IgnoreStatus = SampDeReferenceContext(DomainContext, FALSE);
        }
    }

    //
    // Generate an audit if necesary
    // 
    if (NT_SUCCESS(NtStatus) &&
        SampDoAccountAuditing(DomainContext->DomainIndex) )
    {
        SampAuditDomainChangeDs(DomainContext,
                                cCallMap,
                                rCallMap,
                                rSamAttributeMap
                                );
    }

    //
    // Let shutdown handling logic know that we are done
    // 

    SampDecrementActiveThreads();

    return( NtStatus );
}





NTSTATUS
SampDsSetInformationGroup(
    IN SAMPR_HANDLE GroupHandle,
    IN DSNAME       *pObject,
    IN ULONG        cCallMap,
    IN SAMP_CALL_MAPPING *rCallMap,
    IN SAMP_ATTRIBUTE_MAPPING *rSamAttributeMap 
    )
/*++

Routine Description:

    This routine is called by loopback client to set group object
    information.

Parameters:

    GroupHandle - Group Context
    
    pObject - Domain Object DS Name
    
    cCallMap - number of attributes 
    
    rCallMap - contains attribute blocks
    
    rSamAttributeMap - SAM attribute mapping table

Return Value:

    STATUS_SUCCESS  success
    other value - failed

--*/
{
    NTSTATUS            NtStatus = STATUS_SUCCESS, IgnoreStatus;
    PSAMP_OBJECT        GroupContext = (PSAMP_OBJECT)GroupHandle;
    SAMP_OBJECT_TYPE    FoundType;
    SAMP_V1_0A_FIXED_LENGTH_GROUP   V1Fixed;
    ACCESS_MASK         DesiredAccess = 0;
    UNICODE_STRING      OldAccountName = {0, 0, NULL};
    UNICODE_STRING      NewAccountName, AdminComment;
    ULONG               GroupType, i;
    BOOLEAN             AccountNameChanged = FALSE;

    //
    // Increment the active thread count, so we will consider this
    // thread at shutdown time
    // 
    NtStatus = SampIncrementActiveThreads();
    if (!NT_SUCCESS(NtStatus))
    {
        return( NtStatus );
    }


    //
    // Set the desired access based upon the attributes to be modified
    // 
    for ( i = 0; i< cCallMap; i++ )
    {
        if (!rCallMap[i].fSamWriteRequired || rCallMap[i].fIgnore)
        {
            continue;
        }

        switch (rSamAttributeMap[ rCallMap[i].iAttr ].SamAttributeType)
        {
        case SAMP_GROUP_NAME:
        case SAMP_GROUP_ADMIN_COMMENT:
            DesiredAccess |= GROUP_WRITE_ACCOUNT;
            break;
        default:
            break; 
        }
    }

    //
    // Validate type of, and access to object
    // 
    NtStatus = SampLookupContext(GroupContext,
                                 DesiredAccess,        // Desired Access
                                 SampGroupObjectType,
                                 &FoundType
                                 );

    if (NT_SUCCESS(NtStatus))
    {

        NtStatus = SampRetrieveGroupV1Fixed(GroupContext,
                                            &V1Fixed
                                            );

        if (NT_SUCCESS(NtStatus))
        {
            for ( i = 0; i < cCallMap; i++ )
            {
                ATTR        *pAttr = NULL;

                if ( !rCallMap[i].fSamWriteRequired || rCallMap[i].fIgnore )
                {
                    continue;
                }

                //
                // get the attr address
                // 
                pAttr = &(rCallMap[i].attr);

                switch (rSamAttributeMap[ rCallMap[i].iAttr ].SamAttributeType)
                {
                case SAMP_GROUP_NAME:

                    //
                    // Can only replace the name - can't remove it 
                    // 

                    NtStatus = SampGetUnicodeStringFromAttrVal( 
                                        i, rCallMap,
                                        FALSE,      // remove is not allowed
                                        &NewAccountName );
                    if (NT_SUCCESS(NtStatus))
                    {
                    

                        RtlInitUnicodeString(&OldAccountName, NULL);

                        NtStatus = SampChangeGroupAccountName(
                                        GroupContext,
                                        &NewAccountName,
                                        &OldAccountName
                                        );

                        if (!NT_SUCCESS(NtStatus))
                        {
                            OldAccountName.Buffer = NULL;
                        }

                        AccountNameChanged = TRUE;
                    }

                    break;

                case SAMP_GROUP_ADMIN_COMMENT:
        
                    NtStatus = SampGetUnicodeStringFromAttrVal( 
                                        i, rCallMap, TRUE, &AdminComment );
                    if (NT_SUCCESS(NtStatus))
                    {

                        NtStatus = SampSetUnicodeStringAttribute(
                                        GroupContext,
                                        SAMP_GROUP_ADMIN_COMMENT,
                                        &AdminComment
                                        );
                    }

                    break;

                case SAMP_GROUP_MEMBERS:
            
                    //
                    // Write group member attribute
                    // 
                    NtStatus = SampWriteGroupMembers(GroupHandle, 
                                                     pObject,
                                                     i, 
                                                     rCallMap
                                                     );

                    break;

                case SAMP_GROUP_SID_HISTORY:
        
                    //
                    // SampWriteSidHistory
                    // 
                    NtStatus = SampWriteSidHistory(
                                            GroupHandle,
                                            i,
                                            pObject,
                                            cCallMap,
                                            rCallMap
                                            );

                    break;

                case SAMP_FIXED_GROUP_TYPE:
                
                    //
                    // Get Group Type Value
                    // 
                    SampGetUlongFromAttrVal( i, rCallMap,
                                        FALSE,      // remove is not allowed
                                        &GroupType );

                    NtStatus = SampWriteGroupType(GroupHandle, 
                                                  GroupType,
                                                  FALSE
                                                  );

                    break;

                default:
                    ASSERT(FALSE && "Logic Error, invalid SAM attr type");
                    break;
                }

                if (!NT_SUCCESS(NtStatus))
                    break;
            }
        }

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampDeReferenceContext(GroupContext, TRUE);
        }
        else {
        
            IgnoreStatus = SampDeReferenceContext(GroupContext, FALSE);
        }
    }

    //
    // Audit Account Name Change
    //
    // Note: GroupType, SidHistory, Members changes all have been audited
    //       separately.
    //
    // a more generic audit event will be generated when processing notification 
    // list in SampNotifyReplicatedinChange()
    // 

    if (NT_SUCCESS(NtStatus) && 
        AccountNameChanged && 
        SampDoAccountAuditing(GroupContext->DomainIndex) )
    {
        SampAuditAccountNameChange(GroupContext, &NewAccountName, &OldAccountName);
    }


    //
    // Let shutdown handling logic know that we are done
    // 

    SampDecrementActiveThreads();

    //
    // Cleanup string
    // 
    SampFreeUnicodeString( &OldAccountName );

    return( NtStatus );
}



NTSTATUS
SampDsSetInformationAlias(
    IN SAMPR_HANDLE AliasHandle,
    IN DSNAME       *pObject,
    IN ULONG        cCallMap,
    IN SAMP_CALL_MAPPING *rCallMap,
    IN SAMP_ATTRIBUTE_MAPPING *rSamAttributeMap 
    )
/*++
Routine Description:

    This routine is called by loopback client to set alias object
    information.

Parameters:

    AliasHandle - Alias Context
    
    pObject - Domain Object DS Name
    
    cCallMap - number of attributes 
    
    rCallMap - contains attribute blocks
    
    rSamAttributeMap - SAM attribute mapping table

Return Value:

    STATUS_SUCCESS  success
    other value - failed

--*/

{
    NTSTATUS            NtStatus = STATUS_SUCCESS, IgnoreStatus;
    PSAMP_OBJECT        AliasContext = (PSAMP_OBJECT)AliasHandle;
    SAMP_OBJECT_TYPE    FoundType;
    ACCESS_MASK         DesiredAccess = 0;
    UNICODE_STRING      OldAccountName = {0, 0, NULL};
    UNICODE_STRING      NewAccountName, AdminComment;
    ULONG               GroupType, i;
    BOOLEAN             AccountNameChanged = FALSE;

    //
    // Increment the active thread count, so we will consider this
    // thread at shutdown time
    // 
    NtStatus = SampIncrementActiveThreads();
    if (!NT_SUCCESS(NtStatus))
    {
        return( NtStatus );
    }



    //
    // Set the desired access based upon the attributes to be modified
    // 
    for ( i = 0; i< cCallMap; i++ )
    {
        if (!rCallMap[i].fSamWriteRequired || rCallMap[i].fIgnore)
        {
            continue;
        }

        switch (rSamAttributeMap[ rCallMap[i].iAttr ].SamAttributeType)
        {
        case SAMP_ALIAS_NAME:
        case SAMP_ALIAS_ADMIN_COMMENT:
            DesiredAccess |= ALIAS_WRITE_ACCOUNT;
            break;
        default:
            break; 
        }
    }

    //
    // Validate type of, and access to object
    // 
    NtStatus = SampLookupContext(AliasContext, 
                                 DesiredAccess,
                                 SampAliasObjectType,
                                 &FoundType
                                 );


    if (NT_SUCCESS(NtStatus))
    {
        for ( i = 0; i < cCallMap; i++ )
        {
            ATTR    *pAttr = NULL;

            if ( !rCallMap[i].fSamWriteRequired || rCallMap[i].fIgnore )
            {
                continue;
            }

            switch (rSamAttributeMap[ rCallMap[i].iAttr ].SamAttributeType)
            {
            case SAMP_ALIAS_NAME:

                //
                // Can only replace the name - can't remove it 
                // 

                 NtStatus = SampGetUnicodeStringFromAttrVal(i, rCallMap, 
                                                FALSE, // remove is not allowed
                                                &NewAccountName );
                if (NT_SUCCESS(NtStatus))
                {

                    NtStatus = SampChangeAliasAccountName(
                                    AliasContext,
                                    &NewAccountName,
                                    &OldAccountName
                                    );

                    if (!NT_SUCCESS(NtStatus))
                    {
                        OldAccountName.Buffer = NULL;
                    }

                    AccountNameChanged = TRUE;
                }

                break;

            case SAMP_ALIAS_ADMIN_COMMENT:

                NtStatus = SampGetUnicodeStringFromAttrVal(
                                    i, rCallMap, TRUE,&AdminComment );

                if (NT_SUCCESS(NtStatus))
                {
                    NtStatus = SampSetUnicodeStringAttribute(
                                    AliasContext,
                                    SAMP_ALIAS_ADMIN_COMMENT,
                                    &AdminComment
                                    );
                }

                break;

            case SAMP_ALIAS_MEMBERS:

                //
                // Write alias member attribute
                // 
                NtStatus = SampWriteAliasMembers(AliasHandle,
                                                 pObject,
                                                 i,
                                                 rCallMap
                                                 );

                break;

            case SAMP_ALIAS_SID_HISTORY:

                // 
                // SampWriteSidHistory
                // 
                NtStatus = SampWriteSidHistory(
                                        AliasHandle,
                                        i,
                                        pObject,
                                        cCallMap,
                                        rCallMap
                                        );

                break;

            case SAMP_FIXED_ALIAS_TYPE:

                //
                // Get Group Type Value
                // 
                SampGetUlongFromAttrVal(i, rCallMap,
                                        FALSE,  // remove is not allowed
                                        &GroupType );

                NtStatus = SampWriteGroupType(AliasHandle, 
                                              GroupType,
                                              FALSE
                                              );

                break;

            default:

                ASSERT(FALSE && "Logic Error, invalide SAM attr type");
                break;

            }

            if (!NT_SUCCESS(NtStatus))
                break;
        }

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = SampDeReferenceContext(AliasContext, TRUE);
        }
        else
        {
            IgnoreStatus = SampDeReferenceContext(AliasContext, FALSE);
        }
    }

    //
    // audit account name change
    //
    // Note: GroupType, SidHistory, Members changes all have been audited
    //       separately.
    // 
    // a more generic audit event will be generated when processing notification 
    // list in SampNotifyReplicatedinChange()
    //

    if (NT_SUCCESS(NtStatus) && 
        AccountNameChanged && 
        SampDoAccountAuditing(AliasContext->DomainIndex) )
    {
        SampAuditAccountNameChange(AliasContext, &NewAccountName, &OldAccountName);
    }

    //
    // Let shutdown handling logic know that we are done
    // 

    SampDecrementActiveThreads();


    //
    // Cleanup Strings
    // 
    SampFreeUnicodeString( &OldAccountName );

    return( NtStatus );
}


NTSTATUS
SampDsSetInformationUser(
    IN SAMPR_HANDLE UserHandle,
    IN DSNAME       *pObject,
    IN ULONG        cCallMap,
    IN SAMP_CALL_MAPPING *rCallMap,
    IN SAMP_ATTRIBUTE_MAPPING *rSamAttributeMap 
    )
/*++
Routine Description:

    This routine is called by loopback client to set User object
    information.

Parameters:

    UserHandle - User Context
    
    pObject - Domain Object DS Name
    
    cCallMap - number of attributes 
    
    rCallMap - contains attribute blocks
    
    rSamAttributeMap - SAM attribute mapping table

Return Value:

    STATUS_SUCCESS  success
    other value - failed

--*/

{
    NTSTATUS            NtStatus = STATUS_SUCCESS, IgnoreStatus;
    PSAMP_OBJECT        UserContext = (PSAMP_OBJECT)UserHandle;
    SAMP_OBJECT_TYPE    FoundType;
    ACCESS_MASK         DesiredAccess = 0;
    SAMP_V1_0A_FIXED_LENGTH_USER V1aFixed;
    PSAMP_DEFINED_DOMAINS   Domain;
    ULONG               DomainIndex, 
                        UserAccountControlFlag = 0,
                        UserAccountControl = 0,
                        OldUserAccountControl = 0,
                        PrimaryGroupId = 0,
                        OldPrimaryGroupId = 0,
                        UserRid = 0, 
                        i;
    UNICODE_STRING      Workstations,
                        ApiList,
                        FullName,
                        NewAccountName,
                        OldAccountName = {0, 0, NULL},
                        AdminComment,
                        PasswordInQuote,
                        AccountName = {0, 0, NULL},
                        NewPassword;
    LONG                CountryCode,
                        CodePage;
    BOOLEAN             PasswordExpired = FALSE, 
                        AccountControlChange = FALSE,
                        PrimaryGroupIdChange = FALSE,
                        AccountGettingMorphed = FALSE,
                        KeepOldPrimaryGroupMembership = FALSE,
                        SystemChangesPrimaryGroupId = FALSE,
                        AccountNameChanged = FALSE,
                        FreePassword = FALSE,
                        AccountUnlocked = FALSE;
    LOGON_HOURS         LogonHours;
    LARGE_INTEGER       TimeSupplied, 
                        AccountExpires,
                        LockoutTime;



    //
    // Initialize any data that we may free later
    //

    RtlZeroMemory(&NewPassword, sizeof(UNICODE_STRING));

    //
    // Increment the active thread count, so we will consider this
    // thread at shutdown time
    // 

    NtStatus = SampIncrementActiveThreads();
    if (!NT_SUCCESS(NtStatus))
    {
        return( NtStatus );
    }


    // 
    // Set the desired access based upon which attributes the caller
    // is trying to modify
    // 
    for ( i = 0; i< cCallMap; i++ )
    {
        if (!rCallMap[i].fSamWriteRequired || rCallMap[i].fIgnore)
        {
            continue;
        }
        
        switch (rSamAttributeMap[ rCallMap[i].iAttr ].SamAttributeType)
        {
        case SAMP_USER_ACCOUNT_NAME:
        case SAMP_USER_ADMIN_COMMENT:
        case SAMP_USER_WORKSTATIONS:
        case SAMP_USER_LOGON_HOURS:
        case SAMP_FIXED_USER_ACCOUNT_EXPIRES:

            DesiredAccess |= USER_WRITE_ACCOUNT;
            break;

        case SAMP_FIXED_USER_PRIMARY_GROUP_ID:

            PrimaryGroupIdChange = TRUE;
            DesiredAccess |= USER_WRITE_ACCOUNT;
            break;

        case SAMP_FIXED_USER_ACCOUNT_CONTROL:

            AccountControlChange = TRUE;
            DesiredAccess |= USER_WRITE_ACCOUNT;
            break;


        case SAMP_FIXED_USER_COUNTRY_CODE:
        case SAMP_FIXED_USER_CODEPAGE:

            DesiredAccess |= USER_WRITE_PREFERENCES;
            break;

        case SAMP_USER_UNICODE_PWD:
        case SAMP_FIXED_USER_PWD_LAST_SET:
        case SAMP_USER_PASSWORD:
            DesiredAccess |= USER_FORCE_PASSWORD_CHANGE;
            break;

        default:
            break; 
        }
    }

    //
    // Validate type of, and access to object
    // 

    NtStatus = SampLookupContext(UserContext,
                                 DesiredAccess,
                                 SampUserObjectType,
                                 &FoundType
                                 );

    if (!NT_SUCCESS(NtStatus))
    {
        goto CleanupBeforeReturn;
    }

    DomainIndex = UserContext->DomainIndex;
    Domain = &SampDefinedDomains[ DomainIndex ];

    //
    // Get the user's rid. This is used for notifying other
    // packages of a password change.
    //

    UserRid = UserContext->TypeBody.User.Rid;


    // 
    // Retrieve V1aFixed information
    // 

    NtStatus = SampRetrieveUserV1aFixed(UserContext,
                                        &V1aFixed
                                        );

    if (NT_SUCCESS(NtStatus))
    {
        //
        // Store away the old account control flags for cache update
        //

        OldUserAccountControl = V1aFixed.UserAccountControl;

        //
        // Store away the old Primary Group Id for detecting wether we need
        // to modify the user's membership
        //
        OldPrimaryGroupId = V1aFixed.PrimaryGroupId;
    }
    else
    {
        goto Error;
    }

    NtStatus = SampGetUnicodeStringAttribute(
                  UserContext,
                  SAMP_USER_ACCOUNT_NAME,
                  TRUE,    // Make copy
                  &AccountName
                  );    

    if (!NT_SUCCESS(NtStatus)) {
        goto Error;
    }

    for ( i = 0; i < cCallMap; i++ )
    {
        ATTR        *pAttr = NULL;

        if ( !rCallMap[i].fSamWriteRequired || rCallMap[i].fIgnore )
        {
            continue;
        }

        //
        // Get the attribute address
        // 

        pAttr = &(rCallMap[i].attr); 

        //
        // case on the attribute
        // 
        switch (rSamAttributeMap[ rCallMap[i].iAttr ].SamAttributeType)
        {
        case SAMP_USER_WORKSTATIONS:
            //
            // Get Unicode String attribute value 
            // 
            NtStatus = SampGetUnicodeStringFromAttrVal( 
                            i, rCallMap, TRUE, &Workstations );
            if (NT_SUCCESS(NtStatus))
            {

                NtStatus = SampConvertUiListToApiList(
                                    &Workstations,
                                    &ApiList,
                                    FALSE
                                    );

                if (NT_SUCCESS(NtStatus))
                {
                    NtStatus = SampSetUnicodeStringAttribute(
                                    UserContext,
                                    SAMP_USER_WORKSTATIONS,
                                    &ApiList
                                    );
                }
            }
            break;

        case SAMP_USER_ACCOUNT_NAME:

            NtStatus = SampGetUnicodeStringFromAttrVal(
                            i, rCallMap, FALSE, &NewAccountName);
            if (NT_SUCCESS(NtStatus))
            {

                NtStatus = SampChangeUserAccountName(
                                    UserContext,
                                    &NewAccountName,
                                    V1aFixed.UserAccountControl,
                                    &OldAccountName
                                    );

                if (NT_SUCCESS(NtStatus))
                {
                   AccountNameChanged = RtlCompareUnicodeString(&OldAccountName, 
                                                                &NewAccountName, 
                                                                TRUE 
                                                                ) == 1 ? TRUE:FALSE;
                }
                else 
                {
                    OldAccountName.Buffer = NULL;
                }
            }
            break;

        case SAMP_USER_ADMIN_COMMENT:

            NtStatus = SampGetUnicodeStringFromAttrVal(
                               i, rCallMap, TRUE, &AdminComment);
            if (NT_SUCCESS(NtStatus))
            {

                NtStatus = SampSetUnicodeStringAttribute(
                                    UserContext,
                                    SAMP_USER_ADMIN_COMMENT,
                                    &AdminComment
                                    );
            }
            break;

        case SAMP_USER_LOGON_HOURS:

            if ( (AT_CHOICE_REMOVE_ATT == rCallMap[i].choice) ||
                 (0 == pAttr->AttrVal.pAVal[0].valLen) )
            {
                LogonHours.UnitsPerWeek = 0;
                LogonHours.LogonHours = NULL;
            }
            else
            {
                LogonHours.UnitsPerWeek = 
                    (USHORT) (pAttr->AttrVal.pAVal[0].valLen * 8);
                LogonHours.LogonHours = 
                    (PUCHAR) pAttr->AttrVal.pAVal[0].pVal;
            }

            NtStatus = SampReplaceUserLogonHours(
                                    UserContext,
                                    &LogonHours
                                    );

            break;

        case SAMP_FIXED_USER_COUNTRY_CODE:

            if (AT_CHOICE_REPLACE_ATT == rCallMap[i].choice)
            {
                V1aFixed.CountryCode = 
                    * (USHORT *)pAttr->AttrVal.pAVal[0].pVal;
            }
            else
            {
                V1aFixed.CountryCode = 0;
            }

            NtStatus = SampReplaceUserV1aFixed(
                                UserContext,
                                &V1aFixed
                                );

            break;

        case SAMP_FIXED_USER_CODEPAGE:

            if (AT_CHOICE_REPLACE_ATT == rCallMap[i].choice)
            {
                V1aFixed.CodePage = 
                    * (USHORT *)pAttr->AttrVal.pAVal[0].pVal;
            }
            else
            {
                V1aFixed.CodePage = 0;
            }

            NtStatus = SampReplaceUserV1aFixed(
                                UserContext,
                                &V1aFixed
                                );

            break;

        case SAMP_FIXED_USER_PWD_LAST_SET:

            SampGetLargeIntegerFromAttrVal(i,rCallMap,FALSE,&TimeSupplied);

            NtStatus = SampValidateUserPwdLastSet(UserContext,
                                                  TimeSupplied,
                                                  &PasswordExpired
                                                  );
            //
            // If the PasswordExpired field is passed in,
            // Only update PasswordLastSet if the password is being
            // forced to expire or if the password is currently forced
            // to expire.
            //
            // Avoid setting the PasswordLastSet field to the current
            // time if it is already non-zero.  Otherwise, the field
            // will slowly creep forward each time this function is
            // called and the password will never expire.
            //
            if ( NT_SUCCESS(NtStatus) &&
                 (PasswordExpired ||
                  (SampHasNeverTime.QuadPart == V1aFixed.PasswordLastSet.QuadPart)) ) 
            {

                NtStatus = SampComputePasswordExpired(
                                PasswordExpired,
                                &V1aFixed.PasswordLastSet
                                );

                if (NT_SUCCESS(NtStatus))
                {
                    NtStatus = SampReplaceUserV1aFixed(
                                        UserContext,
                                        &V1aFixed
                                        );
                }
            }

            break;

        case SAMP_USER_UNICODE_PWD:

            // Get the clear text password to be set.

            NtStatus = SampGetNewUnicodePasswordFromAttrVal(i,rCallMap, &NewPassword);

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = SampDsSetPasswordUser(UserHandle,
                                                 &NewPassword
                                                 );
            }

            break;

        case SAMP_USER_PASSWORD:

            // User password is supported only when the behavior version is whistler

            if (SampDefinedDomains[UserContext->DomainIndex].BehaviorVersion 
                    < DS_BEHAVIOR_WHISTLER )
            {
                NtStatus = STATUS_NOT_SUPPORTED;
                break;
            }

            // Get the clear text password to be set.

            NtStatus = SampGetNewUTF8PasswordFromAttrVal(i,rCallMap, &NewPassword);

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = SampDsSetPasswordUser(UserHandle,
                                                 &NewPassword
                                                 );
                FreePassword = TRUE;
            }


            break;

        case SAMP_FIXED_USER_PRIMARY_GROUP_ID:

            SampGetUlongFromAttrVal(i,rCallMap,FALSE,&PrimaryGroupId);

            NtStatus = SampValidatePrimaryGroupId(UserContext,
                                                  V1aFixed,
                                                  PrimaryGroupId
                                                  );

            if (NT_SUCCESS(NtStatus) &&
                (PrimaryGroupId != V1aFixed.PrimaryGroupId) )  
            {
                KeepOldPrimaryGroupMembership = TRUE;
                V1aFixed.PrimaryGroupId = PrimaryGroupId;

                NtStatus = SampReplaceUserV1aFixed(
                                    UserContext,
                                    &V1aFixed
                                    );
            } 

            break;

        case SAMP_FIXED_USER_ACCOUNT_CONTROL:

            SampGetUlongFromAttrVal(i,rCallMap,FALSE,&UserAccountControlFlag);
            NtStatus = SampFlagsToAccountControl(
                                UserAccountControlFlag,
                                &UserAccountControl
                                );

            if (!PrimaryGroupIdChange)
            {
                SystemChangesPrimaryGroupId = TRUE;
            }

            NtStatus = SampSetUserAccountControl(
                                UserContext, 
                                UserAccountControl,
                                &V1aFixed,
                                SystemChangesPrimaryGroupId,
                                &AccountUnlocked,
                                &AccountGettingMorphed,
                                &KeepOldPrimaryGroupMembership
                                );

            if (NT_SUCCESS(NtStatus))
            {
                if (AccountGettingMorphed && 
                    (V1aFixed.UserAccountControl & USER_SERVER_TRUST_ACCOUNT)
                   )
                {
                    //
                    // in this case, system will automatically change the
                    // primary group id.
                    // 
                    SystemChangesPrimaryGroupId = TRUE;
                }

                NtStatus = SampReplaceUserV1aFixed(
                                    UserContext,
                                    &V1aFixed
                                    );
            }

            break;

        case SAMP_FIXED_USER_ACCOUNT_EXPIRES:

            SampGetLargeIntegerFromAttrVal(i,rCallMap,TRUE,&AccountExpires);

            NtStatus = SampValidateUserAccountExpires(
                                    UserContext,
                                    AccountExpires
                                    );

            if (NT_SUCCESS(NtStatus))
            {
                V1aFixed.AccountExpires = AccountExpires;

                NtStatus = SampReplaceUserV1aFixed(
                                    UserContext,
                                    &V1aFixed
                                    );
            }

            break;

        case SAMP_USER_SID_HISTORY:

            //
            // Modify SID History 
            // 

            NtStatus = SampWriteSidHistory(
                                    UserHandle,
                                    i,
                                    pObject,
                                    cCallMap,
                                    rCallMap
                                    );

            break;

        case SAMP_FIXED_USER_LOCKOUT_TIME:

            SampGetLargeIntegerFromAttrVal(i,rCallMap,FALSE,&LockoutTime);

            NtStatus = SampWriteLockoutTime(
                            UserContext,
                            &V1aFixed,
                            LockoutTime
                            );

            if (NT_SUCCESS(NtStatus)) {
                //
                // Via LDAP, the user can get unlocked out two ways:
                // either by setting a user account control or by directly
                // setting the lockoutTime to 0
                //
                ASSERT(LockoutTime.QuadPart == 0i64);
                AccountUnlocked = TRUE;
            }

            break;

        case SAMP_FIXED_USER_SITE_AFFINITY:
        case SAMP_FIXED_USER_CACHED_MEMBERSHIP_TIME_STAMP:
        case SAMP_FIXED_USER_CACHED_MEMBERSHIP:

            //
            // Modify no-gc logon attributes 
            // 

            NtStatus = SampWriteNoGCLogonAttrs(
                                    UserHandle,
                                    rSamAttributeMap[ rCallMap[i].iAttr ].SamAttributeType,
                                    i,
                                    pObject,
                                    cCallMap,
                                    rCallMap
                                    );

            break;

        default:
            ASSERT(FALSE && "Unknonw SAM attribute");
            ;
        }

        if (!NT_SUCCESS(NtStatus))
        {
            break;
        }
    }

    //
    // If the primary group Id has been changed then explicitly modify the
    // user's membership to include the old primary group as a member.
    // 

    if (NT_SUCCESS(NtStatus) &&
        (V1aFixed.PrimaryGroupId != OldPrimaryGroupId) 
       )
    {
        NtStatus = SampMaintainPrimaryGroupIdChange(
                                    UserContext,
                                    V1aFixed.PrimaryGroupId,
                                    OldPrimaryGroupId,
                                    KeepOldPrimaryGroupMembership
                                    );
    }


Error:

    if (NT_SUCCESS(NtStatus)
    && !(V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK)
    && (PasswordExpired ||  AccountUnlocked)) {

        //
        // We want these changes to travel fast within a site
        //
        UserContext->ReplicateUrgently = TRUE;

    }

    if (NT_SUCCESS(NtStatus)) {

        NtStatus = SampDeReferenceContext(UserContext, TRUE);
    }
    else {

        IgnoreStatus = SampDeReferenceContext(UserContext, FALSE);
    }

    //
    // Generate audit if necessary
    // 
    // a more generic audit event will be generated when processing notification 
    // list in SampNotifyReplicatedinChange()
    //

    if (NT_SUCCESS(NtStatus) &&
        SampDoAccountAuditing(UserContext->DomainIndex) )
    {
        //
        // audit account name change
        // 

        if (AccountNameChanged)
        {
            SampAuditAccountNameChange(UserContext, &NewAccountName, &OldAccountName);
        }

        //
        // account been disabled or enabled 
        // 

        if ((OldUserAccountControl & USER_ACCOUNT_DISABLED) !=
            (V1aFixed.UserAccountControl & USER_ACCOUNT_DISABLED))
        {

            SampAuditUserAccountControlChange(UserContext,
                                              V1aFixed.UserAccountControl,
                                              OldUserAccountControl,
                                              &AccountName
                                              );
        }
    }

    if ( NT_SUCCESS(NtStatus) ) {

        ULONG NotifyFlags = 0;

        //
        // If this ends up committing, tell the PDC about this originating
        // change
        //
        if (PasswordExpired) {
            NotifyFlags |= SAMP_PWD_NOTIFY_MANUAL_EXPIRE;
        }
        if (AccountUnlocked) {
            NotifyFlags |= SAMP_PWD_NOTIFY_UNLOCKED;
        }
        if (NewPassword.Length > 0) {
            NotifyFlags |= SAMP_PWD_NOTIFY_PWD_CHANGE;
        }
        if (NotifyFlags != 0) {

            if (V1aFixed.UserAccountControl & USER_MACHINE_ACCOUNT_MASK) {
                NotifyFlags |= SAMP_PWD_NOTIFY_MACHINE_ACCOUNT;
            }
    
            SampPasswordChangeNotify(NotifyFlags,
                                     AccountNameChanged ? &NewAccountName : &AccountName,
                                     UserRid,
                                    &NewPassword,
                                     TRUE  // loopback
                                    );
        }
    }


CleanupBeforeReturn:

    //
    // Let shutdown handling logic know that we are done
    // 

    SampDecrementActiveThreads();


    //
    // Cleanup 
    // 

    SampFreeUnicodeString( &OldAccountName );

    SampFreeUnicodeString( &AccountName );

    if (NewPassword.Length > 0) {
        RtlZeroMemory(NewPassword.Buffer, NewPassword.Length);
    }
    if (FreePassword) {
        LocalFree(NewPassword.Buffer);
    }

    return( NtStatus );
}


NTSTATUS
SamIDsSetObjectInformation(
    IN SAMPR_HANDLE ObjectHandle,
    IN DSNAME       *pObject,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG cCallMap,
    IN SAMP_CALL_MAPPING *rCallMap,
    IN SAMP_ATTRIBUTE_MAPPING *rSamAttributeMap 
    )
/*++

Routine Description:

    This routine takes a DS-Loopback attribute block (rCallMap), first 
    validates each Loopback attribute, then writes them to the Object 
    Context. After finishing all loopback attributes, commit the changes. 
    This function is a thin wrapper, the functionality are implemented in 
    the lower routine - SampDsSetInformation*  (* can be Domain, Group, 
    Alias or User).

Parameters:

    ObjectHandle - SAM Object Handle (context)      
    
    ObjectType - Indicate the SAM object type 
                    Domain
                    Group
                    Alias
                    User

    cCallMap - indicate how many items in the loopback attribute block
    
    rCallMap - pointer to the loopback attribute block (an array)                    

    rSamAttributeMap - pointer to the SAM attribute ID <==> DS ATT ID map

Return Value:

    STATUS_SUCCES
    or any error code

--*/

{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    ASSERT((SampDomainObjectType == ObjectType) ||
           (SampGroupObjectType == ObjectType) ||
           (SampAliasObjectType == ObjectType) ||
           (SampUserObjectType == ObjectType) );

    switch (ObjectType)
    {
    case SampDomainObjectType:

        NtStatus = SampDsSetInformationDomain(ObjectHandle,
                                              pObject,
                                              cCallMap,
                                              rCallMap,
                                              rSamAttributeMap
                                              );
        break;

    case SampGroupObjectType:

        NtStatus = SampDsSetInformationGroup(ObjectHandle,
                                             pObject,
                                             cCallMap,
                                             rCallMap,
                                             rSamAttributeMap
                                             );
        break;

    case SampAliasObjectType:

        NtStatus = SampDsSetInformationAlias(ObjectHandle,
                                             pObject,
                                             cCallMap,
                                             rCallMap,
                                             rSamAttributeMap
                                             );
        break;

    case SampUserObjectType:

        NtStatus = SampDsSetInformationUser(ObjectHandle,
                                            pObject,
                                            cCallMap,
                                            rCallMap,
                                            rSamAttributeMap
                                            );
        break;

    default:

        ASSERT(FALSE && "Invalid object type");

        NtStatus = STATUS_UNSUCCESSFUL;
        break;
    }

    return(NtStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\dsmember.h ===
/*++
Copyright (c) 1996 Microsoft Corporation

Module Name:

    dsmember.h

Abstract:

    Header File for SAM private API Routines that manipulate
    membership related things in the DS.

Author:
    MURLIS

Revision History

    7-2-96 Murlis Created

--*/

VOID
SampDsFreeCachedMembershipOperationsList(
    IN PSAMP_OBJECT Context
    );

NTSTATUS
SampDsFlushCachedMembershipOperationsList(
    IN PSAMP_OBJECT Context
    );

NTSTATUS
SampDsAddMembershipOperationToCache(
    IN PSAMP_OBJECT Context, 
    IN ULONG        OperationType,
    IN DSNAME       * MemberDsName
    );


NTSTATUS
SampDsGetAliasMembershipOfAccount(
    IN DSNAME*   DomainDn,
    IN DSNAME   *AccountDn,
    OUT PULONG MemberCount OPTIONAL,
    IN OUT PULONG BufferSize OPTIONAL,
    OUT PULONG Buffer OPTIONAL
    );

NTSTATUS
SampDsGetGroupMembershipOfAccount(
    IN DSNAME * DomainDn,
    IN DSNAME * AccountObject,
    OUT  PULONG MemberCount,
    OUT PGROUP_MEMBERSHIP *Membership OPTIONAL
    );


NTSTATUS
SampDsAddMembershipAttribute(
    IN DSNAME * GroupObjectName,
    IN SAMP_OBJECT_TYPE SamObjectType,
    IN DSNAME * MemberName
    );

NTSTATUS
SampDsAddMultipleMembershipAttribute(
    IN DSNAME*          GroupObjectName,
    IN SAMP_OBJECT_TYPE SamObjectType,
    IN DWORD            Flags,
    IN DWORD            MemberCount,
    IN DSNAME*          MemberName[]
    );

NTSTATUS
SampDsRemoveMembershipAttribute(
    IN DSNAME * GroupObjectName,
    IN SAMP_OBJECT_TYPE SamObjectType,
    IN DSNAME * MemberName
    );

NTSTATUS
SampDsGetGroupMembershipList(
    IN DSNAME * DomainObject,
    IN DSNAME * GroupName,
    IN ULONG  GroupRid,
    IN PULONG *Members OPTIONAL,
    IN PULONG MemberCount
    );

NTSTATUS
SampDsGetAliasMembershipList(
    IN DSNAME *AliasName,
    IN PULONG MemberCount,
    IN PSID   **Members OPTIONAL
    );


NTSTATUS
SampDsGetReverseMemberships(
   DSNAME * pObjName,
   ULONG    Flags,
   ULONG    *pcSid,
   PSID     **prpSids
   );

NTSTATUS
SampDsGetPrimaryGroupMembers(
    DSNAME * DomainObject,
    ULONG   GroupRid,
    PULONG  PrimaryMemberCount,
    PULONG  *PrimaryMembers
    );


NTSTATUS
SampDsResolveSidsWorker(
    IN  PSID    * rgSids,
    IN  ULONG   cSids,
    IN  PSID    *rgDomainSids,
    IN  ULONG   cDomainSids,
    IN  PSID    *rgEnterpriseSids,
    IN  ULONG   cEnterpriseSids,
    IN  ULONG   Flags,
    OUT DSNAME  ***rgDsNames
    );

NTSTATUS
SampDsResolveSidsForDsUpgrade(
    IN  PSID    DomainSid,
    IN  PSID    * rgSids,
    IN  ULONG   cSids,
    IN  ULONG   Flags,
    OUT DSNAME  ***rgDsNames
    );


//
// Flags for Resolve Sids
//

#define RESOLVE_SIDS_ADD_FORIEGN_SECURITY_PRINCIPAL 0x1 
                  // -- Automatically Adds the foreign 
                  //    domain security principal to the DS.

#define RESOLVE_SIDS_FAIL_WELLKNOWN_SIDS            0x2
                  // -- Fails the call if well known Sids 
                  //    are present in the array
        
#define RESOLVE_SIDS_VALIDATE_AGAINST_GC            0x4 
                  // -- Goes to the G.C if required

#define RESOLVE_SIDS_SID_ONLY_NAMES_OK              0x8
                 // Constructs a Sid Only Name, 
                 // Useful where it is appropriate to use SID based positioning
                 // in the DS. 

#define RESOLVE_SIDS_SID_ONLY_DOMAIN_SIDS_OK       0x10
                 // Constructs a Sid only name, if the SID is from the hosted
                 // domain. This is used by upgrader logic to speed up SID
                 // lookups upon a upgrade. 

#define RESOLVE_SIDS_FAIL_BUILTIN_DOMAIN_SIDS      0x20
                 // Fails call if SIDs like "Administrators" are present
                 // in the array


NTSTATUS
SampDsGetSensitiveSidList(
    IN DSNAME *DomainObjectName,
    IN PULONG pcSensSids,
    IN PSID   **pSensSids
    );

NTSTATUS
SampDsExamineSid(
    IN PSID Sid,
    OUT BOOLEAN * WellKnownSid,
    OUT BOOLEAN * BuiltinDomainSid,
    OUT BOOLEAN * LocalSid,
    OUT BOOLEAN * ForeignSid,
    OUT BOOLEAN * EnterpriseSid
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\dslayer.c ===
/*++

Copyright (C) 1996 Microsoft Corporation

Module Name:

    dslayer.c

Abstract:

    Contains SAM Private API Routines to access the DS
    These provide a simplified API, and hide most of the
    underlying complexity to set up the parameters to a DS call
    and parse the resulting result.

Author:
    MURLIS

Revision History

    5-14-96   Murlis Created
    08-07-96  ColinBr Adjusted for RFC1779 naming change
    04-13-98  Murlis/Wlees Mark well known user objects as critical for
              installation
--*/

#include <winerror.h>
#include <stdlib.h>
#include <samsrvp.h>
#include <ntdsa.h>
#include <dslayer.h>
#include <sdconvrt.h>
#include <mappings.h>
#include <objids.h>
#include <filtypes.h>
#include <dsdsply.h>
#include <fileno.h>
#include <dsconfig.h>
#include <mdlocal.h>
#include <malloc.h>
#include <errno.h>
#include <mdcodes.h>

//
//  Define FILENO for SAM
//


#define FILENO FILENO_SAM

//++
//++
//++   IMPORTANT NOTE REGARDING SID's and RID's
//++
//++   The DS can choose to either store the entire SID's or only
//++   the Rid's for account objects. In case Entire SID's are stored
//++   the DS layer handles the Mapping between the attribute type and
//++   and value of SID and those of Rid for account objects. This is
//++   done within SampDsToSamAttrBlock and SampSamToDsAttrBlock.
//++
//++
//++   Irrespective of which way we go the Rid and Sid are both
//++   attributes defined in the schema.
//++
//++   If we go the way the of storing Sid's then the DS functions
//++   should call the Convert AttrBlock functions using the MAP_SID_RID
//++   conversion Flag, and Lookup Object By Rid, should actually use
//++   the Sid Attribute.
//++
//++


//
// Forward declarations of Private Samp Routines used in this file only
//

NTSTATUS
SampDsSetNewSidAttribute(
    IN PSID DomainSid,
    IN ULONG ConversionFlags,
    IN ATTR *RidAttr,
    IN OUT ATTR *SidAttr,
    OUT BOOLEAN *WellKnownAccount
    );

NTSTATUS
SampDsCopyAttributeValue(
    IN ATTR * Src,
    IN OUT ATTR * Dst
    );

NTSTATUS
SampEscapeAccountName(
    IN PUNICODE_STRING AccountName,
    IN OUT PUNICODE_STRING EscapedAccountName
    );

VOID
SampDsComputeObjectClassAndAccountType(
    SAMP_OBJECT_TYPE ObjectType,
    ULONG            *SamAccountControl, OPTIONAL
    ULONG            Flags,
    PULONG           DsClass,
    PULONG           SamAccountType,
    BOOLEAN          *SamAccountTypePresent,
    PULONG           GroupType,
    BOOLEAN          *GroupAccountTypePresent,
    BOOLEAN          *DcAccount
    );

VOID
SampDsAccountTypeFromUserAccountControl(
    ULONG   UserAccountControl,
    PULONG  SamAccountType
    );

ULONG
Ownstrlen(
    CHAR * Sz
   );

BOOLEAN
SampDefaultContainerExists(
    IN ULONG AccountControl
    );

VOID
BuildStdCommArg(
    IN OUT COMMARG * pCommArg
    )
/*++

  Routine Description:

    Fills a COMMARG structue with the standard set of options

  Arguments:
    pCommArg - Pointer to the COMMARG structure

  Return Values:
    None

--*/
{
    /* Get the default values... */
    InitCommarg(pCommArg);

    /* ...and override some of them */
    pCommArg->Svccntl.fUnicodeSupport = TRUE;
    pCommArg->Svccntl.DerefAliasFlag = DA_NEVER;
    pCommArg->ulSizeLimit = SAMP_DS_SIZE_LIMIT;
    pCommArg->Svccntl.localScope = TRUE;
    pCommArg->fFindSidWithinNc = TRUE;
}



NTSTATUS
SampDsInitialize(
    BOOL fSamLoopback)

/*++

Routine Description:

   Initializes the DS system
   starts up DS.

Arguments:

   fSamLoopback - indicates whether or not DSA.DLL should loop security
        principal calls back through SAM.

Return Values:
        Any values from DsInitialize
--*/
{
    NTSTATUS    Status;
    ULONG       DsInitFlags = 0;

    SAMTRACE("SampDsInitialize");

    ASSERT(SampDsInitialized==FALSE);

    if ( fSamLoopback )
    {
        DsInitFlags |= DSINIT_SAMLOOP_BACK;
    }

    // Start up the DS
    Status = DsInitialize( DsInitFlags ,NULL, NULL );


    // This global variable indicates to SAM routines that
    // the DS initialized.  This routine is called during startup
    // so there should only one thread that ever calls this routine
    // The above assert assures that this function is only called
    // when the the ds has not been started or has been uninitialized
    // in the case of installation.
    if (NT_SUCCESS(Status)) {

        SampDsInitialized = TRUE;

    }
    else
    {
        //
        // In the case of DS failure, and returned us meaningless
        // status code, change it to STATUS_DS_CANT_START
        //
        if (STATUS_UNSUCCESSFUL == Status)
        {
            Status = STATUS_DS_CANT_START;
        }

        //
        // Set the Flag to TRUE, so that later on (in SamIInitialize),
        // we will display the matching error message, which would
        // correctly describe which part is wrong.
        //
        SampDsInitializationFailed = TRUE;
    }

    return Status;
}

NTSTATUS
SampDsUninitialize()

/*++

Routine Description

   Initiates a clean shut down of the DS

Arguments:
                None
Return codes:
                Any returned by DSUninitialize

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    SAMTRACE("SampDsUninitialize");

    if (SampDsInitialized)
    {
        Status = DsUninitialize( FALSE );  // do the full shutdown

        SampDsInitialized = FALSE;
    }

    return Status;
}


NTSTATUS
SampDoImplicitTransactionStart(
        SAMP_DS_TRANSACTION_CONTROL LocalTransactionType
        )
/*++

  Routine Description

    This routine does the logic of implict transaction start.


  Parameters

    LocalTransactionType -- The transaction type required by the immediate caller

  Return Values

     Any errors returned by SampMaybeBeginDsTransaction

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    //
    // We follow the following rules while beginning a transaction implicitly
    //
    // 1. If caller owns the sam lock, then we begin a transaction described in
    //    the global variable SampDsTransactionType. AcquireReadLock will set
    //    TransactionRead and AcquireWriteLock will set TransactionWrite. This
    //    will take care of cases where we want to write, but start by reading.
    //
    // 2. If caller does not owm the sam lock then begin a transaction of the
    //    local transaction type. The caller then has the responsiblity of
    //    either starting with a call that will ensure the correct transaction
    //    type, or explicitly begin a transaction of the correct transaction
    //    type.
    //

    if (SampCurrentThreadOwnsLock())
    {

        //
        // If we are holding the Sam lock
        //

        NtStatus = SampMaybeBeginDsTransaction(SampDsTransactionType);
    }
    else
    {
        NtStatus = SampMaybeBeginDsTransaction(LocalTransactionType);
    }

    return NtStatus;
}


NTSTATUS
SampDsRead(
    IN DSNAME * Object,
    IN ULONG    Flags,
    IN  SAMP_OBJECT_TYPE ObjectType,
    IN ATTRBLOCK * AttributesToRead,
    OUT ATTRBLOCK * AttributeValues
)

/*++

Routine Description:

 Read attributes of an object from the DS

Argumants:
        Object                          -- Pointer to Dist Name, which sepcifies object to read
        Flags                           -- To control operation of routine
        ObjectType              -- Specifies the type of the object
        AttributesToRead        -- Specfies the attributes to read
        AttributeValues         -- Returned value of the attributes

  Return Values:

    STATUS_SUCCESS on successful completion
    DS return codes mapped to NT_STATUS as in SampMapDSErrorToNTStatus

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ENTINFSEL   EntInf;
    READARG     ReadArg;
    COMMARG     *pCommArg;
    ULONG       RetValue;
    READRES     * pReadRes=NULL;
    ATTRBLOCK   *AttrBlockForDs, * ConvertedAttrBlock;

    SAMTRACE("SampDsRead");

    //
    // Asserts and parameter validation
    //

    ASSERT(Object!=NULL);
    ASSERT(AttributesToRead!=NULL);
    ASSERT(AttributeValues != NULL);
    ASSERT(AttributesToRead->attrCount > 0);

    //
    // Perform lazy thread and transaction initialization.
    //

    Status = SampDoImplicitTransactionStart(TransactionRead);

    if (Status!= STATUS_SUCCESS)
        goto Error;

    //
    // Translate the attribute types in Attrblock to map between
    // SAM and DS attributes.
    //

    //
    // First allocate space in stack for the Attrblock to be passed
    // down into the DS
    //

    SAMP_ALLOCA(EntInf.AttrTypBlock.pAttr,AttributesToRead->attrCount*sizeof(ATTR));

    if (NULL==EntInf.AttrTypBlock.pAttr)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    Status = SampSamToDsAttrBlock(
                ObjectType,                     // Object Type
                AttributesToRead,               // Attributes To Convert
                ( MAP_RID_TO_SID
                  | IGNORE_GROUP_UNUSED_ATTR ), // Conversion Flags
                NULL,                           // Domain Sid
                &(EntInf.AttrTypBlock)
                );

    if (!NT_SUCCESS(Status))
    {
        goto Error;
    }

    //
    // Setup up the ENTINFSEL structure
    //

    EntInf.attSel = EN_ATTSET_LIST;
    //EntInf.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EntInf.infoTypes = EN_INFOTYPES_SHORTNAMES;

    //
    // init ReadArg
    //
    RtlZeroMemory(&ReadArg, sizeof(READARG));


    //
    // Build the commarg structure
    //

    pCommArg = &(ReadArg.CommArg);
    BuildStdCommArg(pCommArg);

    if (Flags & SAM_ALLOW_REORDER)
    {
        pCommArg->Svccntl.fMaintainSelOrder = FALSE;
        pCommArg->Svccntl.fDontOptimizeSel = FALSE;
    }

    //
    // Setup the Read Arg Structure
    //

    ReadArg.pObject = Object;
    ReadArg.pSel    = & EntInf;

    //
    // Make the DS call
    //

    SAMTRACE_DS("DirRead");

    RetValue = DirRead(& ReadArg, & pReadRes);

    SAMTRACE_RETURN_CODE_DS(RetValue);

    //
    // Map the RetValue to a NT Status code
    //

    if (NULL==pReadRes)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        Status = SampMapDsErrorToNTStatus(RetValue,&pReadRes->CommRes);
    }

    if (Status!= STATUS_SUCCESS)
        goto Error;

    //
    // Translate attribute types back from DS to SAM
    //

    Status = SampDsToSamAttrBlock(
        ObjectType,
        &(pReadRes->entry.AttrBlock),
        ( MAP_SID_TO_RID ),
        AttributeValues
        );

    if (Status != STATUS_SUCCESS)
        goto Error;



Error:

    //
    // Clear any errors
    //

    SampClearErrors();

    //
    // Turn the fDSA flag back on as in loopback cases this can get reset
    //
    SampSetDsa(TRUE);


    return Status;
}


NTSTATUS
SampDsSetAttributes(
    IN DSNAME * Object,
    IN ULONG  Flags,
    IN ULONG  Operation,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ATTRBLOCK * AttributeList
    )
{
    ULONG *Operations;
    ULONG i;

    SAMP_ALLOCA(Operations,AttributeList->attrCount*sizeof(ULONG));
    if (NULL==Operations)
    {
       return(STATUS_INSUFFICIENT_RESOURCES);
    }
    for (i = 0; i < AttributeList->attrCount; i++) {
        Operations[i] = Operation;
    }

    return SampDsSetAttributesEx(Object,
                                 Flags,
                                 Operations,
                                 ObjectType,
                                 AttributeList);


}

NTSTATUS
SampDsSetAttributesEx(
    IN DSNAME * Object,
    IN ULONG  Flags,
    IN ULONG  *Operations,
    IN  SAMP_OBJECT_TYPE ObjectType,
    IN ATTRBLOCK * AttributeList
)

/*++

Routine Description:

  Set an Object's attributes

Arguments:

      Object         Specifies the DS Object

      Flags          Controls Operation of Routine

                        ALREADY_MAPPED_ATTRIBUTE_TYPES

                         - Attribute types have been mapped from SAM attribute
                           to DS attribute already. so not not map again.

      Operation      Specifies operation to perform

                     Valid Values of Operation are

                        REPLACE_ATT
                        ADD_ATT
                        REMOVE_ATT
                        ADD_VALUE
                        REMOVE_VALUE

      ObjectType     SAM Object Type for attribute Type conversion

      AttributeList  Specifies the attributes to Modify

Return Values:

      STATUS_SUCCESS on succesful completion
      STATUS_NO_MEMORY - if failed to allocate memory
      DS return codes mapped to NT_STATUS as in SampMapDSErrorToNTStatus


--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ATTRMODLIST * AttrModList = NULL;
    MODIFYARG   ModifyArg;
    MODIFYRES   *pModifyRes = NULL;
    ATTRMODLIST * CurrentMod, * NextMod, *LastMod;
    ULONG       Index;
    COMMARG     *pCommArg;
    ULONG       RetValue;
    UCHAR       Choice;
    ULONG       ModCount = 0;


    SAMTRACE("SampDsSetAttributes");

    //
    // Asserts and parameter validation
    //

    ASSERT(Object!=NULL);
    ASSERT(AttributeList != NULL);
    ASSERT(AttributeList->attrCount > 0);

    // Perform lazy thread and transaction initialization.
    Status = SampDoImplicitTransactionStart(TransactionWrite);

    if (Status!= STATUS_SUCCESS)
        goto Error;


    //
    // Allocate enough memory in AttrModList to hold the contents of
    // AttrBlock. First such structure is specified in ModifyArg itself.
    // One additonal structure is allocated so that we can add SAM account
    // type if necessary
    //

    AttrModList = (ATTRMODLIST *)  DSAlloc(
                                        (AttributeList->attrCount-1+2)
                                        // -1 because first structure is in ModifyArg itself
                                        // +1 in case we need to add Sam Account type
                                        // +1 in case we need to add is critical system object
                                        * sizeof(ATTRMODLIST)
                                        );
    if (AttrModList==NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto Error;

    }

    //
    // Initialize the Linked Attribute Modification List
    // required for the DS call
    //

    memset( &ModifyArg, 0, sizeof( ModifyArg ) );
    CurrentMod = &(ModifyArg.FirstMod);
    NextMod    = AttrModList;
    LastMod    = NULL;

    for (Index = 0; Index < AttributeList->attrCount; Index++)
    {
        ULONG DsAttrTyp;

        //
        // Setup our Choice
        //
    
        if (Operations[Index] == ADD_VALUE)
            Choice = AT_CHOICE_ADD_VALUES;
    
        else if (Operations[Index] == REMOVE_VALUE)
            Choice = AT_CHOICE_REMOVE_VALUES;
    
        else if (Operations[Index] == REMOVE_ATT)
            Choice = AT_CHOICE_REMOVE_ATT;
    
        else if (Operations[Index] == REPLACE_ATT)
            Choice = AT_CHOICE_REPLACE_ATT;
    
        else
            Choice = AT_CHOICE_REPLACE_ATT;
    
        //
        // MAP the attribute Type from SAM to DS if requested.
        //
        if (Flags & ALREADY_MAPPED_ATTRIBUTE_TYPES)
        {
            DsAttrTyp = AttributeList->pAttr[Index].attrTyp;
        }
        else
        {
            DsAttrTyp = SampDsAttrFromSamAttr(
                            ObjectType,
                            AttributeList->pAttr[Index].attrTyp
                            );
        }

        //
        // Skip over any Rid Attribute
        //
        if (DsAttrTyp == SampDsAttrFromSamAttr(
                            SampUnknownObjectType,
                            SAMP_UNKNOWN_OBJECTRID
                           ))
        {

            //
            // We will not allow modifications of Rid's
            //

            continue;
        }


        //
        // Setup the Choice
        //

        CurrentMod->choice = Choice;

        //
        // Copy over the ATTR Type
        //
        CurrentMod->AttrInf.attrTyp = DsAttrTyp;

        //
        // Copy Over the Attribute Value
        //

        Status = SampDsCopyAttributeValue(
                     &(AttributeList->pAttr[Index]),
                     &(CurrentMod->AttrInf)
                     );

        if (Status != STATUS_SUCCESS)
            goto Error;

        //
        // If the current attribute is User account control
        // and if we are replacing the attribute then
        // translate the user account control field to UF_Flags and
        // recompute the SAM account type property.
        //

        if (
               (SampUserObjectType==ObjectType)
            && (DsAttrTyp == SampDsAttrFromSamAttr(
                                SampUserObjectType,
                            SAMP_FIXED_USER_ACCOUNT_CONTROL))
            && (REPLACE_ATT==Operations[Index])
           )
        {
            ULONG   UserAccountControl = *((ULONG *)CurrentMod->AttrInf.AttrVal.pAVal->pVal);
            ULONG   SamAccountType;
            ATTR    SamAccountTypeAttr;
            ATTRVAL SamAccountTypeVal = {sizeof(ULONG),(UCHAR*) &SamAccountType};

            //
            // Translate User Account Control to UF_ Flags
            //

            *((ULONG *)CurrentMod->AttrInf.AttrVal.pAVal->pVal) =
                        SampAccountControlToFlags(UserAccountControl);

            //
            // Get the SamAccount Type Value
            //

            SampDsAccountTypeFromUserAccountControl(
                    UserAccountControl,
                    &SamAccountType
                    );

            SamAccountTypeAttr.attrTyp =  SampDsAttrFromSamAttr(
                                                SampUnknownObjectType,
                                                SAMP_UNKNOWN_ACCOUNT_TYPE
                                                );
            SamAccountTypeAttr.AttrVal.valCount = 1;
            SamAccountTypeAttr.AttrVal.pAVal = &SamAccountTypeVal;


            //
            // Get the next Attrinf Block
            //

            LastMod = CurrentMod;
            CurrentMod->pNextMod = NextMod;
            CurrentMod = CurrentMod->pNextMod;
            NextMod    = NextMod +1 ;
            ModCount++;

            //
            // Set it up to hold the SAM Account type property
            //

            CurrentMod->choice = Choice;
            CurrentMod->AttrInf.attrTyp = SamAccountTypeAttr.attrTyp;
            Status = SampDsCopyAttributeValue(
                     &SamAccountTypeAttr,
                     &(CurrentMod->AttrInf)
                     );

            if (Status != STATUS_SUCCESS)
                goto Error;

            // If changing the machine account type, update criticality
            if( UserAccountControl & USER_MACHINE_ACCOUNT_MASK ) {
                ULONG   IsCrit;
                ATTR    IsCritAttr;
                ATTRVAL IsCritVal = {sizeof(ULONG),(UCHAR*) &IsCrit};

                // Only server and interdomain trust accounts should be crit
                if ( (UserAccountControl & USER_SERVER_TRUST_ACCOUNT) ||
                     (UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT) ) {
                    IsCrit = 1;
                } else {
                    IsCrit = 0;
                }

                IsCritAttr.attrTyp = ATT_IS_CRITICAL_SYSTEM_OBJECT;
                IsCritAttr.AttrVal.valCount = 1;
                IsCritAttr.AttrVal.pAVal = &IsCritVal;

                //
                // Get the next Attrinf Block
                //

                LastMod = CurrentMod;
                CurrentMod->pNextMod = NextMod;
                CurrentMod = CurrentMod->pNextMod;
                NextMod    = NextMod +1 ;
                ModCount++;

                //
                // Set it up to hold the is critical property
                //

                CurrentMod->choice = Choice;
                CurrentMod->AttrInf.attrTyp = IsCritAttr.attrTyp;
                Status = SampDsCopyAttributeValue(
                    &IsCritAttr,
                    &(CurrentMod->AttrInf)
                    );

                if (Status != STATUS_SUCCESS)
                    goto Error;
            }
        }

        //
        // Setup the chaining. AttrModList is suposed to be a linked list, though
        // for effciency purposes we allocated a single block
        //

        LastMod = CurrentMod;
        CurrentMod->pNextMod = NextMod;
        CurrentMod = CurrentMod->pNextMod;
        NextMod    = NextMod +1 ;

        //
        //  Keep track of Count of Modifications we pass to DS, as we skip over RId etc
        //
        ModCount++;

    }

    //
    // Initialize the last pointer in the chain to NULL
    //

    if (LastMod)
        LastMod->pNextMod = NULL;
    else

    {
        //
        // This Means we have nothing to modify
        //

        Status = STATUS_SUCCESS;
        goto Error;
    }



    //
    // Setup the Common Args structure
    //

    pCommArg = &(ModifyArg.CommArg);
    BuildStdCommArg(pCommArg);

    //
    // Enable Lazy Commit if caller requested it.
    //

    if (Flags & SAM_LAZY_COMMIT)
        pCommArg->fLazyCommit = TRUE;

    //
    // Urgently replicate the change if necessary
    //
    if ( Flags & SAM_URGENT_REPLICATION )
    {
        pCommArg->Svccntl.fUrgentReplication = TRUE;
    }
    //
    // Setup the MODIFY ARG structure
    //

    ModifyArg.pObject = Object;
    ModifyArg.count = (USHORT) ModCount;

    //
    // Make the DS call
    //

    SAMTRACE_DS("DirModifyEntry\n");

    RetValue = DirModifyEntry(&ModifyArg, &pModifyRes);

    SAMTRACE_RETURN_CODE_DS(RetValue);

    //
    // Map the return code to an NT status
    //

    if (NULL==pModifyRes)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        Status = SampMapDsErrorToNTStatus(RetValue,&pModifyRes->CommRes);
    }

Error:

    //
    // Clear any errors
    //

    SampClearErrors();

    //
    // Turn the fDSA flag back on as in loopback cases this can get reset
    //

    SampSetDsa(TRUE);


    return Status;
}

NTSTATUS
SampDsCreateInitialAccountObject(
    IN   PSAMP_OBJECT    Object,
    IN   ULONG           Flags,
    IN   ULONG           AccountRid,
    IN   PUNICODE_STRING AccountName,
    IN   PSID            CreatorSid OPTIONAL,
    IN   PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,
    IN   PULONG          UserAccountControl OPTIONAL,
    IN   PULONG          GroupType OPTIONAL
    )
/*++

  Routine Description:

    Creates an account object in the DS having only the Sid,
    Account Name , and a few special attributes like, security
    descriptor, User account control Field etc

  Arguments:

    Object                  the object of the account being created
    Flags                   Controls the operation of the routine
                            Currently the Valid Flags are

                            SUPPRESS_GROUP_TYPE_DEFAULTING
                                This flag will suppress the
                                defaulting of group type. Normally
                                Account creation will default the
                                group type field depending upon the
                                SAM object type

    AccountRid              the rid of the account
    AccountName             Name of the Account

    CreatorSid              Pointer to SID the value of ms-ds-CreatorSid
                            attribute

    SecurityDescriptor      SecurityDescriptor on the account
    UserAccountControl      The User Account Control Field
    GroupType               Group Type field, in case the caller passed
                            this in.

  Return values:

    STATUS_SUCCESS on successful completion

--*/
{
    NTSTATUS NtStatus;

    ATTRBLOCK AttrBlock;
    ATTR      Attr[7];
    ATTRVAL   AttrValRid, AttrValAccountName, AttrValSecurityDescriptor,
              AttrValUserAccountControl, AttrValLocalPolicyFlags,
              AttrValGroupType, AttrValCreatorSid;
    ULONG     SecurityDescriptorAttrTyp;
    ULONG     GroupTypeAttrTyp = SAMP_FIXED_GROUP_TYPE;
    ULONG     LocalPolicyFlags;
    BOOLEAN   BuiltinDomain = IsBuiltinDomain(Object->DomainIndex);


    SAMTRACE("SampDsCreateInitialAccountObject");

    ASSERT(Object);
    ASSERT(AccountName);

    ASSERT((Flags & (~(SUPPRESS_GROUP_TYPE_DEFAULTING)))==0);

    // This must have been set
    ASSERT(Object->ObjectNameInDs);

    ASSERT(Object->ObjectType == SampUserObjectType  ||
           Object->ObjectType == SampGroupObjectType ||
           Object->ObjectType == SampAliasObjectType);


    //
    // We must create the attr's required by the DS to create an object
    // namely, we must set the rid.
    //
    AttrBlock.attrCount = 2;
    AttrBlock.pAttr = &(Attr[0]);

    switch ( Object->ObjectType ) {
        case SampUserObjectType:
            Attr[0].attrTyp  = SAMP_FIXED_USER_USERID;
            Attr[1].attrTyp  = SAMP_USER_ACCOUNT_NAME;
            SecurityDescriptorAttrTyp = SAMP_USER_SECURITY_DESCRIPTOR;
            break;
        case SampGroupObjectType:
            Attr[0].attrTyp  = SAMP_FIXED_GROUP_RID;
            Attr[1].attrTyp  = SAMP_GROUP_NAME;
            SecurityDescriptorAttrTyp = SAMP_GROUP_SECURITY_DESCRIPTOR;
            GroupTypeAttrTyp = SAMP_FIXED_GROUP_TYPE;
            ASSERT(!ARGUMENT_PRESENT(UserAccountControl));
            ASSERT(ARGUMENT_PRESENT(GroupType));
            break;
        case SampAliasObjectType:
            Attr[0].attrTyp  = SAMP_FIXED_ALIAS_RID;
            Attr[1].attrTyp  = SAMP_ALIAS_NAME;
            SecurityDescriptorAttrTyp = SAMP_ALIAS_SECURITY_DESCRIPTOR;
            GroupTypeAttrTyp = SAMP_FIXED_ALIAS_TYPE;
            ASSERT(!ARGUMENT_PRESENT(UserAccountControl));
            ASSERT(ARGUMENT_PRESENT(GroupType));
            break;
        default:
            ASSERT(FALSE && "Not Account Object Type");
    }

    // Set Rid
    AttrValRid.valLen = sizeof(ULONG);
    AttrValRid.pVal = (PVOID) &AccountRid;
    Attr[0].AttrVal.valCount = 1;
    Attr[0].AttrVal.pAVal = &AttrValRid;

    // Set Account Name
    AttrValAccountName.valLen = AccountName->Length;
    AttrValAccountName.pVal = (PVOID) AccountName->Buffer;
    Attr[1].AttrVal.valCount = 1;
    Attr[1].AttrVal.pAVal = &AttrValAccountName;

    // Set Security Descriptor
    if (ARGUMENT_PRESENT(SecurityDescriptor))
    {
        AttrValSecurityDescriptor.valLen = RtlLengthSecurityDescriptor(SecurityDescriptor);
        AttrValSecurityDescriptor.pVal = (UCHAR *) SecurityDescriptor;
        Attr[AttrBlock.attrCount].attrTyp = SecurityDescriptorAttrTyp;
        Attr[AttrBlock.attrCount].AttrVal.valCount = 1;
        Attr[AttrBlock.attrCount].AttrVal.pAVal = &AttrValSecurityDescriptor;
        AttrBlock.attrCount++;
    }

    // Set User Account Control
    if (ARGUMENT_PRESENT(UserAccountControl))
    {
        ASSERT(Object->ObjectType==SampUserObjectType);

        AttrValUserAccountControl.valLen = sizeof(ULONG);
        AttrValUserAccountControl.pVal = (UCHAR *) UserAccountControl;
        Attr[AttrBlock.attrCount].attrTyp = SAMP_FIXED_USER_ACCOUNT_CONTROL;
        Attr[AttrBlock.attrCount].AttrVal.valCount =1;
        Attr[AttrBlock.attrCount].AttrVal.pAVal = &AttrValUserAccountControl;
        AttrBlock.attrCount++;

        // For Machine objects also set the local policy flags
        if ((USER_WORKSTATION_TRUST_ACCOUNT & *UserAccountControl)
            || (USER_SERVER_TRUST_ACCOUNT & *UserAccountControl))
        {
            AttrValLocalPolicyFlags.valLen = sizeof(ULONG);
            LocalPolicyFlags = 0;
            AttrValLocalPolicyFlags.pVal = (UCHAR *) &LocalPolicyFlags;
            Attr[AttrBlock.attrCount].attrTyp = SAMP_FIXED_USER_LOCAL_POLICY_FLAGS;
            Attr[AttrBlock.attrCount].AttrVal.valCount=1;
            Attr[AttrBlock.attrCount].AttrVal.pAVal = &AttrValLocalPolicyFlags;
            AttrBlock.attrCount++;
        }

    }

    if (ARGUMENT_PRESENT(CreatorSid))
    {

        ASSERT((SampUserObjectType == Object->ObjectType));

        AttrValCreatorSid.valLen = RtlLengthSid(CreatorSid);
        AttrValCreatorSid.pVal = CreatorSid;
        Attr[AttrBlock.attrCount].attrTyp =  SAMP_USER_CREATOR_SID;
        Attr[AttrBlock.attrCount].AttrVal.valCount = 1;
        Attr[AttrBlock.attrCount].AttrVal.pAVal = &AttrValCreatorSid;
        AttrBlock.attrCount++;
    }

     // Set the group Type
    if (ARGUMENT_PRESENT(GroupType))
    {
        ASSERT((Object->ObjectType==SampGroupObjectType)||
                (Object->ObjectType == SampAliasObjectType));

        AttrValGroupType.valLen = sizeof(ULONG);
        AttrValGroupType.pVal = (UCHAR *) GroupType;
        Attr[AttrBlock.attrCount].attrTyp = GroupTypeAttrTyp;
        Attr[AttrBlock.attrCount].AttrVal.valCount =1;
        Attr[AttrBlock.attrCount].AttrVal.pAVal = &AttrValGroupType;
        AttrBlock.attrCount++;

        //
        // if this is not a security enabled group, pass down the flag
        // so that the sam account type is set correctly
        //

        if (!((*GroupType) & GROUP_TYPE_SECURITY_ENABLED))
        {
            Flags|=SECURITY_DISABLED_GROUP_ADDITION;
        }

        //
        // For Builtin Domain Accouts, set the additional group type
        // bit indicating a builtin local group.
        //

        if (BuiltinDomain)
        {
            (*GroupType)|=GROUP_TYPE_BUILTIN_LOCAL_GROUP;
        }

    }

    //
    // Pass in the DOMAIN_TYPE_BUILTIN flag for the case of
    // the builtin domain.
    //

    if (BuiltinDomain)
    {
        Flags|= DOMAIN_TYPE_BUILTIN;
    }

    //
    // Some SAM objects are meant for advanced view only
    //
    if ( AccountRid == DOMAIN_USER_RID_KRBTGT ) {

        Flags |= ADVANCED_VIEW_ONLY;
    }

    NtStatus = SampDsCreateObjectActual(
                                  Object->ObjectNameInDs,
                                  Flags,
                                  Object->ObjectType,
                                  &AttrBlock,
                                  DomainSidFromAccountContext(Object));
    if ( !NT_SUCCESS(NtStatus) ) {
        KdPrintEx((DPFLTR_SAMSS_ID,
                   DPFLTR_INFO_LEVEL,
                   "SampDsCreateObject failed (0x%x) trying to create account %d\n",
                   NtStatus,
                   AccountRid));

        return NtStatus;
    }

    return NtStatus;

}

NTSTATUS
SampDsCreateObject(
    IN   DSNAME         *Object,
    SAMP_OBJECT_TYPE    ObjectType,
    IN   ATTRBLOCK      *AttributesToSet,
    IN   OPTIONAL PSID  DomainSid
    )
/*++

  Routine Description:

    Creates a SAM Object in the DS.

  Arguments:

    Object              DSNAME of Object
    ObjectType          One of
                            SampDomainObjectType
                            SampServerObjectType
                            SampGroupObjectType
                            SampUserObjectType
                            SampAliasObjectType

                       Specifying SampDomainObjectType creates an
                       actual Domain Object in the DS. For Creating
                       a Builtin-Domain use the SampDsCreateBuiltinDomainObject
                       Function

    AttributesToSet -- Allows the caller to pass in an
                       attribute block to to Set at Object creation time
                       itself. Useful as this allows one to save a JET
                       write. Also the attributes are set in the same
                       transaction as the write.
                       NULL can be passed in if caller does
                       not want any attribute to be set

    DomainSid       -- Optional Parameter, used in creating the Full
                       SID for the account, from the specified Rid


  Return values:

    STATUS_SUCCESS on successful completion
    DS return codes mapped to NT_STATUS as in SampMapDSErrorToNTStatus

--*/
{
    ULONG Flags = SAM_LAZY_COMMIT;

    //
    // If Domain SID specifies a builtin domain account, then
    // set the DOMAIN_TYPE_BUILTIN flag so that correct system
    // flags etc can be set on the object.
    //
    if (RtlEqualSid(DomainSid, SampBuiltinDomainSid))
    {
        Flags |= DOMAIN_TYPE_BUILTIN;
    }


    return(SampDsCreateObjectActual(
                Object,
                Flags,
                ObjectType,
                AttributesToSet,
                DomainSid
                ));
}



NTSTATUS
SampDsCreateBuiltinDomainObject(
    IN   DSNAME         *Object,
    IN   ATTRBLOCK      *AttributesToSet
    )
/*++

  Routine Description:

    Creates a Builtin Domain Object in the DS.

  Arguments:

    Object              DSNAME of Object

    AttributesToSet -- Allows the caller to pass in an
                       attribute block to to Set at Object creation time
                       itself. Useful as this allows one to save a JET
                       write. Also the attributes are set in the same
                       transaction as the write.
                       NULL can be passed in if caller does
                       not want any attribute to be set




  Return values:

    STATUS_SUCCESS on successful completion
    DS return codes mapped to NT_STATUS as in SampMapDSErrorToNTStatus

--*/
{
    //
    // N.B. The FORCE_NO_ADVANCED_VIEW_ONLY is used to override
    // the schema default which was done in the Windows 2000 release.
    // To have the builtin domain object be hidden, simply remove
    // this flag.
    //
    return(SampDsCreateObjectActual(
                Object,
                DOMAIN_TYPE_BUILTIN | FORCE_NO_ADVANCED_VIEW_ONLY, // Flags
                SampDomainObjectType,
                AttributesToSet,
                NULL
                ));
}


NTSTATUS
SampDsCreateObjectActual(
    IN   DSNAME         *Object,
    IN   ULONG          Flags,
    SAMP_OBJECT_TYPE    ObjectType,
    IN   ATTRBLOCK      *AttributesToSet,
    IN   OPTIONAL PSID  DomainSid
    )
/*++

 Routine Description:

     Creates an Object in the DS

 Arguments:


    Object          -- DSNAME of the object to be created

    Flags           -- Flags Controlling the Operation of
                       the routine

                       Valid Flags are
                            DOMAIN_TYPE_DOMAIN
                            DOMAIN_TYPE_BUILTIN
                            ALREADY_MAPPED_ATTRIBUTE_TYPES

    ObjectType      -- one of

                          SampServerObjectType
                          SampDomainObjectType
                          SampGroupObjectType
                          SampUserObjectType
                          SampAliasObjectType


    AttributesToSet -- Allows the caller to pass in an
                       attribute block to to Set at Object creation time
                       itself. Useful as this allows one to save a JET
                       write. Also the attributes are set in the same
                       transaction as the write.
                       NULL can be passed in if caller does
                       not want any attribute to be set

    DomainSid       -- Optional Parameter, used in creating the Full
                       SID for the account, from the specified Rid


  Return values:

    STATUS_SUCCESS on successful completion
    DS return codes mapped to NT_STATUS as in SampMapDSErrorToNTStatus




--*/
{


    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       RetCode;
    ADDARG      AddArg;
    ADDRES      * pAddRes = NULL;
    COMMARG     * pCommArg;


    SAMTRACE("SampDsCreateObjectActual");

    //
    // Parameter validation
    //

    ASSERT(Object);
    ASSERT(AttributesToSet);
    ASSERT(AttributesToSet->attrCount > 0);

    // Perform lazy thread and transaction initialization.
    Status = SampDoImplicitTransactionStart(TransactionWrite);

    if (Status!= STATUS_SUCCESS)
        goto Error;

    //
    // MAP the AttrBlock to get the final attributes to Set
    //

    memset( &AddArg, 0, sizeof( AddArg ) );

    Status = SampSamToDsAttrBlock(
                ObjectType,
                AttributesToSet,
                (
                    MAP_RID_TO_SID
                    | REALLOC_IN_DSMEMORY
                    | ADD_OBJECT_CLASS_ATTRIBUTE
                    | IGNORE_GROUP_UNUSED_ATTR
                    | Flags
                    ),
                DomainSid,
                &AddArg.AttrBlock
                );

    if (Status != STATUS_SUCCESS)
        goto Error;

    //
    // Setup the Common Args structure
    //

    pCommArg = &(AddArg.CommArg);
    BuildStdCommArg(pCommArg);
    if (Flags & SAM_LAZY_COMMIT)
        pCommArg->fLazyCommit = TRUE;

    if (Flags & SAM_URGENT_REPLICATION)
    {
        pCommArg->Svccntl.fUrgentReplication = TRUE;
    }

    //
    // Setup the AddArg structure
    //

    AddArg.pObject = Object;

    //
    // Make the DS call
    //

    SAMTRACE_DS("DirAddEntry\n");

    RetCode = DirAddEntry(&AddArg, &pAddRes);

    SAMTRACE_RETURN_CODE_DS(RetCode);

    //
    // Map the return code to an NT status
    //

    if (NULL==pAddRes)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        Status = SampMapDsErrorToNTStatus(RetCode,&pAddRes->CommRes);
    }

Error:

    //
    // Turn the fDSA flag back on as in loopback cases this can get reset
    //

    SampSetDsa(TRUE);

    return Status;

}


NTSTATUS
SampDsDeleteObject(
    IN DSNAME * Object,
    IN ULONG    Flags
    )
/*++

  Routine Description:

    Delete an Object in the DS

  Arguments:
        Object   -- specifies the Object to delete

        Flags    -- Control Delete, currently defined value is

                    SAM_DELETE_TREE - tells this routine sets argument in
                    RemoveArg, asks core DS to do a Delete Tree operation.

  Return Values:
    STATUS_SUCCESS on succesful completion
    DS return codes mapped to NT_STATUS as in SampMapDSErrorToNTStatus

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    REMOVEARG   RemoveArg;
    REMOVERES   *pRemoveRes=NULL;
    COMMARG     *pCommArg;
    ULONG       RetValue;


    SAMTRACE("SampDsDeleteObject");

    //
    // Asserts and parameter validation
    //

    ASSERT(Object!=NULL);

    // Perform lazy thread and transaction initialization.
    Status = SampDoImplicitTransactionStart(TransactionWrite);

    if (Status!= STATUS_SUCCESS)
        goto Error;

    //
    // Setup the Common Args structure
    //

    memset( &RemoveArg, 0, sizeof( RemoveArg ) );
    pCommArg = &(RemoveArg.CommArg);
    BuildStdCommArg(pCommArg);

    //
    // Setup the RemoveArgs structure
    //

    RemoveArg.pObject = Object;


    //
    // if this is a Tree Delete, set RemoveArgs
    //

    if (SAM_DELETE_TREE & Flags)
    {
        RemoveArg.fTreeDelete = TRUE;
    }


    //
    // Make the directory call
    //

    SAMTRACE_DS("DirRemoveEntry\n");

    RetValue = DirRemoveEntry(&RemoveArg, &pRemoveRes);

    SAMTRACE_RETURN_CODE_DS(RetValue);

    //
    // Map to corresponding NT status code
    //

    if (NULL==pRemoveRes)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        Status = SampMapDsErrorToNTStatus(RetValue,&pRemoveRes->CommRes);
    }


Error:

    //
    // Clear any errors
    //

    SampClearErrors();

    //
    // Turn the fDSA flag back on as in loopback cases this can get reset
    //

    SampSetDsa(TRUE);


    return Status;
}


NTSTATUS
SampDsDeleteWellKnownSidObject(
    IN DSNAME * Object
    )
/*++

  Routine Description:


    This routine first replaces the ATT_OBJECT_SID attribute value with a 
    structurally sound, but non existent SID, and then deletes the object.
    
    We are doing that because SAM still keeps the newest Builtin Well Known 
    Object (even with duplicate SID). If the tombstone object still holds the 
    Object Sid attribute after the deletion, SAM will not be able to find the 
    retained Well Known Account because DS will continue to find duplicate 
    SIDs in the indexed table, (ATT_OBJECT_SID is an indexed attribute) thus 
    leads to SAM Lookup failure.
    
    The solution is to replace the SID attribute with a value that a security
    principal can never have (domain sid, with a RID of 0).
    
  
  Arguments:
        Object   -- specifies the Object to delete

  Return Values:
    STATUS_SUCCESS on succesful completion
    DS return codes mapped to NT_STATUS as in SampMapDSErrorToNTStatus

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    MODIFYARG   ModArg;
    MODIFYRES   *ModRes = NULL;
    REMOVEARG   RemoveArg;
    REMOVERES   *pRemoveRes=NULL;
    COMMARG     *pCommArg;
    ATTR        Attr;
    ATTRVAL     AttrVal;
    ATTRVALBLOCK   AttrValBlock;
    ULONG       RetValue;
    BOOL        fRet;
    BYTE        DomainBuffer[SECURITY_MAX_SID_SIZE];
    BYTE        ReplacementBuffer[SECURITY_MAX_SID_SIZE];
    PSID        DomainSid = (PSID) DomainBuffer;
    PSID        ReplacementSid = (PSID) ReplacementBuffer;
    ULONG       Size;
    ULONG       i;

    SAMTRACE("SampDsDeleteWellKnownSidObject");

    //
    // Asserts and parameter validation
    //

    ASSERT(Object!=NULL);

    // Perform lazy thread and transaction initialization.
    Status = SampDoImplicitTransactionStart(TransactionWrite);

    if (Status!= STATUS_SUCCESS)
        goto Error;


    //
    // Change the SID to a SID that will never exist.  See routine description.
    //
    ASSERT(IsValidSid(&Object->Sid));
    Size = sizeof(DomainBuffer);
    fRet = GetWindowsAccountDomainSid(&Object->Sid,
                                      DomainSid,
                                      &Size);
    if (!fRet)
    {
        Status = STATUS_NO_MEMORY;
        goto Error;
    }

    fRet = InitializeSid(ReplacementSid,
                         GetSidIdentifierAuthority(DomainSid),
                        (*GetSidSubAuthorityCount(DomainSid)) + 1);
    if (!fRet)
    {
        Status = STATUS_NO_MEMORY;
        goto Error;
    }

    for (i = 0; i < *GetSidSubAuthorityCount(DomainSid); i++) {
        *GetSidSubAuthority(ReplacementSid, i) = *GetSidSubAuthority(DomainSid, i);
    }
    *GetSidSubAuthority(ReplacementSid, i) = 0;


    RtlZeroMemory(&ModArg, sizeof(MODIFYARG));

    ModArg.pObject = Object;
    ModArg.FirstMod.pNextMod = NULL;
    ModArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;

    AttrVal.valLen = GetLengthSid(ReplacementSid);
    AttrVal.pVal = ReplacementSid;

    AttrValBlock.valCount = 1;
    AttrValBlock.pAVal = &AttrVal;

    Attr.attrTyp = ATT_OBJECT_SID;
    Attr.AttrVal = AttrValBlock;

    ModArg.FirstMod.AttrInf = Attr;
    ModArg.count = 1;

    pCommArg = &(ModArg.CommArg);
    BuildStdCommArg( pCommArg );


    //
    // set fDSA, so that we can remove ATT_OBJECT_SID
    // 
    SampSetDsa(TRUE);
    
    RetValue = DirModifyEntry( &ModArg, &ModRes );

    if (NULL == ModRes)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        Status = SampMapDsErrorToNTStatus( RetValue, &ModRes->CommRes );
    }


    if (!NT_SUCCESS(Status))
    {
        goto Error;
    }


    //
    // Setup the Common Args structure
    //

    memset( &RemoveArg, 0, sizeof( RemoveArg ) );
    pCommArg = &(RemoveArg.CommArg);
    BuildStdCommArg(pCommArg);

    //
    // Setup the RemoveArgs structure
    //

    RemoveArg.pObject = Object;


    //
    // Make the directory call
    //

    SAMTRACE_DS("DirRemoveEntry\n");

    RetValue = DirRemoveEntry(&RemoveArg, &pRemoveRes);

    SAMTRACE_RETURN_CODE_DS(RetValue);

    //
    // Map to corresponding NT status code
    //

    if (NULL==pRemoveRes)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        Status = SampMapDsErrorToNTStatus(RetValue,&pRemoveRes->CommRes);
    }


Error:

    //
    // Clear any errors
    //

    SampClearErrors();

    //
    // Turn the fDSA flag back on as in loopback cases this can get reset
    //

    SampSetDsa(TRUE);


    return Status;
}



NTSTATUS
SampGenerateNameForDuplicate(
    ULONG   Rid,
    UNICODE_STRING  *NewAccountName
    )
/*++
Routine Description:

    This routine generates a SamAccountName based on the object RID. 
    The new name is like

    $DUPLICATE-<RID>. 

Parameter:

    Rid - object RID
    
    NewAccountName - out parameter

Return Value:

    NtStatus Code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    LPWSTR      NameString = NULL;


    memset(NewAccountName, 0, sizeof(UNICODE_STRING));


    NameString = MIDL_user_allocate( sizeof(WCHAR) * SAMP_MAX_DOWN_LEVEL_NAME_LENGTH ); 
    if (NULL == NameString)
    {
        return( STATUS_INSUFFICIENT_RESOURCES );
    }
    memset(NameString, 0, sizeof(WCHAR) * SAMP_MAX_DOWN_LEVEL_NAME_LENGTH);


    wsprintf(NameString, L"$DUPLICATE-%x", Rid);
    RtlInitUnicodeString(NewAccountName, NameString);

    return( NtStatus );
}


NTSTATUS
SampApplyConstructedAccountName(
    DSNAME *pObjectDsName,
    UNICODE_STRING *pNewAccountName
    )
/*++
Routine Description:

    This routine modifies object (pObjectDsname) SamAccountNamt to pNewAccountName

Parameter:

    pObjectDsName - object dsname 

    pNewAccountName - New SamAccountName

Return Value:

    NtStatus Code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       RetCode = 0; 
    MODIFYARG   ModArg;
    MODIFYRES   *pModRes = NULL;
    COMMARG     *pCommArg = NULL;
    ATTR        Attr;
    ATTRVAL     AttrVal;
    ATTRVALBLOCK    AttrValBlock;

    memset( &ModArg, 0, sizeof(ModArg) );
    ModArg.pObject = pObjectDsName;

    ModArg.FirstMod.pNextMod = NULL;
    ModArg.FirstMod.choice = AT_CHOICE_REPLACE_ATT;

    AttrVal.valLen = pNewAccountName->Length;
    AttrVal.pVal = (PUCHAR) pNewAccountName->Buffer;

    AttrValBlock.valCount = 1;
    AttrValBlock.pAVal = &AttrVal;

    Attr.attrTyp = ATT_SAM_ACCOUNT_NAME;
    Attr.AttrVal = AttrValBlock;

    ModArg.FirstMod.AttrInf = Attr;
    ModArg.count = 1;

    pCommArg = &(ModArg.CommArg);
    BuildStdCommArg( pCommArg );

    RetCode = DirModifyEntry(&ModArg, &pModRes);

    if (NULL==pModRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetCode,&pModRes->CommRes);
    }

    if (!NT_SUCCESS(NtStatus))
    {
    }

    return( NtStatus );  

}






NTSTATUS
SampRenameDuplicateAccount(
    PVOID pv
    )
/*++
Routine Description:

    This routine renames duplicate objects to unique values based on their RIDs

    
    Note: This routine will not re-register itself again if anything fails. 
          Because DuplicateAccountRename will be executed whenever a duplicate 
          is detected, it is not a one time deal. 

Parameter:

    pv - contains object DSNAMEs

Return Value:

    NTSTATUS code

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ULONG       Index = 0;
    SAMP_RENAME_DUP_ACCOUNT_PARM    * RenameParm = (SAMP_RENAME_DUP_ACCOUNT_PARM *)pv;


    if (SampServiceEnabled != SampServiceState)
    {
        goto Cleanup;
    }

    //
    // Perform lazy thread and transaction initialization.
    //

    NtStatus = SampDoImplicitTransactionStart(TransactionRead);

    if (!NT_SUCCESS(NtStatus))
        goto Cleanup;

    // 
    // walk through all duplicate accounts, and generate new SamAccountName. Then
    // rename
    // 

    for (Index = 0; Index < RenameParm->Count; Index ++)
    {
        PSID    pSid = NULL;
        ULONG   Rid = 0;
        UNICODE_STRING  NewAccountName;
        UNICODE_STRING  StringDN;
        PUNICODE_STRING Strings[2];

        // 
        // Create a unique account Name for duplicate objects
        // derive it from object RID
        //

        ASSERT(0 != RenameParm->DuplicateAccountDsNames[Index]->SidLen);
        pSid = &(RenameParm->DuplicateAccountDsNames[Index]->Sid);

        NtStatus = SampSplitSid(pSid, NULL, &Rid); 

        if (!NT_SUCCESS(NtStatus))
        {
            continue;   // continue with the next object to be renamed
        }

        NtStatus = SampGenerateNameForDuplicate(
                            Rid,                             
                            &NewAccountName
                            );

        if (NT_SUCCESS(NtStatus))
        {

            //
            // Call DirModify to rename SamAccountName
            // 
            NtStatus = SampApplyConstructedAccountName(
                                RenameParm->DuplicateAccountDsNames[Index],
                                &NewAccountName
                                );

            if (NT_SUCCESS(NtStatus))
            {
                //
                // Event log account name change if operate succeeds.
                // 
    
                StringDN.Length = (USHORT) RenameParm->DuplicateAccountDsNames[Index]->NameLen * sizeof (WCHAR );
                StringDN.MaximumLength = StringDN.Length;
                StringDN.Buffer= (WCHAR *) &(RenameParm->DuplicateAccountDsNames[Index]->StringName);


                Strings[0] = &StringDN;
                Strings[1] = &NewAccountName;

                SampWriteEventLog(EVENTLOG_INFORMATION_TYPE,
                                  0,
                                  SAMMSG_RENAME_DUPLICATE_ACCOUNT_NAME,
                                  pSid,
                                  2,
                                  0,
                                  Strings,
                                  NULL
                                  );
            }

            MIDL_user_free( NewAccountName.Buffer );
        }
    }
        

Cleanup:

    SampMaybeEndDsTransaction(TransactionCommit);

    MIDL_user_free(((SAMP_RENAME_DUP_ACCOUNT_PARM *)pv)->DuplicateAccountDsNames);
    MIDL_user_free(pv);

    return( NtStatus );
}


NTSTATUS
SampRegisterRenameRoutine(
    IN ULONG   NumMatches,
    IN ENTINFLIST *MatchingEntinfs[],
    IN PDSNAME FoundObject
    )
/*++
Routine Description:

    This routine triggers an asynchronous procedure to rename the duplicate 
    accounts to unique value.

Parameter:

    NumMatches - number of accounts with the same name

    MatchingEntinfs - an array of pointers to ENTINF structure

    FoundObject - pointer to object DSNAME, indicates the account should NOT be 
                  rename, leave this and ONLY this account name unchanged.
    

Return Value:

    NtStatus Code
        STATUS_INSUFFICIENT_RESOURCES
        STATUS_SUCCESS

--*/
{
    NTSTATUS    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    PSAMP_RENAME_DUP_ACCOUNT_PARM   pv = NULL;
    PUCHAR      Destination = NULL;
    ULONG       Index = 0;
    ULONG       DupIndex = 0;
    ULONG       BufLength = 0;

    pv = MIDL_user_allocate(sizeof(SAMP_RENAME_DUP_ACCOUNT_PARM));

    if (NULL != pv)
    {
        memset(pv, 0, sizeof(SAMP_RENAME_DUP_ACCOUNT_PARM));


        // 
        // set the count of objects, which need to be renamed
        //

        ASSERT( NumMatches > 1);
        pv->Count = NumMatches - 1;

        //
        // walk through all duplicate accounts, calculate buffer length.
        //

        //
        // SAMP_RENAME_DUP_ACCOUNT_PARM is a two level structure
        //
        //
        //  pv (Rename Parm)
        //  *--------------------------+
        //  | Count                    |    +----------+
        //  | DuplicateAccountDsNames -|--> | DsName0 -|-----
        //  *--------------------------+    |----------|    |
        //                                  |   ...    |    |
        //                                  |----------|    |
        //                                  | DsNameN -|----|----
        //                                  |----------|    |   |
        //                                  | Buffer 0 | <--|   |
        //                                  |----------|        |
        //                                  |   ...    |        |
        //                                  |----------|        |
        //                                  | Buffer N | <------|
        //                                  |----------|
        //                                  
        // 
        //  the buffers containing the DSNAMEs are allocated in a single slot.
        // 

        BufLength = 0;
        BufLength = (NumMatches - 1) * sizeof( PDSNAME );
        for (Index = 0; Index < NumMatches; Index ++)
        {
            // skip the account to be kept
            if (FoundObject == MatchingEntinfs[Index]->Entinf.pName)
            {
                continue;
            }
            BufLength += MatchingEntinfs[Index]->Entinf.pName->structLen;
        }

        pv->DuplicateAccountDsNames = MIDL_user_allocate( BufLength );

        if (NULL != pv->DuplicateAccountDsNames)
        {
            memset(pv->DuplicateAccountDsNames, 0, BufLength);

            Destination = (PUCHAR) pv->DuplicateAccountDsNames;
            Destination += (NumMatches - 1) * sizeof(PDSNAME);

            DupIndex = 0;

            for (Index = 0; Index < NumMatches; Index ++)
            {
                // skip the account to be kept
                if (FoundObject == MatchingEntinfs[Index]->Entinf.pName)
                {
                    continue;
                }

                // copy DSNAME of the object to be renamed
                memcpy(Destination,
                       MatchingEntinfs[Index]->Entinf.pName,
                       MatchingEntinfs[Index]->Entinf.pName->structLen
                       );

                // set the pointers to the buffer
                pv->DuplicateAccountDsNames[DupIndex] = (PDSNAME) Destination;
                DupIndex ++;

                Destination += MatchingEntinfs[Index]->Entinf.pName->structLen; 
            }

            //
            // trigger the worker routine
            //

            LsaIRegisterNotification(
                    SampRenameDuplicateAccount,
                    (PVOID) pv,
                    NOTIFIER_TYPE_INTERVAL,
                    0,      // no class
                    NOTIFIER_FLAG_ONE_SHOT,
                    5,      // 1 minute
                    NULL    // no handle
                    );

            //
            // set return code to success 
            // 

            NtStatus = STATUS_SUCCESS;
        }
    }

    // release resources if failed

    if ( !NT_SUCCESS(NtStatus) ) 
    {
        if ( pv ) {
            if (pv->DuplicateAccountDsNames) {
                MIDL_user_free( pv->DuplicateAccountDsNames );
            }
            MIDL_user_free( pv );
        }
    }

    return( NtStatus );
}




NTSTATUS
SampHandleDuplicates(
    IN ATTRTYP MatchAttr,
    IN ULONG   NumMatches,
    IN ENTINFLIST *MatchingEntinfs[],
    OUT PDSNAME *FoundObject
    )

/*++

    Routine Description

    SampHandleDuplicates Handles occurences of duplicate Sam account names,
    SIDs etc that are caused by operation within a Distributed System Environment
    The algorithms used to handle these cases are as follows


    1. Duplicate Sids -- In this case both the accounts are deleted
    2. Duplicate Sam account names --
            a. Machine account(s). In this case the most recent account is retained. The
               existance of duplicate accounts is event logged.
            b. All other cases -- The older account is used. The existance of duplicate
               is event logged

    Parameters:

        MatchAttr -- The type of attribute we are matching on
        NumMatches -- The number of entries that matched
        MatchingEntinfs -- The search results containing the matching entries
        FoundObject -- If an object is chosen from the several matching ones, then that
                       object is returned in here



    Return Values:

        STATUS_SUCCESS if an object has been picked
        STATUS_NOT_FOUND if all duplicates were deleted
        STATUS_INTERNAL_ERROR Otherwise
--*/
{
    NTSTATUS    Status = STATUS_SUCCESS, IgnoreStatus = STATUS_SUCCESS;
    ULONG       i;
    LARGE_INTEGER OldestCreationTime;
    LARGE_INTEGER NewestCreationTime;
    DSNAME      * OldestObject;
    DSNAME      * NewestObject;
    VOID          *CurrentThreadState=NULL;

    //
    // Walk through the matches and find the oldest and newest objects
    //

    ASSERT(NumMatches>1);

    ASSERT(3==MatchingEntinfs[0]->Entinf.AttrBlock.attrCount);
    ASSERT(MatchAttr==MatchingEntinfs[0]->Entinf.AttrBlock.pAttr[0].attrTyp);
    ASSERT(ATT_WHEN_CREATED==MatchingEntinfs[0]->Entinf.AttrBlock.pAttr[1].attrTyp);
    ASSERT(ATT_OBJECT_CLASS==MatchingEntinfs[0]->Entinf.AttrBlock.pAttr[2].attrTyp);

    OldestCreationTime
        = *((LARGE_INTEGER *)
          MatchingEntinfs[0]->Entinf.AttrBlock.pAttr[1].AttrVal.pAVal[0].pVal);

    NewestCreationTime
        = *((LARGE_INTEGER *)
          MatchingEntinfs[0]->Entinf.AttrBlock.pAttr[1].AttrVal.pAVal[0].pVal);
    NewestObject = MatchingEntinfs[0]->Entinf.pName;
    OldestObject = MatchingEntinfs[0]->Entinf.pName;

    for (i=1;i<NumMatches;i++)
    {
        ULONG ObjectClass;
        LARGE_INTEGER CreationTime;

        ASSERT(3==MatchingEntinfs[i]->Entinf.AttrBlock.attrCount);
        ASSERT(MatchAttr == MatchingEntinfs[i]->Entinf.AttrBlock.pAttr[0].attrTyp);
        ASSERT(ATT_WHEN_CREATED == MatchingEntinfs[i]->Entinf.AttrBlock.pAttr[1].attrTyp);
        ASSERT(ATT_OBJECT_CLASS == MatchingEntinfs[i]->Entinf.AttrBlock.pAttr[2].attrTyp);

        ObjectClass = *((ULONG *)MatchingEntinfs[i]->Entinf.AttrBlock.pAttr[2].AttrVal.pAVal[0].pVal);
        CreationTime =
            *((LARGE_INTEGER *)MatchingEntinfs[i]->Entinf.AttrBlock.pAttr[1].AttrVal.pAVal[0].pVal);

        if (OldestCreationTime.QuadPart>CreationTime.QuadPart)
        {
            OldestCreationTime = CreationTime;
            OldestObject = MatchingEntinfs[i]->Entinf.pName;
        }

        if (NewestCreationTime.QuadPart<CreationTime.QuadPart)
        {
            NewestCreationTime = CreationTime;
            NewestObject = MatchingEntinfs[i]->Entinf.pName;
        }
    }


    //
    // Now Handle the various cases
    //

    switch(MatchAttr)
    {
    case ATT_OBJECT_SID:

        //
        // Duplicate SIDs are always deleted
        //

        CurrentThreadState = THSave();

        for (i=0;i<NumMatches;i++)
        {
            UNICODE_STRING StringDN;
            PUNICODE_STRING StringPointers = &StringDN;
            PSID            pSid = NULL;
            ULONG           Rid = 0;
            ULONG           EventId = 0;
            BOOLEAN         fFPO = FALSE;
            ULONG           ObjectClass;
            ULONG           j;

            ASSERT(0 != MatchingEntinfs[i]->Entinf.pName->SidLen);
            pSid = &(MatchingEntinfs[i]->Entinf.pName->Sid);

            //
            // Duplicate FPO's shouldn't be deleted.  They cause no harm being
            // duplicated and deleting would ruin an existing membership.
            // Note: perhaps the FPO cleanup task could identify duplicate
            // FPO's and consolidate.  This would have to handle well known
            // SID's (like Everyone) to be complete.
            //
            for (j = 0; j < MatchingEntinfs[i]->Entinf.AttrBlock.pAttr[2].AttrVal.valCount; j++)
            {
                if (CLASS_FOREIGN_SECURITY_PRINCIPAL ==
                     *((ULONG *)MatchingEntinfs[i]->Entinf.AttrBlock.pAttr[2].AttrVal.pAVal[j].pVal))
                {
                    fFPO = TRUE;
                    break;
                }
            }
            if ( fFPO )
            {
                //
                // Return the newest object and don't delete the rest
                // 
                // N.B. If a duplicate SID is found and one of the objects is
                // an FPO, then all duplicate SID objects must be FPO's as
                // well since SAM searches are in the scope of a single 
                // domain.
                //
                *FoundObject = NewestObject;
                break;
            }

            SampSplitSid(pSid, NULL, &Rid);

            //
            // Well known accounts 
            // Only SAM can create wellknown accounts. Instead of delete all
            // duplicates, we will keep the newest well known accounts and 
            // delete the rest.
            //


            if ( SampIsAccountBuiltIn( Rid ) )
            {
                if ( NewestObject == MatchingEntinfs[i]->Entinf.pName )
                {
                    // keep the newest account
                    *FoundObject = NewestObject;
                    continue;
                }
                else
                {
                    // delete all older accounts
                    EventId = SAMMSG_DUPLICATE_SID_WELLKNOWN_ACCOUNT;
                }
            }
            else
            {
                EventId = SAMMSG_DUPLICATE_SID;
            }

            if ( SampIsAccountBuiltIn( Rid ) )
            {
                //
                // This variation of delete object will replace the SID value
                // with a strucuturally sound, non existent SID so that
                // subsequent searches won't find the deleted object.
                //
                SampDsDeleteWellKnownSidObject(MatchingEntinfs[i]->Entinf.pName);
            }
            else 
            {
                //
                // ASSERT at this point since we have a duplicate SID in 
                // an account domain.
                //
                ASSERT(FALSE && "Duplicate SID Found");

                SampDsDeleteObject(MatchingEntinfs[i]->Entinf.pName,
                                   0);
            }

            StringDN.Length = (USHORT) MatchingEntinfs[i]->Entinf.pName->NameLen * sizeof (WCHAR );
            StringDN.MaximumLength = StringDN.Length;
            StringDN.Buffer= (WCHAR *) &MatchingEntinfs[i]->Entinf.pName->StringName;

            SampWriteEventLog(
                    EVENTLOG_ERROR_TYPE,
                    0,
                    EventId,
                    &MatchingEntinfs[i]->Entinf.pName->Sid,
                    1,
                    0,
                    &StringPointers,
                    NULL
                    );
        }

        SampMaybeEndDsTransaction(TransactionCommit);

        THRestore(CurrentThreadState);

        //
        // The return Status is object not found
        //
        if (*FoundObject == NULL) {
            Status =  STATUS_NOT_FOUND;
        }

        break;

    case ATT_SAM_ACCOUNT_NAME:

        //
        // Whistler always preserves the newest account. This is so that we are always
        // consistent with the replicator when mangling CN's.
        //

    
        *FoundObject = NewestObject;
      
        //
        // Trigger a asynchronous routine to rename the dupliate
        // account to a unique value. The duplicates will be 
        // event logged as they are renamed.
        // 

        IgnoreStatus = SampRegisterRenameRoutine(
                                NumMatches,
                                MatchingEntinfs,
                                *FoundObject
                                );

        //
        // The return status is success
        //

        Status = STATUS_SUCCESS;

        break;

    case ATT_MS_DS_ADDITIONAL_SAM_ACCOUNT_NAME:

        Status = STATUS_USER_EXISTS;
        break;

    default:

        Status = STATUS_OBJECT_NAME_COLLISION;
        break;
    }


    return Status;

}


NTSTATUS
SampDsDoUniqueSearch(
             IN ULONG  Flags,
             IN DSNAME * ContainerObject,
             IN ATTR * AttributeToMatch,
             OUT DSNAME **Object
             )
/*++

  Routine Description:

    Searches for the object with the given attribute
    NOTE - SampDsDoUniqueSearch expects that the search result is unique.
    It is typically used in Rid to Object, Sid To Object, Name To Object Mappings,
    This is a simplified search, so that simple searches on a single attribute
    can be easily set up.

  Arguments
        Flags            -- Flags, control searching. Currently defined flag is

            SAM_UNICODE_STRING_MANUAL_COMPARISON   -- Tells the routine to manually
            compare using RtlCompareUnicodeString in a case insenstive fashion in
            case of multiple matches.

            SAM_UPGRADE_FROM_REGISTRY - Tells the routine to not call
            SampHandleDuplicates() when duplicates are found since we are
            upgrading accounts from the registry to the DS.


        ContainerObject  -- specifies the DSNAME of the container in which to search

        AttributeToMatch -- specifies the type and value of the attribute that must match.
                            The attribute Type is the DS attribute Type. Caller must do
                            the translation. This is acceptable as this is not a function that
                            is called from outside dslayer.c

        Object           -- Pointer to a DSNAME specifying the object is returned in here.
                            This object is allocated using SAM's memory allocation routines

  Return Values:
        STATUS_SUCCESS   -- on successful completion
        STATUS_NOT_FOUND -- if object not found
        STATUS_UNSUCCESSFUL -- if more than one match
        DS return codes mapped to NT_STATUS as in SampMapDSErrorToNTStatus
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    SEARCHARG SearchArg;
    SEARCHRES * SearchRes=NULL;
    FILTER  Filter;
    ULONG   RetCode;
    COMMARG * pCommArg;
    SVCCNTL * pSvcCntl;
    ENTINFSEL EntInfSel;
    PVOID     pVal = NULL;
    ENTINFLIST *MatchingEntInf = NULL;
    BOOLEAN   fUseDirFind =  FALSE;
    BOOLEAN   fUseDirSearch = TRUE;
    ULONG     DomainHandle = 0;
    FINDARG   FindArg;
    FINDRES   *pFindRes;
    DSNAME    *FoundObject;

    SAMTRACE("SampDsDoUniqueSearch");

    //
    // Asserts and parameter validation
    //

    ASSERT(AttributeToMatch);
    ASSERT(AttributeToMatch->AttrVal.pAVal);
    ASSERT(ContainerObject);
    ASSERT(Object);

    //
    // Set Object To NULL for sake of error returns
    //

    *Object = NULL;

    //
    // Check to see if we can use Dir Find instead
    // of Dir Search
    //

    if ((SampServiceEnabled==SampServiceState)
        && (ContainerObject->SidLen>0))
    {
        ULONG i;

        //
        // Scan the defined domains Array
        //

        for (i=SampDsGetPrimaryDomainStart();i<SampDefinedDomainsCount;i++)
        {
            if ((RtlEqualSid(&ContainerObject->Sid,
                        SampDefinedDomains[i].Sid))
                 && (0!=SampDefinedDomains[i].DsDomainHandle)
                 && (!IsBuiltinDomain(i)))
            {
                //
                // Yes we found a domain that we host, and that domain
                // is not a builtin domain
                //

                DomainHandle = SampDefinedDomains[i].DsDomainHandle;
                fUseDirFind = TRUE;
                break;
            }
        }
    }


    //
    // Dir Find is hard coded to not find deleted
    // objects. So in such cases use Dir Search
    //

    if (Flags & SAM_MAKE_DEL_AVAILABLE)
    {
        fUseDirFind = FALSE;
    }


    //
    // Perform lazy thread and transaction initialization.
    //

    Status = SampDoImplicitTransactionStart(TransactionRead);

    if (Status!= STATUS_SUCCESS)
        goto Error;



    //
    // Search by using DirFindEntry
    //

    if (fUseDirFind)
    {
        //
        // Dir Find can being used try using it
        //

        RtlZeroMemory(&FindArg,sizeof(FINDARG));
        FindArg.hDomain = DomainHandle;
        FindArg.AttId = AttributeToMatch->attrTyp;
        FindArg.AttrVal = *(AttributeToMatch->AttrVal.pAVal);
        FindArg.fShortNames = TRUE;
        BuildStdCommArg(&FindArg.CommArg);

        SAMTRACE_DS("DirFind\n");

        RetCode = DirFindEntry(&FindArg,&pFindRes);

        SAMTRACE_RETURN_CODE_DS(RetCode);

        //
        // Clear any errors
        //

        SampClearErrors();

        if (0==RetCode)
        {
            //
            // Dir Find Succeeded, No duplicates etc
            // Need not fall over to DirSearch, therefore
            // set fUseDirSearch to false
            //

            FoundObject = pFindRes->pObject;
            fUseDirSearch = FALSE;

        }
        else if (NULL!=pFindRes)
        {
            Status  = SampMapDsErrorToNTStatus(RetCode,&pFindRes->CommRes);
            if (STATUS_OBJECT_NAME_NOT_FOUND == Status)
            {
                //
                // We cound not find the object. Bail
                //

                Status = STATUS_NOT_FOUND;
                goto Error;
            }

            //
            // Some other wierd error occured out here. Fall
            // through to the Dir Search
            //

            Status = STATUS_SUCCESS;

        }
        else
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }
    }


    //
    // Fall over to full DirSearch if DirFindEntry detected any kind of
    // error condition or if we cannot use DirFind
    //

    if (fUseDirSearch)
    {

        //
        // Build the filter
        //
        memset (&Filter, 0, sizeof (Filter));
        Filter.choice = FILTER_CHOICE_ITEM;
        Filter.FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
        Filter.FilterTypes.Item.FilTypes.ava.type = AttributeToMatch->attrTyp;
        Filter.FilterTypes.Item.FilTypes.ava.Value.valLen = AttributeToMatch->AttrVal.pAVal->valLen;

        pVal = DSAlloc(AttributeToMatch->AttrVal.pAVal->valLen);
        if (NULL==pVal)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }

        RtlCopyMemory(
            pVal,
            AttributeToMatch->AttrVal.pAVal->pVal,
            AttributeToMatch->AttrVal.pAVal->valLen
            );

        Filter.FilterTypes.Item.FilTypes.ava.Value.pVal = pVal;

        //
        // Build the SearchArg Structure
        //

        memset(&SearchArg, 0, sizeof(SEARCHARG));
        SearchArg.pObject = ContainerObject;
        SearchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
        SearchArg.pFilter = & Filter;
        SearchArg.searchAliases = FALSE;
        SearchArg.pSelection = & EntInfSel;
        SearchArg.bOneNC = TRUE;

        EntInfSel.attSel = EN_ATTSET_LIST;
        EntInfSel.AttrTypBlock.attrCount = 3;
        SAMP_ALLOCA(EntInfSel.AttrTypBlock.pAttr,3*sizeof(ATTR));
        if (NULL==EntInfSel.AttrTypBlock.pAttr)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }
        RtlZeroMemory(
           EntInfSel.AttrTypBlock.pAttr,
           3*sizeof(ATTR));

        EntInfSel.AttrTypBlock.pAttr[0].attrTyp = AttributeToMatch->attrTyp;
        EntInfSel.AttrTypBlock.pAttr[1].attrTyp = ATT_WHEN_CREATED;
        EntInfSel.AttrTypBlock.pAttr[2].attrTyp = ATT_OBJECT_CLASS;

        // Unique search does a Dir Search only in fairly
        // rare error cases. And in these cases it is useful to
        // have the string name for event logging. So ask for
        // string names
        EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;


        //
        // Build the Commarg structure
        // Get the address of the service control structure
        //

        pCommArg = &(SearchArg.CommArg);
        BuildStdCommArg(pCommArg);

        if (Flags & SAM_MAKE_DEL_AVAILABLE)
        {
            pSvcCntl = &(pCommArg->Svccntl);
            pSvcCntl->makeDeletionsAvail = TRUE;
        }

        //
        // Make the Directory call
        //

        SAMTRACE_DS("DirSearch\n");

        RetCode = DirSearch(&SearchArg, &SearchRes);

        SAMTRACE_RETURN_CODE_DS(RetCode);

        //
        // check for errors
        //
        if (NULL==SearchRes)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            Status  = SampMapDsErrorToNTStatus(RetCode,&SearchRes->CommRes);
            if (STATUS_OBJECT_NAME_NOT_FOUND == Status)
            {
                // Map error to what client expects
                Status = STATUS_NOT_FOUND;
            }
        }
        if (Status != STATUS_SUCCESS)
            goto Error;

        //
        // If more data exists then error out. Under normal memory
        // conditions we should not ever need to hit size limits.
        //

        if ((SearchRes->pPartialOutcomeQualifier)
            && (SearchRes->pPartialOutcomeQualifier->problem == PA_PROBLEM_SIZE_LIMIT))
        {
            // Partial outcome,  error out saying no mmeory
            Status = STATUS_NO_MEMORY;
            goto Error;
        }


        //
        // Check if no match exists or more than one match exists.
        //

        if (SearchRes->count == 0)
        {
            //
            // No Match Exists
            //

            Status =  STATUS_NOT_FOUND;
            goto Error;
        }
        else if (SearchRes->count >= 1)
        {

            //
            // More than one match exists, ( or as exists as claimed by Jet ),
            // perform a binary comparison of the data, with the supplied value
            // for the Data, if this was requested by the caller

            ULONG i, valIndex;
            ENTINFLIST * pEntinf = &SearchRes->FirstEntInf;
            ULONG      NumMatches=0;
            ENTINFLIST **pMatchingEntinfList;

            //
            // Alloc Stack space for all the matching objects.
            //


            SAMP_ALLOCA(pMatchingEntinfList,SearchRes->count * sizeof (ENTINF *));
            if (NULL==pMatchingEntinfList)
            {
                 Status = STATUS_INSUFFICIENT_RESOURCES;
                 goto Error;
            }


            //
            // Walk through the object looking at each object that matched.
            //

            for (i=0;i<SearchRes->count;i++)
            {
                BOOLEAN Matched = FALSE;


                if (Flags & SAM_UNICODE_STRING_MANUAL_COMPARISON)
                {
                    //
                    // If Manual Comparison to further weed out any matches was requested
                    // by caller then perform the appropriate manual comparison. This
                    // comparison is needed because the Jet indices treat many kinds of
                    // localized names as the same, and NT account names do not treat them
                    // so.
                    //

                    UNICODE_STRING TmpString1,TmpString2;


                    TmpString1.Buffer=(WCHAR *)AttributeToMatch->AttrVal.pAVal[0].pVal;
                    TmpString1.Length=(USHORT)AttributeToMatch->AttrVal.pAVal[0].valLen;
                    TmpString1.MaximumLength = TmpString1.Length;

                    ASSERT(NULL!=TmpString1.Buffer);

                    ASSERT(3==pEntinf->Entinf.AttrBlock.attrCount);
                    // ASSERT(1==pEntinf->Entinf.AttrBlock.pAttr[0].AttrVal.valCount);

                    for (valIndex = 0; 
                         valIndex < pEntinf->Entinf.AttrBlock.pAttr[0].AttrVal.valCount;
                         valIndex++)
                    {
                        TmpString2.Buffer=(WCHAR *)pEntinf->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[valIndex].pVal;
                        TmpString2.Length=(USHORT)pEntinf->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[valIndex].valLen;
                        TmpString2.MaximumLength = TmpString2.Length;

                        ASSERT(NULL!=TmpString2.Buffer);

                        //
                        // Do a Case In-Sensitive Comparison
                        //

                        if (0==RtlCompareUnicodeString(&TmpString1,&TmpString2,TRUE))
                        {
                            pMatchingEntinfList[NumMatches] = pEntinf;
                            NumMatches++;
                            MatchingEntInf = pEntinf;
                            Matched = TRUE;
                            break;
                        }
                    }
                }
                else
                {
                    //
                    // Consider it a match if no manual comparison was requested.
                    //
                    pMatchingEntinfList[NumMatches]=pEntinf;
                    NumMatches++;
                    MatchingEntInf = pEntinf;
                    Matched = TRUE;
                }


        #if DBG
                //
                // On Checked Builds print out information regarding conflicting
                // object's if more that one object was returned. Some legal cases
                // will also be printed out but, that is rare enough that this much
                // support is adequate.
                //

                if ((Matched) && (SearchRes->count>1))
                {
                    SampDiagPrint(OBJECT_CONFLICT,("[SAMSS]:Conflict Object is %S\n",
                                    &(pEntinf->Entinf.pName->StringName)));
                }

        #endif
                pEntinf = pEntinf->pNextEntInf;
            }

            if (NumMatches >1)
            {

                //
                // If There were more than one match then call the routine. It is an internal
                // problem such as duplicate SIDs or Sam Account Names. SampHandleDuplicates
                // handles many cases of such duplicates.
                //
                if ( Flags & SAM_UPGRADE_FROM_REGISTRY ) {

                    ASSERT( (Flags & SAM_UNICODE_STRING_MANUAL_COMPARISON) == 0 );

                    //
                    // Since manual comparison was not done, NumMatches will
                    // always be greater that one if any duplicates were found.
                    // In the upgrade case, don't event log the duplicates;
                    // the upgrader code will log an event indicating the RDN
                    // for the account is not the samaccountname.
                    //

                    //
                    // Return the first one
                    //
                    FoundObject = MatchingEntInf->Entinf.pName;

                    Status = STATUS_SUCCESS;

                } else {

                    Status = SampHandleDuplicates(
                                AttributeToMatch->attrTyp,
                                NumMatches,
                                pMatchingEntinfList,
                                &FoundObject
                                );


                }


                if (!NT_SUCCESS(Status))
                {
                    goto Error;
                }

            }
            else if (0==NumMatches)
            {
                //
                // If there were no matches then error out.
                //
                Status = STATUS_NOT_FOUND;
                goto Error;
            }
            else
            {

                //
                // Allocate Memory to hold that object, and copy in its Value
                //

                ASSERT(NULL!=MatchingEntInf);
                FoundObject = MatchingEntInf->Entinf.pName;
            }
        }

    }

    *Object = MIDL_user_allocate(FoundObject->structLen);
    if (NULL==*Object)
    {
        Status = STATUS_NO_MEMORY;
        goto Error;
    }

    RtlCopyMemory(*Object,
                  FoundObject,
                  FoundObject->structLen
                  );

Error:

    //
    // Clear any errors
    //

    SampClearErrors();

    //
    // Turn the fDSA flag back on as in loopback cases this can get reset
    //

    SampSetDsa(TRUE);


    return Status;
}


NTSTATUS
SampDsDoSearch2(
                ULONG    Flags,
                RESTART *Restart,
                DSNAME  *DomainObject,
                FILTER  *DsFilter,
                int      Delta,
                SAMP_OBJECT_TYPE ObjectTypeForConversion,
                ATTRBLOCK *  AttrsToRead,
                ULONG   MaxMemoryToUse,
                ULONG   TimeLimit,
                SEARCHRES **SearchRes
                )
/*++

  Routine Description:

   This routine calls a DS Search to list a set of Objects with
   the given Filter. The user passes in a Filter Structure. PagedResults
   are always requested.

     WARNING

          This Routine Translates only the incoming Attributes To Read, and
          does not translate either the filter structure or the returned
          attributes. This is done for the sake of efficiency as otherwise
          it requires a second walk through cumbersome filter structures and
          potentially large number of search results.

  Arguments:

        Restart         - Pointer to Restart Structure to contine an
                          old search
        ContainerObject - The place to Search in
        DsFilter        - A Ds Filter Structure that is passed in
        StartingIndex   - The number of initial objects to skip
        ObjectTypeForConversion -  Sam Object Type to be used in
                          AttrBlock Conversion of the passed in Attrblock.
        AttrsToRead     - Attributes to be read back, and returned with
                          every object that matched the search criteria.
        MaxMemoryToUse  - The Maximum Memory to Use.
        TimeLimit       - In milliseconds
        SearchRes       - Pointer to Search Results is passed back
                          in this

  Return Values
        DS error codes Mapped to NT Status

--*/
{
    SEARCHARG   SearchArg;
    ENTINFSEL   EntInfSel;
    ULONG       RetCode;
    COMMARG     *pCommArg;
    NTSTATUS    Status = STATUS_SUCCESS;

    SAMTRACE("SampDsDoSearch");

    *SearchRes = NULL;

    // Perform lazy thread and transaction initialization.
    Status = SampDoImplicitTransactionStart(TransactionRead);

    if (Status!= STATUS_SUCCESS)
        return(Status);

    //
    // Build the SearchArg Structure
    //

    memset(&SearchArg, 0, sizeof(SEARCHARG));
    SearchArg.pObject = DomainObject;
    SearchArg.choice = SE_CHOICE_WHOLE_SUBTREE;
    SearchArg.pFilter = DsFilter;
    SearchArg.searchAliases = FALSE;
    SearchArg.pSelection = & EntInfSel;
    SearchArg.bOneNC = TRUE;

    //
    // Fill the ENTINF Structure
    //

    EntInfSel.attSel = EN_ATTSET_LIST;
    //EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EntInfSel.infoTypes = EN_INFOTYPES_SHORTNAMES;

    //
    // Map the Passed in Sam Attribute Type to
    // DS Attribute Type
    //

    //
    // First allocate space in stack for the Attrblock to be passed
    // down into the DS
    //

    SAMP_ALLOCA(EntInfSel.AttrTypBlock.pAttr,AttrsToRead->attrCount * sizeof(ATTR));
    if (NULL==EntInfSel.AttrTypBlock.pAttr)
    {
        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    Status = SampSamToDsAttrBlock(
                ObjectTypeForConversion,
                AttrsToRead,
                ( MAP_RID_TO_SID      |
                  IGNORE_GROUP_UNUSED_ATTR),
                NULL,
                & EntInfSel.AttrTypBlock
                );

    //
    // Build the CommArg Structure
    // Build the Commarg structure
    // Get the address of the service control structure
    //

    pCommArg = &(SearchArg.CommArg);
    BuildStdCommArg(pCommArg);

    //
    // Request For Paged Results
    //

    pCommArg->PagedResult.fPresent = TRUE;
    pCommArg->PagedResult.pRestart = Restart;

    //
    // Set our memory size
    //

    pCommArg->ulSizeLimit = MaxMemoryToUse;

    //
    // Set Delta
    //

    pCommArg->Delta = Delta;

    //
    // Search deleted objects
    //

    if (Flags & SAM_MAKE_DEL_AVAILABLE)
    {
        pCommArg->Svccntl.makeDeletionsAvail = TRUE;
    }

    //
    // Set any requested time limit
    //
    if (0!=TimeLimit)
    {
        pCommArg->StartTick = GetTickCount();
        if(0==pCommArg->StartTick) {
            pCommArg->StartTick = 0xFFFFFFFF;
        }
        pCommArg->DeltaTick = TimeLimit;
    }

    //
    // Make the Directory call
    //

    SAMTRACE_DS("DirSearch\n");

    RetCode = DirSearch(&SearchArg, SearchRes);

    SAMTRACE_RETURN_CODE_DS(RetCode);

    //
    // Map Errors
    //

    if (NULL==*SearchRes)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        Status  = SampMapDsErrorToNTStatus(RetCode,&(*SearchRes)->CommRes);
    }

    //
    // Clear any errors
    //

    SampClearErrors();

    //
    // Turn the fDSA flag back on as in loopback cases this can get reset
    //

    SampSetDsa(TRUE);



    //
    // Return error code
    //

    return Status;
}

NTSTATUS
SampDsLookupObjectByNameEx(
    IN DSNAME * DomainObject,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PUNICODE_STRING ObjectName,
    OUT DSNAME ** Object,
    ULONG SearchFlags
    )
/*++

    Routine Description:

        Does a Name to Object Mapping.

    Arguments:
        ContainerObject -- The container in which to search the object
        ObjectType -- The type of the Object.
        ObjectName -- Unicode name of the Object to be located
        Object -- DSNAME structure specifying the object
        SearchFlags -- flags to pass through to SampDsDoUniqueSearch

    Return Values:

            STATUS_UNSUCCESSFUL
            Returned Status from SampDoDsSearch

--*/

{

    NTSTATUS    Status = STATUS_SUCCESS;
    ATTRVAL     NameVal;
    ATTR        NameAttr;
    PSID        DomainSid;


    SAMTRACE("SampDsLookupObjectByName");

    SampDiagPrint(LOGON,("[SAMSS] DsLookupObjectByName  on %S\n",ObjectName->Buffer));

    //
    // The Name is a property stored in the object
    // and we search for it.
    //

    //
    // setup the attribute field for the search
    //
    NameVal.valLen = (ObjectName->Length);
    NameVal.pVal = (UCHAR *) ObjectName->Buffer;
    NameAttr.AttrVal.valCount = 1;
    NameAttr.AttrVal.pAVal = & NameVal;

    switch (ObjectType)
    {
    case SampGroupObjectType:
        NameAttr.attrTyp =
            SampDsAttrFromSamAttr(ObjectType,SAMP_GROUP_NAME);
        break;

    case SampUserObjectType:
        NameAttr.attrTyp =
            SampDsAttrFromSamAttr(ObjectType,SAMP_USER_ACCOUNT_NAME);
        break;

    case SampAliasObjectType:
        NameAttr.attrTyp =
            SampDsAttrFromSamAttr(ObjectType,SAMP_ALIAS_NAME);
        break;

    case SampUnknownObjectType:
        NameAttr.attrTyp =
            SampDsAttrFromSamAttr(ObjectType,SAMP_UNKNOWN_OBJECTNAME);
        break;
    default:
        ASSERT(FALSE);
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }


    DomainSid = SampDsGetObjectSid(DomainObject);
    Status = SampDsDoUniqueSearch(SearchFlags,DomainObject,&NameAttr,Object);

    if ((NT_SUCCESS(Status)) && (NULL!=DomainSid)
            && ((*Object)->SidLen>0) && (RtlValidSid(&(*Object)->Sid)))
    {
        NT4SID AccountSid;

        //
        // Filter out Additionaly by SID, since the builtin domain is
        // under the domain object and we don't want builtin domain
        // security prinicpals to show up on the account dommain
        //


        RtlCopyMemory(&AccountSid,&(*Object)->Sid,sizeof(NT4SID));
        (*(RtlSubAuthorityCountSid(&AccountSid)))--;
        if (!RtlEqualSid(&AccountSid,DomainSid))
        {
            MIDL_user_free(*Object);
            *Object=NULL;
            Status = STATUS_NOT_FOUND;
        }
    }

    SampDiagPrint(LOGON,("[SAMSS] Returns Status %d\n",Status));

Error:

    return(Status);
}

NTSTATUS
SampDsLookupObjectByName(
    IN DSNAME * DomainObject,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN PUNICODE_STRING ObjectName,
    OUT DSNAME ** Object
    )
{
    return SampDsLookupObjectByNameEx( DomainObject,
                                       ObjectType,
                                       ObjectName,
                                       Object,
                                       SAM_UNICODE_STRING_MANUAL_COMPARISON );

}

NTSTATUS
SampDsObjectFromSid(
    IN PSID Sid,
    OUT DSNAME ** Object
    )
/*++

    This routine searches the local Database for a Sid
    in the local DS Database.

  Arguments:

    Sid -- SID of the object
    DsName -- DS NAME of the located object.


  Return Values:

    STATUS_SUCCESS
    STATUS_NOT_FOUND
--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ATTR     SidAttr;
    ATTRVAL  SidVal;
    DSNAME   RootObject;

    SAMTRACE("SampDsObjectFromSid");



    //
    //  Set up the Sid Attribute
    //

    SidAttr.attrTyp = SampDsAttrFromSamAttr(
                        SampUnknownObjectType,
                        SAMP_UNKNOWN_OBJECTSID
                        );

    SidAttr.AttrVal.valCount = 1;
    SidAttr.AttrVal.pAVal = &SidVal;
    SidVal.valLen = RtlLengthSid(Sid);
    SidVal.pVal = (UCHAR *)Sid;


    //
    // Specify Root domain  as base of Search
    //


    Status = SampDsDoUniqueSearch(
                 0,           // Flags
                 ROOT_OBJECT, // Search Base
                 &SidAttr,    // Sid
                 Object       // Get Results in Here.
                );

    return Status;

}


PSID
SampDsGetObjectSid(
    IN DSNAME * Object
    )
/*++
Routine Description:

  Given the DSNAME of the Object this routine returns the Sid
  of the Object.

  Arguments:

  Object:
        Object whose Sid needs returning

  Return Values:
     Sid of the object.
     NULL if no Sid exists
--*/
{

    ATTR SidAttr;
    ATTRBLOCK SidAttrBlock;
    ATTRBLOCK Result;
    NTSTATUS  Status;
    ULONG     i, sidLen;
    PSID      pSid;

    SAMTRACE("SampDsGetObjectSid");

    // We're either going to do a SampDsRead or a DSAlloc, both
    // of which need a DS transaction.  So start it now.

    Status = SampDoImplicitTransactionStart(TransactionRead);

    if ( !NT_SUCCESS(Status) )
    {
        return(NULL);
    }

    //
    // Check if the SID portion is filled in
    //
    if (Object->SidLen>0)
     {
        // Return a thread state allocated SID just like the search
        // based code does.

        sidLen = Object->SidLen;

        pSid = (PSID) DSAlloc(sidLen);

        if ( NULL != pSid )
        {
            Status = RtlCopySid(sidLen, pSid, &Object->Sid);

            ASSERT(NT_SUCCESS(Status));
        }

        return(pSid);
    }

    //
    // Read the Database to obtain the SID
    //


    SidAttrBlock.attrCount =1;
    SidAttrBlock.pAttr = &(SidAttr);

    SidAttr.AttrVal.valCount =0;
    SidAttr.AttrVal.pAVal = NULL;
    SidAttr.attrTyp = SAMP_UNKNOWN_OBJECTSID;

    Status = SampDsRead(
                   Object,
                   0,
                   SampUnknownObjectType,
                   & SidAttrBlock,
                   & Result
                   );

    if (Status != STATUS_SUCCESS)
        return NULL;

    return Result.pAttr[0].AttrVal.pAVal->pVal;
}


NTSTATUS
SampDsLookupObjectByRid(
    IN DSNAME * DomainObject,
    IN ULONG ObjectRid,
    OUT DSNAME **Object
    )
/*++

Routine Description:

  RID to Object Mapping

Arguments:

        ContainerObject -- The container in which to locate this object
        ObjectRid  -- RID of the object to be located
        Object     -- returns pointer to DSNAME structure specifying the object

  Return Values:
            STATUS_SUCCESS on successful completion
            Any returned by SampDsDoSearch

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ATTRVAL  RidVal = {sizeof(ULONG), (UCHAR *)&ObjectRid};
    ATTR     RidAttr = {SAMP_UNKNOWN_OBJECTRID, {1, &RidVal}};
    PSID     DomainSid;
    ATTR     SidAttr;
    BOOLEAN  WellKnownAccount;

    SAMTRACE("SampDsLookupObjectByRid");

    DomainSid = SampDsGetObjectSid(DomainObject);


    if (DomainSid == NULL)
    {
        Status = STATUS_UNSUCCESSFUL;
        goto Error;
    }

    SidAttr.attrTyp = SampDsAttrFromSamAttr(
                        SampUnknownObjectType,
                        SAMP_UNKNOWN_OBJECTSID
                        );


    Status = SampDsSetNewSidAttribute(
                        DomainSid,
                        REALLOC_IN_DSMEMORY,
                        &RidAttr,
                        &SidAttr,
                        &WellKnownAccount
                        );

    if (Status != STATUS_SUCCESS)
        goto Error;

    Status = SampDsDoUniqueSearch(0,DomainObject,&SidAttr,Object);


Error:

    return Status;

}

NTSTATUS
SampDsLookupObjectBySid(
    IN DSNAME * DomainObject,
    PSID ObjectSid,
    DSNAME **Object
    )
/*++

Routine Description:

  SID to Object Mapping

Arguments:

        ContainerObject -- The container in which to locate this object
        ObjectSid       -- SID of the object to be located
        Object          -- returns pointer to DSNAME structure specifying the object

  Return Values:
            STATUS_SUCCESS on successful completion
            Any returned by SampDsDoSearch

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    ATTR     SidAttr;

    SAMTRACE("SampDsLookupObjectBySid");

    SidAttr.attrTyp = SampDsAttrFromSamAttr(
                        SampUnknownObjectType,
                        SAMP_UNKNOWN_OBJECTSID
                        );

    SidAttr.AttrVal.pAVal = DSAlloc(sizeof(ATTRVAL));

    if (NULL == SidAttr.AttrVal.pAVal)
    {
        Status = STATUS_NO_MEMORY;
        goto Error;
    }

    SidAttr.AttrVal.valCount = 1;
    SidAttr.AttrVal.pAVal->valLen = RtlLengthSid(ObjectSid);
    SidAttr.AttrVal.pAVal->pVal = ObjectSid;

    Status = SampDsDoUniqueSearch(0,DomainObject,&SidAttr,Object);


Error:

    return Status;

}

NTSTATUS
SampMapDsErrorToNTStatus(
    ULONG   DsRetVal,
    COMMRES *ComRes
    )
/*++

Routine Description:

    Maps a DS error to NTSTATUS

Arguments:
    DsRetVal -- The DS return Value
    ComRes   -- The Common results structure, contains
                information regarding the error.

Return Values:
    See the switch statement below

--*/
{
    ULONG ExtendedErr = 0;

    if (   ComRes
        && ComRes->pErrInfo ) {

        ExtendedErr = ComRes->pErrInfo->AtrErr.FirstProblem.intprob.extendedErr;

    }

    if ( ExtendedErr == ERROR_DS_NAME_REFERENCE_INVALID ) {

        //
        // This will occur when trying to add a user to a group
        // and the user doesn't exist
        //
        return STATUS_NO_SUCH_USER;

    }

    return DirErrorToNtStatus( DsRetVal, ComRes );
}



NTSTATUS
SampSamToDsAttrBlock(
            IN SAMP_OBJECT_TYPE ObjectType,
            IN ATTRBLOCK  *AttrBlockToConvert,
            IN ULONG      ConversionFlags,
            IN PSID       DomainSid,
            OUT ATTRBLOCK * ConvertedAttrBlock
            )
/*++

Routine Description:

    Converts the Attribute types in an Attrblock
    from SAM to DS Types. This routine can do various things depending upon
    the flags that are passed in.

Arguments:

    ObjectType           -- specifies type of SAM object

    AttrBlockToConvert   -- pointer to Attrblock to be converted

    ConversionFlags      -- The Type of conversion Desired. Currently
                            defined values are

                            ALREADY_MAPPED_ATTRIBUTE_TYPES

                                This flag indicates that the attribue types
                                has alreade been mapped from SAM attribute types
                                to DS attribute types. So no need to map again.

                            REALLOC_IN_DSMEMORY

                                This flag indicates that the new attrblock to be created
                                requires its pAttr Structure and all values hanging off
                                this structure to be realloc'd using the DS thread memory.
                                The rationale for this is that the DS does not treat many
                                of the in parameters as strictly in-parameters but rather
                                reallocs them using the thread heap. This is typically done
                                in the AddEntry case ( to add default parameters ) etc.


                                REALLOC_IN_DSMEMORY must be specified if either the
                                ADD_OBJECT_CLASS_ATTRIBUTE is specified or if values are
                                present.

                            ADD_OBJECT_CLASS_ATTRIBUTE

                                This flag makes this routine to add the object class attribute
                                and also the corresponding SAM account types to the attr block.
                                This flag is also passed in during the AddEntry Case. The value
                                of the object class attribute is computed using the passed in
                                Sam Object Type.  REALLOC_IN_DSMEMORY must be specified if the
                                Add object class attribute flag is specified.


                            MAP_RID_TO_SID

                                In a number of places in the SAM code the SAM deals with Rids.
                                These are really stored as Sids in the DS. Passing this flag
                                uses the DomainSid parameter and maps all Rids to Sids.

                            DOMAIN_TYPE_BUILTIN

                                This flag is used with the ADD_OBJECT_CLASS_ATTRIBUTE. This flag
                                indicates that the security principal involved belongs to the
                                builtin domain. This is used in 2 ways

                                1. Determination of Object class when creating a domain object
                                   ( DOMAIN_DNS vs Builtin Domain )

                                2. Set System Flags, add an additional Group Type Bit etc when
                                   creating builtin domain security principals


                            IGNORE_GROUP_UNUSED_ATTR

                                Group Membership in the old registry based SAM was represented
                                using an array of Rids. The SAM buffers have space for it, and
                                the attrblock to SAM buffer conversion code still deals with this
                                To be sure that we never will ever write the old registry based
                                membership data to the DS, this flag tells this routine to skip
                                all the Group-Unused Attrs. It also asserts that this attribute
                                is never passed down.

                            SECURITY_DISABLED_GROUP_ADDITION

                                Indicates that this is a security disabled group. Used to set the
                                correct SAM account type.
                                
                            ADVANCED_VIEW_ONLY
                            
                                Indicates to create the object with the 
                                advanced view only set to TRUE
                                
                            FORCE_NO_ADVANCED_VIEW_ONLY
                            
                                Indicates to add the advanced view only and set
                                to FALSE.  This can be used to override schema
                                defaults (as was done in Windows 2000)

    DomainSid            -- Used to Compose the Sid of the Object when the MAP_RID_TO_SID flag is
                            specified.

    ConvertedAttrBlock   -- The Converted DS AttrBlock.


Return Values:
    None

--*/
{

    ULONG Index;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN  WellKnownAccount = FALSE;
    ULONG  DsSidAttr = SampDsAttrFromSamAttr(
                            SampUnknownObjectType,
                            SAMP_UNKNOWN_OBJECTSID
                            );

    ULONG  DsRidAttr = SampDsAttrFromSamAttr(
                            SampUnknownObjectType,
                            SAMP_UNKNOWN_OBJECTRID
                            );

    ULONG SamAccountControlBuffer, *SamAccountControl = NULL;

    ULONG ExtraAttrIndex;

    SAMTRACE("SampSamToDsAttrBlock");


    //
    // Both DOMAIN_TYPE_BUILTIN and ADVANCED_VIEW_ONLY add attributes
    // to the block, so this must be an addition.
    //
    ASSERT((ConversionFlags & DOMAIN_TYPE_BUILTIN)?
        (ConversionFlags & ADD_OBJECT_CLASS_ATTRIBUTE):TRUE);

    ASSERT((ConversionFlags & ADVANCED_VIEW_ONLY)?
        (ConversionFlags & ADD_OBJECT_CLASS_ATTRIBUTE):TRUE);

    ASSERT((ConversionFlags & FORCE_NO_ADVANCED_VIEW_ONLY)?
        (ConversionFlags & ADD_OBJECT_CLASS_ATTRIBUTE):TRUE);

    //
    // If Add Object Class attribute was specified then Realloc in
    // DS memory must be specified.
    //

    ASSERT((ConversionFlags & ADD_OBJECT_CLASS_ATTRIBUTE)?
        (ConversionFlags & REALLOC_IN_DSMEMORY):TRUE);



    //
    // Copy the Fixed Portion
    //

    ConvertedAttrBlock->attrCount = AttrBlockToConvert->attrCount;

    if (ConversionFlags & REALLOC_IN_DSMEMORY)
    {

        ULONG   AttrsToAllocate = AttrBlockToConvert->attrCount;

        if ((ConversionFlags & ADVANCED_VIEW_ONLY) ||
            (ConversionFlags & FORCE_NO_ADVANCED_VIEW_ONLY)) {

            AttrsToAllocate+=1;

        }

        if (ConversionFlags & DOMAIN_TYPE_BUILTIN)
        {
            //
            //  If this is a Builtin Domain Object.
            //  allocate 1 more attribute: ATT_SYSTEM_FLAGS
            //
            AttrsToAllocate+=1;
        }



        if (ConversionFlags & ADD_OBJECT_CLASS_ATTRIBUTE)
        {
            //
            //  Caller requested that an object class attribute
            //  be added, alloc two more attr, one for object class,
            //  one for Sam Account Type, one for group Type, and one
            //  if necessary for Critical System Object
            //

            AttrsToAllocate+=4 ;
        }

        //
        // Realloc and Copy the pAttr portion of it.
        //

        ConvertedAttrBlock->pAttr = DSAlloc(
                                        AttrsToAllocate
                                        * sizeof(ATTR)
                                        );

        if (NULL==ConvertedAttrBlock->pAttr)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }

        RtlCopyMemory(
            ConvertedAttrBlock->pAttr,
            AttrBlockToConvert->pAttr,
            AttrBlockToConvert->attrCount * sizeof(ATTR)
            );

        ConvertedAttrBlock->attrCount = AttrsToAllocate;

    }
    else
    {
        //
        // Assert that the caller has already allocated space
        // for the pAttr structure
        //

        ASSERT(ConvertedAttrBlock->pAttr!=NULL);

        //
        // Initialize that to Zero
        //

        RtlZeroMemory(
            ConvertedAttrBlock->pAttr,
            sizeof(ATTR) *ConvertedAttrBlock->attrCount
            );
    }

    for (Index=0; Index<AttrBlockToConvert->attrCount;Index++)
    {

        //
        // MAP Sam Attribute Types to DS Types if that was requested
        //

        if ( !(ConversionFlags & ALREADY_MAPPED_ATTRIBUTE_TYPES) )
        {
            ConvertedAttrBlock->pAttr[Index].attrTyp =
                    SampDsAttrFromSamAttr(
                        ObjectType,
                        AttrBlockToConvert->pAttr[Index].attrTyp
                        );
        }
        else
        {
            ConvertedAttrBlock->pAttr[Index].attrTyp =
                AttrBlockToConvert->pAttr[Index].attrTyp;
        }


        //
        //
        // Handle the Conversion of the Attribute Value
        //
        //

        if ( (ConversionFlags & MAP_RID_TO_SID)
             &&(ConvertedAttrBlock->pAttr[Index].attrTyp == DsRidAttr)
            )

        {
            //
            // if Attribute is Rid, Map Rid to Sid
            //

            ConvertedAttrBlock->pAttr[Index].attrTyp = DsSidAttr;
            Status = SampDsSetNewSidAttribute(
                        DomainSid,
                        ConversionFlags,
                        & (AttrBlockToConvert->pAttr[Index]),
                        & (ConvertedAttrBlock->pAttr[Index]),
                        & WellKnownAccount
                        );

            if (!(NT_SUCCESS(Status)))
                goto Error;
        }
        else if (NULL!= AttrBlockToConvert->pAttr[Index].AttrVal.pAVal)
        {

            //
            //  Else if a value is present then Copy the attribute
            //  value
            //


            Status = SampDsCopyAttributeValue(
                        & (AttrBlockToConvert->pAttr[Index]),
                        & (ConvertedAttrBlock->pAttr[Index])
                        );


            //
            // Translate User Account Control Values from SAM User Account control
            // to UF Values
            //

            if ((ATT_USER_ACCOUNT_CONTROL==ConvertedAttrBlock->pAttr[Index].attrTyp)
                    && ( NULL!=ConvertedAttrBlock->pAttr[Index].AttrVal.pAVal[0].pVal))
            {


                PULONG UserAccountControl;

                UserAccountControl = (ULONG*)ConvertedAttrBlock->pAttr[Index].AttrVal.pAVal[0].pVal;

                SamAccountControl = &SamAccountControlBuffer;
                SamAccountControlBuffer = *UserAccountControl;

                *UserAccountControl = SampAccountControlToFlags(*UserAccountControl);
            }
        }
        else
        {
            //
            // No Value is present, just zero out the value
            // portions
            //

            ConvertedAttrBlock->pAttr[Index].AttrVal.valCount=0;
            ConvertedAttrBlock->pAttr[Index].AttrVal.pAVal = NULL;
        }

    }

    //
    // If this is a Builtin Domain Object
    // then add ATT_SYSTEM_FLAGS
    //

    ExtraAttrIndex = AttrBlockToConvert->attrCount;
    if (ConversionFlags & DOMAIN_TYPE_BUILTIN)
    {

        ATTR    *SysFlagsAttr;


        SysFlagsAttr =
            &(ConvertedAttrBlock->pAttr[ExtraAttrIndex]);
        SysFlagsAttr->attrTyp = ATT_SYSTEM_FLAGS;
        SysFlagsAttr->AttrVal.valCount = 1;
        SysFlagsAttr->AttrVal.pAVal = DSAlloc(sizeof(ATTRVAL));

        if (NULL == SysFlagsAttr->AttrVal.pAVal)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }

        SysFlagsAttr->AttrVal.pAVal->valLen = sizeof(ULONG);
        SysFlagsAttr->AttrVal.pAVal->pVal = DSAlloc(sizeof(ULONG));

        if (NULL == SysFlagsAttr->AttrVal.pAVal->pVal)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }
        *((ULONG *) SysFlagsAttr->AttrVal.pAVal->pVal) =
                                        FLAG_DOMAIN_DISALLOW_RENAME |
                                        FLAG_DOMAIN_DISALLOW_MOVE   |
                                        FLAG_DISALLOW_DELETE ;

        ExtraAttrIndex++;

    }

    if (   (ConversionFlags & ADVANCED_VIEW_ONLY) 
        || (ConversionFlags & FORCE_NO_ADVANCED_VIEW_ONLY)) {

        ATTR    *HideFromABAttr;
        ULONG   Value;

        if (ConversionFlags & ADVANCED_VIEW_ONLY) {
            // TRUE
            Value = 1;
        } else {
            ASSERT((ConversionFlags & FORCE_NO_ADVANCED_VIEW_ONLY));
            // FALSE
            Value = 0;
        }

        HideFromABAttr =
            &(ConvertedAttrBlock->pAttr[ExtraAttrIndex]);
        HideFromABAttr->attrTyp = ATT_SHOW_IN_ADVANCED_VIEW_ONLY;
        HideFromABAttr->AttrVal.valCount = 1;
        HideFromABAttr->AttrVal.pAVal = DSAlloc(sizeof(ATTRVAL));

        if (NULL == HideFromABAttr->AttrVal.pAVal)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }

        HideFromABAttr->AttrVal.pAVal->valLen = sizeof(ULONG);
        HideFromABAttr->AttrVal.pAVal->pVal = DSAlloc(sizeof(ULONG));

        if (NULL == HideFromABAttr->AttrVal.pAVal->pVal)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }
        *((ULONG *) HideFromABAttr->AttrVal.pAVal->pVal)=Value;

    }

    //
    // If Addition of Object Class attribute was requested then
    // Add this attribute and the SAM_ACCOUNT_TYPE attribute
    //

    if (ConversionFlags & ADD_OBJECT_CLASS_ATTRIBUTE)
    {
        ULONG DsClass;
        ULONG SamAccountType;
        ATTR    *ObjectClassAttr;
        ATTR    *SamAccountTypeAttr;
        BOOLEAN SetSamAccountType = TRUE;
        BOOLEAN SetGroupType = TRUE;
        //ATTR    *GroupTypeAttr;
        ULONG   GroupType;
        BOOLEAN DcAccount=FALSE;


        //
        //  Find the object class, and SAM account type to Use
        //

        SampDsComputeObjectClassAndAccountType(
                ObjectType,
                SamAccountControl,
                ConversionFlags,
                &DsClass,
                &SamAccountType,
                &SetSamAccountType,
                &GroupType,
                &SetGroupType,
                &DcAccount
                );

        //
        // Set the object class Attr
        //

        ObjectClassAttr =
            &(ConvertedAttrBlock->pAttr[ConvertedAttrBlock->attrCount-4]);
        ObjectClassAttr->attrTyp = SampDsAttrFromSamAttr(
                                        SampUnknownObjectType,
                                        SAMP_UNKNOWN_OBJECTCLASS
                                    );
        ObjectClassAttr->AttrVal.valCount = 1;
        ObjectClassAttr->AttrVal.pAVal = DSAlloc(sizeof(ATTRVAL));
        if (NULL== ObjectClassAttr->AttrVal.pAVal)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }

        ObjectClassAttr->AttrVal.pAVal->valLen = sizeof(ULONG);
        ObjectClassAttr->AttrVal.pAVal->pVal = DSAlloc(sizeof(ULONG));
        if (NULL== ObjectClassAttr->AttrVal.pAVal->pVal)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }
        *((ULONG *) ObjectClassAttr->AttrVal.pAVal->pVal) = DsClass;


        //
        // Set the Sam Account Type attribute
        //

        if (SetSamAccountType)
        {
            SamAccountTypeAttr =
                &(ConvertedAttrBlock->pAttr[ConvertedAttrBlock->attrCount-3]);
            SamAccountTypeAttr->attrTyp = SampDsAttrFromSamAttr(
                                            SampUnknownObjectType,
                                            SAMP_UNKNOWN_ACCOUNT_TYPE
                                            );
            SamAccountTypeAttr->AttrVal.valCount = 1;
            SamAccountTypeAttr->AttrVal.pAVal = DSAlloc(sizeof(ATTRVAL));
            if (NULL== SamAccountTypeAttr->AttrVal.pAVal)
            {
                Status = STATUS_NO_MEMORY;
                goto Error;
            }

            SamAccountTypeAttr->AttrVal.pAVal->valLen = sizeof(ULONG);
            SamAccountTypeAttr->AttrVal.pAVal->pVal = DSAlloc(sizeof(ULONG));
            if (NULL== SamAccountTypeAttr->AttrVal.pAVal->pVal)
            {
                Status = STATUS_NO_MEMORY;
                goto Error;
            }
            *((ULONG *) SamAccountTypeAttr->AttrVal.pAVal->pVal) = SamAccountType;
        }
        else
        {
            //
            // Or current attrcount includes space for the Sam account type property.
            // Since we do not plan on setting it decrement the attrcount, to reflect
            // the true number of attrs that we want to set.
            //

            ConvertedAttrBlock->attrCount--;
        }

        //
        // Set the Group Account Type attribute
        //

        if ((SetGroupType)& (!(ConversionFlags & SUPPRESS_GROUP_TYPE_DEFAULTING)))
        {
            ATTR * GroupTypeAttr;

            GroupTypeAttr =
                &(ConvertedAttrBlock->pAttr[ConvertedAttrBlock->attrCount-2]);
            GroupTypeAttr->attrTyp = SampDsAttrFromSamAttr(
                                            SampGroupObjectType,
                                            SAMP_FIXED_GROUP_TYPE
                                            );
            GroupTypeAttr->AttrVal.valCount = 1;
            GroupTypeAttr->AttrVal.pAVal = DSAlloc(sizeof(ATTRVAL));
            if (NULL== GroupTypeAttr->AttrVal.pAVal)
            {
                Status = STATUS_NO_MEMORY;
                goto Error;
            }

            GroupTypeAttr->AttrVal.pAVal->valLen = sizeof(ULONG);
            GroupTypeAttr->AttrVal.pAVal->pVal = DSAlloc(sizeof(ULONG));
            if (NULL== GroupTypeAttr->AttrVal.pAVal->pVal)
            {
                Status = STATUS_NO_MEMORY;
                goto Error;
            }

            *((ULONG *) GroupTypeAttr->AttrVal.pAVal->pVal) = GroupType;
        }
        else
        {
            //
            // Or current attrcount includes space for the Sam account type property.
            // Since we do not plan on setting it decrement the attrcount, to reflect
            // the true number of attrs that we want to set.
            //

            ConvertedAttrBlock->attrCount--;
        }

        if (   (WellKnownAccount)
            || (DcAccount)
            || (ObjectType == SampServerObjectType)
            || (ObjectType == SampDomainObjectType) )
        {

            //
            // Set Critical System to 1
            //
            ATTR * CriticalAttr;

            CriticalAttr =
                &(ConvertedAttrBlock->pAttr[ConvertedAttrBlock->attrCount-1]);
            CriticalAttr->attrTyp = ATT_IS_CRITICAL_SYSTEM_OBJECT;
            CriticalAttr->AttrVal.valCount = 1;
            CriticalAttr->AttrVal.pAVal = DSAlloc(sizeof(ATTRVAL));
            if (NULL== CriticalAttr->AttrVal.pAVal)
            {
                Status = STATUS_NO_MEMORY;
                goto Error;
            }

            CriticalAttr->AttrVal.pAVal->valLen = sizeof(ULONG);
            CriticalAttr->AttrVal.pAVal->pVal = DSAlloc(sizeof(ULONG));
            if (NULL== CriticalAttr->AttrVal.pAVal->pVal)
            {
                Status = STATUS_NO_MEMORY;
                goto Error;
            }
            *((ULONG *) CriticalAttr->AttrVal.pAVal->pVal) = 1;
        }
        else
        {

            ConvertedAttrBlock->attrCount--;
        }

    }


Error:

    return Status;
}


VOID
SampDsComputeObjectClassAndAccountType(
    SAMP_OBJECT_TYPE ObjectType,
    ULONG            *SamAccountControl, OPTIONAL
    ULONG            Flags,
    PULONG           DsClass,
    PULONG           SamAccountType,
    BOOLEAN          *SamAccountTypePresent,
    PULONG           GroupType,
    BOOLEAN          *GroupTypePresent,
    BOOLEAN          *DcAccount
    )
/*++

    Routine Description

        Given an Object Type, and a attribute block that
        is being set ( as part of a create ), compute the correct
        DS object class , and the SAM account type for the object.
        This routine tries to walk the attr-block and tries to find
        the user account control property and uses this to compute the
        SAM object type value. This routine is called only during a create.
        This function also computes the Group type also if necessary

    Parameters:

        ObjectType     -- The SAM object type of the object,

        SamAccountControl --  the account control in terms of the SAM flags

        Flags          -- Flags specifier - currently no flags defined

        DsClass        -- The DS object class is returned in here.

        SamAccountType -- The SAM account type of the object is returned in here

        SamAccountTypePresent -- Boolen value, indicating wether Sam Account Type
                        property needs to be set for the given object type

        GroupType     -- For a group object , the default group type is set in here

        GroupTypePresent -- Indicates that the group type is present
--*/
{
    ULONG i;

    *DcAccount = FALSE;
    switch(ObjectType)
    {
    case SampUserObjectType:
        *DsClass = SampDsClassFromSamObjectType(ObjectType);
        *SamAccountType = SAM_USER_OBJECT;

        if ( ARGUMENT_PRESENT( SamAccountControl ) )
        {
            SampDsAccountTypeFromUserAccountControl(
                    *SamAccountControl,
                    SamAccountType
                    );

            if ( (*SamAccountControl) & USER_SERVER_TRUST_ACCOUNT )
                *DcAccount = TRUE;

        }

        // Set classid to computer for machine objects
        if (SAM_MACHINE_ACCOUNT == *SamAccountType) {
            *DsClass = CLASS_COMPUTER;
        }

        *SamAccountTypePresent = TRUE;
        *GroupTypePresent = FALSE;
        break;

    case SampGroupObjectType:
        *DsClass = SampDsClassFromSamObjectType(ObjectType);
        if (Flags & SECURITY_DISABLED_GROUP_ADDITION)
        {
            *SamAccountType = SAM_NON_SECURITY_GROUP_OBJECT;
        }
        else
        {
            *SamAccountType = SAM_GROUP_OBJECT;
        }
        *SamAccountTypePresent = TRUE;
        *GroupTypePresent = (Flags & SUPPRESS_GROUP_TYPE_DEFAULTING)?FALSE:TRUE;
        *GroupType = GROUP_TYPE_SECURITY_ENABLED|GROUP_TYPE_ACCOUNT_GROUP;
        break;

    case SampAliasObjectType:
        *DsClass = SampDsClassFromSamObjectType(ObjectType);
        if (Flags & SECURITY_DISABLED_GROUP_ADDITION)
        {
            *SamAccountType = SAM_NON_SECURITY_ALIAS_OBJECT;
        }
        else
        {
            *SamAccountType = SAM_ALIAS_OBJECT;
        }
        *SamAccountTypePresent = TRUE;
        *GroupTypePresent = (Flags & SUPPRESS_GROUP_TYPE_DEFAULTING)?FALSE:TRUE;
        *GroupType = GROUP_TYPE_SECURITY_ENABLED|GROUP_TYPE_RESOURCE_GROUP;
        if (Flags & DOMAIN_TYPE_BUILTIN)
        {
            (*GroupType)|=GROUP_TYPE_BUILTIN_LOCAL_GROUP;
        }
        break;

    case SampDomainObjectType:
        if (Flags & DOMAIN_TYPE_BUILTIN)
        {
            *DsClass = CLASS_BUILTIN_DOMAIN;
        }
        else
        {
            // 
            // SAM should not be creating objects of class domain save for the builtin
            // container that is crated at install time and handled as above
            // If we do get a creation assert as below -- indicates a coding error
            // and default the class to CLASS_DOMAIN_DNS
            //         

            *DsClass = CLASS_DOMAIN_DNS;

            //
            // Currently we know of no code that tries to create a
            // root domain object, therefore we think we should never
            // hit this code path
            //

            ASSERT(FALSE && " Should not be creating Domain object");
        }
        //
        // Domain objects do not have the sam account type property.
        // therefore do not set this on them
        //

        *SamAccountTypePresent = FALSE;
        *GroupTypePresent = FALSE;
        break;

    case SampServerObjectType:
        *DsClass = SampDsClassFromSamObjectType(ObjectType);
        *SamAccountTypePresent = FALSE;
        *GroupTypePresent = FALSE;
        break;

    default:
        ASSERT(FALSE && "Unknown Object Type");
    }


}


NTSTATUS
SampDsNewAccountSid(
    PSID DomainSid,
    ULONG AccountRid,
    PSID *NewSid
    )
/*
    Routine Description

        Composes an Account Sid from the given Domain Sid and Rid.
        Uses DS thread memory. THis is the main difference between
        the function in utility.c

    Arguments:

         DomainSid   The Domain Sid
         AccountRid  The Rid
         NewSid      The final account Sid

    Return Values

        STATUS_SUCCESS
        STATUS_NO_MEMORY
*/

{

    ULONG DomainSidLength = RtlLengthSid(DomainSid);
    NTSTATUS    Status = STATUS_SUCCESS;

    SAMTRACE("SampDsNewAccountSid");

    //
    // Alloc Memory to hold the account Sid
    //

    *NewSid = DSAlloc(DomainSidLength + sizeof(ULONG));

    if (NULL==*NewSid)
    {
        Status = STATUS_NO_MEMORY;
        goto Error;
    }

    //
    // Copy the Domain Sid Part
    //

    RtlCopyMemory(*NewSid,DomainSid,DomainSidLength);

    //
    // Increment the SubAuthority Count
    //

    ((UCHAR *) *NewSid)[1]++;

    //
    // Add the RID as a sub authority
    //

    *((ULONG *) (((UCHAR *) *NewSid ) + DomainSidLength)) =
            AccountRid;

Error:

    return Status;
}


NTSTATUS
SampDsSetNewSidAttribute(
    PSID DomainSid,
    ULONG ConversionFlags,
    ATTR *RidAttr,
    ATTR *SidAttr,
    BOOLEAN * WellKnownAccount
    )
/*
    Routine Description

        Composes a DS Sid Attr , given a DS Rid Attr

  Arguments:

        Conversion Flags

                Any Value that Can be passed to the Sam to DS attrblock
                conversion functions.

                Currently only used value is REALLOC_IN_DS_MEMORY
                REALLOC_IN_DS_MEMORY must be specified if an attribute
                value is actually present for the Rid.



        RidAttr

                Rid Attribute
        SidAttr

                The Sid Attribute that is composed
*/
{

    PSID NewSid = NULL;
    ULONG AccountRid;
    NTSTATUS Status = STATUS_SUCCESS;

    SAMTRACE("SampDsSetNewSidAttribute");

    *WellKnownAccount=FALSE;

    if (
         (RidAttr->AttrVal.valCount)
         && (RidAttr->AttrVal.pAVal)
         && (RidAttr->AttrVal.pAVal->pVal)
         && (RidAttr->AttrVal.pAVal->valLen)
         )
    {
        //
        // Values are Present, assert that REALLOC is also
        // specified
        //

        ASSERT(ConversionFlags & REALLOC_IN_DSMEMORY);
        ASSERT(DomainSid!=NULL);

        if (!(ConversionFlags & REALLOC_IN_DSMEMORY))
        {
            //
            // Realloc in DS memory is not specified
            //

            Status = STATUS_NOT_IMPLEMENTED;
            goto Error;
        }

        //
        // Compose New Sid
        //

        AccountRid = * ((ULONG *)RidAttr->AttrVal.pAVal->pVal);
        Status = SampDsNewAccountSid(DomainSid,AccountRid, &NewSid);
        if (!(NT_SUCCESS(Status)))
            goto Error;


        //
        // if the Account RID is less than the well known account RID
        // of 1000 then return that information to the caller. The caller
        // will use this information to mark the object as critical.

        if (SampIsAccountBuiltIn(AccountRid))
        {
            *WellKnownAccount = TRUE;
        }

        //
        //  Alloc Memory for ATTRVAL structure
        //

        SidAttr->AttrVal.pAVal =
                            DSAlloc(sizeof(ATTRVAL));

        if (NULL== SidAttr->AttrVal.pAVal)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }

        //
        // Set the Value to the New Sid
        //

        SidAttr->AttrVal.valCount = 1;
        SidAttr->AttrVal.pAVal->valLen = RtlLengthSid(NewSid);
        SidAttr->AttrVal.pAVal->pVal = NewSid;
    }
    else
    {
        SidAttr->AttrVal.valCount = 0;
        SidAttr->AttrVal.pAVal = NULL;
    }

Error:


    return Status;
}


NTSTATUS
SampDsCopyAttributeValue(
    ATTR * Src,
    ATTR * Dst
    )
/*
    Routine Description

        Copies a DS Attributes Value

    Arguments:

        Src - Source Attribute
        Dst - Destination Attribute

    Return Values

        STATUS_SUCCESS
        STATUS_NO_MEMORY

*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG    Index;

    if (
         (Src->AttrVal.valCount)
         && (Src->AttrVal.pAVal)
         )
    {
        //
        // Values are Present, Copy Them
        //

        Dst->AttrVal.pAVal = DSAlloc(
                                Src->AttrVal.valCount *
                                sizeof(ATTRVAL)
                                );

        if (NULL== Dst->AttrVal.pAVal)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }

        Dst->AttrVal.valCount = Src->AttrVal.valCount;

        for (Index=0;Index<Src->AttrVal.valCount;Index++)
        {

            Dst->AttrVal.pAVal[Index].valLen =
                    Src->AttrVal.pAVal[Index].valLen;

            if ((Src->AttrVal.pAVal[Index].valLen)
                && (Src->AttrVal.pAVal[Index].pVal))
            {

                Dst->AttrVal.pAVal[Index].pVal =
                    DSAlloc(Src->AttrVal.pAVal[Index].valLen);
                if (NULL== Dst->AttrVal.pAVal[Index].pVal)
                    {
                        Status = STATUS_NO_MEMORY;
                        goto Error;
                    }
                RtlCopyMemory(
                        Dst->AttrVal.pAVal[Index].pVal,
                        Src->AttrVal.pAVal[Index].pVal,
                        Dst->AttrVal.pAVal[Index].valLen
                        );
            }
            else
              Dst->AttrVal.pAVal[Index].pVal = NULL;
        }
    }
    else
    {
         Dst->AttrVal.pAVal = NULL;
         Dst->AttrVal.valCount = 0;
    }

Error:

    return Status;
}



NTSTATUS
SampDsToSamAttrBlock(
            IN SAMP_OBJECT_TYPE ObjectType,
            IN ATTRBLOCK * AttrBlockToConvert,
            IN ULONG     ConversionFlags,
            OUT ATTRBLOCK * ConvertedAttrBlock
            )
/*++

Routine Description:

    Converts the Attribute types in an Attrblock
    from DS to SAM Types

Arguments:

    ObjectType           -- specifies type of SAM object
    AttrBlockToConvert   -- pointer to Attrblock to be converted
    ConversionFlags      -- The Type of Conversion Desired. Currently
                            defined values are

                                ALREADY_MAPPED_ATTRIBUTE_TYPES
                                MAP_SID_TO_RID

    ConvertedAttrBlock   -- The converted AttrBlock.

Return Values:
    None


 --*/
 {
    ULONG Index,Index2;
    ULONG   DsSidAttr = SampDsAttrFromSamAttr(
                            SampUnknownObjectType,
                            SAMP_UNKNOWN_OBJECTSID
                            );

    ULONG   DsRidAttr = SampDsAttrFromSamAttr(
                            SampUnknownObjectType,
                            SAMP_UNKNOWN_OBJECTRID
                            );

    SAMTRACE("SampDsToSamAttrBlock");

    *ConvertedAttrBlock = *AttrBlockToConvert;

    for (Index=0; Index<AttrBlockToConvert->attrCount;Index++)
    {
        //
        // MAP Any Sid Attribute to Rid Attribute
        //

        if ((ConversionFlags & MAP_SID_TO_RID) &&
            (AttrBlockToConvert->pAttr[Index].attrTyp == DsSidAttr))

        {
            ATTR * pSidAttr =  &(AttrBlockToConvert->pAttr[Index]);

            switch(ObjectType)
            {
                case SampGroupObjectType:
                case SampAliasObjectType:
                case SampUserObjectType:

                    //
                    // Map the Attr Type
                    //

                    pSidAttr->attrTyp = DsRidAttr;

                    //
                    // Map the Attr Value, the Last ULONG in the Sid
                    // is the Rid, so advance the pointer accordingly
                    //

                    pSidAttr->AttrVal.pAVal->pVal+=
                        pSidAttr->AttrVal.pAVal->valLen - sizeof(ULONG);
                    pSidAttr->AttrVal.pAVal->valLen = sizeof(ULONG);

                default:
                    break;
            }
        }

        //
        //  MAP Attribute Types
        //

        if ( !(ConversionFlags & ALREADY_MAPPED_ATTRIBUTE_TYPES) )
        {
            ConvertedAttrBlock->pAttr[Index].attrTyp =
                SampSamAttrFromDsAttr(
                    ObjectType,
                    AttrBlockToConvert->pAttr[Index].attrTyp
                    );
        }

        //
        // Translate User Account Control From Flags which are stored in
        // the DS.
        //

        if ((SampUserObjectType==ObjectType)
                && (SAMP_FIXED_USER_ACCOUNT_CONTROL==ConvertedAttrBlock->pAttr[Index].attrTyp)
                && (NULL!=ConvertedAttrBlock->pAttr[Index].AttrVal.pAVal[0].pVal))
        {
            NTSTATUS IgnoreStatus;
            PULONG UserAccountControl;

            UserAccountControl = (ULONG*)ConvertedAttrBlock->pAttr[Index].AttrVal.pAVal[0].pVal;

            IgnoreStatus = SampFlagsToAccountControl(*UserAccountControl,UserAccountControl);
            // What's stored in the DS better be valid
            ASSERT(NT_SUCCESS(IgnoreStatus));
        }


    } // End of For Loop

    return STATUS_SUCCESS;

}


NTSTATUS
SampDsCreateDsName2(
            IN DSNAME * DomainObject,
            IN PUNICODE_STRING AccountName,
            IN ULONG           Flags,
            IN OUT DSNAME ** NewObject
            )
/*++
    Routine Description

        Builds a DSName given the account Name and  the Domain Object

  Arguments:

          DomainObject -- DSName of the Domain Object
          AccountName  -- The name of the account
          Flags        -- Controls operation of the routine
          NewObject    -- Returns the New DS Name in this object

  Return values:
          STATUS_SUCCESS - upon successful completion
          STATUS_NO_MEMORY - Memory alloc Failure

--*/
{


    NTSTATUS    Status = STATUS_SUCCESS;
    WCHAR       *CommonNamePart;
    ULONG       SizeofCommonNamePart = 0;
    WCHAR       CNPart[] = L"CN=";
    WCHAR       OUPart[] = L"OU=";
    ULONG       NewStructLen;
    ULONG       NewNameLen;
    UCHAR       *DomainNameStart;
    UCHAR       *CommonNamePartStart;
    UCHAR       *AccountNameStart;
    DSNAME      *LoopbackName;

    SAMTRACE("SampDsCreateDsName");

    if ( (Flags & SAM_USE_OU_FOR_CN) )
    {
        CommonNamePart = OUPart;
        SizeofCommonNamePart = sizeof( OUPart );
    }
    else
    {
        CommonNamePart = CNPart;
        SizeofCommonNamePart = sizeof( CNPart );
    }

    //
    // We need to handle two different conditions.
    //
    // 1) We got here because of a native Samr call (eg: user manager)
    //    in which case we construct a DN from the default domain
    //    container and use the account name as the RDN.
    //
    // 2) We got here because we're looping back from the DS in which
    //    case we want to use the DN which is stored in the loopback
    //    arguments.
    //

    if (( SampExistsDsLoopback(&LoopbackName) )
        && (!(Flags & SAM_NO_LOOPBACK_NAME)))
    {
        *NewObject = MIDL_user_allocate(LoopbackName->structLen);

        if ( NULL == *NewObject )
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }

        RtlCopyMemory(*NewObject, LoopbackName, LoopbackName->structLen);

        Status = STATUS_SUCCESS;
    }

    else
    {
        WCHAR EscapeBuffer[MAX_RDN_SIZE+1];
        UNICODE_STRING EscapedAccountName;

        //
        // Non-loopback case.  Compute the New Name Length
        //

        //
        // Escape the Account Name
        //

        EscapedAccountName.Buffer = EscapeBuffer;
        EscapedAccountName.Length = 0;
        EscapedAccountName.MaximumLength = sizeof(EscapeBuffer);

        Status = SampEscapeAccountName(AccountName,&EscapedAccountName);
        if (!NT_SUCCESS(Status))
        {
            goto Error;
        }

        NewNameLen  = DomainObject->NameLen +                     // Name Len of Domain
                        (EscapedAccountName.Length) /sizeof(WCHAR) +    // Name Len of Account
                        SizeofCommonNamePart/sizeof(WCHAR) - 1+ // Len of CN=
                        1;                                        // 1 for Comma
        //
        // Compute the new structure length
        //

        NewStructLen =  DSNameSizeFromLen(NewNameLen);

        //
        // Allocate space for the new Object
        //

        *NewObject = MIDL_user_allocate(NewStructLen);

        if (*NewObject == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }

        //
        // Compute the starting locations of DomainName , cn= and Account Name Parts
        //

        CommonNamePartStart = (UCHAR *) &((*NewObject)->StringName);
        AccountNameStart    = CommonNamePartStart + SizeofCommonNamePart - sizeof(WCHAR);
        DomainNameStart     = AccountNameStart + (EscapedAccountName.Length)
                                               + sizeof(WCHAR); // For Comma

        //
        // Zero out the GUID
        //

        RtlZeroMemory(&((*NewObject)->Guid), sizeof(GUID));


        //
        // Copy Common Name Part
        //

        RtlCopyMemory(
           CommonNamePartStart,
           CommonNamePart,
           SizeofCommonNamePart - sizeof(WCHAR)
           );

        //
        //  Copy Account Name Part
        //

         RtlCopyMemory(
            AccountNameStart,
            EscapedAccountName.Buffer,
            EscapedAccountName.Length
            );

        //
        // Add The Comma before Domain Name Part
        //

        *((UNALIGNED WCHAR *)DomainNameStart -1) = L',';

        //
        // NULL terminate the DSNAME
        //

        (*NewObject)->StringName[NewNameLen] = 0;

        //
        // Copy the Domain name part
        //

        RtlCopyMemory(
            DomainNameStart,
            &(DomainObject->StringName),
            (DomainObject->NameLen) * sizeof(WCHAR)
            );

        //
        // Initialize all the fields
        //
        (*NewObject)->NameLen = NewNameLen;
        (*NewObject)->structLen = NewStructLen;
        (*NewObject)->SidLen = 0;

    }



Error:

    return Status;
}

NTSTATUS
SampDsCreateAccountObjectDsName(
    IN  DSNAME *DomainObject,
    IN  PSID    DomainSid OPTIONAL,
    IN  SAMP_OBJECT_TYPE ObjectType,
    IN  PUNICODE_STRING AccountName,
    IN  PULONG  AccountRid OPTIONAL,
    IN  PULONG  UserAccountControl OPTIONAL,
    IN  BOOLEAN BuiltinDomain,
    OUT DSNAME  **AccountObject
    )
/*++

    Routine Description

        This Routine Creates an Account Object's DSNAME,

    Parameters
        Domain Object  DSNAME of the domain Object
        ObjectType     The SAM object Type
        AccountName    Account Name of the Account to be created
        UserAccountControl Optional Argument passing in the user account
                        control field
        BuiltinDomain   TRUE, indicates that the domain is a builtin domain
                        in which case no containers will be prepended
        AccountObject   Account Object is returned in here

    Return Values
        STATUS_SUCCESS
        Other Error Codes upon Creation
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;


    ASSERT((SampUserObjectType==ObjectType)||
            (SampAliasObjectType==ObjectType)
            || (SampGroupObjectType==ObjectType));


    if (BuiltinDomain)
    {
        //
        // Everything is children of Root for Builtin Domain
        //

        return(SampDsCreateDsName(DomainObject,AccountName,
                    AccountObject));
    }

    //
    // We Must prepend a Container path
    //

    if ((SampUserObjectType==ObjectType)
        &&(ARGUMENT_PRESENT(UserAccountControl))
        &&((*UserAccountControl & USER_WORKSTATION_TRUST_ACCOUNT)
            ||(*UserAccountControl & USER_SERVER_TRUST_ACCOUNT)))
    {
        UNICODE_STRING ComputerName;

        //
        // Machine Account
        //

        //
        // Trim the dollar at the end of the account name ( if account
        // name ends with $)
        //

        RtlCopyMemory(&ComputerName,AccountName,sizeof(UNICODE_STRING));
        if (L'$'==ComputerName.Buffer[ComputerName.Length/2-1])
        {
            ComputerName.Length-=sizeof(USHORT);
        }

        if ( (*UserAccountControl & USER_SERVER_TRUST_ACCOUNT)
           && SampDefaultContainerExists( *UserAccountControl ) )
        {
            //
            // domain controller
            //

            ASSERT(SampDomainControllersOUDsName);

            NtStatus = SampDsCreateDsName(
                            SampDomainControllersOUDsName,
                            &ComputerName,
                            AccountObject
                            );

        }
        else
        {
            //
            // Computers Container
            //

            ASSERT(SampComputersContainerDsName);

            NtStatus = SampDsCreateDsName(
                            SampComputersContainerDsName,
                            &ComputerName,
                            AccountObject
                            );
        }
    }
    else
    {
        //
        // User Group or Alias Account
        //

        if (NT_SUCCESS(NtStatus))
        {
            DSNAME  *LoopbackName = NULL;

            ASSERT(SampUsersContainerDsName);

            if (((SampGroupObjectType == ObjectType) ||
                 (SampAliasObjectType == ObjectType)) &&
                 (ARGUMENT_PRESENT(AccountRid)) &&
                !SampExistsDsLoopback(&LoopbackName) )
            {
                ATTRVAL     AttValCN;
                BOOL        UseSidName = FALSE;
                //
                // come from downlevel API (not a Loopback case), then
                // check whether the samAccountName can be used as
                // a valid CN or not
                //
                AttValCN.valLen = AccountName->Length;
                AttValCN.pVal = (PUCHAR) AccountName->Buffer;
                UseSidName = DsCheckConstraint(ATT_COMMON_NAME,
                                               &AttValCN,
                                               TRUE      // also check RDN
                                               );
                if (!UseSidName)
                {
                    // The samAccountName is not a valid CN
                    // We will use the SID string as the CN instead
                    PSID    AccountSid = NULL;

                    NtStatus = SampCreateFullSid(DomainSid,
                                                 *AccountRid,
                                                 &AccountSid);

                    if (NT_SUCCESS(NtStatus))
                    {
                        UNICODE_STRING  SidName;

                        RtlZeroMemory(&SidName, sizeof(UNICODE_STRING));
                        NtStatus = RtlConvertSidToUnicodeString(&SidName,
                                                                AccountSid,
                                                                TRUE );

                        if (NT_SUCCESS(NtStatus))
                        {
                            NtStatus = SampDsCreateDsName(
                                            SampUsersContainerDsName,
                                            &SidName,
                                            AccountObject
                                            );

                            // free memory
                            RtlFreeUnicodeString(&SidName);
                        }

                        // free memory
                        MIDL_user_free(AccountSid);
                    }
                }
                else
                {
                    //
                    // samAccountName can be used as valid CN
                    //
                    NtStatus = SampDsCreateDsName(
                                    SampUsersContainerDsName,
                                    AccountName,
                                    AccountObject
                                    );
                }
            }
            else
            {
                //
                // User Account(Downlevel API or Loopback)
                //      Use Account Name as CN
                // Group/Alias in Loopback case
                //      Use DsName cached in Loopback
                //
                NtStatus = SampDsCreateDsName(
                                SampUsersContainerDsName,
                                AccountName,
                                AccountObject
                                );
            }
        }
    }

    return NtStatus;

}



void
SampInitializeDsName(
                     IN DSNAME * pDsName,
                     IN WCHAR * NamePrefix,
                     IN ULONG NamePrefixLen,
                     IN WCHAR * ObjectName,
                     IN ULONG NameLen
                     )
/*++

Routine Description:
    Initializes a DSNAME structure

Arguments:
    pDsName -- A pointer to a buffer large enough to hold everything. This
               buffer will be filled with a NULL GUID plus a complete name

    NamePrefix -- pointer to a sequence of NULL terminated
                  UNICODE chars holding any prefix
                  to the name. Useful  in composing
                  hierarchial names

    NamePrefixLen -- Length of the Prefix in bytes. Also includes the
                     NULL terminator

    ObjectName -- pointer to a sequence of NULL terminated
                  UNICODE char the name of the object

    NameLen    --   Length of the Object Name in bytes. Also includes the
                    NULL terminator, even though the DSNAME field does not.


 Return Values:

     None

--*/
{
    SAMTRACE("SampInitializeDsName");

    //
    // Single NULL string is not allowed for name or Prefix
    //

    ASSERT(NamePrefixLen!=sizeof(WCHAR));
    ASSERT(NameLen!=sizeof(WCHAR));

    //
    // Zero the GUID
    //

    RtlZeroMemory(&(pDsName->Guid), sizeof(GUID));

    //
    // Compute String Length not including Null terminator
    //

    if (NamePrefix)
    {

        UCHAR       *NameStart;
        UCHAR       *CommaStart;
        UCHAR       *PrefixStart;

        // Exclude NULL characters in Name and Prefix strings
        pDsName->NameLen = (NameLen + NamePrefixLen) / sizeof(WCHAR)
                           - 2    // for null characters
                           + 1;   // for comma

        //
        // Compute the Struct length
        //

        pDsName->structLen = DSNameSizeFromLen(pDsName->NameLen);

        NameStart   = (UCHAR*) &(pDsName->StringName[0]);
        CommaStart  = NameStart + NameLen - sizeof(WCHAR);
        PrefixStart = CommaStart + sizeof(WCHAR);

        //
        // Copy the Object Name
        //

        RtlCopyMemory(NameStart, ObjectName, NameLen);

        //
        // Copy the comma
        //

        RtlCopyMemory(CommaStart, L",", sizeof(WCHAR));

        //
        // Copy the name Prefix
        //

        RtlCopyMemory(PrefixStart, NamePrefix, NamePrefixLen);


    }
    else
    {
        pDsName->NameLen = (NameLen/sizeof(WCHAR)) - 1;

        //
        // Compute the Struct length
        //

        pDsName->structLen = DSNameSizeFromLen(pDsName->NameLen);

        //
        // Copy the Object Name
        //

        RtlCopyMemory(&(pDsName->StringName[0]), ObjectName, NameLen);
    }

}


PVOID
DSAlloc(
        IN ULONG Length
        )
/*++

  Routine Description:

        Ds Memory Allocation Routine

  Arguments:

      Length - Amount of memory to be allocated

  Return Values

    NULL if Memory alloc failed
    Pointer to memory upon success
--*/
{
    PVOID MemoryToReturn = NULL;

    // Must have a DS transaction (i.e. valid thread state)
    // else there is no thread local allocator!

    ASSERT(SampExistsDsTransaction());

    MemoryToReturn = THAlloc(Length);

    return MemoryToReturn;
}


NTSTATUS
SampDsBuildRootObjectName()
/*++

  Routine Description:

        Initializes the Global variable that holds the
        name of the Root Object

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    DWORD    Size = 0;

    if ( !RootObjectName )
    {
        NtStatus = GetConfigurationName( DSCONFIGNAME_DOMAIN,
                                         &Size,
                                         RootObjectName );

        ASSERT( STATUS_BUFFER_TOO_SMALL == NtStatus );
        if ( STATUS_BUFFER_TOO_SMALL == NtStatus )
        {
            RootObjectName = (DSNAME*) MIDL_user_allocate( Size );
            if ( RootObjectName )
            {
                RtlZeroMemory( RootObjectName, Size );
                NtStatus = GetConfigurationName( DSCONFIGNAME_DOMAIN,
                                                 &Size,
                                                 RootObjectName );
            }
            else
            {
                NtStatus = STATUS_NO_MEMORY;
            }
        }
    }

    return NtStatus;

}


NTSTATUS
SampDsGetWellKnownContainerDsName(
    IN  DSNAME  *DomainObject,
    IN  GUID    *WellKnownGuid,
    OUT DSNAME  **ContainerObject
    )
/*++
Routine Description

    The routine will read core DS, trying to find the wellknown container's
    dsname based on the well known GUID publiched in ntdsapi.h. Even the
    wellknown container has been renamed, DS still has logic to find them.
    As far as Users Container, Computers Container and Domain Controllers
    OU, they can not be renamed, deleted or moved according to the schema.

    The caller should have a DS transaction open. And it is the responsbility
    of caller to close the transaction.

Parameters:

    DomainObject - pointer to the Domain Object's DsName

    WellKnowGuid - pointer to the well known guid published in ntdsapi.h

    ContainerObject - return the read result

Return Value:

    STATUS_SUCCESS

    NtStatus from DirRead
--*/

{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    READARG     ReadArg;
    READRES     *ReadRes = NULL;
    DSNAME      *ReadDsName = NULL;
    DSNAME      *LoopbackName;
    ENTINFSEL   EntInfSel;
    ULONG       Size = 0, Length = 0;
    ULONG       DirError = 0;


    SAMTRACE("SampDsGetWellKnownContainerDsName");


    //
    // ASSERT we have an open transaction
    //
    ASSERT( SampExistsDsTransaction() );

    //
    // Get Domain Object's String Name
    // required by DirRead, with Domain Object's String Name,
    // we can not get the well known container's DsName
    //
    // Core DS requires Domain Object's String Name and
    // published well known container's GUID to find
    // the ds name for that well known container.
    //

    Length = DomainObject->NameLen;
    ASSERT(Length && "DomainObject's String Name should not be NULL");

    Size = DSNameSizeFromLen( Length );
    SAMP_ALLOCA(ReadDsName , Size );
    if (NULL==ReadDsName)
    {
         return(STATUS_INSUFFICIENT_RESOURCES);
    }
    RtlZeroMemory( ReadDsName, Size );

    ReadDsName->structLen = Size;
    ReadDsName->NameLen = Length;
    wcscpy( ReadDsName->StringName, DomainObject->StringName );
    ReadDsName->Guid = *WellKnownGuid;

    //
    // Build the ReadArg structure
    //

    memset(&ReadArg, 0, sizeof(READARG));
    memset(&EntInfSel, 0, sizeof(ENTINFSEL));

    ReadArg.pObject = ReadDsName;
    ReadArg.pSel = &EntInfSel;

    EntInfSel.attSel = EN_ATTSET_LIST;
    EntInfSel.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EntInfSel.AttrTypBlock.attrCount = 1;
    SAMP_ALLOCA(EntInfSel.AttrTypBlock.pAttr,sizeof(ATTR));
    if (NULL==EntInfSel.AttrTypBlock.pAttr)
    {
         return(STATUS_INSUFFICIENT_RESOURCES);
    }
    RtlZeroMemory(EntInfSel.AttrTypBlock.pAttr, sizeof(ATTR));
    EntInfSel.AttrTypBlock.pAttr[0].attrTyp = ATT_OBJ_DIST_NAME;

    BuildStdCommArg( &(ReadArg.CommArg) );

    //
    // Read Core DS
    //

    DirError = DirRead( &ReadArg, &ReadRes );

    //
    // Map the return error
    //

    if (ReadRes)
    {
        NtStatus = SampMapDsErrorToNTStatus( DirError, &ReadRes->CommRes );
    }
    else
    {
        NtStatus = STATUS_NO_MEMORY;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        goto Cleanup;
    }

    //
    // fill the container object's dsname if we find that container
    //

    Size = ReadRes->entry.pName->structLen;

    *ContainerObject = MIDL_user_allocate( Size );

    if (NULL == *ContainerObject)
    {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlZeroMemory(*ContainerObject, Size);
    RtlCopyMemory(*ContainerObject,
                  ReadRes->entry.pName,
                  Size
                  );

Cleanup:

    //
    // ASSERT we still have the transaction opened
    //
    ASSERT( SampExistsDsTransaction() );

    return NtStatus;
}




NTSTATUS
SampInitWellKnownContainersDsName(
    IN DSNAME *DomainObject
    )
/*++
Routine Description:

    This routine will initilize these well known containers' DsName including
    Domain Controllers OU, Users Container and Computers Container.

    NOTE: SHOULD NOT have an open transaction while calling this routine.

Parameters:

    DomainObject - pointer to the Domain Object's ds name.

Return Values:

    STATUS_SUCCESS,
    STATUS_NO_MEMORY,
    error returned from SampDsGetWellKnownContainerDsName

--*/
{
    ULONG   NtStatus = STATUS_SUCCESS;


    SAMTRACE("SampInitWellKnownContainersDsName");


    //
    // Should not have an open transaction while calling this routine.
    //

    ASSERT( !SampExistsDsTransaction() );

    __try
    {
        //
        // Open a DS transaction
        //
        NtStatus = SampMaybeBeginDsTransaction( TransactionRead );

        if (!NT_SUCCESS(NtStatus))
        {
            __leave;
        }

        //
        // should free all the previous cached well known
        // containers' dsname.
        //

        if (NULL != SampDomainControllersOUDsName)
        {
            MIDL_user_free(SampDomainControllersOUDsName);
            SampDomainControllersOUDsName = NULL;
        }

        //
        // query DS to get the latest (most updated)
        // well known containers' dsname.
        //

        NtStatus = SampDsGetWellKnownContainerDsName(
                                DomainObject,
                                (GUID *) GUID_DOMAIN_CONTROLLERS_CONTAINER_BYTE,
                                &SampDomainControllersOUDsName
                                );

        if (!NT_SUCCESS(NtStatus))
        {
            __leave;
        }

        //
        // do the same thing on Computers Container
        //

        if (NULL != SampComputersContainerDsName)
        {
            MIDL_user_free(SampComputersContainerDsName);
            SampComputersContainerDsName = NULL;
        }

        NtStatus = SampDsGetWellKnownContainerDsName(
                                DomainObject,
                                (GUID *) GUID_COMPUTRS_CONTAINER_BYTE,
                                &SampComputersContainerDsName
                                );

        if (!NT_SUCCESS(NtStatus))
        {
            __leave;
        }

        if (NULL != SampUsersContainerDsName)
        {
            MIDL_user_free(SampUsersContainerDsName);
            SampUsersContainerDsName = NULL;
        }

        NtStatus = SampDsGetWellKnownContainerDsName(
                                DomainObject,
                                (GUID *) GUID_USERS_CONTAINER_BYTE,
                                &SampUsersContainerDsName
                                );

        
        if (!NT_SUCCESS(NtStatus))
        {
            __leave;
        }
        
        
    }
    __finally
    {
        SampMaybeEndDsTransaction( TransactionCommit );
    }

    return NtStatus;
}




NTSTATUS
SampEscapeAccountName(
    IN PUNICODE_STRING AccountName,
    IN OUT PUNICODE_STRING EscapedAccountName
    )
/*++

    Routine Description

        Given an Account Name, this routine scans the string to find wether an
        invalid RFC1779 Character is present. If so the string is then quoted and
        depending upon the character, the character might be paired. Pairing a
        character in RFC1779 is same as escaping with a "\"


            For example

                  MS1  will yield  MS1
                  MS#1 will yield "MS#1"
                  MS"1 will yield "MS\"1"
    Parameters

        AccountName -- The account Name to escape
        EscapedAccount Name -- The Escaped Account Name

    Return Values

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       NumQuotedRDNChars=0;

    NumQuotedRDNChars = QuoteRDNValue(
                            AccountName->Buffer,
                            AccountName->Length/sizeof(WCHAR),
                            EscapedAccountName->Buffer,
                            EscapedAccountName->MaximumLength/sizeof(WCHAR)
                            );
    if (   (NumQuotedRDNChars == 0)
        || (NumQuotedRDNChars > EscapedAccountName->MaximumLength/sizeof(WCHAR)))
    {
        Status = STATUS_UNSUCCESSFUL;
    }
    else {
        EscapedAccountName->Length = (USHORT) NumQuotedRDNChars * sizeof(WCHAR);
        EscapedAccountName->MaximumLength = (USHORT) NumQuotedRDNChars * sizeof(WCHAR);
    }

    return Status;
}

VOID
SampDsAccountTypeFromUserAccountControl(
    ULONG   UserAccountControl,
    PULONG  SamAccountType
    )
/*++

    Routine Description

        This routined computes a SAM account type attribute value,
        given the user account control field of a user object

    Parameters
        UserAccountControl  -- The User account control field
        SamAccountType  -- Computed Sam account type value is
                           returned in here
--*/
{
    if ((UserAccountControl & USER_WORKSTATION_TRUST_ACCOUNT)
        || ( UserAccountControl & USER_SERVER_TRUST_ACCOUNT))
    {
        *SamAccountType = SAM_MACHINE_ACCOUNT;
    }
    else if (UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT)
    {
        *SamAccountType = SAM_TRUST_ACCOUNT;
    }
    else
    {
        *SamAccountType = SAM_NORMAL_USER_ACCOUNT;
    }

}


NTSTATUS
SampCopyRestart(
    IN  PRESTART OldRestart,
    OUT PRESTART *NewRestart
    )
/*++

  Routine Description:

        This Routine Copies a Restart Structure

  Arguments:

    OldRestart - Old Structure
    NewRestart - New Structure

  Return Values:

        STATUS_SUCCESS
        STATUS_NO_MEMORY

  --*/
{
    NTSTATUS    Status = STATUS_SUCCESS;

    *NewRestart = NULL;
    if (OldRestart!=NULL)
    {
        // Alloc memory for 1 restart structure
        *NewRestart = MIDL_user_allocate(OldRestart->structLen);
        if (NULL == *NewRestart)
        {
            Status = STATUS_NO_MEMORY;
        }
        else {
            memcpy((*NewRestart),OldRestart,OldRestart->structLen);
        }
    }

    return Status;
}


ULONG
Ownstrlen(
    CHAR * Sz
   )
/*++

  Routine Description

    String Length function for ASCII Null terminated strings. Own version
    as we are not yet inclined to use C-Runtime

  Arguments

    Sz - NULL terminated String Whose lenght we eant to count

  Return Values

    Length of String

--*/
{
    ULONG   Count = 0;

    ASSERT(Sz);

    while (*Sz)
    {
        Sz++;
        Count++;
    }

    return Count;
}

VOID
BuildDsNameFromSid(
    PSID Sid,
    DSNAME * DsName
    )
/*++

  Builds a Ds Name from a SID that contains only a SID

    Parameters

        Sid -- Pointer to SID
        DsName -- Pointer to DSNAME

  --*/
{
    RtlZeroMemory(DsName,sizeof(DSNAME));
    DsName->structLen =
                        DSNameSizeFromLen(DsName->NameLen);
    DsName->SidLen = RtlLengthSid(Sid);
    RtlCopyMemory(
        &(DsName->Sid),
        Sid,
        RtlLengthSid(Sid)
        );
}

ATTR *
SampDsGetSingleValuedAttrFromAttrBlock(
    IN ATTRTYP attrTyp,
    IN ATTRBLOCK * AttrBlock
    )
/*++

    Given an AttrBlock, this routine walks through the attrblock
    and returns the first pAttr structure that matches the attribute
    specified through the attrTyp parameter. This routine makes the
    assumption that attribute is single valued

    Parameters:

        attrTyp : Attribute type to find
        Attrblock -- Specifies to the set of attributes, where we need
                     to look

    Return Values

        Address of the pAttr, if found, NULL if not

--*/
{
    ULONG i;

    for (i=0;i<AttrBlock->attrCount;i++)
    {
        if ((AttrBlock->pAttr[i].attrTyp == attrTyp)
            && (1==AttrBlock->pAttr[i].AttrVal.valCount)
            && (NULL!=AttrBlock->pAttr[i].AttrVal.pAVal[0].pVal)
            && (0!=AttrBlock->pAttr[i].AttrVal.pAVal[0].valLen))
        {
            return (&(AttrBlock->pAttr[i]));
        }
    }

    return NULL;
}



NTSTATUS
SampDsChangeAccountRDN(
    IN PSAMP_OBJECT Context,
    IN PUNICODE_STRING NewAccountName
    )

/*++
Routine Description:

    This routine changes the RDN of a user account, when the user
    account is changed.

    THIS SERVICE MUST BE CALLED WITH THE TRANSACTION DOMAIN SET.

Arguments:

    Context - Points to the User context whose name is to be changed.

    NewAccountName - New name to give this account

Return Value:


    STATUS_SUCCESS - The information has been retrieved.

    Other status values that may be returned by:
--*/
{

    NTSTATUS    NtStatus = STATUS_SUCCESS;
    ENTINFSEL   EntInf;
    READARG     ReadArg;
    READRES     *pReadRes = NULL;
    MODIFYDNARG ModifyDNArg;
    MODIFYDNRES *pModifyDNRes = NULL;
    COMMARG     *pCommArg = NULL;
    ATTRVAL     RDNAttrVal;
    ATTR        RDNAttr;
    ULONG       RetValue;


    SAMTRACE("SampDsChangeMachineAccountRDN");

    NtStatus = SampDoImplicitTransactionStart(TransactionWrite);

    if (NtStatus != STATUS_SUCCESS)
        return NtStatus;


    EntInf.attSel = EN_ATTSET_LIST;
    EntInf.infoTypes = EN_INFOTYPES_TYPES_VALS;
    EntInf.AttrTypBlock.attrCount = 0;
    EntInf.AttrTypBlock.pAttr = NULL;

    memset( &ReadArg, 0, sizeof(READARG) );
    ReadArg.pObject = Context->ObjectNameInDs;
    ReadArg.pSel = &EntInf;
    pCommArg = &(ReadArg.CommArg);
    BuildStdCommArg(pCommArg);

    SAMTRACE_DS("DirRead\n");

    RetValue = DirRead(&ReadArg, &pReadRes);

    SAMTRACE_RETURN_CODE_DS(RetValue);

    if (NULL==pReadRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetValue, &pReadRes->CommRes);
    }

    if (NtStatus != STATUS_SUCCESS)
        goto Error;


    RDNAttr.attrTyp = ATT_COMMON_NAME;
    RDNAttr.AttrVal.valCount = 1;
    RDNAttr.AttrVal.pAVal = &RDNAttrVal;

    // Trim the dollar at the end of machine account name.
    if (L'$'==NewAccountName->Buffer[NewAccountName->Length/2-1])
    {
        RDNAttrVal.valLen = NewAccountName->Length - sizeof(WCHAR);
    }
    else
    {
        RDNAttrVal.valLen = NewAccountName->Length;
    }
    RDNAttrVal.pVal = (PUCHAR)NewAccountName->Buffer;

    memset( &ModifyDNArg, 0, sizeof(MODIFYDNARG) );
    ModifyDNArg.pObject = pReadRes->entry.pName;
    ModifyDNArg.pNewRDN = &RDNAttr;
    pCommArg = &(ModifyDNArg.CommArg);
    BuildStdCommArg(pCommArg);

    SAMTRACE_DS("DirModifyDN\n");

    RetValue = DirModifyDN(&ModifyDNArg, &pModifyDNRes);

    SAMTRACE_RETURN_CODE_DS(RetValue);

    if (NULL==pModifyDNRes)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }
    else
    {
        NtStatus = SampMapDsErrorToNTStatus(RetValue,&pModifyDNRes->CommRes);
    }


Error:

    SampClearErrors();

    return NtStatus;

}


BOOLEAN
SampDefaultContainerExists(
    IN ULONG AccountControl
    )
/*++
Routine Description:

    This routine determines if the well known ou container for SAM
    objects exists.

    This routine assumes a current transaction.

    //
    // Note: this code is needed because although the containers are well known
    // and hence cannot be renamed or deleted, the Domain Controllers
    // OU was not added until after the last incompatible build was
    // released.  So, theoretically, some domains could exist without
    // this OU
    //

Arguments:

    AccountControl : the type of account object

Return Value:

    TRUE if it exists; FALSE otherwise

--*/
{
    if ( AccountControl & USER_SERVER_TRUST_ACCOUNT )
    {
        return SampDomainControllersOUExists;
    }
    else if ( AccountControl & USER_WORKSTATION_TRUST_ACCOUNT )
    {
        return SampComputersContainerExists;
    }
    else
    {
        // every else goes into Users
        return SampUsersContainerExists;
    }

}


VOID
SampMapSamAttrIdToDsAttrId(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN OUT ATTRBLOCK * AttributeBlock
    )

/*++

Routine Description:

Parameters:

Return Values:

--*/

{
    ULONG Index, DsAttrTyp;

    SAMTRACE("SampMapAttrIdToAttrId");

    if (NULL == AttributeBlock)
    {
        return;
    }

    for (Index = 0; Index < AttributeBlock->attrCount; Index++)
    {
        DsAttrTyp = SampDsAttrFromSamAttr(
                        ObjectType,
                        AttributeBlock->pAttr[Index].attrTyp
                        );

        AttributeBlock->pAttr[Index].attrTyp = DsAttrTyp;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\dsutilp.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dsutilp.h

Abstract:

    This file contains definitions private to the SAM server program.

Author:

    Chris Mayhall (ChrisMay) 09-May-1996

Environment:

    User Mode - Win32

Revision History:

    ChrisMay    09-May-1996
        Created initial file.

--*/

#ifndef _DSUTILP_H_
#define _DSUTILP_H_

// Include DSA header files to resolve READARG, READRES, etc.

#include <ntdsa.h>      // public DS data types 

// Wrap the DS typedefs with private typedefs to insulate the SAM code from
// onging changes to the DS structure names.

typedef READRES         DSDATA, *PDSDATA;
typedef ATTR            DSATTR, *PDSATTR;
typedef ATTRVAL         DSATTRVAL, *PDSATTRVAL;
typedef ATTRBLOCK       DSATTRBLOCK, *PDSATTRBLOCK;
typedef ATTRVALBLOCK    DSATTRVALBLOCK, *PDSATTRVALBLOCK;
typedef ATTRMODLIST     DSATTRMODLIST, *PDSATTRMODLIST;

//
// The following type is used to identify which grouping of attribute
// (fixed or variable-length) are being refered to in a number of api.
//

#define SAMP_FIXED_ATTRIBUTES       (0L)
#define SAMP_VARIABLE_ATTRIBUTES    (1L)

// BUG: Defining BOGUS_TYPE. This type is used to indicate a missing or
// erroneous data type in the various AttributeMappingTables, found in
// mappings.c.

#define BOGUS_TYPE      0

// SAM does not explicity store type or length information for its fixed-
// length attributes, but the DS storage routines require this information.
// This structure is intended to store any "patch" information needed for
// the DS backing store, as regards fixed attributes.

typedef struct _SAMP_FIXED_ATTRIBUTE_TYPE_INFO
{
    // Type of the fixed-length attribute.

    ULONG Type;

    // Byte count of the fixed length attribute when stored in SAM
    ULONG SamLength;

    // Byte count of the fixed-length attribute when stored in the DS

    ULONG Length;

} SAMP_FIXED_ATTRIBUTE_TYPE_INFO, PSAMP_FIXED_ATTRIBUTE_TYPE_INFO;

// These constants are used to allocate a table of fixed-attribute informa-
// tion structures. If elements are added or removed from SAMP_OBJECT_TYPE,
// or if structure members in any of the SAM fixed-attribute strucutes are
// added or removed, then these constants must be updated to reflect the new
// members. SAMP_ATTRIBUTE_TYPES_MAX is the maximum number of attributes in
// any single SAM object.

#define SAMP_OBJECT_TYPES_MAX               5
#define SAMP_FIXED_ATTRIBUTES_MAX           18
#define SAMP_VAR_ATTRIBUTES_MAX             18

// These values of these constants are equal to the number of data members in
// the SAM fixed-length attribute structures for each object type. These con-
// stants must be updated whenever data members are added or removed from the
// fixed-length attributes structures.

#define SAMP_SERVER_FIXED_ATTR_COUNT        1
#define SAMP_DOMAIN_FIXED_ATTR_COUNT        15
#define SAMP_GROUP_FIXED_ATTR_COUNT         1
#define SAMP_ALIAS_FIXED_ATTR_COUNT         1
#define SAMP_USER_FIXED_ATTR_COUNT          12

// These type-information arrays are used by the routines in this file. They
// contain data type/size information that is needed by the DS routines for
// reading/writing data. Changes to the fixed-length attribute structures re-
// quire corresponding updates to these arrays.

extern SAMP_FIXED_ATTRIBUTE_TYPE_INFO
    SampFixedAttributeInfo[SAMP_OBJECT_TYPES_MAX][SAMP_FIXED_ATTRIBUTES_MAX];

// SAM variable-length attributes explicitly store length and the number
// of attributes for each object is defined in samsrvp.h. No type information,
// however is stored with these attributes, so define this table.

typedef struct _SAMP_VAR_ATTRIBUTE_TYPE_INFO
{
    // Type of the variable-length attribute.

    ULONG Type;

    // The field identifier identifies the attribute as being associated
    // with a field of the WhichFields parameter for user all information.
    // The passed in whichfields parameter in userallinformation can be used
    // to control what is being prefetched.

    ULONG FieldIdentifier;
    BOOLEAN IsGroupMembershipAttr;

} SAMP_VAR_ATTRIBUTE_TYPE_INFO, PSAMP_VAR_ATTRIBUTE_TYPE_INFO;

extern SAMP_VAR_ATTRIBUTE_TYPE_INFO
    SampVarAttributeInfo[SAMP_OBJECT_TYPES_MAX][SAMP_VAR_ATTRIBUTES_MAX];

// Routine forward declarations.

NTSTATUS
SampConvertAttrBlockToVarLengthAttributes(
    IN INT ObjectType,
    IN PDSATTRBLOCK DsAttributes,
    OUT PSAMP_VARIABLE_LENGTH_ATTRIBUTE *SamAttributes,
    OUT PULONG TotalLength
    );

NTSTATUS
SampConvertVarLengthAttributesToAttrBlock(
    IN PSAMP_OBJECT Context,
    IN PSAMP_VARIABLE_LENGTH_ATTRIBUTE SamAttributes,
    OUT PDSATTRBLOCK *DsAttributes
    );

NTSTATUS
SampConvertAttrBlockToFixedLengthAttributes(
    IN INT ObjectType,
    IN PDSATTRBLOCK DsAttributes,
    OUT PVOID *SamAttributes,
    OUT PULONG TotalLength
    );

NTSTATUS
SampConvertFixedLengthAttributesToAttrBlock(
    IN INT ObjectType,
    IN PVOID SamAttributes,
    OUT PDSATTRBLOCK *DsAttributes
    );

NTSTATUS
SampConvertAttrBlockToCombinedAttributes(
    IN INT ObjectType,
    IN PDSATTRBLOCK DsAttributes,
    OUT PVOID *SamAttributes,
    OUT PULONG FixedLength,
    OUT PULONG VariableLength
    );

NTSTATUS
SampConvertCombinedAttributesToAttrBlock(
    IN PSAMP_OBJECT Context,
    IN ULONG FixedLength,
    IN ULONG VariableLength,
    OUT PDSATTRBLOCK *DsAttributes
    );

VOID
SampFreeAttributeBlock(
   IN PDSATTRBLOCK AttrBlock
   );

BOOLEAN
IsGroupMembershipAttr(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG AttrIndex
    );

NTSTATUS
SampAppendAttrToAttrBlock(
    IN ATTR CredentialAttr,
    IN OUT PDSATTRBLOCK * DsAttrBlock
    );

VOID
SampMarkPerAttributeInvalidFromWhichFields(
    IN PSAMP_OBJECT Context,
    IN ULONG        WhichFields
    );

#endif // _DSUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\dsrmpwd.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dsrmpwd.c

Abstract:

    Routines in the file are used to set Directory Service Restore Mode 
    Administrator Account Password.

Author:

    Shaohua Yin  (ShaoYin) 08-01-2000

Environment:

    User Mode - Win32

Revision History:

    08-01-2000 ShaoYin Create Init File
--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <dsutilp.h>
#include <dslayer.h>
#include <dsmember.h>
#include <attids.h>
#include <mappings.h>
#include <ntlsa.h>
#include <nlrepl.h>
#include <dsevent.h>             // (Un)ImpersonateAnyClient()
#include <sdconvrt.h>
#include <ridmgr.h>
#include <malloc.h>
#include <setupapi.h>
#include <crypt.h>
#include <wxlpc.h>
#include <rc4.h>
#include <md5.h>
#include <enckey.h>
#include <rng.h>






NTSTATUS
SampEncryptDSRMPassword(
    OUT PUNICODE_STRING EncryptedData,
    IN  USHORT          KeyId,
    IN  SAMP_ENCRYPTED_DATA_TYPE DataType,
    IN  PUNICODE_STRING ClearData,
    IN  ULONG Rid
    );


NTSTATUS
SampValidateDSRMPwdSet(
    VOID
    )
/*++
Routine Description:
    
    This routine checks whether this client can set DSRM (Directory Service
    Restore Mode) Administrator's password or not by checking whether the 
    caller is a member of Builtin Administrators Group or not. 
    
Parameter:

    None. 
    
Return Value:

    STATUS_SUCCESS iff the caller is a member of DOMAIN ADMINs GROUP
    
--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;
    BOOLEAN     fImpersonating = FALSE;
    HANDLE      ClientToken = INVALID_HANDLE_VALUE;
    ULONG       RequiredLength = 0, i;
    PTOKEN_GROUPS   Groups = NULL;
    BOOLEAN     ImpersonatingNullSession = FALSE;

    //
    // Impersonate client
    //

    NtStatus = SampImpersonateClient(&ImpersonatingNullSession);
    if (!NT_SUCCESS(NtStatus))
    {
        return( NtStatus );
    }
    fImpersonating = TRUE;

    //
    // Get Client Token
    // 

    NtStatus = NtOpenThreadToken(
                        NtCurrentThread(),
                        TOKEN_QUERY,
                        TRUE,           // OpenAsSelf
                        &ClientToken
                        );

    if (!NT_SUCCESS(NtStatus))
    {
        goto Error;
    }

    //
    // Query ClienToken for User's Groups

    NtStatus = NtQueryInformationToken(
                        ClientToken,
                        TokenGroups,
                        NULL,
                        0,
                        &RequiredLength
                        );

    if ((STATUS_BUFFER_TOO_SMALL == NtStatus) && (RequiredLength > 0))
    {
        //
        // Allocate memory
        //

        Groups = MIDL_user_allocate(RequiredLength);
        if (NULL == Groups)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            goto Error;
        }
        RtlZeroMemory(Groups, RequiredLength);

        //
        // Query Groups again
        // 

        NtStatus = NtQueryInformationToken(
                            ClientToken,
                            TokenGroups,
                            Groups,
                            RequiredLength,
                            &RequiredLength
                            );

        if (!NT_SUCCESS(NtStatus))
        {
            goto Error;
        }

        //
        // Check whether this client is member of Domain Admins Group
        // 

        ASSERT(NT_SUCCESS(NtStatus));
        NtStatus = STATUS_ACCESS_DENIED;
        for (i = 0; i < Groups->GroupCount; i++)
        {
            PSID    pSid = NULL;
            ULONG   Rid = 0;
            ULONG   SubAuthCount = 0;

            pSid = Groups->Groups[i].Sid;

            ASSERT(pSid);
            ASSERT(RtlValidSid(pSid));

            SubAuthCount = *RtlSubAuthorityCountSid(pSid);

            ASSERT(SubAuthCount >= 1);

            Rid = *RtlSubAuthoritySid(pSid, SubAuthCount - 1);

            if (DOMAIN_ALIAS_RID_ADMINS == Rid)
            {
                NtStatus = STATUS_SUCCESS;
                break;
            }
        } // for loop

    }


Error:

    if (fImpersonating)
        SampRevertToSelf(ImpersonatingNullSession);

    if (Groups)
        MIDL_user_free(Groups);

    if (INVALID_HANDLE_VALUE != ClientToken)
        NtClose(ClientToken);

    return( NtStatus );
}




NTSTATUS 
SamrSetDSRMPassword( 
    IN handle_t BindingHandle,
    IN PRPC_UNICODE_STRING ServerName,
    IN ULONG UserId,
    IN PENCRYPTED_NT_OWF_PASSWORD EncryptedNtOwfPassword
    )
/*++
Routine Description:

    This routine sets Directory Service Restore Mode Administrator Account 
    Password.

Parameters:

    BindingHandle   - RPC binding handle

    ServerName - Name of the machine this SAM resides on. Ignored by this
        routine, may be UNICODE or OEM string depending on Unicode parameter.

    UserId - Relative ID of the account, only Administrator ID is valid so far.

    EncryptedNtOwfPassword - Encrypted NT OWF Password

Return Values:

    NTSTATUS Code

--*/
{
    NTSTATUS        NtStatus = STATUS_SUCCESS, 
                    IgnoreStatus = STATUS_SUCCESS;
    PSAMP_OBJECT    UserContext = NULL;
    ULONG           DomainIndex = SAFEMODE_OR_REGISTRYMODE_ACCOUNT_DOMAIN_INDEX;
    UNICODE_STRING  StoredBuffer, StringBuffer;



    SAMTRACE("SamrSetDSRMPassword");

    //
    // This RPC only supported in DS Mode   
    // 

    if (!SampUseDsData)
    {
        return( STATUS_NOT_SUPPORTED );
    }

    //
    // Only Administrator's password can be reset  
    // 
    if (DOMAIN_USER_RID_ADMIN != UserId)
    {
        return( STATUS_NOT_SUPPORTED );
    }

    if (EncryptedNtOwfPassword == NULL) {
        return( STATUS_INVALID_PARAMETER );
    }


    //
    // check client permission
    // 
    NtStatus = SampValidateDSRMPwdSet();

    if (!NT_SUCCESS(NtStatus)) 
    {
        return( NtStatus );
    }


    //
    // Encrypt NtOwfPassword with password encryption Key
    // 
    StringBuffer.Buffer = (PWCHAR)EncryptedNtOwfPassword;
    StringBuffer.Length = ENCRYPTED_NT_OWF_PASSWORD_LENGTH;
    StringBuffer.MaximumLength = StringBuffer.Length;

    RtlInitUnicodeString(&StoredBuffer, NULL);

    NtStatus = SampEncryptDSRMPassword(
                        &StoredBuffer,
                        SAMP_DEFAULT_SESSION_KEY_ID,
                        NtPassword,
                        &StringBuffer,
                        UserId
                        );

    if (!NT_SUCCESS(NtStatus))
    {
        return( NtStatus );
    }

    //
    // Acquire SAM Write Lock in order to access SAM backing store
    // 

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus))
    {
        return( NtStatus );
    }

    //
    // Begin a Registry transaction by, ( acquire lock will not
    // do so because we are in DS mode ). We will use this registry
    // transaction to update the restore mode account password 
    // information in the safe boot hive
    //

    IgnoreStatus = RtlStartRXact( SampRXactContext );
    ASSERT(NT_SUCCESS(IgnoreStatus));

    SampSetTransactionWithinDomain(FALSE);
    SampSetTransactionDomain(DomainIndex);

    //
    // Create a Context for the User Account
    // 
    UserContext = SampCreateContextEx(SampUserObjectType,
                                      TRUE,     // TrustedClient
                                      FALSE,    // DsMode
                                      TRUE,     // ThreadSafe
                                      FALSE,    // LoopbackClient
                                      TRUE,     // LazyCommit
                                      TRUE,     // PersistAcrossCalss
                                      FALSE,    // BufferWrite
                                      FALSE,    // Opened By DcPromo
                                      DomainIndex
                                      );

    if (NULL == UserContext)
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        goto Error;
    }

    //
    // Turn the object flag to Registry Account, so that SAM will switch to 
    // registry routines to get/set attributes
    // 
    SetRegistryObject(UserContext);
    UserContext->ObjectNameInDs = NULL;
    UserContext->DomainIndex = DomainIndex;
    UserContext->GrantedAccess = USER_ALL_ACCESS;
    UserContext->TypeBody.User.Rid = UserId;

    NtStatus = SampBuildAccountSubKeyName(
                   SampUserObjectType,
                   &UserContext->RootName,
                   UserId,
                   NULL             // Don't give a sub-key name
                   );

    if (NT_SUCCESS(NtStatus)) 
    {
        OBJECT_ATTRIBUTES   ObjectAttributes;

        //
        // If the account should exist, try and open the root key
        // to the object - fail if it doesn't exist.
        //
        InitializeObjectAttributes(
                &ObjectAttributes,
                &UserContext->RootName,
                OBJ_CASE_INSENSITIVE,
                SampKey,
                NULL
                );

        SampDumpNtOpenKey((KEY_READ | KEY_WRITE), &ObjectAttributes, 0);

        NtStatus = RtlpNtOpenKey(&UserContext->RootKey,
                                 (KEY_READ | KEY_WRITE),
                                 &ObjectAttributes,
                                 0
                                 );

        if ( !NT_SUCCESS(NtStatus) ) {
            UserContext->RootKey = INVALID_HANDLE_VALUE;
            NtStatus = STATUS_NO_SUCH_USER;
        }

    } else {
        RtlInitUnicodeString(&UserContext->RootName, NULL);
    }

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = SampSetUnicodeStringAttribute(UserContext,
                                                 SAMP_USER_UNICODE_PWD,
                                                 &StoredBuffer
                                                 );

        if (NT_SUCCESS(NtStatus))
        {
            //
            // Update the change to registry backing store
            // 
            NtStatus = SampStoreObjectAttributes(UserContext,
                                                 TRUE
                                                 );
        }

    }

Error:

    // 
    // Commit or Abort the registry transaction by hand
    // 

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = RtlApplyRXact(SampRXactContext);
    }
    else
    {
        NtStatus = RtlAbortRXact(SampRXactContext);
    }

    if (NULL != UserContext)
    {
        SampDeleteContext(UserContext);
    }

    //
    // Release Write Lock
    // 

    IgnoreStatus = SampReleaseWriteLock(FALSE);
    ASSERT(NT_SUCCESS(IgnoreStatus));

    if (NULL != StoredBuffer.Buffer)
    {
        RtlZeroMemory(StoredBuffer.Buffer, StoredBuffer.Length);
        MIDL_user_free(StoredBuffer.Buffer);
    }

    return( NtStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\dsutil.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    dsutil.c

Abstract:

    This file contains helper routines for accessing and manipulating data
    based on the DS backing store. Included, are routines for converting be-
    tween the SAM data format (BLOBs) and the DS data format (ATTRBLOCKs).

    NOTE: The routines in this file have direct knowledge of the SAM fixed-
    length attribute and variable-length attribute structures, as well as the
    DS ATTRBLOCK structure. Any changes to these structures, including:

    -addition/deletion of a structure member
    -data type/size change of a structure member
    -reordering of the data members
    -renaming of the data members

    will break these routines. SAM attributes are accessed via byte buffer
    offsets and lengths, rather than by identifier or by explicit structure
    data members. Because of this, changes to the structure layout will lead
    to failures in SAM operation.

    Several of the routines have been written assuming that the order of the
    attributes passed in via an ATTRBLOCK are exactly the order in which SAM
    understands its own buffer layout. If the attributes are passed into the
    routines (that take ATTRBLOCKs) out of order, the data in the SAM buffers
    will be invalid.

Author:

    Chris Mayhall (ChrisMay) 09-May-1996

Environment:

    User Mode - Win32

Revision History:

    ChrisMay        09-May-1996
        Created initial file, DS ATTRBLOCK-SAM buffer conversion routines for
        variable-length attributes.
    ChrisMay        14-May-1996
        DS ATTRBLOCK-SAM buffer conversion routines for fixed-length attri-
        butes.
    ChrisMay        22-May-1996
        Added DWORD_ALIGN macro to align data on DWORD boundaries. Fixed
        alignment problems on MIPS in SampExtractAttributeFromDsAttr routine.
    ChrisMay        30-May-1996
        Added routines to convert SAM combined-buffer attributes to/from DS
        ATTRBLOCKs. Revised fixed-length routines to do explicit structure
        member assignment instead of attempting to compute structure offsets.
    ChrisMay        18-Jun-1996
        Updated fixed-attribute tables to reflect recent changes in mappings.c
        and mappings.h, and DS schema. Added code to coerce the data sizes of
        USHORT and BOOLEAN to DS integer data type (4 bytes) so that the DS
        modify entry routines don't AV. Correctly set attribute type for the
        variable-length attributes.
    ChrisMay        25-Jun-1996
        Added RtlZeroMemory calls where they were missing.
    ColinBr         18-Jul-1996
        Fixed array overwrite and assigned type to variable length
        attributes when combining fixed and variable length attrs
        into one.
    ColinBr         19-Jul-1996
        Replaced the mappings of membership related SAM attributes to
        *_UNUSED. So
        SAMP_USER_GROUPS   -> SAMP_USER_GROUPS_UNUSED
        SAMP_GROUP_MEMBERS -> SAMP_GROUP_MEMBERS_UNUSED
        SAMP_ALIAS_MEMBERS -> SAMP_ALIAS_MEMBERS_UNUSED
    ChrisMay        25-Jun-1996
        Added extremely slime-ridden hack to make logon hours work for the
        technology preview.

        REMOVE THIS COMMENT AFTER THIS IS FIXED, AFTER THE PREVIEW.

        Search for "TECHNOLOGY PREVIEW HACK". The problem is that the
        Qualifier field is used to store the units of time for a user's
        logon hours. This is bogus since most of the time it is used as
        a count of values for multivalued attributes. Consequently, this
        code "whacks" 0xa8 into the qualifier field whenever the attri-
        butes are read in from disk. 0xa8 means that the time units are
        in hours-per-day (probably!).


--*/

#include <samsrvp.h>
#include <dsutilp.h>
#include <mappings.h>
#include <objids.h>

// Private debugging display routine is enabled when DSUTIL_DBG_PRINTF = 1.

#define DSUTIL_DBG_PRINTF                  0

#if (DSUTIL_DBG_PRINTF == 1)
#define DebugPrint printf
#else
#define DebugPrint
#endif


#if DBG
#define AssertAddressWhenSuccess(NtStatus, Address)    \
        if (NT_SUCCESS(NtStatus))                      \
        {                                              \
            ASSERT(Address);                           \
        }
#else
#define AssertAddressWhenSuccess(NtStatus, Address)
#endif // DBG

// DWORD_ALIGN is used to adjust pointer offsets up to the next DWORD boundary
// during the construction of SAM blob buffers.

#define DWORD_ALIGN(value) (((DWORD)(value) + 3) & ~3)

// Because it is apparently difficult for the DS to support NT data types of
// USHORT, UCHAR, and BOOLEAN (and which are used by SAM), these crappy data
// types have been defined for the SampFixedAttributeInfo table so that four-
// byte quantities are used. These four-byte quantities correspond to the DS
// "integer" data type (for how long?) which is used for storing certain SAM
// attributes. Note that it is important to zero out any memory allocated w/
// these data sizes, since only the lower couple of bytes actually contain
// data. Enjoy...and refer to the DS schema(.hlp file) for the ultimate word
// on the currently used DS data types.

#define DS_USHORT   ULONG
#define DS_UCHAR    ULONG
#define DS_BOOLEAN  ULONG

// This type-information table is used by the routines that convert between
// SAM fixed-length buffers and DS ATTRBLOCKs. The table contains information
// about the data type and size (but may contain any suitable information that
// is needed in the future) of the fixed-length attributes. NOTE: the layout
// of this table corresponds to the data members of the fixed-length struct-
// ures (in samsrvp.h), hence, any changes to those structures must be re-
// flected in the type-information table.

SAMP_FIXED_ATTRIBUTE_TYPE_INFO
    SampFixedAttributeInfo[SAMP_OBJECT_TYPES_MAX][SAMP_FIXED_ATTRIBUTES_MAX] =
{
    // The initialization values of this table must strictly match the set
    // and order of the data members in the SAM fixed-attribute structures,
    // contained in samsrvp.h.

    // The routines that manipulate this table assume that the fixed-length
    // attributes, unlike the variable-length counterparts, are single valued
    // attributes (i.e. are not multi-valued attributes).

    // The first column of each element in the table is a type identifier, as
    // defined in mappings.c. This is used to map the SAM data type into the
    // equivalent DS data type. The second column of each table element is the
    // actual (C-defined) size of the element and is used throughout the data
    // conversion routines in this file in order to allocate memory or set
    // offset information correctly.

    // SampServerObjectType

    {
        {SAMP_FIXED_SERVER_REVISION_LEVEL,              sizeof(ULONG), sizeof(ULONG)}
    },

    // SampDomainObjectType

    {
        {SAMP_FIXED_DOMAIN_CREATION_TIME,               sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_DOMAIN_MODIFIED_COUNT,              sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_DOMAIN_MAX_PASSWORD_AGE,            sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_DOMAIN_MIN_PASSWORD_AGE,            sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_DOMAIN_FORCE_LOGOFF,                sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_DOMAIN_LOCKOUT_DURATION,            sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_DOMAIN_LOCKOUT_OBSERVATION_WINDOW,  sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_DOMAIN_MODCOUNT_LAST_PROMOTION,     sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_DOMAIN_NEXT_RID,                    sizeof(ULONG),sizeof(ULONG)},
        {SAMP_FIXED_DOMAIN_PWD_PROPERTIES,              sizeof(ULONG),sizeof(ULONG)},
        {SAMP_FIXED_DOMAIN_MIN_PASSWORD_LENGTH,         sizeof(USHORT),sizeof(DS_USHORT)},
        {SAMP_FIXED_DOMAIN_PASSWORD_HISTORY_LENGTH,     sizeof(USHORT),sizeof(DS_USHORT)},
        {SAMP_FIXED_DOMAIN_LOCKOUT_THRESHOLD,           sizeof(USHORT),sizeof(DS_USHORT)},
        {SAMP_FIXED_DOMAIN_SERVER_STATE,                sizeof(DOMAIN_SERVER_ENABLE_STATE),sizeof(DOMAIN_SERVER_ENABLE_STATE)},
        {SAMP_FIXED_DOMAIN_UAS_COMPAT_REQUIRED,         sizeof(BOOLEAN),sizeof(DS_BOOLEAN)}
    },

    // SampGroupObjectType

    {
        {SAMP_FIXED_GROUP_RID,                          sizeof(ULONG),sizeof(ULONG)}
       
    },

    // SampAliasObjectType

    {
        {SAMP_FIXED_ALIAS_RID,                          sizeof(ULONG),sizeof(ULONG)}
    },

    // SampUserObjectType

    {
        {SAMP_FIXED_USER_LAST_LOGON,                    sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_USER_LAST_LOGOFF,                   sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_USER_PWD_LAST_SET,                  sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_USER_ACCOUNT_EXPIRES,               sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_USER_LAST_BAD_PASSWORD_TIME,        sizeof(LARGE_INTEGER),sizeof(LARGE_INTEGER)},
        {SAMP_FIXED_USER_USERID,                        sizeof(ULONG),sizeof(ULONG)},
        {SAMP_FIXED_USER_PRIMARY_GROUP_ID,              sizeof(ULONG),sizeof(ULONG)},
        {SAMP_FIXED_USER_ACCOUNT_CONTROL,               sizeof(ULONG),sizeof(ULONG)},
        {SAMP_FIXED_USER_COUNTRY_CODE,                  sizeof(USHORT),sizeof(DS_USHORT)},
        {SAMP_FIXED_USER_CODEPAGE,                      sizeof(USHORT),sizeof(DS_USHORT)},
        {SAMP_FIXED_USER_BAD_PWD_COUNT,                 sizeof(USHORT),sizeof(DS_USHORT)},
        {SAMP_FIXED_USER_LOGON_COUNT,                   sizeof(USHORT),sizeof(DS_USHORT)}
    }
};



SAMP_VAR_ATTRIBUTE_TYPE_INFO
    SampVarAttributeInfo[SAMP_OBJECT_TYPES_MAX][SAMP_VAR_ATTRIBUTES_MAX] =
{
    // The initialization values of this table must strictly match the set
    // and order of the data members in the SAM variable-attributes, defined
    // in samsrvp.h. Size is not defined here, because SAM variable-length
    // attributes store attribute length explicity. Refer to mappings.c and
    // mappings.h for the definitions used for the data types in this table.

    // SampServerObjectType

    {
        {SAMP_SERVER_SECURITY_DESCRIPTOR,0,FALSE}
    },

    // SampDomainObjectType

    {
        {SAMP_DOMAIN_SECURITY_DESCRIPTOR,0,FALSE},
        {SAMP_DOMAIN_SID,0,FALSE},
        {SAMP_DOMAIN_OEM_INFORMATION,0,FALSE},
        {SAMP_DOMAIN_REPLICA,0,FALSE}
    },

    // SampGroupObjectType

    {
        {SAMP_GROUP_SECURITY_DESCRIPTOR,0,FALSE},
        {SAMP_GROUP_NAME,0, FALSE},
        {SAMP_GROUP_ADMIN_COMMENT,0,FALSE},
        {SAMP_GROUP_MEMBERS,0,TRUE}
    },

    // SampAliasObjectType

    {
        {SAMP_ALIAS_SECURITY_DESCRIPTOR,0,FALSE},
        {SAMP_ALIAS_NAME,0,FALSE},
        {SAMP_ALIAS_ADMIN_COMMENT,0,FALSE},
        {SAMP_ALIAS_MEMBERS,0,TRUE}
    },

    // SampUserObjectType

    {
        {SAMP_USER_SECURITY_DESCRIPTOR,USER_ALL_SECURITYDESCRIPTOR,FALSE},
        {SAMP_USER_ACCOUNT_NAME, 0 /* USER_ALL_USERNAME */,FALSE},
                   // always fetch sam account name, as sam requires at least
                   // one variable attribute in the context. Having a 0 in 
                   // the field identifier portion causes the code to always
                   // fetch SAM account name
        {SAMP_USER_FULL_NAME,USER_ALL_FULLNAME,FALSE},
        {SAMP_USER_ADMIN_COMMENT,USER_ALL_ADMINCOMMENT,FALSE},
        {SAMP_USER_USER_COMMENT,USER_ALL_USERCOMMENT,FALSE},
        {SAMP_USER_PARAMETERS,USER_ALL_PARAMETERS,FALSE},
        {SAMP_USER_HOME_DIRECTORY,USER_ALL_HOMEDIRECTORY,FALSE},
        {SAMP_USER_HOME_DIRECTORY_DRIVE,USER_ALL_HOMEDIRECTORYDRIVE,FALSE},
        {SAMP_USER_SCRIPT_PATH,USER_ALL_SCRIPTPATH,FALSE},
        {SAMP_USER_PROFILE_PATH,USER_ALL_PROFILEPATH,FALSE},
        {SAMP_USER_WORKSTATIONS,USER_ALL_WORKSTATIONS,FALSE},
        {SAMP_USER_LOGON_HOURS,USER_ALL_LOGONHOURS,FALSE},
        {SAMP_USER_GROUPS,0,TRUE},
        {SAMP_USER_DBCS_PWD,USER_ALL_OWFPASSWORD,FALSE},
        {SAMP_USER_UNICODE_PWD,USER_ALL_OWFPASSWORD,FALSE},
        {SAMP_USER_NT_PWD_HISTORY,USER_ALL_PRIVATEDATA,FALSE},
        {SAMP_USER_LM_PWD_HISTORY,USER_ALL_PRIVATEDATA,FALSE}
    }
};



//
// MISCELLANEOUS HELPER ROUTINES
//

VOID
SampFreeAttributeBlock(
    IN DSATTRBLOCK * AttrBlock
    )
/*
    Routine Description:
        This routine Frees a DS Attrblock structure allocated
        out of the process Heap

    Arguments

      AttrBlock - Pointer to the Attrblock

    Return Values:

      None
*/
{
   ULONG i;
   ULONG j;

   if (NULL!=AttrBlock)
   {
      if (NULL!=AttrBlock->pAttr)
      {
         for(i=0;i<AttrBlock->attrCount;i++)
         {
            if (NULL!=AttrBlock->pAttr[i].AttrVal.pAVal)
            {
               for(j=0;j<AttrBlock->pAttr[i].AttrVal.valCount;j++)
               {
                  if (NULL!=AttrBlock->pAttr[i].AttrVal.pAVal[j].pVal)
                      RtlFreeHeap(RtlProcessHeap(),0,AttrBlock->pAttr[i].AttrVal.pAVal[j].pVal);
               }
               RtlFreeHeap(RtlProcessHeap(),0,AttrBlock->pAttr[i].AttrVal.pAVal);
             }
         }
         RtlFreeHeap(RtlProcessHeap(),0,AttrBlock->pAttr);
      }
      RtlFreeHeap(RtlProcessHeap(),0,AttrBlock);
    }
}




NTSTATUS
SampFreeSamAttributes(
    IN PSAMP_VARIABLE_LENGTH_ATTRIBUTE SamAttributes
    )

/*++

Routine Description:

    (Under development)

Arguments:



Return Value:


--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampFreeSamAttributes");

    return(NtStatus);
}



NTSTATUS
SampReallocateBuffer(
    IN ULONG OldLength,
    IN ULONG NewLength,
    IN OUT PVOID *Buffer
    )

/*++

Routine Description:

    This routine resizes an in-memory buffer. The routine can either grow or
    shrink the buffer based on specified lengths. Data is preserved from old
    to new buffers, truncating if the new buffer is shorter than the actual
    data length. The newly allocated buffer is returned as an out parameter,
    the passed in buffer is released for the caller.

Arguments:

    OldLength - Length of the buffer passed into the routine.

    NewLength - Length of the re-allocated buffer.

    Buffer - Pointer, incoming buffer to resize, outgoing new buffer.

Return Value:

    STATUS_SUCCESS - Buffer header block allocated and initialized.

    Other codes indicating the nature of the failure.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    PVOID BufferTmp = NULL;

    SAMTRACE("SampReallocateBuffer");

    if ((NULL != Buffer)  &&
        (NULL != *Buffer) &&
        (0 < OldLength)   &&
        (0 < NewLength))
    {
        // Allocate a new buffer and set the temporary variable. Note that
        // the routine does not destroy the old buffer if there is any kind
        // of failure along the way.

        BufferTmp = RtlAllocateHeap(RtlProcessHeap(), 0, NewLength);

        if (NULL != BufferTmp)
        {
            RtlZeroMemory(BufferTmp, NewLength);

            // Copy the original buffer into the new one, truncating data if
            // the new buffer is shorter than the original data size.

            if (OldLength < NewLength)
            {
                RtlCopyMemory(BufferTmp, *Buffer, OldLength);
            }
            else
            {
                RtlCopyMemory(BufferTmp, *Buffer, NewLength);
            }

            // If all has worked, delete the old buffer and set the outgoing
            // buffer pointer.

            RtlFreeHeap(RtlProcessHeap(), 0, *Buffer);
            *Buffer = BufferTmp;

            NtStatus = STATUS_SUCCESS;
        }
        else
        {
            NtStatus = STATUS_NO_MEMORY;
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return(NtStatus);
}



BOOLEAN
IsGroupMembershipAttr(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG AttrIndex
    )
{
    BOOLEAN RetValue = FALSE;


    switch(ObjectType)
    {
    case SampGroupObjectType:
        if (SAMP_GROUP_MEMBERS== 
            SampVarAttributeInfo[ObjectType][AttrIndex].Type)
        {
            RetValue = TRUE;
        }
        break;

     case SampAliasObjectType:
        if (SAMP_ALIAS_MEMBERS== 
            SampVarAttributeInfo[ObjectType][AttrIndex].Type)
        {
            RetValue = TRUE;
        }
        break;

     case SampUserObjectType:
        if (SAMP_USER_GROUPS== 
            SampVarAttributeInfo[ObjectType][AttrIndex].Type)
        {
            RetValue = TRUE;
        }

        break;
    }


    return (RetValue);
}




//
// ATTRBLOCK-TO-VARIABLE LENGTH CONVERSION ROUTINES
//

NTSTATUS
SampInitializeVarLengthAttributeBuffer(
    IN ULONG AttributeCount,
    OUT PULONG BufferLength,
    OUT PSAMP_VARIABLE_LENGTH_ATTRIBUTE *SamAttributes
    )

/*++

Routine Description:

    This routine sets up the SAM attribute buffer that is the destination for
    attributes read from the DS backing store. The buffer contains a header,
    followed by variable-length attributes (SAMP_VARIABLE_LENGTH_ATTRIBUTE).

    This routine allocates memory for the buffer header and zeros it out.

Arguments:

    AttributeCount - Number of variable-length attributes.

    BufferLength - Pointer, buffer size allocated by this routine.

    SamAttributes - Pointer, returned buffer.

Return Value:

    STATUS_SUCCESS - Buffer header block allocated and initialized.

    Other codes indicating the nature of the failure.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG Length = 0;

    SAMTRACE("SampInitializeVarLengthAttributeBuffer");

    if (0 < AttributeCount)
    {
        // Calculate the space needed for the attribute-offset array. If the
        // attribute count is zero, skip the allocation and return an error.

        Length = AttributeCount * sizeof(SAMP_VARIABLE_LENGTH_ATTRIBUTE);

        if (NULL != SamAttributes)
        {
            *SamAttributes = RtlAllocateHeap(RtlProcessHeap(), 0, Length);

            if (NULL != *SamAttributes)
            {
                // Initialize the block and return the updated buffer offset,
                // which now points to the last byte of the header block.

                RtlZeroMemory(*SamAttributes, Length);

                if (NULL != BufferLength)
                {
                    *BufferLength = Length;
                    NtStatus = STATUS_SUCCESS;
                }
            }
            else
            {
                NtStatus = STATUS_NO_MEMORY;
            }
        }
    }

    return(NtStatus);
}



NTSTATUS
SampExtractAttributeFromDsAttr(
    IN PDSATTR Attribute,
    OUT PULONG MultiValuedCount,
    OUT PULONG Length,
    OUT PVOID  Buffer
    )

/*++

Routine Description:

    This routine determines whether or not the current attribute is single-
    valued or multi-valued and returns a buffer containing the value(s) of
    the attribute. If the attribute is multi-valued, the values are appended
    in the buffer.

Arguments:

    Attribute - Pointer, incoming DS attribute structure.

    MultiValuedCount - Pointer, returned count of the number of values found
        for this attribute.

    Length - Pointer, returned buffer length.

    Buffer - Pointer, returned buffer containing one or more values.
             Caller has the responsibility of allocating an appropriate sized
             buffer.

Return Value:

    STATUS_SUCCESS - Buffer header block allocated and initialized.

    Other codes indicating the nature of the failure.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG ValueCount = 0;
    PDSATTRVALBLOCK ValueBlock;
    PDSATTRVAL Values = NULL;
    ULONG ValueIndex = 0;
    ULONG TotalLength = 0;
    ULONG Offset = 0;
    

    SAMTRACE("SampExtractAttributeFromDsAttr");

    // Get the count of attributes and a pointer to the attribute. Note that
    // it is possible to have multi-valued attributes, in which case they are
    // appended onto the end of the return buffer.

    if (NULL != Attribute)
    {
        // DSATTR structure contains: attrTyp, AttrVal

        ValueBlock = &(Attribute->AttrVal);

        // DSATTRVALBLOCK structure contains: valCount, pAVal

        ValueCount = ValueBlock->valCount;
        Values = ValueBlock->pAVal;

        if ((0 < ValueCount) && (NULL != Values))
        {
            // Multi-valued attribute processing; first determine the total
            // buffer length that will be needed.

            // Note that padded only occurs between values, so the first
            // value should only be padded when followed by another
            // value, and the last value should not be padded
            // Note that the length of each individual value length
            // should not include the amout of padding, of course.

            TotalLength = Values[0].valLen;
            for (ValueIndex = 1; ValueIndex < ValueCount; ValueIndex++)
            {
                // Determine total length needed for this attribute. Because
                // the value lengths may not be DWORD size, pad up to the
                // next DWORD size.
                TotalLength = DWORD_ALIGN(TotalLength);

                TotalLength += Values[ValueIndex].valLen;
            }
        }

        //
        // if the passed in length was less then return buffer too small
        //

        if (*Length < TotalLength)
        {
            *Length = TotalLength;
            return ( STATUS_BUFFER_TOO_SMALL);
        }

        if ((0 < TotalLength) && (NULL != Buffer))
        {

           RtlZeroMemory(Buffer, TotalLength);

           for (ValueIndex = 0;
                 ValueIndex < ValueCount;
                 ValueIndex++)
           {
                // DSATTRVAL structure contains: valLen, pVal. Append
                // subsequent values onto the end of the buffer, up-
                // dating the end-of-buffer offset each time.

                RtlCopyMemory(((BYTE *)Buffer + Offset),
                             (PBYTE)(Values[ValueIndex].pVal),
                             Values[ValueIndex].valLen);

                // Adjust the offset up to the next DWORD boundary.

                Offset += DWORD_ALIGN(Values[ValueIndex].valLen);
            }

            if ((NULL != MultiValuedCount) && (NULL != Length))
            {
               // Finished, update return values.

               *MultiValuedCount = ValueCount;
               *Length = TotalLength;
               NtStatus = STATUS_SUCCESS;
            }
        }
    }

    return(NtStatus);
}



NTSTATUS
SampVerifyVarLengthAttribute(
    IN INT ObjectType,
    IN ULONG AttrIndex,
    IN ULONG MultiValuedCount,
    IN ULONG AttributeLength
    )

/*++

Routine Description:

    This routine is under construction.

Arguments:


Return Value:

    STATUS_SUCCESS - Buffer header block allocated and initialized.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampVerifyVarLengthAttribute");

    // BUG: Define a table of variable-length attribute information.

    switch(ObjectType)
    {

    // For each SAM object type, verify that attributes that are supposed to
    // be single valued, have a MultiValueCount of 1 (multi-valued attributes
    // can have a count greater-than or equal to 1).

    case SampServerObjectType:

        if (1 == MultiValuedCount)
        {
            NtStatus = STATUS_SUCCESS;
        }

        break;

    case SampDomainObjectType:

        if (1 == MultiValuedCount)
        {
            NtStatus = STATUS_SUCCESS;
        }

        break;

    case SampGroupObjectType:

        // Multi-valued attribute

        if ((SAMP_GROUP_MEMBERS != AttrIndex))
        {
            if (1 == MultiValuedCount)
            {
                NtStatus = STATUS_SUCCESS;
            }
        }

        break;

    case SampAliasObjectType:

        // Multi-valued attribute

        if ((SAMP_ALIAS_MEMBERS != AttrIndex))
        {
            if (1 == MultiValuedCount)
            {
                NtStatus = STATUS_SUCCESS;
            }
        }

        break;

    case SampUserObjectType:

        // Multi-valued attributes

        if ((SAMP_USER_GROUPS != AttrIndex) &&
            (SAMP_USER_LOGON_HOURS != AttrIndex))
        {
            if (1 == MultiValuedCount)
            {
                NtStatus = STATUS_SUCCESS;
            }
        }

        break;

    default:

        break;

    }

    NtStatus = STATUS_SUCCESS;

    return(NtStatus);
}



NTSTATUS
SampAppendVarLengthAttributeToBuffer(
    IN INT ObjectType,
    IN ULONG AttrIndex,
    IN PVOID NewAttribute,
    IN ULONG MultiValuedCount,
    IN ULONG AttributeLength,
    IN OUT PULONG BufferLength,
    IN OUT PULONG BufferLengthUsed,
    IN OUT PSAMP_VARIABLE_LENGTH_ATTRIBUTE *SamAttributes
    )

/*++

Routine Description:

    This routine appends the current attribute onto the end of the attribute
    buffer, and updates the SAMP_VARIABLE_LENGTH_DATA structures in the head-
    er of the buffer with new offset, length, and qualifier information.

Arguments:

    AttrIndex - Index into the array of variable-length offsets.

    NewAttribute - Pointer, the new attribute to be appended to the buffer.

    MultiValuedCount - Number of values for the attribute.

    AttributeLength - Number of bytes of the attribute.

    BufferLength - Pointer, incoming contains the current length of the buf-
        fer; outgoing contains the updated length after appending the latest
        attribute.

    BufferLength - Pointer, incoming contains the current length of the buffer
       that has been used so far. Outgoing containes the updated length of the
       buffer that has been used.

    SamAttributes - Pointer, SAMP_VARIABLE_LENGTH_ATTRIBUTE buffer.

Return Value:

    STATUS_SUCCESS - Buffer header block allocated and initialized.

    Other codes indicating the nature of the failure.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG NewLength = 0;
    #define SAMP_DS_ONDISK_BUFFER_GROWTH_SIZE 512

    SAMTRACE("SampAppendVarLengthAttributeToBuffer");

    if (AttributeLength>0)
    {
        // Compute the required buffer length needed to append the attribute.

        // BUG: >>>TECHNOLOGY PREVIEW HACK BELOW THIS LINE<<<

        if ((SampUserObjectType == ObjectType) &&
            (SAMP_USER_LOGON_HOURS == AttrIndex))
        {
            // (*SamAttributes + AttrIndex)->Qualifier = *((DWORD*)NewAttribute);
            // NewAttribute = ((PBYTE)NewAttribute) + sizeof(DWORD);
            // AttributeLength -= sizeof(DWORD);

            (*SamAttributes + AttrIndex)->Qualifier = 0xa8;
        }
        else
        {
            (*SamAttributes + AttrIndex)->Qualifier = MultiValuedCount;
        }

        // BUG: >>>TECHNOLOGY PREVIEW HACK ABOVE THIS LINE<<<

        // DWORD_ALIGN the space for the value so the next value will be
        // be aligned.

        NewLength = *BufferLengthUsed + DWORD_ALIGN(AttributeLength);

        if ( (*BufferLength) < NewLength)
        {
            // Adjust buffer size for the attribute.

            NtStatus = SampReallocateBuffer(*BufferLengthUsed,
                                            NewLength+SAMP_DS_ONDISK_BUFFER_GROWTH_SIZE,
                                            SamAttributes);

            if (NT_SUCCESS(NtStatus))
            {
                *BufferLength = NewLength+SAMP_DS_ONDISK_BUFFER_GROWTH_SIZE;
            }
        }

        if (NT_SUCCESS(NtStatus))
        {
            // Zero out the allocated memory in case of padding

            RtlZeroMemory((((PBYTE)(*SamAttributes)) + *BufferLengthUsed),
                         DWORD_ALIGN(AttributeLength));

            // Append the attribute onto the return buffer.

            RtlCopyMemory((((PBYTE)(*SamAttributes)) + *BufferLengthUsed),
                         NewAttribute,
                         AttributeLength);

            // Update the variable-length header information for the latest
            // attribute.

            (*SamAttributes + AttrIndex)->Offset = *BufferLengthUsed;
            (*SamAttributes + AttrIndex)->Length = AttributeLength;

            // Pass back the updated buffer length.

            *BufferLengthUsed = NewLength;

            DebugPrint("BufferLength = %lu\n", *BufferLength);
            DebugPrint("NewLength = %lu\n", NewLength);
            DebugPrint("SamAttributes Offset = %lu\n",      (*SamAttributes + AttrIndex)->Offset);
            DebugPrint("SamAttributes Length = %lu\n",      (*SamAttributes + AttrIndex)->Length);
            DebugPrint("SamAttributes Qualifier = %lu\n",   (*SamAttributes + AttrIndex)->Qualifier);
        }
    }
    else
    {
            // Update the variable-length header information for the latest
            // attribute.

            (*SamAttributes + AttrIndex)->Offset = *BufferLengthUsed;
            (*SamAttributes + AttrIndex)->Length = 0;

            // BUG: Assuming that Qualifier is used for multi-value count?

            (*SamAttributes + AttrIndex)->Qualifier = MultiValuedCount;
            NtStatus = STATUS_SUCCESS;
    }

    return(NtStatus);
}



NTSTATUS
SampConvertAttrBlockToVarLengthAttributes(
    IN INT ObjectType,
    IN PDSATTRBLOCK DsAttributes,
    OUT PSAMP_VARIABLE_LENGTH_ATTRIBUTE *SamAttributes,
    OUT PULONG TotalLength
    )

/*++

Routine Description:

    This routine extracts the DS attributes from a DS READRES structure and
    builds a SAMP_VARIABLE_LENGTH_BUFFER with them. This routine allocates
    the necessary memory block for the SAM variable-length attribute buffer.

    This routine assumes that the attributes passed in via the READRES struc-
    ture are in the correct order (as known to SAM).

Arguments:

    ObjectType - SAM object type identifier (this parameter is currently un-
        used, but will likely be used to set the maximum number of attributes
        for any given conversion).

    DsAttributes - Pointer, DS attribute list.

    SamAttributes - Pointer, returned SAM variable-length attribute buffer.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG AttributeCount = 0;
    PDSATTR Attributes = NULL;
    ULONG BufferLength = 0;
    ULONG BufferLengthUsed=0;
    ULONG AttrIndex = 0;
    ULONG AttributeLength = 0;
    ULONG AttributeBufferLength = 0;
    ULONG MultiValuedCount = 0;
    PVOID Attribute = NULL;
    ULONG DsIndex   = 0;

    #define SAM_INITIAL_ATTRIBUTE_BUFFER_SIZE 512

    SAMTRACE("SampConvertAttrBlockToVarLengthAttributes");

    if ((NULL != DsAttributes) && (NULL != SamAttributes))
    {
        // Get the attribute count and a pointer to the attributes.

        switch(ObjectType)
        {
            case SampDomainObjectType:
                AttributeCount = SAMP_DOMAIN_VARIABLE_ATTRIBUTES;
                break;
            case SampServerObjectType:
                AttributeCount = SAMP_SERVER_VARIABLE_ATTRIBUTES;
                break;
            case SampGroupObjectType:
                AttributeCount = SAMP_GROUP_VARIABLE_ATTRIBUTES;
                break;
            case SampAliasObjectType:
                AttributeCount = SAMP_ALIAS_VARIABLE_ATTRIBUTES;
                break;
            case SampUserObjectType:
                AttributeCount = SAMP_USER_VARIABLE_ATTRIBUTES;
                break;
            default:
                ASSERT(FALSE);
                return(STATUS_INVALID_PARAMETER);
        }

        Attributes = DsAttributes->pAttr;

        if ((0 < AttributeCount) && (NULL != Attributes))
        {
            // Set up the variable-length attribute buffer header based on the
            // number of attributes. Allocate and initialize the SamAttributes
            // buffer. Update BufferLength to reflect the new size.

            NtStatus = SampInitializeVarLengthAttributeBuffer(
                                                     AttributeCount,
                                                     &BufferLength,
                                                     SamAttributes);
            BufferLengthUsed = BufferLength;
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    //
    // Pre allocate memory for the attributes
    //

    Attribute = MIDL_user_allocate(SAM_INITIAL_ATTRIBUTE_BUFFER_SIZE);
    if (NULL!=Attribute)
    {
       AttributeBufferLength = SAM_INITIAL_ATTRIBUTE_BUFFER_SIZE;
    }
    else
    {
        NtStatus = STATUS_NO_MEMORY;
    }
        

    if (NT_SUCCESS(NtStatus))
    {
        // For each attribute, get its value (or values in the case of multi-
        // valued attributes).

        DsIndex = 0;

        for (AttrIndex = 0; AttrIndex < AttributeCount ; AttrIndex++)
        {
            // A given attribute may be multi-valued, in which case multiple
            // values are simply concatenated together. MultiValuedCount will
            // contain the number of values for the attribute.

            if ((DsIndex < DsAttributes->attrCount)
                 && (Attributes[DsIndex].attrTyp==AttrIndex))
            {
                //
                // Ds Actually Returned the Attribute
                //

                AttributeLength = AttributeBufferLength;

                NtStatus = SampExtractAttributeFromDsAttr(
                                                &(Attributes[DsIndex]),
                                                &MultiValuedCount,
                                                &AttributeLength,
                                                Attribute);

                if (STATUS_BUFFER_TOO_SMALL==NtStatus)
                {
                    //
                    // The attribute is bigger than the buffer
                    //
                    if (NULL!=Attribute)
                    {
                        MIDL_user_free(Attribute);
                    }
                    Attribute = MIDL_user_allocate(AttributeLength);
                    if (NULL!=Attribute)
                    {
                        AttributeBufferLength = AttributeLength;
                        NtStatus = SampExtractAttributeFromDsAttr(
                                                &(Attributes[DsIndex]),
                                                &MultiValuedCount,
                                                &AttributeLength,
                                                Attribute
                                                ); 
                    }
                    else
                    {
                       NtStatus = STATUS_NO_MEMORY;
                    }
                 }
                       

                // Verify that the DS has returned SAM attributes correctly. Check
                // such things as attribute length, single vs. multi-value status.

                if (NT_SUCCESS(NtStatus))
                {
                    NtStatus = SampVerifyVarLengthAttribute(ObjectType,
                                                        AttrIndex,
                                                        MultiValuedCount,
                                                        AttributeLength);
                }
                if (NT_SUCCESS(NtStatus))
                {
                    // Append the current attribute onto the end of the SAM vari-
                    // able length attribute buffer and update the offset array.

                    // AttrIndex is not only the loop counter, but is also the
                    // index into the proper element of the variable-length attr-
                    // ibute array. NOTE: This routine assumes that the order in
                    // which the elements were returned in the READRES buffer is
                    // in fact the correct order of the SAM attributes as defined
                    // in samsrvp.h

                    NtStatus = SampAppendVarLengthAttributeToBuffer(
                                                           ObjectType,
                                                           AttrIndex,
                                                           Attribute,
                                                           MultiValuedCount,
                                                           AttributeLength,
                                                           &BufferLength,
                                                           &BufferLengthUsed,
                                                           SamAttributes);

                }


                DsIndex++;
            }
            else if ((DsIndex < DsAttributes->attrCount)
                    && (Attributes[DsIndex].attrTyp >= AttributeCount))
            {
               //
               // Case where we do not care about the Attribute
               // SAMP_USER_GROUPS_UNUSED
               //
                NtStatus = SampAppendVarLengthAttributeToBuffer(
                                                        ObjectType,
                                                        AttrIndex,
                                                        NULL,
                                                        0,
                                                        0,
                                                        &BufferLength,
                                                        &BufferLengthUsed,
                                                        SamAttributes);

                DsIndex++;
            }
            else
            {
                //
                // The Attribute was not returned. Append NULL Attribute
                //

                NtStatus = SampAppendVarLengthAttributeToBuffer(
                                                        ObjectType,
                                                        AttrIndex,
                                                        NULL,
                                                        0,
                                                        0,
                                                        &BufferLength,
                                                        &BufferLengthUsed,
                                                        SamAttributes);
            }


            if (!NT_SUCCESS(NtStatus))
            {
                // Detect failure of either routine and break for return. Let
                // the caller release the memory that is returned.

                break;
            }
        }

        if (NULL != TotalLength)
        {
            *TotalLength = BufferLength;
        }
        else
        {
            NtStatus = STATUS_INVALID_PARAMETER;
        }
    }

    if (NULL!=Attribute)
    {
        MIDL_user_free(Attribute);
    }

    return(NtStatus);
}



//
// VARIABLE LENGTH-TO-ATTRBLOCK CONVERSION ROUTINES
//

BOOLEAN
SampIsQualifierTheCount(
    IN INT ObjectType,
    IN ULONG AttrIndex
    )
{
    BOOLEAN IsCount = FALSE;

    SAMTRACE("SampIsQualifierTheCount");

    switch(ObjectType)
    {

    case SampServerObjectType:

        IsCount = FALSE;

        break;

    case SampDomainObjectType:

        IsCount = FALSE;

        break;

    case SampGroupObjectType:

        // Multi-valued attribute

        if ((SAMP_GROUP_MEMBERS == AttrIndex))
        {
            IsCount = TRUE;
        }

        break;

    case SampAliasObjectType:

        // Multi-valued attribute

        if ((SAMP_ALIAS_MEMBERS == AttrIndex))
        {
            IsCount = TRUE;
        }

        break;

    case SampUserObjectType:

        // Multi-valued attributes

        if (SAMP_USER_GROUPS == AttrIndex)
        {
            IsCount = TRUE;
        }

        break;

    default:

        // Error

        break;

    }

    return(IsCount);

}



NTSTATUS
SampConvertAndAppendAttribute(
    IN INT ObjectType,
    IN ULONG AttrIndex,
    IN ULONG CurrentAttribute,
    IN PSAMP_VARIABLE_LENGTH_ATTRIBUTE SamAttributes,
    OUT PDSATTR Attributes
    )

/*++

Routine Description:

    This routine does the work of converting a variable-length attribute from
    a SAM buffer into a DS attribute. A DSATTR structure is constructed and
    passed back from this routine to the caller.

Arguments:

    ObjectType - SAM object type identifier (this parameter is currently un-
        used, but will likely be used to set the maximum number of attributes
        for any given conversion).

    AttrIndex - Index into the array of the variable-length attribute inform-
        ation 
        
    CurrentAttribute - Index into the DS attribute array (i.e. the current attribute).

    SamAttributes - Pointer, returned SAM variable-length attribute buffer.

    Attributes - Pointer, the returned DS attribute structure.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG Offset = SamAttributes[AttrIndex].Offset;
    ULONG Length = SamAttributes[AttrIndex].Length;
    ULONG MultiValuedCount = SamAttributes[AttrIndex].Qualifier;
    BOOLEAN SpecialFlag = FALSE;
    ULONG Index = 0;
    PDSATTRVAL Attribute = NULL;
    PBYTE Value = NULL;

    SAMTRACE("SampConvertAndAppendAttribute");

    // Set the attribute type to the equivalent DS data type.

    Attributes[CurrentAttribute].attrTyp =
        SampVarAttributeInfo[ObjectType][AttrIndex].Type;


    if (TRUE == SampIsQualifierTheCount(ObjectType, AttrIndex))
    {
        // Qualifier contains the attribute's multi-value count.

        Attributes[CurrentAttribute].AttrVal.valCount = MultiValuedCount;
    }
    else
    {
       
        // Qualifier is used for group, alias, membership counts, in which
        // case it serves as the count of a multivalued attribute count. In
        // other cases, it has another meaning:
        //
        // SAM server revision value
        // SAM user-logon hours time units
        //
        // and is not a multivalued count, but something else. These must be
        // handled as special-case values (see below).
        //
        // These are "special" attributes! Add more cases as needed.

        if ((SampUserObjectType == ObjectType) &&
            (SAMP_USER_LOGON_HOURS == AttrIndex))
        {
            SpecialFlag = TRUE;
        }

        MultiValuedCount = 1;
        Attributes[CurrentAttribute].AttrVal.valCount = 1;

    }

    // Allocate memory for the attribute (array if multi-valued).

    Attribute = RtlAllocateHeap(RtlProcessHeap(),
                                0,
                                (MultiValuedCount * sizeof(DSATTRVAL)));

    if (NULL != Attribute)
    {
        RtlZeroMemory(Attribute, (MultiValuedCount * sizeof(DSATTRVAL)));

        // Begin construction of the DSATTR structure by setting the pointer
        // the to the attribute.

        Attributes[CurrentAttribute].AttrVal.pAVal = Attribute;

        // SAM does not store per-value length information for multi-valued
        // attributes, instead the total length of all of the values of a
        // single attribute is stored.

        // Length is the number of bytes in the overall attribute. If the
        // attribute is multi-valued, then this length is the total length
        // of all of the attribute values. The per-value allocation is equal
        // to the Length divided by the number of values (because all values
        // of all multi-valued attributes are a fixed size (i.e. ULONG or
        // LARGE_INTEGER).

        // Test to make sure that total length is an integral multiple of the
        // number of values--a sanity check.

        if (0 == (Length % MultiValuedCount))
        {
            Length = (Length / MultiValuedCount);
        }
        else
        {
            // The length is erroneous, so artificially reset to zero in order
            // to terminate things.

            Length = 0;
        }

        for (Index = 0; Index < MultiValuedCount; Index++)
        {
            // Allocate memory for the attribute data.

            Value = RtlAllocateHeap(RtlProcessHeap(), 0, Length);

            if (NULL != Value)
            {
                RtlZeroMemory(Value, Length);

                // For each value, in the attribute, store its length and
                // copy the value into the destination buffer.

                Attribute[Index].valLen = Length;
                Attribute[Index].pVal = Value;

                // Note: SamAttributes is passed in as PSAMP_VARIABLE_-
                // LENGTH_ATTRIBUTE, hence is explicitly cast to a byte
                // pointer to do the byte-offset arithmetic correctly
                // for RtlCopyMemory.

                if (FALSE == SpecialFlag)
                {
                    // Qualifier was the count, so just copy the attribute.

                    RtlCopyMemory(Value,
                                  (((PBYTE)SamAttributes) + Offset),
                                  Length);
                }
                else
                {
                    
                    // Qualifier was not the count, so first copy the value
                    // of the Qualifier and then append the remaining SAM
                    // attribute onto the end of the buffer, creating a blob
                    // of concatenated values. Note that the first element
                    // is a DWORD, so will be aligned correctly. Enjoy.

                 
                    RtlCopyMemory(Value,
                                  (((PBYTE)SamAttributes) + Offset),
                                  Length);

                  
                }

                // Adjust the SAM-buffer offset to point at the next value in
                // the multi-valued attribute.

                Offset += Length;

                NtStatus = STATUS_SUCCESS;
            }
            else
            {
                NtStatus = STATUS_NO_MEMORY;
                break;
            }
        }
    }
    else
    {
        NtStatus = STATUS_NO_MEMORY;
    }

    return(NtStatus);
}



NTSTATUS
SampConvertVarLengthAttributesToAttrBlock(
    IN PSAMP_OBJECT Context,
    IN PSAMP_VARIABLE_LENGTH_ATTRIBUTE SamAttributes,
    OUT PDSATTRBLOCK *DsAttributes
    )

/*++

Routine Description:

    This routine determines the SAM object type so that the attribute count
    can be set, and then performs the attribute conversion. This routine al-
    locates the top-level DS structure and then calls a helper routine to
    fill in the rest of the data.

Arguments:

    ObjectType - SAM object type identifier (this parameter is currently un-
        used, but will likely be used to set the maximum number of attributes
        for any given conversion).

    SamAttributes - Pointer, returned SAM variable-length attribute buffer.

    DsAttributes - Pointer, the returned DS attribute structure.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG AttributeCount = 0;
    PDSATTR Attributes = NULL;
    PVOID Attribute = NULL;
    ULONG AttrIndex = 0;
    ULONG Length = 0;
    ULONG Qualifier = 0;
    SAMP_OBJECT_TYPE ObjectType = Context->ObjectType;

    SAMTRACE("SampConvertVarLengthAttributesToAttrBlock");

    ASSERT(DsAttributes);
    ASSERT(SamAttributes);

    // Allocate the top-level structure.

    *DsAttributes = RtlAllocateHeap(RtlProcessHeap(),
                                    0,
                                    sizeof(DSATTRBLOCK));

    if (NULL == *DsAttributes)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(*DsAttributes, sizeof(DSATTRBLOCK));

    // Determine the object type, and hence set the corresponding
    // attribute count.

    switch(ObjectType)
    {

    case SampServerObjectType:

        AttributeCount = SAMP_SERVER_VARIABLE_ATTRIBUTES;
        break;

    case SampDomainObjectType:

        AttributeCount = SAMP_DOMAIN_VARIABLE_ATTRIBUTES;
        break;

    case SampGroupObjectType:

        AttributeCount = SAMP_GROUP_VARIABLE_ATTRIBUTES;
        break;

    case SampAliasObjectType:

        AttributeCount = SAMP_ALIAS_VARIABLE_ATTRIBUTES;
        break;

    case SampUserObjectType:

        AttributeCount = SAMP_USER_VARIABLE_ATTRIBUTES;
        break;

    default:

        AttributeCount = 0;
        break;

    }

    DebugPrint("AttributeCount = %lu\n", AttributeCount);

    // Allocate the array of DS attribute-information structs.

    Attributes = RtlAllocateHeap(RtlProcessHeap(),
                                 0,
                                 (AttributeCount * sizeof(DSATTR)));

    if (NULL != Attributes)
    {
        RtlZeroMemory(Attributes, (AttributeCount * sizeof(DSATTR)));

        (*DsAttributes)->attrCount = 0;
        (*DsAttributes)->pAttr = Attributes;

        // Walk through the array of attributes, converting each
        // SAM variable-length attribute to a DS attribute. Refer to
        // the DS header files (core.h, drs.h) for definitions of
        // these structures.

        for (AttrIndex = 0; AttrIndex < AttributeCount; AttrIndex++)
        {
            if ((RtlCheckBit(&Context->PerAttributeDirtyBits, AttrIndex))
                && (!IsGroupMembershipAttr(Context->ObjectType,AttrIndex)))
            {
                //
                // The per attribute dirty is also set. Add this attribute
                // to the attributes to flush
                //

                NtStatus = SampConvertAndAppendAttribute(ObjectType,
                                                     AttrIndex,
                                                     (*DsAttributes)->attrCount,
                                                     SamAttributes,
                                                     Attributes);

                if (!NT_SUCCESS(NtStatus))
                {
                    break;
                }

                (*DsAttributes)->attrCount++;

                DebugPrint("attrCount = %lu\n", (*DsAttributes)->attrCount);
                DebugPrint("attrTyp = %lu\n",   (*DsAttributes)->pAttr[AttrIndex].attrTyp);
                DebugPrint("valCount = %lu\n",   (*DsAttributes)->pAttr[AttrIndex].AttrVal.valCount);
                DebugPrint("valLen = %lu\n",    (*DsAttributes)->pAttr[AttrIndex].AttrVal.pAVal->valLen);
            }
            
        }
    }
    else
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // In the error case, memory should be free by caller by 
    // calling SampFreeAttributeBlock().
    // 

    return(NtStatus);
}



//
// ATTRBLOCK-TO-FIXED LENGTH CONVERSION ROUTINES
//

NTSTATUS
SampExtractFixedLengthAttributeFromDsAttr(
    IN PDSATTR Attribute,
    OUT PULONG Length,
    OUT PVOID *Buffer
    )

/*++

Routine Description:

    This routine determines whether or not the current attribute is single-
    valued or multi-valued and returns a buffer containing the value(s) of
    the attribute. The Call is failed if Multi Valued attributes are present.
    The Assumption is that all fixed attributes are just single valued.

Arguments:

    Attribute - Pointer, incoming DS attribute structure.

    Length - Pointer, returned buffer length.

    Buffer - Pointer, returned buffer containing one or more values.

Return Value:

    STATUS_SUCCESS - Buffer header block allocated and initialized.

    Other codes indicating the nature of the failure.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG ValueCount = 0;
    PDSATTRVALBLOCK ValueBlock;
    PDSATTRVAL Values = NULL;
    ULONG ValueIndex = 0;
    ULONG TotalLength = 0;
    ULONG Offset = 0;

    SAMTRACE("SampExtractFixedLengthAttributeFromDsAttr");

    // Get the count of attributes and a pointer to the attribute. Note that
    // it is possible to have multi-valued attributes, in which case they are
    // appended onto the end of the return buffer.

    if (NULL != Attribute)
    {
        // DSATTR structure contains: attrTyp, AttrVal

        ValueBlock = &(Attribute->AttrVal);

        // DSATTRVALBLOCK structure contains: valCount, pAVal

        if (NULL != ValueBlock)
        {
            ValueCount = ValueBlock->valCount;
            Values = ValueBlock->pAVal;

            if ((1==ValueCount) && (0!=Values->valLen) && (NULL!=Values->pVal))
            {
                *Buffer = Values->pVal;
                *Length = Values->valLen;
                NtStatus = STATUS_SUCCESS;
            }
        }
    }

    return(NtStatus);
}



NTSTATUS
SampVerifyFixedLengthAttribute(
    IN INT ObjectType,
    IN ULONG AttrIndex,
    IN ULONG AttributeLength
    )

/*++

Routine Description:

    This routine verifies that the length of a given (fixed-length) attribute
    obtained from the attribute information in a DSATTRBLOCK is in fact the
    correct length. This check is necessary because the underlying data store
    and various internal DS layers remap the SAM data types to their internal
    data types, which may be a different size (e.g. BOOLEAN is mapped to INT).
    Validation of the lenght is accomplished by comparing the passed-in length
    to the a prior known lengths stored in the SampFixedAttributeInfo table.

    NOTE: Currently, this routine simply checks for equality, returning an
    error if the two lengths are not equal. This test may need to "special
    case" certain attributes as the database schema is finalized and more is
    known about the underlying data types.


Arguments:

    ObjectType - SAM Object identifier (server, domain, etc.) index

    AttrIndex - Index into the array of fixed-length attribute length inform-
        ation.

    AttributeLength - Attribute length (byte count) to be verified.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampVerifyFixedLengthAttribute");

    // Verify that the attribute length is correct. The AttributeLength is
    // already rounded up to a DWORD boundary, so do the same for the attri-
    // bute information length.

    if (AttributeLength ==
            (SampFixedAttributeInfo[ObjectType][AttrIndex].Length))
    {
        

        NtStatus = STATUS_SUCCESS;
    }
    else
    {
        DebugPrint("AttributeLength = %lu Length = %lu\n",
                   AttributeLength,
                   SampFixedAttributeInfo[ObjectType][AttrIndex].Length);
    }


    return(NtStatus);
}



NTSTATUS
SampAppendFixedLengthAttributeToBuffer(
    IN INT ObjectType,
    IN ULONG AttrIndex,
    IN PVOID NewAttribute,
    IN OUT PVOID SamAttributes
    )

/*++

Routine Description:

    This routine builds a SAM fixed-length attribute buffer from a correspond-
    ing DS attribute by copying the data into the SAM fixed-length structure.

    Note that pointer-casts during structure member assignment are not only
    needed due to the fact that NewAttribute is a PVOID, but also because the
    DS uses different data types than does SAM for certain data types (e.g.
    SAM USHORT is stored as a four-byte integer in the DS). Refer to the Samp-
    FixedAttributeInfo table for details. The data truncation is benign in
    all cases.

Arguments:

    ObjectType - SAM object type (server, domain, etc.).

    AttrIndex - Index of the attribute to set. This value corresponds to the
        elements of the various fixed-length attributes (see samsrvp.h).

    NewAttribute - The incoming attribute, extracted from the DS data.

    SamAttributes - Pointer, updated SAM attribute buffer.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PSAMP_V1_FIXED_LENGTH_SERVER ServerAttrs = NULL;
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN DomainAttrs = NULL;
    PSAMP_V1_0A_FIXED_LENGTH_GROUP GroupAttrs = NULL;
    PSAMP_V1_FIXED_LENGTH_ALIAS AliasAttrs = NULL;
    PSAMP_V1_0A_FIXED_LENGTH_USER UserAttrs = NULL;

    SAMTRACE("SampAppendFixedLengthAttributeToBuffer");

    ASSERT(NULL != NewAttribute);
    ASSERT(NULL != SamAttributes);

    // BUG: Define constants for the fixed attributes cases.

    // Determine the object type, and then the attribute for that object
    // to copy into the target SAM fixed-length structure.

    switch(ObjectType)
    {

    case SampServerObjectType:

        ServerAttrs = SamAttributes;

        switch(AttrIndex)
        {

        case 0:
            ServerAttrs->RevisionLevel = *(PULONG)NewAttribute;
            break;

        default:
            NtStatus = STATUS_INTERNAL_ERROR;
            break;

        }

        break;

    case SampDomainObjectType:

        DomainAttrs = SamAttributes;

        //
        // The following Domain Attrs are Defaulted rather than
        // Read from the Database
        //

        DomainAttrs->Revision = SAMP_DS_REVISION;
        DomainAttrs->Unused1  = 0;
        DomainAttrs->ServerRole = DomainServerRoleBackup;

        switch(AttrIndex)
        {
        
        case 0:
            DomainAttrs->CreationTime = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 1:
            DomainAttrs->ModifiedCount = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 2:
            DomainAttrs->MaxPasswordAge = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 3:
            DomainAttrs->MinPasswordAge = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 4:
            DomainAttrs->ForceLogoff = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 5:
            DomainAttrs->LockoutDuration = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 6:
            DomainAttrs->LockoutObservationWindow = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 7:
            DomainAttrs->ModifiedCountAtLastPromotion = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 8:
            DomainAttrs->NextRid = *(PULONG)NewAttribute;
            break;

        case 9:
            DomainAttrs->PasswordProperties = *(PULONG)NewAttribute;
            break;

        case 10:
            DomainAttrs->MinPasswordLength = *(PUSHORT)NewAttribute;
            break;

        case 11:
            DomainAttrs->PasswordHistoryLength = *(PUSHORT)NewAttribute;
            break;

        case 12:
            DomainAttrs->LockoutThreshold = *(PUSHORT)NewAttribute;
            break;

        case 13:
            DomainAttrs->ServerState = *(PULONG)NewAttribute;
            break;

       
        case 14:
            DomainAttrs->UasCompatibilityRequired = *(PBOOLEAN)NewAttribute;
            break;

        default:

            ASSERT(FALSE && "Unknown Attribute");
            NtStatus = STATUS_INTERNAL_ERROR;
            break;

        }

        break;

    case SampGroupObjectType:

        GroupAttrs = SamAttributes;

        //
        // The following Group Attrs are defaulted rather than
        // read from the Database
        //

        GroupAttrs->Revision = SAMP_DS_REVISION;
        GroupAttrs->Attributes = SAMP_DEFAULT_GROUP_ATTRIBUTES;
        GroupAttrs->Unused1 = 0;
        GroupAttrs->AdminCount =0;
        GroupAttrs->OperatorCount = 0;

        switch(AttrIndex)
        {

       
        case 0:
            GroupAttrs->RelativeId = *(PULONG)NewAttribute;
            break;

        default:

            ASSERT(FALSE && "Unknown Attribute");
            NtStatus = STATUS_INTERNAL_ERROR;
            break;

        }

        break;

    case SampAliasObjectType:

        AliasAttrs = SamAttributes;

        switch(AttrIndex)
        {

        case 0:
            AliasAttrs->RelativeId = *(PULONG)NewAttribute;
            break;

        default:
            ASSERT(FALSE && "Unknown Attribute");
            NtStatus = STATUS_INTERNAL_ERROR;
            break;

        }

        break;

    case SampUserObjectType:

        UserAttrs = SamAttributes;

        //
        // The following User Attrs are defaulted rather than
        // read from the database
        //
        
        UserAttrs->Revision = SAMP_DS_REVISION;
        UserAttrs->Unused1  = 0;
        UserAttrs->Unused2  = 0;
        UserAttrs->AdminCount = 0;
        UserAttrs->OperatorCount = 0;

        switch(AttrIndex)
        {

       
        case 0:
            UserAttrs->LastLogon = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 1:
            UserAttrs->LastLogoff = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 2:
            UserAttrs->PasswordLastSet = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 3:
            UserAttrs->AccountExpires = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 4:
            UserAttrs->LastBadPasswordTime = *(PLARGE_INTEGER)NewAttribute;
            break;

        case 5:
            UserAttrs->UserId = *(PULONG)NewAttribute;
            break;

        case 6:
            UserAttrs->PrimaryGroupId = *(PULONG)NewAttribute;
            break;

        case 7:
            UserAttrs->UserAccountControl = *(PULONG)NewAttribute;
            break;

        case 8:
            UserAttrs->CountryCode = *(PUSHORT)NewAttribute;
            break;

        case 9:
            UserAttrs->CodePage = *(PUSHORT)NewAttribute;
            break;

        case 10:
            UserAttrs->BadPasswordCount = *(PUSHORT)NewAttribute;
            break;

        case 11:
            UserAttrs->LogonCount = *(PUSHORT)NewAttribute;
            break;

     
        default:
            ASSERT(FALSE && "Unknown Attribute");
            NtStatus = STATUS_INTERNAL_ERROR;
            break;

        }

        break;

    default:
        ASSERT(FALSE && "Unknown Object Type");
        NtStatus = STATUS_INTERNAL_ERROR;
        break;

    }
    

    return(NtStatus);
}


NTSTATUS
SampGetDefaultAttributeValue(
    IN  ULONG            RequestedAttrTyp,
    IN  SAMP_OBJECT_TYPE ObjectType,
    IN  ULONG            BufferSize,
    IN  OUT PVOID        Buffer,
    OUT PULONG           DefaultLen
    )
/*++

  Routine Description

     This Routine Provides Default Values for all those Fixed Attributes
     that are not present in the DS. Not all fixed attributes have default
     values. Only those subset of attributes that are not replicated are
     provided default values by this routine. This is because in the replicated
     install case, they will not be initially set and therefore in order to continue
     we must provide default Values


   Parameters:

        RequestedAttrTyp -- The Attribute that we requested
        ObjectType       -- The object type of the object
        BufferSize       -- The Size of the passed in buffer
        Buffer           -- The Passed in Buffer
        DefaultLen       -- The length of the attribute is returned in here. A length of zero
                            returned in here means that no attribute is found, but the caller
                            should go on without supplying an attribute value for that attribute

   Return Values

    STATUS_SUCCESS
    STATUS_INTERNAL_ERROR

--*/
{
    NTSTATUS    NtStatus = STATUS_SUCCESS;

    switch (ObjectType)
    {
    case SampDomainObjectType:
        switch(RequestedAttrTyp)
        {
       
        //
        // Server State is defaulted to Enabled
        //

        case SAMP_FIXED_DOMAIN_SERVER_STATE:
            *DefaultLen = sizeof(DOMAIN_SERVER_ENABLE_STATE);
            ASSERT(BufferSize>=*DefaultLen);
            *((DOMAIN_SERVER_ENABLE_STATE *)Buffer) = DomainServerEnabled;
            break;

        //
        // Modified Count is defaulted to 1
        //

        case SAMP_FIXED_DOMAIN_MODIFIED_COUNT:
            *DefaultLen = sizeof(LARGE_INTEGER);
             ASSERT(BufferSize>=*DefaultLen);
             ((LARGE_INTEGER *)Buffer)->QuadPart = 1;
             break;

        default:
            NtStatus = STATUS_INTERNAL_ERROR;
            break;
        }
        break;

    case SampUserObjectType:

        switch(RequestedAttrTyp)
        {

        //
        // Logon and Bad pwd counts are defaulted to 0
        //

        case SAMP_FIXED_USER_BAD_PWD_COUNT:
        case SAMP_FIXED_USER_LOGON_COUNT:

            *DefaultLen = sizeof(DS_USHORT);
            ASSERT(BufferSize>=*DefaultLen);
            *((DS_USHORT *)Buffer) = 0;
            break;

        //
        // Last Logon, Last Logoff and Bad Pwd Times are defaulted to Never
        //

        case SAMP_FIXED_USER_LAST_LOGON:
        case SAMP_FIXED_USER_LAST_LOGOFF:
        case SAMP_FIXED_USER_LAST_BAD_PASSWORD_TIME:

            *DefaultLen = sizeof(LARGE_INTEGER);
            ASSERT(BufferSize>=*DefaultLen);
            RtlCopyMemory(Buffer,&SampHasNeverTime,sizeof(LARGE_INTEGER));
            break;

        default:
            //
            // Under Normal Circumstances the only properties that may be absent
            // are the non replicable properties above. However in a freshly created
            // account object not all properties are set and therefore this function
            // is called to initialize default values. The value of such defaults is
            // immaterial as the properties would be written to immediately. 
            // This function therefore just returns a length of 0.
            //

            *DefaultLen = 0;
            break;
        }

        break;

        case SampAliasObjectType:
        case SampGroupObjectType:

            //
            // Same Reason as Above
            //

            *DefaultLen = 0;
            break;

    default:

        NtStatus = STATUS_INTERNAL_ERROR;
        break;
    }

    return NtStatus;
}



NTSTATUS
SampConvertAttrBlockToFixedLengthAttributes(
    IN INT ObjectType,
    IN PDSATTRBLOCK DsAttributes,
    OUT PVOID *SamAttributes,
    OUT PULONG TotalLength
    )

/*++

Routine Description:

    This routine converts a DS ATTRBLOCK into a SAM fixed-length buffer. The
    SAM buffer that is passed back from the routine can be either treated as
    a blob or can be cast to one of the SAM fixed-length attribute types for
    convenience.

Arguments:

    ObjectType - Identifies which SAM object type, and hence, which attribute
        set to work with.

    DsAttributes - Pointer, incoming DS ATTRBLOCK containing fixed-length
        attributes.

    SamAttributes - Pointer, updated SAM attribute buffer.

    TotalLength - Pointer, length of the SAM fixed attribute data returned.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG ReturnedAttrCount = 0;
    PDSATTR Attributes = NULL;
    ULONG Length = 0;
    ULONG BufferLength = 0;
    ULONG AttributeLength = 0;
    ULONG ReturnedAttrIndex = 0;
    PVOID AttributeValue = NULL;
    ULONG RequestedAttrIndex=0;
    ULONG RequestedAttrCount=0;
    UCHAR DefaultValueBuffer[sizeof(LARGE_INTEGER)];
    

    SAMTRACE("SampConvertAttrBlockToFixedLengthAttributes");

    ASSERT(NULL!=DsAttributes);
    ASSERT(NULL!=SamAttributes);
    ASSERT(NULL!=TotalLength);    

    ReturnedAttrCount = DsAttributes->attrCount;
    RequestedAttrCount = ARRAY_COUNT(SampFixedAttributeInfo[ObjectType]);
    Attributes = DsAttributes->pAttr;
    
    ASSERT(NULL!=Attributes);

    // Using the SAM object type identifer, set the length of the buffer
    // to be allocated based on the fixed-length data structure.

    switch(ObjectType)
    {

    case SampServerObjectType:

        Length = sizeof(SAMP_V1_FIXED_LENGTH_SERVER);
        break;

    case SampDomainObjectType:

        Length = sizeof(SAMP_V1_0A_FIXED_LENGTH_DOMAIN);
        break;

    case SampGroupObjectType:

        Length = sizeof(SAMP_V1_0A_FIXED_LENGTH_GROUP);
        break;

    case SampAliasObjectType:

        Length = sizeof(SAMP_V1_FIXED_LENGTH_ALIAS);
        break;

    case SampUserObjectType:

        Length = sizeof(SAMP_V1_0A_FIXED_LENGTH_USER);
        break;

    default:

        Length = 0;
        break;
    }

    // Allocate space for the fixed-length attributes.
    
    *SamAttributes = MIDL_user_allocate(Length);

    if (NULL != *SamAttributes)
    {
        RtlZeroMemory(*SamAttributes, Length);

        //
        // Walk the DSATTRBLOCK, pulling out the attributes and returning
        // each one in the Attribute out parameter.
        //

        for (ReturnedAttrIndex = 0,RequestedAttrIndex=0; 
                (ReturnedAttrIndex<ReturnedAttrCount)&&(RequestedAttrIndex<RequestedAttrCount); 
                    RequestedAttrIndex++)
        {

            ULONG   RequestedAttrTyp;
            ULONG   ReturnedAttrTyp;

            AttributeValue = NULL;
            
            // 
            // The Read would have asked for all attributes, but the DS may
            // not have returned all the attributes. In case a particular 
            // attribute was missing, the DS does not give an error value in
            // its place, but rather just simply skips them. Therefore try to
            // match the attribute Type , Starting from the Last Sam Atribute
            // that we matched
            //
            ReturnedAttrTyp = Attributes[ReturnedAttrIndex].attrTyp;
            RequestedAttrTyp  = SampFixedAttributeInfo[ObjectType][RequestedAttrIndex].Type;
            if (RequestedAttrTyp!=ReturnedAttrTyp)
            {
                //
                // The Attribute at RequestedAttrIndex has not been returned by the DS.
                // The reason, for that in the absence of any other error codes is that
                // the attribute is not present. This is a legal condition and in this
                // case provide a default value for the attribute from the table
                //

                
                NtStatus = SampGetDefaultAttributeValue(
                                RequestedAttrTyp,
                                ObjectType,
                                sizeof(DefaultValueBuffer),
                                DefaultValueBuffer,
                                &AttributeLength
                                );

                if (NT_SUCCESS(NtStatus))
                {

                    if (AttributeLength>0)
                    {

                        AttributeValue = DefaultValueBuffer;
                    }
                    else
                    {
                        //
                        // You may get a 0 for a defaulted length. This just
                        // means that the property has not been set and happens
                        // when a new object is being created
                        // 

                        ASSERT(NULL==AttributeValue);
                    }

                }

                //
                // Since we defaulted the attribute we should not proceed to the
                // next returned attribute, ie do not increment ReturnedAttrIndex.
                // We will examine if this returned attribute matches the next 
                // requested attribute.
                //
            }
            else
            {
                //
                // The attribute was returned by the DS.
                //

                NtStatus = SampExtractFixedLengthAttributeFromDsAttr(
                                        &(Attributes[ReturnedAttrIndex]),
                                        &AttributeLength,
                                        &AttributeValue);

                //
                // Verify the extraction
                //

                if (NT_SUCCESS(NtStatus))
                {
                    NtStatus = SampVerifyFixedLengthAttribute(ObjectType,
                                                      RequestedAttrIndex,
                                                      AttributeLength);

                    //
                    // We may now proceed to the next Returned Attribute
                    //

                    ReturnedAttrIndex++;
                }
            }

            // Append the attribute onto the end of the SAM buffer (i.e.
            // fill in the members of the fixed-length data structure).

            // NOTE: This routine assumes that the order of the attributes
            // returned in the DSATTRBLOCK are correct (i.e. correspond
            // to the order of the members in the given SAM fixed-length
            // structure). It also assumes that SAM fixed-length attri-
            // butes are always single-valued attributes.

            if (NT_SUCCESS(NtStatus))
            {

                
                if (NULL!=AttributeValue)
                {
              
                    //
                    // If the Attribute is Non Null then Set it in the
                    // Fixed Attributes Blob
                    //
                    NtStatus = SampAppendFixedLengthAttributeToBuffer(
                                    ObjectType,
                                    RequestedAttrIndex,
                                    AttributeValue,
                                    *SamAttributes
                                    );
                }
                else
                {
                    //
                    // You may have NULL values for attributes in conditions where
                    // you are newly creating objects where all properties are not
                    // yet set. This is O.K and legal.
                    //
                }
                              
            }
            else
            {
                //
                // We error'd out so break out of the loop
                //

                break;
            }
        }
                    
        *TotalLength = Length;
       
    }
    else
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
       
    }

    return(NtStatus);
}



//
// FIXED LENGTH-TO-ATTRBLOCK CONVERSION ROUTINES
//

NTSTATUS
SampConvertFixedLengthAttributes(
    IN INT ObjectType,
    IN PVOID SamAttributes,
    IN ULONG AttributeCount,
    OUT PDSATTR Attributes
    )

/*++

Routine Description:

    This routine does the work of converting a given SAM fixed-length attri-
    bute type (i.e. contains all of the fixed-length attributes pertinent to
    the specified ObjectType) into a DSATTR array. Related DS attribute infor-
    mation, such as attribute length and type, are also set by this routine.

Arguments:

    ObjectType - Identifies which SAM object type, and hence, which attribute
        set to work with.

    SamAttributes - Pointer, updated SAM attribute buffer.

    AttributeCount - Number of attributes to convert into DSATTRs.

    Attributes - Pointer, outgoing DSATTR, containing fixed-length attributes.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG Offset = 0;
    ULONG Length = 0;
    ULONG SamLength=0;
    ULONG Index = 0;
    PDSATTRVAL Attribute = NULL;
    PBYTE Value = NULL;
    ULONG AttrIndex = 0;
    PSAMP_V1_FIXED_LENGTH_SERVER ServerAttrs = NULL;
    PSAMP_V1_0A_FIXED_LENGTH_DOMAIN DomainAttrs = NULL;
    PSAMP_V1_0A_FIXED_LENGTH_GROUP GroupAttrs = NULL;
    PSAMP_V1_FIXED_LENGTH_ALIAS AliasAttrs = NULL;
    PSAMP_V1_0A_FIXED_LENGTH_USER UserAttrs = NULL;

    SAMTRACE("SampConvertFixedLengthAttributes");

    for (AttrIndex = 0; AttrIndex < AttributeCount; AttrIndex++)
    {
        // BUG: Assuming that all fixed-length attributes are single-valued.

        // Set the multi-value count to 1 for the fixed-length attribute, and
        // set its type identifier.

        Attributes[AttrIndex].AttrVal.valCount = 1;

        Attributes[AttrIndex].attrTyp =
            SampFixedAttributeInfo[ObjectType][AttrIndex].Type;

        // First, allocate a block for the individual DSATTRVAL.

        Attribute = RtlAllocateHeap(RtlProcessHeap(), 0, sizeof(DSATTRVAL));

        if (NULL != Attribute)
        {
            RtlZeroMemory(Attribute, sizeof(DSATTRVAL));

            Attributes[AttrIndex].AttrVal.pAVal = Attribute;
            Length = SampFixedAttributeInfo[ObjectType][AttrIndex].Length;
            SamLength = SampFixedAttributeInfo[ObjectType][AttrIndex].SamLength;
            ASSERT(SamLength<=Length);

            // Second, allocate a block for the actual value, and make the
            // DSATTRVAL point to it.

            Value = RtlAllocateHeap(RtlProcessHeap(), 0, Length);

            if (NULL != Value)
            {
                RtlZeroMemory(Value, Length);
                Attribute->pVal = Value;
                Attribute->valLen = Length;

                // Then copy the data into the target DS attribute.

                switch(ObjectType)
                {

                case SampServerObjectType:

                    ServerAttrs = SamAttributes;

                    switch(AttrIndex)
                    {

                    case 0:
                        RtlCopyMemory(Value,
                                     &(ServerAttrs->RevisionLevel),
                                     SamLength);
                        break;

                    default:
                        ASSERT(FALSE && "UndefinedAttribute");
                        NtStatus = STATUS_INTERNAL_ERROR;
                        break;

                    }

                    break;

                case SampDomainObjectType:

                    DomainAttrs = SamAttributes;

                    switch(AttrIndex)
                    {


                    case 0:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->CreationTime),
                                     SamLength);
                        break;

                    case 1:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->ModifiedCount),
                                     SamLength);
                        break;

                    case 2:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->MaxPasswordAge),
                                     SamLength);
                        break;

                    case 3:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->MinPasswordAge),
                                     SamLength);
                        break;

                    case 4:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->ForceLogoff),
                                     SamLength);
                        break;

                    case 5:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->LockoutDuration),
                                     SamLength);
                        break;

                    case 6:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->LockoutObservationWindow),
                                     SamLength);
                        break;

                    case 7:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->ModifiedCountAtLastPromotion),
                                     SamLength);
                        break;

                    case 8:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->NextRid),
                                     SamLength);
                        break;

                    case 9:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->PasswordProperties),
                                     SamLength);
                        break;

                    case 10:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->MinPasswordLength),
                                     SamLength);
                        break;

                    case 11:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->PasswordHistoryLength),
                                     SamLength);
                        break;

                    case 12:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->LockoutThreshold),
                                     SamLength);
                        break;

                    case 13:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->ServerState),
                                     SamLength);
                        break;
                   
                    case 14:
                        RtlCopyMemory(Value,
                                     &(DomainAttrs->UasCompatibilityRequired),
                                     SamLength);
                        break;

                    default:
                        ASSERT(FALSE && "UndefinedAttribute");
                        NtStatus = STATUS_INTERNAL_ERROR;
                        break;

                    }

                    break;

                case SampGroupObjectType:

                    GroupAttrs = SamAttributes;

                    switch(AttrIndex)
                    {

                    
                    case 0:
                        RtlCopyMemory(Value,
                                     &(GroupAttrs->RelativeId),
                                     SamLength);
                        break;

                   
                    default:
                        ASSERT(FALSE && "UndefinedAttribute");
                        NtStatus = STATUS_INTERNAL_ERROR;
                        break;

                    }

                    break;

                case SampAliasObjectType:

                    AliasAttrs = SamAttributes;

                    switch(AttrIndex)
                    {

                    case 0:
                        RtlCopyMemory(Value,
                                     &(AliasAttrs->RelativeId),
                                     SamLength);
                        break;

                    default:
                        ASSERT(FALSE && "UndefinedAttribute");
                        NtStatus = STATUS_INTERNAL_ERROR;
                        break;

                    }

                    break;

                case SampUserObjectType:

                    UserAttrs = SamAttributes;

                    switch(AttrIndex)
                    {

                    case 0:
                        RtlCopyMemory(Value,
                                     &(UserAttrs->LastLogon),
                                     SamLength);
                        break;

                    case 1:
                        RtlCopyMemory(Value,
                                     &(UserAttrs->LastLogoff),
                                     SamLength);
                        break;

                    case 2:
                        RtlCopyMemory(Value,
                                     &(UserAttrs->PasswordLastSet),
                                     SamLength);
                        break;

                    case 3:
                        RtlCopyMemory(Value,
                                     &(UserAttrs->AccountExpires),
                                     SamLength);
                        break;

                    case 4:
                        RtlCopyMemory(Value,
                                     &(UserAttrs->LastBadPasswordTime),
                                     SamLength);
                        break;

                    case 5:
                        RtlCopyMemory(Value,
                                     &(UserAttrs->UserId),
                                     SamLength);
                        break;

                    case 6:
                        RtlCopyMemory(Value,
                                     &(UserAttrs->PrimaryGroupId),
                                     SamLength);
                        break;

                    case 7:
                        RtlCopyMemory(Value,
                                     &(UserAttrs->UserAccountControl),
                                     SamLength);
                        break;

                    case 8:
                        RtlCopyMemory(Value,
                                     &(UserAttrs->CountryCode),
                                     SamLength);
                        break;

                    case 9:
                        RtlCopyMemory(Value,
                                     &(UserAttrs->CodePage),
                                     SamLength);
                        break;

                    case 10:
                        RtlCopyMemory(Value,
                                     &(UserAttrs->BadPasswordCount),
                                     SamLength);
                        break;

                    case 11:
                        RtlCopyMemory(Value,
                                     &(UserAttrs->LogonCount),
                                     SamLength);
                        break;


                    default:
                        ASSERT(FALSE && "UndefinedAttribute");
                        NtStatus = STATUS_INTERNAL_ERROR;
                        break;

                    }

                    break;

                default:
                    ASSERT(FALSE && "UndefinedObjectClass");
                    NtStatus = STATUS_INTERNAL_ERROR;
                    break;

                }
            }
            else
            {
                NtStatus = STATUS_NO_MEMORY;
                break;
            }
        }
        else
        {
            NtStatus = STATUS_NO_MEMORY;
            break;
        }
    }

    return(NtStatus);
}



NTSTATUS
SampConvertFixedLengthAttributesToAttrBlock(
    IN INT ObjectType,
    IN PVOID SamAttributes,
    OUT PDSATTRBLOCK *DsAttributes
    )

/*++

Routine Description:

    This routine is the top-level routine for converting a SAM fixed-length
    attribute into a DSATTRBLOCK. Based on the SAM object type, the attribute
    count is set, and subsequently used to allocate memory for the DS attri-
    butes.

Arguments:

    ObjectType - Identifies which SAM object type, and hence, which attribute
        set to work with.

    SamAttributes - Pointer, updated SAM attribute buffer.

    DsAttributes - Pointer, outgoing DSATTRBLOCK, containing fixed-length
        attributes.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG AttributeCount = 0;
    ULONG Length = 0;
    PDSATTR Attributes = NULL;

    SAMTRACE("SampConvertFixedLengthAttributesToAttrBlock");

    ASSERT(SamAttributes);
    ASSERT(DsAttributes);

    // Allocate the top-level DS structure, DSATTRBLOCK.

    *DsAttributes = RtlAllocateHeap(RtlProcessHeap(),
                                    0,
                                    sizeof(DSATTRBLOCK));

    if (NULL == *DsAttributes)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    // From the SAM object type, set the attribute count.

    RtlZeroMemory(*DsAttributes, sizeof(DSATTRBLOCK));

    switch(ObjectType)
    {

    case SampServerObjectType:

        AttributeCount = SAMP_SERVER_FIXED_ATTR_COUNT;
        break;

    case SampDomainObjectType:

        AttributeCount = SAMP_DOMAIN_FIXED_ATTR_COUNT;
        break;

    case SampGroupObjectType:

        AttributeCount = SAMP_GROUP_FIXED_ATTR_COUNT;
        break;

    case SampAliasObjectType:

        AttributeCount = SAMP_ALIAS_FIXED_ATTR_COUNT;
        break;

    case SampUserObjectType:

        AttributeCount = SAMP_USER_FIXED_ATTR_COUNT;
        break;

    default:

        break;

    }

    // Allocate a block for the DSATTR array, then convert the SAM
    // fixed-length attributes into the DSATTRBLOCK.

    Length = AttributeCount * sizeof(DSATTR);
    Attributes = RtlAllocateHeap(RtlProcessHeap(), 0, Length);

    if (NULL != Attributes)
    {
        RtlZeroMemory(Attributes, Length);

        (*DsAttributes)->attrCount = AttributeCount;
        (*DsAttributes)->pAttr = Attributes;

        NtStatus = SampConvertFixedLengthAttributes(ObjectType,
                                                    SamAttributes,
                                                    AttributeCount,
                                                    Attributes);
    }
    else
    {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // In the error case, allocated memory will be free by 
    // the caller
    // 

    return(NtStatus);
}



//
// ATTRBLOCK-TO-COMBINED BUFFER CONVERSION ROUTINES
//

NTSTATUS
SampWalkAttrBlock(
    IN ULONG FixedLengthAttributeCount,
    IN ULONG VarLengthAttributeCount,
    IN PDSATTRBLOCK DsAttributes,
    OUT PDSATTRBLOCK *FixedLengthAttributes,
    OUT PDSATTRBLOCK *VarLengthAttributes
    )

/*++

Routine Description:

    This routine scans the DSATTRBLOCK containing the fixed and variable-
    length attributes, identifying where each starts. Two new DSATTRBLOCK are
    allocated, one that points to the fixed-length data, while the second
    points at the variable-length data.

Arguments:

    FixedLengthAttributeCount - Number of fixed-length attributes for this
        object.

    VarLengthAttributeCount - Number of variable-length attributes for this
        object.

    DsAttributes - Pointer, incoming DSATTRBLOCK, containing all of the
        attributes.

    FixedLengthAttributes - Pointer, returned pointer to the first fixed-
        length attribute.

    VarLengthAttributes - Pointer, returned pointer to the first variable-
        length attribute.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG AttributeCount = FixedLengthAttributeCount + VarLengthAttributeCount;

    if ((0 < FixedLengthAttributeCount) &&
        (0 < VarLengthAttributeCount) &&
        (NULL != DsAttributes))
    {
        ASSERT(DsAttributes->attrCount == AttributeCount);

        if ((NULL != FixedLengthAttributes) &&
            (NULL != VarLengthAttributes))
        {
            // Allocate a new DSATTRBLOCK structure that will point to the
            // first N DSATTR elements, representing the fixed-length attri-
            // butes for this SAM object.

            *FixedLengthAttributes = RtlAllocateHeap(RtlProcessHeap(),
                                                     0,
                                                     sizeof(DSATTRBLOCK));

            if (NULL != *FixedLengthAttributes)
            {
                RtlZeroMemory(*FixedLengthAttributes, sizeof(DSATTRBLOCK));

                // Set the pointer, and attribute count to the number of fixed
                // length attributes.

                if (NULL != DsAttributes->pAttr)
                {
                    (*FixedLengthAttributes)->pAttr = DsAttributes->pAttr;

                    (*FixedLengthAttributes)->attrCount =
                        FixedLengthAttributeCount;

                    // Now, allocate a second DSATTRBLOCK that will point
                    // to the variable-length attributes.

                    *VarLengthAttributes = RtlAllocateHeap(RtlProcessHeap(),
                                                           0,
                                                           sizeof(DSATTRBLOCK));

                    if (NULL != *VarLengthAttributes)
                    {
                        RtlZeroMemory(*VarLengthAttributes,
                                      sizeof(DSATTRBLOCK));

                        // The remaining M DSATTR elements represent the var-
                        // iable length attributes. Set the pointer, and the
                        // attribute count to the number of variable attrs.

                        (*VarLengthAttributes)->pAttr =
                            DsAttributes->pAttr + FixedLengthAttributeCount;

                        (*VarLengthAttributes)->attrCount =
                            VarLengthAttributeCount;

                        NtStatus = STATUS_SUCCESS;
                    }
                    else
                    {
                        NtStatus = STATUS_NO_MEMORY;
                    }
                }
                else
                {
                    NtStatus = STATUS_INTERNAL_ERROR;
                }
            }
            else
            {
                NtStatus = STATUS_NO_MEMORY;
            }
        }
        else
        {
            NtStatus = STATUS_INVALID_PARAMETER;
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return(NtStatus);
}



NTSTATUS
SampLocateAttributesInAttrBlock(
    IN INT ObjectType,
    IN PDSATTRBLOCK DsAttributes,
    OUT PDSATTRBLOCK *FixedLengthAttributes,
    OUT PDSATTRBLOCK *VarLengthAttributes
    )

/*++

Routine Description:

    This routine determines the number of attributes based on object type,
    then calls a worker routine to obtain pointers to the fixed-length and
    variable-length portions of the DSATTRBLOCK.

Arguments:

    ObjectType - Identifies which SAM object type, and hence, which attribute
        set to work with.

    DsAttributes - Pointer, incoming DSATTRBLOCK.

    FixedLengthAttributes - Pointer, returned pointer to the fixed data.

    VarLengthAttributes - Pointer, returned pointer to the variable data.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG FixedLengthAttributeCount = 0;
    ULONG VarLengthAttributeCount = 0;
    ULONG AttributeCount = 0;

    SAMTRACE("SampLocateAttributesInAttrBlock");

    // Set the fixed-length, variable-length attribute counts based upon
    // the object type.

    switch(ObjectType)
    {

    case SampServerObjectType:

        FixedLengthAttributeCount = SAMP_SERVER_FIXED_ATTR_COUNT;
        VarLengthAttributeCount = SAMP_SERVER_VARIABLE_ATTRIBUTES;
        break;

    case SampDomainObjectType:

        FixedLengthAttributeCount = SAMP_DOMAIN_FIXED_ATTR_COUNT;
        VarLengthAttributeCount = SAMP_DOMAIN_VARIABLE_ATTRIBUTES;
        break;

    case SampGroupObjectType:

        FixedLengthAttributeCount = SAMP_GROUP_FIXED_ATTR_COUNT;
        VarLengthAttributeCount = SAMP_GROUP_VARIABLE_ATTRIBUTES;
        break;

    case SampAliasObjectType:

        FixedLengthAttributeCount = SAMP_ALIAS_FIXED_ATTR_COUNT;
        VarLengthAttributeCount = SAMP_ALIAS_VARIABLE_ATTRIBUTES;
        break;

    case SampUserObjectType:

        FixedLengthAttributeCount = SAMP_USER_FIXED_ATTR_COUNT;
        VarLengthAttributeCount = SAMP_USER_VARIABLE_ATTRIBUTES;
        break;

    default:
        break;

    }

    AttributeCount = FixedLengthAttributeCount + VarLengthAttributeCount;

    if (0 < AttributeCount)
    {
        NtStatus = SampWalkAttrBlock(FixedLengthAttributeCount,
                                     VarLengthAttributeCount,
                                     DsAttributes,
                                     FixedLengthAttributes,
                                     VarLengthAttributes);
    }

    return(NtStatus);
}



NTSTATUS
SampCombineSamAttributes(
    IN PVOID SamFixedLengthAttributes,
    IN ULONG FixedLength,
    IN PSAMP_VARIABLE_LENGTH_ATTRIBUTE SamVarLengthAttributes,
    IN ULONG VarLength,
    OUT PVOID *SamAttributes
    )

/*++

Routine Description:

    This routine combines the SAM fixed and variable-length buffers into a
    single SAM combined-attribute buffer.

Arguments:

    SamFixedLengthAttributes - Pointer, fixed attributes.

    FixedLength - Number of bytes.

    SamVarLengthAttributes - Pointer, variable attributes.

    VarLength - Number of bytes.

    SamAttributes - Pointer, returned combined-attribute buffer.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG CombinedLength = 0;

    SAMTRACE("SampCombineSamAttributes");

    if ((0 < FixedLength) && (0 < VarLength))
    {
        // Adjust the length so that the appended variable attributes start
        // on a DWORD boundary.

        FixedLength = DWORD_ALIGN(FixedLength);
        CombinedLength = FixedLength + VarLength;

        if (NULL != SamAttributes)
        {
            // Allocate a new buffer for the combined attributes.

            *SamAttributes = RtlAllocateHeap(RtlProcessHeap(),
                                             0,
                                             CombinedLength);

            if (NULL != *SamAttributes)
            {
                RtlZeroMemory(*SamAttributes, CombinedLength);

                if ((NULL != SamFixedLengthAttributes) &&
                    (NULL != SamVarLengthAttributes))
                {
                    // BUG: Check return value from RtlCopyMemory.

                    // Copy the fixed-length attributes first...

                    RtlCopyMemory(*SamAttributes,
                                 SamFixedLengthAttributes,
                                 FixedLength);

                    RtlFreeHeap(RtlProcessHeap(), 0, SamFixedLengthAttributes);

                    // then the variable ones.

                    RtlCopyMemory(((PBYTE)(*SamAttributes)) + FixedLength,
                                 SamVarLengthAttributes,
                                 VarLength);

                    RtlFreeHeap(RtlProcessHeap(), 0, SamVarLengthAttributes);

                    // BUG: Need to set Object->VariableArrayOffset, etc.

                    NtStatus = STATUS_SUCCESS;
                }
                else
                {
                    NtStatus = STATUS_INVALID_PARAMETER;
                }
            }
            else
            {
                NtStatus = STATUS_NO_MEMORY;
            }
        }
        else
        {
            NtStatus = STATUS_INVALID_PARAMETER;
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return(NtStatus);
}



//
// COMBINED BUFFER-TO-ATTRBLOCK CONVERSION ROUTINES
//

NTSTATUS
SampLocateAttributesInSamBuffer(
    IN INT ObjectType,
    IN PVOID SamAttributes,
    IN ULONG FixedLength,
    IN ULONG VariableLength,
    OUT PVOID *FixedLengthAttributes,
    OUT PSAMP_VARIABLE_LENGTH_ATTRIBUTE *VarLengthAttributes
    )

/*++

Routine Description:

    This routine finds the start of the fixed-length and variable-length
    attributes, returning a pointer to each.

Arguments:

    ObjectType - Identifies which SAM object type, and hence, which attribute
        set to work with.

    SamAttributes - Pointer, SAM attribute buffer.

    FixedLength - Number of bytes of fixed-length attributes.

    VariableLength - Number of bytes of variable-length attributes.

    FixedLengthAttributes - Pointer, returned pointer to the fixed data.

    VarLengthAttributes - Pointer, returned pointer to the variable data.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;

    SAMTRACE("SampLocateAttributesInSamBuffer");

    // BUG: ObjectType and VariableLength are not used in this routine.
    // These parameters could be used in the future for validation checks.

    if ((NULL != SamAttributes) && (NULL != FixedLengthAttributes))
    {
        // The fixed-length attributes are in the first part of the overall
        // buffer.

        *FixedLengthAttributes = SamAttributes;

        if (NULL != VarLengthAttributes)
        {
            // The variable-length attributes come after the fixed ones.

            *VarLengthAttributes =
                (PSAMP_VARIABLE_LENGTH_ATTRIBUTE)(((PBYTE)SamAttributes) +
                FixedLength);

            NtStatus = STATUS_SUCCESS;
        }
    }

    return(NtStatus);
}



NTSTATUS
SampCreateDsAttributes(
    IN INT ObjectType,
    IN PDSATTRBLOCK DsFixedLengthAttributes,
    IN ULONG FixedLengthAttributeCount,
    IN PDSATTRBLOCK DsVarLengthAttributes,
    IN ULONG VarLengthAttributeCount,
    OUT PDSATTRBLOCK *DsAttributes
    )

/*++

Routine Description:

    This routine does the work of combining two DSATTRBLOCKs into a single
    DSATTRBLOCK by "concatenating" them together. The routine allocates a
    new top-level DSATTR array, and then fixes up the pointers to the real
    attributes, finally releasing the old DSATTR array.

Arguments:

    AttributeCount - Total number of attributes, fixed and variable.

    DsFixedLengthAttributes - Pointer, the DSATTRBLOCK containing the fixed-
        length attributes.

    DsVarLengthAttributes - Pointer, the DSATTRBLOCK containing the variable-
        length attributes.

    DsAttributes - Pointer, the outgoing DSATTRBLOCK containing both sets of
        attributes.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    PDSATTR Attributes = NULL;
    PDSATTR FixedAttributes = NULL;
    PDSATTR VarAttributes = NULL;
    ULONG AttrIndex = 0;
    ULONG AttrIndexTmp = 0;
    ULONG AttributeCount = FixedLengthAttributeCount + VarLengthAttributeCount;

    ASSERT(DsAttributes);
    ASSERT(DsFixedLengthAttributes);
    ASSERT(DsVarLengthAttributes);


    // Allocate a new top-level DSATTRBLOCK for DsAttributes.

    *DsAttributes = RtlAllocateHeap(RtlProcessHeap(),
                                    0,
                                    sizeof(DSATTRBLOCK));

    if (NULL != *DsAttributes)
    {
        RtlZeroMemory(*DsAttributes, sizeof(DSATTRBLOCK));

        // Allocate the DSATTR array for the attributes.

        Attributes = RtlAllocateHeap(RtlProcessHeap(),
                                     0,
                                     (AttributeCount * sizeof(DSATTR)));

        if (NULL != Attributes)
        {
            RtlZeroMemory(Attributes, (AttributeCount * sizeof(DSATTR)));

            // Set the return DsAttributes members.

            (*DsAttributes)->attrCount = AttributeCount;
            (*DsAttributes)->pAttr = Attributes;

            if ((NULL != DsFixedLengthAttributes) &&
                (NULL != DsVarLengthAttributes))
            {
                FixedAttributes = DsFixedLengthAttributes->pAttr;
                VarAttributes = DsVarLengthAttributes->pAttr;

                if ((NULL != FixedAttributes) &&
                    (NULL != VarAttributes))
                {
                    // Reset the attribute pointers so that DsAttributes
                    // points to the fixed-length attributes and counts.

                    for (AttrIndex = 0;
                         AttrIndex < FixedLengthAttributeCount;
                         AttrIndex++)
                    {
                        Attributes[AttrIndex].attrTyp =
                            SampFixedAttributeInfo[ObjectType][AttrIndex].Type;

                        Attributes[AttrIndex].AttrVal.valCount =
                            FixedAttributes[AttrIndex].AttrVal.valCount;

                        Attributes[AttrIndex].AttrVal.pAVal =
                            FixedAttributes[AttrIndex].AttrVal.pAVal;
                    }

                    // Save the current attribute index so that the
                    // variable-length attributes can be appended next.

                    AttrIndexTmp = AttrIndex;

                    // Now fix up the variable-length attribute pointers.

                    for (AttrIndex = 0;
                         AttrIndex < VarLengthAttributeCount;
                         AttrIndex++)
                    {
                        Attributes[AttrIndex + AttrIndexTmp].attrTyp =
                            VarAttributes[AttrIndex].attrTyp;

                        Attributes[AttrIndex + AttrIndexTmp].AttrVal.valCount =
                            VarAttributes[AttrIndex].AttrVal.valCount;

                        Attributes[AttrIndex + AttrIndexTmp].AttrVal.pAVal =
                            VarAttributes[AttrIndex].AttrVal.pAVal;
                    }

                    ASSERT( (AttrIndex+AttrIndexTmp) == AttributeCount );

                    NtStatus = STATUS_SUCCESS;
                }
            }
        }
        else
        {
            NtStatus = STATUS_NO_MEMORY;
        }
    }
    else
    {
        NtStatus = STATUS_NO_MEMORY;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        if (*DsAttributes)
        {
            if ((*DsAttributes)->pAttr)
            {
                RtlFreeHeap(RtlProcessHeap(), 0, (*DsAttributes)->pAttr);
            }
            RtlFreeHeap(RtlProcessHeap(), 0, *DsAttributes);
            *DsAttributes = NULL;
        }
    }

    return(NtStatus);
}



NTSTATUS
SampCombineDsAttributes(
    IN INT ObjectType,
    IN PDSATTRBLOCK DsFixedLengthAttributes,
    IN PDSATTRBLOCK DsVarLengthAttributes,
    OUT PDSATTRBLOCK *DsAttributes
    )

/*++

Routine Description:

    This routine does the work of combining two DSATTRBLOCKs into a single
    DSATTRBLOCK by "concatenating" them together. The routine allocates a
    new top-level DSATTR array, and then fixes up the pointers to the real
    attributes, finally releasing the old DSATTR array.

Arguments:

    ObjectType - Identifies which SAM object type, and hence, which attribute
        set to work with.

    DsFixedLengthAttributes - Pointer, the DSATTRBLOCK containing the fixed-
        length attributes.

    DsVarLengthAttributes - Pointer, the DSATTRBLOCK containing the variable-
        length attributes.

    DsAttributes - Pointer, the outgoing DSATTRBLOCK containing both sets of
        attributes.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    ULONG FixedLengthAttributeCount = 0;
    ULONG VarLengthAttributeCount = 0;
    ULONG AttributeCount = 0;

    SAMTRACE("SampCombineDsAttributes");

    // Set the combined attribute count 

    AttributeCount = DsFixedLengthAttributes->attrCount + DsVarLengthAttributes->attrCount;

    ASSERT(0 < AttributeCount);

    if (0 < AttributeCount)
    {
        NtStatus = SampCreateDsAttributes(ObjectType,
                                          DsFixedLengthAttributes,
                                          DsFixedLengthAttributes->attrCount,
                                          DsVarLengthAttributes,
                                          DsVarLengthAttributes->attrCount,
                                          DsAttributes);
    }

    return(NtStatus);
}



NTSTATUS
SampConvertCombinedAttributesToAttrBlock(
    IN PSAMP_OBJECT Context,
    IN ULONG FixedLength,
    IN ULONG VariableLength,
    OUT PDSATTRBLOCK *DsAttributes
    )

/*++

Routine Description:

    This routine converts a SAM combined-attribute buffer into a DSATTRBLOCK
    containing all of the attributes. A SAM combined buffer contains fixed-
    length attributes, followed by variable-length attributes (see attr.c for
    the layout).

    The resultant DSATTRBLOCK contains the SAM attributes in exactly the
    order in which they appeared in the input SAM buffer.

Arguments:

    ObjectType - Identifies which SAM object type, and hence, which attribute
        set to work with.

    SamAttributes - Pointer, input SAM combined attribute buffer.

    FixedLength - Number of bytes of the buffer containing the fixed-length
        attributes.

    VariableLength - Number of bytes of the buffer containing the variable-
        length attributes.

    DsAttributes - Pointer, the returned DSATTRBLOCK containing the SAM attri-
        butes.

Return Value:

    STATUS_SUCCESS - The object has been successfully accessed.

--*/

{
    NTSTATUS NtStatus = STATUS_INTERNAL_ERROR;
    PVOID SamFixedLengthAttributes = NULL;
    PSAMP_VARIABLE_LENGTH_ATTRIBUTE SamVarLengthAttributes = NULL;
    PDSATTRBLOCK DsFixedLengthAttributes = NULL;
    PDSATTRBLOCK DsVarLengthAttributes = NULL;
    SAMP_OBJECT_TYPE    ObjectType = Context->ObjectType;
    PVOID               SamAttributes = Context->OnDisk;

    SAMTRACE("SampConvertCombinedAttributesToAttrBlock");

    ASSERT(SamAttributes);
    ASSERT(DsAttributes);
    ASSERT(FixedLength);
    ASSERT(VariableLength);

    if ((NULL != SamAttributes) && (0 < FixedLength) && (0 < VariableLength))
    {
        // Begin by obtaining a two pointers: a pointer to the fixed-length
        // attributes and a pointer to the variable-length attributes within
        // the SAM buffer.

        NtStatus = SampLocateAttributesInSamBuffer(ObjectType,
                                                   SamAttributes,
                                                   FixedLength,
                                                   VariableLength,
                                                   &SamFixedLengthAttributes,
                                                   &SamVarLengthAttributes);


        if (NT_SUCCESS(NtStatus) &&
            (NULL != SamFixedLengthAttributes) &&
            (NULL != SamVarLengthAttributes))
        {
            // First, convert the fixed-length attributes into a DSATTRBLOCK.

            NtStatus = SampConvertFixedLengthAttributesToAttrBlock(
                            ObjectType,
                            SamFixedLengthAttributes,
                            &DsFixedLengthAttributes);

            AssertAddressWhenSuccess(NtStatus, DsFixedLengthAttributes); 

            if (NT_SUCCESS(NtStatus) && (NULL != DsFixedLengthAttributes))
            {
                // Then convert the variable-length attributes.

                NtStatus = SampConvertVarLengthAttributesToAttrBlock(
                                Context,
                                SamVarLengthAttributes,
                                &DsVarLengthAttributes);

                AssertAddressWhenSuccess(NtStatus, DsVarLengthAttributes);

                if (NT_SUCCESS(NtStatus) && (NULL != DsVarLengthAttributes))
                {
                    if (NULL != DsAttributes)
                    {
                        // Finally, combine the two DSATTRBLOCKs into a single
                        // DSATTRBLOCK, containing all of the attributes.

                        NtStatus = SampCombineDsAttributes(
                                        ObjectType,
                                        DsFixedLengthAttributes,
                                        DsVarLengthAttributes,
                                        DsAttributes);

                        AssertAddressWhenSuccess(NtStatus, DsAttributes);
                    }
                    else
                    {
                        NtStatus = STATUS_INVALID_PARAMETER;
                    }
                }
                else
                {
                    NtStatus = STATUS_INTERNAL_ERROR;
                }
            }
            else
            {
                NtStatus = STATUS_INTERNAL_ERROR;
            }
        }
        else
        {
            NtStatus = STATUS_INTERNAL_ERROR;
        }
    }
    else
    {
        NtStatus = STATUS_INVALID_PARAMETER;
    }

    if (!NT_SUCCESS(NtStatus))
    {
        if (NULL != DsFixedLengthAttributes)
        {
            SampFreeAttributeBlock(DsFixedLengthAttributes);
        }
        if (NULL != DsVarLengthAttributes)
        {
            SampFreeAttributeBlock(DsVarLengthAttributes);
        }
    }
    else
    {
        if (NULL != DsFixedLengthAttributes)
        {
            if (NULL != DsFixedLengthAttributes->pAttr)
            {
                RtlFreeHeap(RtlProcessHeap(), 0, DsFixedLengthAttributes->pAttr);
            }
            RtlFreeHeap(RtlProcessHeap(), 0, DsFixedLengthAttributes);
        }

        if (NULL != DsVarLengthAttributes)
        {
            if (NULL != DsVarLengthAttributes->pAttr)
            {
                RtlFreeHeap(RtlProcessHeap(), 0, DsVarLengthAttributes->pAttr);
            }
            RtlFreeHeap(RtlProcessHeap(), 0, DsVarLengthAttributes);
        }
    }

    return(NtStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\enckey.c ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1997-1997
//
// File:        enckey.c
//
// Contents:    Password based key encryption/decryption library.
//
// History:     17-Apr-97      terences created
//
//---------------------------------------------------------------------------


#include <windows.h>
#include <rc4.h>
#include <md5.h>
#include <rng.h>
#include <enckey.h>

// --------------------------------------------
// EncryptKey
//
//  Caller passes in hash of unicode password, struct to get the enc key,
//  and struct to get the clear key.
//  The hash of the password is passed in a KEClearKey struct so that this
//  can be changed in the future.
//
//  EncryptKey generates a random salt, random key, builds the encryption
//  structure, and returns the clear key.
//
//  WARNING:  Eat the clear key as soon after use as possible!
//            Also, not threadsafe.
//
//      return code:
//          always returns success

DWORD
KEEncryptKey(
    IN KEClearKey       *pPassword,
    OUT KEEncKey        *pEncBlock,
    OUT KEClearKey      *pSAMKey,
    IN DWORD            dwFlags)
{
    MD5_CTX         LocalHash;
    struct RC4_KEYSTRUCT    LocalRC4Key;

    if ((pPassword == NULL) || (pEncBlock == NULL) || (pSAMKey == NULL))
        return 0;

    if (pPassword->dwVersion != KE_CUR_VERSION)
        return 0;

    // Fill in the structs with versions and sizes.

    pEncBlock->dwVersion = KE_CUR_VERSION;
    pEncBlock->dwLength = sizeof(KEEncKey);

    pSAMKey->dwVersion = KE_CUR_VERSION;
    pSAMKey->dwLength = sizeof(KEClearKey);

    // Gen the keying material

    STInitializeRNG();

    STGenerateRandomBits(pEncBlock->Salt, KE_KEY_SIZE);
    STGenerateRandomBits(pEncBlock->EncKey, KE_KEY_SIZE);

    // Copy out the clear key

    memcpy(pSAMKey->ClearKey, pEncBlock->EncKey, KE_KEY_SIZE);

    // Generate the confirmer.

    MD5Init(&LocalHash);
    MD5Update(&LocalHash, pEncBlock->EncKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_1, sizeof(MAGIC_CONST_1));
    MD5Update(&LocalHash, pEncBlock->EncKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_2, sizeof(MAGIC_CONST_2));
    MD5Final(&LocalHash);

    memcpy(pEncBlock->Confirm, &(LocalHash.digest), KE_KEY_SIZE);
    memset(&(LocalHash), 0, sizeof(LocalHash));

    // Encrypt the key and the confirmer

    MD5Init(&LocalHash);
    MD5Update(&LocalHash, pEncBlock->Salt, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_2, sizeof(MAGIC_CONST_2));
    MD5Update(&LocalHash, pPassword->ClearKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_1, sizeof(MAGIC_CONST_1));
    MD5Final(&LocalHash);
    rc4_key(&LocalRC4Key, KE_KEY_SIZE, (BYTE *)&(LocalHash.digest));
    rc4(&LocalRC4Key, KE_KEY_SIZE * 2, (BYTE *)&(pEncBlock->EncKey));

    memset(&(LocalRC4Key), 0, sizeof(LocalRC4Key));
    memset(&(LocalHash), 0, sizeof(LocalHash));

    // return success!

    return KE_OK;
}

//---------------------------------------------
// DecryptKey
//
//  Caller passes in hash of unicode password, enc key struct, struct to
//  get the clear key
//
//  DecryptKey will return the clear key if the password matches.  Note that
//  this function is ALWAYS destructive to the passed encryption block.  In
//  the case of a decrypt, it will be zeroed out.
//
//  return codes:
//      KE_BAD_PASSWORD     Password will not decrypt key
//      KE_OK               Password decrypted key

DWORD KEDecryptKey(
    IN KEClearKey   *pPassword,
    IN KEEncKey     *pEncBlock,
    OUT KEClearKey  *pSAMKey,
    IN DWORD        dwFlags)
{
    MD5_CTX         LocalHash;
    struct RC4_KEYSTRUCT   LocalRC4Key;

    if ((pPassword == NULL) || (pEncBlock == NULL) || (pSAMKey == NULL))
        return KE_FAIL;

    if ((pEncBlock->dwVersion != KE_CUR_VERSION) ||
        (pPassword->dwVersion != KE_CUR_VERSION))
        return KE_FAIL;

    pSAMKey->dwVersion = KE_CUR_VERSION;
    pSAMKey->dwLength = sizeof(KEClearKey);

    // Decrypt the key and the confirmer
    MD5Init(&LocalHash);
    MD5Update(&LocalHash, pEncBlock->Salt, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_2, sizeof(MAGIC_CONST_2));
    MD5Update(&LocalHash, pPassword->ClearKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_1, sizeof(MAGIC_CONST_1));
    MD5Final(&LocalHash);
    rc4_key(&LocalRC4Key, KE_KEY_SIZE, (BYTE *) &(LocalHash.digest));
    rc4(&LocalRC4Key, KE_KEY_SIZE * 2, (BYTE *)&(pEncBlock->EncKey));

    // Clean up immediately

    memset(&(LocalHash), 0, sizeof(LocalHash));
    memset(&(LocalRC4Key), 0, sizeof(LocalRC4Key));

    // Generate the confirmer.

    MD5Init(&LocalHash);
    MD5Update(&LocalHash, pEncBlock->EncKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_1, sizeof(MAGIC_CONST_1));
    MD5Update(&LocalHash, pEncBlock->EncKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_2, sizeof(MAGIC_CONST_2));
    MD5Final(&LocalHash);

    // Check that the confirmer matches

    if (memcmp(&(LocalHash.digest), &(pEncBlock->Confirm), KE_KEY_SIZE))
    {
        // Failed.  Zero and leave.
        // No need to zero the block, since rc4 trashed it.

        memset(&(LocalHash), 0, sizeof(LocalHash));
        return KE_BAD_PASSWORD;
    }

    // Confirmer matched.

    memset(&(LocalHash), 0, sizeof(LocalHash));
    memcpy(pSAMKey->ClearKey, pEncBlock->EncKey, KE_KEY_SIZE);
    memset(pEncBlock, 0, sizeof(KEEncKey));

    return KE_OK;
}


//---------------------------------------------
// ChangeKey
//
//  Caller passes in hash of old unicode password, hash of new password,
//  enc key struct, enc key struct is reencrypted with the new password.
//
//  return codes:
//      KE_BAD_PASSWORD     Password will not decrypt key
//      KE_OK               Password decrypted key

DWORD KEChangeKey(
    IN KEClearKey       *pOldPassword,
    IN KEClearKey       *pNewPassword,
    IN OUT KEEncKey     *pEncBlock,
    IN DWORD            dwFlags)
{
    MD5_CTX         LocalHash;
    struct RC4_KEYSTRUCT   LocalRC4Key;

    if ((pOldPassword == NULL) || (pEncBlock == NULL)||(pNewPassword == NULL))
        return KE_FAIL;

    if ((pEncBlock->dwVersion != KE_CUR_VERSION) ||
        (pOldPassword->dwVersion != KE_CUR_VERSION) ||
                (pNewPassword->dwVersion != KE_CUR_VERSION))
        return KE_FAIL;

    // Decrypt the key and the confirmer

    MD5Init(&LocalHash);
    MD5Update(&LocalHash, pEncBlock->Salt, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_2, sizeof(MAGIC_CONST_2));
    MD5Update(&LocalHash, pOldPassword->ClearKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_1, sizeof(MAGIC_CONST_1));
    MD5Final(&LocalHash);
    rc4_key(&LocalRC4Key, KE_KEY_SIZE, (BYTE *)&(LocalHash.digest));
    rc4(&LocalRC4Key, KE_KEY_SIZE * 2, (BYTE *)&(pEncBlock->EncKey));

    // Clean up immediately

    memset(&(LocalHash), 0, sizeof(LocalHash));
    memset(&(LocalRC4Key), 0, sizeof(LocalRC4Key));

    // Generate the confirmer.

    MD5Init(&LocalHash);
    MD5Update(&LocalHash, pEncBlock->EncKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_1, sizeof(MAGIC_CONST_1));
    MD5Update(&LocalHash, pEncBlock->EncKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_2, sizeof(MAGIC_CONST_2));
    MD5Final(&LocalHash);

    // Check that the confirmer matches

    if (memcmp(&(LocalHash.digest), &(pEncBlock->Confirm), KE_KEY_SIZE))
    {
        // Failed.  Zero and leave.
        // No need to zero the block, since rc4 trashed it.

        memset(&(LocalHash), 0, sizeof(LocalHash));
        return KE_BAD_PASSWORD;
    }

    // Confirmer matched.

    memset(&(LocalHash), 0, sizeof(LocalHash));

    // Reencrypt with the new password.

    MD5Init(&LocalHash);
    MD5Update(&LocalHash, pEncBlock->Salt, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_2, sizeof(MAGIC_CONST_2));
    MD5Update(&LocalHash, pNewPassword->ClearKey, KE_KEY_SIZE);
    MD5Update(&LocalHash, MAGIC_CONST_1, sizeof(MAGIC_CONST_1));
    MD5Final(&LocalHash);
    rc4_key(&LocalRC4Key, KE_KEY_SIZE, (BYTE *)&(LocalHash.digest));
    rc4(&LocalRC4Key, KE_KEY_SIZE * 2, (BYTE *)&(pEncBlock->EncKey));

    // Clean up immediately

    memset(&(LocalHash), 0, sizeof(LocalHash));
    memset(&(LocalRC4Key), 0, sizeof(LocalRC4Key));

    return KE_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\enckey.h ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1997-1997
//
// File:        enckey.h
//
// Contents:    Password based key encryption/decryption library.
//
// History:     17-Apr-97      terences created
//
//---------------------------------------------------------------------------



// consts

#define KE_KEY_SIZE     16
#define KE_CUR_VERSION  1

#define MAGIC_CONST_1   "0123456789012345678901234567890123456789"
#define MAGIC_CONST_2   "!@#$%^&*()qwertyUIOPAzxcvbnmQQQQQQQQQQQQ)(*@&%"

// error codes

#define KE_OK           0
#define KE_FAIL         1
#define KE_BAD_PASSWORD 2

typedef struct _EncKey {
    DWORD   dwVersion;      // 00000001 = 128 bit RC4
    DWORD   dwLength;       // = sizeof(KEEncKey)
    BYTE    Salt[16];       // 16 bytes of random salt
    BYTE    EncKey[KE_KEY_SIZE];     // Key encrypted with PW + Salt
    BYTE    Confirm[16];    // MD5(Key) encrypted with PW+Salt
} KEEncKey;

typedef struct _ClearKey {
    DWORD   dwVersion;          // 00000001 = 128 bit plain key
    DWORD   dwLength;           // = sizeof(KEClearKey)
    BYTE    ClearKey[KE_KEY_SIZE];   // 128 bits of key data
} KEClearKey;

// --------------------------------------------
// EncryptKey
//
//  Caller passes in hash of unicode password, struct to get the enc key,
//  and struct to get the clear key.
//  The hash of the password is passed in a KEClearKey struct so that this
//  can be changed in the future.
//
//  EncryptKey generates a random salt, random key, builds the encryption
//  structure, and returns the clear key.
//
//  WARNING:  Eat the clear key as soon after use as possible!
//
//      return code:
//          always returns success

DWORD
KEEncryptKey(
    IN KEClearKey       *pszPassword,
    OUT KEEncKey        *pEncBlock,
    OUT KEClearKey      *pSAMKey,
    IN DWORD            dwFlags);

//---------------------------------------------
// DecryptKey
//
//  Caller passes in hash of unicode password, enc key struct, struct to
//  get the clear key
//
//  DecryptKey will return the clear key if the password matches.
//
//  return codes:
//      KE_BAD_PASSWORD     Password will not decrypt key
//      KE_OK               Password decrypted key

DWORD KEDecryptKey(
    IN KEClearKey       *pszPassword,
    IN KEEncKey     *pEncBlock,
    OUT KEClearKey      *pSAMKey,
    IN DWORD            dwFlags);

//---------------------------------------------
// ChangeKey
//
//  Caller passes in hash of old unicode password, hash of new password,
//  enc key struct, enc key struct is reencrypted with the new password.
//
//  return codes:
//      KE_BAD_PASSWORD     Password will not decrypt key
//      KE_OK               Password decrypted key

DWORD KEChangeKey(
    IN KEClearKey       *pOldPassword,
    IN KEClearKey       *pNewPassword,
    IN OUT KEEncKey     *pEncBlock,
    IN DWORD            dwFlags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\extsid.c ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:

    extsid.c

Abstract:

    This file contains routines to support an Extended Sid.

Author:

    Colin Brace    (ColinBr)  27-March-2000

Environment:

    User Mode - Nt


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////
#include <stdlib.h>
#include <samsrvp.h>
#include <samrpc.h>
#include <samisrv.h>


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Theory of Operation                                                       //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// The server side behavoir of the large SID emluation behavoir is governed
// by the contents of the global SampExtendedSidOptions.
//
// Current bit field values are
//
// SAM_EXTENDED_SID_DOMAIN
// SAM_EXTENDED_SID_DOMAIN_COMPAT_1
// SAM_EXTENDED_SID_DOMAIN_COMPAT_2
//
// SAM_EXTENDED_SID_DOMAIN is set whenever the account domain hosts domain
// that is in extended sid mode.  When set, the client will call SamrRidToSid
// to obtain the SID of an account given just the RID.
//
// SAM_EXTENDED_SID_DOMAIN_COMPAT_1 implies the following behavoir:
//
// 1. the NET API client should return a 0 for the RID in user and group 
//    information levels that return a rid
//
// 2. that SAM clients older than SAM_NETWORK_REVISION_3 will not be allowed
//    to connect if the account domain is in extended sid mode
//
// 3. that SAM clients will not be able to write to the primary group id
//    attribute
//
// SAM_EXTENDED_SID_DOMAIN_COMPAT_2 implies the following behavoir:
//
// 1. the NET API client should return ERROR_NOT_SUPPORTED for information
//    levels that return a rid
//
// 2. that SAM clients older than SAM_NETWORK_REVISION_3 will not be allowed
//    to connect if the account domain is in extended sid mode
//
// 3. that SAM clients will not be able to write to the primary group id
//    attribute
//
//
//
// Until large SID support is supported, applications can put a server in 
// "Emulation Mode" via a registry key. This causes the SAM server to behavoir
// as if the account domain is in ExtendedSid mode but the account doesn't
// really allocate SID's in a large sid fashion.  This emulation is controlled
// by the registry key ExtendedSidEmulationMode: a value of 1 indicates
// compatibility mode 1; a value of 2 indicates  compatibility mode 2; any other
// value is ignored.
//
//
// For more details, see the Extending the Rid spec.
//
//

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private declarations                                                      //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

DWORD SampExtendedSidOptions;

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Public Routines                                                           //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

NTSTATUS
SamrRidToSid(
    IN  SAMPR_HANDLE  ObjectHandle,
    IN  ULONG         Rid,
    OUT PRPC_SID     *Sid
    )
/*++

Description:

    This routine translates the "temporary" Rid of an account to its actual
    Sid.

Parameters:

    ObjectHandle -- the SAM handle from which the RID was obtained
    
    Rid          -- the "temporary" ID of the account
    
    Sid          -- on success, the SID of the account

Return Values:

    STATUS_SUCCESS - The service completed successfully.
    
    STATUS_NOT_FOUND -- no such RID could be located
    
    other NT resource errors

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    NTSTATUS IgnoreStatus;

    PSAMP_OBJECT            Context = (PSAMP_OBJECT) ObjectHandle;
    PSAMP_DEFINED_DOMAINS   Domain = NULL;
    SAMP_OBJECT_TYPE        ObjectType;

    BOOLEAN fLock = FALSE;
    BOOLEAN fContext = FALSE;

    if (NULL == Sid) {
        return STATUS_INVALID_PARAMETER;
    }

   
    //
    // RPC gaurentees a non-NULL context
    //              
    ASSERT( Context );

    //
    // Acquire the read lock
    //

    SampMaybeAcquireReadLock(Context,
                             DOMAIN_OBJECT_DONT_ACQUIRELOCK_EVEN_IF_SHARED,
                             &fLock);

    NtStatus = SampLookupContext(
                   Context,
                   0,                     // No special access necessary
                   SampUnknownObjectType, // ExpectedType
                   &ObjectType
                   );

    if ( !NT_SUCCESS(NtStatus) ) {
        goto Cleanup;
    }
    fContext = TRUE;

    switch (ObjectType) 
    {
    case SampDomainObjectType:
    case SampGroupObjectType:
    case SampAliasObjectType:
    case SampUserObjectType:
        // These are valid object types for this call
        break;
    default: 
        NtStatus = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Note: no security check is necessary -- the security check required
    // to obtain a handle is sufficient
    //

    //
    // Now that we have a good SAM handle, find the related Domain sid
    //
    Domain = &SampDefinedDomains[ Context->DomainIndex ];
    ASSERT(RtlValidSid(Domain->Sid));

    NtStatus = SampCreateFullSid(Domain->Sid,
                                 Rid,
                                 (PSID)Sid);

Cleanup:

    if ( fContext ) {
        IgnoreStatus = SampDeReferenceContext2( Context, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    SampMaybeReleaseReadLock(fLock);

    return NtStatus;
}

VOID
SampInitEmulationSettings(
    IN HKEY LsaKey 
    )
/*++

Description:

    This routine reads some configuration information from the registry to
    determine if SAM should behave in extended SID emulation.
    
Parameters:

    LsaKey -- an open key to Control\LSA
    
Return Values:

    None.
    
--*/
{
    DWORD WinError = ERROR_SUCCESS;
    DWORD dwSize, dwValue, dwType;
    DWORD TempValue = 0;

    dwSize = sizeof(dwValue);
    WinError = RegQueryValueExA(LsaKey,
                                "ExtendedSidEmulationMode",
                                NULL,
                                &dwType,
                                (LPBYTE)&dwValue,
                                &dwSize);
    if ((ERROR_SUCCESS == WinError) && 
        (REG_DWORD == dwType)) {

        TempValue |= SAM_EXTENDED_SID_DOMAIN;
        if ( dwValue == 1 ) {
            TempValue |= SAM_EXTENDED_SID_DOMAIN_COMPAT_1;
        } else if ( dwValue == 2 ) {
            TempValue |= SAM_EXTENDED_SID_DOMAIN_COMPAT_2;
        } else {
            // Wierd value
            TempValue = 0;
        }
    }

    //
    // Set the global value
    //
    SampExtendedSidOptions = TempValue;

    return;
}

BOOLEAN
SampIsExtendedSidModeEmulated(
    IN ULONG *Mode OPTIONAL
    )
/*++

Description:

    This routine reads some configuration information from the registry to
    determine if SAM should behave in extended SID emulation.
    
Parameters:

    Mode -- set to the specific emulation mode 
    
Return Values:

    TRUE if in emulation mode; FALSE otherwise
    
--*/
{
    if ( Mode ) {
        *Mode = SampExtendedSidOptions;
    }

    return !!(SampExtendedSidOptions & SAM_EXTENDED_SID_DOMAIN);
}


BOOLEAN
SamIIsExtendedSidMode(
    SAMPR_HANDLE ObjectHandle
    )
/*++

Description:

    This routine is exported outside the DLL for other security DLL's to 
    know what emulation mode we are in.           
    
Parameters:

    ObjectHandle -- a non-server SAM handle                           
    
Return Values:

    TRUE if object is from an extended SID domain
    
    FALSE otherwise
    
--*/
{
    PSAMP_OBJECT Context = (PSAMP_OBJECT)ObjectHandle;
    ASSERT( NULL != Context );
    ASSERT( Context->ObjectType != SampServerObjectType );

    return SampIsContextFromExtendedSidDomain(Context);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\gentab2.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    gentab2.c

Abstract:

    GenericTable2 package

    Generic table services for maintaining data sets.  The primary
    characteristic of this generic table package is that it maintains
    a relatively balanced tree, which provides for good (O(log(N))
    performance.
                                                                      
    The GenericTable2 routines are similar to the original 
    GenericTable routines provided by Gary Kimure except that the 
    GenericTable2 routines use a 2-3-tree rather than a splay tree.
    2-3-trees are described in "Data Structures And Algorithms", by 
    Aho, Hopcroft, and Ullman, published by Addison Wesley Publishing 
    Company.

    Another difference between this package and the original Generic 
    Table package is that this one references element buffers that are 
    inserted rather than copying the data (as in the orignal package).  
    This characteristic is nice if you have to sort large numbers of 
    records by multiple keys 
                                                                        
    2-3-trees have better characteristics than splay-trees when the     
    data being maintained is not random.  For example, maintaining a    
    dictionary, in which the data quite often is provided in an orderly 
    manner, is an ideal application for 2-3-trees.                       
                                                                        
    This package does not support the retrieval of elements in inserted 
    order that is supported in the original Generic Table package.      
                                                                        
    Differences between the algorithm outlined in Aho, et al and what   
    is coded here are:                                                  

        1) I provide an additional means of obtaining the elements
           in the tree in sorted order (for enumeration performance).
           I keep a linked list of elements in addition to the tree
           structure.

        1) Aho et al point directly to elements in the tree from
           nodes in the tree.  In order to allow me to keep the linked
           list mentioned in (1), I have a separate leaf element pointed
           to from nodes which point to the element values.  This leaf
           component has the LIST_ENTRY structures used to link the
           elements together.

        3) Aho et al's algorithms ignore the fact that they may fail
           to allocate memory (that is, they assume the Pascal "new"
           function always succeeds).  This package assumes that
           any memory allocation may fail and will always leave the
           tree in a valid form (although an insertion may fail in
           this case).


Author:

    Jim Kelly (JimK)  20-Jan-1994

Environment:

    Run time library, user or kernel mode.

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


#include <nt.h>
#include <ntrtl.h>
#include <samsrvp.h>




//////////////////////////////////////////////////////////////////////////
//                                                                      //
//  defines ...                                                         //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

//
// The following define controls the diagnostic capabilities that     
// are built into this package.
//

#if DBG
#define GTBP_DIAGNOSTICS 1
#endif // DBG


//
// These definitions are useful diagnostics aids
//

#if GTBP_DIAGNOSTICS

//
// defining the following symbol causes significant amounts of
// development assistance code to be built
//

//#define GTBP_DEVELOPER_BUILD 1

//
// Global Diagnostics Flags
//

ULONG GtbpGlobalFlag;

//
// Test for diagnostics enabled
//

#define IF_GTBP_GLOBAL( FlagName ) \
    if (GtbpGlobalFlag & (GTBP_DIAG_##FlagName))

//
// Diagnostics print statement
//

#define GtbpDiagPrint( FlagName, _Text_ )                               \
    IF_GTBP_GLOBAL( FlagName )                                          \
        DbgPrint _Text_
    

#else

//
// No diagnostics included in build
//

//
// Test for diagnostics enabled
//

#define IF_GTBP_GLOBAL( FlagName ) if (FALSE)


//
// Diagnostics print statement (nothing)
//

#define GtbpDiagPrint( FlagName, Text )     ;


#endif // GTBP_DIAGNOSTICS

//
// The following flags enable or disable various diagnostic
// capabilities within SAM.  These flags are set in
// GtbpGlobalFlag.
//
//      INSERT - print diagnostic messages related to insertion
//          operations.
//
//      DELETION - print diagnostic messages related to deletion
//          operations.
//
//      LEAF_AND_NODE_ALLOC - print diagnostic messages related
//          to allocation of leaf and node objects for insertion
//          operations.
//
//      ENUMERATE - print diagnostic messages related to enumeration
//          operations.  This includes getting restart keys.
//
//      LOOKUP - print diagnostic messages related to element lookup
//          operations.
//
//      COLLISIONS - print diagnostic messages indicating when collisions
//          occur on insert.
//
//      VALIDATE - print diagnostic messages to be printed during table
//          validations.
//

#define GTBP_DIAG_INSERT                    ((ULONG) 0x00000001L)
#define GTBP_DIAG_DELETION                  ((ULONG) 0x00000002L)
#define GTBP_DIAG_LEAF_AND_NODE_ALLOC       ((ULONG) 0x00000004L)
#define GTBP_DIAG_ENUMERATE                 ((ULONG) 0X00000008L)
#define GTBP_DIAG_LOOKUP                    ((ULONG) 0X00000010L)
#define GTBP_DIAG_COLLISIONS                ((ULONG) 0X00000020L)
#define GTBP_DIAG_VALIDATE                  ((ULONG) 0X00000040L)


//////////////////////////////////////////////////////////////////////////
//                                                                      //
//  Macros ...                                                          //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

//
//  GtbpChildrenAreLeaves(
//      IN GTB_TWO_THREE_NODE  N
//      )
//  Returns TRUE if children of N are leaves.
//  Otherwise returns FALSE.
//

#define GtbpChildrenAreLeaves( N ) ((((N)->Control) & GTB_CHILDREN_ARE_LEAVES) != 0)


///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Private structures and definitions                                        //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

//
// GTB_TWO_THREE_NODE.Control field values
//

#define GTB_CHILDREN_ARE_LEAVES           (0x00000001)



//////////////////////////////////////////////////////////////////////////
//                                                                      //
//  Internal Routine Definitions ...                                    //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
GtbpDeleteFromSubTree (
    IN  PRTL_GENERIC_TABLE2         Table,
    IN  PGTB_TWO_THREE_NODE         Node,
    IN  PVOID                       Element,
    OUT PGTB_TWO_THREE_LEAF         *LowOfNode,
    OUT BOOLEAN                     *ElementDeleted,
    OUT BOOLEAN                     *OnlyOneChildLeft
    );

BOOLEAN
GtbpInsertIntoSubTree (
    PRTL_GENERIC_TABLE2             Table,
    IN  PGTB_TWO_THREE_NODE         Node,
    IN  BOOLEAN                     NodeIsLeaf,
    IN  PVOID                       Element,
    IN  ULONG                       SplitCount,
    IN  PVOID                       *FoundElement,
    OUT PGTB_TWO_THREE_NODE         *ExtraNode,
    OUT PGTB_TWO_THREE_LEAF         *LowLeaf,
    OUT PLIST_ENTRY                 *AllocatedNodes
    );

ULONG
GtbpNumberOfChildren(
    IN  PGTB_TWO_THREE_NODE         Node
    );

VOID
GtbpGetSubTreeOfElement(
    IN  PRTL_GENERIC_TABLE2         Table,
    IN  PGTB_TWO_THREE_NODE         Node,
    IN  PVOID                       Element,
    OUT PGTB_TWO_THREE_NODE         *SubTreeNode,
    OUT ULONG                       *SubTree
    );

VOID
GtbpCoalesceChildren(
    IN  PRTL_GENERIC_TABLE2         Table,
    IN  PGTB_TWO_THREE_NODE         Node,
    IN  ULONG                       SubTree,
    OUT BOOLEAN                     *OnlyOneChildLeft
    );

VOID
GtbpSplitNode(
    IN  PGTB_TWO_THREE_NODE         Node,
    IN  PGTB_TWO_THREE_NODE         NodePassedBack,
    IN  PGTB_TWO_THREE_LEAF         LowPassedBack,
    IN  ULONG                       SubTree,
    IN  PLIST_ENTRY                 AllocatedNodes,
    OUT PGTB_TWO_THREE_NODE         *NewNode,
    OUT PGTB_TWO_THREE_LEAF         *LowLeaf
    );

PGTB_TWO_THREE_LEAF
GtbpAllocateLeafAndNodes(
    IN  PRTL_GENERIC_TABLE2     Table,
    IN  ULONG                   SplitCount,
    OUT PLIST_ENTRY             *AllocatedNodes
    );

PGTB_TWO_THREE_NODE
GtbpGetNextAllocatedNode(
    IN PLIST_ENTRY      AllocatedNodes
    );




//////////////////////////////////////////////////////////////////////////
//                                                                      //
//  Exported Services ...                                               //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


VOID
RtlInitializeGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PRTL_GENERIC_2_COMPARE_ROUTINE  CompareRoutine,
    PRTL_GENERIC_2_ALLOCATE_ROUTINE AllocateRoutine,
    PRTL_GENERIC_2_FREE_ROUTINE     FreeRoutine
    )

/*++

Routine Description:

    Initialize the table by initializing the corresponding
    (empty) two-three tree and the extra linked-list we have
    going through the tree.

    Two-three trees are described in "Data Structures And Algorithms"
    by Alfred Aho, John Hopcroft, and Jeffrey Ullman (Addison Wesley
    publishing).

Arguments:

    Table - Pointer to the generic table to be initialized.  This gets
        typecast internally, but we export this so that we don't have to
        invent another type of generic table for users to worry about.

    CompareRoutine - User routine to be used to compare to keys in the
                     table.

    AllocateRoutine - Used by the table package to allocate memory
        when necessary.

    FreeRoutine - Used by the table package to free memory previously
        allocated using the AllocateRoutine.

Return Value:

    None.

--*/
{


    //
    // Tree is empty.
    //

    Table->Root = NULL;
    Table->ElementCount = 0;

    Table->Compare  = CompareRoutine;
    Table->Allocate = AllocateRoutine;
    Table->Free     = FreeRoutine;

    InitializeListHead(&Table->SortOrderHead);

    return;
}


PVOID
RtlInsertElementGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PVOID Element,
    PBOOLEAN NewElement
    )

/*++

Routine Description:


    This function inserts an element into the table.

    If the element is successfully inserted into the table
    then NewElement will be returned as TRUE and the function will
    return the value passed via the Element parameter.

    If the element already exists in the table, then NewElement
    is returned as FALSE and the function will return the value
    of the element already found in the table.


    The caller is responsible for ensuring that an element referenced by
    the table is not modified or deallocated while it is still in the
    table.

Arguments:

    Table - Pointer to the generic table to which the Element is to
        be inserted.

    Element - Pointer to the element to be entered into the table.

    NewElement - Receives TRUE if the element was added to the table.
        Receives FALSE if the element collided with an element already
        in the table (that is, an element with the same comparison
        value already exists in the table).


Return Value:

    Pointer to the element inserted, or the element that was already
    in the table with the same value as the one being inserted.

    If NULL is returned, then memory could not be allocated to add
    the new element.

--*/
{

    RTL_GENERIC_COMPARE_RESULTS
        CompareResult;


    PGTB_TWO_THREE_NODE
        NodePassedBack,
        NewNode,
        SubTreeNode,
        Node;

    PGTB_TWO_THREE_LEAF
        Leaf,
        LowLeaf,
        LowPassedBack;

    ULONG
        SplitCount,
        SubTree;

    PVOID
        FoundElement;

    PLIST_ENTRY
        AllocatedNodes;

    BOOLEAN
        NodeIsLeaf;


    GtbpDiagPrint( INSERT,
                 ("GTB: Inserting Element 0x%lx into table 0x%lx\n", Element, Table));

    //
    // Except for errors, one of the following will occur:
    //
    //  o There is no root ==>
    //      1) Allocate a root and leaf
    //      2) put the element in the leaf and make it the
    //      3) first child of the root
    //
    //  o There is a root with only one child ==>
    //      1) If the elements are equal, return without new entry
    //      2) If the new element is less, move child 1 to 2 and
    //         make new leaf child 1.
    //      3) Otherwise element is greater, allocate it a leaf
    //         and make it child 2.
    //
    //  o There is a root with at least two children ==>
    //      1) If there are already 3 children, then set split
    //         count = 2, otherwise set it to 1.
    //      2) Call normal insertion routine to insert into
    //         appropriate SubTree.
    //      3) If there is a split needed, then establish
    //         a newly allocated node as the root, and make it the
    //         parent of the current node.  Then use the normal
    //         split routine.
    //          





    //
    // If empty, then create a root node and add the element.
    //

    if (Table->ElementCount == 0) {

        GtbpDiagPrint( INSERT, 
                 ("GTB:   Table empty.  Creating root node.\n"));

        NewNode = (PGTB_TWO_THREE_NODE)
                  ((*Table->Allocate)( sizeof(GTB_TWO_THREE_NODE) ));
        if (NewNode == NULL) {
            GtbpDiagPrint(INSERT,
                 ("GTB:   Couldn't allocate memory for root node.\n"));
                 (*NewElement) = FALSE;
                 return( NULL );
        }
        GtbpDiagPrint( INSERT, 
                 ("GTB:   New root node is: 0x%lx\n", NewNode));


        NewNode->ParentNode  = NULL;  // Doesn't have a parent.  Special case.
        NewNode->Control     = GTB_CHILDREN_ARE_LEAVES;
        NewNode->SecondChild = NULL;
        NewNode->ThirdChild  = NULL;

        //
        // Allocate a leaf and put the element in it.
        //

        Leaf = (PGTB_TWO_THREE_LEAF)
               ((*Table->Allocate)( sizeof(GTB_TWO_THREE_LEAF) ));

        if (Leaf == NULL) {
            GtbpDiagPrint(INSERT,
                ("GTB:   Couldn't allocate memory for leaf.\n"));
            ((*Table->Free)( NewNode ));
            (*NewElement) = FALSE;
            return( NULL );
        }


        InsertHeadList( &Table->SortOrderHead, &Leaf->SortOrderEntry );
        Leaf->Element = Element;
        NewNode->FirstChild = (PGTB_TWO_THREE_NODE)Leaf;

        Table->Root = NewNode;
        Table->ElementCount++;
        ASSERT(Table->ElementCount == 1);
        (*NewElement) = TRUE;
        return(Element);
    }


    //
    // We have a root with at least one child in it.
    //

    if (Table->Root->SecondChild == NULL) {

        //
        // The root doesn't have two children.
        // If it didn't have any children it would have been
        // deallocated.  So, it must have a degenerate case of
        // only one child.
        //

        Leaf = (PGTB_TWO_THREE_LEAF)Table->Root->FirstChild;
        CompareResult = (*Table->Compare)( Element, Leaf->Element );

        if (CompareResult == GenericEqual) {
            (*NewElement) = FALSE;

            GtbpDiagPrint( COLLISIONS,
                           ("GTB: Insertion attempt resulted in collision.\n"
                            "     Element NOT being inserted.\n"
                            "     Elements in table: %d\n",
                            Table->ElementCount));
            return( Leaf->Element );
        }


        //
        // Need a new leaf
        //

        Leaf = (PGTB_TWO_THREE_LEAF)
               ((*Table->Allocate)( sizeof(GTB_TWO_THREE_LEAF) ));

        if (Leaf == NULL) {
            GtbpDiagPrint(INSERT,
                ("GTB:   Couldn't allocate memory for leaf.\n"));
            (*NewElement) = FALSE;
            return( NULL );
        }
        Leaf->Element = Element;

        //
        // it is either the first child or second
        //

        if (CompareResult == GenericLessThan) {

            //
            // Move the first child to be the second child and make
            // a new first child leaf for the new element.
            //
            
            InsertHeadList( &Table->SortOrderHead, &Leaf->SortOrderEntry );
        


            Table->Root->SecondChild = Table->Root->FirstChild;
            Table->Root->LowOfSecond = (PGTB_TWO_THREE_LEAF)
                                       Table->Root->SecondChild;  //it is the leaf

            Table->Root->FirstChild = (PGTB_TWO_THREE_NODE)Leaf;


        } else {

            //
            // new element is greater than existing element.
            // make it the second child.
            //

            InsertTailList( &Table->SortOrderHead, &Leaf->SortOrderEntry );
            
            Table->Root->SecondChild = (PGTB_TWO_THREE_NODE)Leaf;
            Table->Root->LowOfSecond = Leaf;

        }

        Table->ElementCount++;
        ASSERT(Table->ElementCount == 2);

        (*NewElement) = TRUE;                   //Set return value
        return(Element);
            
    }

    //
    // Normal insertion.
    // If we get an ExtraNode coming back, then we may have to
    // split the root.  Normally for a node with three children
    // you would need to allow for one node in a split.  However,
    // we will need a new root as well, so allow for two new nodes.
    //

    if (Table->Root->ThirdChild != NULL) {
        SplitCount = 2;
    } else {
        SplitCount = 0;
    }

    GtbpGetSubTreeOfElement( Table, Table->Root, Element, &SubTreeNode, &SubTree);
    NodeIsLeaf = GtbpChildrenAreLeaves(Table->Root);

    (*NewElement) = GtbpInsertIntoSubTree ( Table,
                                            SubTreeNode,
                                            NodeIsLeaf,
                                            Element,
                                            SplitCount,
                                            &FoundElement,
                                            &NodePassedBack,
                                            &LowPassedBack,
                                            &AllocatedNodes
                                            );

    //
    // One of several things could have happened:
    //
    //      1) We didn't have enough memory to add the new element.
    //         In this case we are done and simply return.
    //
    //      2) The element was added, and no-rearrangement to this
    //         node is needed.  In this case we are done and simply
    //         return.
    //
    //      3) The element was added and caused a node to be pushed
    //         out of the SubTree.  We have some work to do.
    //


    if ( (FoundElement == NULL)  ||         // Insufficient memory, or
         (NodePassedBack == NULL)  ) {      // no work for this node

        return(FoundElement);
    }


    Node = Table->Root;
    if (Node->ThirdChild == NULL) {

        //
        // Root doesn't yet have a third child, so use it.
        // This might require shuffling the second child to the
        // be the third child.
        //

        if (SubTree == 2) {

            //
            // NodePassedBack fell out of second SubTree and root does't 
            // have a third SubTree.  Make that node the third SubTree.
            //

            Node->ThirdChild = NodePassedBack;
            Node->LowOfThird = LowPassedBack;

        } else {

            //
            // Node fell out of first SubTree.
            // Make the second SubTree the third SubTree and
            // then make the passed back node the second SubTree.
            //

            ASSERT(SubTree == 1);

            Node->ThirdChild  = Node->SecondChild;
            Node->LowOfThird  = Node->LowOfSecond;
            Node->SecondChild = NodePassedBack;
            Node->LowOfSecond = LowPassedBack;

        }
    } else {

        //
        // Node already has three children - split it.
        // Do this by setting a new parent first.
        //

        NewNode = GtbpGetNextAllocatedNode( AllocatedNodes );
        ASSERT(NewNode != NULL);

        Table->Root = NewNode;
        NewNode->ParentNode  = NULL;
        NewNode->Control     = 0;
        NewNode->FirstChild  = Node;
        NewNode->SecondChild = NULL;
        NewNode->ThirdChild  = NULL;

        Node->ParentNode = NewNode;


        GtbpSplitNode( Node,
                       NodePassedBack,
                       LowPassedBack,
                       SubTree,
                       AllocatedNodes,
                       &NewNode,
                       &LowLeaf
                       );

        Table->Root->SecondChild = NewNode;
        Table->Root->LowOfSecond = LowLeaf;
    }

    return(FoundElement);
}


BOOLEAN
RtlDeleteElementGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PVOID Element
    )

/*++

Routine Description:

    The function DeleteElementGenericTable2 will find and delete an element
    from a generic table.  If the element is located and deleted the return
    value is TRUE, otherwise if the element is not located the return value
    is FALSE.  The user supplied input buffer is only used as a key in
    locating the element in the table.

    The value of the passed element is compared to elements in the table
    to determine whether or not the element is in the table.  Therefore,
    the Element passed in may be the address of the element in the table
    to delete, or it may be an element with the same value that is not
    in the table.

Arguments:

    Table - Pointer to the table in which to (possibly) delete the
            element referenced by the buffer.

    Element - Passed to the user comparasion routine.  Its contents are
             up to the user but one could imagine that it contains some
             sort of key value.

Return Value:

    BOOLEAN - If the table contained the Element then TRUE, otherwise FALSE.

--*/
{

    RTL_GENERIC_COMPARE_RESULTS
        CompareResult;

    PGTB_TWO_THREE_NODE
        Node,
        SubTreeNode;

    PGTB_TWO_THREE_LEAF
        Leaf,
        LowOfNode;

    BOOLEAN
        ElementDeleted,
        OnlyOneChildLeft;

    ULONG
        SubTree;

    GtbpDiagPrint( DELETION,
                   ("GTB: Request received to delete element 0x%lx\n", Element));


    //
    // There are the following special cases:
    //
    //      1) The table is empty.
    //      2) The table has only one leaf
    //
    // Otherwise, all operations work the same.
    //

    if (Table->ElementCount == 0) {
        GtbpDiagPrint( DELETION,
                       ("GTB: No elements in table to delete.\n"));
        return(FALSE);
    }

    if (GtbpChildrenAreLeaves(Table->Root)) {


        //
        // See if any of the elements match the one passed in.
        // If so, delete the element and shift larger elements
        // to take up the free'd child's spot (unless it is the
        // third child).
        //

        if (Table->Root->ThirdChild != NULL) {
            Leaf = (PGTB_TWO_THREE_LEAF)Table->Root->ThirdChild;
            CompareResult = (*Table->Compare)( Element, Leaf->Element );

            if (CompareResult == GenericEqual) {

                GtbpDiagPrint( DELETION,
                               ("GTB:     Deleting child 3 (0x%lx) from root node.\n"
                                "         Element count before deletion: %d\n",
                               Leaf, Table->ElementCount));

                RemoveEntryList( &Leaf->SortOrderEntry );
                (*Table->Free)(Leaf);
                Table->Root->ThirdChild = NULL;

                Table->ElementCount--;
                ASSERT(Table->ElementCount == 2);


                return(TRUE);
            }
        }

        //
        // Try second child
        //

        if (Table->Root->SecondChild != NULL) {
            Leaf = (PGTB_TWO_THREE_LEAF)Table->Root->SecondChild;
            CompareResult = (*Table->Compare)( Element, Leaf->Element );

            if (CompareResult == GenericEqual) {

                GtbpDiagPrint( DELETION,
                               ("GTB:     Deleting child 2 (0x%lx) from root node.\n"
                                "         Element count before deletion: %d\n",
                               Leaf, Table->ElementCount));

                RemoveEntryList( &Leaf->SortOrderEntry );
                (*Table->Free)(Leaf);
                Table->Root->SecondChild = Table->Root->ThirdChild;
                Table->Root->ThirdChild  = NULL;

                Table->Root->LowOfSecond = Table->Root->LowOfThird;

                Table->ElementCount--;
                ASSERT(Table->ElementCount <= 2);

                return(TRUE);
            }
        }

        //
        // Try first child
        //

        ASSERT(Table->Root->FirstChild != NULL);
        Leaf = (PGTB_TWO_THREE_LEAF)Table->Root->FirstChild;
        CompareResult = (*Table->Compare)( Element, Leaf->Element );

        if (CompareResult == GenericEqual) {    

            GtbpDiagPrint( DELETION,
                           ("GTB:     Deleting child 1 (0x%lx) from root node.\n"
                            "         Element count before deletion: %d\n",
                           Leaf, Table->ElementCount));

            RemoveEntryList( &Leaf->SortOrderEntry );
            (*Table->Free)(Leaf);
            Table->Root->FirstChild  = Table->Root->SecondChild;
            Table->Root->SecondChild = Table->Root->ThirdChild;
            Table->Root->LowOfSecond = Table->Root->LowOfThird;
            Table->Root->ThirdChild = NULL;


            Table->ElementCount--;
            ASSERT(Table->ElementCount <= 2);

            //
            // If that was the last element, then free the root as well.
            //

            if (Table->ElementCount == 0) {
                (*Table->Free)(Table->Root);
                Table->Root = NULL;

                GtbpDiagPrint( DELETION,
                               ("GTB: Deleted last element.  Deleting Root node.\n"));

            }

            return(TRUE);
        }

        //
        // Didn't match any of the leaves
        //

        GtbpDiagPrint( DELETION,
                       ("GTB: No matching element found on DELETE attempt.\n"));
        return(FALSE);

    }





    //
    // We have:
    //
    //  - Root with at least two children
    //  - Root's children are not leaves.
    //

    //
    // Find which sub-tree the element might be in.
    //

    Node = Table->Root;
    GtbpGetSubTreeOfElement( Table, Node, Element, &SubTreeNode, &SubTree );

    GtbpDeleteFromSubTree( Table,
                           SubTreeNode,
                           Element,
                           &LowOfNode,
                           &ElementDeleted,
                           &OnlyOneChildLeft
                           );


    //
    // If we deleted an entry from either the second or third
    // subtree, then we may need to set a new LowOfXxx value.
    // If it was the first subtree, then we simply have to return
    // the LowLeaf value we received.
    //

    if (LowOfNode != 0) {
        if (SubTree == 2) {
            Node->LowOfSecond = LowOfNode;
        } else if (SubTree == 3) {
            Node->LowOfThird = LowOfNode;
        }

    }


    //
    // If the SubTreeNode has only one child left, then some
    // adjustments are going to be necessary.  Otherwise,
    // we are done.
    //

    if (OnlyOneChildLeft) {

        GtbpDiagPrint( DELETION,
                       ("GTB:    Only one child left in 0x%lx\n", SubTreeNode));
        
        //
        // We are at the root and one of our children has only one
        // child.  Re-shuffle our kid's kids.
        //
        
        GtbpCoalesceChildren(  Table,
                               Node,
                               SubTree,
                               &OnlyOneChildLeft
                               );
        
        //
        // After coellescing our children, the root may have only one child
        // left.  Since we are the root node, we can't pass responsibility
        // for fixing this problem to our caller.
        //
        
        if (OnlyOneChildLeft) {
        
            GtbpDiagPrint( DELETION,
                           ("GTB:    Root has only one child. \n"
                           "        Replacing root with child: 0x%lx\n", Node->FirstChild));
            Table->Root = Table->Root->FirstChild;
            Table->Root->ParentNode = NULL;
        
            (*Table->Free)((PVOID)Node);
        }
    }

    return(ElementDeleted);

}


PVOID
RtlLookupElementGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PVOID Element
    )

/*++

Routine Description:


    The function LookupElementGenericTable2 will find an element in a
    generic table.  If the element is located the return value is a
    pointer to the user defined structure associated with the element,
    otherwise if the element is not located the return value is NULL.
    The user supplied input buffer is only used as a key in locating
    the element in the table.


Arguments:

    Table - Pointer to the users generic table.

    Element - Used for the comparison.

Return Value:

    PVOID - returns a pointer to the user data if found, otherwise NULL.

--*/

{
    RTL_GENERIC_COMPARE_RESULTS
        CompareResult;

    PGTB_TWO_THREE_NODE
        Node;

    PGTB_TWO_THREE_LEAF
        Leaf;

    ULONG
        SubTree;


    GtbpDiagPrint( LOOKUP,
                   ("GTB: Looking up element 0x%lx in table 0x%lx\n",
                    Element, Table));
    //
    // If the table is empty, then no possible match.
    //

    if (Table->ElementCount == 0) {
        GtbpDiagPrint( LOOKUP,
                       ("GTB: Element not found.  No elements in table.\n"));
        return(NULL);
    }

    Node = Table->Root;

    //
    // traverse the tree until we reach a node that has leaves as
    // children.
    //
    // We don't need to use recursion here because there
    // is no tree re-structuring necessary.  That is, there
    // is no need to perform any operations back up the tree
    // once we find the element, so it is much more efficient
    // not to use recursion (which uses lots of push, call,
    // pop, and ret instructions rather than short loop
    // termination tests).
    //

    while (!GtbpChildrenAreLeaves(Node)) {
        GtbpGetSubTreeOfElement( Table, Node, Element, &Node, &SubTree );
    }

    //
    // We are at the node which "might" contain the element.
    // See if any of the children match.
    //

    //
    // Try first child
    //

    Leaf = (PGTB_TWO_THREE_LEAF)Node->FirstChild;
    CompareResult = (*Table->Compare)( Element, Leaf->Element );

    if (CompareResult == GenericEqual) {
        GtbpDiagPrint( LOOKUP,
                       ("GTB: Element found: 2nd child (0x%lx) of node 0x%lx\n",
                       Leaf, Node));
        return(Leaf->Element);
    }

    //
    // Try second child
    //

    if (Node->SecondChild != NULL) {    // Must allow for Root node case
        Leaf = (PGTB_TWO_THREE_LEAF)Node->SecondChild;
        CompareResult = (*Table->Compare)( Element, Leaf->Element );

        if (CompareResult == GenericEqual) {
            GtbpDiagPrint( LOOKUP,
                           ("GTB: Element found: 2nd child (0x%lx) of node 0x%lx\n",
                           Leaf, Node));
            return(Leaf->Element);
        }
    }
    //
    // Try third child
    //

    if (Node->ThirdChild != NULL) {
        Leaf = (PGTB_TWO_THREE_LEAF)Node->ThirdChild;
        CompareResult = (*Table->Compare)( Element, Leaf->Element );

        if (CompareResult == GenericEqual) {
            GtbpDiagPrint( LOOKUP,
                           ("GTB: Element found: 3rd child (0x%lx) of node 0x%lx\n",
                           Leaf, Node));
            return(Leaf->Element);
        }
    }

    
    GtbpDiagPrint( LOOKUP,
                   ("GTB: Element NOT found in node 0x%lx\n", Node));

    return(NULL);

}


PVOID
RtlEnumerateGenericTable2 (
    PRTL_GENERIC_TABLE2 Table,
    PVOID *RestartKey
    )

/*++

Routine Description:


    The function EnumerateGenericTable2 will return to the
    caller, one-by-one, the elements of a table (in sorted order).
    The return value is a pointer to the user defined structure
    associated with the element.
    
    The input parameter RestartKey indicates where the enumeration should
    proceed from.  If there are no more new elements to return the return
    value is NULL.
    
    A RestartKey value of NULL will cause the enumeration to proceed
    from the beginning of the list.
    
    As an example of its use, to enumerate all of the elements in a table
    the user would write:
    
        RestartKey = NULL;
        for (ptr = EnumerateGenericTable2(Table, &RestartKey);
             ptr != NULL;
             ptr = EnumerateGenericTable2(Table, &RestartKey)) {
                :
        }
    
    
    If you wish to initiate an enumeration at a point other than the first
    entry, you may use RestartKeyByIndexGenericTable2() or
    RestartKeyByValueGenericTable2().  If a RestartKey
    for the I'th entry was obtained via RestartKeyByIndexGenericTable2(),
    then passing that RestartKey to this routine will cause the (I+1)th
    element to be returned.  If a RestartKey was obtained matching
    a value passed to RestartKeyByValueGenericTable2(), then passing
    that RestartKey to this routine will cause the entry with the
    next higher value to be returned.
    
                               ! WARNING !
    A RestartKey value may become invalid and cause an access violation
    if any entries have been removed from the table.  If enumeration
    is to be carried out and it is unknown whether or not the table
    contents have changed, it is best to obtain a RestartKey using
    RestartKeyByIndexGenericTable2() or
    RestartKeyByValueGenericTable2().
  

Arguments:

    Table - Pointer to the generic table to enumerate.

    RestartKey - Upon call, indicates where the enumeration is to
        begin.  Upon return, receives context that may be used to
        continue enumeration in a successive call.  NULL indicates
        enumeration should start at the beginning of the table.
        A return value of NULL indicates the last entry has been
        returned.

Return Value:

    PVOID - Pointer to the next enumerated element or NULL.
        NULL is returned if the entire table has already been
        enumerated.

--*/

{
    PLIST_ENTRY
        ListEntry;

    PGTB_TWO_THREE_LEAF
        Leaf;

    ListEntry = (PLIST_ENTRY)(*RestartKey);

    //
    // The restart key is a pointer to our leaf element.
    // Since all leaves are linked together in the SortOrderList,
    // this makes it really trivial to return the next element.
    //

    if (ListEntry == NULL) {
        ListEntry = &Table->SortOrderHead;  //Point to previous element
    }

    //
    // RestartKey pointed to the last enumerated leaf.
    // Advance to the new one.
    //

    ListEntry = ListEntry->Flink;

    //
    // See if we have reached the end of the list
    //

    if (ListEntry == &Table->SortOrderHead) {
        (*RestartKey) = NULL;
        return(NULL);
    }

    //
    // Otherwise, return the address of the element from this leaf.
    //

    Leaf = (PGTB_TWO_THREE_LEAF)((PVOID)ListEntry);

    (*RestartKey) = (PVOID)Leaf;
    return(Leaf->Element);

}



PVOID
RtlRestartKeyByIndexGenericTable2(
    PRTL_GENERIC_TABLE2 Table,
    ULONG I,
    PVOID *RestartKey
    )

/*++

Routine Description:

    
    The function RestartKeyByIndexGenericTable2 will return a RestartKey
    which may then be passed to EnumerateGenericTable2() to perform
    an enumeration of sorted elements following the I'th sorted element
    (zero based).

    This routine also returns a pointer to the I'th element.
    
    I = 0 implies restart at the second sorted element.

    I = (RtlNumberGenericTable2Elements(Table)-1) will return the last
    sorted element in the generic table.

    Values of I greater than (NumberGenericTableElements(Table)-1) 
    will return NULL and the returned RestartKey will cause an 
    enumeration to be performed from the beginning of the sorted list 
    if passed to EnumerateGenericTable2().

        WARNING - You may be tempted to use this routine, passing 
                  first 0, then 1, then 2, et cetera, to perform
                  enumerations.  DON'T.  This is a very expensive
                  operation compared to the enumeration call.

Arguments:

    Table - Pointer to the generic table.

    I - Indicates the point following which you wish to be able
        to resume enumeration.  For example, if you pass 7 for I,
        then a RestartKey will be returned that continues enumeration
        at the 8th element (skipping elements 0 through 6).

    RestartKey - Receives context that may be used to continue 
        enumeration in a successive call.  If there is no I'th
        element, then NULL is returned.

 Return Value:

    PVOID - Pointer to the I'th Element.  If there is no I'th element,
        then returns NULL.

--*/

{
    PLIST_ENTRY
        ListEntry;

    PGTB_TWO_THREE_LEAF
        Leaf;

    ULONG
        i;

    if (I >= Table->ElementCount) {
        (*RestartKey) = NULL;
        return(NULL);
    }

    //
    // Point to the first entry on the list.
    //

    ListEntry = Table->SortOrderHead.Flink;

    //
    // Move to the desired index
    //

    for (i=0; i<I; i++) {
        ListEntry = ListEntry->Flink;
    }


    //
    // Found the I'th element .
    //

    (*RestartKey) = (PVOID)ListEntry;
    Leaf = (PGTB_TWO_THREE_LEAF)((PVOID)ListEntry);
    return(Leaf->Element);

}


PVOID
RtlRestartKeyByValueGenericTable2(
    PRTL_GENERIC_TABLE2 Table,
    PVOID Element,
    PVOID *RestartKey
    )

/*++

Routine Description:

    
    The function RestartKeyByValueGenericTable2 will return a RestartKey
    which may then be passed to EnumerateGenericTable2() to perform
    an enumeration of sorted elements.  The RestartKey will have a
    value that will cause the enumeration to begin starting with
    the first element whose value is greater than the passed in element
    value.

    There does not have to be an element in the tree whose value
    exactly matches the passed in value.  A pointer to the element
    with the largest value that is less than or equal to the passed
    in value will be returned and serve as the continuation point
    for the enumeration.



Arguments:

    Table - Pointer to the generic table.

    Value - points to an element whose value indicates where you
        wish enumeration to continue.

    RestartKey - Receives context that may be used to continue 
        enumeration in a successive call.

 Return Value:

    PVOID - Pointer to the element with the largest value less than
        or equal to the element value passed in.  If there are no
        elements in the table less than or equal to the passed value,
        then a value of NULL will be returned.

--*/

{
    RTL_GENERIC_COMPARE_RESULTS
        CompareResult;

    PGTB_TWO_THREE_NODE
        Node;

    PGTB_TWO_THREE_LEAF
        Leaf;

    ULONG
        Children,
        SubTree;

    BOOLEAN
        LargestElementPath;

    //
    // This routine is real similar to LookupElement
    //

    //
    // handle the special "table is empty" case.
    //

    if (Table->ElementCount == 0) {
        (*RestartKey) = NULL;
        return(NULL);
    }


    Node = Table->Root;

    //
    // traverse the tree until we reach a node that has leaves as
    // children.
    //
    // We don't need to use recursion here because there
    // is no tree re-structuring necessary.  That is, there
    // is no need to perform any operations back up the tree
    // once we find the element, so it is much more efficient
    // not to use recursion (which uses lots of push, call,
    // pop, and ret instructions rather than short loop
    // termination tests).
    //

    LargestElementPath = TRUE;
    while (!GtbpChildrenAreLeaves(Node)) {
        Children = GtbpNumberOfChildren( Node );
        GtbpGetSubTreeOfElement( Table, Node, Element, &Node, &SubTree );
        if (Children > SubTree) { //did we take the highest value path?
            LargestElementPath = FALSE;
        }
    }

    Children = GtbpNumberOfChildren(Node);

    //
    // We are at the node which "might" contain the element.
    // See if any of the children match.
    //
    //      MUST compare 3rd, then 2nd, then 1st child !!
    //

    //
    // Try third child...
    // If we are evaluating the largest element in the
    // table, then the RestartKey will be set to continue
    // at the beginning of the table.  Otherwise, it is
    // set to continue from here.
    //

    if (Children == 3) {
        Leaf = (PGTB_TWO_THREE_LEAF)Node->ThirdChild;
        CompareResult = (*Table->Compare)( Leaf->Element, Element );

        if ( (CompareResult == GenericEqual)  ||
             (CompareResult == GenericLessThan)  ) {
            if (LargestElementPath && (Children == 3)) {
                (*RestartKey) = NULL; // Restart at beginning of list
            } else {
                (*RestartKey) = (PVOID)(Leaf); // Restart here
            }
            return(Leaf->Element);
        }
    }

    //
    // Try second child
    //

    if (Children >= 2) {    // Must allow for Root node case
        Leaf = (PGTB_TWO_THREE_LEAF)Node->SecondChild;
        CompareResult = (*Table->Compare)( Leaf->Element, Element );

        if ( (CompareResult == GenericEqual)  ||
             (CompareResult == GenericLessThan)  ) {
            if (LargestElementPath && (Children == 2)) {
                (*RestartKey) = NULL; // Restart at beginning of list
            } else {
                (*RestartKey) = (PVOID)(Leaf); // Restart here
            }
            return(Leaf->Element);
        }
    }

    //
    // Try first child
    //

    Leaf = (PGTB_TWO_THREE_LEAF)Node->FirstChild;
    CompareResult = (*Table->Compare)( Leaf->Element, Element );

    if ( (CompareResult == GenericEqual)  ||
         (CompareResult == GenericLessThan)  ) {
        if (LargestElementPath && (Children == 1)) {
            (*RestartKey) = NULL; // Restart at beginning of list
        } else {
            (*RestartKey) = (PVOID)(Leaf); // Restart here
        }
        return(Leaf->Element);
    }


    
    (*RestartKey) = NULL;
    return(NULL);
}


ULONG
RtlNumberElementsGenericTable2(
    PRTL_GENERIC_TABLE2 Table
    )

/*++

Routine Description:

    The function NumberGenericTableElements returns a ULONG value 
    which is the number of generic table elements currently inserted
    in the generic table.                                         
    

Arguments:

    Table - Pointer to the generic table.


 Return Value:

    ULONG - The number of elements in the table.

--*/

{   
    return Table->ElementCount;
}


BOOLEAN
RtlIsGenericTable2Empty (
    PRTL_GENERIC_TABLE2 Table
    )
/*++

Routine Description:

    The function IsGenericTableEmpty will return to the caller TRUE if
    the generic table is empty (i.e., does not contain any elements) 
    and FALSE otherwise.
    

Arguments:

    Table - Pointer to the generic table.


 Return Value:

    BOOLEAN - True if table is empty, otherwise FALSE.

--*/

{   
    return (Table->ElementCount == 0);
}



//////////////////////////////////////////////////////////////////////////
//                                                                      //
//  Internal (private) Services ...                                     //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


VOID
GtbpDeleteFromSubTree (
    IN  PRTL_GENERIC_TABLE2         Table,
    IN  PGTB_TWO_THREE_NODE         Node,
    IN  PVOID                       Element,
    OUT PGTB_TWO_THREE_LEAF         *LowOfNode,
    OUT BOOLEAN                     *ElementDeleted,
    OUT BOOLEAN                     *OnlyOneChildLeft
    )

/*++

Routine Description:

    Delete an element from a SubTree.


Arguments:

    Table - Points to the table.  This is needed for comparison
        and memory-free routine.

    Node - Points to the child node within which the element to
        delete resides (if it is in the tree at all).

    Element - points to an element.  We are to delete any element
        found to be equal to this element.

    LowOfNode - If the first child of Node isn't changed, then
        a zero will be returned to this parameter, signifying that
        the caller doesn't have to worry about updating LowOfXxx values.
        However, if the first child of Node does change, then this
        value will point to the new Low Leaf for the node's subtrees.

    ElementDeleted - Receives a boolean value indicating whether or
        not an element was actually deleted.  TRUE is returned if
        an element was deleted.  FALSE is returned if no element
        was deleted.

    OnlyOneChildLeft - Receives a boolean value indicating whether or
        not ChildNode was reduced to having only a single child.
        TRUE indicates ChildNode now has only one child.
        FALSE indicates ChildNode has at least two children.

Return Value:

    None.

--*/

{
    RTL_GENERIC_COMPARE_RESULTS
        CompareResult;

    PGTB_TWO_THREE_NODE
        SubTreeNode;

    PGTB_TWO_THREE_LEAF
        Leaf;

    ULONG
        SubTree;

    (*LowOfNode) = 0;   // Default is no change
    (*OnlyOneChildLeft) = FALSE;  // Default return value
    

    //
    // If we are a parent of leaves, then we can look for an
    // element to delete.  Otherwise, just find the subtree
    // to continue or search in and recurse.
    //

    if (GtbpChildrenAreLeaves(Node)) {

        (*ElementDeleted) = FALSE;  // Default return value

        //
        // See if any of the elements match the one passed in.
        // If so, delete the element and shift larger elements
        // to take up the free'd child's spot (unless it is the
        // third child).
        //

        if (Node->ThirdChild != NULL) {
            Leaf = (PGTB_TWO_THREE_LEAF)Node->ThirdChild;
            CompareResult = (*Table->Compare)( Element, Leaf->Element );

            if (CompareResult == GenericEqual) {

                GtbpDiagPrint( DELETION,
                               ("GTB: Deleting 3rd child (0x%lx) of node 0x%lx\n"
                               "     ElementCount before deletion: %d\n",
                               Leaf, Node, Table->ElementCount));

                RemoveEntryList( &Leaf->SortOrderEntry );
                (*Table->Free)(Leaf);
                Node->ThirdChild = NULL;

                Table->ElementCount--;

                (*ElementDeleted) = TRUE;
                return;
            }
        }

        //
        // Try second child
        //

        Leaf = (PGTB_TWO_THREE_LEAF)Node->SecondChild;
        CompareResult = (*Table->Compare)( Element, Leaf->Element );

        if (CompareResult == GenericEqual) {

            GtbpDiagPrint( DELETION,
                           ("GTB: Deleting 2nd child (0x%lx) of node 0x%lx\n"
                           "     ElementCount before deletion: %d\n",
                           Leaf, Node, Table->ElementCount));

            RemoveEntryList( &Leaf->SortOrderEntry );
            (*Table->Free)(Leaf);
            Node->SecondChild = Node->ThirdChild;
            Node->LowOfSecond = Node->LowOfThird;
            Node->ThirdChild  = NULL;


            //
            // If we are down to the last element, let that
            // be known.
            //
            
            if (Node->SecondChild == NULL) {
                GtbpDiagPrint( DELETION,
                               ("GTB: Only one child left in node (0x%lx).\n",
                                Node));
                (*OnlyOneChildLeft) = TRUE;
            }

            Table->ElementCount--;
            (*ElementDeleted) = TRUE;
            return;
        }

        //
        // Try first child
        //

        Leaf = (PGTB_TWO_THREE_LEAF)Node->FirstChild;
        CompareResult = (*Table->Compare)( Element, Leaf->Element );

        if (CompareResult == GenericEqual) {

            GtbpDiagPrint( DELETION,
                           ("GTB: Deleting 1st child (0x%lx) of node 0x%lx\n"
                           "     ElementCount before deletion: %d\n",
                           Leaf, Node, Table->ElementCount));

            RemoveEntryList( &Leaf->SortOrderEntry );
            (*Table->Free)(Leaf);
            Node->FirstChild  = Node->SecondChild;
            (*LowOfNode)      = Node->LowOfSecond;

            Node->SecondChild = Node->ThirdChild;
            Node->LowOfSecond = Node->LowOfThird;

            Node->ThirdChild = NULL;


            //
            // If we are down to the last element, let that
            // be known.
            //

            if (Node->SecondChild == NULL) {
                GtbpDiagPrint( DELETION,
                               ("GTB: Only one child left in node (0x%lx).\n",
                                Node));
                (*OnlyOneChildLeft) = TRUE;
            }

            Table->ElementCount--;
            (*ElementDeleted) = TRUE;
            return;
        }

        //
        // Didn't match any of the leaves
        //

        GtbpDiagPrint( DELETION,
                       ("GTB:    No matching element found on DELETE attempt.\n"));

        return; // Default value already set
    }

    //
    // Find a subtree to continue our search...
    //

    GtbpGetSubTreeOfElement( Table, Node, Element, &SubTreeNode, &SubTree );

    GtbpDeleteFromSubTree( Table,
                           SubTreeNode,
                           Element,
                           LowOfNode,
                           ElementDeleted,
                           OnlyOneChildLeft
                           );


    //
    // If we deleted an entry from either the second or third
    // subtree, then we may need to set a new LowOfXxx value.
    // If it was the first subtree, then we simply have to return
    // the LowLeaf value we received.
    //

    if ((*LowOfNode) != 0) {
        if (SubTree == 2) {
            Node->LowOfSecond = (*LowOfNode);
            (*LowOfNode) = NULL;
        } else if (SubTree == 3) {
            Node->LowOfThird = (*LowOfNode);
            (*LowOfNode) = NULL;
        } 
    }


    //
    // If the SubTreeNode has only one child left, then some
    // adjustments are going to be necessary.  Otherwise,
    // we are done.
    //

    if ((*OnlyOneChildLeft)) {

        GtbpDiagPrint( DELETION,
                       ("GTB:    Only one child left in 0x%lx\n", SubTreeNode));
        
        //
        // One of our children has only one child.
        // Re-shuffle our kid's kids.
        //
        
        GtbpCoalesceChildren(  Table,
                               Node,
                               SubTree,
                               OnlyOneChildLeft
                               );
    }

    return;
}


BOOLEAN
GtbpInsertIntoSubTree (
    PRTL_GENERIC_TABLE2             Table,
    IN  PGTB_TWO_THREE_NODE         Node,
    IN  BOOLEAN                     NodeIsLeaf,
    IN  PVOID                       Element,
    IN  ULONG                       SplitCount,
    IN  PVOID                       *FoundElement,
    OUT PGTB_TWO_THREE_NODE         *ExtraNode,
    OUT PGTB_TWO_THREE_LEAF         *LowLeaf,
    OUT PLIST_ENTRY                 *AllocatedNodes
    )

/*++

Routine Description:

    Insert an element into the SubTree specified by Node.

    Special note:

            if FoundElement is returned as NULL, that means we
            couldn't allocate memory to add the new element.

Arguments:

    Table - Points to the table being inserted into.  This is needed
        for its allocation routine.
        

    Node - Points to the root node of the SubTree into
        which the element is to be inserted.

    NodeIsLeaf - TRUE if the node passed in is a leaf.  FALSE
        if it is an internal node.

    Element - Points to the element to be inserted.

    SplitCount - indicates how many nodes have been traversed since
        a node with only two children.  When inserting a new element
        that causes nodes to be split, this will indicate how many
        nodes will split.  This allows all memory that will be required
        to split nodes to be allocated at the very bottom routine
        (before any changes to the tree are made).  See the description
        of the AllocatedNodes parameter for more information.

    FoundElement - Receives a pointer to the element that
        was either inserted, or one already in the table
        but found to match the one being inserted.
        If null is returned, then not enough memory could be
        allocated to insert the new element.

    ExtraNode - If it was necessary to create a new node to
        accomodate the insertion, then ExtraNode will receive
        a pointer to that node, otherwise ExtraNode will receive
        NULL.

    LowLeaf - This value points to the lowest value leaf of the
        SubTree starting at Node.

    AllocatedNodes - This is a tricky parameter.  We have the problem
        that when we insert an element in the tree, we may need to
        allocate additional internal nodes further up the tree as
        we return out of our recursive calls.  We must avoid the
        situation where we start making changes to the tree only to
        find we can't allocate memory to re-arrange higher levels of
        the tree.  To accomodate this situation, we always allocate
        all the nodes we will need at the very bottom of the call
        chain and pass back a linked list of GTB_TWO_THREE_NODEs using
        this parameter.  We know how many nodes we will need to
        allocate because it is the number of nodes between the leaf
        and the lowest level node in the path between the leaf and the
        root that has only 2 children.  That is, all nodes directly
        above the leaf that have 3 children will need to be split.
        Example:

                                  3
                                / | \
                         +-----+  |  +----
        Won't split -->  2        ...      ...
                       / |
                +-----+  |
              ...        3 <-- Will split 
                       / | \
                +-----+  |  +----+
              ...                3  <--- Will split
                               / | \
                        +-----+  |  +----+
                       Leaf     Leaf    Leaf   <- Add fourth leaf here.

        Adding a fourth leaf where indicated will cause a split at the
        two nodes indicated.  So, you can see that keeping a count of
        the nodes with three children since the last encountered node
        with only two children will tell us how many nodes will split.







Return Value:

    TRUE - if element was added.
    FALSE - if element not added (due to collision or out-of-memory)

--*/

{
    RTL_GENERIC_COMPARE_RESULTS
        CompareResult;

    ULONG
        SubTree;        // To track which SubTree an element is being placed in.


    PGTB_TWO_THREE_NODE
        SubTreeNode,
        NodePassedBack;


    PGTB_TWO_THREE_LEAF
        NewLeaf,
        LowPassedBack;

    BOOLEAN
        Inserted,
        SubNodeIsLeaf;


    //
    // Don't have an extra node to pass back yet.
    //

    (*ExtraNode) = NULL;


    //
    // We are either at a leaf, or an internal node.
    //

    if (NodeIsLeaf) {

        //
        // Typecast the Node into a leaf
        //

        PGTB_TWO_THREE_LEAF Leaf = (PGTB_TWO_THREE_LEAF)((PVOID)Node);

        //
        // See if the value matches.
        //

        CompareResult = (*Table->Compare)( Element, Leaf->Element );

        if (CompareResult == GenericEqual) {
            (*LowLeaf)      = Leaf;
            (*FoundElement) = Leaf->Element;

            GtbpDiagPrint( COLLISIONS,
                           ("GTB: Insertion attempt resulted in collision.\n"
                            "     Element NOT being inserted.\n"
                            "     Elements in table: %d\n",
                            Table->ElementCount));

            return(FALSE);
        }  //end_if equal

        //
        // The new element isn't in the tree.
        // Allocate a new leaf for it.
        //

        NewLeaf = GtbpAllocateLeafAndNodes( Table, SplitCount, AllocatedNodes );
        if (NewLeaf == NULL) {

            //
            // The following (unusual) return value indicates we
            // couldn't allocate memory to add the entry into the
            // tree.
            //

            (*FoundElement) = NULL;
            return(FALSE);

        }  //end_if (NewLeaf == NULL)

        switch (CompareResult) {

        case GenericLessThan: {

            //
            // Move the original element into the new leaf.  Notice
            // that the SortOrderEntry of the existing leaf is
            // still in the right place in the linked-list, even
            // though the leaf now points at a different element.
            //

            NewLeaf->Element    = Leaf->Element;
            Leaf->Element       = Element;

            break;
        } //end_case

        case GenericGreaterThan: {

            //
            // The new element does not supplant the existing element.
            // Put it in the new leaf.
            //

            NewLeaf->Element    = Element;
            break;
        } //end_case


        } //end_switch

        //
        // At this point, the lower-value element is in Leaf
        // and the higher-value element is in NewLeaf.  The
        // caller is responsible to putting NewLeaf someplace
        // else in the tree.
        //

        //
        // Now link the new leaf into our sort-order list.
        // The new leaf immediately follows our existing leaf,
        // regardless of which element is in the new leaf (original
        // or new element).
        //

        InsertHeadList(&Leaf->SortOrderEntry, &NewLeaf->SortOrderEntry);
        Table->ElementCount++;  // Increment the element count

        (*ExtraNode)    = (PGTB_TWO_THREE_NODE)((PVOID)NewLeaf);
        (*LowLeaf)      = NewLeaf;
        (*FoundElement) = Element;

        return(TRUE);

    }  //end_if NodeIsLeaf

    //
    // Node is internal (not a leaf)
    //

    //
    // See if we should re-set or increment the SplitCount.
    //

    if (Node->ThirdChild == NULL) {
        SplitCount = 0;
    } else {
        SplitCount += 1;
    }

    GtbpGetSubTreeOfElement( Table, Node, Element, &SubTreeNode, &SubTree);
    SubNodeIsLeaf = GtbpChildrenAreLeaves(Node);

    Inserted = GtbpInsertIntoSubTree ( Table,
                                       SubTreeNode,
                                       SubNodeIsLeaf,
                                       Element,
                                       SplitCount,
                                       FoundElement,
                                       &NodePassedBack,
                                       &LowPassedBack,
                                       AllocatedNodes
                                       );

    //
    // One of several things could have happened:
    //
    //      1) We didn't have enough memory to add the new element.
    //         In this case we are done and simply return.
    //
    //      2) The element was added, and no-rearrangement to this
    //         node is needed.  In this case we are done and simply
    //         return.
    //
    //      3) The element was added and caused a leaf to be pushed
    //         out of the SubTree.  We have some work to do.
    //

    if ( (FoundElement == NULL)  ||         // Insufficient memory, or
         (NodePassedBack == NULL)  ) {      // no work for this node
        return(Inserted);
    }

    if (Node->ThirdChild == NULL) {

        if (!GtbpChildrenAreLeaves(Node)) {
            NodePassedBack->ParentNode = Node;
        }

        //
        // Node doesn't yet have a third child, so use it.
        // This might require shuffling the second child to the
        // be the third child.
        //

        if (SubTree == 2) {

            //
            // Node fell out of second SubTree and we don't have a
            // third SubTree.  Make that node the third SubTree.
            //

            Node->ThirdChild = NodePassedBack;
            Node->LowOfThird = LowPassedBack;

        } else {

            //
            // Node fell out of first SubTree.
            // Make the second SubTree the third SubTree and
            // then make the passed back node the second SubTree.
            //

            ASSERT(SubTree == 1);

            Node->ThirdChild  = Node->SecondChild;
            Node->LowOfThird  = Node->LowOfSecond;
            Node->SecondChild = NodePassedBack;
            Node->LowOfSecond = LowPassedBack;

            //
            //

        }
    } else {

        //
        // Node already has three children - split it.
        //

        GtbpSplitNode( Node,
                       NodePassedBack,
                       LowPassedBack,
                       SubTree,
                       (*AllocatedNodes),
                       ExtraNode,
                       LowLeaf
                       );

    }

    return(Inserted);
}


ULONG
GtbpNumberOfChildren(
    IN  PGTB_TWO_THREE_NODE         Node
    )

/*++

Routine Description:

    Return the number of children of a specified node.

Arguments:

    Node - points to the node whose children are to be counted.

Return Values:

    0, 1, 2, or 3.

--*/
{
    if (Node->ThirdChild != NULL) {
        return(3);
    }
    if (Node->SecondChild != NULL) {
        return(2);
    }
    if (Node->FirstChild != NULL) {
        return(1);
    }
    return(0);

}


VOID
GtbpGetSubTreeOfElement(
    IN  PRTL_GENERIC_TABLE2         Table,
    IN  PGTB_TWO_THREE_NODE         Node,
    IN  PVOID                       Element,
    OUT PGTB_TWO_THREE_NODE         *SubTreeNode,
    OUT ULONG                       *SubTree
    )

/*++

Routine Description:

    Find which SubTree of Node that Element might be in (or should be
    in, if being inserted).

Arguments:

    Table - Points to the table  This is needed for its comparison routine.

    Node - Is the node, one of whose SubTrees is to be chosen as the
        subtree in which Element could/should reside.

    Element - is the element we are interested in placing or locating.

    SubTreeNode - Receives a pointer to the node of the SubTree in
        which the element could/should reside.

    SubTree - Receives the index (1, 2, or 3) of the subtree of Node
        in which the element could/should reside.

Return Values:

    None.

--*/
{
    RTL_GENERIC_COMPARE_RESULTS
        CompareResult;

    CompareResult = (*Table->Compare)( Element, Node->LowOfSecond->Element );

    if (CompareResult == GenericLessThan) {

        (*SubTree) = 1;
        (*SubTreeNode) = Node->FirstChild;

    } else {

        //
        // default to the second subtree, but
        // if there is a subtree we may change it.
        //

        (*SubTree) = 2;
        (*SubTreeNode) = Node->SecondChild;

        if (Node->ThirdChild != NULL) {

            CompareResult = (*Table->Compare)( Element, Node->LowOfThird->Element );
            if ( (CompareResult == GenericGreaterThan)  ||
                 (CompareResult == GenericEqual)          ) {

                (*SubTree) = 3;
                (*SubTreeNode) = Node->ThirdChild;
            }
        }
    }
    
    return;

}



VOID
GtbpCoalesceChildren(
    IN  PRTL_GENERIC_TABLE2         Table,
    IN  PGTB_TWO_THREE_NODE         Node,
    IN  ULONG                       SubTree,
    OUT BOOLEAN                     *OnlyOneChildLeft
    )

/*++

Routine Description:

    This routine is called following a deletion that leaves a child
    node with only one child of its own.  That is, a child of the
    Node parameter has only one child.  The SubTree parameter indicates
    which child of Node has only one child.


                    

Arguments:

    Table - Points to the table.

    Node - Is the node, one of whose children has only one child.

        NOTE: The ParentNode field of this node must be valid.
              The Low values of ParentNode will be referenced.

    SubTree - Indicates which child of Node (1, 2, or 3) has only one
        child.

    OnlyOneChildLeft - Receives a boolean indicating whether or not
        Node itself has been left with only one child due to the
        coalescing.

Return Values:

    None.

--*/
{
    PGTB_TWO_THREE_NODE
        A,
        B,
        C;

    (*OnlyOneChildLeft) = FALSE;    // Default return value

    //
    // For the following discussion, using the following:
    //
    //      N is the parent node
    //      S is the node which has only one child
    //        (S is a child of N)
    //
    //      A is the first child of N
    //      B is the second child of N
    //      C is the third child of N
    //
    // If S is the first child of N (meaning S is A)
    // then:
    //
    //      if B has three children (let A adopt the smallest)
    //      then:
    //
    //              Move B(1) to A(2)
    //              Move B(2) to B(1)
    //              Move B(3) to B(2)
    //
    //      else (B has two children)
    //
    //              (move the orphan into B)
    //              Move B(2) to B(3)
    //              Move B(1) to B(2)
    //              Move A(1) to B(1)
    //              
    //              Free A
    //              Make B the first child of N
    //              if (C is a real child)
    //              then:
    //                  Make C the second child of N
    //              else (N only has one child now)
    //                  (*OnlyOneChildLeft) = TRUE;
    //
    // else if S is the second child of N (meaning S is B)
    // then:
    //
    //      if A has three children
    //      then:
    //              Move B(1) to B(2)
    //              Move A(3) to B(1)
    //
    //      else if C exists and has three children
    //           then:
    //
    //                  Move C(1) to B(2)
    //                  Move C(2) to C(1)
    //                  Move C(3) to C(2)
    //
    //           else: (no other child of N has three children)
    //
    //                  (Move the orphan into A)
    //                  Move B(1) to A(3)
    //              
    //                  Free B
    //                  if (C is a real child)
    //                  then:
    //                          Make C the second child of N
    //                  else: (N only has one child now)
    //                          (*OnlyOneChildLeft) = TRUE;
    //
    // else: (S is the third child of N (meaning S is C))
    //
    //      if B has three children
    //      then:
    //              (move one into C)
    //              Move C(1) to C(2)
    //              Move B(3) to C(1)
    //
    //      else: (B only has two children)
    //
    //              (move the orphan into B)
    //              Move C(1) to B(3)
    //              Free C
    // Wow!


    A = Node->FirstChild;
    B = Node->SecondChild;
    C = Node->ThirdChild;


    //
    // SubTree indicates which child has the orphan.
    //

    if (SubTree == 1) {

        //
        // First child has the orphan
        //

        if (B->ThirdChild != NULL) {

            // (B has three children - let A adopt the smallest)
            //
            //      Move B(1) to A(2)
            //      Move B(2) to B(1)
            //      Move B(3) to B(2)
            //

            A->SecondChild = B->FirstChild;
            A->LowOfSecond = Node->LowOfSecond;

            B->FirstChild  = B->SecondChild;
            Node->LowOfSecond = B->LowOfSecond;

            B->SecondChild = B->ThirdChild;
            B->LowOfSecond = B->LowOfThird;
            B->ThirdChild = NULL;

        } else {

            //
            // (B has two children)
            //  
            //        (move the orphan into B)
            //        Move B(2) to B(3)
            //        Move B(1) to B(2)
            //        Move A(1) to B(1)
            //

            B->ThirdChild  = B->SecondChild;
            B->LowOfThird  = B->LowOfSecond;

            B->SecondChild = B->FirstChild;
            B->LowOfSecond = Node->LowOfSecond;

            B->FirstChild  = A->FirstChild;
            //Node->LowOfSecond = Node->LowOfFirst;  // This gets moved back in a few steps

            //        Free A
            //        Make B the first child of N
            //        if (C is a real child)
            //        then:
            //            Make C the second child of N
            //        else (N only has one child now)
            //            (*OnlyOneChildLeft) = TRUE;
            //

            (*Table->Free)(A);
            Node->FirstChild = B;
            //Node->LowOfFirst = Node->LowOfSecond;  // See comment a few lines up

            if (C != NULL) {
                Node->SecondChild = C;
                Node->LowOfSecond = Node->LowOfThird;
                Node->ThirdChild = NULL;
            } else {
                Node->SecondChild = NULL;
                (*OnlyOneChildLeft) = TRUE;
            }
        }


    } else if (SubTree == 2) {

        //
        // Second child has the orphan
        //

        if (A->ThirdChild != NULL) {

            //
            // (A has three children)
            //
            //      Move B(1) to B(2)
            //      Move A(3) to B(1)
            //

            B->SecondChild = B->FirstChild;
            B->LowOfSecond = Node->LowOfSecond;

            B->FirstChild  = A->ThirdChild;
            Node->LowOfSecond = A->LowOfThird;
            A->ThirdChild = NULL;

        } else {

            if (C != NULL  &&
                C->ThirdChild != NULL) {

                //
                // (C exists and has three children)
                // (move the smallest into B)
                //
                //      Move C(1) to B(2)
                //      Move C(2) to C(1)
                //      Move C(3) to C(2)
                //

                B->SecondChild = C->FirstChild;
                B->LowOfSecond = Node->LowOfThird;

                C->FirstChild  = C->SecondChild;
                Node->LowOfThird = C->LowOfSecond;

                C->SecondChild = C->ThirdChild;
                C->LowOfSecond = C->LowOfThird;
                C->ThirdChild = NULL;





            } else {

                //
                // (no other child of N has three children)
                // (Move the orphan into A)
                //
                //      Move B(1) to A(3)
                //      
                //      Free B
                //      if (C is a real child)
                //      then:
                //              Make C the second child of N
                //      else: (N only has one child now)
                //              (*OnlyOneChildLeft) = TRUE;
                //

                A->ThirdChild = B->FirstChild;
                A->LowOfThird = Node->LowOfSecond;

                (*Table->Free)(B);

                if (C != NULL) {
                    Node->SecondChild = C;
                    Node->LowOfSecond = Node->LowOfThird;
                    Node->ThirdChild  = NULL;
                } else {
                    Node->SecondChild = NULL;
                    (*OnlyOneChildLeft) = TRUE;
                }
            }
        }



    } else {

        //
        // Third child has the orphan
        //

        ASSERT(SubTree == 3);
        ASSERT(C != NULL);
        ASSERT(B != NULL);

        if (B->ThirdChild != NULL) {

            //
            // (B has three children)
            // (move the largest of them into C)
            // Move C(1) to C(2)
            // Move B(3) to C(1)
            //

            C->SecondChild = C->FirstChild;
            C->LowOfSecond = Node->LowOfThird;

            C->FirstChild  = B->ThirdChild;
            Node->LowOfThird = B->LowOfThird;
            B->ThirdChild = 0;
        } else {

            //
            // (B only has two children)
            // (move the orphan into B)
            // Move C(1) to B(3)
            // Free C
            //

            B->ThirdChild = C->FirstChild;
            B->LowOfThird = Node->LowOfThird;
            Node->ThirdChild = NULL;

            (*Table->Free)(C);

        }
    }
    
    return;

}


VOID
GtbpSplitNode(
    IN  PGTB_TWO_THREE_NODE         Node,
    IN  PGTB_TWO_THREE_NODE         NodePassedBack,
    IN  PGTB_TWO_THREE_LEAF         LowPassedBack,
    IN  ULONG                       SubTree,
    IN  PLIST_ENTRY                 AllocatedNodes,
    OUT PGTB_TWO_THREE_NODE         *NewNode,
    OUT PGTB_TWO_THREE_LEAF         *LowLeaf
    )

/*++

Routine Description:
    
    This routine splits a node that already has three children.
    Memory necessary to perform the split is expected to have
    already been allocated and available via the AllocatedNodes
    parameter.
    

Parameters:

    Node - The node to be split.

    NodePassedBack - The 4th node passed back from an insertion operation
        into the SubTree of Node specified by the SubTree parameter.
        NOTE: that this may, in fact, be a GTB_TWO_THREE_LEAF !!!

    LowPassedBack - points the the low leaf value passed back by the
        insertion operation that is causing the split.

    SubTree - Indicates which SubTree of Node an element was inserted
        into which is causing the split.

    AllocatedNodes - Contains a list of allocated GTB_TWO_THREE_NODE
        blocks for use in an insertion operation (which this split
        is assumed to be part of).

    NewNode - Receives a pointer to the node generated by the split.

    LowLeaf - receives a pointer to the low leaf of the NewNode's SubTree.


Return Values:

    None.

--*/
{

    PGTB_TWO_THREE_NODE
        LocalNode;



    // Make a new node and split things up.
    // The node has already been allocated and passed back to
    // this routine via the AllocatedNodes parameter.
    //

    LocalNode = GtbpGetNextAllocatedNode( AllocatedNodes );
    ASSERT( LocalNode != NULL);
    (*NewNode) = LocalNode;

    //
    // Set known fields of new node
    //

    LocalNode->ParentNode  = Node->ParentNode;
    LocalNode->Control     = Node->Control;
    LocalNode->ThirdChild  = NULL; //Low of third is left undefined

    //
    // Now move around children...
    //

    if (SubTree == 3) {

        //
        // We were inserting into the 3rd SubTree.  This implies:
        //
        //            Node(child 3) moves to  new(child 1)
        //            Back          is put in new(child 2)
        //
      
        LocalNode->FirstChild  = Node->ThirdChild;
        LocalNode->SecondChild = NodePassedBack;
        LocalNode->LowOfSecond = LowPassedBack;
        (*LowLeaf)             = Node->LowOfThird;  // low of the new node is low of old third

        Node->ThirdChild       = NULL; //Low of third is left undefined



    } else {

        //
        // We inserted into either SubTree 1 or 2.
        // These cases cause:
        //
        //      1 =>  Node(child 3) moves to new(child 2)
        //            Node(child 2) moves to New(child 1)
        //            Back          is put in Node(child 2)
        //
        //      2 =>  Node(child 3) moves to new(child 2)
        //            Back          is put in New(child 1)
        //
        // In both these cases, Node(child 3) moves to New(child 2)
        // and there are no third children.  So do that.
        //
      
        LocalNode->SecondChild  = Node->ThirdChild;
        LocalNode->LowOfSecond  = Node->LowOfThird;


        if (SubTree == 2) {

            LocalNode->FirstChild  = NodePassedBack;
            (*LowLeaf)             = LowPassedBack;

            if (!GtbpChildrenAreLeaves(Node)) {
                NodePassedBack->ParentNode = LocalNode;
            }

        } else {

            //
            // SubTree == 1
            //

            LocalNode->FirstChild  = Node->SecondChild;
            (*LowLeaf)             = Node->LowOfSecond;

            Node->SecondChild          = NodePassedBack;
            Node->LowOfSecond          = LowPassedBack;
            if (!GtbpChildrenAreLeaves(Node)) {
                NodePassedBack->ParentNode = Node;
            }

        }
    }

    //
    // Neither node has a third child anymore
    //

    LocalNode->ThirdChild  = NULL; //Low of third is left undefined
    Node->ThirdChild       = NULL;

    //
    // Set the ParentNodes only if the children aren't leaves.
    //

    if (!GtbpChildrenAreLeaves(Node)) {

        Node->FirstChild->ParentNode  = Node;
        Node->SecondChild->ParentNode = Node;

        LocalNode->FirstChild->ParentNode  = LocalNode;
        LocalNode->SecondChild->ParentNode = LocalNode;
    }


    return;
}



PGTB_TWO_THREE_LEAF
GtbpAllocateLeafAndNodes(
    IN  PRTL_GENERIC_TABLE2     Table,
    IN  ULONG                   SplitCount,
    OUT PLIST_ENTRY             *AllocatedNodes
    )
/*++

Routine Description:

    Allocate a leaf and some number of internal nodes.  This is
    used in conjunction with GtbpGetNextAllocatedNode() when splitting
    nodes following an insertion.  These two routines allow all necessary
    memory to be allocated all at once, rather than trying to deal with
    memory allocation failures once changes to the tree have begun.


Arguments:

    Table - the table into which the nodes will be added.  This
        provides the allocation routine.

    SplitCount - indicates how many nodes will need splitting, and,
        thus, how many nodes need to be allocated.


Return Value:

    Pointer to the leaf if successful.
    NULL if unsuccessful.

--*/
{

    PGTB_TWO_THREE_LEAF
        Leaf;

    PLIST_ENTRY
        NodeRoot,
        NextNode;

    ULONG
        i;

#ifdef GTBP_DIAGNOSTICS
    PGTB_TWO_THREE_NODE
        N;
#endif //GTBP_DIAGNOSTICS

    NodeRoot = NULL;

    //
    // Allocate a chain of Nodes, if necessary
    //

    if (SplitCount > 0) {

        NodeRoot = (PLIST_ENTRY)
                   ((*Table->Allocate)( sizeof(GTB_TWO_THREE_NODE)));
        if (NodeRoot == NULL) {
            goto error_return;
        }

        InitializeListHead( NodeRoot );

#ifdef GTBP_DIAGNOSTICS

        GtbpDiagPrint(LEAF_AND_NODE_ALLOC,
                      ("GTB: Allocating %d nodes with leaf, root: 0x%lx\n",
                      SplitCount, NodeRoot));
        N = (PGTB_TWO_THREE_NODE)NodeRoot;
        N->Control = 10000;     //Used as a diagnostic allocation counter/index

#endif //GTBP_DIAGNOSTICS

        for (i=1; i<SplitCount; i++) {
            NextNode = (PLIST_ENTRY)
                       ((*Table->Allocate)( sizeof(GTB_TWO_THREE_NODE)));
            if (NextNode == NULL) {
                goto error_return;
            }
            InsertTailList( NodeRoot, NextNode );

#ifdef GTBP_DIAGNOSTICS

            N = (PGTB_TWO_THREE_NODE)NextNode;
            N->Control = 10000+i;     //Used as a diagnostic allocation counter/index

#endif //GTBP_DIAGNOSTICS
        }
    }


    //
    // Finally, allocate the leaf
    //

    Leaf = (PGTB_TWO_THREE_LEAF)
           ((*Table->Allocate)( sizeof(GTB_TWO_THREE_LEAF)));

    if (Leaf == NULL) {
        goto error_return;
    }

    (*AllocatedNodes) = NodeRoot;
    return(Leaf);

error_return:

    GtbpDiagPrint(LEAF_AND_NODE_ALLOC,
                  ("GTB:    ** error allocating leaf and nodes - insufficient memory.\n"));
    //
    // Deallocate any nodes that have already been allocated.
    //

    if (NodeRoot != NULL) {

        NextNode = NodeRoot->Flink;
        while (NextNode != NodeRoot) {
            RemoveEntryList( NextNode );
            (*Table->Free)( NextNode );
        
        
        }
        
        (*Table->Free)( NodeRoot );
    }

    return(NULL);
}


PGTB_TWO_THREE_NODE
GtbpGetNextAllocatedNode(
    IN PLIST_ENTRY      AllocatedNodes
    )
/*++

Routine Description:

    Take the next node off of the list of allocated nodes and
    return its address.


Arguments:

    AllocatedNodes - Points to the list of nodes allocated using
        GtbpAllocateLeafAndNodes().


Return Value:

    Pointer to the node.
    any other return value indicates an error in the caller.

--*/
{
    PLIST_ENTRY
        NextNode;

#ifdef GTBP_DIAGNOSTICS
    PGTB_TWO_THREE_NODE
        N;
#endif //GTBP_DIAGNOSTICS

    //
    // Remove the first entry on the list.
    // This ensures that the passed in root is the last entry
    // returned.
    //

    NextNode = AllocatedNodes->Flink;
    RemoveEntryList( NextNode );

#ifdef GTBP_DIAGNOSTICS

    NextNode->Flink = NULL;     //Just to prevent accidental re-use
    N = (PGTB_TWO_THREE_NODE)NextNode;
    ASSERT(N->Control >= 10000);    //under 10000 mplies it has already been allocated.


    GtbpDiagPrint(LEAF_AND_NODE_ALLOC,
                  ("GTB: Allocating node (index: %d) from root: 0x%lx\n",
                  (N->Control-10000), AllocatedNodes));
#endif //GTBP_DIAGNOSTICS

    return( (PGTB_TWO_THREE_NODE)((PVOID)NextNode) );
}



//////////////////////////////////////////////////////////////////////////
//                                                                      //
//  Diagnostic (Developer) routines ...                                 //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

#ifdef GTBP_DEVELOPER_BUILD

#include <string.h>

//
// This routine is expected to dump an element's value
//

typedef
VOID
(NTAPI *PGTBP_DEV_DUMP_ELEMENT_ROUTINE) (
    PVOID Element
    );


VOID
GtbpDevIndent(
    ULONG Depth
    )
{
    UNICODE_STRING
        Indent;

    RtlInitUnicodeString( &Indent,
    L"                                                                     +");

    Indent.Length = (USHORT)(Depth*4);
    if (Indent.Length > Indent.MaximumLength) {
        Indent.Length = Indent.MaximumLength;
    }

    DbgPrint("\n%wZ%d: ", &Indent, Depth);
    return;
}


VOID
GtbpDevDumpNode(
    PGTB_TWO_THREE_NODE             Parent,
    PGTB_TWO_THREE_NODE             N,
    PGTB_TWO_THREE_LEAF             Low,
    ULONG                           Depth,
    PGTBP_DEV_DUMP_ELEMENT_ROUTINE  DumpElement
    )
/*++

Routine Description:

    Dump the 2-3 tree starting at the specified node.
    
Arguments:

    N - Points to the node to start the dump at.

    Depth - Indicates the depth of the tree prior to this node.
        This is used to indent the printing.

Return Value:

    None.

--*/
{
    ASSERT(Parent == N->ParentNode);


    GtbpDevIndent( Depth );
    DbgPrint("0x%lx ", N);
    if (ARGUMENT_PRESENT(Low)) {
        DbgPrint("(LowElement): ");
        DumpElement( Low->Element );
    }

    Depth++;

    if (GtbpChildrenAreLeaves(N)) {

        GtbpDevIndent( Depth );
        DumpElement( ((PGTB_TWO_THREE_LEAF)N->FirstChild)->Element );

        if (N->SecondChild != NULL) {
            GtbpDevIndent( Depth );
            DumpElement( ((PGTB_TWO_THREE_LEAF)N->SecondChild)->Element );

            if (N->ThirdChild != NULL) {
                GtbpDevIndent( Depth );
                DumpElement( ((PGTB_TWO_THREE_LEAF)N->ThirdChild)->Element );
            }
        }
    } else {

        GtbpDevDumpNode( N, N->FirstChild, NULL, Depth, DumpElement );

        if (N->SecondChild != NULL) {
            GtbpDevDumpNode( N, N->SecondChild, N->LowOfSecond, Depth, DumpElement );

            if (N->ThirdChild != NULL) {
                GtbpDevDumpNode( N, N->ThirdChild, N->LowOfThird, Depth, DumpElement );
            }
        }
    }

    return;
}


VOID
GtbpDevDumpTwoThreeTree(
    PRTL_GENERIC_TABLE2 Table,
    PGTBP_DEV_DUMP_ELEMENT_ROUTINE  DumpElement
    )
/*++

Routine Description:

    This routine causes the entire 2-3 tree to be dumped.


Arguments:

    Table - The table containing the 2-3 tree to dump.

    DumpElement - A caller supplied routine that may be called
        to dump element values.

Return Value:

    None.

--*/
{
    PLIST_ENTRY
        Next;

    
    DbgPrint("\n\n\n ****    Dump Of Generic Table2 (2-3 tree)    **** \n\n");

    DbgPrint("Table        : 0x%lx\n", Table);
    DbgPrint("Element Count: %d\n", Table->ElementCount);
    

    DbgPrint("\n\nSort Order Of Elements...");

    Next = Table->SortOrderHead.Flink;
    if (Next == &(Table->SortOrderHead)) {
        DbgPrint("Sorted list is empty.\n");
    } else {
    
        while (Next != &(Table->SortOrderHead)) {
            DbgPrint("\n0x%lx: ", Next);
            (*DumpElement)( ((PGTB_TWO_THREE_LEAF)((PVOID)Next))->Element );
            Next = Next->Flink;
        } //end_while
    } //end_if

    DbgPrint("\n\n\nTree Structure...");

    if (Table->Root == NULL) {
        DbgPrint("  Root of table is NULL - no tree present\n");
    } else {

        //
        // Walk the tree first-SubTree, second-SubTree, third-SubTree order
        //

        GtbpDevDumpNode(NULL, Table->Root, NULL, 0, DumpElement);
    }

    DbgPrint("\n\n");


    return;
}



BOOLEAN
GtbpDevValidateLeaf(
    IN     PGTB_TWO_THREE_LEAF  Leaf,
    IN     PLIST_ENTRY          ListHead,
    IN OUT ULONG                *ElementCount,
    IN OUT PLIST_ENTRY          *ListEntry
    )

/*++

Routine Description:

    Validate the specified leaf matches the next leaf in the
    SortOrder list.


Arguments:

    Leaf - Points to the leaf to validate.

    ListHead - Points to the head of the SortOrderList.

    ElementCount - Contains a count of elements already validated.
        This parameter will be incremented by 1 if the leaf is
        found to be valid.
    
    ListEntry - Points to the next element in the SortOrderList.
        This pointer will be updated to point to the next element
        in the list if the leaf is found to be valid.

Return Value:

    TRUE - Leaf is valid.

    FALSE - Leaf is not valid.

--*/
{

    if ((*ListEntry) == ListHead) {
        GtbpDiagPrint( VALIDATE,
                       ("GTB: Exhausted entries in SortOrderList while there are still\n"
                        "     entries in the tree.\n"));
    }


    if ((PVOID)Leaf == (PVOID)(*ListEntry)) {
        (*ElementCount)++;
        (*ListEntry) = (*ListEntry)->Flink;
        return(TRUE);
    } else {
        GtbpDiagPrint( VALIDATE,
                       ("GTB: Tree leaf doesn't match sort order leaf.\n"
                        "         Tree Leaf      : 0x%lx\n"
                        "         sort order leaf: 0x%lx\n",
                        Leaf, (*ListEntry)));
        return(FALSE);
    }
}


BOOLEAN
GtbpDevValidateTwoThreeSubTree(
    IN     PGTB_TWO_THREE_NODE  Node,
    IN     PLIST_ENTRY          ListHead,
    IN OUT ULONG                *ElementCount,
    IN OUT PLIST_ENTRY          *ListEntry
    )

/*++

Routine Description:

    Validate the specified subtree of a 2-3 tree.

    The ParentNode of the tree is expected to already have been
    validated by the caller of this routine.


Arguments:

    Node - Pointer to the root node of the subtree to validate.
    Validate the specified leaf matches the next leaf in the
    SortOrder list.


Arguments:

    Leaf - Points to the leaf to validate.

    ListHead - points to the SortOrderList's listhead.

    ElementCount - Contains a count of elements already validated.
        This parameter will be incremented by the number of elements
        in this subtree.

    ListEntry - Points to the next element in the SortOrderList.
        This pointer will be updated as elements are encountered and
        compared to the elements in the SortOrderList.

Return Value:

    TRUE - SubTree structure is valid.

    FALSE - SubTree structure is not valid.

--*/
{

    BOOLEAN
        Result;


    //
    // Must have at least two children unless we are the root node.
    //

    if (Node->ParentNode != NULL) {
        if  (Node->SecondChild == NULL)  {
            GtbpDiagPrint( VALIDATE,
                           ("GTB: Non-root node has fewer than two children.\n"
                            "         Node       : 0x%lx\n"
                            "         FirstChild : 0x%lx\n"
                            "         SecondChild: 0x%lx\n"
                            "         ThirdChild : 0x%lx\n",
                            Node, Node->FirstChild, Node->SecondChild,
                            Node->ThirdChild));
            return(FALSE);
        }
    }

    if  (Node->FirstChild == NULL)  {
        GtbpDiagPrint( VALIDATE,
                       ("GTB: Non-root node does not have first child.\n"
                        "         Node       : 0x%lx\n"
                        "         FirstChild : 0x%lx\n"
                        "         SecondChild: 0x%lx\n"
                        "         ThirdChild : 0x%lx\n",
                        Node, Node->FirstChild, Node->SecondChild,
                        Node->ThirdChild));
        return(FALSE);
    }



    if (!GtbpChildrenAreLeaves(Node)) {


        Result = GtbpDevValidateTwoThreeSubTree( Node->FirstChild,
                                                 ListHead,
                                                 ElementCount,
                                                 ListEntry);

        if ( Result && (Node->SecondChild != NULL) ) {
            Result = GtbpDevValidateTwoThreeSubTree( Node->SecondChild,
                                                     ListHead,
                                                     ElementCount,
                                                     ListEntry);
            if ( Result && (Node->ThirdChild != NULL) ) {
                Result = GtbpDevValidateTwoThreeSubTree( Node->ThirdChild,
                                                         ListHead,
                                                         ElementCount,
                                                         ListEntry);
            }
        }

        return(Result);
    }


    //
    // We are at a leaf node
    // Check that we have a SortOrderList entry matching each
    // leaf.
    //

    Result = GtbpDevValidateLeaf( (PGTB_TWO_THREE_LEAF)Node->FirstChild,
                                  ListHead,
                                  ElementCount,
                                  ListEntry);

    if (Result && (Node->SecondChild != NULL)) {
        Result = GtbpDevValidateLeaf( (PGTB_TWO_THREE_LEAF)Node->SecondChild,
                                      ListHead,
                                      ElementCount,
                                      ListEntry);
    if (Result && (Node->ThirdChild != NULL)) {
        Result = GtbpDevValidateLeaf( (PGTB_TWO_THREE_LEAF)Node->ThirdChild,
                                      ListHead,
                                      ElementCount,
                                      ListEntry);
        }
    }

    if (!Result) {
        GtbpDiagPrint( VALIDATE,
                       ("GTB: previous error in child analysis prevents further\n"
                        "     validation of node: 0x%lx\n", Node));
    }

    return(Result);
}

BOOLEAN
GtbpDevValidateGenericTable2(
    PRTL_GENERIC_TABLE2 Table
    )
/*++

Routine Description:

    This routine causes the entire 2-3 tree's structure to be
    validated.

        !!   DOESN'T YET VALIDATE LowOfChild VALUES    !!

Arguments:

    Table - The table containing the 2-3 tree to validate.


Return Value:

    TRUE - Table structure is valid.

    FALSE - Table structure is not valid.

--*/
{
    ULONG
        ElementCount,
        ElementsInList;

    PGTB_TWO_THREE_NODE
        Node;

    PLIST_ENTRY
        ListEntry;

    BOOLEAN
        Result;

    //
    // Walk the tree and the linked list simultaneously.
    // Walk the tree first-child, second-child, third-child
    // order to get ascending values that match the linked list.
    //


    if (Table->ElementCount == 0) {
        if (Table->Root != NULL) {
            GtbpDiagPrint( VALIDATE,
                           ("GTB: ElementCount is zero, but root node is not null.\n"
                            "     Table: 0x%lx     Root: 0x%lx\n", Table, Table->Root));
            Result = FALSE;
        } else {
            return(TRUE);
        }


    } else {
        if (Table->Root == NULL) {
            GtbpDiagPrint( VALIDATE,
                           ("GTB: ElementCount is non-zero, but root node is null.\n"
                            "     Table: 0x%lx    ElementCount: %d\n",
                            Table, Table->ElementCount));
            Result = FALSE;
        }


        if (Table->SortOrderHead.Flink == &Table->SortOrderHead) {
            GtbpDiagPrint( VALIDATE,
                           ("GTB: ElementCount is non-zero, but sort order list is empty.\n"
                            "     Table: 0x%lx    ElementCount: %d\n",
                            Table, Table->ElementCount));
            Result = FALSE;
        }

    }

    if (Result) {

        ListEntry = Table->SortOrderHead.Flink;
        Node = Table->Root;
        
        //
        // Verify parent pointer (responsibility of caller)
        //
        
        if (Node->ParentNode != NULL) {
            GtbpDiagPrint( VALIDATE,
                           ("GTB: Root parent pointer is non-null.\n"
                            "     Table: 0x%lx    Root: 0x%lx    ParentNode: 0x%lx\n",
                            Table, Node, Node->ParentNode));
            Result = FALSE;
        }

        if (Result) {

            ElementCount = 0;
            Result = GtbpDevValidateTwoThreeSubTree( Node,
                                                     &Table->SortOrderHead,
                                                     &ElementCount,
                                                     &ListEntry);
            if (Result) {
            
                ElementsInList = ElementCount;
                while (ListEntry != &Table->SortOrderHead) {
                    ElementsInList++;
                    ListEntry = ListEntry->Flink;
                }
                if ( (ElementCount != Table->ElementCount) ||
                     (ElementsInList != ElementCount) ) {
                    GtbpDiagPrint( VALIDATE,
                                   ("GTB: Table is valid except either the ElementCount doesn't match\n"
                                    "     the number of elements in the table or there were entries on\n"
                                    "     the SortOrderList that weren't in the table.\n"
                                    "           Table           :  0x%lx\n"
                                    "           Root            :  0x%lx\n"
                                    "           ElementCount    :  %d\n"
                                    "           Elements In Tree:  %d\n"
                                    "           Elements In List:  %d\n",
                                        Table, Node, Table->ElementCount,
                                        ElementCount, ElementsInList));
                    Result = FALSE;
                }
            } else {
                GtbpDiagPrint( VALIDATE,
                               ("GTB: previous validation error in table 0x%lx prevents\n"
                                "     further processing.\n", Table));
            }
        }
    }

    if (!Result) {
        DbgBreakPoint();
    }


    return(Result);
}
#endif //GTBP_DEVELOPER_BUILD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\enum.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    enum.c

Abstract:

    This file contains the core account enumeration services

Author:

    Murli Satagopan    (MURLIS) 

Environment:

    User Mode - Win32

Revision History:

  6-19-96: MURLIS Created.


--*/


/////////////////////////////////////////////////////////////////////////////
/*
 
  ENUMERATION ROUTINES IMPLEMENTATION

    The Entry Points for the core Enumeration routines are

        SampEnumerateAcountNamesCommon -- 

            Called By the Samr RPC routines

        SampEnumerateAccountNames2 -- 

            Called by the above SampEnumerateAccountNamesCommon
            and internal routines that need enumeration.

        SampEnumerateAccountNames

            Called by old Registry Mode routines only, that require enumeration
            EnumerateAccountNames is called with the TransactionDomain Set
            and Read lock Held. It can also be called in DS mode as long as
            the above 2 conditions are met.

         
    SampEnumerateAccountNames2 does the actual work of enumerating account 
    names. the transaction domain to be set . SampEnumerateAccountNames 
    looks at the current current transaction domain and makes the decision
    wether it is DS or Registry and then Calls either DS or Registry version.
    While the way enumeration is done from the registry is unaltered the 
    way it is done from the DS is as follows:

    Enumerating Accounts in DS uses the DS Search mechanism along with 
    the Paged Results extension. The First time the client calls the Enumerate
    accounts routine, the value of EnumerationHandle is set to 0. 
    This results in the code building a DS Filter structure and set up a 
    new search. If More entries are turned up the search, than memory 
    restrictions will warrant, then the DS will turn return a PagedResults 
    Structure. This paged results structure is used to determine if more entries
    are present. The restart handle given out by the DS is the RID. The top 2 bits
    are used to represent the account type of the user ( user, machine, trust ) for 
    user enumeration. Index ranges set on NC_acctype_sid index are used to restart
    the search given the account type and the RID.
    
   

*/
////////////////////////////////////////////////////////////////////////////

//
//  Includes
// 
#include <samsrvp.h>
#include <mappings.h>
#include <dslayer.h>
#include <filtypes.h>
#include <dsdsply.h>
#include <dsconfig.h>
#include <malloc.h>
#include <lmcons.h>

//
//
// The Maximum Number of Enumerations a Client can simultaneously do. Since
// we keep around some state in memory per enumeration operation and since
// we are the security system, we cannot alow a malicious client from running
// us out of memory. So limit on a per client basis. Our state info is size is
// qpprox 1K byte. 
//

#define SAMP_MAX_CLIENT_ENUMERATIONS 16

//
// DS limits the number of items that a given search can find. While in the
// SAM API, the approximate amount of memory is specified. This factor is
// is used in computing the number of entries required fro memory specified
//

#define AVERAGE_MEMORY_PER_ENTRY    sizeof(SAM_RID_ENUMERATION) + LM20_UNLEN * sizeof(WCHAR) + sizeof(WCHAR)



//
// In DS mode the max size of the buffer that can be returned by the enumeration
// API's
//

#define SAMP_MAXIMUM_MEMORY_FOR_DS_ENUMERATION AVERAGE_MEMORY_PER_ENTRY * 512 

//
//  Prototypes of Private Functions
//

NTSTATUS
SampEnumerateAccountNamesDs(
    IN DSNAME * DomainObjectName,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN          BuiltinDomain,
    IN OUT PULONG EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG Filter,
    OUT PULONG CountReturned,
    IN BOOLEAN TrustedClient
    );

NTSTATUS
SampBuildDsEnumerationFilter(
   IN SAMP_OBJECT_TYPE  ObjectType,
   IN ULONG             UserAccountControlFilter,
   OUT FILTER         * DsFilter,
   OUT PULONG         SamAccountTypeLo,
   OUT PULONG         SamAccountTypeHi
   );

VOID
SampFreeDsEnumerationFilter(
    FILTER * DsFilter
    );


NTSTATUS
SampEnumerateAccountNamesRegistry(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG Filter,
    OUT PULONG CountReturned,
    IN BOOLEAN TrustedClient
    );


NTSTATUS
SampPackDsEnumerationResults(
    IN PSID     DomainPrefix,
    IN BOOLEAN  BuiltinDomain,
    SEARCHRES   *SearchRes,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN ULONG    ExpectedAttrCount,
    IN ULONG    Filter,
    ULONG       * Count,
    PSAMPR_RID_ENUMERATION  *RidEnumerationList
    );

NTSTATUS
SampDoDsSearchContinuation(
    IN  SEARCHRES * SearchRes,
    IN OUT PULONG EnumerationContext,
    IN  BOOLEAN   CanEnumerateEntireDomain,
    OUT BOOLEAN * MoreEntries
    );
    
NTSTATUS
SampGetLastEntryRidAndAccountControl(
    IN  SEARCHRES * SearchRes, 
    IN  SAMP_OBJECT_TYPE ObjectType,
    IN  ULONG     ExpectedAttrCount,
    OUT ULONG     * Rid,
    OUT ULONG     * LastAccountControlValue
    );
    

NTSTATUS
SampEnumerateAccountNames2(
    IN PSAMP_OBJECT     DomainContext,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG Filter,
    OUT PULONG CountReturned,
    IN BOOLEAN TrustedClient
    );

ULONG
Ownstrlen(
    CHAR * Sz
   );


NTSTATUS
SampEnumerateAccountNamesCommon(
    IN SAMPR_HANDLE DomainHandle,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationHandle,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG Filter,
    OUT PULONG CountReturned
    )

/*++

Routine Description:

    This routine enumerates names of either user, group or alias accounts.
    This routine is intended to directly support

        SamrEnumerateGroupsInDomain(),
        SamrEnumerateAliasesInDomain() and
        SamrEnumerateUsersInDomain().

    This routine performs database locking, and context lookup (including
    access validation).




    All allocation for OUT parameters will be done using MIDL_user_allocate.



Arguments:

    DomainHandle - The domain handle whose users or groups are to be enumerated.

    ObjectType - Indicates whether users or groups are to be enumerated.

    EnumerationHandle - API specific handle to allow multiple calls.  The
        caller should return this value in successive calls to retrieve
        additional information.

    Buffer - Receives a pointer to the buffer containing the
        requested information.  The information returned is
        structured as an array of SAM_ENUMERATION_INFORMATION data
        structures.  When this information is no longer needed, the
        buffer must be freed using SamFreeMemory().

    PreferedMaximumLength - Prefered maximum length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves
        as a guide to the server.  Due to data conversion between
        systems with different natural data sizes, the actual amount
        of data returned may be greater than this value.

    Filter - if ObjectType is users, the users can optionally be filtered
        by setting this field with bits from the AccountControlField that
        must match.  Otherwise ignored.

    CountReturned - Receives the number of entries returned.


Return Value:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.  Entries may or may not have been
        returned from this call.  The CountReturned parameter indicates
        whether any were.

    STATUS_MORE_ENTRIES - There are more entries which may be obtained
        using successive calls to this API.  This is a successful return.

    STATUS_ACCESS_DENIED - Caller does not have access to request the data.

    STATUS_INVALID_HANDLE - The handle passed is invalid.


--*/
{
    NTSTATUS                    NtStatus;
    NTSTATUS                    IgnoreStatus;
    PSAMP_OBJECT                Context;
    SAMP_OBJECT_TYPE            FoundType;
    ACCESS_MASK                 DesiredAccess;
    BOOLEAN                     fLockAcquired = FALSE;

    SAMTRACE("SampEnumerateAccountNamesCommon");

    //
    // Update DS performance statistics
    //

    SampUpdatePerformanceCounters(
        DSSTAT_ENUMERATIONS,
        FLAG_COUNTER_INCREMENT,
        0
        );


    ASSERT( (ObjectType == SampGroupObjectType) ||
            (ObjectType == SampAliasObjectType) ||
            (ObjectType == SampUserObjectType)    );

    if ((ObjectType!=SampGroupObjectType) 
        && (ObjectType!=SampUserObjectType)
        && (ObjectType!=SampAliasObjectType))
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        return NtStatus;
    }

    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (DomainHandle != NULL);
    ASSERT (EnumerationHandle != NULL);
    ASSERT (  Buffer  != NULL);
    ASSERT ((*Buffer) == NULL);
    ASSERT (CountReturned != NULL);


    //
    // Establish type-specific information
    //

    DesiredAccess = DOMAIN_LIST_ACCOUNTS;


    SampAcquireReadLock();
    fLockAcquired = TRUE;


    //
    // Validate type of, and access to object.
    //

    Context = (PSAMP_OBJECT)DomainHandle;
    NtStatus = SampLookupContext(
                   Context,
                   DesiredAccess,
                   SampDomainObjectType,
                   &FoundType
                   );


    if (NT_SUCCESS(NtStatus)) {
   
        //
        // If We are in DS Mode then release the READ lock
        // DS enumeration routines do not require the READ lock
        //

        if (IsDsObject(Context))
        {
            SampReleaseReadLock();
            fLockAcquired = FALSE;
        }


        //
        // Call our private worker routine
        //

        NtStatus = SampEnumerateAccountNames2(
                        Context,
                        ObjectType,
                        EnumerationHandle,
                        Buffer,
                        PreferedMaximumLength,
                        Filter,
                        CountReturned,
                        Context->TrustedClient
                        );

        //
        // Re-Acquire the Lock again
        //

        if (!fLockAcquired)
        {
            SampAcquireReadLock();
            fLockAcquired = TRUE;
        }    

        //
        // De-reference the object, discarding changes
        //

        IgnoreStatus = SampDeReferenceContext( Context, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Free the read lock
    //

    ASSERT(fLockAcquired);

    SampReleaseReadLock();

    return(NtStatus);
}

NTSTATUS
SampEnumerateAccountNames(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG Filter,
    OUT PULONG CountReturned,
    IN BOOLEAN TrustedClient
    )

/*++

  Routine Description

    This routine is a wrapper aroung SampEnumerateAccountNames2, so that
    old Registry mode callers can continue to use this entry point. 
    Parameters to this are identical to SampEnumerateAccountNames2

--*/
{
    ASSERT(SampCurrentThreadOwnsLock());
    ASSERT(SampTransactionWithinDomain);

    return(SampEnumerateAccountNames2(
                SampDefinedDomains[SampTransactionDomainIndex].Context,
                ObjectType,
                EnumerationContext,
                Buffer,
                PreferedMaximumLength,
                Filter,
                CountReturned,
                TrustedClient
                ));
}

NTSTATUS
SampEnumerateAccountNames2(
    IN PSAMP_OBJECT     DomainContext,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG Filter,
    OUT PULONG CountReturned,
    IN BOOLEAN TrustedClient
    )
/*++

Routine Description:

    This is the wrapper around the worker routine used to enumerate user,
    group or alias accounts. This determines wether the domain is in the
    DS or Registry, and then depending upon the outcome calls the 
    appropriate flavour of the routine


    Note:  IN REGISTRY MODE ONLY THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN.
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseReadLock() in registry mode. In DS mode this
           routine is completely thread safe.



    All allocation for OUT parameters will be done using MIDL_user_allocate.



Arguments:

    DomainContext - Pointer to SAM object.

    ObjectType - Indicates whether users or groups are to be enumerated.

    EnumerationContext - API specific handle to allow multiple calls.  The
        caller should return this value in successive calls to retrieve
        additional information.

    Buffer - Receives a pointer to the buffer containing the
        requested information.  The information returned is
        structured as an array of SAM_ENUMERATION_INFORMATION data
        structures.  When this information is no longer needed, the
        buffer must be freed using SamFreeMemory().

    PreferedMaximumLength - Prefered maximum length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves
        as a guide to the server.  Due to data conversion between
        systems with different natural data sizes, the actual amount
        of data returned may be greater than this value.

    Filter - if ObjectType is users, the users can optionally be filtered
        by setting this field with bits from the AccountControlField that
        must match.  Otherwise ignored.

    CountReturned - Receives the number of entries returned.

    TrustedClient - says whether the caller is trusted or not.  If so,
        we'll ignore the SAMP_MAXIMUM_MEMORY_TO_USE restriction on data
        returns.


Return Value:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.  Entries may or may not have been
        returned from this call.  The CountReturned parameter indicates
        whether any were.

    STATUS_MORE_ENTRIES - There are more entries which may be obtained
        using successive calls to this API.  This is a successful return.

    STATUS_ACCESS_DENIED - Caller does not have access to request the data.


--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;


    if (SampUseDsData)
    {
        //
        // DS Object - Do the DS thing
        //
        do
        {
        
            NtStatus = SampEnumerateAccountNamesDs(
                                        DomainContext->ObjectNameInDs,
                                        ObjectType,
                                        IsBuiltinDomain(DomainContext->DomainIndex),
                                        (PULONG)
                                            EnumerationContext,
                                        Buffer,
                                        PreferedMaximumLength,
                                        Filter,
                                        CountReturned,
                                        TrustedClient
                                        );
           
          
            if ((0 == *CountReturned) && (STATUS_MORE_ENTRIES == NtStatus))
            {
                if (*Buffer)
                {
                    MIDL_user_free(*Buffer);
                    *Buffer = NULL;
                }
            }
            
            // 
            // The above routine will first do a DS search, then apply the 
            // bit mask Filter on all the entries returned from core DS search. 
            // Only reture those objects which satisfy the bitmask filter. In 
            // the unfortuante case that no object matching the bitmask is found, 
            // and we still have more objects to look through into the core DS, 
            // we end up returning STATUS_MORE_ENTRIES with 0 count of entries.
            // To address this problem, we should continue to search until we
            // have at least one entry to return or nothing to return.
            // 
                                        
        } while ((0 == *CountReturned) && (STATUS_MORE_ENTRIES == NtStatus));
    }
    else
    {

        ASSERT(SampCurrentThreadOwnsLock());
        ASSERT(SampTransactionWithinDomain);
        ASSERT(SampTransactionDomainIndex==DomainContext->DomainIndex);

        //
        // Registry Object - Do the Registry thing
        //
        NtStatus = SampEnumerateAccountNamesRegistry(
                                    ObjectType,
                                    EnumerationContext,
                                    Buffer,
                                    PreferedMaximumLength,
                                    Filter,
                                    CountReturned,
                                    TrustedClient
                                    );
    }

    return NtStatus;
 
}
   
NTSTATUS
SamIEnumerateInterdomainTrustAccountsForUpgrade(
    IN OUT PULONG   EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG       PreferredMaximumLength,
    OUT PULONG     CountReturned
    )
/*++

   Routine Description

   This is packaged export for in process callers to enumerate
   accounts from the DS that can be called when upgrading from
   NT4. Specification of the domain is not required as we know
   the domain that we are upgrading.

   Parameters

      See SampEnumerateAccountNamesDs below
 
   Return Values
 
      See SampEnumerateAccountNamesDs below
--*/
{
    PDSNAME      DomainDn=NULL;
    ULONG        Length = 0;
    NTSTATUS     NtStatus = STATUS_SUCCESS;


    //
    // Get the root domain
    //

    NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                                &Length,
                                NULL
                                );


    if (STATUS_BUFFER_TOO_SMALL == NtStatus)
    {
        SAMP_ALLOCA(DomainDn,Length );
        if (NULL==DomainDn)
        {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

        NtStatus = GetConfigurationName(DSCONFIGNAME_DOMAIN,
                                    &Length,
                                    DomainDn
                                    );

       ASSERT(NT_SUCCESS(NtStatus));
       
    }

    if (!NT_SUCCESS(NtStatus))
    {
       return(NtStatus);
    }

    return(SampEnumerateAccountNamesDs(
                  DomainDn,
                  SampUserObjectType,
                  FALSE,
                  EnumerationContext,
                  Buffer,
                  0xFFFFFFFF,
                  USER_INTERDOMAIN_TRUST_ACCOUNT,
                  CountReturned,
                  TRUE  // Trusted client
                  ));
}
                  

NTSTATUS
SampEnumerateAccountNamesDs(
    IN DSNAME   * DomainObjectName,
    IN SAMP_OBJECT_TYPE ObjectType,
    IN BOOLEAN    BuiltinDomain,
    IN OUT PULONG EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG Filter,
    OUT PULONG CountReturned,
    IN BOOLEAN TrustedClient
    )
/*++

Routine Description:

    This routine does the work of enumeration for the DS case.

    All allocation for OUT parameters will be done using MIDL_user_allocate.



Arguments:

    ObjectType - Indicates whether users or groups are to be enumerated.

    BuiltinDomain - Indicates the the domain is a builtin domain

    EnumerationContext - API specific handle to allow multiple calls.  The
        caller should return this value in successive calls to retrieve
        additional information. The Enumeration context returned is the RID of
        the account

    Buffer - Receives a pointer to the buffer containing the
        requested information.  The information returned is
        structured as an array of SAM_ENUMERATION_INFORMATION data
        structures.  When this information is no longer needed, the
        buffer must be freed using SamFreeMemory().

    PreferedMaximumLength - Prefered maximum length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves
        as a guide to the server.  Due to data conversion between
        systems with different natural data sizes, the actual amount
        of data returned may be greater than this value.

    Filter - if ObjectType is users, the users can optionally be filtered
        by setting this field with bits from the AccountControlField that
        must match.  Otherwise ignored.

    CountReturned - Receives the number of entries returned.

    TrustedClient - says whether the caller is trusted or not.  If so,
        we'll ignore the SAMP_MAXIMUM_MEMORY_TO_USE restriction on data
        returns.


Return Value:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.  Entries may or may not have been
        returned from this call.  The CountReturned parameter indicates
        whether any were.

    STATUS_MORE_ENTRIES - There are more entries which may be obtained
        using successive calls to this API.  This is a successful return.

    STATUS_ACCESS_DENIED - Caller does not have access to request the data.


--*/
{
    //
    // Amount of memory that we may use.
    //

    ULONG       MemoryToUse = PreferedMaximumLength;

    //
    // Specify the attributes that we want to read as part of the search.
    // The Attributes specified in GenericReadAttrTypes are read from the DS, 
    // except for user objects ( due to filter on account control bits )
    // account control bits. 
    //
    // NOTE 
    // The Ordering of the Rid and the Name 
    // must be the same for both User and Generic Attr Types. 
    // Further they should be the First two attributes.
    //

    ATTRTYP     GenericReadAttrTypes[]=
                {
                    SAMP_UNKNOWN_OBJECTRID,
                    SAMP_UNKNOWN_OBJECTNAME,
                }; 
    ATTRVAL     GenericReadAttrVals[]=
                {
                    {0,NULL},
                    {0,NULL}
                };
                  
    DEFINE_ATTRBLOCK2(
                      GenericReadAttrs,
                      GenericReadAttrTypes,
                      GenericReadAttrVals
                      );

    ATTRTYP     UserReadAttrTypes[]=
                {
                    SAMP_FIXED_USER_USERID,
                    SAMP_USER_ACCOUNT_NAME,
                    SAMP_FIXED_USER_ACCOUNT_CONTROL,
                };
    ATTRVAL     UserReadAttrVals[]=
                {
                    {0,NULL},
                    {0,NULL},
                    {0,NULL}
                };

    DEFINE_ATTRBLOCK3(
                        UserReadAttrs,
                        UserReadAttrTypes,
                        UserReadAttrVals
                      );

    //
    // Specify other local variables that we need
    //
    ATTRBLOCK  *AttrsToRead;
    NTSTATUS   Status = STATUS_SUCCESS;
    PSAMPR_RID_ENUMERATION  RidEnumerationList = NULL;
    SEARCHRES   *SearchRes;
    BOOLEAN     MoreEntries = FALSE;
    BOOLEAN     CanEnumerateEntireDomain = TRUE;
    ULONG       MaximumNumberOfEntries;
    SAMP_OBJECT_TYPE    ObjectTypeForConversion;
    FILTER      DsFilter;
    ULONG       SamAccountTypeLo, SamAccountTypeHi;
    ULONG       StartingRid = 0;
    PSID        StartingSid = NULL;
    PSID        EndingSid = NULL;
    PSID        DomainSid = &DomainObjectName->Sid;
    ULONG       LastAccountControlValue;

#define TOP_2_FOR_MACHINE_ACCOUNT  ((ULONG)0x80000000)
#define TOP_2_FOR_TRUST_ACCOUNT    ((ULONG)0xC0000000)
    //
    // The Passed in Domain Object Must have a SID in it
    //

    ASSERT(DomainObjectName->SidLen>0);
    ASSERT(RtlValidSid(&DomainObjectName->Sid));

    //
    // Allocate memory to hold the result
    //

    *Buffer = MIDL_user_allocate(sizeof(SAMPR_ENUMERATION_BUFFER));
    if (NULL==*Buffer)
    {
        Status = STATUS_NO_MEMORY;
        goto Error;
    }

  

    //
    // Check for Memory Restrictions
    //

    if ( (!TrustedClient) && 
         (PreferedMaximumLength > SAMP_MAXIMUM_MEMORY_FOR_DS_ENUMERATION))
    {
        MemoryToUse = SAMP_MAXIMUM_MEMORY_FOR_DS_ENUMERATION;
    }

    //
    // For Builtin Domain, no matter what, try maximum 
    // entries we can search.  
    //
    // That is because 
    // 1. We do not set the index hints for builtin domain. 
    // 2. And We do not support continue enumeration for builtin domain 
    // 
    // So the caller will never get all alias groups if the 
    // PreferedMaximumLength was set too small. 
    // fortunatelty, there are only couple of alias groups in 
    // builtin domain. (say less than 10, maybe 9 only)
    //

    if (BuiltinDomain)
    {
        MemoryToUse = SAMP_MAXIMUM_MEMORY_FOR_DS_ENUMERATION;
    }

    //
    // Compute the maximim number of entries we want based on 
    // memory restrictions. Add plus 1 , so that at least 1 entry
    // will be returned.
    //

    MaximumNumberOfEntries = MemoryToUse/AVERAGE_MEMORY_PER_ENTRY + 1;


    //
    // Run special check (introduced for Windows 2000 SP2).
    // 
    // The goal is to stop enumerate everyone behaviour. This hotfix
    // allows an administrator to shut down this API's alone to everyone
    // except a subset of people. 
    // 
    
    if (SampDoExtendedEnumerationAccessCheck)
    {
        Status = SampExtendedEnumerationAccessCheck( &CanEnumerateEntireDomain );

        if (!NT_SUCCESS(Status))
        {
            goto Error;
        }
    }

    if ((!CanEnumerateEntireDomain) && (0!=*EnumerationContext))
    {
        //
        // Enumerating whole domain and no rights bail
        //

        Status = STATUS_SUCCESS;
        MoreEntries = FALSE;
        *CountReturned = 0;
        RidEnumerationList = NULL;
        goto Error;

    }

    //
    // Specify the Apropriate Attributes to Read
    //

    if (ObjectType == SampUserObjectType)
    {
        AttrsToRead = &UserReadAttrs;
        ObjectTypeForConversion = SampUserObjectType;
    }
    else
    {
        AttrsToRead = &GenericReadAttrs;
        ObjectTypeForConversion = SampUnknownObjectType;
    }
    
    //
    // Build the correct filter
    //

    RtlZeroMemory(&DsFilter,sizeof(FILTER));

    Status = SampBuildDsEnumerationFilter(
                ObjectType, 
                Filter, 
                &DsFilter,
                &SamAccountTypeLo,
                &SamAccountTypeHi
                );

    if (!NT_SUCCESS(Status))
        goto Error;

    //
    // Compute the starting and ending Sid Ranges
    // The top 2 bits of the Enumeration Context indicate the account type
    // value ( need to preserve it in the enumeration context, cannot do read that
    // again from database as object could have been deleted.
    // SO mask the top 2 bits.

   
    StartingRid = ((*EnumerationContext) &0x3FFFFFFF) + 1;
   
    Status = SampCreateFullSid(
                    DomainSid,
                    StartingRid,
                    &StartingSid
                    );

    if (!NT_SUCCESS(Status))
        goto Error;

    Status = SampCreateFullSid(
                    DomainSid,
                    0x7fffffff,
                    &EndingSid
                    );

    if (!NT_SUCCESS(Status))
        goto Error;

  
    //
    // Start a transaction if one did not exist.
    //

    Status = SampMaybeBeginDsTransaction(TransactionRead);
    if (!NT_SUCCESS(Status))
        goto Error;

    //
    // If this were a restarted search, then we may need to modify
    // SamAccountTypeLo to be the SAM account type of the object we
    // gave out. So find the object and get its SamAccount type in 
    // here. We that only in the case of the user object as that is
    // the only category where we will traverse multiple values of
    // SAM account type in the same enumeration
    //

    if ((0!=*EnumerationContext)
        && (SampUserObjectType == ObjectType))
    {
        ULONG Top2Bits = ((*EnumerationContext) & 0xC0000000);

        switch(Top2Bits)
        {
        case TOP_2_FOR_TRUST_ACCOUNT:
                SamAccountTypeLo = SAM_TRUST_ACCOUNT;
                break;
        case TOP_2_FOR_MACHINE_ACCOUNT:
                SamAccountTypeLo = SAM_MACHINE_ACCOUNT;
                break;
        default:
                SamAccountTypeLo = SAM_NORMAL_USER_ACCOUNT;
                break;

        }
    }
                


    //
    // if not Trusted Client, Turn off fDSA
    //
    if (!TrustedClient) {
        SampSetDsa(FALSE);
    }

   
    //
    // Set the Index hints for the DS. If it is the builtin domain do not
    // set the index hints to the DS. The DS will simply choose the PDNT
    // index for the builtin domain
    //

    ASSERT((!BuiltinDomain) || (*EnumerationContext==0));
    if (!BuiltinDomain)
    {
        Status = SampSetIndexRanges(
                    SAM_SEARCH_NC_ACCTYPE_SID,
                    sizeof(ULONG),
                    &SamAccountTypeLo,
                    RtlLengthSid(StartingSid),
                    StartingSid,
                    sizeof(ULONG),
                    &SamAccountTypeHi,
                    RtlLengthSid(EndingSid),
                    EndingSid,
                    FALSE
                    );

        if (!NT_SUCCESS(Status))
            goto Error;
    }

    //
    // Perform the Search by calling DirSearch
    //

    Status = SampDsDoSearch2(
                          0,
                          NULL, 
                          DomainObjectName, 
                          &DsFilter,
                          0,
                          ObjectTypeForConversion,
                          AttrsToRead,
                          MaximumNumberOfEntries,
                          TrustedClient?0:(15 * 60 * 1000 ),
                                // 15 min timeout for non trusted client. 
                          &SearchRes
                          );

    //
    // First Free the Filter Structure , irrespective of any
    // Error returns
    //

    SampFreeDsEnumerationFilter(&DsFilter);

    if (!NT_SUCCESS(Status))
        goto Error;
   

    //
    // Handle any paged results returned by the DS.
    //

    Status =  SampDoDsSearchContinuation(
                    SearchRes,
                    EnumerationContext,
                    CanEnumerateEntireDomain,
                    &MoreEntries
                    );

    if (!NT_SUCCESS(Status))
        goto Error;
        
  
    if (MoreEntries)
    {
        //
        // Set the Enumeration handle to the value of the last 
        // entry's RID
        //
        
        ULONG   LastRid = 0;
        
        //
        // Get last entry's Rid, and AccountControl if applicable.
        // 
        
        Status = SampGetLastEntryRidAndAccountControl(
                                     SearchRes, 
                                     ObjectType, 
                                     AttrsToRead->attrCount,
                                     &LastRid, 
                                     &LastAccountControlValue
                                     );
        
        if (!NT_SUCCESS(Status))
            goto Error;
            
        //
        // Check, if we did get something from above, then fill the 
        // enumeration context. 
        //
            
        if (0 != LastRid)
        {
            *EnumerationContext = LastRid;

            if (SampUserObjectType==ObjectType)
            {
                //
                // for User Object, the LastAccountControlValue should 
                // always be the correct one corresponding to the RID.
                //
                 
                //
                // No One's AccountControl is 0, assert it. 
                // 
                ASSERT((0 != LastAccountControlValue) && "LastAccountControlValue is 0. Impossible");
                
                if (LastAccountControlValue & USER_INTERDOMAIN_TRUST_ACCOUNT)
                {
                    (*EnumerationContext)|=TOP_2_FOR_TRUST_ACCOUNT;
                }
                else if (LastAccountControlValue & USER_MACHINE_ACCOUNT_MASK)
                {
                    (*EnumerationContext)|=TOP_2_FOR_MACHINE_ACCOUNT;
                }
            }
        }
        else
        {
            // 
            // The only case we would fall into here is that
            //  1. there are more entries in DS we should look through.
            //  2. No entry in the current search results is passed DS access check
            // 
            // In this case, we really should do an additional read against the the 
            // last entry (while turn on fDSA, without DS access check), get the last 
            // entry's AccountControl and Rid, set the enumeration context correctly. 
            // 
            // However, when the client falls into this case, it seems that most likely
            // the client does not enough right to enumeration this domain. To less 
            // this additional read on Domain Controller, we vote to return access 
            // deny, even this means minor DownLevel imcopatibility problem. 
            // 
            
            Status = STATUS_ACCESS_DENIED;
            
            goto Error;
        }
    }
    else
    {
        *EnumerationContext = 0;
    }

    //
    // Search Succeeded. Pack the results into appropriate
    // Rid Enumeration Buffers.
    //

    Status = SampPackDsEnumerationResults(
                    &DomainObjectName->Sid,
                    BuiltinDomain,
                    SearchRes,
                    ObjectType,
                    AttrsToRead->attrCount,
                    Filter,
                    CountReturned,
                    &RidEnumerationList
                    );

   


  
Error:

    if (!NT_SUCCESS(Status))
    {
        //
        // Error return, do the cleanup work.
        //

        *EnumerationContext = 0;
        
        *CountReturned = 0;

        if (*Buffer)
        {
            MIDL_user_free(*Buffer);
            *Buffer = NULL;
        }

    }
    else
    {
        //
        // More Entry, set the Status 
        // 
        if (MoreEntries)
        {
            Status = STATUS_MORE_ENTRIES;
        }
        
        
        (*Buffer)->EntriesRead = *CountReturned;
        (*Buffer)->Buffer = RidEnumerationList;
    }

    //
    // End Any DS transactions
    //

    SampMaybeEndDsTransaction(TransactionCommit);

    //
    // Free starting and ending SIDs
    //

    if (StartingSid)
        MIDL_user_free(StartingSid);

    if (EndingSid)
        MIDL_user_free(EndingSid);


    return Status;
}


NTSTATUS
SampPackDsEnumerationResults(
    IN  PSID        DomainPrefix,
    IN  BOOLEAN     BuiltinDomain,
    IN  SEARCHRES   *SearchRes,
    IN  SAMP_OBJECT_TYPE ObjectType,
    IN  ULONG       ExpectedAttrCount,
    IN  ULONG       Filter,
    OUT ULONG       * Count,
    OUT PSAMPR_RID_ENUMERATION  *RidEnumerationList
    )
/*++

  Routine Description:

    This routine Packs the complex structures 
    returned by the core DS, into the Rid Enumeration 
    Structures required by SAM.

  Arguments:

        DomainPrefix The SID of the domain in question. 

        SearchRes SearchRes strucure as obtained from the DS.

        ExpectedAttrCount -- Passed by the caller. This is the count
                  of Attrs which the caller expects from the SearchRes
                  on a per search entry basis. Used to validate results
                  from the DS.

        Filter    For User Accounts bits of the AccountControlId.

        Count     Returned Count of Structures.

        RidEnumerationList - Array of structures of type 
                    SAMP_RID_ENUMERATION passed back in this.


--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    PSAMPR_RID_ENUMERATION  RidEnumerationListToReturn = NULL;
    ULONG       FilteredCount = 0;

    //
    // Initialize what we plan to return.
    //
    *RidEnumerationList = NULL;
    *Count = 0;

    //
    //  Look if search turned up any results.
    //  If so stuff them in Rid Enumeration Array ( or whatever )
    //
    if (SearchRes->count)
    {
        //
        // Search Did Turn up Results
        //

        ULONG Index;
        ENTINFLIST * CurrentEntInf;
        PSID        ReturnedSid;

        //
        // Allocate memory for an array of Rid Enumerations
        //
        RidEnumerationListToReturn = MIDL_user_allocate(
                                    SearchRes->count 
                                      * sizeof(SAMPR_RID_ENUMERATION)
                                    );
        if (NULL==RidEnumerationListToReturn)
        {
            Status = STATUS_NO_MEMORY;
            goto Error;
        }

        //
        // Zero Memory just what we alloced. Useful for freeing up stuff
        // in case we error'd out
        //
        RtlZeroMemory(RidEnumerationListToReturn,SearchRes->count 
                                      * sizeof(SAMPR_RID_ENUMERATION)
                                      );

        //
        // Walk through the List turned up by the search and 
        // build the RidEnumeration Buffer    
        //
        for (CurrentEntInf = &(SearchRes->FirstEntInf);
                CurrentEntInf!=NULL;
                    CurrentEntInf=CurrentEntInf->pNextEntInf)
        {
          PSID   DomainSid = NULL;

          if (CurrentEntInf->Entinf.AttrBlock.attrCount!=
                    ExpectedAttrCount)
          {
              //
              // Fails the access check executed by core DS
              // skip this entry.
              continue;
          }

          //
          // Assert that the Rid is in the right place,
          // Remember the DS will return us a SID.
          //

          ASSERT(CurrentEntInf->Entinf.AttrBlock.pAttr[0].attrTyp ==
                    SampDsAttrFromSamAttr(SampUnknownObjectType, 
                        SAMP_UNKNOWN_OBJECTSID));
          //
          // Assert that  the Name is in the right place
          //

          ASSERT(CurrentEntInf->Entinf.AttrBlock.pAttr[1].attrTyp ==
                    SampDsAttrFromSamAttr(SampUnknownObjectType, 
                        SAMP_UNKNOWN_OBJECTNAME));

          if (ObjectType == SampUserObjectType)
          {

              //
              // For User objects we need to filter based on account-control
              // field
              //

              ULONG     AccountControlValue;
              NTSTATUS  IgnoreStatus;
              //
              // Assert that the Account control is in the right place
              //

              ASSERT(CurrentEntInf->Entinf.AttrBlock.pAttr[2].attrTyp ==
                      SampDsAttrFromSamAttr(SampUserObjectType, 
                           SAMP_FIXED_USER_ACCOUNT_CONTROL));

              //
              // Get account control value and skip past if does
              // not match the filter criteria. Remember DS stores
              // Flags, so transalate it to account control
              // Using BIT wise OR logic
              //

              IgnoreStatus = SampFlagsToAccountControl(
                                *((ULONG *)(CurrentEntInf->Entinf.AttrBlock.
                                    pAttr[2].AttrVal.pAVal[0].pVal)),
                                    &AccountControlValue);

              ASSERT(NT_SUCCESS(IgnoreStatus));

              if ((Filter!=0) && 
                    ((Filter & AccountControlValue) == 0))
              {
                    //
                    // Fails the Filter Test, skip this one
                    //

                    continue;
              }

          }

          //
          // Stuff this entry in the buffer to be returned.
          //

          //
          // Copy the RID, Remember DS returns us a SID, so get the Rid Part out
          //

          
          ReturnedSid = CurrentEntInf->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal;
          Status = SampSplitSid(
                        ReturnedSid,
                        &DomainSid,
                        &(RidEnumerationListToReturn[FilteredCount].RelativeId)
                        );
          if (!NT_SUCCESS(Status))
          {
              goto Error;
          }


          // 
          // Case 1. For Account Domain 
          // Since we provide StartSid and EndSid to core DS core, 
          // they should not return any objects which belong to 
          // another domain. No need to check the Domain SID
          //
          // Case 2. For Builtin Domain 
          // Did not set SID index range, so still need to 
          // Compare Domain SID for any enumeration in Builtin Domain
          // 
          if (BuiltinDomain)
          {
              if (!RtlEqualSid(DomainSid, DomainPrefix))
              {
                  // 
                  // Sids are not the same, filter this account out
                  // 

                  MIDL_user_free(DomainSid);
                  DomainSid = NULL;
                  continue;
              }
          }

#if DBG
          else      // Account Domain
          {
              if (!RtlEqualSid(DomainSid, DomainPrefix))
              {
                  ASSERT(FALSE && "Account is not in Account Domain");
                  MIDL_user_free(DomainSid);
                  DomainSid = NULL;
                  continue;
              }

          }
#endif // DBG


          //
          // Free the Domain Sid, got from SampSplitSid
          //

          MIDL_user_free(DomainSid);
          DomainSid = NULL;

          //
          // Copy the Name
          //

          RidEnumerationListToReturn[FilteredCount].Name.Length = (USHORT)
                  (CurrentEntInf->Entinf.AttrBlock.pAttr[1].AttrVal.
                        pAVal[0].valLen);
          RidEnumerationListToReturn[FilteredCount].Name.MaximumLength = (USHORT) 
                  (CurrentEntInf->Entinf.AttrBlock.pAttr[1].AttrVal.
                        pAVal[0].valLen);

          
          RidEnumerationListToReturn[FilteredCount].Name.Buffer =  
                  MIDL_user_allocate(CurrentEntInf->Entinf.AttrBlock.pAttr[1].
                                            AttrVal.pAVal[0].valLen);

          if (NULL== (RidEnumerationListToReturn[FilteredCount]).Name.Buffer)
          {
              Status = STATUS_NO_MEMORY;
              goto Error;
          }
          
          RtlCopyMemory( RidEnumerationListToReturn[FilteredCount].Name.Buffer,
                         CurrentEntInf->Entinf.AttrBlock.pAttr[1].AttrVal.
                                    pAVal[0].pVal,
                         CurrentEntInf->Entinf.AttrBlock.pAttr[1].AttrVal.
                                    pAVal[0].valLen
                        );

          //
          // Increment the Count
          //

          FilteredCount++;

        }

        //
        // End of For Loop
        //    
        
        // 
        // if we filter all the entries out. need to release the allocated memory  
        // 
        
        if (0 == FilteredCount)
        {
            MIDL_user_free(RidEnumerationListToReturn);
            RidEnumerationListToReturn = NULL;
        }
        
    }
    //
    // Fill in the count and return buffer correctly
    //

    *Count = FilteredCount;
    *RidEnumerationList = RidEnumerationListToReturn;


Error:

    if (!NT_SUCCESS(Status))
    {
        //
        // We Errored out, need to free all that we allocated
        //

        if (NULL!=RidEnumerationListToReturn)
        {
            //
            // We did allocate something
            //

            ULONG Index;

            //
            // First free all possible Names that we alloc'ed.
            //

            for (Index=0;Index<SearchRes->count;Index++)
            {
                if (RidEnumerationListToReturn[Index].Name.Buffer)
                    MIDL_user_free(
                        RidEnumerationListToReturn[Index].Name.Buffer);
            }

            //
            // Free the buffer that we alloc'ed
            //

            MIDL_user_free(RidEnumerationListToReturn);
            RidEnumerationListToReturn = NULL;
            *RidEnumerationList = NULL;
        }
    }

    return Status;

}



NTSTATUS
SampGetLastEntryRidAndAccountControl(
    IN  SEARCHRES * SearchRes, 
    IN  SAMP_OBJECT_TYPE ObjectType,
    IN  ULONG     ExpectedAttrCount,
    OUT ULONG     * Rid,
    OUT ULONG     * LastAccountControlValue
    )
/*++
Routine Description:

    This routine scans the search results, finds the last qualified entry (with all 
    expected attributes), returns its RID and AccountControl if applicable (for User 
    Object)
    
Parameters:

    SearchRes -- Pointer to Search Results, returned by core DS
    
    ObjectType -- Specify client desired object.
    
    ExpectedAttrCount -- Used to exam each entry in search results, since DS access
                         check may not return all attributes we asked for.
                         
    Rid -- Used to return last entry's (with all expected attributes) Relative ID
    
    LastAccountControlValue -- Return last entry's AccountControl if applicable 
                               (User object only). For other object, 
                               LastAccountControlValue is useless.
    
    
Return Value:

    STATUS_SUCCESS
    STATUS_NO_MEMORY
    
--*/    
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ENTINFLIST  * CurrentEntInf = NULL;
    ENTINFLIST  * NextEntInf = NULL;
    ENTINFLIST  * LastQualifiedEntInf = NULL;
    PSID        DomainSid = NULL;
    PSID        ReturnedSid = NULL;
    
    //
    // Initialize what we plan to return 
    //     
    
    *Rid = 0;
    *LastAccountControlValue = 0;
    
    //
    // this routine is only called when we have more entried to look
    // into. So that means we have at least one entry in this search 
    // result.
    // 
    
    ASSERT(SearchRes->count);
    
    if (SearchRes->count)
    {
        //
        // Locate the last entry  
        // 
        
        NextEntInf = &(SearchRes->FirstEntInf);
        
        do
        {
            CurrentEntInf = NextEntInf;
            NextEntInf = CurrentEntInf->pNextEntInf;
            
            //
            // Find the last entry with all expected attributes
            // This logic is linked with SampPackDsEnumerationResults() when
            // we filter the DS returned entries. 
            //
            // Actually, at here we only care about RID and AccountControl 
            //
            
            if (CurrentEntInf->Entinf.AttrBlock.attrCount == 
                    ExpectedAttrCount)
            {
                LastQualifiedEntInf = CurrentEntInf;
            }
        
        } while (NULL != NextEntInf);
        
        
        //
        // LastQualifiedEntInf points to the entry with all expected attributes. 
        // if it's NULL, it means none of the returned entries should be 
        // exposed to client. Thus Rid and LastAccountControlValue left to be 0 
        //   
        
        if (NULL != LastQualifiedEntInf)
        {
            // 
            // Get AccountControl for User Object
            //
        
            if (SampUserObjectType == ObjectType)
            {
                NTSTATUS    IgnoreStatus;
            
                //
                // Assert that the Account Control is in the right place 
                // 
            
                ASSERT(LastQualifiedEntInf->Entinf.AttrBlock.pAttr[2].attrTyp ==
                        SampDsAttrFromSamAttr(SampUserObjectType, 
                                              SAMP_FIXED_USER_ACCOUNT_CONTROL));
                                          
                // 
                // Get the account control value, need to map the DS flag to SAM 
                // account control.                                   
                //
            
                IgnoreStatus = SampFlagsToAccountControl(
                                  *((ULONG *)(LastQualifiedEntInf->Entinf.AttrBlock.
                                      pAttr[2].AttrVal.pAVal[0].pVal)), 
                                      LastAccountControlValue);
                                  
                ASSERT(NT_SUCCESS(IgnoreStatus));
            
            }
        
            // 
            // Assert that the SID is in the right place
            // DS will return us SID instead of RID 
            //  
        
            ASSERT(LastQualifiedEntInf->Entinf.AttrBlock.pAttr[0].attrTyp ==
                      SampDsAttrFromSamAttr(SampUnknownObjectType, 
                          SAMP_UNKNOWN_OBJECTSID));
                      
                      
            ReturnedSid = LastQualifiedEntInf->Entinf.AttrBlock.pAttr[0].AttrVal.pAVal[0].pVal;
                      
            Status = SampSplitSid(ReturnedSid, 
                                  &DomainSid, 
                                  Rid
                                  );
        }                              
    }
    
    if (NULL != DomainSid)
    {
        MIDL_user_free(DomainSid);
    }
    
    return Status;
}



NTSTATUS
SampDoDsSearchContinuation(
    IN  SEARCHRES * SearchRes,
    IN OUT PULONG EnumerationContext,
    IN  BOOLEAN   CanEnumerateEntireDomain,
    OUT BOOLEAN * MoreEntries
    )
/*++
    Routine Description

        This routine will look if a PagedResults is present in
        the Search Res argument that is passed in. If so, then it
        will Try creating and EnumerationContext if NULL was passed
        in the handle. Else it will free the old restart structure 
        from the Enumeration Context and copy in the new one passed
        by the DS.

  Arguments:
        SearchRes - Pointer to Search Results structure returned by
                    the DS.

        EnumerationContext - Holds a pointer to the enumeration Context
                            Structure

        MoreEntries - Inidicates that more entries are present.

  Return Values:

        STATUS_SUCCESS
        STATUS_NO_MEMORY


-*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
  

    //
    // Initialize this to False
    //

    *MoreEntries = FALSE;

    //
    // Now look at the Paged Results part of Search Results
    // And create enumeration contexts as necessary.
    //

    if ((SearchRes->PagedResult.fPresent) 
         && (SearchRes->PagedResult.pRestart) 
         && CanEnumerateEntireDomain
         )
    {
        
        //
        // Search has more entries to it and therefore retrned
        // a restart structure
        //

        *MoreEntries = TRUE;

    }
    else
    {
        //
        // Search is Over, DS did not indicate that we have to come 
        // back for more entries. Free any state information that we
        // created for this search
        //

       *EnumerationContext = 0;
    }

    return Status;
        



}
 
NTSTATUS
SampBuildDsEnumerationFilter(
    IN SAMP_OBJECT_TYPE  ObjectType,
    IN ULONG             UserAccountControlFilter,
    OUT FILTER         * DsFilter,
    OUT PULONG           SamAccountTypeLo,
    OUT PULONG           SamAccountTypeHi
    )
/*++

  Routine Description:

        Builds a Filter structure for use in enumeration operations.

  Arguments:

        ObjectType - Type of SAM objects we want enumerated
        UserAcountControlFilter - Bitmaks of bits to be set in Account Control field
                                  when enumerating user objects
        DsFilter    -- Filter structure is built in here.

            NOTE This routine must be kept in sync with 
            SampFreeDsEnumerationFilter

    Return Values

        STATUS_SUCCESS
        STATUS_NO_MEMORY

--*/
{
   
    NTSTATUS    Status = STATUS_SUCCESS;
    PULONG      FilterValue = NULL;

    //
    // Initialize the defaults for the filter
    //

    DsFilter->choice = FILTER_CHOICE_ITEM;
    DsFilter->FilterTypes.Item.choice = FI_CHOICE_EQUALITY;
    DsFilter->FilterTypes.
        Item.FilTypes.ava.type = SampDsAttrFromSamAttr(
                                    SampUnknownObjectType, 
                                    SAMP_UNKNOWN_ACCOUNT_TYPE
                                    );

    DsFilter->FilterTypes.Item.FilTypes.ava.Value.valLen = sizeof(ULONG);
    
    FilterValue = MIDL_user_allocate(sizeof(ULONG));
    if (NULL==FilterValue)
    {
        Status = STATUS_NO_MEMORY;
        goto Error;
    }

    DsFilter->FilterTypes.Item.FilTypes.ava.Value.pVal =  (UCHAR *)FilterValue;

    //
    // Build the Appropriate Filter by ovewrting the defaults
    //

    switch(ObjectType)
    {
    case SampUserObjectType:

        if (UserAccountControlFilter!=0)
        {
            //
            // Filtering on Account control field  is Specified
            //
            // There are 4 cases
            //
            //     1. Client wants machine accounts
            //     2. Client wants inter-domain trust accounts
            //     3. Client wants normal user accounts
            //     4. Client wants some arbitary bits

            if ((USER_WORKSTATION_TRUST_ACCOUNT == UserAccountControlFilter)
                || (USER_SERVER_TRUST_ACCOUNT == UserAccountControlFilter))
            {
                //
                // Case1 machine accounts are needed
                //

                *SamAccountTypeLo = SAM_MACHINE_ACCOUNT;
                *SamAccountTypeHi = SAM_MACHINE_ACCOUNT;
                *FilterValue = SAM_MACHINE_ACCOUNT;
            }
            else if (USER_INTERDOMAIN_TRUST_ACCOUNT == UserAccountControlFilter)
            {
                //
                // Case2 inter-domain trust accounts
                // 
                *SamAccountTypeLo = SAM_TRUST_ACCOUNT;
                *SamAccountTypeHi = SAM_TRUST_ACCOUNT;
                *FilterValue = SAM_TRUST_ACCOUNT;
            }
            else if ((USER_NORMAL_ACCOUNT == UserAccountControlFilter) ||
                     (USER_TEMP_DUPLICATE_ACCOUNT == UserAccountControlFilter))
            {
                //
                // Case3 normal user accounts
                // 
                *SamAccountTypeLo = SAM_NORMAL_USER_ACCOUNT;
                *SamAccountTypeHi = SAM_NORMAL_USER_ACCOUNT;
                *FilterValue = SAM_NORMAL_USER_ACCOUNT;
            }
            else
            {
                     
                //
                // Case4 arbitary bits
                //

                ULONG   AccountType;
                AccountType = UserAccountControlFilter & USER_ACCOUNT_TYPE_MASK;

                if ((AccountType == USER_TEMP_DUPLICATE_ACCOUNT) ||
                    (AccountType == USER_NORMAL_ACCOUNT) ||
                    (AccountType == USER_INTERDOMAIN_TRUST_ACCOUNT) ||
                    (AccountType == USER_WORKSTATION_TRUST_ACCOUNT) ||
                    (AccountType == USER_SERVER_TRUST_ACCOUNT) )
                {
                    //
                    // Case4.1 Only one Account Type is specified.
                    // 
                    DsFilter->FilterTypes.Item.choice = FI_CHOICE_BIT_OR;
                    DsFilter->FilterTypes.
                        Item.FilTypes.ava.type = SampDsAttrFromSamAttr(
                                                    SampUserObjectType, 
                                                    SAMP_FIXED_USER_ACCOUNT_CONTROL
                                                    );

                    // Remember DS uses Flags, instead of Account Control. So Translate
                    // to Flags
                    *FilterValue = SampAccountControlToFlags(UserAccountControlFilter);
            
                    //
                    // Index ranges on Sam account type will also be set intelligently
                    // depending upon bits present in the user account control field
                    //
                    if  ((USER_WORKSTATION_TRUST_ACCOUNT & UserAccountControlFilter)
                    || (USER_SERVER_TRUST_ACCOUNT & UserAccountControlFilter))
                    {
                        *SamAccountTypeLo = SAM_MACHINE_ACCOUNT;
                        *SamAccountTypeHi = SAM_MACHINE_ACCOUNT;
                    }
                    else if (USER_INTERDOMAIN_TRUST_ACCOUNT & UserAccountControlFilter)
                    {
                        *SamAccountTypeLo = SAM_TRUST_ACCOUNT;
                        *SamAccountTypeHi = SAM_TRUST_ACCOUNT;
                    }
                    else 
                    {       
                        *SamAccountTypeLo = SAM_NORMAL_USER_ACCOUNT;
                        *SamAccountTypeHi = SAM_NORMAL_USER_ACCOUNT;
                    }
                }
                else
                {
                    //
                    // Case4.2 Multiple Account Types are desired.
                    //         Do not use DS Filter
                    // 
                    DsFilter->FilterTypes.Item.choice = FI_CHOICE_TRUE;
                    *SamAccountTypeLo = SAM_NORMAL_USER_ACCOUNT;
                    *SamAccountTypeHi = SAM_ACCOUNT_TYPE_MAX; 
                }
            }
        }
        else
        {
            //
            //   Non User Account Control filter case
            //
            *SamAccountTypeLo = SAM_NORMAL_USER_ACCOUNT;
            *SamAccountTypeHi = SAM_ACCOUNT_TYPE_MAX;
            *FilterValue = SAM_NORMAL_USER_ACCOUNT;
            DsFilter->FilterTypes.Item.choice = FI_CHOICE_GREATER_OR_EQ;
        }

        break;

    case SampGroupObjectType:
        *SamAccountTypeLo = SAM_GROUP_OBJECT;
        *SamAccountTypeHi = SAM_GROUP_OBJECT;
        *FilterValue = SAM_GROUP_OBJECT;
        break;

    case SampAliasObjectType:
        *SamAccountTypeLo = SAM_ALIAS_OBJECT;
        *SamAccountTypeHi = SAM_ALIAS_OBJECT;
        *FilterValue = SAM_ALIAS_OBJECT;
        break;

    default:
                            
        ASSERT(FALSE && "Invalid Object Type Specified");
        Status = STATUS_INTERNAL_ERROR;
    }

Error:
    return Status;

}


VOID
SampFreeDsEnumerationFilter(
    FILTER * DsFilter
    )
/*++

  Routine Description:

        This routine frees a DS Filter as built by SampBuildDsEnumerationFilter

  NOTE: This routine must be kept in sync with SampBuildDsEnumerationFilter

  Argumements:
    
      DsFilter  -- Pointer to a DS Filter Structure

  --*/
{
    //
    // For Now, Hopefully forever, our filters do not have anything hanging
    // of them
    //

    MIDL_user_free(DsFilter->FilterTypes.Item.FilTypes.ava.Value.pVal);

}



NTSTATUS
SampEnumerateAccountNamesRegistry(
    IN SAMP_OBJECT_TYPE ObjectType,
    IN OUT PSAM_ENUMERATE_HANDLE EnumerationContext,
    OUT PSAMPR_ENUMERATION_BUFFER *Buffer,
    IN ULONG PreferedMaximumLength,
    IN ULONG Filter,
    OUT PULONG CountReturned,
    IN BOOLEAN TrustedClient
    )

/*++

Routine Description:

    This is the worker routine used to enumerate user, group or alias accounts


    Note:  THIS ROUTINE REFERENCES THE CURRENT TRANSACTION DOMAIN
           (ESTABLISHED USING SampSetTransactioDomain()).  THIS
           SERVICE MAY ONLY BE CALLED AFTER SampSetTransactionDomain()
           AND BEFORE SampReleaseReadLock().



    All allocation for OUT parameters will be done using MIDL_user_allocate.



Arguments:

    ObjectType - Indicates whether users or groups are to be enumerated.

    EnumerationContext - API specific handle to allow multiple calls.  The
        caller should return this value in successive calls to retrieve
        additional information.

    Buffer - Receives a pointer to the buffer containing the
        requested information.  The information returned is
        structured as an array of SAM_ENUMERATION_INFORMATION data
        structures.  When this information is no longer needed, the
        buffer must be freed using SamFreeMemory().

    PreferedMaximumLength - Prefered maximum length of returned data
        (in 8-bit bytes).  This is not a hard upper limit, but serves
        as a guide to the server.  Due to data conversion between
        systems with different natural data sizes, the actual amount
        of data returned may be greater than this value.

    Filter - if ObjectType is users, the users can optionally be filtered
        by setting this field with bits from the AccountControlField that
        must match.  Otherwise ignored.

    CountReturned - Receives the number of entries returned.

    TrustedClient - says whether the caller is trusted or not.  If so,
        we'll ignore the SAMP_MAXIMUM_MEMORY_TO_USE restriction on data
        returns.


Return Value:

    STATUS_SUCCESS - The Service completed successfully, and there
        are no additional entries.  Entries may or may not have been
        returned from this call.  The CountReturned parameter indicates
        whether any were.

    STATUS_MORE_ENTRIES - There are more entries which may be obtained
        using successive calls to this API.  This is a successful return.

    STATUS_ACCESS_DENIED - Caller does not have access to request the data.


--*/
{
    SAMP_V1_0A_FIXED_LENGTH_USER   UserV1aFixed;
    NTSTATUS                    NtStatus, TmpStatus;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    HANDLE                      TempHandle = NULL;
    ULONG                       i, NamesToReturn = 0, MaxMemoryToUse;
    ULONG                       TotalLength,NewTotalLength;
    PSAMP_OBJECT                UserContext = NULL;
    PSAMP_ENUMERATION_ELEMENT   SampHead = NULL,
                                NextEntry = NULL,
                                NewEntry = NULL,
                                SampTail = NULL;
    BOOLEAN                     MoreNames = FALSE;
    BOOLEAN                     LengthLimitReached = FALSE;
    BOOLEAN                     FilteredName;
    PSAMPR_RID_ENUMERATION      ArrayBuffer = NULL;
    ULONG                       ArrayBufferLength;
    LARGE_INTEGER               IgnoreLastWriteTime;
    UNICODE_STRING              AccountNamesKey;
    SID_NAME_USE                IgnoreUse;

    SAMTRACE("SampEnumerateAccountNames");


    //
    // Open the registry key containing the account names
    //

    NtStatus = SampBuildAccountKeyName(
                   ObjectType,
                   &AccountNamesKey,
                   NULL
                   );

    if ( NT_SUCCESS(NtStatus) ) {

        //
        // Now try to open this registry key so we can enumerate its
        // sub-keys
        //


        InitializeObjectAttributes(
            &ObjectAttributes,
            &AccountNamesKey,
            OBJ_CASE_INSENSITIVE,
            SampKey,
            NULL
            );

        SampDumpNtOpenKey((KEY_READ), &ObjectAttributes, 0);

        NtStatus = RtlpNtOpenKey(
                       &TempHandle,
                       (KEY_READ),
                       &ObjectAttributes,
                       0
                       );

        if (NT_SUCCESS(NtStatus)) {

            //
            // Read names until we have exceeded the preferred maximum
            // length or we run out of names.
            //

            NamesToReturn = 0;
            SampHead      = NULL;
            SampTail      = NULL;
            MoreNames     = TRUE;

            NewTotalLength = 0;
            TotalLength    = 0;

            if ( TrustedClient ) {

                //
                // We place no restrictions on the amount of memory used
                // by a trusted client.  Rely on their
                // PreferedMaximumLength to limit us instead.
                //

                MaxMemoryToUse = 0xffffffff;

            } else {

                MaxMemoryToUse = SAMP_MAXIMUM_MEMORY_TO_USE;
            }

            while (MoreNames) {

                UNICODE_STRING SubKeyName;
                USHORT LengthRequired;

                //
                // Try reading with a DEFAULT length buffer first.
                //

                LengthRequired = 32;

                NewTotalLength = TotalLength +
                                 sizeof(UNICODE_STRING) +
                                 LengthRequired;

                //
                // Stop if SAM or user specified length limit reached
                //

                if ( ( (TotalLength != 0) &&
                       (NewTotalLength  >= PreferedMaximumLength) ) ||
                     ( NewTotalLength  > MaxMemoryToUse )
                   ) {

                    NtStatus = STATUS_SUCCESS;
                    break; // Out of while loop, MoreNames = TRUE
                }

                NtStatus = SampInitUnicodeString(&SubKeyName, LengthRequired);
                if (!NT_SUCCESS(NtStatus)) {
                    break; // Out of while loop
                }

                NtStatus = RtlpNtEnumerateSubKey(
                               TempHandle,
                               &SubKeyName,
                               *EnumerationContext,
                               &IgnoreLastWriteTime
                               );

                SampDumpRtlpNtEnumerateSubKey(&SubKeyName,
                                              EnumerationContext,
                                              IgnoreLastWriteTime);

                if (NtStatus == STATUS_BUFFER_OVERFLOW) {

                    //
                    // The subkey name is longer than our default size,
                    // Free the old buffer.
                    // Allocate the correct size buffer and read it again.
                    //

                    SampFreeUnicodeString(&SubKeyName);

                    LengthRequired = SubKeyName.Length;

                    NewTotalLength = TotalLength +
                                     sizeof(UNICODE_STRING) +
                                     LengthRequired;

                    //
                    // Stop if SAM or user specified length limit reached
                    //

                    if ( ( (TotalLength != 0) &&
                           (NewTotalLength  >= PreferedMaximumLength) ) ||
                         ( NewTotalLength  > MaxMemoryToUse )
                       ) {

                        NtStatus = STATUS_SUCCESS;
                        break; // Out of while loop, MoreNames = TRUE
                    }

                    //
                    // Try reading the name again, we should be successful.
                    //

                    NtStatus = SampInitUnicodeString(&SubKeyName, LengthRequired);
                    if (!NT_SUCCESS(NtStatus)) {
                        break; // Out of while loop
                    }

                    NtStatus = RtlpNtEnumerateSubKey(
                                   TempHandle,
                                   &SubKeyName,
                                   *EnumerationContext,
                                   &IgnoreLastWriteTime
                                   );

                    SampDumpRtlpNtEnumerateSubKey(&SubKeyName,
                                                  EnumerationContext,
                                                  IgnoreLastWriteTime);

                }


                //
                // Free up our buffer if we failed to read the key data
                //

                if (!NT_SUCCESS(NtStatus)) {

                    SampFreeUnicodeString(&SubKeyName);

                    //
                    // Map a no-more-entries status to success
                    //

                    if (NtStatus == STATUS_NO_MORE_ENTRIES) {

                        MoreNames = FALSE;
                        NtStatus  = STATUS_SUCCESS;
                    }

                    break; // Out of while loop
                }

                //
                // We've allocated the subkey and read the data into it
                // Stuff it in an enumeration element.
                //

                NewEntry = MIDL_user_allocate(sizeof(SAMP_ENUMERATION_ELEMENT));
                if (NewEntry == NULL) {
                    NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                } else {

                    *(PUNICODE_STRING)&NewEntry->Entry.Name = SubKeyName;

                    //
                    // Now get the Rid value of this named
                    // account.  We must be able to get the
                    // name or we have an internal database
                    // corruption.
                    //

                    NtStatus = SampLookupAccountRidRegistry(
                                   ObjectType,
                                   (PUNICODE_STRING)&NewEntry->Entry.Name,
                                   STATUS_INTERNAL_DB_CORRUPTION,
                                   &NewEntry->Entry.RelativeId,
                                   &IgnoreUse
                                   );

                    ASSERT(NtStatus != STATUS_INTERNAL_DB_CORRUPTION);

                    if (NT_SUCCESS(NtStatus)) {

                        FilteredName = TRUE;

                        if ( ( ObjectType == SampUserObjectType ) &&
                            ( Filter != 0 ) ) {

                            //
                            // We only want to return users with a
                            // UserAccountControl field that matches
                            // the filter passed in.  Check here.
                            //

                            NtStatus = SampCreateAccountContext(
                                           SampUserObjectType,
                                           NewEntry->Entry.RelativeId,
                                           TRUE, // Trusted client
                                           FALSE,
                                           TRUE, // Account exists
                                           &UserContext
                                           );

                            if ( NT_SUCCESS( NtStatus ) ) {

                                NtStatus = SampRetrieveUserV1aFixed(
                                               UserContext,
                                               &UserV1aFixed
                                               );

                                if ( NT_SUCCESS( NtStatus ) ) {

                                    if ( ( UserV1aFixed.UserAccountControl &
                                        Filter ) == 0 ) {

                                        FilteredName = FALSE;
                                        SampFreeUnicodeString( &SubKeyName );
                                    }
                                }

                                SampDeleteContext( UserContext );
                            }
                        }

                        *EnumerationContext += 1;

                        if ( NT_SUCCESS( NtStatus ) && ( FilteredName ) ) {

                            NamesToReturn += 1;

                            TotalLength = TotalLength + (ULONG)
                                          NewEntry->Entry.Name.MaximumLength;

                            NewEntry->Next = NULL;

                            if( SampHead == NULL ) {

                                ASSERT( SampTail == NULL );

                                SampHead = SampTail = NewEntry;
                            }
                            else {

                                //
                                // add this new entry to the list end.
                                //

                                SampTail->Next = NewEntry;
                                SampTail = NewEntry;
                            }

                        } else {

                            //
                            // Entry was filtered out, or error getting
                            // filter information.
                            //

                            MIDL_user_free( NewEntry );
                        }

                    } else {

                        //
                        // Error looking up the RID
                        //

                        MIDL_user_free( NewEntry );
                    }
                }


                //
                // Free up our subkey name
                //

                if (!NT_SUCCESS(NtStatus)) {

                    SampFreeUnicodeString(&SubKeyName);
                    break; // Out of whle loop
                }

            } // while



            TmpStatus = NtClose( TempHandle );
            ASSERT( NT_SUCCESS(TmpStatus) );

        }


        SampFreeUnicodeString( &AccountNamesKey );
    }




    if ( NT_SUCCESS(NtStatus) ) {




        //
        // If we are returning the last of the names, then change our
        // enumeration context so that it starts at the beginning again.
        //

        if (!( (NtStatus == STATUS_SUCCESS) && (MoreNames == FALSE))) {

            NtStatus = STATUS_MORE_ENTRIES;
        }



        //
        // Set the number of names being returned
        //

        (*CountReturned) = NamesToReturn;


        //
        // Build a return buffer containing an array of the
        // SAM_ENUMERATION_INFORMATIONs pointed to by another
        // buffer containing the number of elements in that
        // array.
        //

        (*Buffer) = MIDL_user_allocate( sizeof(SAMPR_ENUMERATION_BUFFER) );

        if ( (*Buffer) == NULL) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        } else {

            (*Buffer)->EntriesRead = (*CountReturned);

            ArrayBufferLength = sizeof( SAM_RID_ENUMERATION ) *
                                 (*CountReturned);
            ArrayBuffer  = MIDL_user_allocate( ArrayBufferLength );
            (*Buffer)->Buffer = ArrayBuffer;

            if ( ArrayBuffer == NULL) {

                NtStatus = STATUS_INSUFFICIENT_RESOURCES;
                MIDL_user_free( (*Buffer) );

            }   else {

                //
                // Walk the list of return entries, copying
                // them into the return buffer
                //

                NextEntry = SampHead;
                i = 0;
                while (NextEntry != NULL) {

                    NewEntry = NextEntry;
                    NextEntry = NewEntry->Next;

                    ArrayBuffer[i] = NewEntry->Entry;
                    i += 1;

                    MIDL_user_free( NewEntry );
                }

            }

        }



    }

    if ( !NT_SUCCESS(NtStatus) ) {

        //
        // Free the memory we've allocated
        //

        NextEntry = SampHead;
        while (NextEntry != NULL) {

            NewEntry = NextEntry;
            NextEntry = NewEntry->Next;

            if (NewEntry->Entry.Name.Buffer != NULL ) MIDL_user_free( NewEntry->Entry.Name.Buffer );
            MIDL_user_free( NewEntry );
        }

        (*EnumerationContext) = 0;
        (*CountReturned)      = 0;
        (*Buffer)             = NULL;

    }

    return(NtStatus);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\global.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    global.c

Abstract:

    This file contains global variables for the SAM server program.

    Note: There are also some global variables in the files generated
          by the RPC midl compiler.  These variables start with the
          prefix "samr_".

Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:

    08-Oct-1996 ChrisMay
        Added global flag SampUseDsData for crash recovery.

--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Global variables                                                          //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////



#if SAMP_DIAGNOSTICS
//
// SAM Global Controls - see flags in samsrvp.h
//

ULONG SampGlobalFlag = 0;
#endif //SAMP_DIAGNOSTICS


//
// Internal data structure and Registry database synchronization lock
//
// The SampTransactionWithinDomainGlobal field is used to track whether a
// lock held for exclusive WRITE access is for a transaction within
// a single domain.  If so, then SampTransactionDomainIndex contains
// the index into SampDefinedDomains of the domain being modified.
//

RTL_RESOURCE SampLock;
BOOLEAN SampTransactionWithinDomainGlobal;
ULONG SampTransactionDomainIndexGlobal;


//
// This critical section is used to protect SampContextListHead (double link list) - active context list
// 

RTL_CRITICAL_SECTION    SampContextListCritSect;

//
// This critical section is used to protect SampAccounttNameTable
// 

RTL_CRITICAL_SECTION    SampAccountNameTableCriticalSection;
PRTL_CRITICAL_SECTION   SampAccountNameTableCritSect;


RTL_GENERIC_TABLE2      SampAccountNameTable;

//
// Set limit on number of contexts a non-trusted client can open
// 

RTL_GENERIC_TABLE2      SampActiveContextTable;

//
// The type of product this SAM server is running in
//

NT_PRODUCT_TYPE SampProductType;

//
// SampUseDsData is TRUE whenever SAM reads or writes data from/to the
// directory service. It is set to FALSE whenever the data resides in the
// registry. Under normal operation, a domain controller always references
// data in the DS, while workstations and member servers reference data
// in the registry. Additionally, in the event of a DS failure (such as
// a problem starting or accessing the DS), a DC will fall back to using
// the registry in order to allow an administrator to logon and repair the
// DS.
//

BOOLEAN SampUseDsData = FALSE;

//
// SampRidManager Initialized is used to keep track of the state of
// the Rid manager. When the Rid manager has been successfully initilized
// this variable is set to true. Else it is set to false
//
BOOLEAN SampRidManagerInitialized = FALSE;


//
// Used to indicate whether the SAM service is currently processing
// normal client calls.  If not, then trusted client calls will still
// be processed, but non-trusted client calls will be rejected.
//

//
// SAM Service operation states.
// Valid state transition diagram is:
//
//    Initializing ----> Enabled <====> Disabled ---> Shutdown -->Terminating
//                               <====> Demoted  ---> Shutdown -->Terminating
//
// Explicitly initialize it to 0 (none of the above values, the valid value
// start from 1).
// 


SAMP_SERVICE_STATE SampServiceState = 0;


//
// This boolean is set to TRUE if the LSA auditing policy indicates
// account auditing is enabled.  Otherwise, this will be FALSE.
//
// This enables SAM to skip all auditing processing unless auditing
// is currently enabled.
//

BOOLEAN SampSuccessAccountAuditingEnabled;
BOOLEAN SampFailureAccountAuditingEnabled;


//
// This is a handle to the root of the SAM backstore information in the
// registry.   This is the level at which the RXACT information is
// established.  This key can not be closed if there are any SERVER object
// context blocks active.
// ("SAM")
//

HANDLE SampKey;


//
// This is the pointer to the RXactContext structure that will be created
// when RXact is initialized.  It must be passed into each RXact call.
//

PRTL_RXACT_CONTEXT SampRXactContext;


//
// Keep a list of server and domain contexts
//

LIST_ENTRY SampContextListHead;

//
// This array contains information about each domain known to this
// SAM server.  Reference and Modification of this array is protected
// by the SampLock.
//

ULONG SampDefinedDomainsCount=0;
PSAMP_DEFINED_DOMAINS SampDefinedDomains=NULL;





//
// Object type-independent information for each of the various
// SAM defined objects.
// This information is READ-ONLY once initialized.

SAMP_OBJECT_INFORMATION SampObjectInformation[ SampUnknownObjectType ];






//
//  Address of DLL routine to do password filtering.
//

//PSAM_PF_PASSWORD_FILTER    SampPasswordFilterDllRoutine;



//
// Unicode strings containing well known registry key names.
// These are read-only values once initialized.
//

UNICODE_STRING SampNameDomains;
UNICODE_STRING SampNameDomainGroups;
UNICODE_STRING SampNameDomainAliases;
UNICODE_STRING SampNameDomainAliasesMembers;
UNICODE_STRING SampNameDomainUsers;
UNICODE_STRING SampNameDomainAliasesNames;
UNICODE_STRING SampNameDomainGroupsNames;
UNICODE_STRING SampNameDomainUsersNames;
UNICODE_STRING SampCombinedAttributeName;
UNICODE_STRING SampFixedAttributeName;
UNICODE_STRING SampVariableAttributeName;



//
// A plethora of other useful characters or strings
//

UNICODE_STRING SampBackSlash;           // "/"
UNICODE_STRING SampNullString;          // Null string
UNICODE_STRING SampSamSubsystem;        // "Security Account Manager"
UNICODE_STRING SampServerObjectName;    // Name of root SamServer object


//
// Useful times
//

LARGE_INTEGER SampImmediatelyDeltaTime;
LARGE_INTEGER SampNeverDeltaTime;
LARGE_INTEGER SampHasNeverTime;
LARGE_INTEGER SampWillNeverTime;

//
// checked build only. If CurrentControlSet\Control\Lsa\UpdateLastLogonTSByMinute
// is set, the value of LastLogonTimeStampSyncInterval will be a "unit" by minute
// instead of "days", which helps to test this feature.   So checked build only.
// 

#if DBG
BOOLEAN SampLastLogonTimeStampSyncByMinute = FALSE;
#endif 

//
// Useful encryption constants
//

LM_OWF_PASSWORD SampNullLmOwfPassword;
NT_OWF_PASSWORD SampNullNtOwfPassword;


//
// Useful Sids
//

PSID SampWorldSid;
PSID SampAnonymousSid;
PSID SampLocalSystemSid;
PSID SampAdministratorUserSid;
PSID SampAdministratorsAliasSid;
PSID SampAccountOperatorsAliasSid;
PSID SampAuthenticatedUsersSid;
PSID SampPrincipalSelfSid;
PSID SampBuiltinDomainSid;
PSID SampNetworkSid;


//
//  Variables for the thread that flushes changes to the registry.
//
//  LastUnflushedChange - if there are no changes to be flushed, this
//      has a value of "Never".  If there are changes to be flushed,
//      this is the time of the last change that was made.  The flush
//      thread will flush if a SampFlushThreadMinWaitSeconds has passed
//      since the last change.
//
//  FlushThreadCreated - set TRUE as soon as the flush thread is created,
//      and FALSE when the thread exits.  A new thread will be created
//      when this is FALSE, unless FlushImmediately is TRUE.
//
//  FlushImmediately - an important event has occurred, so we want to
//      flush the changes immediately rather than waiting for the flush
//      thread to do it.  LastUnflushedChange should be set to "Never"
//      so the flush thread knows it doesn't have to flush.
//

LARGE_INTEGER LastUnflushedChange;
BOOLEAN FlushThreadCreated;
BOOLEAN FlushImmediately;

//
// These should probably be #defines, but we want to play with them.
//
//  SampFlushThreadMinWaitSeconds - The unit of time that the flush thread
//      waits.  If one of these has passed since the last unflushed change,
//      the changes will be flushed.
//
//  SampFlushThreadMaxWaitSeconds - If this amount of time has passed since
//      the flush thread was created or last flushed, the thread will force
//      a flush even if the database is still being changed.
//
//  SampFlushThreadExitDelaySeconds - How long the flush thread waits
//      around after a flush to see if any more changes occur.  If they
//      do, it starts waiting again; but if they don't, it will exit
//      to keep down thread overhead.
//

LONG   SampFlushThreadMinWaitSeconds;
LONG   SampFlushThreadMaxWaitSeconds;
LONG   SampFlushThreadExitDelaySeconds;

//
// Special SIDs
//

PSID SampBuiltinDomainSid = NULL;
PSID SampAccountDomainSid = NULL;


//
// Null token handle.  This is used when clients connect via unauthenticated
// RPC instead of authenticated RPC or named pipes.  Since they can't be
// authenticated, we impersonate this pre-built Null sesssion token.
//

HANDLE SampNullSessionToken;

//
// Flag indicating whether Netware server installed.
//

BOOLEAN SampNetwareServerInstalled = FALSE;

//
// Flag indicating whether to start listening on TCP/IP
//

BOOLEAN SampIpServerInstalled = FALSE;

//
// Flag indicating whether to start listening on apple talk
//

BOOLEAN SampAppletalkServerInstalled = FALSE;

//
// Flag indicating whether to start listening on Vines
//

BOOLEAN SampVinesServerInstalled = FALSE;

//
// Session key for encrypting all secret (sensitive data).
//

UCHAR SampSecretSessionKey[SAMP_SESSION_KEY_LENGTH];
UCHAR SampSecretSessionKeyPrevious[SAMP_SESSION_KEY_LENGTH];


//
// Flag indicating whether or not secret encryption is enabled
//

BOOLEAN SampSecretEncryptionEnabled = FALSE;

//
// Flag indicating whether or not upgrade is in process so as to allow
// calls to succeed.
//

BOOLEAN SampUpgradeInProcess;

//
// Flag indicating whether current global lock is for read or write.
// Used by dslayer routines to optimize DS transaction.
//

SAMP_DS_TRANSACTION_CONTROL SampDsTransactionType = TransactionWrite;
BOOLEAN SampLockHeld = FALSE;


//
// This flag is TRUE when DS failed to initialize. 
// SAM use it to display correct error message, saying "Directory Service 
// can not start..."
// 

BOOLEAN SampDsInitializationFailed = FALSE;


//
// This flag is TRUE when the DS has been successfully initialized
//

BOOLEAN SampDsInitialized = FALSE;

//
// Global pointer (to heap memory) to store DSNAME of the (single) authoritative
// domain name
//

DSNAME *RootObjectName = NULL;


//
// Variable to hold the Server Object's Name
//

DSNAME * SampServerObjectDsName = NULL;

//
// SAM Trace Levels, disable tracing by default. See dbgutilp.h for the
// details of how to enable tracing from the debugger. These flags are
// used for runtime debugging.
//

ULONG SampTraceTag = 0;
ULONG SampTraceFileTag = 0;




//
// Flags to determine if particular containers which were added piecemeal in 
// the development cycle exist.
//
BOOLEAN SampDomainControllersOUExists = TRUE;
BOOLEAN SampUsersContainerExists = TRUE;
BOOLEAN SampComputersContainerExists = TRUE;


//
// 
// Global pointer (to heap memory) to store well known container's 
// distinguished name
//
DSNAME * SampDomainControllersOUDsName = NULL;
DSNAME * SampUsersContainerDsName = NULL;
DSNAME * SampComputersContainerDsName = NULL;
DSNAME * SampComputerObjectDsName = NULL;



//
// Global Set at startup to determine whether we have a hard/soft attitude
// to GC downs
//
BOOLEAN SampIgnoreGCFailures = FALSE;

//
// This flag indicates that we should not store the LM hash. This is based
// upon a registry key setting.
//

BOOLEAN SampNoLmHash = FALSE;

//
// This flag indicates that we should check extended SAM Query/Enumerate 
// Access control right. This is based upon a registry key setting
// 

BOOLEAN SampDoExtendedEnumerationAccessCheck = FALSE;

//
// Flag to indicate NT4 PDC upgrade is in progressing
// 
//
BOOLEAN SampNT4UpgradeInProgress = FALSE;

//
// This flag indicates whether null sessions (world) should be allowed to
// list users in the domain and members of groups.
//

BOOLEAN SampRestrictNullSessions;

//
// This flag when set disables netlogon notifications
//

BOOLEAN SampDisableNetlogonNotification = FALSE;

//
// This flag indicates whether or not to enforce giving site affinity to
// clients outside our site by looking at the client's IP address.
//
BOOLEAN SampNoGcLogonEnforceKerberosIpCheck = FALSE;

//
// This flag indicates whether or not to enforce that only interactive
// logons via NTLM are to be given site affinity
//
BOOLEAN SampNoGcLogonEnforceNTLMCheck = FALSE;

//
// This flags indicates whether or not to replicate password set/change
// operations urgently.
//
BOOLEAN SampReplicatePasswordsUrgently = FALSE;

//
// This flag is enabled in personal and can be enabled in professional
// machines to force network access to guest account levels.
//
BOOLEAN SampForceGuest = FALSE;

//
// This flag indicates whether or not the local machine is joined to a domain
// 
BOOLEAN SampIsMachineJoinedToDomain = FALSE;

//
// This flag tells if we are running Personal SKU
// 
BOOLEAN SampPersonalSKU = FALSE;

//
// This flag is enabled in personal and can be enabled in professional
// machines to limit password changes where existing password on an account
// is a blank password
//
BOOLEAN SampLimitBlankPasswordUse = FALSE;

//
// This flag is used to control what gets printed to the sam.log file
// for deployment diagnostics.
//
ULONG SampLogLevel = 0;

//
// Globals to maintain state on Key IDs
//

ULONG SampCurrentKeyId;
ULONG SampPreviousKeyId;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\gclookup.c ===
/*++

Copyright (C) 1996 Microsoft Corporation

Module Name:

    gclookup.c

Abstract:
    
    Contains routines to perform GC lookups for clients within samsrv.dll's
    process space.
    
Author:
    
    ColinBr

Revision History


--*/

#include <winerror.h>
#include <stdlib.h>
#include <samsrvp.h>
#include <ntdsa.h>
#include <dslayer.h>
#include <mappings.h>
#include <objids.h>
#include <filtypes.h>
#include <dsdsply.h>
#include <fileno.h>
#include <dsconfig.h>
#include <mdlocal.h>
#include <malloc.h>
#include <errno.h>
#include <mdcodes.h>


VOID
SampSplitSamAccountName(
    IN  UNICODE_STRING *AccountName,
    OUT UNICODE_STRING *DomainName,
    OUT UNICODE_STRING *UserName
    )
/*++

Routine Description

    This routine separates Account name into a Domain and User portion.
    DomainName and UserName are not allocated -- they point to the buffer
    in AccountName.         
    
    The Domain is consider the part before the first L'\\'.  If this character
    doesn't exist, then UserName == AccountName
    

Parameters:

    AccountName -- the name to parse
    
    DomainName  -- the domain name portion
    
    UserName    -- the user name portion

Return Values:

    None.

--*/
{
    USHORT i;
    USHORT Length;

    ASSERT( AccountName );
    ASSERT( DomainName );
    ASSERT( UserName );

    Length = (AccountName->Length/sizeof(WCHAR));

    for (i = 0; i < Length; i++ ) {
        if ( L'\\' == AccountName->Buffer[i] ) {
            break;
        }
    }

    if ( i < Length ) {
        UserName->Buffer = &AccountName->Buffer[i+1];
        UserName->Length = UserName->MaximumLength = (AccountName->Length - (i+1));
        DomainName->Buffer = AccountName->Buffer;
        DomainName->Length = DomainName->MaximumLength = i;
    } else {
        RtlCopyMemory( UserName, AccountName, sizeof(UNICODE_STRING));
        RtlInitUnicodeString( DomainName, NULL );
    }

    return;

}

SID_NAME_USE
SampAccountTypeToNameUse(
    ULONG AccountType 
    )
{
    switch ( AccountType ) {
        
        case SAM_DOMAIN_OBJECT:
            return SidTypeDomain;

        case SAM_NON_SECURITY_GROUP_OBJECT:
        case SAM_GROUP_OBJECT:
            return SidTypeGroup;

        case SAM_NON_SECURITY_ALIAS_OBJECT:
        case SAM_ALIAS_OBJECT:
            return SidTypeAlias;

        case SAM_USER_OBJECT:
        case SAM_MACHINE_ACCOUNT:
        case SAM_TRUST_ACCOUNT:
            return SidTypeUser;

        default:

            ASSERT( FALSE && "Unexpected Account Type!" );
            return SidTypeUnknown;
    }

    ASSERT( FALSE && "Unexpected control flow" );
    return SidTypeUnknown;
}

BOOLEAN
SampSidWasFoundSimply(
    ULONG status
    )
//
// status is return code from the name cracking API.  see ntdsapi.h
//
{
    switch (status) {
        case DS_NAME_ERROR_IS_SID_USER:
        case DS_NAME_ERROR_IS_SID_GROUP:
        case DS_NAME_ERROR_IS_SID_ALIAS:
        case DS_NAME_ERROR_IS_SID_UNKNOWN:
            return TRUE;
    }

    return FALSE;
}
    
BOOLEAN
SampSidWasFoundByHistory(
    ULONG status
    )
//
// status is return code from the name cracking API.  see ntdsapi.h
//
{
    switch (status) {
        case DS_NAME_ERROR_IS_SID_HISTORY_USER:
        case DS_NAME_ERROR_IS_SID_HISTORY_GROUP:
        case DS_NAME_ERROR_IS_SID_HISTORY_ALIAS:
        case DS_NAME_ERROR_IS_SID_HISTORY_UNKNOWN:
            return TRUE;
    }

    return FALSE;
}

NTSTATUS
SamIGCLookupSids(
    IN ULONG            cSids,
    IN PSID            *SidArray,
    IN ULONG            Options,
    OUT ULONG           *Flags,
    OUT SID_NAME_USE   *SidNameUse,
    OUT PSAMPR_RETURNED_USTRING_ARRAY Names
    )
/*++

Routine Description

    This routine, exported to in-proc clients, translates a list of sids
    into sam account names as well as find thier sam object type (user, alias ... )


Parameters:

    cSids    -- the number of sids
    
    SidArray -- the array of sids
    
    Options  -- flags to control this functions behavoir.  Currently only
                SAMP_LOOKUP_BY_SID_HISTORY is supported.
    
    SidNameUse -- a preallocated array to be filled with each sid's use. 
                  SidTypeUnknown is used if the sid can't be resolved
    Names -- a preallocated array of empty unicode strings to be filled in
             The string is set to blank if the name could not be resolved.                  

Return Values:

    STATUS_SUCCESS
    
    STATUS_DS_GC_NOT_AVAILABLE: the GC was not available, no names were translated
    
    Standard resource errors    
    
--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG    DsErr = 0;

    PDS_NAME_RESULTW Results = NULL;

    BOOL     fKillThreadState = FALSE;

    BOOLEAN  fDoSidHistory = (Options & SAMP_LOOKUP_BY_SID_HISTORY) ? TRUE : FALSE;

    ULONG i, j;


    //
    // We should not be called in registry mode or if we have a transaction
    //
    ASSERT( SampUseDsData );

    // Parameter check
    ASSERT( SidNameUse );
    ASSERT( Names );

    //
    // Start a thread state if need be
    //
    if ( !THQuery() ) {
        
        if ( THCreate( CALLERTYPE_SAM ) ) {

            NtStatus = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        fKillThreadState = TRUE;
    }
    // We should not be in a transaction
    ASSERT(!SampExistsDsTransaction());

    // Init the out params
    for (i = 0; i < cSids; i++ ) {
        SidNameUse[i] = SidTypeUnknown;
        Flags[i] = 0;
    }
    Names->Count = 0;
    Names->Element = (PSID) MIDL_user_allocate( sizeof(RPC_UNICODE_STRING) * cSids );
    if ( !Names->Element ) {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    Names->Count = cSids;
    RtlZeroMemory( Names->Element, sizeof(RPC_UNICODE_STRING) * cSids );

    //
    // Hit the GC if possible
    //
    DsErr = SampGCLookupSids(cSids,
                             SidArray,
                            &Results);

    if ( 0 != DsErr )
    {
        //
        // Assume any error implies a GC could not be reached
        //
        NtStatus = STATUS_DS_GC_NOT_AVAILABLE;
        goto Cleanup;
    }
    ASSERT( cSids = Results->cItems );

    //
    // Now interpret the results
    //
    for ( i = 0; i < cSids; i++ ) {

        //
        // See if the sid was resolved
        //
        if (  SampSidWasFoundSimply( Results->rItems[i].status ) 
          || (fDoSidHistory
          && SampSidWasFoundByHistory( Results->rItems[i].status ) ) ) {

            ULONG Length;
            WCHAR *Name;

            //
            // Set the sid name use
            //
            switch ( Results->rItems[i].status ) {
                
                case DS_NAME_ERROR_IS_SID_USER:
                case DS_NAME_ERROR_IS_SID_HISTORY_USER:
                    SidNameUse[i] = SidTypeUser;
                    break;
                case DS_NAME_ERROR_IS_SID_GROUP:
                case DS_NAME_ERROR_IS_SID_HISTORY_GROUP:
                    SidNameUse[i] = SidTypeGroup;
                    break;
                case DS_NAME_ERROR_IS_SID_ALIAS:
                case DS_NAME_ERROR_IS_SID_HISTORY_ALIAS:
                    SidNameUse[i] = SidTypeAlias;
                    break;
                default:
                    SidNameUse[i] = SidTypeUnknown;
                    break;
            }

            if ( SampSidWasFoundByHistory( Results->rItems[i].status ) )
            {
                Flags[i] |= SAMP_FOUND_BY_SID_HISTORY;
            }

            //
            // Set up the name
            //
            Length = (wcslen( Results->rItems[i].pName ) + 1) * sizeof(WCHAR);
            Name = (WCHAR*) MIDL_user_allocate( Length );
            if ( !Name ) {
                NtStatus = STATUS_NO_MEMORY;
                goto Cleanup;
            }
            wcscpy( Name, Results->rItems[i].pName );
            RtlInitUnicodeString( (UNICODE_STRING *)&Names->Element[i], Name );

         } else if ( (Results->rItems[i].status == DS_NAME_ERROR_TRUST_REFERRAL)
                  && (Results->rItems[i].pDomain != NULL) ) {
             //
             // This is a routing hint indicating that the SID belongs to
             // a cross forest domain.
             //
             Flags[i] |= SAMP_FOUND_XFOREST_REF;
         }
    }

Cleanup:

    if ( !NT_SUCCESS( NtStatus ) ) {

        // Release all allocated memory
        SamIFree_SAMPR_RETURNED_USTRING_ARRAY( Names );
        
        // reset out params just to be clean
        for (i = 0; i < cSids; i++ ) {
            SidNameUse[i] = SidTypeUnknown;
        }
        RtlZeroMemory( Names, sizeof(SAMPR_RETURNED_USTRING_ARRAY) );
    }

    if ( fKillThreadState ) {

        THDestroy();
    }



    return NtStatus;
}

NTSTATUS
SamIGCLookupNames(
    IN ULONG           cNames,
    IN PUNICODE_STRING Names,
    IN ULONG           Options,
    IN OUT ULONG         *Flags,
    OUT SID_NAME_USE  *SidNameUse,
    OUT PSAMPR_PSID_ARRAY *pSidArray
    )
/*++

Routine Description

    This routine, exported to in-proc clients, translates a list of 
    names into sids as well as find thier sam object type (user, alias ... )

Parameters:

    cNames    -- the number of names
    Names     -- the array of names
    
    Options   -- flags to indicate what names to include. Currently only
                 SAMP_LOOKUP_BY_UPN supported
                 
    Flags     -- Flags to indicate to the caller how the name was found.
                 SAMP_FOUND_BY_SAM_ACCOUNT_NAME -- the name passed in is
                                                   a sam account name
                 SAMP_FOUND_XFOREST_REF -- the name belongs to an trusted
                                            forest
                 
                 Note: this array is allocated by the caller.                 
                  
    
    SidNameUse -- a preallocated array to be filled with each sid's use. 
                  SidTypeUnknown is used if the sid can't be resolved
                  
    SidArray -- a pointer to the structure to hold the sids.  While usual SAM
                practice would have this just be a pointer rather than 
                a pointer to a pointer, the exported "free" routines for SAM
                don't handle this, so we'll make it a pointer to a pointer.
                
Return Values:

    STATUS_SUCCESS
    
    STATUS_DS_GC_NOT_AVAILABLE: the GC was not available, no names were translated
    
    Standard resource errors    
    
--*/
{
    ULONG    DsErr = 0;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    ENTINF   *ReturnedEntInf = 0;

    BOOL     fKillThreadState = FALSE;

    ULONG i, j;

    DWORD err;

    PSAMPR_PSID_ARRAY SidArray = NULL;

    UNICODE_STRING ReturnedName;
    UNICODE_STRING DomainName1, DomainName2;
    UNICODE_STRING UserName1, UserName2;

    //
    // We should not be called in registry mode or if we have a transaction
    //
    ASSERT( SampUseDsData );

    // Parameter check
    ASSERT( SidNameUse );
    ASSERT( Names );
    ASSERT( pSidArray );
    ASSERT( Flags );

    //
    // Start a thread state if need be
    //
    if ( !THQuery() ) {
        
        if ( THCreate( CALLERTYPE_SAM ) ) {
            NtStatus = STATUS_NO_MEMORY;
            goto Cleanup;
        }
        fKillThreadState = TRUE;
    }
    ASSERT(!SampExistsDsTransaction());

    // Init the out params
    for (i = 0; i < cNames; i++ ) {
        SidNameUse[i] = SidTypeUnknown;
    }
    *pSidArray = NULL;
    SidArray = MIDL_user_allocate( sizeof( SAMPR_PSID_ARRAY ) );
    if ( !SidArray ) {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    *pSidArray = SidArray;

    SidArray->Count = 0;
    SidArray->Sids = MIDL_user_allocate( cNames * sizeof( SAMPR_SID_INFORMATION ) );
    if ( !SidArray->Sids ) {
        NtStatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }
    SidArray->Count = cNames;
    RtlZeroMemory( SidArray->Sids, cNames * sizeof( SAMPR_SID_INFORMATION ) );


    RtlZeroMemory( Flags, cNames * sizeof(ULONG) );


    //
    // Hit the GC if possible
    //
    DsErr = SampGCLookupNames(cNames,
                              Names,
                             &ReturnedEntInf);

    if ( 0 != DsErr )
    {
        //
        // Assume any error implies a GC could not be reached
        //
        NtStatus = STATUS_DS_GC_NOT_AVAILABLE;
        goto Cleanup;
    }


    //
    // Now interpret the results
    //
    for ( i = 0; i < cNames; i++ ) {
        
        PSID   Sid = NULL;
        DWORD  AccountType = 0;
        BOOLEAN fAccountTypeFound = FALSE;
        ULONG  Length;
        ENTINF *pEntInf = &ReturnedEntInf[i];
        WCHAR  *AccountName = NULL;

        RtlZeroMemory(  &ReturnedName, sizeof(ReturnedName) );

        //
        // If the object could not be resolved then no attributes
        // we be set in the attr block, so we will fall through
        // and the sidnameuse will remain "Unknown"

        //
        // Iterate through the ATTRBLOCK
        //
        for (j = 0; j < pEntInf->AttrBlock.attrCount; j++ ) {

            ATTR *pAttr;

            pAttr = &pEntInf->AttrBlock.pAttr[j];

            switch ( pAttr->attrTyp ) {
                
                case ATT_OBJECT_SID:

                    ASSERT( 1 == pAttr->AttrVal.valCount );
                    ASSERT( NULL != pAttr->AttrVal.pAVal[0].pVal  );
                    Sid = (WCHAR*) pAttr->AttrVal.pAVal[0].pVal;
                    break;

                case ATT_SAM_ACCOUNT_TYPE:

                    ASSERT( 1 == pAttr->AttrVal.valCount);
                    AccountType = *((DWORD*) pAttr->AttrVal.pAVal[0].pVal);
                    fAccountTypeFound = TRUE;
                    break;

                case ATT_SAM_ACCOUNT_NAME:

                    ASSERT( 1 == pAttr->AttrVal.valCount);
                    AccountName = (WCHAR*) pAttr->AttrVal.pAVal[0].pVal;

                    ReturnedName.Buffer = (WCHAR*) pAttr->AttrVal.pAVal[0].pVal;
                    ReturnedName.Length = ReturnedName.MaximumLength = (USHORT)pAttr->AttrVal.pAVal[0].valLen;
                    break;

            case FIXED_ATT_EX_FOREST:

                    //
                    // This indicates that the name belongs to a cross
                    // forest trust
                    //
                    Flags[i] |= SAMP_FOUND_XFOREST_REF;
                    break;

                default:
                
                    ASSERT( FALSE && !"Unexpected switch statement" );
            }
        }
            
        if (   Sid 
            && fAccountTypeFound ) {

            if ( AccountName ) {

                ASSERT( ReturnedName.Length > 0 );

                SampSplitSamAccountName( &Names[i], &DomainName1, &UserName1 );
                SampSplitSamAccountName( &ReturnedName, &DomainName2, &UserName2 );
                if ((CSTR_EQUAL == CompareString(DS_DEFAULT_LOCALE,
                                                 DS_DEFAULT_LOCALE_COMPARE_FLAGS,
                                                 UserName1.Buffer,
                                                 UserName1.Length/sizeof(WCHAR),
                                                 UserName2.Buffer,
                                                 UserName2.Length/sizeof(WCHAR) ))){
    
                    //
                    // The user name portion is the same we can use this value
                    // to cache
                    //
                    Flags[i] |= SAMP_FOUND_BY_SAM_ACCOUNT_NAME;
    
                }

            }

            //
            // Ok, we found something and we can use it
            //
            Length = RtlLengthSid( Sid );
            SidArray->Sids[i].SidPointer = (PSID) midl_user_allocate( Length );
            if ( !SidArray->Sids[i].SidPointer ) {
                NtStatus = STATUS_NO_MEMORY;
                goto Cleanup;
            }
            RtlCopySid( Length, SidArray->Sids[i].SidPointer, Sid );

            SidNameUse[i] = SampAccountTypeToNameUse( AccountType );

        }

    }

Cleanup:

    if ( !NT_SUCCESS( NtStatus ) ) {

        // Release any allocated memory 
        SamIFreeSidArray( *pSidArray );
        *pSidArray = NULL;

        // Reset parameters to be clean
        for (i = 0; i < cNames; i++ ) {
            SidNameUse[i] = SidTypeUnknown;
        }

    }

    if ( ReturnedEntInf ) {
        
        THFree( ReturnedEntInf );
    }

    if ( fKillThreadState ) {

        THDestroy();
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\ds\src\sam\server\group.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    group.c

Abstract:

    This file contains services related to the SAM "group" object.


Author:

    Jim Kelly    (JimK)  4-July-1991

Environment:

    User Mode - Win32

Revision History:


--*/

///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Includes                                                                  //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

#include <samsrvp.h>
#include <msaudite.h>
#include <dslayer.h>
#include <dsmember.h>
#include <ridmgr.h>
#include <malloc.h>
#include <dsevent.h>
#include <gcverify.h>
#include <attids.h>
#include <samtrace.h>



///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// private service prototypes                                                //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////


NTSTATUS
SampDeleteGroupKeys(
    IN PSAMP_OBJECT Context
    );

NTSTATUS
SampReplaceGroupMembers(
    IN PSAMP_OBJECT GroupContext,
    IN ULONG MemberCount,
    IN PULONG Members
    );

NTSTATUS
SampAddAccountToGroupMembers(
    IN PSAMP_OBJECT GroupContext,
    IN ULONG UserRid,
    IN DSNAME * MemberDsName OPTIONAL
    );

NTSTATUS
SampRemoveAccountFromGroupMembers(
    IN PSAMP_OBJECT GroupContext,
    IN ULONG AccountRid,
    IN DSNAME * MemberDsName OPTIONAL
    );


NTSTATUS
SampRemoveMembershipGroup(
    IN ULONG GroupRid,
    IN ULONG MemberRid,
    IN SAMP_MEMBERSHIP_DELTA AdminGroup,
    IN SAMP_MEMBERSHIP_DELTA OperatorGroup
    );

NTSTATUS
SampAddSameDomainMemberToGlobalOrUniversalGroup(
    IN  PSAMP_OBJECT AccountContext,
    IN  ULONG        MemberId,
    IN  ULONG        Attributes,
    IN  DSNAME       *MemberDsName OPTIONAL
    );

NTSTATUS
SampRemoveSameDomainMemberFromGlobalOrUniversalGroup(
    IN  PSAMP_OBJECT AccountContext,
    IN  ULONG        MemberId,
    IN  DSNAME       *MemberDsName OPTIONAL
    );




///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// Exposed RPC'able Services                                                 //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////






NTSTATUS
SamrOpenGroup(
    IN SAMPR_HANDLE DomainHandle,
    IN ACCESS_MASK DesiredAccess,
    IN ULONG GroupId,
    OUT SAMPR_HANDLE *GroupHandle
    )

/*++

Routine Description:

    This API opens an existing group in the account database.  The group
    is specified by a ID value that is relative to the SID of the
    domain.  The operations that will be performed on the group must be
    declared at this time.

    This call returns a handle to the newly opened group that may be
    used for successive operations on the group.  This handle may be
    closed with the SamCloseHandle API.



Parameters:

    DomainHandle - A domain handle returned from a previous call to
        SamOpenDomain.

    DesiredAccess - Is an access mask indicating which access types
        are desired to the group.  These access types are reconciled
        with the Discretionary Access Control list of the group to
        determine whether the accesses will be granted or denied.

    GroupId - Specifies the relative ID value of the group to be
        opened.

    GroupHandle - Receives a handle referencing the newly opened
        group.  This handle will be required in successive calls to
        operate on the group.

Return Values:

    STATUS_SUCCESS - The group was successfully opened.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_NO_SUCH_GROUP - The specified group does not exist.

    STATUS_INVALID_HANDLE - The domain handle passed is invalid.

--*/
{
    NTSTATUS            NtStatus;
    DECLARE_CLIENT_REVISION(DomainHandle);

    SAMTRACE_EX("SamrOpenGroup");

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidOpenGroup
                   );


    NtStatus = SampOpenAccount(
                   SampGroupObjectType,
                   DomainHandle,
                   DesiredAccess,
                   GroupId,
                   FALSE,
                   GroupHandle
                   );


    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidOpenGroup
                   );

    return(NtStatus);
}


NTSTATUS
SamrQueryInformationGroup(
    IN SAMPR_HANDLE GroupHandle,
    IN GROUP_INFORMATION_CLASS GroupInformationClass,
    OUT PSAMPR_GROUP_INFO_BUFFER *Buffer
    )

/*++

Routine Description:

    This API retrieves information on the group specified.



Parameters:

    GroupHandle - The handle of an opened group to operate on.

    GroupInformationClass - Class of information to retrieve.  The
        accesses required for each class is shown below:

        Info Level                      Required Access Type
        -----------------------         ----------------------

        GroupGeneralInformation         GROUP_READ_INFORMATION
        GroupNameInformation            GROUP_READ_INFORMATION
        GroupAttributeInformation       GROUP_READ_INFORMATION
        GroupAdminInformation           GROUP_READ_INFORMATION

    Buffer - Receives a pointer to a buffer containing the requested
        information.  When this information is no longer needed, this
        buffer must be freed using SamFreeMemory().

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

--*/
{

    NTSTATUS                NtStatus;
    NTSTATUS                IgnoreStatus;
    PSAMP_OBJECT            AccountContext;
    SAMP_OBJECT_TYPE        FoundType;
    ACCESS_MASK             DesiredAccess;
    ULONG                   i;
    SAMP_V1_0A_FIXED_LENGTH_GROUP V1Fixed;
   
    //
    // Used for tracking allocated blocks of memory - so we can deallocate
    // them in case of error.  Don't exceed this number of allocated buffers.
    //                                     
    PVOID                   AllocatedBuffer[10];
    ULONG                   AllocatedBufferCount = 0;
    BOOLEAN                 fLockAcquired = FALSE;
    DECLARE_CLIENT_REVISION(GroupHandle) ;

    SAMTRACE_EX("SamrQueryInformationGroup");

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidQueryInformationGroup
                   );

    #define RegisterBuffer(Buffer)                                      \
        {                                                               \
            if ((Buffer) != NULL) {                                     \
                                                                        \
                ASSERT(AllocatedBufferCount <                           \
                       sizeof(AllocatedBuffer) / sizeof(*AllocatedBuffer)); \
                                                                        \
                AllocatedBuffer[AllocatedBufferCount++] = (Buffer);     \
            }                                                           \
        }

    #define AllocateBuffer(NewBuffer, Size)                             \
        {                                                               \
            (NewBuffer) = MIDL_user_allocate(Size);                     \
            RegisterBuffer(NewBuffer);                                  \
        }                                                               \


    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    ASSERT (Buffer != NULL);
    ASSERT ((*Buffer) == NULL);

    if (!((Buffer!=NULL)&&(*Buffer==NULL)))
    {
        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }


    //
    // Set the desired access based upon the Info class
    //

    switch (GroupInformationClass) {

    case GroupGeneralInformation:
    case GroupNameInformation:
    case GroupAttributeInformation:
    case GroupAdminCommentInformation:
    case GroupReplicationInformation:

        DesiredAccess = GROUP_READ_INFORMATION;
        break;

    default:
        (*Buffer) = NULL;
        NtStatus = STATUS_INVALID_INFO_CLASS;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    } // end_switch


   
   

    //
    // Allocate the info structure
    //

    (*Buffer) = MIDL_user_allocate( sizeof(SAMPR_GROUP_INFO_BUFFER) );
    if ((*Buffer) == NULL) {
        NtStatus = STATUS_INSUFFICIENT_RESOURCES;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }

    RegisterBuffer(*Buffer);


    //
    // Acquire the Read lock if necessary
    //
    
    AccountContext = (PSAMP_OBJECT)GroupHandle;
    SampMaybeAcquireReadLock(AccountContext,
                             DEFAULT_LOCKING_RULES, // acquire lock for shared domain context
                             &fLockAcquired);

    //
    // Validate type of, and access to object.
    //

    
    NtStatus = SampLookupContext(
               AccountContext,
               DesiredAccess,
               SampGroupObjectType,           // ExpectedType
               &FoundType
               );


    if (NT_SUCCESS(NtStatus)) {


        //
        // If the information level requires, retrieve the V1_FIXED record
        // from the registry.
        //

        switch (GroupInformationClass) {

        case GroupGeneralInformation:
        case GroupReplicationInformation:
        case GroupAttributeInformation:

            NtStatus = SampRetrieveGroupV1Fixed(
                           AccountContext,
                           &V1Fixed
                           );
            break; //out of switch

        default:
            NtStatus = STATUS_SUCCESS;

        } // end_switch

        if (NT_SUCCESS(NtStatus)) {

            //
            // case on the type information requested
            //

            switch (GroupInformationClass) {

            case GroupGeneralInformation:
            case GroupReplicationInformation:


                (*Buffer)->General.Attributes  = V1Fixed.Attributes;


                if (GroupGeneralInformation==GroupInformationClass)
                {
                    


                    //
                    // Get the member count
                    //

                    NtStatus = SampRetrieveGroupMembers(
                                   AccountContext,
                                   &(*Buffer)->General.MemberCount,
                                   NULL                                 // Only need members
                                );
                }
                else
                {
                    //
                    // Do not query the member count. Netlogon will get this 
                    // while querying the group membership ( Saves redundant
                    // computation
                    //

                    (*Buffer)->General.MemberCount=0;
                }


                if (NT_SUCCESS(NtStatus)) {


                    //
                    // Get copies of the strings we must retrieve from
                    // the registry.
                    //

                    NtStatus = SampGetUnicodeStringAttribute(
                                   AccountContext,
                                   SAMP_GROUP_NAME,
                                   TRUE,    // Make copy
                                   (PUNICODE_STRING)&((*Buffer)->General.Name)
                                   );

                    if (NT_SUCCESS(NtStatus)) {

                        RegisterBuffer((*Buffer)->General.Name.Buffer);

                        NtStatus = SampGetUnicodeStringAttribute(
                                       AccountContext,
                                       SAMP_GROUP_ADMIN_COMMENT,
                                       TRUE,    // Make copy
                                       (PUNICODE_STRING)&((*Buffer)->General.AdminComment)
                                       );

                        if (NT_SUCCESS(NtStatus)) {

                            RegisterBuffer((*Buffer)->General.AdminComment.Buffer);
                        }
                    }
                }


                break;


            case GroupNameInformation:

                //
                // Get copies of the strings we must retrieve from
                // the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_GROUP_NAME,
                               TRUE,    // Make copy
                               (PUNICODE_STRING)&((*Buffer)->Name.Name)
                               );

                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->Name.Name.Buffer);
                }


                break;


            case GroupAdminCommentInformation:

                //
                // Get copies of the strings we must retrieve from
                // the registry.
                //

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_GROUP_ADMIN_COMMENT,
                               TRUE,    // Make copy
                               (PUNICODE_STRING)&((*Buffer)->AdminComment.AdminComment)
                               );

                if (NT_SUCCESS(NtStatus)) {

                    RegisterBuffer((*Buffer)->AdminComment.AdminComment.Buffer);
                }


                break;


            case GroupAttributeInformation:


                (*Buffer)->Attribute.Attributes  = V1Fixed.Attributes;

                break;

            }   // end_switch


        } // end_if



        //
        // De-reference the object, discarding changes
        //

        IgnoreStatus = SampDeReferenceContext( AccountContext, FALSE );
        ASSERT(NT_SUCCESS(IgnoreStatus));

    }

    //
    // Free the read lock if necessary
    //

    
    SampMaybeReleaseReadLock(fLockAcquired);
   



    //
    // If we didn't succeed, free any allocated memory
    //

    if (!NT_SUCCESS(NtStatus)) {
        for ( i=0; i<AllocatedBufferCount ; i++ ) {
            MIDL_user_free( AllocatedBuffer[i] );
        }

        (*Buffer) = NULL;
    }

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidQueryInformationGroup
                   );

    return(NtStatus);
}



NTSTATUS
SamrSetInformationGroup(
    IN SAMPR_HANDLE GroupHandle,
    IN GROUP_INFORMATION_CLASS GroupInformationClass,
    IN PSAMPR_GROUP_INFO_BUFFER Buffer
    )

/*++

Routine Description:

    This API allows the caller to modify group information.


Parameters:

    GroupHandle - The handle of an opened group to operate on.

    GroupInformationClass - Class of information to retrieve.  The
        accesses required for each class is shown below:

        Info Level                      Required Access Type
        ------------------------        -------------------------

        GroupGeneralInformation         (can't write)

        GroupNameInformation            GROUP_WRITE_ACCOUNT
        GroupAttributeInformation       GROUP_WRITE_ACCOUNT
        GroupAdminInformation           GROUP_WRITE_ACCOUNT

    Buffer - Buffer where information retrieved is placed.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_INFO_CLASS - The class provided was invalid.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_NO_SUCH_GROUP - The group specified is unknown.

    STATUS_SPECIAL_GROUP - The group specified is a special group and
        cannot be operated on in the requested fashion.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.

--*/
{

    NTSTATUS                NtStatus,
                            TmpStatus,
                            IgnoreStatus;

    PSAMP_OBJECT            AccountContext;

    SAMP_OBJECT_TYPE        FoundType;

    ACCESS_MASK             DesiredAccess;

    SAMP_V1_0A_FIXED_LENGTH_GROUP V1Fixed;

    UNICODE_STRING          OldAccountName,
                            NewAdminComment,
                            NewAccountName,
                            NewFullName;

    ULONG                   ObjectRid,
                            OldGroupAttributes = 0;

    BOOLEAN                 Modified = FALSE,
                            RemoveAccountNameFromTable = FALSE, 
                            AccountNameChanged = FALSE;
    DECLARE_CLIENT_REVISION(GroupHandle);

    SAMTRACE_EX("SamrSetInformationGroup");

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_START,
                   SampGuidSetInformationGroup
                   );

    //
    // Make sure we understand what RPC is doing for (to) us.
    //

    if (Buffer == NULL) {
        NtStatus = STATUS_INVALID_PARAMETER;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }

    //
    // Reset any strings that we'll be freeing in clean-up code
    //

    RtlInitUnicodeString(&OldAccountName, NULL);
    RtlInitUnicodeString(&NewAccountName, NULL);
    RtlInitUnicodeString(&NewFullName, NULL);
    RtlInitUnicodeString(&NewAdminComment, NULL);

    //
    // Set the desired access based upon the Info class
    //

    switch (GroupInformationClass) {

    case GroupNameInformation:
    case GroupAttributeInformation:
    case GroupAdminCommentInformation:

        DesiredAccess = GROUP_WRITE_ACCOUNT;
        break;


    case GroupGeneralInformation:
    default:

        NtStatus = STATUS_INVALID_INFO_CLASS;
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;

    } // end_switch



    //
    // Grab the lock
    //

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto Error;
    }



    //
    // Validate type of, and access to object.
    //

    AccountContext = (PSAMP_OBJECT)GroupHandle;
    ObjectRid = AccountContext->TypeBody.Group.Rid;
    NtStatus = SampLookupContext(
                   AccountContext,
                   DesiredAccess,
                   SampGroupObjectType,           // ExpectedType
                   &FoundType
                   );


    if (NT_SUCCESS(NtStatus)) {


        //
        // If the information level requires, retrieve the V1_FIXED record
        // from the registry.  This includes anything that will cause
        // us to update the display cache.
        //

        switch (GroupInformationClass) {

        case GroupAdminCommentInformation:
        case GroupNameInformation:
        case GroupAttributeInformation:

            NtStatus = SampRetrieveGroupV1Fixed(
                           AccountContext,
                           &V1Fixed
                           );

            OldGroupAttributes = V1Fixed.Attributes;
            break; //out of switch


        default:
            NtStatus = STATUS_SUCCESS;

        } // end_switch

        if (NT_SUCCESS(NtStatus)) {

            //
            // case on the type information requested
            //

            switch (GroupInformationClass) {

            case GroupNameInformation:

                NtStatus = SampChangeGroupAccountName(
                                AccountContext,
                                (PUNICODE_STRING)&(Buffer->Name.Name),
                                &OldAccountName
                                );
                if (!NT_SUCCESS(NtStatus)) {
                      OldAccountName.Buffer = NULL;
                }

                //
                // RemoveAccountNameFromTable tells us whether
                // the caller (this routine) is responsable 
                // to remove the name from the table. 
                // 
                RemoveAccountNameFromTable = 
                    AccountContext->RemoveAccountNameFromTable;

                // 
                // Reset to FALSE 
                //
                AccountContext->RemoveAccountNameFromTable = FALSE;

                //
                // Don't free OldAccountName yet; we'll need it at the
                // very end.
                //

                AccountNameChanged = TRUE;

                break;


            case GroupAdminCommentInformation:

                //
                // build the key name
                //

                NtStatus = SampSetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_GROUP_ADMIN_COMMENT,
                               (PUNICODE_STRING)&(Buffer->AdminComment.AdminComment)
                               );

                break;


            case GroupAttributeInformation:

                V1Fixed.Attributes = Buffer->Attribute.Attributes;

                NtStatus = SampReplaceGroupV1Fixed(
                           AccountContext,             // ParentKey
                           &V1Fixed
                           );

                break;


            } // end_switch


        }  // end_if


        //
        // Go fetch any data we'll need to update the display cache
        // Do this before we dereference the context
        //

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_GROUP_NAME,
                               TRUE,    // Make copy
                               &NewAccountName
                               );

            if (NT_SUCCESS(NtStatus)) {

                NtStatus = SampGetUnicodeStringAttribute(
                               AccountContext,
                               SAMP_GROUP_ADMIN_COMMENT,
                               TRUE, // Make copy
                               &NewAdminComment
                               );
                //
                // If the account name has changed, then OldAccountName
                // is already filled in. If the account name hasn't changed
                // then the OldAccountName is the same as the new!
                //

                if (NT_SUCCESS(NtStatus) && (OldAccountName.Buffer == NULL)) {

                    NtStatus = SampDuplicateUnicodeString(
                                   &OldAccountName,
                                   &NewAccountName);
                }
            }
        }


        //
        // Dereference the account context
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // De-reference the object, write out any change to current xaction.
            //

            NtStatus = SampDeReferenceContext( AccountContext, TRUE );

        } else {

            //
            // De-reference the object, ignore changes
            //

            TmpStatus = SampDeReferenceContext( AccountContext, FALSE );
            ASSERT(NT_SUCCESS(TmpStatus));
        }



    } //end_if



    //
    // Commit the transaction, update the display cache,
    // and notify netlogon of the changes
    //

    if ( NT_SUCCESS(NtStatus) ) {

        NtStatus = SampCommitAndRetainWriteLock();

        //
        // Generate audit if necessary if still success
        //

        if (NT_SUCCESS(NtStatus) && 
            SampDoAccountAuditing(AccountContext->DomainIndex)) {

            // audit account name change
            if (AccountNameChanged)
            {
                SampAuditAccountNameChange(AccountContext,
                                           (PUNICODE_STRING)&(Buffer->Name.Name),
                                           &OldAccountName
                                           );
            }

            //
            // generate more generic group change audit
            // 
            // the following audit is generated for RPC client only.   
            // ldap client (loopback) client will not go through this code 
            // path, GroupChange audit is generate in SampNotifyReplicatedinChange()
            // for loopback client. 
            // 
            // RPC client can modify Security Enabled Account Group Only.
            // 


            SampAuditGroupChange(AccountContext->DomainIndex,
                                 &NewAccountName,
                                 &(AccountContext->TypeBody.Group.Rid),
                                 (GROUP_TYPE_SECURITY_ENABLED | GROUP_TYPE_ACCOUNT_GROUP)
                                 );
        }

        if ( NT_SUCCESS(NtStatus) ) {



            //
            // Update the display information if the cache may be affected
            //

            if ( !IsDsObject(AccountContext) ) {

                SAMP_ACCOUNT_DISPLAY_INFO OldAccountInfo;
                SAMP_ACCOUNT_DISPLAY_INFO NewAccountInfo;

                OldAccountInfo.Name = OldAccountName;
                OldAccountInfo.Rid = ObjectRid;
                OldAccountInfo.AccountControl = OldGroupAttributes;
                RtlInitUnicodeString(&OldAccountInfo.Comment, NULL);
                RtlInitUnicodeString(&OldAccountInfo.FullName, NULL);  // Not used for groups

                NewAccountInfo.Name = NewAccountName;
                NewAccountInfo.Rid = ObjectRid;
                NewAccountInfo.AccountControl = V1Fixed.Attributes;
                NewAccountInfo.Comment = NewAdminComment;
                NewAccountInfo.FullName = NewFullName;

                IgnoreStatus = SampUpdateDisplayInformation(&OldAccountInfo,
                                                            &NewAccountInfo,
                                                            SampGroupObjectType);
                ASSERT(NT_SUCCESS(IgnoreStatus));
            }

            if (AccountContext->TypeBody.Group.SecurityEnabled)
            {

                if ( GroupInformationClass == GroupNameInformation ) {

                    SampNotifyNetlogonOfDelta(
                        SecurityDbRename,
                        SecurityDbObjectSamGroup,
                        ObjectRid,
                        &OldAccountName,
                        (DWORD) FALSE,  // Replicate immediately
                        NULL            // Delta data
                        );

                } else {

                    SampNotifyNetlogonOfDelta(
                        SecurityDbChange,
                        SecurityDbObjectSamGroup,
                        ObjectRid,
                        (PUNICODE_STRING) NULL,
                        (DWORD) FALSE,  // Replicate immediately
                        NULL            // Delta data
                        );
                }
            }


        }
    }


    //
    // Remove the New Account Name from the Global
    // SAM Account Name Table
    // 
    if (RemoveAccountNameFromTable)
    {
        IgnoreStatus = SampDeleteElementFromAccountNameTable(
                            (PUNICODE_STRING)&(Buffer->Name.Name),
                            SampGroupObjectType
                            );
        ASSERT(NT_SUCCESS(IgnoreStatus));
    }

    //
    // Release the write lock
    //

    TmpStatus = SampReleaseWriteLock( FALSE );

    if (NT_SUCCESS(NtStatus)) {
        NtStatus = TmpStatus;
    }


    //
    // Clean up strings
    //

    SampFreeUnicodeString( &OldAccountName );
    SampFreeUnicodeString( &NewAccountName );
    SampFreeUnicodeString( &NewFullName );
    SampFreeUnicodeString( &NewAdminComment );

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);

Error:

    // WMI event trace

    SampTraceEvent(EVENT_TRACE_TYPE_END,
                   SampGuidSetInformationGroup
                   );

    return(NtStatus);

}


NTSTATUS
SamrAddMemberToGroup(
    IN SAMPR_HANDLE GroupHandle,
    IN ULONG MemberId,
    IN ULONG Attributes
    )

/*++

Routine Description:

    This API adds a member to a group.  Note that this API requires the
    GROUP_ADD_MEMBER access type for the group.


Parameters:

    GroupHandle - The handle of an opened group to operate on.

    MemberId - Relative ID of the member to add.

    Attributes - The attributes of the group assigned to the user.
        The attributes assigned here may have any value.  However,
        at logon time these attributes are minimized by the
        attributes of the group as a whole.

          Mandatory -    If the Mandatory attribute is assigned to
                    the group as a whole, then it will be assigned to
                    the group for each member of the group.

          EnabledByDefault - This attribute may be set to any value
                    for each member of the group.  It does not matter
                    what the attribute value for the group as a whole
                    is.

          Enabled - This attribute may be set to any value for each
                    member of the group.  It does not matter what the
                    attribute value for the group as a whole is.

          Owner -   If the Owner attribute of the group as a
                    whole is not set, then the value assigned to
                    members is ignored.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.


    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_INVALID_HANDLE - The handle passed is invalid.

    STATUS_NO_SUCH_MEMBER - The member specified is unknown.

    STATUS_MEMBER_IN_GROUP - The member already belongs to the group.

    STATUS_INVALID_GROUP_ATTRIBUTES - Indicates the group attribute
        values being assigned to the member are not compatible with
        the attribute values of the group as a whole.

    STATUS_INVALID_DOMAIN_STATE - The domain server is not in the
        correct state (disabled or enabled) to perform the requested
        operation.  The domain server must be enabled for this
        operation

    STATUS_INVALID_DOMAIN_ROLE - The domain server is serving the
        incorrect role (primary or backup) to perform the requested
        operation.




--*/
{

    NTSTATUS         NtStatus, TmpStatus;
    PSAMP_OBJECT     AccountContext;
    SAMP_OBJECT_TYPE FoundType;
    UNICODE_STRING   GroupName;
    DECLARE_CLIENT_REVISION(GroupHandle);

    SAMTRACE_EX("SamrAddMemberToGroup");

    //
    // Do a start type WMI event Trace.
    // 
    
    SampTraceEvent(EVENT_TRACE_TYPE_START, 
                   SampGuidAddMemberToGroup
                   );

    SampUpdatePerformanceCounters(
        DSSTAT_MEMBERSHIPCHANGES,
        FLAG_COUNTER_INCREMENT,
        0
        );
        
    //
    // Initialize buffers we will cleanup at the end
    //

    RtlInitUnicodeString(&GroupName, NULL);

    //
    // Grab the lock
    //

    NtStatus = SampAcquireWriteLock();
    if (!NT_SUCCESS(NtStatus)) {
        SAMTRACE_RETURN_CODE_EX(NtStatus);
        goto SamrAddMemberToGroupError;
    }

    //
    // Validate type of, and access to object.
    //

    AccountContext = (PSAMP_OBJECT)(GroupHandle);
    NtStatus = SampLookupContext(
                   AccountContext,
                   GROUP_ADD_MEMBER,
                   SampGroupObjectType,           // ExpectedType
                   &FoundType
                   );

    

    if (NT_SUCCESS(NtStatus)) {


        //
        // Call the worker routine
        //

        NtStatus = SampAddSameDomainMemberToGlobalOrUniversalGroup(
                        AccountContext,
                        MemberId,
                        Attributes,
                        NULL
                        );

        if (NT_SUCCESS(NtStatus)) {

            //
            // Get and save the account name for
            // I_NetNotifyLogonOfDelta.
            //

            NtStatus = SampGetUnicodeStringAttribute(
                           AccountContext,
                           SAMP_GROUP_NAME,
                           TRUE,    // Make copy
                           &GroupName
                           );

            if (!NT_SUCCESS(NtStatus)) {
                RtlInitUnicodeString(&GroupName, NULL);
            }
        }


        //
        // Dereference the account context
        //

        if (NT_SUCCESS(NtStatus)) {

            //
            // De-reference the object, write out any change to current xaction.
            //

            NtStatus = SampDeReferenceContext( AccountContext, TRUE );

        } else {

            //
            // De-reference the object, ignore changes
            //

            TmpStatus = SampDeReferenceContext( AccountContext, FALSE );
            ASSERT(NT_SUCCESS(TmpStatus));
        }

        //
        // Commit the transaction and notify net logon of the changes
        //

        if (NT_SUCCESS(NtStatus)) {

            NtStatus = SampCommitAndRetainWriteLock();

            if (( NT_SUCCESS( NtStatus ) )
                && (AccountContext->TypeBody.Group.SecurityEnabled))
            {

                SAM_DELTA_DATA DeltaData;

                //
                // Fill in id of member being added
                //

                DeltaData.GroupMemberId.MemberRid = MemberId;


                if (AccountContext->TypeBody.Group.SecurityEnabled)
                {
                    SampNotifyNetlogonOfDelta(
                        SecurityDbChangeMemberAdd,
                        SecurityDbObjectSamGroup,
                        AccountContext->TypeBody.Group.Rid,
                        &GroupName,
                        (DWORD) FALSE,      // Replicate immediately
                        &DeltaData
                        );
                }
            }
        }


        //
        // Free up the group name
        //

        SampFreeUnicodeString(&GroupName);       

    }

    //
    // Release the Lock
    //


    TmpStatus = SampReleaseWriteLock( FALSE );
    ASSERT(NT_SUCCESS(TmpStatus));

    SAMP_MAP_STATUS_TO_CLIENT_REVISION(NtStatus);
    SAMTRACE_RETURN_CODE_EX(NtStatus);
    
    
SamrAddMemberToGroupError:

    //
    // Do a WMI end type event trace
    // 
    
    SampTraceEvent(EVENT_TRACE_TYPE_END, 
                   SampGuidAddMemberToGroup
                   );

    return(NtStatus);
}



NTSTATUS
SamrDeleteGroup(
    IN SAMPR_HANDLE *GroupHandle
    )

/*++

Routine Description:

    This API removes a group from the account database.  There may be no
    members in the group or the deletion request will be rejected.  Note
    that this API requires DELETE access to the specific group being
    deleted.


Parameters:

    GroupHandle - The handle of an opened group to operate on.

Return Values:

    STATUS_SUCCESS - The Service completed successfully.

    STATUS_ACCESS_DENIED - Caller does not have the appropriate
        access to complete the operation.

    STATUS_I