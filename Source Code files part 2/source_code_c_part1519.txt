llscreen, exclusive mode.
    //
    hr = m_lpDDObj->SetCooperativeLevel( hWnd, DDSCL_NORMAL );
    if( FAILED( hr ) )
        return hr;

    //
    // Initialize a surface description structure for the primary surface. The
    // primary surface represents the entire display, with dimensions and a
    // pixel format of the display. Therefore, none of that information needs
    // to be specified in order to create the primary surface.
    //
    DDSURFACEDESC2 ddsd;
    ZeroMemory( &ddsd, sizeof(DDSURFACEDESC2) );
    ddsd.dwSize = sizeof(DDSURFACEDESC2);
    ddsd.dwFlags        = DDSD_CAPS;
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;

    //
    // Create the primary surface.
    //
    hr = m_lpDDObj->CreateSurface( &ddsd, &m_lpPriSurf, NULL );
    if( FAILED( hr ) )
        return hr;

    //
    // Create a clipper object which handles all our clipping for cases when
    // our window is partially obscured by other windows. This is not needed
    // for apps running in fullscreen mode.
    //
    LPDIRECTDRAWCLIPPER pcClipper;
    hr = m_lpDDObj->CreateClipper( 0, &pcClipper, NULL );
    if( FAILED( hr ) )
        return hr;

    //
    // Associate the clipper with our window. Note that, afterwards, the
    // clipper is internally referenced by the primary surface, so it is safe
    // to release our local reference to it.
    //
    pcClipper->SetHWnd( 0, hWnd );
    m_lpPriSurf->SetClipper( pcClipper );
    pcClipper->Release();

    //
    // Setup a surface description to create a backbuffer. This is an
    // offscreen plain surface with dimensions equal to our window size.
    // The DDSCAPS_3DDEVICE is needed so we can later query this surface
    // for an IDirect3DDevice interface.
    //
    ddsd.dwFlags        = DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS;
    ddsd.ddsCaps.dwCaps = DDSCAPS_VIDEOMEMORY | DDSCAPS_3DDEVICE;
    ddsd.dwWidth  = 640;
    ddsd.dwHeight = 480;

    //
    // Create the backbuffer. The most likely reason for failure is running
    // out of video memory. (A more sophisticated app should handle this.)
    //
    hr = m_lpDDObj->CreateSurface( &ddsd, &m_lpBackBuffer, NULL );
    if( FAILED( hr ) )
        return hr;

    //
    // Before creating the device, check that we are NOT in a palettized
    // display. That case will cause CreateDevice() to fail, since this simple
    // tutorial does not bother with palettes.
    //
    ddsd.dwSize = sizeof(DDSURFACEDESC2);
    m_lpDDObj->GetDisplayMode( &ddsd );
    if( ddsd.ddpfPixelFormat.dwRGBBitCount <= 8 )
        return DDERR_INVALIDMODE;

    //
    // Create the device. The device is created off of our back buffer, which
    // becomes the render target for the newly created device. Note that the
    // z-buffer must be created BEFORE the device
    //
    if( FAILED( hr = m_pD3D->CreateDevice( IID_IDirect3DHALDevice,
                                           m_lpBackBuffer,
                                           &m_pD3DDevice ) ) )
    {
        // This call could fail for many reasons. The most likely cause is
        // that we specifically requested a hardware device, without knowing
        // whether there is even a 3D card installed in the system. Another
        // possibility is the hardware is incompatible with the current display
        // mode (the correct implementation would use enumeration for this.)

        if( FAILED( hr = m_pD3D->CreateDevice( IID_IDirect3DRGBDevice,
                                               m_lpBackBuffer,
                                               &m_pD3DDevice ) ) )
            return hr;
    }

//  hr = m_pD3DDevice->SetRenderState(D3DRENDERSTATE_LIGHTING, FALSE);
//  hr = m_pD3DDevice->SetRenderState(D3DRENDERSTATE_CULLMODE, D3DCULL_NONE);
//  hr = m_pD3DDevice->SetRenderState(D3DRENDERSTATE_BLENDENABLE, FALSE);

//  hr = m_pD3DDevice->SetTextureStageState(0, D3DTSS_COLOROP, D3DTOP_SELECTARG1);
//  hr = m_pD3DDevice->SetTextureStageState(0, D3DTSS_MAGFILTER, D3DTFG_LINEAR);
//  hr = m_pD3DDevice->SetTextureStageState(0, D3DTSS_MINFILTER, D3DTFN_LINEAR);
//  hr = m_pD3DDevice->SetTextureStageState(0, D3DTSS_MIPFILTER, D3DTFP_LINEAR);
//  hr = m_pD3DDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE);
//  hr = m_pD3DDevice->SetTextureStageState(0, D3DTSS_ADDRESS, D3DTADDRESS_CLAMP);

    // Create the viewport
    DWORD dwRenderWidth  = 640;
    DWORD dwRenderHeight = 480;
    D3DVIEWPORT7 vp = { 0, 0, dwRenderWidth, dwRenderHeight, 0.0f, 1.0f };
    hr = m_pD3DDevice->SetViewport( &vp );
    if( FAILED( hr ) )
        return hr;

    // Finish by setting up our scene
    return InitDeviceObjects( m_pD3DDevice );
}


/*****************************Private*Routine******************************\
* CreateCube()
*
* Sets up the vertices for a cube. Don't forget to set the texture
* coordinates for each vertex.
*
* History:
* Mon 04/10/2000 - StEstrop - Created
*
\**************************************************************************/

// work around lack of D3D_OVERLOADS :(
D3DVECTOR
MakeD3DVector( float x, float y, float z )
{
    D3DVECTOR ret;
    ret.x = x;
    ret.y = y;
    ret.z = z;
    return ret;
}

D3DVERTEX
MakeD3DVertex( const D3DVECTOR& p, const D3DVECTOR& n, float tu, float tv )
{
    D3DVERTEX ret;
    ret.x = p.x;  ret.y = p.y;  ret.z = p.z;
    ret.nx = n.x; ret.ny = n.y; ret.nz = n.z;
    ret.tu = tu; ret.tv = tv;
    return ret;

}

VOID
CreateCube(
    D3DVERTEX* pVertices
    )
{
    // Define the normals for the cube
    D3DVECTOR n0 = MakeD3DVector( 0.0f, 0.0f, 1.0f ); // Front face
    D3DVECTOR n1 = MakeD3DVector( 0.0f, 0.0f, 1.0f ); // Back face
    D3DVECTOR n2 = MakeD3DVector( 0.0f, 1.0f, 0.0f ); // Top face
    D3DVECTOR n3 = MakeD3DVector( 0.0f,-1.0f, 0.0f ); // Bottom face
    D3DVECTOR n4 = MakeD3DVector( 1.0f, 0.0f, 0.0f ); // Right face
    D3DVECTOR n5 = MakeD3DVector(-1.0f, 0.0f, 0.0f ); // Left face

    // Front face
    *pVertices++ = MakeD3DVertex( MakeD3DVector(-1.0f, 1.0f,-1.0f), n0, 0.0f, 0.0f );
    *pVertices++ = MakeD3DVertex( MakeD3DVector( 1.0f, 1.0f,-1.0f), n0, 1.0f, 0.0f );
    *pVertices++ = MakeD3DVertex( MakeD3DVector(-1.0f,-1.0f,-1.0f), n0, 0.0f, 1.0f );
    *pVertices++ = MakeD3DVertex( MakeD3DVector( 1.0f,-1.0f,-1.0f), n0, 1.0f, 1.0f );

    // Back face
    *pVertices++ = MakeD3DVertex( MakeD3DVector(-1.0f, 1.0f, 1.0f), n1, 1.0f, 0.0f );
    *pVertices++ = MakeD3DVertex( MakeD3DVector(-1.0f,-1.0f, 1.0f), n1, 1.0f, 1.0f );
    *pVertices++ = MakeD3DVertex( MakeD3DVector( 1.0f, 1.0f, 1.0f), n1, 0.0f, 0.0f );
    *pVertices++ = MakeD3DVertex( MakeD3DVector( 1.0f,-1.0f, 1.0f), n1, 0.0f, 1.0f );

    // Top face
    *pVertices++ = MakeD3DVertex( MakeD3DVector(-1.0f, 1.0f, 1.0f), n2, 0.0f, 0.0f );
    *pVertices++ = MakeD3DVertex( MakeD3DVector( 1.0f, 1.0f, 1.0f), n2, 1.0f, 0.0f );
    *pVertices++ = MakeD3DVertex( MakeD3DVector(-1.0f, 1.0f,-1.0f), n2, 0.0f, 1.0f );
    *pVertices++ = MakeD3DVertex( MakeD3DVector( 1.0f, 1.0f,-1.0f), n2, 1.0f, 1.0f );

    // Bottom face
    *pVertices++ = MakeD3DVertex( MakeD3DVector(-1.0f,-1.0f, 1.0f), n3, 0.0f, 0.0f );
    *pVertices++ = MakeD3DVertex( MakeD3DVector(-1.0f,-1.0f,-1.0f), n3, 0.0f, 1.0f );
    *pVertices++ = MakeD3DVertex( MakeD3DVector( 1.0f,-1.0f, 1.0f), n3, 1.0f, 0.0f );
    *pVertices++ = MakeD3DVertex( MakeD3DVector( 1.0f,-1.0f,-1.0f), n3, 1.0f, 1.0f );

    // Right face
    *pVertices++ = MakeD3DVertex( MakeD3DVector( 1.0f, 1.0f,-1.0f), n4, 0.0f, 0.0f );
    *pVertices++ = MakeD3DVertex( MakeD3DVector( 1.0f, 1.0f, 1.0f), n4, 1.0f, 0.0f );
    *pVertices++ = MakeD3DVertex( MakeD3DVector( 1.0f,-1.0f,-1.0f), n4, 0.0f, 1.0f );
    *pVertices++ = MakeD3DVertex( MakeD3DVector( 1.0f,-1.0f, 1.0f), n4, 1.0f, 1.0f );

    // Left face
    *pVertices++ = MakeD3DVertex( MakeD3DVector(-1.0f, 1.0f,-1.0f), n5, 1.0f, 0.0f );
    *pVertices++ = MakeD3DVertex( MakeD3DVector(-1.0f,-1.0f,-1.0f), n5, 1.0f, 1.0f );
    *pVertices++ = MakeD3DVertex( MakeD3DVector(-1.0f, 1.0f, 1.0f), n5, 0.0f, 0.0f );
    *pVertices++ = MakeD3DVertex( MakeD3DVector(-1.0f,-1.0f, 1.0f), n5, 0.0f, 1.0f );
}




/******************************Public*Routine******************************\
* InitDeviceObjects
*
* Initialize scene objects. This function sets up our scene, which is
* simply a rotating, texture-mapped cube.
*
* History:
* Mon 04/10/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CMpegMovie::InitDeviceObjects(
    LPDIRECT3DDEVICE7 pd3dDevice
    )
{
    // Generate the vertices for the cube
    CreateCube( m_pCubeVertices );


    // For simplicity, just use ambient lighting and a white material
    D3DMATERIAL7 mtrl;
    ZeroMemory( &mtrl, sizeof(mtrl) );
    mtrl.diffuse.r = mtrl.diffuse.g = mtrl.diffuse.b = 1.0f;
    mtrl.ambient.r = mtrl.ambient.g = mtrl.ambient.b = 1.0f;
    pd3dDevice->SetMaterial( &mtrl );
    pd3dDevice->SetRenderState( D3DRENDERSTATE_AMBIENT, 0xffffffff );

    // Set the projection matrix. Note that the view and world matrices are
    // set in the App_FrameMove() function, so they can be animated each
    // frame.
    D3DMATRIX matProj;
    ZeroMemory( &matProj, sizeof(D3DMATRIX) );
    matProj._11 =  2.0f;
    matProj._22 =  2.0f;
    matProj._33 =  1.0f;
    matProj._34 =  1.0f;
    matProj._43 = -1.0f;
    pd3dDevice->SetTransform( D3DTRANSFORMSTATE_PROJECTION, &matProj );

    return S_OK;
}




/*****************************Private*Routine******************************\
* App_FrameMove
*
* Called once per frame, the call is used for animating the scene. The
* device is used for changing various render states, and the timekey is
* used for timing of the dynamics of the scene.
*
* History:
* Mon 04/10/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CMpegMovie::FrameMove(
    LPDIRECT3DDEVICE7 pd3dDevice,
    FLOAT fTimeKey
    )
{
    // Set the view matrix so that the camera is backed out along the z-axis,
    // and looks down on the cube (rotating along the x-axis by -0.5 radians).
    D3DMATRIX matView;
    ZeroMemory( &matView, sizeof(D3DMATRIX) );
    matView._11 = 1.0f;
    matView._22 =  (FLOAT)cos(-0.5f);
    matView._23 =  (FLOAT)sin(-0.5f);
    matView._32 = -(FLOAT)sin(-0.5f);
    matView._33 =  (FLOAT)cos(-0.5f);
    matView._43 = 5.0f;
    matView._44 = 1.0f;
    pd3dDevice->SetTransform( D3DTRANSFORMSTATE_VIEW, &matView );

    // Set the world matrix to rotate along the y-axis, in sync with the
    // timekey
    D3DMATRIX matRotate;
    ZeroMemory( &matRotate, sizeof(D3DMATRIX) );
    matRotate._11 =  (FLOAT)cos(fTimeKey);
    matRotate._13 =  (FLOAT)sin(fTimeKey);
    matRotate._22 =  1.0f;
    matRotate._31 = -(FLOAT)sin(fTimeKey);
    matRotate._33 =  (FLOAT)cos(fTimeKey);
    matRotate._44 =  1.0f;
    pd3dDevice->SetTransform( D3DTRANSFORMSTATE_WORLD, &matRotate );

    return S_OK;
}




/*****************************Private*Routine******************************\
* Render
*
* Renders the scene. This tutorial draws textured-mapped, rotating cube.
*
* History:
* Mon 04/10/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CMpegMovie::Render(
    LPDIRECT3DDEVICE7 pd3dDevice
    )
{
    DDSURFACEDESC2 ddSurfaceDesc;
    INITDDSTRUCT(ddSurfaceDesc);
    m_lpDDTexture->GetSurfaceDesc(&ddSurfaceDesc);

    // Clear the viewport to a deep blue color
    pd3dDevice->Clear( 0, NULL, D3DCLEAR_TARGET, 0x00100010, 1.0f, 0L );

    // Begin the scene
    if( FAILED( pd3dDevice->BeginScene() ) )
        return E_FAIL;

    // Draw the front and back faces of the cube using texture 1
    pd3dDevice->SetTexture(0, m_lpDDTexture);
    pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, D3DFVF_VERTEX,
                               m_pCubeVertices+0, 4, NULL );
    pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, D3DFVF_VERTEX,
                               m_pCubeVertices+4, 4, NULL );

    // Draw the top and bottom faces of the cube using texture 2
    pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, D3DFVF_VERTEX,
                               m_pCubeVertices+8, 4, NULL );
    pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, D3DFVF_VERTEX,
                               m_pCubeVertices+12, 4, NULL );

    // Draw the left and right faces of the cube using texture 3
    pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, D3DFVF_VERTEX,
                               m_pCubeVertices+16, 4, NULL );
    pd3dDevice->DrawPrimitive( D3DPT_TRIANGLESTRIP, D3DFVF_VERTEX,
                               m_pCubeVertices+20, 4, NULL );

    // End the scene.
    pd3dDevice->EndScene();

    return S_OK;
}

/******************************Public*Routine******************************\
* AllocateSurfaceWorker
*
*
*
* History:
* Sat 04/08/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CMpegMovie::AllocateSurfaceWorker(
    DWORD dwFlags,
    LPBITMAPINFOHEADER lpHdr,
    LPDDPIXELFORMAT lpPixFmt,
    LPSIZE lpAspectRatio,
    DWORD dwMinBuffers,
    DWORD dwMaxBuffers,
    DWORD* lpdwBuffer,
    LPDIRECTDRAWSURFACE7* lplpSurface
    )
{
    LPBITMAPINFOHEADER lpHeader = lpHdr;
    if (!lpHeader) {
        DbgLog((LOG_ERROR, 1, TEXT("Can't get bitmapinfoheader from media type!!")));
        return E_INVALIDARG;
    }

    D3DDEVICEDESC7 ddDesc;
    if (FAILED(m_pD3DDevice->GetCaps(&ddDesc)))
        return NULL;

    DDSURFACEDESC2 ddsd;
    INITDDSTRUCT(ddsd);
    ddsd.dwFlags = DDSD_CAPS|DDSD_HEIGHT|DDSD_WIDTH|DDSD_PIXELFORMAT;
    ddsd.dwWidth = abs(lpHeader->biWidth);
    ddsd.dwHeight = abs(lpHeader->biHeight);
    ddsd.ddsCaps.dwCaps = DDSCAPS_VIDEOMEMORY | DDSCAPS_TEXTURE;
//  ddsd.ddsCaps.dwCaps2 = DDSCAPS2_TEXTUREMANAGE;

    ddsd.ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);

    if (lpHdr->biCompression <= BI_BITFIELDS &&
        m_DispInfo.bmiHeader.biBitCount <= lpHdr->biBitCount)
    {
        ddsd.ddpfPixelFormat.dwFourCC = BI_RGB;
        ddsd.ddpfPixelFormat.dwFlags = DDPF_RGB;
        ddsd.ddpfPixelFormat.dwRGBBitCount = lpHdr->biBitCount;

        if (dwFlags & AMAP_3D_TARGET) {
            ddsd.ddsCaps.dwCaps |= DDSCAPS_3DDEVICE;
        }
        // Store the masks in the DDSURFACEDESC
        const DWORD *pBitMasks = GetBitMasks(lpHdr);
        ASSERT(pBitMasks);
        ddsd.ddpfPixelFormat.dwRBitMask = pBitMasks[0];
        ddsd.ddpfPixelFormat.dwGBitMask = pBitMasks[1];
        ddsd.ddpfPixelFormat.dwBBitMask = pBitMasks[2];
    }
    else if (lpHdr->biCompression > BI_BITFIELDS)
    {
        ddsd.ddpfPixelFormat.dwFourCC = lpHdr->biCompression;
        ddsd.ddpfPixelFormat.dwFlags = DDPF_FOURCC;
        ddsd.ddpfPixelFormat.dwYUVBitCount = lpHdr->biBitCount;
    }
    else
    {
        DbgLog((LOG_ERROR, 1, TEXT("Supplied mediatype not suitable ")
                TEXT("for either YUV or RGB surfaces")));
        return E_FAIL;
    }

    // Adjust width and height, if the driver requires it
    DWORD dwWidth  = ddsd.dwWidth;
    DWORD dwHeight = ddsd.dwHeight;

    if (ddDesc.dpcTriCaps.dwTextureCaps & D3DPTEXTURECAPS_POW2)
    {
        for( ddsd.dwWidth=1;  dwWidth>ddsd.dwWidth;   ddsd.dwWidth<<=1 );
        for( ddsd.dwHeight=1; dwHeight>ddsd.dwHeight; ddsd.dwHeight<<=1 );
    }

    if (ddDesc.dpcTriCaps.dwTextureCaps & D3DPTEXTURECAPS_SQUAREONLY)
    {
        if( ddsd.dwWidth > ddsd.dwHeight ) ddsd.dwHeight = ddsd.dwWidth;
        else                               ddsd.dwWidth  = ddsd.dwHeight;
    }

    HRESULT hr = m_lpDDObj->CreateSurface(&ddsd, &m_lpDDTexture, NULL);

    if (SUCCEEDED(hr)) {

        m_VideoAR = *lpAspectRatio;

        m_VideoSize.cx = abs(lpHeader->biWidth);
        m_VideoSize.cy = abs(lpHeader->biHeight);

        SetRect(&m_rcDst, 0, 0, m_VideoSize.cx, m_VideoSize.cy);
        m_rcSrc = m_rcDst;

        hr = PaintDDrawSurfaceBlack(m_lpDDTexture);

        *lplpSurface = m_lpDDTexture;
        *lpdwBuffer = 1;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\rndlessplayer\app.cpp ===
/******************************Module*Header*******************************\
* Module Name: app.cpp
*
* A simple Video CD player
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/
#include <streams.h>
#include <atlbase.h>
#include <atlconv.cpp>
#include <mmreg.h>
#include <commctrl.h>

#include <initguid.h>
#include "project.h"
#include "mpgcodec.h"

#include <stdarg.h>
#include <stdio.h>

#include <initguid.h>

/* -------------------------------------------------------------------------
** Global variables that are initialized at run time and then stay constant.
** -------------------------------------------------------------------------
*/
HINSTANCE           hInst;
HICON               hIconVideoCd;
HWND                hwndApp;
HWND                g_hwndToolbar;
CCompositor         *pMpegMovie;
//CMpegMovie          *pMpegMovie;
BOOL                g_bUseThreadedGraph;
BOOL                g_bPlay = FALSE;

int                 dyToolbar;
TCHAR               g_szPerfLog[MAX_PATH];

MSR_DUMPPROC        *lpDumpProc;
MSR_CONTROLPROC     *lpControlProc;
HINSTANCE           hInstMeasure;


/* -------------------------------------------------------------------------
** True Globals - these may change during execution of the program.
** -------------------------------------------------------------------------
*/
TCHAR               g_achFileName[MAX_PATH];
DWORD               g_State = VCD_NO_CD;
LONG                lMovieOrgX, lMovieOrgY;
int                 g_TimeFormat = IDM_TIME;
HANDLE              hRenderLog = INVALID_HANDLE_VALUE;
TCHAR *		    g_szOtherStuff;
BOOL                g_IsNT;



/* -------------------------------------------------------------------------
** Constants
** -------------------------------------------------------------------------
*/
const TCHAR szClassName[] = TEXT("SJE_VCDPlayer_CLASS");
const TCHAR g_szNULL[]    = TEXT("\0");
const TCHAR g_szEmpty[]   = TEXT("");
const TCHAR g_szMovieX[]  = TEXT("MovieOriginX");
const TCHAR g_szMovieY[]  = TEXT("MovieOriginY");

/*
** these values are defined by the UI gods...
*/
const int   dxBitmap        = 16;
const int   dyBitmap        = 15;
const int   dxButtonSep     = 8;
const TCHAR g_chNULL        = TEXT('\0');
const LONG  g_Style         = WS_THICKFRAME | WS_POPUP | WS_CAPTION  |
                              WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX |
                              WS_CLIPCHILDREN;

const TBBUTTON tbButtons[DEFAULT_TBAR_SIZE] = {
    { IDX_SEPARATOR,    1,                    0,               TBSTYLE_SEP           },
    { IDX_1,            IDM_MOVIE_PLAY,       TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_2,            IDM_MOVIE_PAUSE,      TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_3,            IDM_MOVIE_STOP,       TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
//  { IDX_SEPARATOR,    2,                    0,               TBSTYLE_SEP           },
//  { IDX_4,            IDM_MOVIE_PREVTRACK,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
//  { IDX_5,            IDM_MOVIE_SKIP_BACK,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
//  { IDX_6,            IDM_MOVIE_SKIP_FORE,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
//  { IDX_7,            IDM_MOVIE_NEXTTRACK,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
//  { IDX_SEPARATOR,    3,                    0,               TBSTYLE_SEP           },
//  { IDX_9,            IDM_PERF_NEW,         TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
//  { IDX_10,           IDM_PERF_DUMP,        TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
//  { IDX_SEPARATOR,    4,                    0,               TBSTYLE_SEP           },
//  { IDX_11,           IDM_FULL_SCREEN,      TBSTATE_ENABLED, TBSTYLE_CHECK,  0, 0, 0, -1 }
};

const int CX_DEFAULT	      = 310;
const int CY_DEFAULT	      = 120;

const int CX_MOVIE_DEFAULT    = 352;
const int CY_MOVIE_DEFAULT    = 120;


void ProcessOpen();


/******************************Public*Routine******************************\
* WinMain
*
*
* Windows recognizes this function by name as the initial entry point
* for the program.  This function calls the application initialization
* routine, if no other instance of the program is running, and always
* calls the instance initialization routine.  It then executes a message
* retrieval and dispatch loop that is the top-level control structure
* for the remainder of execution.  The loop is terminated when a WM_QUIT
* message is received, at which time this function exits the application
* instance by returning the value passed by PostQuitMessage().
*
* If this function must abort before entering the message loop, it
* returns the conventional value NULL.
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
int PASCAL
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLineOld,
    int nCmdShow
    )
{
    USES_CONVERSION;
    lstrcpy(g_szPerfLog, TEXT("c:\\perfdata.log"));
    LPTSTR lpCmdLine = A2T(lpCmdLineOld);

    HRESULT hres = CoInitialize(NULL);
    if (hres == S_FALSE) {
        CoUninitialize();
    }

    if ( !hPrevInstance ) {
        if ( !InitApplication( hInstance ) ) {
            return FALSE;
        }
    }

    /*
    ** Perform initializations that apply to a specific instance
    */
    if ( !InitInstance( hInstance, nCmdShow ) ) {
        return FALSE;
    }

    /* Look for options */
    while (lpCmdLine && (*lpCmdLine == '-' || *lpCmdLine == '/')) {
        if (lpCmdLine[1] == 'T') {
            //  No threaded graph
            g_bUseThreadedGraph = TRUE;
            lpCmdLine += 2;
        } else if (lpCmdLine[1] == 'P') {
            g_bPlay = TRUE;
            lpCmdLine += 2;
        } else {
            break;
        }
        while (lpCmdLine[0] == ' ') {
            lpCmdLine++;
        }
    }

    /*
    ** Acquire and dispatch messages until a WM_QUIT message is received.
    */
    int iRet = DoMainLoop();
    QzUninitialize();
    return iRet;
}


/*****************************Private*Routine******************************\
* DoMainLoop
*
* Process the main message loop
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
int
DoMainLoop(
    void
    )
{
    MSG         msg;
    HANDLE      ahObjects[8];;
    int         cObjects;
    HACCEL      haccel = LoadAccelerators(hInst, MAKEINTRESOURCE(IDR_ACCELERATOR));

    //
    // message loop lasts until we get a WM_QUIT message
    // upon which we shall return from the function
    //

    for ( ;; ) {

        if (pMpegMovie != NULL) {
            cObjects = pMpegMovie->GetNumMovieEventHandle();

            if (cObjects) {
                CopyMemory(ahObjects, pMpegMovie->GetMovieEventHandle(),
                           sizeof(HANDLE)*cObjects);
            }
        }
        else {
            ahObjects[0] = NULL;
            cObjects = 0;
        }

        if (ahObjects[0] == NULL) {
            WaitMessage();
        }
        else {

            //
            // wait for any message sent or posted to this queue
            // or for a graph notification
            //
            DWORD result;

            result = MsgWaitForMultipleObjects(cObjects, ahObjects, FALSE,
                                               INFINITE, QS_ALLINPUT);
            if (result != (WAIT_OBJECT_0 + cObjects)) {

                VideoCd_OnGraphNotify(result - WAIT_OBJECT_0);

                continue;
            }
        }

        //
        // When here, we either have a message or no event handle
        // has been created yet.
        //
        // read all of the messages in this next loop
        // removing each message as we read it
        //

        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {

            if (msg.message == WM_QUIT) {
                return (int) msg.wParam;
            }

            if (!TranslateAccelerator(hwndApp, haccel, &msg)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }

} // DoMainLoop


//
// InitAboutString
//
// Obtains the version information from the binary file. Note that if
// we fail we just return. The template for the about dialog has a
// "Version not available" as default.
//
TCHAR *InitAboutString()
{
    //
    // Find the version of this binary
    //
    TCHAR achFileName[128];
    if ( !GetModuleFileName(hInst, achFileName, sizeof(achFileName)) )
        return((TCHAR *)g_szEmpty);

    DWORD dwTemp;
    DWORD dwVerSize = GetFileVersionInfoSize( achFileName, &dwTemp );
    if ( !dwVerSize)
        return((TCHAR *)g_szEmpty);

    HLOCAL hTemp = LocalAlloc( LHND, dwVerSize );
    if (!hTemp)
        return((TCHAR *)g_szEmpty);

    LPVOID lpvVerBuffer = LocalLock( hTemp );
    if (!lpvVerBuffer) {
        LocalFree( hTemp );
        return((TCHAR *)g_szEmpty);
    }

    if ( !GetFileVersionInfo( achFileName, 0L, dwVerSize, lpvVerBuffer ) ) {
        LocalUnlock( hTemp );
        LocalFree( hTemp );
        return((TCHAR *)g_szEmpty);
    }

    // "040904E4" is the code page for US English (Andrew believes).
    LPVOID lpvValue;
    UINT uLen;
    if (VerQueryValue( lpvVerBuffer,
                   TEXT("\\StringFileInfo\\040904E4\\ProductVersion"),
                   (LPVOID *) &lpvValue, &uLen)) {

        //
        // Get creation date of executable (date of build)
        //
        WIN32_FIND_DATA FindFileData;
        HANDLE hFind = FindFirstFile(achFileName, &FindFileData);
        ASSERT(hFind != INVALID_HANDLE_VALUE);
        FindClose(hFind);

        FILETIME ModTime = FindFileData.ftLastWriteTime;
        SYSTEMTIME SysTime;
        FileTimeToSystemTime(&ModTime,&SysTime);
        char szBuildDate[20];
        sprintf(szBuildDate, " - Build: %2.2u%2.2u%2.2u",
              SysTime.wYear % 100, SysTime.wMonth, SysTime.wDay);
        strcat((LPSTR) lpvValue, szBuildDate);
    }

    TCHAR *szAbout = (TCHAR *) _strdup((LPSTR) lpvValue);

    LocalUnlock( hTemp );
    LocalFree( hTemp );

    return(szAbout);
}


/*****************************Private*Routine******************************\
* InitApplication(HANDLE)
*
* This function is called at initialization time only if no other
* instances of the application are running.  This function performs
* initialization tasks that can be done once for any number of running
* instances.
*
* In this case, we initialize a window class by filling out a data
* structure of type WNDCLASS and calling the Windows RegisterClass()
* function.  Since all instances of this application use the same window
* class, we only need to do this when the first instance is initialized.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
InitApplication(
    HINSTANCE hInstance
    )
{
    WNDCLASS  wc;

    hInstMeasure = LoadLibraryA("measure.dll");
    if (hInstMeasure) {
        *(FARPROC *)&lpDumpProc = GetProcAddress(hInstMeasure, "Msr_Dump");
        *(FARPROC *)&lpControlProc = GetProcAddress(hInstMeasure, "Msr_Control");
    }

    /*
    ** Fill in window class structure with parameters that describe the
    ** main window.
    */
    hIconVideoCd     = LoadIcon( hInstance, MAKEINTRESOURCE(IDR_VIDEOCD_ICON) );

    wc.style         = CS_VREDRAW | CS_HREDRAW;
    wc.lpfnWndProc   = VideoCdWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = hIconVideoCd;
    wc.hCursor       = LoadCursor( NULL, IDC_ARROW );
    wc.hbrBackground = (HBRUSH)NULL; // (COLOR_BTNFACE + 1);
    wc.lpszMenuName  = MAKEINTRESOURCE( IDR_MAIN_MENU);
    wc.lpszClassName = szClassName;

    OSVERSIONINFO OSVer;
    OSVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    BOOL bRet = GetVersionEx((LPOSVERSIONINFO) &OSVer);
    ASSERT(bRet);

    g_IsNT = (OSVer.dwPlatformId == VER_PLATFORM_WIN32_NT);

    g_szOtherStuff = InitAboutString();

    /*
    ** Register the window class and return success/failure code.
    */
    return RegisterClass( &wc );

}


/*****************************Private*Routine******************************\
* InitInstance
*
*
* This function is called at initialization time for every instance of
* this application.  This function performs initialization tasks that
* cannot be shared by multiple instances.
*
* In this case, we save the instance handle in a static variable and
* create and display the main program window.
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
InitInstance(
    HINSTANCE hInstance,
    int nCmdShow
    )
{
    HWND    hwnd;
    RECT    rc;
    POINT   pt;

    /*
    ** Save the instance handle in static variable, which will be used in
    ** many subsequence calls from this application to Windows.
    */
    hInst = hInstance;

    if ( ! LoadWindowPos(&rc))
       rc.left = rc.top = CW_USEDEFAULT;

    /*
    ** Create a main window for this application instance.
    */
    hwnd = CreateWindow( szClassName, IdStr(STR_APP_TITLE), g_Style,
                         rc.left, rc.top,
                         rc.right - rc.left, rc.bottom - rc.top,
                         NULL, NULL, hInstance, NULL );

    /*
    ** If window could not be created, return "failure"
    */
    if ( NULL == hwnd ) {
        return FALSE;
    }


    hwndApp = hwnd;

    pt.x = lMovieOrgX =  ProfileIntIn(g_szMovieX, 0);
    pt.y = lMovieOrgY =  ProfileIntIn(g_szMovieY, 0);

    // if we fail to get the working area (screen-tray), then assume
    // the screen is 640x480
    //
    if (!SystemParametersInfo(SPI_GETWORKAREA, 0, &rc, FALSE)) {
        rc.top = rc.left = 0;
        rc.right = 640;
        rc.bottom = 480;
    }

    if (!PtInRect(&rc, pt)) {
        lMovieOrgX = lMovieOrgY = 0L;
    }


    /*
    ** Make the window visible; update its client area; and return "success"
    */
    SetPlayButtonsEnableState();
    ShowWindow( hwnd, nCmdShow );
    UpdateWindow( hwnd );

    ProcessOpen();

    return TRUE;
}

/*****************************Private*Routine******************************\
* GetMoviePosition
*
* Place the movie in the centre of the client window.  We do not stretch the
* the movie yet !
*
* History:
* Fri 03/03/2000 - StEstrop - Created
*
\**************************************************************************/
void
GetMoviePosition(
    HWND hwnd,
    long* xPos,
    long* yPos,
    long* pcx,
    long* pcy
    )
{

    RECT rc;

    GetClientRect(hwnd, &rc);

    *xPos = rc.left;
    *yPos = rc.top;

    *pcx = rc.right - rc.left;
    *pcy = rc.bottom - rc.top;
}


void
RepositionMovie(HWND hwnd)
{
    if (pMpegMovie) {
        long xPos, yPos, cx, cy;
        GetMoviePosition(hwnd, &xPos, &yPos, &cx, &cy);
        pMpegMovie->PutMoviePosition(xPos, yPos, cx, cy);
        InvalidateRect(hwnd, NULL, false);
        UpdateWindow(hwnd);
    }
}

void
VideoCd_OnMove(
    HWND hwnd,
    int x,
    int y
    )
{
    RepositionMovie(hwnd);
}


/******************************Public*Routine******************************\
* VideoCdWndProc
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
LRESULT CALLBACK
VideoCdWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch ( message ) {

    HANDLE_MSG( hwnd, WM_CREATE,            VideoCd_OnCreate );
    HANDLE_MSG( hwnd, WM_PAINT,             VideoCd_OnPaint );
    HANDLE_MSG( hwnd, WM_COMMAND,           VideoCd_OnCommand );
    HANDLE_MSG( hwnd, WM_CLOSE,             VideoCd_OnClose );
    HANDLE_MSG( hwnd, WM_QUERYENDSESSION,   VideoCd_OnQueryEndSession );
    HANDLE_MSG( hwnd, WM_DESTROY,           VideoCd_OnDestroy );
    HANDLE_MSG( hwnd, WM_SIZE,              VideoCd_OnSize );
    HANDLE_MSG( hwnd, WM_SYSCOLORCHANGE,    VideoCd_OnSysColorChange );
    HANDLE_MSG( hwnd, WM_INITMENUPOPUP,     VideoCd_OnInitMenuPopup );
    HANDLE_MSG( hwnd, WM_NOTIFY,            VideoCd_OnNotify );
    HANDLE_MSG( hwnd, WM_KEYUP,             VideoCd_OnKeyUp);
    HANDLE_MSG( hwnd, WM_MOVE,              VideoCd_OnMove );

    default:
        return DefWindowProc(hwnd, message, wParam, lParam);
    }

    return 0L;
}


/*****************************Private*Routine******************************\
* VideoCd_OnCreate
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
VideoCd_OnCreate(
    HWND hwnd,
    LPCREATESTRUCT lpCreateStruct
    )
{
    RECT rc;
    int Pane[2];

    InitCommonControls();

    /*
    ** Create the toolbar and statusbar.
    */
    g_hwndToolbar = CreateToolbarEx( hwnd,
                                     WS_VISIBLE | WS_CHILD |
                                     TBSTYLE_TOOLTIPS | CCS_NODIVIDER,
                                     ID_TOOLBAR, NUMBER_OF_BITMAPS,
                                     hInst, IDR_TOOLBAR, tbButtons,
                                     DEFAULT_TBAR_SIZE, dxBitmap, dyBitmap,
                                     dxBitmap, dyBitmap, sizeof(TBBUTTON) );

    if ( g_hwndToolbar == NULL ) {
        return FALSE;
    }

    return TRUE;
}

/*****************************Private*Routine******************************\
* VideoCd_OnKeyUp
*
*
*
* History:
* 23/3/1996 - AnthonyP - Created
*
\**************************************************************************/
void
VideoCd_OnKeyUp(
    HWND hwnd,
    UINT vk,
    BOOL fDown,
    int cRepeat,
    UINT flags
    )
{
    // Catch escape sequences to stop fullscreen mode

    if (vk == VK_ESCAPE) {
        if (pMpegMovie) {
            SetPlayButtonsEnableState();
        }
    }
}



/*****************************Private*Routine******************************\
* VideoCd_OnPaint
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnPaint(
    HWND hwnd
    )
{
    PAINTSTRUCT ps;
    HDC         hdc;
    RECT        rc1;
    RECT        rc2;

    /*
    ** Draw a frame around the movie playback area.
    */
    GetClientRect(hwnd, &rc2);


    hdc = BeginPaint( hwnd, &ps );

    if (pMpegMovie) {

        long xPos, yPos, cx, cy;
        GetMoviePosition(hwnd, &xPos, &yPos, &cx, &cy);
        SetRect(&rc1, xPos, yPos, xPos + cx, yPos + cy);

        HRGN rgnClient = CreateRectRgnIndirect(&rc2);
        HRGN rgnVideo  = CreateRectRgnIndirect(&rc1);
        CombineRgn(rgnClient, rgnClient, rgnVideo, RGN_DIFF);

        HBRUSH hbr = GetSysColorBrush(COLOR_BTNFACE);
        FillRgn(hdc, rgnClient, hbr);
        DeleteObject(hbr);
    }
    else {
        FillRect(hdc, &rc2, (HBRUSH)(COLOR_BTNFACE + 1));
    }

    EndPaint( hwnd, &ps );
}


/*****************************Private*Routine******************************\
* VideoCd_OnCommand
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnCommand(
    HWND hwnd,
    int id,
    HWND hwndCtl,
    UINT codeNotify
    )
{
    switch (id) {

    case IDM_FILE_EXIT:
        PostMessage( hwnd, WM_CLOSE, 0, 0L );
        break;

    case IDM_MOVIE_PLAY:
        VcdPlayerPlayCmd();
        break;

    case IDM_MOVIE_STOP:
        VcdPlayerStopCmd();
        break;

    case IDM_MOVIE_PAUSE:
        VcdPlayerPauseCmd();
        break;

    case IDM_PERF_NEW:
        if (lpControlProc) (*lpControlProc)(MSR_RESET_ALL);
        break;

    case IDM_PERF_DUMP:
        if (lpDumpProc) {

            HANDLE hFile;
            hFile = CreateFile(g_szPerfLog, GENERIC_WRITE, 0, NULL,
                               CREATE_ALWAYS, 0, NULL);
            (*lpDumpProc)(hFile);
            CloseHandle(hFile);
        }
        break;

    case IDM_HELP_ABOUT:
        {
            TCHAR  szApp[STR_MAX_STRING_LEN];
            TCHAR  szOtherStuff[STR_MAX_STRING_LEN];

            lstrcpy( szApp, IdStr(STR_APP_TITLE) );
            lstrcat( szApp, TEXT("#") );
            if (g_IsNT)
		lstrcat( szApp, TEXT("Windows NT") );
	    // for some reason ShellAbout prints OS uner Win95 but not NT
	    // else
	    //	strcat( szApp, "Windows 95" );
            lstrcpy( szOtherStuff, IdStr(STR_APP_TITLE) );
            lstrcat( szOtherStuff, TEXT("\n") );
            lstrcat( szOtherStuff, g_szOtherStuff );
            ShellAbout( hwnd, szApp, szOtherStuff, hIconVideoCd );
        }
        break;
    }

    SetPlayButtonsEnableState();
}




/******************************Public*Routine******************************\
* VideoCd_OnDestroy
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnDestroy(
    HWND hwnd
    )
{
    PostQuitMessage( 0 );
}




/******************************Public*Routine******************************\
* VideoCd_OnClose
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnClose(
    HWND hwnd
    )
{
    VcdPlayerCloseCmd();
    ProfileIntOut(g_szMovieX, lMovieOrgX);
    ProfileIntOut(g_szMovieY, lMovieOrgY);

    SaveWindowPos( hwnd );
    DestroyWindow( hwnd );
}

BOOL
VideoCd_OnQueryEndSession(
    HWND hwnd
    )
{
    SaveWindowPos( hwnd );
    return TRUE;
}


/******************************Public*Routine******************************\
* VideoCd_OnSize
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnSize(
    HWND hwnd,
    UINT state,
    int dx,
    int dy
    )
{
    if (IsWindow(g_hwndToolbar)) {
        SendMessage( g_hwndToolbar, WM_SIZE, 0, 0L );
    }

    RepositionMovie(hwnd);
}


/*****************************Private*Routine******************************\
* VideoCd_OnSysColorChange
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnSysColorChange(
    HWND hwnd
    )
{
    FORWARD_WM_SYSCOLORCHANGE(g_hwndToolbar, SendMessage);
}




/*****************************Private*Routine******************************\
* VideoCd_OnInitMenuPopup
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnInitMenuPopup(
    HWND hwnd,
    HMENU hMenu,
    UINT item,
    BOOL fSystemMenu
    )
{
    UINT uFlags;

    if (item == 0) { // File menu

        if (g_State & (VCD_IN_USE | VCD_NO_CD | VCD_DATA_CD_LOADED)) {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        EnableMenuItem(hMenu, IDM_FILE_CLOSE, uFlags );

        if (lpControlProc == NULL) {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        EnableMenuItem(hMenu, IDM_FILE_SET_PERF_LOG, uFlags );
    }
}


/*****************************Private*Routine******************************\
* VideoCd_OnGraphNotify
*
* This is where we get any notifications from the filter graph.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnGraphNotify(
    int stream
    )
{
    long    lEventCode;
    HDC     hdc;

    lEventCode = pMpegMovie->GetMovieEventCode(stream);
    switch (lEventCode) {
    case EC_FULLSCREEN_LOST:
        SetPlayButtonsEnableState();
        break;

    case EC_COMPLETE:
        pMpegMovie->RestartStream(stream);
        break;

    case EC_USERABORT:
    case EC_ERRORABORT:
        VcdPlayerStopCmd();
        SetPlayButtonsEnableState();
        break;

    default:
        break;
    }
}


/*****************************Private*Routine******************************\
* VideoCd_OnNotify
*
* This is where we get the text for the little tooltips
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
LRESULT
VideoCd_OnNotify(
    HWND hwnd,
    int idFrom,
    NMHDR FAR* pnmhdr
    )
{
    switch (pnmhdr->code) {

    case TTN_NEEDTEXT:
        {
            LPTOOLTIPTEXT   lpTt;

            lpTt = (LPTOOLTIPTEXT)pnmhdr;
            LoadString( hInst, (UINT) lpTt->hdr.idFrom, lpTt->szText,
                        sizeof(lpTt->szText) );
        }
        break;
    }

    return 0;
}


/******************************Public*Routine******************************\
* SetPlayButtonsEnableState
*
* Sets the play buttons enable state to match the state of the current
* cdrom device.  See below...
*
*
*                 VCD Player buttons enable state table
* Ŀ
* E=Enabled D=Disabled       Play  Pause  Eject  Stop   Other 
* Ĵ
* Disk in use                 D     D      D       D      D   
* Ĵ
* No video cd or data cdrom   D     D      E       D      D   
* Ĵ
* Video cd (playing)          D     E      E       E      E   
* Ĵ
* Video cd (paused)           E     D      E       E      E   
* Ĵ
* Video cd (stopped)          E     D      E       D      E   
* 
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
SetPlayButtonsEnableState(
    void
    )
{
    BOOL    fEnable, fPress;
    BOOL    fVideoCdLoaded;

    /*
    ** Do we have a video cd loaded.
    */
    if (g_State & (VCD_NO_CD | VCD_DATA_CD_LOADED | VCD_IN_USE)) {
        fVideoCdLoaded = FALSE;
    }
    else {
        fVideoCdLoaded = TRUE;
    }


    /*
    ** Do the play button
    */
    if ( fVideoCdLoaded
      && ((g_State & VCD_STOPPED) || (g_State & VCD_PAUSED))) {

        fEnable = TRUE;
    }
    else {
        fEnable = FALSE;
    }
    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON, IDM_MOVIE_PLAY, fEnable );


    /*
    ** Do the stop button
    */
    if ( fVideoCdLoaded
      && ((g_State & VCD_PLAYING) || (g_State & VCD_PAUSED))) {

        fEnable = TRUE;
    }
    else {
        fEnable = FALSE;
    }
    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON, IDM_MOVIE_STOP, fEnable );


    /*
    ** Do the pause button
    */
    if ( fVideoCdLoaded && (g_State & VCD_PLAYING) ) {
        fEnable = TRUE;
    }
    else {
        fEnable = FALSE;
    }
    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON, IDM_MOVIE_PAUSE, fEnable );


    /*
    ** Do the remaining buttons
    */

    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON,
                 IDM_MOVIE_SKIP_FORE, fVideoCdLoaded );

    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON,
                 IDM_MOVIE_SKIP_BACK, fVideoCdLoaded );

    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON,
                 IDM_MOVIE_NEXTTRACK, fVideoCdLoaded );

    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON,
                 IDM_MOVIE_PREVTRACK, fVideoCdLoaded );

    //
    // do "new log" and "dump log" buttons
    //
    SendMessage( g_hwndToolbar, TB_HIDEBUTTON,
                 IDM_PERF_NEW, lpControlProc == NULL);

    SendMessage( g_hwndToolbar, TB_HIDEBUTTON,
                 IDM_PERF_DUMP, lpDumpProc == NULL);
}


/*****************************Private*Routine******************************\
* GetAdjustedClientRect
*
* Calculate the size of the client rect and then adjusts it to take into
* account the space taken by the toolbar and status bar.
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
GetAdjustedClientRect(
    RECT *prc
    )
{
    RECT    rcTool;

    GetClientRect(hwndApp, prc);

    GetWindowRect(g_hwndToolbar, &rcTool);
    prc->top += (rcTool.bottom - rcTool.top);
}


/******************************Public*Routine******************************\
* IdStr
*
* Loads the given string resource ID into the passed storage.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
LPCTSTR
IdStr(
    int idResource
    )
{
    static TCHAR    chBuffer[ STR_MAX_STRING_LEN ];

    if (LoadString(hInst, idResource, chBuffer, STR_MAX_STRING_LEN) == 0) {
        return g_szEmpty;
    }

    return chBuffer;

}

/*+ GetAppKey
 *
 *-=================================================================*/

static TCHAR cszWindow[] = TEXT("Window");
static TCHAR cszAppKey[] = TEXT("Software\\Microsoft\\Multimedia Tools\\VCDPlayer");

HKEY
GetAppKey(
    BOOL fCreate
    )
{
    HKEY hKey = 0;

    if (fCreate) {
       if (RegCreateKey(HKEY_CURRENT_USER, cszAppKey, &hKey) == ERROR_SUCCESS)
          return hKey;
    }
    else {
       if (RegOpenKey(HKEY_CURRENT_USER, cszAppKey, &hKey) == ERROR_SUCCESS)
          return hKey;
    }

    return NULL;
}

/*+ ProfileIntIn
 *
 *-=================================================================*/

int
ProfileIntIn(
    const TCHAR *szKey,
    int iDefault
    )
{
    DWORD dwType;
    int   iValue;
    BYTE  aData[20];
    DWORD cb;
    HKEY  hKey;

    if (!(hKey = GetAppKey(TRUE))) {
        return iDefault;
    }

    *(UINT *)&aData = 0;
    cb = sizeof(aData);

    if (RegQueryValueEx (hKey, szKey, NULL, &dwType, aData, &cb)) {
       iValue = iDefault;
    }
    else {

        if (dwType == REG_DWORD || dwType == REG_BINARY) {
            iValue = *(int *)&aData;
        }
#ifdef UNICODE
        else if (dwType == REG_SZ) {
            iValue = atoiW((LPWSTR)aData);
        }
#else
        else if (dwType == REG_SZ) {
            iValue = atoiA((LPTTR)aData);
        }
#endif
    }

    RegCloseKey (hKey);
    return iValue;
}


/*+ ProfileIntOut
 *
 *-=================================================================*/

BOOL
ProfileIntOut (
    const TCHAR *szKey,
    int iVal
    )
{
    HKEY  hKey;
    BOOL  bRet = FALSE;

    hKey = GetAppKey(TRUE);
    if (hKey) {
        RegSetValueEx(hKey, szKey, 0, REG_DWORD, (LPBYTE)&iVal, sizeof(DWORD));
        RegCloseKey (hKey);
        bRet = TRUE;
    }
    return bRet;
}


/*+ ProfileString
 *
 *-=================================================================*/

UINT
ProfileStringIn (
    LPTSTR  szKey,
    LPTSTR  szDef,
    LPTSTR  sz,
    DWORD   cb
    )
{
    HKEY  hKey;
    DWORD dwType;

    if (!(hKey = GetAppKey (FALSE)))
    {
        lstrcpy (sz, szDef);
        return lstrlen (sz);
    }

    if (RegQueryValueEx(hKey, szKey, NULL, &dwType, (LPBYTE)sz, &cb) || dwType != REG_SZ)
    {
        lstrcpy (sz, szDef);
        cb = lstrlen (sz);
    }

    RegCloseKey (hKey);
    return cb;
}

void
ProfileStringOut (
    LPTSTR  szKey,
    LPTSTR  sz
    )
{
    HKEY  hKey;

    hKey = GetAppKey(TRUE);
    if (hKey)
        RegSetValueEx(hKey, szKey, 0, REG_SZ, (LPBYTE)sz,
                      sizeof(TCHAR) * (lstrlen(sz)+1));

    RegCloseKey (hKey);
}


/*+ LoadWindowPos
 *
 * retrieve the window position information from dragn.ini
 *
 *-=================================================================*/

#ifndef SPI_GETWORKAREA
 #define SPI_GETWORKAREA 48  // because NT doesnt have this define yet
#endif

BOOL
LoadWindowPos(
    LPRECT lprc
    )
{
    static RECT rcDefault = {0,0,CX_DEFAULT,CY_DEFAULT};
    RECT  rcScreen;
    RECT  rc;
    HKEY  hKey = GetAppKey(FALSE);

    // read window placement from the registry.
    //
    *lprc = rcDefault;
    if (hKey)
    {
        DWORD cb;
        DWORD dwType;

        cb = sizeof(rc);
        if ( ! RegQueryValueEx(hKey, cszWindow, NULL, &dwType, (LPBYTE)&rc, &cb)
            && dwType == REG_BINARY && cb == sizeof(RECT))
        {
            *lprc = rc;
        }

        RegCloseKey (hKey);
    }

    // if we fail to get the working area (screen-tray), then assume
    // the screen is 640x480
    //
    if ( ! SystemParametersInfo(SPI_GETWORKAREA, 0, &rcScreen, FALSE))
    {
        rcScreen.top = rcScreen.left = 0;
        rcScreen.right = 640;
        rcScreen.bottom = 480;
    }

    // if the proposed window position is outside the screen,
    // use the default placement
    //
    if ( ! IntersectRect(&rc, &rcScreen, lprc)) {
        *lprc = rcDefault;
    }

    return ! IsRectEmpty (lprc);
}


/*+ SaveWindowPos
 *
 * store the window position information in dragn.ini
 *
 *-=================================================================*/

BOOL
SaveWindowPos(
    HWND hwnd
    )
{
    WINDOWPLACEMENT wpl;
    HKEY  hKey = GetAppKey(TRUE);

    if (!hKey) {
       return FALSE;
    }

    // save the current size and position of the window to the registry
    //
    ZeroMemory (&wpl, sizeof(wpl));
    wpl.length = sizeof(wpl);
    GetWindowPlacement (hwnd, &wpl);


    RegSetValueEx( hKey, cszWindow, 0, REG_BINARY,
                   (LPBYTE)&wpl.rcNormalPosition,
                   sizeof(wpl.rcNormalPosition));

    RegCloseKey (hKey);
    return TRUE;
}


/*****************************Private*Routine******************************\
* FormatRefTime
*
* Formats the given RefTime into the passed in character buffer,
* returns a pointer to the character buffer.
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
TCHAR *
FormatRefTime(
    TCHAR *sz,
    REFTIME rt
    )
{
    int hrs, mins, secs;

    rt += 0.49;

    hrs  =  (int)rt / 3600;
    mins = ((int)rt % 3600) / 60;
    secs = ((int)rt % 3600) % 60;

    wsprintf(sz, TEXT("%02d:%02d:%02d h:m:s"),hrs, mins, secs);

#if 0
#ifdef UNICODE
    swprintf(sz, L"%02d:%02d:%02d h:m:s", rt);
#else
    sprintf(sz, "%02d:%02d:%02d h:m:s", hrs, mins, secs);
#endif
#endif


    return sz;
}

const TCHAR quartzdllname[] = TEXT("quartz.dll");
#ifdef UNICODE
const char  amgeterrorprocname[] = "AMGetErrorTextW";
#else
const char  amgeterrorprocname[] = "AMGetErrorTextA";
#endif

BOOL GetAMErrorText(HRESULT hr, TCHAR *Buffer, DWORD dwLen)
{
    HMODULE hInst = GetModuleHandle(quartzdllname);
    if (hInst) {
        AMGETERRORTEXTPROC lpProc;
        *((FARPROC *)&lpProc) = GetProcAddress(hInst, amgeterrorprocname);
        if (lpProc) {
            return 0 != (*lpProc)(hr, Buffer, dwLen);
        }
    }
    return FALSE;
}


/******************************Public*Routine******************************\
* ProcessOpen
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
ProcessOpen(
    )
{
    /*
    ** If we currently have a video loaded we need to discard it here.
    */
    if ( g_State & VCD_LOADED) {
        VcdPlayerCloseCmd();
    }

    pMpegMovie = new CCompositor(hwndApp);
    if (pMpegMovie) {

        HRESULT hr = pMpegMovie->OpenComposition();
        if (SUCCEEDED(hr)) {

            g_State = (VCD_LOADED | VCD_STOPPED);
            RepositionMovie(hwndApp);
            InvalidateRect(hwndApp, NULL, FALSE);

        }
        else {
            TCHAR Buffer[MAX_ERROR_TEXT_LEN];

            if (GetAMErrorText(hr, Buffer, MAX_ERROR_TEXT_LEN)) {
                MessageBox( hwndApp, Buffer,
                            IdStr(STR_APP_TITLE), MB_OK );
            }
            else {
                MessageBox( hwndApp,
                            TEXT("Failed to open the movie; ")
                            TEXT("either the file was not found or ")
                            TEXT("the wave device is in use"),
                            IdStr(STR_APP_TITLE), MB_OK );
            }

            pMpegMovie->CloseComposition();
            delete pMpegMovie;
            pMpegMovie = NULL;
        }
    }

    InvalidateRect( hwndApp, NULL, FALSE );
    UpdateWindow( hwndApp );
    SetPlayButtonsEnableState();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\rndlessplayer\commands.cpp ===
/******************************Module*Header*******************************\
* Module Name: commands.cpp
*
*  Processes commands from the user.
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/
#include <streams.h>
#include <mmreg.h>
#include <commctrl.h>

#include "project.h"
#include "mpgcodec.h"
#include <stdio.h>


BOOL GetAMErrorText(HRESULT hr, TCHAR *Buffer, DWORD dwLen);

extern CCompositor *pMpegMovie;

/******************************Public*Routine******************************\
* VcdPlayerOpenCmd
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
VcdPlayerOpenCmd(
    void
    )
{
    return TRUE;
}


/******************************Public*Routine******************************\
* VcdPlayerCloseCmd
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
VcdPlayerCloseCmd(
    void
    )
{
    if (pMpegMovie) {

        LONG cx, cy;

        g_State = VCD_NO_CD;
        pMpegMovie->StopMovie();
        pMpegMovie->CloseComposition();

        delete pMpegMovie;
        pMpegMovie = NULL;
    }
    InvalidateRect( hwndApp, NULL, FALSE );
    UpdateWindow( hwndApp );
    return TRUE;
}

/******************************Public*Routine******************************\
* VcdPlayerPlayCmd
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
VcdPlayerPlayCmd(
    void
    )
{
    BOOL fStopped = (g_State & VCD_STOPPED);
    BOOL fPaused  = (g_State & VCD_PAUSED);

    if ( (fStopped || fPaused) ) {

        // HDC hdc;
        // RECT rc;


        //
        // Clear out the old stats from the main window
        //
        // hdc = GetDC(hwndApp);
        // GetAdjustedClientRect(&rc);
        // FillRect(hdc, &rc, (HBRUSH)(COLOR_BTNFACE + 1));
        // ReleaseDC(hwndApp, hdc);

        if (pMpegMovie) {
            pMpegMovie->PlayMovie();
        }

        g_State &= ~(fStopped ? VCD_STOPPED : VCD_PAUSED);
        g_State |= VCD_PLAYING;
    }

    return TRUE;
}


/******************************Public*Routine******************************\
* VcdPlayerStopCmd
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
VcdPlayerStopCmd(
    void
    )
{
    BOOL fPlaying = (g_State & VCD_PLAYING);
    BOOL fPaused  = (g_State & VCD_PAUSED);

    if ( (fPlaying || fPaused) ) {

        if (pMpegMovie) {
            pMpegMovie->StopMovie();
        }

        g_State &= ~(fPlaying ? VCD_PLAYING : VCD_PAUSED);
        g_State |= VCD_STOPPED;
    }
    return TRUE;
}


/******************************Public*Routine******************************\
* VcdPlayerPauseCmd
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
VcdPlayerPauseCmd(
    void
    )
{
    BOOL fPlaying = (g_State & VCD_PLAYING);
    BOOL fPaused  = (g_State & VCD_PAUSED);

    if (fPlaying) {

        if (pMpegMovie) {
            pMpegMovie->PauseMovie();
        }

        g_State &= ~VCD_PLAYING;
        g_State |= VCD_PAUSED;
    }
    else if (fPaused) {

        if (pMpegMovie) {
            pMpegMovie->PlayMovie();
        }

        g_State &= ~VCD_PAUSED;
        g_State |= VCD_PLAYING;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\rndlessplayer\project.h ===
/******************************Module*Header*******************************\
* Module Name: project.h
*
*  Master header file that includes all the other header files used by the
* project.  This enables compiled headers to work using build.
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1996  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/

#include "app.h"
#include "vcdplyer.h"
#include "resource.h"


#include "..\inc\AllocLib.h"
#include "..\inc\MediaSType.h"

DEFINE_GUID(IID_IDirectDraw7,
            0x15e65ec0,0x3b9c,0x11d2,0xb9,0x2f,0x00,0x60,0x97,0x97,0xea,0x5b);
#if 0
DEFINE_GUID( IID_IDirect3D7,            0xf5049e77,0x4861,0x11d2,0xa4,0x7,0x0,0xa0,0xc9,0x6,0x29,0xa8);
DEFINE_GUID( IID_IDirect3DRGBDevice,    0xA4665C60,0x2673,0x11CF,0xA3,0x1A,0x00,0xAA,0x00,0xB9,0x33,0x56 );
DEFINE_GUID( IID_IDirect3DHALDevice,    0x84E63dE0,0x46AA,0x11CF,0x81,0x6F,0x00,0x00,0xC0,0x20,0x15,0x6E );
#endif


// {B87BEB7B-8D29-423f-AE4D-6582C10175AC}
DEFINE_GUID(CLSID_VideoMixingRenderer,
0xb87beb7b, 0x8d29, 0x423f, 0xae, 0x4d, 0x65, 0x82, 0xc1, 0x1, 0x75, 0xac);

// { fd501041-8ebe-11ce-8183-00aa00577da1 }
DEFINE_GUID(CLSID_BouncingBall,
0xfd501041, 0x8ebe, 0x11ce, 0x81, 0x83, 0x00, 0xaa, 0x00, 0x57, 0x7d, 0xa1);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\rndlessplayer\compositor.h ===
/******************************Module*Header*******************************\
* Module Name: Compositor.h
*
* Creates and manages the composition of 3 DShow FG's.
* The 1st movie is used as a background and must use a H/W overlay, not that
* we draw the color key.
* The other 2 movies are used as textures onto the faces of a rotating cube,
* which is then stretch Blt'ed to opposite corners of the playback window.
*
* Created: Mon 04/17/2000
* Author:  Stephen Estrop [StEstrop]
*
* Copyright (c) 2000 Microsoft Corporation
\**************************************************************************/

#ifndef __INC_COMPOSITOR_H__
#define __INC_COMPOSITOR_H__

class CCompositor  {


public:
    LONG                GetMovieEventCode(int stream);
    int                 GetNumMovieEventHandle();
    HANDLE*             GetMovieEventHandle();

    HRESULT             PlayMovie();
    HRESULT             PauseMovie();
    HRESULT             StopMovie();

    HRESULT             PutMoviePosition(int xPos, int yPos, int cx, int cy);

    HRESULT             OpenComposition();
    HRESULT             CloseComposition();

    HRESULT             RestartStream(int stream);

    CCompositor(HWND hwndApp) :
        m_hwnd(hwndApp), m_pBackground(NULL), m_pCube1(NULL), m_pCube2(NULL)
    {
    };

private:
    HWND                m_hwnd;

    CMpegMovie*         m_pBackground;
    CMpegMovie*         m_pCube1;
    CMpegMovie*         m_pCube2;

    HANDLE              m_Handles[3];

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\rndlessplayer\mpgcodec.h ===
// Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
#include <mpegtype.h>   // IMpegAudioDecoder

typedef struct {
    LONG           lWidth;             //  Native Width in pixels
    LONG           lHeight;            //  Native Height in pixels
    LONG           lvbv;               //  vbv
    REFERENCE_TIME PictureTime;        //  Time per picture in 100ns units
    LONG           lTimePerFrame;      //  Time per picture in MPEG units
    LONG           dwBitRate;          //  Bits per second
    LONG           lXPelsPerMeter;     //  Pel aspect ratio
    LONG           lYPelsPerMeter;     //  Pel aspect ratio
    DWORD          dwStartTimeCode;    //  First GOP time code (or -1)
    LONG           lActualHeaderLen;   //  Length of valid bytes in raw seq hdr
    BYTE           RawHeader[140];     //  The real sequence header
} SEQHDR_INFO;


#define DECODE_I        0x0001L
#define DECODE_IP       0x0003L
#define DECODE_IPB      0x0007L     // Normal B Frame
#define DECODE_IPB1     0x000FL     // Decode 1 out of 4 B frames
#define DECODE_IPB2     0x0010L     // Decode 2 out of 4 B frames
#define DECODE_IPB3     0x0020L     // Decode 3 out of 4 B frames
#define DECODE_DIS      0x0040L     // No Decode, Convert only

#define DECODE_BQUAL_HIGH   0x00000000L  // Normal B Decode
#define DECODE_BQUAL_MEDIUM 0x10000000L  // Fast B Frame (No Half Pixel)
#define DECODE_BQUAL_LOW    0x20000000L  // Super Fast B Frame (No Half Pixel & Fast IDCT)

#define MM_NOCONV       0x00000000L     // No Conversion
#define MM_HRESOLUTION  0x10000000L     // Half Resolution
#define MM_CLIPPED      0x20000000L     // Clipped version (RGB8 only at present)

#define MM_420PL        0x00000001L     // YU12 :: YCbCr
#define MM_420PL_       0x00000002L     // YV12 :: YCrCb

#define MM_422PK        0x00000010L     // YUY2 :: YCbCr
#define MM_422PK_       0x00000020L     // YVY2 :: YCrCb
#define MM_422SPK       0x00000040L     //      :: CbYCrY
#define MM_422SPK_      0x00000080L     //      :: CrYCbY
#define MM_411PK        0x00000100L     // BT41
#define MM_410PL_       0x00000200L     // YVU9 - 16:1:1 Planar format


#define MM_Y_DIB        0x00001000L     // Luminance Only DIB
#define MM_Y_DDB        0x00002000L     // Luminance Only DDB

#define MM_RGB24_DIB    0x00010000L     // RGB 8:8:8 DIB   (Not Supported)
#define MM_RGB24_DDB    0x00020000L     // RGB 8:8:8 DDB   (Not Supported)
#define MM_RGB32_DIB    0x00040000L     // RGB a:8:8:8 DIB   (Not Supported)
#define MM_RGB32_DDB    0x00080000L     // RGB a:8:8:8 DDB   (Not Supported)

#define MM_RGB565_DIB   0x00100000L     // RGB 5:6:5 DIB
#define MM_RGB565_DDB   0x00200000L     // RGB 5:6:5 DDB
#define MM_RGB555_DIB   0x00400000L     // RGB 5:5:5 DIB
#define MM_RGB555_DDB   0x00800000L     // RGB 5:5:5 DDB

#define MM_RGB8_DIB     0x01000000L     // 8 Bit Paletized RGB DIB
#define MM_RGB8_DDB     0x02000000L     // 8 Bit Paletized RGB DDB


#define DECODE_HALF_HIQ	  0x00004000L
#define DECODE_HALF_FULLQ 0x00008000L


// {CC785860-B2CA-11ce-8D2B-0000E202599C}
DEFINE_GUID(CLSID_MpegAudioDecodePropertyPage,
0xcc785860, 0xb2ca, 0x11ce, 0x8d, 0x2b, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x9c);


// {E5B4EAA0-B2CA-11ce-8D2B-0000E202599C}
DEFINE_GUID(CLSID_MpegVideoDecodePropertyPage,
0xe5b4eaa0, 0xb2ca, 0x11ce, 0x8d, 0x2b, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x9c);


// {EB1BB270-F71F-11CE-8E85-02608C9BABA2}
DEFINE_GUID(IID_IMpegVideoDecoder,
0xeb1bb270, 0xf71f, 0x11ce, 0x8e, 0x85, 0x02, 0x60, 0x8c, 0x9b, 0xab, 0xa2);


//
// Structure to describe the caps of the mpeg video decoder.
//
typedef struct {
    DWORD   VideoMaxBitRate;
} MPEG_VIDEO_DECODER_CAPS;


//
// IMpegVideoDecoder
//
DECLARE_INTERFACE_(IMpegVideoDecoder, IUnknown) {

    STDMETHOD(get_CurrentDecoderOption)
    ( THIS_
      DWORD *pOptions
    ) PURE;

    STDMETHOD(set_CurrentDecoderOption)
    ( THIS_
      DWORD Options
    ) PURE;

    STDMETHOD(get_DefaultDecoderOption)
    ( THIS_
      DWORD *pOptions
    ) PURE;

    STDMETHOD(set_DefaultDecoderOption)
    ( THIS_
      DWORD Options
    ) PURE;

    STDMETHOD(get_QualityMsgProcessing)
    ( THIS_
      BOOL *pfIgnore
    ) PURE;

    STDMETHOD(set_QualityMsgProcessing)
    ( THIS_
      BOOL fIgnore
    ) PURE;

    STDMETHOD(get_GreyScaleOutput)
    ( THIS_
      BOOL *pfGrey
    ) PURE;

    STDMETHOD(set_GreyScaleOutput)
    ( THIS_
      BOOL fGrey
    ) PURE;

    STDMETHOD(get_SequenceHeader)
    ( THIS_
      SEQHDR_INFO *pSeqHdrInfo
    ) PURE;

    STDMETHOD(get_OutputFormat)
    ( THIS_
      DWORD *pOutputFormat
    ) PURE;

    STDMETHOD(get_FrameStatistics)
    ( THIS_
      DWORD *pIFramesDecoded,
      DWORD *pPFramesDecoded,
      DWORD *pBFramesDecoded,
      DWORD *pIFramesSkipped,
      DWORD *pPFramesSkipped,
      DWORD *pBFramesSkipped
    ) PURE;

    STDMETHOD(ResetFrameStatistics)
    ( THIS_
    ) PURE;

    STDMETHOD(get_DecoderPaletteInfo)
    ( THIS_
      LPDWORD lpdwFirstEntry,
      LPDWORD lpdwLastEntry
    ) PURE;

    STDMETHOD(get_DecoderPaletteEntries)
    ( THIS_
      DWORD dwStartEntry,
      DWORD dwNumEntries,
      LPPALETTEENTRY lppe
    ) PURE;

    STDMETHOD(get_EncryptionKey)
    ( THIS_
      DWORD *dwEncrptionKey
    ) PURE;

    STDMETHOD(put_EncryptionKey)
    ( THIS_
      DWORD dwEncrptionKey
    ) PURE;

    STDMETHOD(get_DecoderCaps)
    ( THIS_
      MPEG_VIDEO_DECODER_CAPS *pCaps
    ) PURE;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\rndlessplayer\vcdplyer.cpp ===
/******************************Module*Header*******************************\
* Module Name: vcdplyer.cpp
*
* A simple Video CD player
*
*
* Created: 30-10-95
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/
#include <streams.h>
#include <mmreg.h>
#include <commctrl.h>

#include "project.h"
#include "mpgcodec.h"

#include <stdarg.h>
#include <stdio.h>



/******************************Public*Routine******************************\
* CMpegMovie
*
* Constructors and destructors
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
CMpegMovie::CMpegMovie(HWND hwndApplication, BOOL bRndLess)
    : CUnknown(NAME("Allocator Presenter"), NULL),
      m_hwndApp(hwndApplication),
      m_MediaEvent(NULL),
      m_Mode(MOVIE_NOTOPENED),
      m_Fg(NULL),
      m_Gb(NULL),
      m_Mc(NULL),
      m_Ms(NULL),
      m_Me(NULL),
      m_SAN(NULL),
      m_Wc(NULL),
      m_bRndLess(bRndLess)
{
    m_hMonitor = NULL;
    m_lpDDObj = NULL;
    m_pD3D = NULL;
    m_lpPriSurf = NULL;
    m_lpBackBuffer = NULL;
    m_lpDDTexture = NULL;
    m_pD3DDevice = NULL;

    AddRef();
}

CMpegMovie::~CMpegMovie() {
    ;
}

static HRESULT SetRenderingMode( IBaseFilter* pBaseFilter, VMRMode mode )
{
    // Test VMRConfig, VMRMonitorConfig
    IVMRFilterConfig* pConfig;
    HRESULT hr = pBaseFilter->QueryInterface(IID_IVMRFilterConfig, (LPVOID *)&pConfig);
    if( SUCCEEDED( hr )) {
        pConfig->SetRenderingMode( mode );
//      if (mode == VMRMode_Renderless) {
//          pConfig->SetNumberOfStreams(1);
//      }
        pConfig->Release();
    }

    return hr;
}

/*****************************Private*Routine******************************\
* AddVideoMixingRendererToFG()
*
*
*
* History:
* Sat 04/08/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CMpegMovie::AddVideoMixingRendererToFG()
{
    IBaseFilter* pBF = NULL;
    HRESULT hRes = CoCreateInstance(CLSID_VideoMixingRenderer,
                                    NULL,
                                    CLSCTX_INPROC,
                                    IID_IBaseFilter,
                                    (LPVOID *)&pBF);
    if (SUCCEEDED(hRes)) {
        hRes = m_Fg->AddFilter(pBF, L"Video Mixing Renderer");
    }

    if (m_bRndLess) {
        hRes = SetRenderingMode( pBF, VMRMode_Renderless );
        if (SUCCEEDED(hRes)) {
            hRes = pBF->QueryInterface(IID_IVMRSurfaceAllocatorNotify,
                                       (LPVOID *)&m_SAN);
        }


        if (SUCCEEDED(hRes)) {
            hRes = m_SAN->AdviseSurfaceAllocator(this);
        }

        if (SUCCEEDED(hRes)) {
            hRes = m_SAN->SetDDrawDevice(m_lpDDObj, m_hMonitor);
        }
    }
    else {
        hRes = SetRenderingMode( pBF, VMRMode_Windowless );
        if (SUCCEEDED(hRes)) {
            hRes = pBF->QueryInterface(IID_IVMRWindowlessControl, (LPVOID *)&m_Wc);
        }

        if (SUCCEEDED(hRes)) {
            m_Wc->SetVideoClippingWindow(m_hwndApp);
        }
        else {
            if (m_Wc) {
                m_Wc->Release();
                m_Wc = NULL;
            }
        }
    }


    if (pBF) {
        pBF->Release();
    }


    if (FAILED(hRes)) {

        if (m_SAN) {
            m_SAN->Release();
            m_SAN = NULL;
        }
    }



    return hRes;
}

/*****************************Private*Routine******************************\
* AddBallToFG()
*
*
*
* History:
* Sat 04/08/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CMpegMovie::AddBallToFG()
{
    IBaseFilter* pBF = NULL;
    HRESULT hRes = CoCreateInstance(CLSID_BouncingBall, NULL, CLSCTX_INPROC,
                                    IID_IBaseFilter, (LPVOID *)&pBF);
    if (SUCCEEDED(hRes)) {
        hRes = m_Fg->AddFilter(pBF, L"Ball");
        if (SUCCEEDED(hRes)) {
            IPin * pin;
            hRes = pBF->FindPin(L"1", &pin);
            if (SUCCEEDED(hRes)) {
                m_Gb->Render(pin);
                pin->Release();
            }
        }

    }

    if (pBF) {
        pBF->Release();
    }

    return hRes;
}



/******************************Public*Routine******************************\
* OpenMovie
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
HRESULT
CMpegMovie::OpenMovie(
    TCHAR *lpFileName
    )
{
    IUnknown        *pUnk;
    HRESULT         hres;

    WCHAR           FileName[MAX_PATH];

#ifdef UNICODE
    lstrcpy(FileName, lpFileName);
#else
    swprintf(FileName, L"%hs", lpFileName);
#endif

    Initialize3DEnvironment(m_hwndApp);

    hres = CoCreateInstance(g_bUseThreadedGraph ?
                                CLSID_FilterGraph : CLSID_FilterGraphNoThread,
                            NULL, CLSCTX_INPROC, IID_IUnknown, (LPVOID *)&pUnk);
    if (SUCCEEDED(hres)) {

        m_Mode = MOVIE_OPENED;
        hres = pUnk->QueryInterface(IID_IFilterGraph, (LPVOID *)&m_Fg);
        ASSERT( SUCCEEDED( hres ));
        if (FAILED(hres)) {
            pUnk->Release();
            return hres;
        }

        hres = AddVideoMixingRendererToFG();
        ASSERT( SUCCEEDED( hres ));
        if (FAILED(hres)) {
            m_Fg->Release(); m_Fg = NULL;
            if (m_SAN) {
                m_SAN->AdviseSurfaceAllocator(NULL);
                m_SAN->Release(); m_SAN = NULL;
            }

            if (m_Wc) {
                m_Wc->Release(); m_Wc = NULL;
            }
            return hres;
        }


        hres = pUnk->QueryInterface(IID_IGraphBuilder, (LPVOID *)&m_Gb);
        ASSERT( SUCCEEDED( hres ));
        if (FAILED(hres)) {
            pUnk->Release();
            m_Fg->Release(); m_Fg = NULL;

            if (m_SAN) {
                m_SAN->AdviseSurfaceAllocator(NULL);
                m_SAN->Release(); m_SAN = NULL;
            }

            if (m_Wc) {
                m_Wc->Release(); m_Wc = NULL;
            }

            return hres;
        }

        if (hRenderLog!=INVALID_HANDLE_VALUE) {
            m_Gb->SetLogFile((DWORD_PTR) hRenderLog);
        }

        hres = m_Gb->RenderFile(FileName, NULL);
        ASSERT( SUCCEEDED( hres ));
        if (FAILED(hres)) {
            pUnk->Release();

            if (m_SAN) {
                m_SAN->AdviseSurfaceAllocator(NULL);
                m_SAN->Release(); m_SAN = NULL;
            }

            if (m_Wc) {
                m_Wc->Release(); m_Wc = NULL;
            }

            m_Fg->Release(); m_Fg = NULL;
            m_Gb->Release(); m_Gb = NULL;
            return hres;
        }

        if (hRenderLog!=INVALID_HANDLE_VALUE) {
            CloseHandle(hRenderLog);
            hRenderLog = INVALID_HANDLE_VALUE;
        }

#if 0
        //
        // Commenting this out for now as it blues screens my machine!!
        //
        if (m_bRndLess) {
            IVMRMixerBitmap* pBmp;
            HRESULT hr = m_SAN->QueryInterface(IID_IVMRMixerBitmap,
                                               (LPVOID *)&pBmp);
            if( SUCCEEDED( hr )) {
                HWND hwnd = GetDesktopWindow();
                HDC hdc = GetDC(hwnd);
                HBITMAP hbmp = CreateCompatibleBitmap( hdc, 128, 128 );
                HDC hdcBmp = CreateCompatibleDC( hdc );
                HBITMAP hbmpold = (HBITMAP) SelectObject( hdcBmp, hbmp );
                PatBlt( hdcBmp, 0, 0, 128, 128, WHITENESS );
                for ( UINT i = 0; i < 100; i++ )
                {
                    MoveToEx( hdcBmp, rand()%128, rand()%128, NULL );
                    LineTo( hdcBmp, rand()%128, rand()%128 );
                }

                VMRALPHABITMAP bmpInfo;
                memset( &bmpInfo, 0, sizeof(bmpInfo) );
                bmpInfo.dwFlags = VMRBITMAP_HDC;
                bmpInfo.hdc = hdcBmp;
                bmpInfo.rSrc.left = 0;
                bmpInfo.rSrc.top = 0;
                bmpInfo.rSrc.right = 128;
                bmpInfo.rSrc.bottom = 128;
                bmpInfo.rDest.left = 0.8f;
                bmpInfo.rDest.top = 0.8f;
                bmpInfo.rDest.right = 0.9f;
                bmpInfo.rDest.bottom = 0.9f;
                bmpInfo.fAlpha = 1.0f;
                pBmp->SetAlphaBitmap( &bmpInfo );

                DeleteObject( SelectObject( hdcBmp, hbmpold ) );
                ReleaseDC( hwnd, hdcBmp );
                ReleaseDC( hwnd, hdc );
                pBmp->Release();
            }
//          AddBallToFG();
//          AddBallToFG();
//          AddBallToFG();
        }
#endif


        hres = pUnk->QueryInterface(IID_IMediaControl, (LPVOID *)&m_Mc);
        if (FAILED(hres)) {
            pUnk->Release();
            if (m_SAN) {
                m_SAN->AdviseSurfaceAllocator(NULL);
                m_SAN->Release(); m_SAN = NULL;
            }

            if (m_Wc) {
                m_Wc->Release(); m_Wc = NULL;
            }
            m_Fg->Release(); m_Fg = NULL;
            m_Gb->Release(); m_Gb = NULL;
            return hres;
        }

        //
        // Not being able to get the IMediaEvent interface does
        // necessarly mean that we can't play the graph.
        //
        pUnk->QueryInterface(IID_IMediaEvent, (LPVOID *)&m_Me);
        GetMovieEventHandle();

        pUnk->QueryInterface(IID_IMediaSeeking, (LPVOID *)&m_Ms);

	
        pUnk->Release();
        return S_OK;

    }
    else {
        m_Fg = NULL;
    }

    return hres;
}


/******************************Public*Routine******************************\
* CloseMovie
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
DWORD
CMpegMovie::CloseMovie(
    )
{
    m_Mode = MOVIE_NOTOPENED;
    m_bFullScreen = FALSE;

    if (m_Mc) {
        m_Mc->Release();
        m_Mc = NULL;
    }

    if (m_Me) {
        m_MediaEvent = NULL;
        m_Me->Release();
        m_Me = NULL;
    }

    if (m_Ms) {
        m_Ms->Release();
        m_Ms = NULL;
    }


    if (m_Wc) {
        m_Wc->Release(); m_Wc = NULL;
    }

    if (m_Gb) {
        m_Gb->Release();
        m_Gb = NULL;
    }

    if (m_Fg) {
        m_Fg->Release();
        m_Fg = NULL;
    }

    //if (m_SAN) {
    //    m_SAN->AdviseSurfaceAllocator(NULL);
    //    m_SAN->Release(); m_SAN = NULL;
    //}


    if (m_lpPriSurf) {
        m_lpPriSurf->Release();
        m_lpPriSurf = NULL;
    }

    if (m_lpDDObj) {
        m_lpDDObj->Release();
        m_lpDDObj = NULL;
    }

    return 0L;
}


/******************************Public*Routine******************************\
* CMpegMovie::GetNativeMovieSize
*
*
*
* History:
* Fri 03/03/2000 - StEstrop - Created
*
\**************************************************************************/
BOOL
CMpegMovie::GetNativeMovieSize(
    LONG *cx,
    LONG *cy
    )
{
    BOOL    bRet = TRUE;

    if (m_bRndLess) {
        *cx = m_VideoSize.cx;
        *cy = m_VideoSize.cy;
    }
    else {
        if (m_Wc) {
            bRet = (m_Wc->GetNativeVideoSize(cx, cy, NULL, NULL) == S_OK);
        }
    }

    return bRet;
}


/******************************Public*Routine******************************\
* PutMoviePosition
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::PutMoviePosition(
    LONG x,
    LONG y,
    LONG cx,
    LONG cy
    )
{
    BOOL    bRet = TRUE;

    RECT rc;
    SetRect(&rc, x, y, x + cx, y + cy);
    if (m_bRndLess) {
        MapWindowRect(m_hwndApp, HWND_DESKTOP, &rc);
        m_rcDst = rc;
    }
    else {
        if (m_Wc) {
            bRet = (m_Wc->SetVideoPosition(NULL, &rc) == S_OK);
        }
    }

    return bRet;
}



/******************************Public*Routine******************************\
* PlayMovie
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::PlayMovie(
    )
{
    REFTIME rt;
    REFTIME rtAbs;
    REFTIME rtDur;

    rt = GetCurrentPosition();
    rtDur = GetDuration();

    //
    // If we are near the end of the movie seek to the start, otherwise
    // stay where we are.
    //
    rtAbs = rt - rtDur;
    if (rtAbs < (REFTIME)0) {
        rtAbs = -rtAbs;
    }

    if (rtAbs < (REFTIME)1) {
        SeekToPosition((REFTIME)0,FALSE);
    }

    //
    // Change mode after setting m_Mode but before starting the graph
    //
    m_Mode = MOVIE_PLAYING;
    m_Mc->Run();
    return TRUE;
}


/******************************Public*Routine******************************\
* PauseMovie
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::PauseMovie(
    )
{
    m_Mode = MOVIE_PAUSED;
    m_Mc->Pause();
    return TRUE;
}


/******************************Public*Routine******************************\
* GetStateMovie
*
*
*
* History:
* 15-04-96 - AnthonyP - Created
*
\**************************************************************************/

OAFilterState
CMpegMovie::GetStateMovie(
    )
{
    OAFilterState State;
    m_Mc->GetState(INFINITE,&State);
    return State;
}


/******************************Public*Routine******************************\
* StopMovie
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::StopMovie(
    )
{
    m_Mode = MOVIE_STOPPED;
    m_Mc->Stop();
    return TRUE;
}


/******************************Public*Routine******************************\
* StatusMovie
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
EMpegMovieMode
CMpegMovie::StatusMovie(
    )
{
    if (m_Mc) {

        FILTER_STATE    fs;
        HRESULT         hr;

        hr = m_Mc->GetState(100, (OAFilterState *)&fs);

        // Don't know what the state is so just stay at old state.
        if (hr == VFW_S_STATE_INTERMEDIATE) {
            return m_Mode;
        }

        switch (fs) {

        case State_Stopped:
            m_Mode = MOVIE_STOPPED;
            break;

        case State_Paused:
            m_Mode = MOVIE_PAUSED;
            break;

        case State_Running:
            m_Mode = MOVIE_PLAYING;
            break;
        }
    }

    return m_Mode;
}


/******************************Public*Routine******************************\
* GetMediaEventHandle
*
* Returns the IMediaEvent event hamdle for the filter graph iff the
* filter graph exists.
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
HANDLE
CMpegMovie::GetMovieEventHandle(
    )
{
    HRESULT     hr;

    if (m_Me != NULL) {

        if ( m_MediaEvent == NULL) {
            hr = m_Me->GetEventHandle((OAEVENT *)&m_MediaEvent);
        }
    }
    else {
        m_MediaEvent = NULL;
    }

    return m_MediaEvent;
}


/******************************Public*Routine******************************\
* GetMovieEventCode
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
long
CMpegMovie::GetMovieEventCode()
{
    HRESULT hr;
    long    lEventCode;
	LONG_PTR	lParam1, lParam2;

    if (m_Me != NULL) {
        hr = m_Me->GetEvent(&lEventCode, &lParam1, &lParam2, 0);
        if (SUCCEEDED(hr)) {
            return lEventCode;
        }
    }

    return 0L;
}


/******************************Public*Routine******************************\
* GetDuration
*
* Returns the duration of the current movie
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
REFTIME
CMpegMovie::GetDuration()
{
    HRESULT hr;
    LONGLONG Duration;

    // Should we seek using IMediaSelection

    if (m_Ms != NULL && m_TimeFormat != TIME_FORMAT_MEDIA_TIME) {
        hr = m_Ms->GetDuration(&Duration);
        if (SUCCEEDED(hr)) {
            return double(Duration);
        }
    } else if (m_Ms != NULL) {
        hr = m_Ms->GetDuration(&Duration);
        if (SUCCEEDED(hr)) {
            return double(Duration) / UNITS;
        }
    }
    return 0;
}


/******************************Public*Routine******************************\
* GetCurrentPosition
*
* Returns the duration of the current movie
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
REFTIME
CMpegMovie::GetCurrentPosition()
{
    REFTIME rt = (REFTIME)0;
    HRESULT hr;
    LONGLONG Position;

    // Should we return a media position

    if (m_Ms != NULL && m_TimeFormat != TIME_FORMAT_MEDIA_TIME) {
        hr = m_Ms->GetPositions(&Position, NULL);
        if (SUCCEEDED(hr)) {
            return double(Position);
        }
    } else if (m_Ms != NULL) {
        hr = m_Ms->GetPositions(&Position, NULL);
        if (SUCCEEDED(hr)) {
            return double(Position) / UNITS;
        }
    }
    return rt;
}


/*****************************Private*Routine******************************\
* SeekToPosition
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::SeekToPosition(
    REFTIME rt,
    BOOL bFlushData
    )
{
    HRESULT hr;
    LONGLONG llTime = LONGLONG( m_TimeFormat == TIME_FORMAT_MEDIA_TIME ? rt * double(UNITS) : rt );

    if (m_Ms != NULL) {

        FILTER_STATE fs;
        m_Mc->GetState(100, (OAFilterState *)&fs);

        m_Ms->SetPositions(&llTime, AM_SEEKING_AbsolutePositioning, NULL, 0);

        // This gets new data through to the renderers

        if (fs == State_Stopped && bFlushData){
            m_Mc->Pause();
            hr = m_Mc->GetState(INFINITE, (OAFilterState *)&fs);
            m_Mc->Stop();
        }

        if (SUCCEEDED(hr)) {
            return TRUE;
        }
    }
    return FALSE;
}



HRESULT
CMpegMovie::FindInterfaceFromFilterGraph(
    REFIID iid, // interface to look for
    LPVOID *lp  // place to return interface pointer in
    )
{
    IEnumFilters*   pEF;	
    IBaseFilter*        pFilter;

    // Grab an enumerator for the filter graph.
    HRESULT hr = m_Fg->EnumFilters(&pEF);

    if (FAILED(hr)) {
        return hr;
    }

    // Check out each filter.
    while (pEF->Next(1, &pFilter, NULL) == S_OK)
    {
        hr = pFilter->QueryInterface(iid, lp);
        pFilter->Release();

        if (SUCCEEDED(hr)) {
            break;
        }
    }

    pEF->Release();

    return hr;
}


/******************************Public*Routine******************************\
* RepaintVideo
*
*
*
* History:
* Tue 02/29/2000 - StEstrop - Created
*
\**************************************************************************/
BOOL
CMpegMovie::RepaintVideo(
    HWND hwnd,
    HDC hdc
    )
{
    BOOL bRet = FALSE;

//  if (m_Wc) {
//      bRet = (m_Wc->RepaintVideo(hwnd, hdc) == S_OK);
//  }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\rndlessplayer\qprops.cpp ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <mmreg.h>
#include <commctrl.h>

#include "project.h"
#include "mpgcodec.h"
#include <olectl.h>
#include <stdio.h>
extern HINSTANCE hInst;

// these lines copied from SDK\CLASSES\BASE\FILTER.H
#define QueryFilterInfoReleaseGraph(fi) if ((fi).pGraph) (fi).pGraph->Release();

typedef HRESULT (STDAPICALLTYPE *LPOCPF)(HWND hwndOwner, UINT x, UINT y,
    LPCOLESTR lpszCaption, ULONG cObjects, LPUNKNOWN FAR* ppUnk, ULONG cPages,
    LPCLSID pPageClsID, LCID lcid, DWORD dwReserved, LPVOID pvReserved);

typedef HRESULT (STDAPICALLTYPE *LPOI)(LPVOID pvReserved);
typedef void (STDAPICALLTYPE *LPOUI)(void);


//
// Release the reference count for those filters put into the configuration
// listbox
//

void ReleaseFilters(HWND hwndListbox)
{
    if (hwndListbox) {
        IBaseFilter* pFilter;

        for (int i=ListBox_GetCount(hwndListbox); i--;) {
            if (pFilter = (IBaseFilter*)ListBox_GetItemData(hwndListbox, i))
                pFilter->Release();
            else
                break;
        }
    }
}

INT_PTR CALLBACK ConfigDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    switch (wMsg) {
    case WM_INITDIALOG:
        {
            IFilterGraph *pFG = (IFilterGraph *) lParam;

            IEnumFilters* pEF;	
            IBaseFilter* pFilter;
            FILTER_INFO Info;

            HWND hlist = GetDlgItem(hDlg, IDC_FILTERS);
            if (pFG == NULL)
                return FALSE;

            // Grab an enumerator for the filter graph.
            HRESULT hr = pFG->EnumFilters(&pEF);

            // ASSERT(SUCCEEDED(hr));

            // Check out each filter.
            while (pEF->Next(1, &pFilter, NULL) == S_OK)
            {
                int Index;

                hr = pFilter->QueryFilterInfo(&Info);
                // ASSERT(SUCCEEDED(hr));
                QueryFilterInfoReleaseGraph(Info);

#ifdef UNICODE
                Index = ListBox_AddString(hlist, Info.achName);
#else
                CHAR    aFilterName[MAX_FILTER_NAME];
                WideCharToMultiByte(CP_ACP, 0, Info.achName, -1, aFilterName, MAX_FILTER_NAME, NULL, NULL);
                Index = ListBox_AddString(hlist, aFilterName);
#endif

                // ASSERT(Index != LB_ERR);
                // ASSERT(Index != LB_ERRSPACE);

                // Store the IBaseFilter pointer with the listbox item.
                // it gets used if the properties have to be queried
                ListBox_SetItemData(hlist, Index, pFilter);
            }

            pEF->Release();
        }
        return TRUE;

    case WM_ENDSESSION:
        if (wParam)	{
            ReleaseFilters(GetDlgItem(hDlg, IDC_FILTERS));
            EndDialog(hDlg, FALSE);
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            ReleaseFilters(GetDlgItem(hDlg, IDC_FILTERS));
            EndDialog(hDlg, TRUE);
            break;

        case IDCANCEL:
            ReleaseFilters(GetDlgItem(hDlg, IDC_FILTERS));
            EndDialog(hDlg, FALSE);
            break;

        case IDC_FILTERS:
            if (HIWORD(wParam) == LBN_SELCHANGE) {

                HRESULT hr = E_FAIL;

                HWND    hlist = GetDlgItem(hDlg, IDC_FILTERS);
                IBaseFilter *pF;
                ISpecifyPropertyPages *pSPP;

                pF = (IBaseFilter *)
                     ListBox_GetItemData(hlist, ListBox_GetCurSel(hlist));

                if (pF) {
                    hr = pF->QueryInterface(IID_ISpecifyPropertyPages,
                                                    (void **)&pSPP);
                }

                if (hr == S_OK) {
                    pSPP->Release();
                }
                EnableWindow(GetDlgItem(hDlg, IDC_PROPERTIES), hr == S_OK);
            }
            else if (HIWORD(wParam) == LBN_DBLCLK) {
                HWND hwndBtn = GetDlgItem(hDlg, IDC_PROPERTIES);
                SendMessage(hwndBtn, WM_LBUTTONDOWN, 0, 0L);
                SendMessage(hwndBtn, WM_LBUTTONUP, 0, 0L);
            }
            break;

        case IDC_PROPERTIES:
            {
                HWND hlist = GetDlgItem(hDlg, IDC_FILTERS);
                IBaseFilter *pF;
                pF = (IBaseFilter *)
                ListBox_GetItemData(hlist, ListBox_GetCurSel(hlist));

                static const TCHAR szOleControlDll[] = TEXT("OLEPRO32.dll");
                static const char szOCPF[] = "OleCreatePropertyFrame";
                static const TCHAR szOleDll[] = TEXT("OLE32.dll");
                static const char szOleInit[] = "OleInitialize";
                static const char szOleUninit[] = "OleUninitialize";

                HINSTANCE hinst = LoadLibrary(szOleControlDll);
                if (!hinst) break;

                LPOCPF lpfn = (LPOCPF)GetProcAddress(hinst, szOCPF);
                HINSTANCE hinstOLE = LoadLibrary(szOleDll);

                if (hinstOLE) {
                    LPOI lpfnInit = (LPOI)GetProcAddress(hinstOLE, szOleInit);
                    LPOUI lpfnUninit = (LPOUI)GetProcAddress(hinstOLE, szOleUninit);

                    if (lpfn && lpfnInit && lpfnUninit) {

                        (*lpfnInit) (NULL);
                        (*lpfn)(hDlg,               // Parent
                            0,                      // x coordinate
                            0,                      // y coordinate
                            L"Filter",              // Caption
                            1,                      // Number of objects
                            (IUnknown**)&pF,        // 1 object
                            0,                      // No pages :- will use
                            NULL,                   // ISpecifyPropertyPages	
                            0,                      // AmbientLocaleID(),
                            0,                      // Reserved
                            NULL);                  // Reserved
                        (*lpfnUninit) ();
                    }
                    FreeLibrary(hinstOLE);
                }
                FreeLibrary(hinst);
            }
            break;
        }
        break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\rndlessplayer\vcdplyer.h ===
/******************************Module*Header*******************************\
* Module Name: vcdplyer.h
*
* Function prototype for the Video CD Player application.
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/
#include <ddraw.h>
#define D3D_OVERLOADS
#include <d3d.h>


/* -------------------------------------------------------------------------
** CMpegMovie - an Mpeg movie playback class.
** -------------------------------------------------------------------------
*/
enum EMpegMovieMode { MOVIE_NOTOPENED = 0x00,
                      MOVIE_OPENED = 0x01,
                      MOVIE_PLAYING = 0x02,
                      MOVIE_STOPPED = 0x03,
                      MOVIE_PAUSED = 0x04 };


typedef struct {
    BITMAPINFOHEADER    bmiHeader;
    union {
        RGBQUAD         bmiColors[iPALETTE_COLORS];
        DWORD           dwBitMasks[iMASK_COLORS];
        TRUECOLORINFO   TrueColorInfo;
    };
} AMDISPLAYINFO;

#define NUM_CUBE_VERTICES (4*6)

class CMpegMovie :
    public CUnknown,
    public IVMRSurfaceAllocator,
    public IVMRImagePresenter
{

private:
    // Our state variable - records whether we are opened, playing etc.
    EMpegMovieMode  m_Mode;
    HANDLE          m_MediaEvent;
    HWND            m_hwndApp;
    BOOL            m_bFullScreen;
    GUID            m_TimeFormat;

    RECT            m_rcSrc;
    RECT            m_rcDst;
    SIZE            m_VideoSize;
    SIZE            m_VideoAR;


    HRESULT Initialize3DEnvironment(HWND hwndApp);
    HRESULT InitDeviceObjects(LPDIRECT3DDEVICE7 pd3dDevice);
    HRESULT FrameMove(LPDIRECT3DDEVICE7 pd3dDevice,FLOAT fTimeKey);
    HRESULT Render(LPDIRECT3DDEVICE7 pd3dDevice);
    HRESULT AllocateSurfaceWorker(DWORD dwFlags,
                                  LPBITMAPINFOHEADER lpHdr,
                                  LPDDPIXELFORMAT lpPixFmt,
                                  LPSIZE lpAspectRatio,
                                  DWORD dwMinBackBuffers,
                                  DWORD dwMaxBackBuffers,
                                  DWORD* lpdwBackBuffer,
                                  LPDIRECTDRAWSURFACE7* lplpSurface);

    HMONITOR                    m_hMonitor;
    LPDIRECTDRAW7               m_lpDDObj;
    LPDIRECT3D7                 m_pD3D;
    LPDIRECTDRAWSURFACE7        m_lpPriSurf;
    LPDIRECTDRAWSURFACE7        m_lpBackBuffer;
    LPDIRECTDRAWSURFACE7        m_lpDDTexture;
    LPDIRECT3DDEVICE7           m_pD3DDevice;
    D3DVERTEX                   m_pCubeVertices[NUM_CUBE_VERTICES];
    DDCAPS                      m_ddHWCaps;
    AMDISPLAYINFO               m_DispInfo;
    BOOL                        m_bRndLess;

    IFilterGraph*               m_Fg;
    IGraphBuilder*              m_Gb;
    IMediaControl*              m_Mc;
    IMediaSeeking*              m_Ms;
    IMediaEvent*                m_Me;
    IVMRSurfaceAllocatorNotify* m_SAN;
    IVMRWindowlessControl*      m_Wc;


    HRESULT AddVideoMixingRendererToFG();
    HRESULT AddBallToFG();

    HRESULT FindInterfaceFromFilterGraph(
        REFIID iid, // interface to look for
        LPVOID *lp  // place to return interface pointer in
        );

public:
     CMpegMovie(HWND hwndApplication, int bRndLess);
    ~CMpegMovie();

    DECLARE_IUNKNOWN
    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void**);

// IVMRSurfaceAllocator
    STDMETHODIMP AllocateSurface(DWORD dwFlags,
                                 LPBITMAPINFOHEADER lpHdr,
                                 LPDDPIXELFORMAT lpPixFmt,
                                 LPSIZE lpAspectRatio,
                                 DWORD dwMinBackBuffers,
                                 DWORD dwMaxBackBuffers,
                                 DWORD* lpdwActualBackBuffers,
                                 LPDIRECTDRAWSURFACE7* lplpSurface);
    STDMETHODIMP FreeSurface();
    STDMETHODIMP PrepareSurface(LPDIRECTDRAWSURFACE7 lplpSurface,
                                DWORD dwSurfaceFlags);
    STDMETHODIMP AdviseNotify(IVMRSurfaceAllocatorNotify* lpIVMRSurfAllocNotify);


// IVMRImagePresenter
    STDMETHODIMP StartPresenting();
    STDMETHODIMP StopPresenting();
    STDMETHODIMP PresentImage(LPDIRECTDRAWSURFACE7 dwSurface,
                              const REFERENCE_TIME rtNow,
                              const DWORD dwSurfaceFlags);

    HRESULT         OpenMovie(TCHAR *lpFileName);
    DWORD           CloseMovie();
    BOOL            PlayMovie();
    BOOL            PauseMovie();
    BOOL            StopMovie();
    OAFilterState   GetStateMovie();

    HANDLE          GetMovieEventHandle();
    long            GetMovieEventCode();

    BOOL            PutMoviePosition(LONG x, LONG y, LONG cx, LONG cy);
    BOOL            GetNativeMovieSize(LONG *cx, LONG *cy);

    REFTIME         GetDuration();
    REFTIME         GetCurrentPosition();
    BOOL            SeekToPosition(REFTIME rt,BOOL bFlushData);
    EMpegMovieMode  StatusMovie();

    BOOL            RepaintVideo(HWND hwnd, HDC hdc);
};

#include "Compositor.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\video\vmrdeinterlace.cpp ===
/******************************Module*Header*******************************\
* Module Name: VMRDeinterlace.cpp
*
*
*
*
* Created: Wed 03/13/2002
* Author:  Stephen Estrop [StEstrop]
*
* Copyright (c) 2002 Microsoft Corporation
\**************************************************************************/
#include <streams.h>
#include "vmrenderer.h"




/******************************Public*Routine******************************\
* CVMRDeinterlaceContainer
*
*
*
* History:
* Thu 02/28/2002 - StEstrop - Created
*
\**************************************************************************/
CVMRDeinterlaceContainer::CVMRDeinterlaceContainer(
    LPDIRECTDRAW7 pDD,
    HRESULT* phr
    ) :
    m_pIDDVAContainer(NULL),
    m_pIDDVideoAccelerator(NULL)
{
    HRESULT hr = DD_OK;

    __try {

        CHECK_HR(hr = pDD->QueryInterface(IID_IDDVideoAcceleratorContainer,
                                          (void**)&m_pIDDVAContainer));

        GUID guid;
        DDVAUncompDataInfo UncompInfo = {sizeof(DDVAUncompDataInfo), 0, 0, 0};
        CopyMemory(&guid, &DXVA_DeinterlaceContainerDevice, sizeof(GUID));

        CHECK_HR(hr = m_pIDDVAContainer->CreateVideoAccelerator(
                                                &guid, &UncompInfo,
                                                NULL, 0,
                                                &m_pIDDVideoAccelerator,
                                                NULL));
    }
    __finally {

        if (hr != DD_OK) {
            RELEASE(m_pIDDVideoAccelerator);
            RELEASE(m_pIDDVAContainer);
            *phr = hr;
        }
    }
}

/******************************Public*Routine******************************\
* ~CVMRDeinterlaceContainer
*
*
*
* History:
* Thu 02/28/2002 - StEstrop - Created
*
\**************************************************************************/
CVMRDeinterlaceContainer::~CVMRDeinterlaceContainer()
{
    RELEASE(m_pIDDVideoAccelerator);
    RELEASE(m_pIDDVAContainer);
}



/******************************Public*Routine******************************\
* QueryAvailableModes
*
*
*
* History:
* Thu 02/28/2002 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRDeinterlaceContainer::QueryAvailableModes(
    LPDXVA_VideoDesc lpVideoDescription,
    LPDWORD lpdwNumModesSupported,
    LPGUID pGuidsDeinterlaceModes
    )
{
    // lpInput => DXVA_VideoDesc*
    // lpOuput => DXVA_DeinterlaceQueryAvailableModes*

    DXVA_DeinterlaceQueryAvailableModes qam;
    qam.Size     = sizeof(DXVA_DeinterlaceQueryAvailableModes);
    qam.NumGuids = MAX_DEINTERLACE_DEVICE_GUIDS;
    ZeroMemory(&qam.Guids[0], MAX_DEINTERLACE_DEVICE_GUIDS);

    HRESULT hr = m_pIDDVideoAccelerator->Execute(
                    DXVA_DeinterlaceQueryAvailableModesFnCode,
                    (LPVOID)lpVideoDescription, sizeof(LPDXVA_VideoDesc),
                    &qam, sizeof(qam),
                    0, NULL);

    if (hr == DD_OK) {

        DWORD NumGUIDs;

        if (pGuidsDeinterlaceModes) {
            NumGUIDs = min(*lpdwNumModesSupported, qam.NumGuids);
            for (DWORD i = 0; i < NumGUIDs; i++) {
                pGuidsDeinterlaceModes[i] = qam.Guids[i];
            }
        }
        else {
             NumGUIDs = qam.NumGuids;
        }

        *lpdwNumModesSupported = NumGUIDs;
    }

    return hr;
}


/******************************Public*Routine******************************\
* QueryModeCaps
*
*
*
* History:
* Thu 02/28/2002 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRDeinterlaceContainer::QueryModeCaps(
    LPGUID pGuidDeinterlaceMode,
    LPDXVA_VideoDesc lpVideoDescription,
    LPDXVA_DeinterlaceCaps lpDeinterlaceCaps
    )
{
    // lpInput => DXVA_DeinterlaceQueryModeCaps*
    // lpOuput => DXVA_DeinterlaceCaps*

    DXVA_DeinterlaceQueryModeCaps qmc;
    qmc.Size = sizeof(DXVA_DeinterlaceQueryModeCaps),
    qmc.Guid = *pGuidDeinterlaceMode;
    qmc.VideoDesc = *lpVideoDescription;

    HRESULT hr = m_pIDDVideoAccelerator->Execute(
                    DXVA_DeinterlaceQueryModeCapsFnCode,
                    &qmc, sizeof(qmc),
                    lpDeinterlaceCaps, sizeof(DXVA_DeinterlaceCaps),
                    0, NULL);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\rndlessplayer\resource.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
//
// These are indexes used by the toolbar.
//
#define IDC_ADEFAULT2                   4013
#define IDC_STATIC                      -1

#define IDX_SEPARATOR                   -1
#define IDX_1                           0
#define IDX_2                           1
#define IDX_3                           2
#define IDX_4                           3
#define IDX_5                           4
#define IDX_6                           5
#define IDX_7                           6
#define IDX_8                           7
#define IDX_9                           8
#define IDX_10                          9
#define IDX_11                          10
#define DEFAULT_TBAR_SIZE               4
#define NUMBER_OF_BITMAPS               11


#define ID_STATUSBAR                    8
#define ID_TOOLBAR                      9
#define ID_TRACKBAR                     10

#define IDR_MAIN_MENU                   101
#define IDR_TOOLBAR                     102
#define IDR_VIDEOCD_ICON                103
#define IDR_ACCELERATOR                 104

#define IDM_FILE_OPEN                   40001
#define IDM_FILE_CLOSE                  40002
#define IDM_FILE_EXIT                   40003


#define IDM_PROPERTIES                  40004
#define IDM_VIDEO_DECODER               40005
#define IDM_AUDIO_DECODER               40006
#define IDM_FILTERS                     40007

#define IDM_FILE_SET_LOG                40008
#define IDM_FILE_SET_PERF_LOG           40009

#define IDM_HELP_INDEX                  40100
#define IDM_HELP_USING                  40101
#define IDM_HELP_ABOUT                  40102
#define IDM_HELP_SEARCH                 40103

// Different time formats
#define IDM_TIME                        40150
#define IDM_FRAME                       40151
#define IDM_FIELD                       40152
#define IDM_SAMPLE                      40153
#define IDM_BYTES                       40154

// Toolbar commands
#define IDM_MOVIE_STOP                  40010
#define IDM_MOVIE_PLAY                  40011
#define IDM_MOVIE_PREVTRACK             40012
#define IDM_MOVIE_PAUSE                 40013
#define IDM_MOVIE_SKIP_FORE             40014
#define IDM_MOVIE_SKIP_BACK             40015
#define IDM_MOVIE_NEXTTRACK             40016

#define IDM_PERF_NEW                    40017
#define IDM_PERF_DUMP                   40018
#define IDM_FULL_SCREEN                 40019

#define IDM_MOVIE_ALIGN                 40020



#define MENU_STRING_BASE                1000

        // File
#define STR_FILE_OPEN           IDM_FILE_OPEN  + MENU_STRING_BASE
#define STR_FILE_CLOSE          IDM_FILE_CLOSE + MENU_STRING_BASE
#define STR_FILE_EXIT           IDM_FILE_EXIT  + MENU_STRING_BASE
#define STR_FILE_SET_LOG        IDM_FILE_SET_LOG  + MENU_STRING_BASE
#define STR_FILE_SET_PERF_LOG   IDM_FILE_SET_PERF_LOG  + MENU_STRING_BASE


        // Properties Menu
#define STR_PROP_VIDEO_DECODER  IDM_VIDEO_DECODER + MENU_STRING_BASE
#define STR_PROP_AUDIO_DECODER  IDM_AUDIO_DECODER + MENU_STRING_BASE
#define STR_PROP_OTHER          IDM_FILTERS + MENU_STRING_BASE

        // Time format menu
#define STR_PROP_IDM_TIME       IDM_TIME      + MENU_STRING_BASE
#define STR_PROP_IDM_FRAME      IDM_FRAME     + MENU_STRING_BASE
#define STR_PROP_IDM_FIELD      IDM_FIELD     + MENU_STRING_BASE
#define STR_PROP_IDM_SAMPLE     IDM_SAMPLE    + MENU_STRING_BASE
#define STR_PROP_IDM_BYTES      IDM_BYTES     + MENU_STRING_BASE

        // Dither Menu          OPTIONS_MENU_BASE


        // Help Menu            HELP_MENU_BASE
#define STR_HELP_INDEX          IDM_HELP_INDEX    + MENU_STRING_BASE
#define STR_HELP_USING          IDM_HELP_USING    + MENU_STRING_BASE
#define STR_HELP_ABOUT          IDM_HELP_ABOUT    + MENU_STRING_BASE
#define STR_HELP_SEARCH         IDM_HELP_SEARCH   + MENU_STRING_BASE


        // System Menu
#define STR_SYSMENU_RESTORE     1800
#define STR_SYSMENU_MOVE        1801
#define STR_SYSMENU_MINIMIZE    1802
#define STR_SYSMENU_CLOSE       1803
#define STR_SYSMENU_MAXIMIZE    1804
#define STR_SYSMENU_TASK_LIST   1805



#define STR_FILE_FILTER         2000
#define STR_APP_TITLE           2001
#define STR_APP_TITLE_LOADED    2002
#define STR_FILE_LOG_FILTER     2003
#define STR_FILE_PERF_LOG       2004


#define MPEG_CODEC_BASE         4000

#define IDD_AUDIOPROP           4000    //  MPEG_CODEC_BASE + 0
#define FULL_FREQ               MPEG_CODEC_BASE + 1
#define HALF_FREQ               MPEG_CODEC_BASE + 2
#define QUARTER_FREQ            MPEG_CODEC_BASE + 3
#define IDC_INTEGER             MPEG_CODEC_BASE + 4
#define D_HIGH                  MPEG_CODEC_BASE + 5
#define D_MEDIUM                MPEG_CODEC_BASE + 6
#define D_LOW                   MPEG_CODEC_BASE + 7
#define STEREO_OUTPUT           MPEG_CODEC_BASE + 8
#define IDC_8_BIT               MPEG_CODEC_BASE + 9
#define IDC_16_BIT              MPEG_CODEC_BASE + 10
#define IDC_ADEFAULT            MPEG_CODEC_BASE + 11
#define IDC_AINFO               MPEG_CODEC_BASE + 12


#define IDD_VIDEOPROP           4008    //  MPEG_CODEC_BASE + 9
#define NO_DECODE               MPEG_CODEC_BASE + 10
#define I_ONLY                  MPEG_CODEC_BASE + 11
#define IP_ONLY                 MPEG_CODEC_BASE + 12
#define IP_1_IN_4_B             MPEG_CODEC_BASE + 13
#define IP_2_IN_4_B             MPEG_CODEC_BASE + 14
#define IP_3_IN_4_B             MPEG_CODEC_BASE + 15
#define IP_ALL_B                MPEG_CODEC_BASE + 16
#define B_HIGH                  MPEG_CODEC_BASE + 17
#define B_MEDIUM                MPEG_CODEC_BASE + 18
#define B_LOW                   MPEG_CODEC_BASE + 19
#define OUTPUT_16BIT            MPEG_CODEC_BASE + 20
#define OUTPUT_8BIT             MPEG_CODEC_BASE + 21
#define CONVERT_OUTPUT          MPEG_CODEC_BASE + 22
#define HI_QUALITY_OUTPUT       MPEG_CODEC_BASE + 23

#define B_GREY                  MPEG_CODEC_BASE + 24
#define IGNORE_QUALITY          MPEG_CODEC_BASE + 25
#define STATS_BUTTON            MPEG_CODEC_BASE + 26
#define ID_DEFAULT              MPEG_CODEC_BASE + 27

#define IDD_VIDEOSTATS          4027    //  MPEG_CODEC_BASE + 28
#define ID_STATSBOX             MPEG_CODEC_BASE + 29
#define ID_REFRESH              MPEG_CODEC_BASE + 30

#define IDD_PROPPAGE            4040    //  MPEG_CODEC_BASE + 40
#define IDC_FILTERS             MPEG_CODEC_BASE + 41
#define IDC_PROPERTIES          MPEG_CODEC_BASE + 42

#define STR_MAX_STRING_LEN      256
#define IDS_FRAMES_DEC          MPEG_CODEC_BASE + 31
#define IDS_PROPORTION          MPEG_CODEC_BASE + 32
#define IDS_IMAGE_SIZE          MPEG_CODEC_BASE + 33
#define IDS_BUFFER_VBV          MPEG_CODEC_BASE + 34
#define IDS_BITRATE             MPEG_CODEC_BASE + 35
#define IDS_PROP_I              MPEG_CODEC_BASE + 36
#define IDS_PROP_P              MPEG_CODEC_BASE + 37
#define IDS_PROP_B              MPEG_CODEC_BASE + 38
#define IDS_SKIP_I              MPEG_CODEC_BASE + 39
#define IDS_SKIP_P              MPEG_CODEC_BASE + 40
#define IDS_SKIP_B              MPEG_CODEC_BASE + 41
#define IDS_NO_DATA             MPEG_CODEC_BASE + 42
#define IDS_NEWLINE             MPEG_CODEC_BASE + 43
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\video\vmrenderer.h ===
/******************************Module*Header*******************************\
* Module Name: VMRenderer.h
*
*
*
*
* Created: Tue 02/15/2000
* Author:  Stephen Estrop [StEstrop]
*
* Copyright (c) 2000 Microsoft Corporation
\**************************************************************************/

#include "VMRuuids.h"
#include "alloclib.h"
#include "CVMRMediaSample.h"
#include "vmrwinctrl.h"
#include "vmrwindow.h"
#include "vmrp.h"
#include "ddva.h"
#include "videoacc.h"


class CVMRInputPin;
class CVMRFilter;
class CVMRAllocator;
class CVMRRendererMacroVision;
class CVMRDeinterlaceContainer;

extern const AMOVIESETUP_FILTER sudVMRFilter;


class CVMRDeinterlaceContainer {

public:

    CVMRDeinterlaceContainer(LPDIRECTDRAW7 pDD, HRESULT* phr);
    ~CVMRDeinterlaceContainer();

    HRESULT QueryAvailableModes(
        LPDXVA_VideoDesc lpVideoDescription,
        LPDWORD lpdwNumModesSupported,
        LPGUID pGuidsDeinterlaceModes
        );

    HRESULT QueryModeCaps(
        LPGUID pGuidDeinterlaceMode,
        LPDXVA_VideoDesc lpVideoDescription,
        LPDXVA_DeinterlaceCaps lpDeinterlaceCaps
        );

private:
    IDDVideoAcceleratorContainer*   m_pIDDVAContainer;
    IDirectDrawVideoAccelerator*    m_pIDDVideoAccelerator;
};


//
// Combination of all the VP_TV_XXX flags (w/o _WIN_VGA) gives 0x7FFF
//
#define ValidTVStandard(dw)  (dw & 0x7FFF)

//
// MacroVision implementation wrapped in a class for Video Renderer
//
class CVMRRendererMacroVision {

    public:
        CVMRRendererMacroVision(void) ;
        ~CVMRRendererMacroVision(void) ;

        BOOL  SetMacroVision(HMONITOR hMon, DWORD dwCPBits) ;
        BOOL  StopMacroVision();
        HMONITOR  GetCPHMonitor(void)   { return m_hMon; };

    private:
        DWORD       m_dwCPKey;
        HMONITOR    m_hMon;
};

/* -------------------------------------------------------------------------
** Dedicated Mixer Pin allocator class
** -------------------------------------------------------------------------
*/
class CVMRPinAllocator :
    public CBaseAllocator
{
    friend class CVMRFilter;
    friend class CVMRInputPin;

public:
    CVMRPinAllocator(CVMRInputPin* pPin, CCritSec *pLock, HRESULT *phr);

    // Overriden to delegate reference counts to the pin
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,VOID **ppv);

    STDMETHODIMP SetProperties(
        ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual);

    STDMETHODIMP GetBuffer(
        IMediaSample **ppSample, REFERENCE_TIME *pStartTime,
        REFERENCE_TIME *pEndTime, DWORD dwFlags);

    STDMETHODIMP ReleaseBuffer(IMediaSample *pMediaSample);

    //  Check all samples are returned
    BOOL CanFree() const
    {
        return m_lFree.GetCount() == m_lAllocated;
    }

private:
    void Free();
    HRESULT Alloc();

private:
    CVMRInputPin*   m_pPin;
    CCritSec*       m_pInterfaceLock;
};



//
// these values are used to do sanity checking mostly
//
#define MAX_COMPRESSED_TYPES    10
#define MAX_COMPRESSED_BUFFERS  20

typedef struct _tag_SURFACE_INFO {
    LPDIRECTDRAWSURFACE7    pSurface;
    union {
        LPVOID                  pBuffer;    // NULL if not locked
        DWORD_PTR               InUse;
    };
} SURFACE_INFO, *LPSURFACE_INFO;

typedef struct _tag_COMP_SURFACE_INFO {
    DWORD                   dwAllocated;
    LPSURFACE_INFO          pSurfInfo;
} COMP_SURFACE_INFO, *LPCOMP_SURFACE_INFO;


enum {
    AM_VIDEOACCELERATOR = 0x01,
    AM_IMEMINPUTPIN = 0x02
};


/* -------------------------------------------------------------------------
** New Renderer's input pin
** -------------------------------------------------------------------------
*/
class CVMRInputPin :
    public CBaseInputPin,
    public IPinConnection,
    public IAMVideoAccelerator,
    public IVMRVideoStreamControl
{

public:

    DECLARE_IUNKNOWN

    CVMRInputPin(DWORD dwID, CVMRFilter* pRenderer,
                 CCritSec *pLock, HRESULT *phr, LPCWSTR Name);
    virtual ~CVMRInputPin();


    // Overriden to delegate reference counts to the filter
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,VOID **ppv);


    // IPinConnection
    //
    // This interface is implemented to allow the VMR to support dynamice
    // pin reconnections.
    //
    STDMETHODIMP DynamicQueryAccept(const AM_MEDIA_TYPE *pmt);
    STDMETHODIMP NotifyEndOfStream(HANDLE hNotifyEvent);
    STDMETHODIMP IsEndPin();
    STDMETHODIMP DynamicDisconnect();


    // IOverlay
    //
    // This interface is only added to support old applications that want to
    // know the VMR's window handle.  This interface is only obtainable when
    // the VMR is in Window'ed mode.  New applications should be written to the
    // WindowLess mode and therefore already know the window handle of the
    // playback window (because they created the thing!).
    //
    // The VMR will not allow upstream filters to connect using this interface,
    // that is the VMR should only expose the interface after a connection
    // (via IMemInputPin or IAMVideoAccelerator) has been made.  Note that
    // this interface is implemented as a nested class, this is so that we
    // we can have "proper" Set/GetColorKey functions on the IVMRPinConfig
    // interface that don't clash with the functions of the same name in this
    // interface.
    //
    class CIIOverlay : public IOverlay {
        LONG            m_cRef;
        CVMRInputPin*   m_pObj;

    public:
        CIIOverlay(CVMRInputPin* pObj) :
            m_cRef(0), m_pObj(pObj) {}

        STDMETHODIMP_(ULONG) AddRef()
        {
            return (ULONG)++m_cRef;
        }

        STDMETHODIMP_(ULONG) Release()
        {
            return (ULONG)--m_cRef;
        }

        STDMETHODIMP QueryInterface(REFIID riid, void **ppv)
        {
            return m_pObj->QueryInterface(riid, ppv);
        }

        STDMETHODIMP GetPalette(DWORD *, PALETTEENTRY**) { return E_NOTIMPL;}
        STDMETHODIMP SetPalette(DWORD, PALETTEENTRY*) { return E_NOTIMPL;}
        STDMETHODIMP GetDefaultColorKey(COLORKEY*) { return E_NOTIMPL;}
        STDMETHODIMP GetColorKey(COLORKEY*) { return E_NOTIMPL;}
        STDMETHODIMP SetColorKey(COLORKEY*) { return E_NOTIMPL;}
        STDMETHODIMP GetWindowHandle(HWND* pHwnd) {
            return m_pObj->GetWindowHandle(pHwnd);
        }
        STDMETHODIMP GetClipList(RECT*, RECT*, RGNDATA**) { return E_NOTIMPL;}
        STDMETHODIMP GetVideoPosition(RECT*, RECT*) { return E_NOTIMPL;}
        STDMETHODIMP Advise(IOverlayNotify*, DWORD) { return E_NOTIMPL;}
        STDMETHODIMP Unadvise() { return E_NOTIMPL;}
    };

    // IAMVideoAccelerator
    STDMETHODIMP GetVideoAcceleratorGUIDs(
        LPDWORD pdwNumGuidsSupported,
        LPGUID pGuidsSupported
        );

    STDMETHODIMP GetUncompFormatsSupported(
        const GUID* pGuid,
        LPDWORD pdwNumFormatsSupported,
        LPDDPIXELFORMAT pFormatsSupported
        );

    STDMETHODIMP GetInternalMemInfo(
        const GUID* pGuid,
        const AMVAUncompDataInfo* pamvaUncompDataInfo,
        LPAMVAInternalMemInfo pamvaInternalMemInfo
        );

    STDMETHODIMP GetCompBufferInfo(
        const GUID* pGuid,
        const AMVAUncompDataInfo* pamvaUncompDataInfo,
        LPDWORD pdwNumTypesCompBuffers,
        LPAMVACompBufferInfo pamvaCCompBufferInfo
        );

    STDMETHODIMP GetInternalCompBufferInfo(
        LPDWORD pdwNumTypesCompBuffers,
        LPAMVACompBufferInfo pamvaCCompBufferInfo
        );

    STDMETHODIMP BeginFrame(
        const AMVABeginFrameInfo* pamvaBeginFrameInfo
        );

    STDMETHODIMP EndFrame(
        const AMVAEndFrameInfo* pEndFrameInfo
        );

    STDMETHODIMP GetBuffer(
        DWORD dwTypeIndex,
        DWORD dwBufferIndex,
        BOOL bReadOnly,
        LPVOID* ppBuffer,
        LPLONG lpStride
        );

    STDMETHODIMP ReleaseBuffer(
        DWORD dwTypeIndex,
        DWORD dwBufferIndex
        );

    STDMETHODIMP Execute(
        DWORD dwFunction,
        LPVOID lpPrivateInputData,
        DWORD cbPrivateInputData,
        LPVOID lpPrivateOutputData,
        DWORD cbPrivateOutputData,
        DWORD dwNumBuffers,
        const AMVABUFFERINFO *pAMVABufferInfo
        );

    STDMETHODIMP QueryRenderStatus(
        DWORD dwTypeIndex,
        DWORD dwBufferIndex,
        DWORD dwFlags
        );

    STDMETHODIMP DisplayFrame(
        DWORD dwFlipToIndex,
        IMediaSample *pMediaSample
        );

    // Override ReceiveConnection to allow format changes while running
    STDMETHODIMP ReceiveConnection(IPin * pConnector, const AM_MEDIA_TYPE *pmt);

    STDMETHODIMP Disconnect();

    // connection related functions
    HRESULT BreakConnect();
    HRESULT CompleteConnect(IPin *pReceivePin);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT CheckMediaType(const CMediaType* mtOut);
    HRESULT DynamicCheckMediaType(const CMediaType* pmt);
    HRESULT CheckInterlaceFlags(DWORD dwInterlaceFlags);

    HRESULT OnAlloc(
        CVMRMediaSample **ppSampleList,
        LONG lSampleCount);

    HRESULT OnSetProperties(
        ALLOCATOR_PROPERTIES* pReq, ALLOCATOR_PROPERTIES* pAct);

    HRESULT AllocateSurfaceWorker(
        SURFACE_INFO* lplpDDSurf,
        DDSURFACEDESC2* lpddsd,
        DWORD* lpdwBuffCount,
        bool fInterlaced
        );

    HRESULT AllocateSurface(
        const AM_MEDIA_TYPE* cmt,
        SURFACE_INFO** lplpDDSurfInfo,
        DWORD* lpdwBackBuffer,
        DWORD* lpdwSurfFlags,
        DWORD Pool,
        AM_MEDIA_TYPE** ppmt);

    HRESULT OnGetBuffer(
        IMediaSample *pSamp,REFERENCE_TIME *pSTime,
        REFERENCE_TIME *pETime,DWORD dwFlags);

    // allocator control
    STDMETHODIMP GetAllocator(IMemAllocator **ppAllocator);
    STDMETHODIMP NotifyAllocator(IMemAllocator *pAllocator,BOOL bReadOnly);

    // streaming functions
    HRESULT Active();
    HRESULT Inactive();

    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();
    STDMETHODIMP Receive(IMediaSample *pMediaSample);
    STDMETHODIMP EndOfStream();

    // IVMRVideoStreamControl

    // - uses p_Mixer & dwPin ID to map to the corresponding SetStreamXXX call
    STDMETHODIMP SetColorKey(DDCOLORKEY* Clr);
    STDMETHODIMP GetColorKey(DDCOLORKEY* pClr);
    STDMETHODIMP SetStreamActiveState(BOOL fActive);
    STDMETHODIMP GetStreamActiveState(BOOL* lpfActive);

    HRESULT GetWindowHandle(HWND* pHwnd);
    DWORD   GetPinID() {
        return m_dwPinID;
    }


private:
    friend class CVMRPinAllocator;
    friend class CVMRFilter;
    friend class CIIOverlay;

    void    DoQualityMessage();

    HRESULT TryDynamicReconfiguration(IPin* pConnector,const AM_MEDIA_TYPE *pmt);
    HRESULT DynamicReconfigureMEM(IPin* pConnector,const AM_MEDIA_TYPE *pmt);
    HRESULT DynamicReconfigureDVA(IPin* pConnector,const AM_MEDIA_TYPE *pmt);

    //
    // Helper functions for the IAMVideoAccelerator connection protocol
    //
    SURFACE_INFO* SurfaceInfoFromTypeAndIndex(DWORD dwTypeIdx, DWORD dwBuffIdx);
    HRESULT CheckValidMCConnection();
    void FlipDVASurface(DWORD dwFlipToIndex,DWORD dwFlipFromIndex);
    HRESULT VABreakConnect();
    HRESULT VACompleteConnect(IPin *pReceivePin,const CMediaType *pMediaType);
    HRESULT CreateVideoAcceleratorObject();
    HRESULT InitializeUncompDataInfo(BITMAPINFOHEADER *pbmiHeader);
    BOOL    IsSuitableVideoAcceleratorGuid(const GUID * pGuid);
    HRESULT AllocateVACompSurfaces(LPDIRECTDRAW7 pDDraw, BITMAPINFOHEADER *pbmiHdr);
    HRESULT AllocateMCUncompSurfaces(const CMediaType *pMediaType,
                                     LPDIRECTDRAW7 pDDraw, BITMAPINFOHEADER *pbmiHdr);


    //
    // motion comp related variables
    //
    HANDLE                          m_hDXVAEvent;
    BOOL                            m_bVideoAcceleratorSupported;
    DWORD                           m_dwBackBufferCount;
    GUID                            m_mcGuid;
    DDVAUncompDataInfo              m_ddUncompDataInfo;
    DDVAInternalMemInfo             m_ddvaInternalMemInfo;
    DWORD                           m_dwCompSurfTypes;
    LPCOMP_SURFACE_INFO             m_pCompSurfInfo;
    IDDVideoAcceleratorContainer*   m_pIDDVAContainer;
    IDirectDrawVideoAccelerator*    m_pIDDVideoAccelerator;
    IAMVideoAcceleratorNotify*      m_pIVANotify;

    //
    // DShow filter related variables
    //
    CVMRFilter*             m_pRenderer;
    CCritSec*               m_pInterfaceLock;
    CVMRPinAllocator        m_PinAllocator;
    CMediaType              m_mtNew;
    LONG                    m_lSampleSize;
    enum {DELTA_DECODE_CHECKED = 0x01, DELTA_DECODE_MODE_SET = 0x02};
    DWORD                   m_dwDeltaDecode;

    BOOL                    m_fInDFC;
    bool                    m_bDynamicFormatNeeded;
    bool                    m_bActive;
    DWORD                   m_dwPinID;
    LPDIRECTDRAWSURFACE7    m_pDDS;
    CIIOverlay              m_pIOverlay;
    DWORD                   m_RenderTransport;

    //
    // De-interlace variables, only relevant in mixing mode.
    //
    DXVA_DeinterlaceCaps    m_DeinterlaceCaps;
    GUID                    m_DeinterlaceGUID;
    BOOL                    m_DeinterlaceUserGUIDSet;
    GUID                    m_DeinterlaceUserGUID;

    // array of DDraw surfaces in allocation order, if pBuffer is non-NULL
    // then the surface is in use, the array is m_dwNumSamples big.
    SURFACE_INFO*           m_pVidSurfs;

    // array of video samples in temporal order, the array
    // is only allocated when we are de-interlacing, the array
    // is m_dwNumHistorySamples big.
    DXVA_VideoSample*       m_pVidHistorySamps;
    DWORD                   m_dwNumSamples;
    DWORD                   m_dwNumHistorySamples;
    BOOL                    m_InterlacedStream;
    REFERENCE_TIME          m_SamplePeriod;
    DWORD                   m_SampleCount;
    CCritSec                m_DeinterlaceLock;

    HRESULT                 GetStreamInterlaceProperties(
                                const AM_MEDIA_TYPE *pMT,
                                BOOL* lpIsInterlaced,
                                GUID* lpDeintGuid,
                                DXVA_DeinterlaceCaps* pCaps);

    void ReleaseAllocatedSurfaces() {

        if (m_pVidSurfs) {

            //
            // delete the surfaces in reverse order.
            //
            DWORD dwNumSamples = m_dwNumSamples - 1;
            for (DWORD i = 0; i < m_dwNumSamples; i++) {
                RELEASE(m_pVidSurfs[dwNumSamples - i].pSurface);
            }
            m_dwNumSamples = 0;
            delete [] m_pVidSurfs;
            m_pVidSurfs = NULL;
        }

        if (m_pVidHistorySamps) {
            m_dwNumHistorySamples = 0;
            delete [] m_pVidHistorySamps;
            m_pVidHistorySamps = NULL;
        }
    }


    BOOL m_FrontBufferStale;
    void FrontBufferStale(BOOL bStale) {
        if (bStale) {
            m_dwDeltaDecode = 0;
        }
        m_FrontBufferStale = bStale;
    }
    BOOL IsFrontBufferStale() {
        return m_FrontBufferStale;
    }

    BOOL m_bConnected;
    void CompletelyConnected(BOOL bConnected) {
        m_bConnected = bConnected;
    }
    BOOL IsCompletelyConnected() {
        return m_bConnected;
    }

    //
    // IPinConnection stuff
    //
    HANDLE                  m_hEndOfStream;
};



/* -------------------------------------------------------------------------
** New Renderer's filter
** -------------------------------------------------------------------------
*/
class CVMRFilter :
    public CBaseFilter,
    public CPersistStream,
    public IQualProp,
    public IQualityControl,
    public IAMFilterMiscFlags,
    public IKsPropertySet,
    public IVMRWindowlessControl,
    public IVMRMixerControl,
    public IVMRFilterConfig,
    public IVMRFilterConfigInternal,
    public IVMRMonitorConfig,
    public IVMRMixerBitmap,
    public IVMRDeinterlaceControl,
    public ISpecifyPropertyPages
{

public:

    DECLARE_IUNKNOWN
    STDMETHODIMP NonDelegatingQueryInterface(REFIID, void**);
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);
    static CUnknown *CreateInstance2(LPUNKNOWN, HRESULT *);
    static void InitClass(BOOL bLoading, const CLSID *clsid);

    int NumInputPinsConnected() const;

    CVMRFilter(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr, BOOL fDefault);
    virtual ~CVMRFilter();
    void VMRCleanUp();

    CBasePin *GetPin(int n);
    int GetPinCount();

    // Override the filter and pin interface functions
    STDMETHODIMP JoinFilterGraph(IFilterGraph *pGraph,LPCWSTR pName);
    STDMETHODIMP SetSyncSource(IReferenceClock *pClock);
    STDMETHODIMP Stop();
    STDMETHODIMP Pause();
    STDMETHODIMP Run(REFERENCE_TIME StartTime);
    STDMETHODIMP GetState(DWORD dwMSecs,FILTER_STATE *State);

    HRESULT Receive(DWORD dwPinID, IMediaSample *pMediaSample);

    // called when the filter changes state
    HRESULT Active(DWORD dwPinID);
    HRESULT Inactive(DWORD dwPinID);
    HRESULT BeginFlush(DWORD dwPinID);
    HRESULT EndFlush(DWORD dwPinID);
    HRESULT EndOfStream(DWORD dwPinID);
    HRESULT CompleteConnect(DWORD dwPinID, const CMediaType& cmt);
    HRESULT RuntimeAbortPlayback(HRESULT hr);


    // deal with connections
    HRESULT BreakConnect(DWORD dwPinID);
    HRESULT CheckMediaType(const CMediaType *);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT OnSetProperties(CVMRInputPin* pReceivePin);


    // IQualProp property page support
    STDMETHODIMP get_FramesDroppedInRenderer(int *cFramesDropped);
    STDMETHODIMP get_FramesDrawn(int *pcFramesDrawn);
    STDMETHODIMP get_AvgFrameRate(int *piAvgFrameRate);
    STDMETHODIMP get_Jitter(int *piJitter);
    STDMETHODIMP get_AvgSyncOffset(int *piAvg);
    STDMETHODIMP get_DevSyncOffset(int *piDev);


    // IQualityControl methods - Notify allows audio-video throttling
    STDMETHODIMP SetSink( IQualityControl * piqc);
    STDMETHODIMP Notify( IBaseFilter * pSelf, Quality q);


    // IAMFilterMiscFlags
    STDMETHODIMP_(ULONG) GetMiscFlags(void)
    {
        return AM_FILTER_MISC_FLAGS_IS_RENDERER;
    }

    // IVMRWindowlessControl
    STDMETHODIMP GetNativeVideoSize(LONG* lWidth, LONG* lHeight,
                                    LONG* lARWidth, LONG* lARHeight);
    STDMETHODIMP GetMinIdealVideoSize(LONG* lWidth, LONG* lHeight);
    STDMETHODIMP GetMaxIdealVideoSize(LONG* lWidth, LONG* lHeight);
    STDMETHODIMP SetVideoPosition(const LPRECT lpSRCRect,
                                  const LPRECT lpDSTRect);
    STDMETHODIMP GetVideoPosition(LPRECT lpSRCRect,LPRECT lpDSTRect);
    STDMETHODIMP GetAspectRatioMode(DWORD* lpAspectRatioMode);
    STDMETHODIMP SetAspectRatioMode(DWORD AspectRatioMode);

    STDMETHODIMP SetVideoClippingWindow(HWND hwnd);
    STDMETHODIMP RepaintVideo(HWND hwnd, HDC hdc);
    STDMETHODIMP DisplayModeChanged();
    STDMETHODIMP GetCurrentImage(BYTE** lpDib);

    STDMETHODIMP SetBorderColor(COLORREF Clr);
    STDMETHODIMP GetBorderColor(COLORREF* lpClr);
    STDMETHODIMP SetColorKey(COLORREF Clr);
    STDMETHODIMP GetColorKey(COLORREF* lpClr);


    // IVMRMixerControl
    STDMETHODIMP SetAlpha(DWORD dwID, float Alpha);
    STDMETHODIMP GetAlpha(DWORD dwID, float* Alpha);
    STDMETHODIMP SetZOrder(DWORD dwID, DWORD zOrder);
    STDMETHODIMP GetZOrder(DWORD dwID, DWORD* zOrder);
    STDMETHODIMP SetOutputRect(DWORD dwID, const NORMALIZEDRECT *pRect);
    STDMETHODIMP GetOutputRect(DWORD dwID, NORMALIZEDRECT *pRect);

    STDMETHODIMP SetBackgroundClr(COLORREF  clrBkg);
    STDMETHODIMP GetBackgroundClr(COLORREF* lpClrBkg);
    STDMETHODIMP SetMixingPrefs(DWORD dwRenderFlags);
    STDMETHODIMP GetMixingPrefs(DWORD* pdwRenderFlags);


    // IVMRDeinterlaceControl

    STDMETHODIMP GetNumberOfDeinterlaceModes(VMRVideoDesc* lpVideoDesc,
                                             LPDWORD lpdwNumDeinterlaceModes,
                                             LPGUID lpDeinterlaceModes);
    STDMETHODIMP GetDeinterlaceModeCaps(LPGUID lpDeinterlaceMode,
                                        VMRVideoDesc* lpVideoDesc,
                                        VMRDeinterlaceCaps* lpDeinterlaceCaps);
    STDMETHODIMP GetDeinterlaceMode(DWORD dwStreamID,
                                    LPGUID lpDeinterlaceMode);
    STDMETHODIMP SetDeinterlaceMode(DWORD dwStreamID,
                                    LPGUID lpDeinterlaceMode);
    STDMETHODIMP GetDeinterlacePrefs(LPDWORD lpdwDeinterlacePrefs);
    STDMETHODIMP SetDeinterlacePrefs(DWORD dwDeinterlacePrefs);
    STDMETHODIMP GetActualDeinterlaceMode(DWORD dwStreamID,
                                          LPGUID lpDeinterlaceMode);

    //
    // IKsPropertySet interface methods
    //
    STDMETHODIMP Set(REFGUID guidPropSet, DWORD PropID, LPVOID pInstanceData,
                     DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData);

    STDMETHODIMP Get(REFGUID guidPropSet, DWORD PropID, LPVOID pInstanceData,
                     DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData,
                     DWORD *pcbReturned);

    STDMETHODIMP QuerySupported(REFGUID guidPropSet, DWORD PropID, DWORD *pTypeSupport);

    // IVMRSurfaceAllocatorNotify
    class CIVMRSurfaceAllocatorNotify : public IVMRSurfaceAllocatorNotify {
        LONG        m_cRef;
        CVMRFilter* m_pObj;

    public:
        CIVMRSurfaceAllocatorNotify(CVMRFilter* pObj) :
            m_cRef(0), m_pObj(pObj) {}
        ~CIVMRSurfaceAllocatorNotify();

        STDMETHODIMP_(ULONG) AddRef()
        {
            return InterlockedIncrement(&m_cRef);
        }

        STDMETHODIMP_(ULONG) Release()
        {
            return InterlockedDecrement(&m_cRef);
        }

        STDMETHODIMP QueryInterface(REFIID riid, void **ppv)
        {
            return m_pObj->QueryInterface(riid, ppv);
        }

        STDMETHODIMP AdviseSurfaceAllocator(
            DWORD_PTR dwUserID,
            IVMRSurfaceAllocator* lpIVRMSurfaceAllocator
            );

        STDMETHODIMP SetDDrawDevice(LPDIRECTDRAW7 lpDDrawDevice, HMONITOR hMon);
        STDMETHODIMP ChangeDDrawDevice(LPDIRECTDRAW7 lpDDrawDevice, HMONITOR hMon);
        STDMETHODIMP RestoreDDrawSurfaces();
        STDMETHODIMP NotifyEvent(LONG EventCode, LONG_PTR lp1, LONG_PTR lp2);
        STDMETHODIMP SetBorderColor(COLORREF clr);
    };

    // IVMRImagePresenter
    class CIVMRImagePresenter : public IVMRImagePresenter {
        LONG        m_cRef;
        CVMRFilter* m_pObj;

    public:
        CIVMRImagePresenter(CVMRFilter* pObj) :
            m_cRef(0), m_pObj(pObj) {}

        STDMETHODIMP_(ULONG) AddRef()
        {
            return (ULONG)++m_cRef;
        }

        STDMETHODIMP_(ULONG) Release()
        {
            return (ULONG)--m_cRef;
        }

        STDMETHODIMP QueryInterface(REFIID riid, void **ppv)
        {
            return m_pObj->QueryInterface(riid, ppv);
        }

        STDMETHODIMP StartPresenting(DWORD_PTR dwUserID);
        STDMETHODIMP StopPresenting(DWORD_PTR dwUserID);

        STDMETHODIMP PresentImage(
            DWORD_PTR dwUserID,
            VMRPRESENTATIONINFO* lpPresInfo
            );
    };

    // IImageSyncNotifyEvent
    class CIImageSyncNotifyEvent : public IImageSyncNotifyEvent {
        LONG        m_cRef;
        CVMRFilter* m_pObj;

    public:
        CIImageSyncNotifyEvent(CVMRFilter* pObj) :
            m_cRef(0), m_pObj(pObj) {}

        STDMETHODIMP_(ULONG) AddRef()
        {
            return (ULONG)++m_cRef;
        }

        STDMETHODIMP_(ULONG) Release()
        {
            return (ULONG)--m_cRef;
        }

        STDMETHODIMP QueryInterface(REFIID riid, void **ppv)
        {
            return m_pObj->QueryInterface(riid, ppv);
        }

        STDMETHODIMP NotifyEvent(long EventCode, LONG_PTR lp1, LONG_PTR lp2);
    };

    // CPersistStream
    HRESULT WriteToStream(IStream *pStream);
    HRESULT ReadFromStream(IStream *pStream);
    int SizeMax();

    STDMETHODIMP GetClassID(CLSID *pClsid);


    // IVMRFilterConfig
    STDMETHODIMP SetImageCompositor(IVMRImageCompositor* lpVMRImgCompositor);
    STDMETHODIMP SetNumberOfStreams(DWORD dwMaxStreams);
    STDMETHODIMP GetNumberOfStreams(DWORD* lpdwMaxStreams);
    STDMETHODIMP SetRenderingPrefs(DWORD dwRenderFlags);
    STDMETHODIMP GetRenderingPrefs(DWORD* pdwRenderFlags);
    STDMETHODIMP SetRenderingMode(DWORD Mode);
    STDMETHODIMP GetRenderingMode(DWORD* pMode);

    // IVMRFilterConfigInternal
    STDMETHODIMP GetAspectRatioModePrivate(DWORD* lpAspectRatioMode);
    STDMETHODIMP SetAspectRatioModePrivate(DWORD AspectRatioMode);

    // IVMRMonitorConfig ... proxied to To the app-presenter if it supports it
    STDMETHODIMP SetMonitor( const VMRGUID *pGUID );
    STDMETHODIMP GetMonitor( VMRGUID *pGUID );
    STDMETHODIMP SetDefaultMonitor( const VMRGUID *pGUID );
    STDMETHODIMP GetDefaultMonitor( VMRGUID *pGUID );
    STDMETHODIMP GetAvailableMonitors( VMRMONITORINFO* pInfo, DWORD dwMaxInfoArraySize,
                    DWORD* pdwNumDevices );

    // IVMRMixerBitmap
    STDMETHODIMP SetAlphaBitmap( const VMRALPHABITMAP *pBmpParms );
    STDMETHODIMP UpdateAlphaBitmapParameters( PVMRALPHABITMAP pBmpParms );
    STDMETHODIMP GetAlphaBitmapParameters( PVMRALPHABITMAP pBmpParms );

    // ISpecifyPropertyPages
    STDMETHODIMP GetPages(CAUUID *pPages);

    // helper for the window manager
    IVMRWindowlessControl* GetWLControl() {
        return m_lpWLControl;
    }

    HRESULT SetAbortSignal(BOOL fAbort) {
        return m_lpISControl->SetAbortSignal(fAbort);
    }

private:

    friend class CVMRInputPin;
    friend class CIVMRWindowlessControl;
    friend class CIVMRSurfaceAllocatorNotify;
    friend class CIVMRImagePresenter;
    friend class CIImageSyncNotifyEvent;

    CVMRInputPin*               m_pInputPins[MAX_MIXER_PINS];
    CCritSec                    m_InterfaceLock;// Critical section for interfaces
    CCritSec                    m_RendererLock; // Controls access to internals
    IVMRWindowlessControl*      m_lpWLControl;
    IVMRSurfaceAllocator*       m_lpRLNotify;
    IVMRImagePresenter*         m_lpPresenter;
    IVMRImagePresenterConfig*   m_pPresenterConfig;
    IVMRMonitorConfig*          m_pPresenterMonitorConfig;
    IVMRMixerControlInternal*   m_lpMixControl;
    IVMRMixerBitmap*            m_lpMixBitmap;
    IVMRMixerStream*            m_lpMixStream;
    IImageSyncControl*          m_lpISControl;
    IImageSync*                 m_lpIS;
    IQualProp*                  m_lpISQualProp;
    DWORD_PTR                   m_dwUserID;
    DWORD                       m_VMRMode;
    BOOL                        m_VMRCreateAsDefaultRenderer;
    BOOL                        m_VMRModePassThru;
    BOOL                        m_bModeChangeAllowed;
    BOOL                        m_fInputPinCountSet;
    DWORD                       m_dwNumPins;
    CVMRRendererMacroVision     m_MacroVision;

    HMONITOR                    m_hMonitor;
    LPDIRECTDRAW7               m_lpDirectDraw;
    DDCAPS_DX7                  m_ddHWCaps;
    HRESULT                     m_hrSurfaceFlipped;
    HRESULT                     m_hr3D;

    DWORD                       m_ARMode;
    BOOL                        m_bARModeDefaultSet;
    DWORD                       m_TexCaps;
    DDPIXELFORMAT               m_ddpfMonitor;
    DWORD                       m_dwDisplayChangeMask;
    DWORD                       m_dwEndOfStreamMask;
    DWORD                       m_dwRenderPrefs;

    CRendererPosPassThru*       m_pPosition; // Support IMediaSeeking
    CVMRVideoWindow*            m_pVideoWindow;
    CVMRDeinterlaceContainer*   m_pDeinterlace;
    DWORD                       m_dwDeinterlacePrefs;

    CIVMRSurfaceAllocatorNotify m_pIVMRSurfaceAllocatorNotify;
    CIVMRImagePresenter         m_pIVMRImagePresenter;
    CIImageSyncNotifyEvent      m_pIImageSyncNotifyEvent;

    HRESULT ValidateIVRWindowlessControlState();
    HRESULT GetMediaPositionInterface(REFIID riid, void** ppv);
    HRESULT CreateDefaultAllocatorPresenter();
    HRESULT SetDDrawDeviceWorker(LPDIRECTDRAW7 lpDDrawDevice, HMONITOR hMon);
    HRESULT CreateExtraInputPins(DWORD dwNumPins);
    void DestroyExtraInputPins();
    HRESULT CreateInputPin();
    HRESULT ImageSyncInit();
    HRESULT MixerInit(DWORD dwNumStreams);
    void    AutoShowWindow();
    BOOL    ModeChangeAllowed();
    void    SetVMRMode(DWORD mode);
    BOOL    IsVPMConnectedToUs();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\video\vmrdva.cpp ===
/******************************Module*Header*******************************\
* Module Name: VMRDvava.cpp
*
* VMR  video accelerator functionality
*
*
* Created: Wed 05/10/2000
* Author:  Stephen Estrop [StEstrop]
*
* Copyright (c) 2000 Microsoft Corporation
\**************************************************************************/
#include <streams.h>
#include <dvdmedia.h>
#include <windowsx.h>

#include "VMRenderer.h"
#include <malloc.h>     // for __alloca

#define VA_ERROR_LEVEL  1
#define VA_TRACE_LEVEL  2

#if defined( EHOME_WMI_INSTRUMENTATION )
#include "dxmperf.h"
#endif

/*****************************Private*Routine******************************\
* IsSuitableVideoAcceleratorGuid
*
* Check if a media subtype GUID is a video accelerator type GUID
*
* This function calls the DirectDraw video accelerator container
* to list the video accelerator GUIDs and checks to see if the
* Guid passed in is a supported video accelerator GUID.
*
* We should only do this if the upstream pin support IVideoAccleratorNotify
* since otherwise they may be trying to use the GUID without the
* video accelerator interface
*
*
* History:
* Wed 05/10/2000 - StEstrop - Created
*
\**************************************************************************/
BOOL
CVMRInputPin::IsSuitableVideoAcceleratorGuid(
    const GUID * pGuid
    )
{
    AMTRACE((TEXT("CVMRInputPin::IsSuitableVideoAcceleratorGuid")));
    ASSERT(pGuid);

    HRESULT hr = NOERROR;
    DWORD dwNumGuidsSupported = 0, i = 0;
    LPGUID pGuidsSupported = NULL;
    BOOL bMatchFound = FALSE;
    LPDIRECTDRAW7 pDirectDraw = m_pRenderer->m_lpDirectDraw;

    if (!pDirectDraw) {
        return bMatchFound;
    }

    if (!m_pIDDVAContainer) {

        hr = pDirectDraw->QueryInterface(IID_IDDVideoAcceleratorContainer,
                                         (void**)&m_pIDDVAContainer);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                    TEXT("pDirectDraw->QueryInterface(")
                    TEXT("IID_IVideoAcceleratorContainer) failed, hr = 0x%x"),
                    hr));
            return bMatchFound;
        }
        else {
            DbgLog((LOG_TRACE, VA_TRACE_LEVEL,
                    TEXT("pDirectDraw->QueryInterface(")
                    TEXT("IID_IVideoAcceleratorContainer) succeeded")));
        }
    }

    ASSERT(m_pIDDVAContainer);

    // get the guids supported by the vga

    // find the number of guids supported
    hr = m_pIDDVAContainer->GetVideoAcceleratorGUIDs(&dwNumGuidsSupported, NULL);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("m_pIDDVAContainer->GetVideoAcceleratorGUIDs ")
                TEXT("failed, hr = 0x%x"), hr));
        return bMatchFound;
    }
    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("%d Motion comp GUIDs supported")));
    ASSERT(dwNumGuidsSupported);
    if (0 == dwNumGuidsSupported) {
        return bMatchFound;
    }

    // allocate the necessary memory
    pGuidsSupported = (LPGUID)_alloca(dwNumGuidsSupported*sizeof(GUID));

    // get the guids proposed
    hr = m_pIDDVAContainer->GetVideoAcceleratorGUIDs(&dwNumGuidsSupported,
                                                     pGuidsSupported);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("m_pIDDVAContainer->GetVideoAcceleratorGUIDs")
                TEXT(" failed, hr = 0x%x"), hr));
        return bMatchFound;
    }

    for (i = 0; i < dwNumGuidsSupported; i++) {
        if (*pGuid == pGuidsSupported[i]) {
            bMatchFound = TRUE;
            break;
        }
    }

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL,
            TEXT("%s %s suitable video accelerator GUID"),
            (LPCTSTR)CDisp(*pGuid), bMatchFound ? TEXT("is") : TEXT("is not")));

    return bMatchFound;
}

/*****************************Private*Routine******************************\
* InitializeUncompDataInfo
*
* initialize the m_ddUncompDataInfo struct
* get the uncompressed pixel format by choosing the first of all formats
* supported by the vga
*
* BUGBUG why the first?
*
* History:
* Wed 05/10/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::InitializeUncompDataInfo(
    BITMAPINFOHEADER *pbmiHeader
    )
{
    AMTRACE((TEXT("CVMRInputPin::InitializeUncompDataInfo")));

    HRESULT hr = NOERROR;
    AMVAUncompBufferInfo amvaUncompBufferInfo;

    // find the number of entries to be proposed
    hr = m_pIVANotify->GetUncompSurfacesInfo(&m_mcGuid, &amvaUncompBufferInfo);

    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("m_pIVANotify->GetUncompSurfacesInfo failed, hr = 0x%x"),
                hr));
        return hr;
    }

    // initialize the m_ddUncompDataInfo structure
    // We choose the first pixel format since we don't care
    // provided we can make a surface (which we assume we can)
    INITDDSTRUCT(m_ddUncompDataInfo);
    m_ddUncompDataInfo.dwUncompWidth       = pbmiHeader->biWidth;
    m_ddUncompDataInfo.dwUncompHeight      = pbmiHeader->biHeight;
    m_ddUncompDataInfo.ddUncompPixelFormat = amvaUncompBufferInfo.ddUncompPixelFormat;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL,
            TEXT("Uncompressed buffer pixel format %s"),
            (LPCTSTR)CDispPixelFormat(&amvaUncompBufferInfo.ddUncompPixelFormat)));

    return hr;
}


/*****************************Private*Routine******************************\
* AllocateVACompSurfaces
*
*
*
* History:
* Wed 05/10/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::AllocateVACompSurfaces(
    LPDIRECTDRAW7 pDirectDraw,
    BITMAPINFOHEADER *pbmiHeader
    )
{
    HRESULT hr = NOERROR;
    DWORD i = 0, j = 0;
    LPDDVACompBufferInfo pddCompSurfInfo = NULL;
    DDSURFACEDESC2 SurfaceDesc2;

    AMTRACE((TEXT("CVMRInputPin::AllocateVACompSurfaces")));

    ASSERT(pDirectDraw);
    ASSERT(pbmiHeader);

    // get the compressed buffer info

    // find the number of entries to be proposed
    hr = m_pIDDVAContainer->GetCompBufferInfo(&m_mcGuid, &m_ddUncompDataInfo,
                                              &m_dwCompSurfTypes, NULL);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("pIVANotify->GetCompBufferInfo failed, hr = 0x%x"), hr));
        return hr;
    }

    if (!m_dwCompSurfTypes) {
        hr = E_FAIL;
        return hr;
    }

    // allocate the necessary memory
    pddCompSurfInfo = (DDVACompBufferInfo *)_alloca(
                                sizeof(DDVACompBufferInfo) * m_dwCompSurfTypes);

    // memset the allocated memory to zero
    memset(pddCompSurfInfo, 0, m_dwCompSurfTypes*sizeof(DDVACompBufferInfo));

    // set the right size of all the structs
    for (i = 0; i < m_dwCompSurfTypes; i++) {
        pddCompSurfInfo[i].dwSize = sizeof(DDVACompBufferInfo);
    }

    // get the entries proposed
    hr = m_pIDDVAContainer->GetCompBufferInfo(&m_mcGuid,
                                              &m_ddUncompDataInfo,
                                              &m_dwCompSurfTypes,
                                              pddCompSurfInfo);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("GetCompBufferInfo failed, hr = 0x%x"), hr));
        return hr;
    }

    // Set the surface description common to all kinds of surfaces
    INITDDSTRUCT(SurfaceDesc2);
    SurfaceDesc2.dwFlags = DDSD_CAPS | DDSD_WIDTH |
                           DDSD_HEIGHT | DDSD_PIXELFORMAT;

    // allocate memory for storing comp_surface_info
    m_pCompSurfInfo = new COMP_SURFACE_INFO[m_dwCompSurfTypes + 1];
    if (!m_pCompSurfInfo) {
        hr = E_OUTOFMEMORY;
        return hr;
    }

    // memset the allocated memory to zero
    ZeroMemory(m_pCompSurfInfo, (m_dwCompSurfTypes+1)*sizeof(COMP_SURFACE_INFO));

    // allocate the compressed surfaces
    for (i = 1; i <= m_dwCompSurfTypes; i++) {

        DWORD dwAlloc = pddCompSurfInfo[i-1].dwNumCompBuffers;
        if (dwAlloc == 0) {
            continue;
        }

        ASSERT(pddCompSurfInfo[i-1].dwNumCompBuffers);

        // allocate memory for storing surface_info for surfaces of this type
        m_pCompSurfInfo[i].pSurfInfo = new SURFACE_INFO[dwAlloc];
        if (!m_pCompSurfInfo[i].pSurfInfo) {
            hr = E_OUTOFMEMORY;
            return hr;
        }

        // memset the allocated memory to zero
        ZeroMemory(m_pCompSurfInfo[i].pSurfInfo, dwAlloc*sizeof(SURFACE_INFO));

        // intialize the pddCompSurfInfo[i-1] struct
        dwAlloc = m_pCompSurfInfo[i].dwAllocated =
                                        pddCompSurfInfo[i-1].dwNumCompBuffers;

        SurfaceDesc2.ddsCaps = pddCompSurfInfo[i-1].ddCompCaps;
        SurfaceDesc2.dwWidth = pddCompSurfInfo[i-1].dwWidthToCreate;
        SurfaceDesc2.dwHeight = pddCompSurfInfo[i-1].dwHeightToCreate;
        memcpy(&SurfaceDesc2.ddpfPixelFormat,
               &pddCompSurfInfo[i-1].ddPixelFormat, sizeof(DDPIXELFORMAT));

        DbgLog((LOG_TRACE, VA_TRACE_LEVEL,
                TEXT("SurfType=%d Buffs=%u %dx%d pixels at %d bpp"),
                i, dwAlloc, SurfaceDesc2.dwWidth, SurfaceDesc2.dwHeight,
                SurfaceDesc2.ddpfPixelFormat.dwRGBBitCount));

        // create the surfaces, storing surfaces handles for each
        for (j = 0; j < dwAlloc; j++) {

            hr = pDirectDraw->CreateSurface(
                        &SurfaceDesc2,
                        &m_pCompSurfInfo[i].pSurfInfo[j].pSurface,
                        NULL);
            if (FAILED(hr)) {
                DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                        TEXT("Function CreateSurface failed, hr = 0x%x"), hr));
                return hr;
            }
        }
    }

    return hr;
}



/*****************************Private*Routine******************************\
* AllocateMCUncompSurfaces
*
* This function needs re-writting and possible moving into the AP object.
*
* allocate the uncompressed buffer
*
* History:
* Wed 05/10/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::AllocateMCUncompSurfaces(
    const CMediaType *pMediaType,
    LPDIRECTDRAW7 pDirectDraw,
    BITMAPINFOHEADER *lpHdr
    )
{
    AMTRACE((TEXT("CVMRInputPin::AllocateMCUncompSurfaces")));
    HRESULT hr = NOERROR;

    AMVAUncompBufferInfo amUncompBuffInfo;
    LPDIRECTDRAWSURFACE7 pSurface7 = NULL;
    DDSCAPS2 ddSurfaceCaps;
    DWORD i = 0, dwTotalBufferCount = 0;
    SURFACE_INFO *pSurfaceInfo;
    AM_MEDIA_TYPE *pNewMediaType = NULL;


    ASSERT(pDirectDraw);
    ASSERT(lpHdr);

    __try {

        // get the uncompressed surface info from the decoder
        ZeroMemory(&amUncompBuffInfo, sizeof(AMVAUncompBufferInfo));
        hr = m_pIVANotify->GetUncompSurfacesInfo(&m_mcGuid, &amUncompBuffInfo);

        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("AllocateMCUncompSurfaces: m_pIVANotify->")
                TEXT("GetUncompSurfacesInfo failed, hr = 0x%x"), hr));
            __leave;
        }


        if (amUncompBuffInfo.dwMinNumSurfaces > amUncompBuffInfo.dwMaxNumSurfaces) {
            hr = E_INVALIDARG;
            DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("AllocateMCUncompSurfaces: dwMinNumSurfaces >")
                TEXT("dwMaxNumSurfaces")));
            __leave;
        }

        if (amUncompBuffInfo.dwMinNumSurfaces == 0) {
            hr = E_INVALIDARG;
            DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("AllocateMCUncompSurfaces: dwMinNumSurfaces == 0") ));
            __leave;
        }


        DDSURFACEDESC2 ddsd;
        INITDDSTRUCT(ddsd);
        DWORD dwSurfFlags = VMR_SF_NONE;
        GUID guidDeint;
        GUID* lpDeinterlaceGUID = NULL;

        if (m_pRenderer->m_VMRModePassThru) {

            VMRALLOCATIONINFO p;
            CHECK_HR(hr = GetImageAspectRatio(pMediaType,
                                     &p.szAspectRatio.cx,
                                     &p.szAspectRatio.cy));

            p.dwFlags = (AMAP_PIXELFORMAT_VALID | AMAP_DIRECTED_FLIP | AMAP_DXVA_TARGET);

            p.lpHdr = lpHdr;
            p.lpPixFmt = &m_ddUncompDataInfo.ddUncompPixelFormat;
            p.dwMinBuffers = amUncompBuffInfo.dwMinNumSurfaces;
            p.dwMaxBuffers = max(amUncompBuffInfo.dwMaxNumSurfaces,3);
            p.szNativeSize.cx = abs(lpHdr->biWidth);
            p.szNativeSize.cy = abs(lpHdr->biHeight);

            CHECK_HR(hr = GetInterlaceFlagsFromMediaType(pMediaType,
                                                         &p.dwInterlaceFlags));

            CHECK_HR(hr = m_pRenderer->m_lpRLNotify->AllocateSurface(
                                m_pRenderer->m_dwUserID, &p,
                                &dwTotalBufferCount, &pSurface7));
        }
        else {

            // Set the surface description common to all kinds of surfaces
            ddsd.dwFlags = DDSD_CAPS | DDSD_WIDTH |
                           DDSD_HEIGHT | DDSD_PIXELFORMAT;

            // store the caps and dimensions
            ddsd.ddsCaps.dwCaps = DDSCAPS_VIDEOMEMORY;
            ddsd.dwWidth = abs(lpHdr->biWidth);
            ddsd.dwHeight = abs(lpHdr->biHeight);

            // define the pixel format
            ddsd.ddpfPixelFormat = m_ddUncompDataInfo.ddUncompPixelFormat;

            BITMAPINFOHEADER* pTmp = GetbmiHeader(pMediaType);
            DWORD dwFourccTmp = pTmp->biCompression;
            pTmp->biCompression = ddsd.ddpfPixelFormat.dwFourCC;
            hr = GetStreamInterlaceProperties(pMediaType,
                                              &m_InterlacedStream,
                                              &guidDeint,
                                              &m_DeinterlaceCaps);
            pTmp->biCompression = dwFourccTmp;

            //
            // don't use the SUCCEEDED macro here as
            // GetStreamInterlaceProperties can return S_FALSE
            //
            if (hr == S_OK && m_InterlacedStream) {

                //
                // we need to allocate enough samples for the
                // de-interlacer and enough for the DX-VA decode operation.
                //

                dwTotalBufferCount = amUncompBuffInfo.dwMinNumSurfaces;
                dwTotalBufferCount += (m_DeinterlaceCaps.NumForwardRefSamples +
                                       m_DeinterlaceCaps.NumBackwardRefSamples);
                DbgLog((LOG_TRACE, 0, TEXT("UnComp Buffers = %d"), dwTotalBufferCount));

                m_DeinterlaceGUID = guidDeint;
                lpDeinterlaceGUID = &m_DeinterlaceGUID;

            }
            else {
                m_InterlacedStream = FALSE;
                dwTotalBufferCount = amUncompBuffInfo.dwMinNumSurfaces;

                ZeroMemory(&m_DeinterlaceCaps, sizeof(m_DeinterlaceCaps));
                ZeroMemory(&m_DeinterlaceGUID, sizeof(m_DeinterlaceGUID));
                lpDeinterlaceGUID = NULL;
            }

            for (i = 0; i < 2; i++) {

                // CleanUp stuff from the last loop
                RELEASE(pSurface7);

                switch (i) {
                case 0:
                    ddsd.ddsCaps.dwCaps &= ~DDSCAPS_OFFSCREENPLAIN;
                    ddsd.ddsCaps.dwCaps |= DDSCAPS_TEXTURE;
                    dwSurfFlags = VMR_SF_TEXTURE;
                    break;

                case 1:
                    ddsd.ddsCaps.dwCaps &= ~DDSCAPS_TEXTURE;
                    ddsd.ddsCaps.dwCaps |= DDSCAPS_OFFSCREENPLAIN;
                    dwSurfFlags = VMR_SF_NONE;
                    break;
                }

                if (dwTotalBufferCount > 1) {

                    ddsd.dwFlags |= DDSD_BACKBUFFERCOUNT;
                    ddsd.ddsCaps.dwCaps |=
                        DDSCAPS_FLIP | DDSCAPS_COMPLEX | DDSCAPS_LOCALVIDMEM;

                    ddsd.dwBackBufferCount = dwTotalBufferCount - 1;
                }
                else {
                    ddsd.dwFlags &= ~DDSD_BACKBUFFERCOUNT;
                    ddsd.ddsCaps.dwCaps &= ~(DDSCAPS_FLIP | DDSCAPS_COMPLEX);
                    ddsd.dwBackBufferCount = 0;
                }

                hr = pDirectDraw->CreateSurface(&ddsd, &pSurface7, NULL);
                if (FAILED(hr)) {
                    DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                            TEXT("Function CreateSurface failed in Video memory, ")
                            TEXT("BackBufferCount = %d, hr = 0x%x"),
                            dwTotalBufferCount-1, hr));
                }

                if (SUCCEEDED(hr)) {
                    PaintDDrawSurfaceBlack(pSurface7);
                    break;
                }
            }

            //
            // Tell the VMR's mixer about the new DX-VA connection we have just made.
            // Also, create the DX-VA/Mixer sync event.
            //
            if (FAILED(hr)) {
                DbgLog((LOG_ERROR, 1,
                        TEXT("AllocateMCUncompSurfaces: Could not ")
                        TEXT("create UnComp surfaces") ));
                __leave;
            }

            ASSERT(m_hDXVAEvent == NULL);
            m_hDXVAEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

            if (m_hDXVAEvent == NULL) {
                DbgLog((LOG_ERROR, 1,
                        TEXT("Could not create DX-VA sync event") ));
                hr = E_FAIL;
                __leave;
            }
        }

        //
        // create a media type for this surface.
        //
        ASSERT(pSurface7);
        CHECK_HR(hr = pSurface7->GetSurfaceDesc(&ddsd));
        CHECK_HR(hr = ConvertSurfaceDescToMediaType(&ddsd,
                                                    pMediaType,
                                                    &pNewMediaType));
        m_mtNew = *(CMediaType *)pNewMediaType;
        m_mtNew.subtype = pMediaType->subtype;

        //
        // free the temporary mediatype
        //
        DeleteMediaType(pNewMediaType);
        pNewMediaType = NULL;

        if (!m_pRenderer->m_VMRModePassThru) {

            IVMRMixerStream* lpMixStream = m_pRenderer->m_lpMixStream;
            if (lpMixStream) {

                DbgLog((LOG_TRACE, 1,
                    TEXT("Pin %d calling SetStreamMediaType on the Mixer"),
                    m_dwPinID ));

                AM_MEDIA_TYPE mtTmp;
                CHECK_HR(hr = CopyMediaType(&mtTmp, (AM_MEDIA_TYPE*)pMediaType));

                BITMAPINFOHEADER *pTmp = GetbmiHeader(&mtTmp);
                BITMAPINFOHEADER *pCnt = GetbmiHeader(&m_mtNew);

                pTmp->biCompression = pCnt->biCompression;

                hr = lpMixStream->SetStreamMediaType(m_dwPinID, &mtTmp,
                                                     dwSurfFlags,
                                                     lpDeinterlaceGUID,
                                                     &m_DeinterlaceCaps);
                FreeMediaType(mtTmp);

                if (FAILED(hr)) {
                    __leave;
                }
            }
        }


        // store the complex surface in m_pDDS
        m_pDDS = pSurface7;
        m_pDDS->AddRef();
        m_dwBackBufferCount = dwTotalBufferCount - 1;

        ASSERT(m_pCompSurfInfo && NULL == m_pCompSurfInfo[0].pSurfInfo);
        m_pCompSurfInfo[0].pSurfInfo = new SURFACE_INFO[m_dwBackBufferCount + 1];

        if (NULL == m_pCompSurfInfo[0].pSurfInfo) {
            hr = E_OUTOFMEMORY;
            DbgLog((LOG_ERROR, 1,
                    TEXT("AllocateMCUncompSurfaces: memory allocation failed") ));
            __leave;
        }

        // memset the allcated memory to zero
        ZeroMemory(m_pCompSurfInfo[0].pSurfInfo,
                   (m_dwBackBufferCount + 1) * sizeof(SURFACE_INFO));

        pSurfaceInfo = m_pCompSurfInfo[0].pSurfInfo;
        m_pCompSurfInfo[0].dwAllocated = m_dwBackBufferCount + 1;

        // initalize the m_ppUncompSurfaceList
        pSurfaceInfo->pSurface = pSurface7;


        //
        //
        //
        ddsd.ddsCaps.dwCaps &= ~(DDSCAPS_FRONTBUFFER | DDSCAPS_VISIBLE);


        for (i = 0; i < m_dwBackBufferCount; i++) {

            // Get the back buffer surface
            // New version of DirectX now requires DDSCAPS2 (header file bug)
            // Note that this AddRef's the surface so we should be sure to
            // release them

            CHECK_HR(hr = pSurfaceInfo[i].pSurface->GetAttachedSurface(
                            &ddsd.ddsCaps,
                            &pSurfaceInfo[i+1].pSurface));
        }

        //
        // fix up the de-interlace surface structures
        //
        if (!m_pRenderer->m_VMRModePassThru && m_InterlacedStream) {

            DWORD dwBuffCount = 1 +
                                m_DeinterlaceCaps.NumForwardRefSamples +
                                m_DeinterlaceCaps.NumBackwardRefSamples;
            m_pVidHistorySamps = new DXVA_VideoSample[dwBuffCount];
            if (m_pVidHistorySamps == NULL) {
                hr = E_OUTOFMEMORY;
                __leave;
            }
            ZeroMemory(m_pVidHistorySamps, (dwBuffCount * sizeof(DXVA_VideoSample)));
            m_dwNumHistorySamples = dwBuffCount;
        }

        //  Pass back number of surfaces actually allocated
        CHECK_HR(hr = m_pIVANotify->SetUncompSurfacesInfo(dwTotalBufferCount));
    }
    __finally {

        if (FAILED(hr)) {

            if (m_hDXVAEvent) {
                CloseHandle(m_hDXVAEvent);
                m_hDXVAEvent = NULL;
            }

            ReleaseAllocatedSurfaces();
            RELEASE(pSurface7);
        }
    }


    return hr;
}


/*****************************Private*Routine******************************\
* CreateVideoAcceleratorObject
*
* create the motion comp object, using the misc data from the decoder
*
* History:
* Wed 05/10/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::CreateVideoAcceleratorObject()
{
    HRESULT hr = NOERROR;
    DWORD dwSizeMiscData = 0;
    LPVOID pMiscData = NULL;

    AMTRACE((TEXT("CVMRInputPin::CreateVideoAcceleratorObject")));

    // get the data to be passed from the decoder
    hr = m_pIVANotify->GetCreateVideoAcceleratorData(&m_mcGuid,
                                                     &dwSizeMiscData,
                                                     &pMiscData);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("m_pIVANotify->GetCreateVideoAcceleratorData failed,")
                TEXT(" hr = 0x%x"), hr));
        return hr;
    }

    // ask the vga for the motion comp object
    hr = m_pIDDVAContainer->CreateVideoAccelerator(&m_mcGuid,
                                                   &m_ddUncompDataInfo,
                                                   pMiscData,
                                                   dwSizeMiscData,
                                                   &m_pIDDVideoAccelerator,
                                                   NULL);
    //  Free motion comp data
    CoTaskMemFree(pMiscData);

    if (FAILED(hr) || !m_pIDDVideoAccelerator) {

        if (SUCCEEDED(hr)) {
            hr = E_FAIL;
        }

        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("m_pIDDVAContainer->CreateVideoAcceleratorideo ")
                TEXT("failed, hr = 0x%x"), hr));
    }

    return hr;
}


/*****************************Private*Routine******************************\
* VACompleteConnect
*
*
*
* History:
* Wed 05/10/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::VACompleteConnect(
    IPin *pReceivePin,
    const CMediaType *pMediaType
    )
{
    HRESULT hr = NOERROR;
    BITMAPINFOHEADER *pbmiHeader = NULL;
    DWORD dwNumUncompFormats = 0;
    LPDIRECTDRAW7 pDirectDraw = NULL;

    AMTRACE((TEXT("CVMRInputPin::VACompleteConnect")));

    ASSERT(m_pIDDVAContainer);
    ASSERT(pReceivePin);
    ASSERT(pMediaType);

    pbmiHeader = GetbmiHeader(pMediaType);
    if (!pbmiHeader) {
        DbgLog((LOG_ERROR, 1, TEXT("Could not get bitmap header from MT")));
        return E_FAIL;
    }

    if (!m_pIVANotify) {
        DbgLog((LOG_ERROR, 1, TEXT("IAMVANotify not valid")));
        return E_FAIL;
    }

    pDirectDraw = m_pRenderer->m_lpDirectDraw;
    ASSERT(pDirectDraw);

    // save the decoder's guid
    m_mcGuid = pMediaType->subtype;

    // initialize the get the uncompressed formats supported by the vga
    hr = InitializeUncompDataInfo(pbmiHeader);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("InitializeUncompDataInfo failed, hr = 0x%x"), hr));
        return hr;
    }

    // allocate compressed buffers
    hr = AllocateVACompSurfaces(pDirectDraw, pbmiHeader);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("AllocateVACompSurfaces failed, hr = 0x%x"), hr));
        return hr;
    }

    // allocate uncompressed buffers
    hr = AllocateMCUncompSurfaces(pMediaType, pDirectDraw, pbmiHeader);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("AllocateMCUncompSurfaces failed, hr = 0x%x"), hr));
        return hr;
    }

    // create the motion comp object
    hr = CreateVideoAcceleratorObject();
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("CreateVideoAcceleratorObject failed, hr = 0x%x"), hr));
        return hr;
    }

    return hr;
}

/*****************************Private*Routine******************************\
* VABreakConnect()
*
*
*
* History:
* Wed 05/10/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::VABreakConnect()
{
    HRESULT hr = NOERROR;
    DWORD i = 0, j = 0;

    AMTRACE((TEXT("CVMRInputPin::VABreakConnect")));

    if (m_pCompSurfInfo) {

        for (i = 0; i < m_dwCompSurfTypes + 1; i++) {

            DWORD dwAlloc = m_pCompSurfInfo[i].dwAllocated;

            if (!m_pCompSurfInfo[i].pSurfInfo)
                continue;

            // release the compressed surfaces
            for (j = 0; j < dwAlloc; j++) {

                if (m_pCompSurfInfo[i].pSurfInfo[j].pSurface) {

                    //  Unlock if necessary
                    if (m_pCompSurfInfo[i].pSurfInfo[j].pBuffer) {

                        m_pCompSurfInfo[i].pSurfInfo[j].pSurface->Unlock(NULL);
                    }
                    m_pCompSurfInfo[i].pSurfInfo[j].pSurface->Release();
                }
            }
            delete [] m_pCompSurfInfo[i].pSurfInfo;
        }
        delete [] m_pCompSurfInfo;
        m_pCompSurfInfo = NULL;
    }
    m_dwCompSurfTypes = 0;

    if (m_hDXVAEvent) {
        CloseHandle(m_hDXVAEvent);
        m_hDXVAEvent = NULL;
    }

    RELEASE(m_pIDDVideoAccelerator);
    RELEASE(m_pIDDVAContainer);
    RELEASE(m_pIVANotify);

    return hr;
}


// -------------------------------------------------------------------------
// IAMVideoAccelerator
// -------------------------------------------------------------------------
//

/******************************Public*Routine******************************\
* GetVideoAcceleratorGUIDs
*
* pdwNumGuidsSupported is an IN OUT paramter
* pGuidsSupported is an IN OUT paramter
*
* if pGuidsSupported is NULL,  pdwNumGuidsSupported should return back with the
* number of uncompressed pixel formats supported
* Otherwise pGuidsSupported is an array of *pdwNumGuidsSupported structures
*
*
* History:
* Wed 05/10/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRInputPin::GetVideoAcceleratorGUIDs(
    LPDWORD pdwNumGuidsSupported,
    LPGUID pGuidsSupported)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVMRInputPin::GetVideoAcceleratorGUIDs")));

    CAutoLock cLock(m_pInterfaceLock);

    LPDIRECTDRAW7 pDirectDraw;
    pDirectDraw = m_pRenderer->m_lpDirectDraw;
    if (!pDirectDraw) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("GetVideoAcceleratorGUIDs: VMR not inialized yet!")));
        return VFW_E_WRONG_STATE;
    }

    if (!m_pIDDVAContainer) {

        hr = pDirectDraw->QueryInterface(IID_IDDVideoAcceleratorContainer,
                                         (void**)&m_pIDDVAContainer);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                    TEXT("pDirectDraw->QueryInterface(")
                    TEXT("IID_IVideoAcceleratorContainer) failed, hr = 0x%x"),
                    hr));
            return hr;
        }
        else {
            DbgLog((LOG_TRACE, VA_TRACE_LEVEL,
                    TEXT("pDirectDraw->QueryInterface(")
                    TEXT("IID_IVideoAcceleratorContainer) succeeded")));
        }
    }

    ASSERT(m_pIDDVAContainer);

    hr = m_pIDDVAContainer->GetVideoAcceleratorGUIDs(pdwNumGuidsSupported,
                                                     pGuidsSupported);

    return hr;
}



/******************************Public*Routine******************************\
* GetUncompFormatsSupported
*
* pGuid is an IN parameter
* pdwNumFormatsSupported is an IN OUT paramter
* pFormatsSupported is an IN OUT paramter (caller should make sure to set
* the size of EACH struct)
*
* if pFormatsSupported is NULL,  pdwNumFormatsSupported should return back with
* the number of uncompressed pixel formats supported
* Otherwise pFormatsSupported is an array of *pdwNumFormatsSupported structures
*
*
* History:
* Wed 05/10/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRInputPin::GetUncompFormatsSupported(
    const GUID * pGuid, LPDWORD pdwNumFormatsSupported,
    LPDDPIXELFORMAT pFormatsSupported)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVMRInputPin::GetUncompFormatsSupported")));

    CAutoLock cLock(m_pInterfaceLock);

    if (!m_pIDDVAContainer) {
        hr = E_FAIL;
        return hr;
    }

    hr = m_pIDDVAContainer->GetUncompFormatsSupported((GUID *)pGuid,
                                                      pdwNumFormatsSupported,
                                                      pFormatsSupported);

    return hr;
}

/******************************Public*Routine******************************\
* GetInternalMemInfo
*
* pGuid is an IN parameter
* pddvaUncompDataInfo is an IN parameter
* pddvaInternalMemInfo is an IN OUT parameter
*
* (caller should make sure to set the size of struct)
* currently only gets info about how much scratch memory will the
* hal allocate for its private use
*
*
* History:
* Wed 05/10/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRInputPin::GetInternalMemInfo(
    const GUID * pGuid,
    const AMVAUncompDataInfo *pamvaUncompDataInfo,
    LPAMVAInternalMemInfo pamvaInternalMemInfo)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVMRInputPin::GetInternalMemInfo")));

    CAutoLock cLock(m_pInterfaceLock);

    if (!m_pIDDVAContainer) {
        hr = E_FAIL;
        return hr;
    }

    DDVAUncompDataInfo ddvaDataInfo;
    INITDDSTRUCT(ddvaDataInfo);

    ddvaDataInfo.dwUncompWidth       = pamvaUncompDataInfo->dwUncompWidth;
    ddvaDataInfo.dwUncompHeight      = pamvaUncompDataInfo->dwUncompHeight;
    ddvaDataInfo.ddUncompPixelFormat = pamvaUncompDataInfo->ddUncompPixelFormat;

    DDVAInternalMemInfo ddvaInternalMemInfo;
    INITDDSTRUCT(ddvaInternalMemInfo);

    //  Unfortunately the ddraw header files don't use const
    hr = m_pIDDVAContainer->GetInternalMemInfo((GUID *)pGuid,
                                               &ddvaDataInfo,
                                               &ddvaInternalMemInfo);

    if (SUCCEEDED(hr)) {
        pamvaInternalMemInfo->dwScratchMemAlloc =
        ddvaInternalMemInfo.dwScratchMemAlloc;
    }

    return hr;
}


/******************************Public*Routine******************************\
* GetCompBufferInfo
*
* pGuid is an IN parameter
* pddvaUncompDataInfo is an IN parameter
* pdwNumTypesCompBuffers is an IN OUT paramter
* pddvaCompBufferInfo is an IN OUT paramter
*
* (caller should make sure to set the size of EACH struct)
* if pddvaCompBufferInfo is NULL,  pdwNumTypesCompBuffers should return
* back with the number of types of compressed buffers
* Otherwise pddvaCompBufferInfo is an array of *pdwNumTypesCompBuffers structures
*
* History:
* Wed 05/10/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRInputPin::GetCompBufferInfo(
    const GUID * pGuid,
    const AMVAUncompDataInfo *pamvaUncompDataInfo,
    LPDWORD pdwNumTypesCompBuffers,
    LPAMVACompBufferInfo pamvaCompBufferInfo)
{
    HRESULT hr = NOERROR;

    // Stays NULL if pamvaComBufferInfo is NULL
    DDVACompBufferInfo *pddvaCompBufferInfo = NULL;

    AMTRACE((TEXT("CVMRInputPin::GetCompBufferInfo")));

    CAutoLock cLock(m_pInterfaceLock);

    if (!m_pIDDVAContainer) {
        hr = E_FAIL;
        return hr;
    }

    DDVAUncompDataInfo ddvaDataInfo;
    INITDDSTRUCT(ddvaDataInfo);
    ddvaDataInfo.dwUncompWidth       = pamvaUncompDataInfo->dwUncompWidth;
    ddvaDataInfo.dwUncompHeight      = pamvaUncompDataInfo->dwUncompHeight;
    ddvaDataInfo.ddUncompPixelFormat = pamvaUncompDataInfo->ddUncompPixelFormat;


    if (pamvaCompBufferInfo) {

        pddvaCompBufferInfo = (DDVACompBufferInfo *)
                              _alloca(sizeof(DDVACompBufferInfo) *
                                      (*pdwNumTypesCompBuffers));

        for (DWORD j = 0; j < *pdwNumTypesCompBuffers; j++) {
            INITDDSTRUCT(pddvaCompBufferInfo[j]);
        }
    }

    hr = m_pIDDVAContainer->GetCompBufferInfo((GUID *)pGuid,
                                              &ddvaDataInfo,
                                              pdwNumTypesCompBuffers,
                                              pddvaCompBufferInfo);

    if ((SUCCEEDED(hr) || hr == DDERR_MOREDATA) && pamvaCompBufferInfo) {

        for (DWORD i = 0; i < *pdwNumTypesCompBuffers; i++) {

            DbgLog((LOG_TRACE, VA_TRACE_LEVEL,
                    TEXT("Compressed buffer type(%d) %d buffers")
                    TEXT(" width(%d) height(%d) bytes(%d)"),
                    i,
                    pddvaCompBufferInfo[i].dwNumCompBuffers,
                    pddvaCompBufferInfo[i].dwWidthToCreate,
                    pddvaCompBufferInfo[i].dwHeightToCreate,
                    pddvaCompBufferInfo[i].dwBytesToAllocate));


            pamvaCompBufferInfo[i].dwNumCompBuffers     =
                pddvaCompBufferInfo[i].dwNumCompBuffers;

            pamvaCompBufferInfo[i].dwWidthToCreate      =
                pddvaCompBufferInfo[i].dwWidthToCreate;

            pamvaCompBufferInfo[i].dwHeightToCreate     =
                pddvaCompBufferInfo[i].dwHeightToCreate;

            pamvaCompBufferInfo[i].dwBytesToAllocate    =
                pddvaCompBufferInfo[i].dwBytesToAllocate;

            pamvaCompBufferInfo[i].ddCompCaps           =
                pddvaCompBufferInfo[i].ddCompCaps;

            pamvaCompBufferInfo[i].ddPixelFormat        =
                pddvaCompBufferInfo[i].ddPixelFormat;
        }
    }

    return hr;
}


/*****************************Private*Routine******************************\
* CheckValidMCConnection
*
*
*
* History:
* Wed 05/10/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::CheckValidMCConnection()
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVMRInputPin::CheckValidMCConnection")));

    // if not connected, this function does not make much sense
//  if (!IsCompletelyConnected()) {
//      DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
//              TEXT("pin not connected, exiting")));
//      hr = VFW_E_NOT_CONNECTED;
//      return hr;
//  }
//
//  if (m_RenderTransport != AM_VIDEOACCELERATOR) {
//      hr = VFW_E_INVALIDSUBTYPE;
//      return hr;
//  }

    return hr;
}


/******************************Public*Routine******************************\
* GetInternalCompBufferInfo
*
*
*
* History:
* Wed 05/10/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRInputPin::GetInternalCompBufferInfo(
    LPDWORD pdwNumTypesCompBuffers,
    LPAMVACompBufferInfo pamvaCompBufferInfo)
{
    AMTRACE((TEXT("CVMRInputPin::GetInternalCompBufferInfo")));

    HRESULT hr = NOERROR;
    CAutoLock cLock(m_pInterfaceLock);

    // make sure that we have a valid motion-comp connection
    hr = CheckValidMCConnection();
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("CheckValidMCConnection failed, hr = 0x%x"), hr));
        return hr;
    }

    ASSERT(m_pIDDVAContainer);

    DDVACompBufferInfo ddvaCompBufferInfo;
    INITDDSTRUCT(ddvaCompBufferInfo);

    AMVAUncompDataInfo amvaUncompDataInfo;
    amvaUncompDataInfo.dwUncompWidth       = m_ddUncompDataInfo.dwUncompWidth;
    amvaUncompDataInfo.dwUncompHeight      = m_ddUncompDataInfo.dwUncompHeight;
    amvaUncompDataInfo.ddUncompPixelFormat = m_ddUncompDataInfo.ddUncompPixelFormat;

    hr = GetCompBufferInfo(&m_mcGuid, &amvaUncompDataInfo,
                           pdwNumTypesCompBuffers, pamvaCompBufferInfo);

    return hr;
}


/******************************Public*Routine******************************\
* BeginFrame
*
*
*
* History:
* Wed 05/10/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRInputPin::BeginFrame(
    const AMVABeginFrameInfo *pamvaBeginFrameInfo
    )
{
    AMTRACE((TEXT("CVMRInputPin::BeginFrame")));

    // BUGBUG - check surface isn't being flipped
    HRESULT hr = NOERROR;
    DDVABeginFrameInfo ddvaBeginFrameInfo;
    SURFACE_INFO *pSurfInfo;

    CAutoLock cLock(m_pInterfaceLock);

    if (!pamvaBeginFrameInfo) {
        hr = E_POINTER;
        return hr;
    }

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL,
            TEXT("BeginFrame index %d"),
            pamvaBeginFrameInfo->dwDestSurfaceIndex));

    // make sure that we have a valid motion-comp connection
    hr = CheckValidMCConnection();
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("CheckValidMCConnection failed, hr = 0x%x"), hr));
        return hr;
    }


    INITDDSTRUCT(ddvaBeginFrameInfo);

    pSurfInfo = SurfaceInfoFromTypeAndIndex(
                                           0xFFFFFFFF,
                                           pamvaBeginFrameInfo->dwDestSurfaceIndex);
    if (pSurfInfo == NULL) {
        hr = E_INVALIDARG;
        return hr;
    }
    ddvaBeginFrameInfo.pddDestSurface = pSurfInfo->pSurface;

    DbgLog((LOG_TRACE, 2, TEXT("BeginFrame to surface %p"), pSurfInfo->pSurface));


    ddvaBeginFrameInfo.dwSizeInputData  = pamvaBeginFrameInfo->dwSizeInputData;
    ddvaBeginFrameInfo.pInputData       = pamvaBeginFrameInfo->pInputData;
    ddvaBeginFrameInfo.dwSizeOutputData = pamvaBeginFrameInfo->dwSizeOutputData;
    ddvaBeginFrameInfo.pOutputData      = pamvaBeginFrameInfo->pOutputData;

    ASSERT(m_pIDDVideoAccelerator);
    hr = m_pIDDVideoAccelerator->BeginFrame(&ddvaBeginFrameInfo);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("m_pIDDVideoAccelerator->BeginFrame failed, hr = 0x%x"), hr));
        return hr;
    }

    return hr;
}

/******************************Public*Routine******************************\
* EndFrame
*
* end a frame, the pMiscData is passed directly to the hal
* only valid to call this after the pins are connected
*
* History:
* Wed 05/10/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRInputPin::EndFrame(
    const AMVAEndFrameInfo *pEndFrameInfo
    )
{
    AMTRACE((TEXT("CVMRInputPin::EndFrame")));
    HRESULT hr = NOERROR;

    CAutoLock cLock(m_pInterfaceLock);

    if (NULL == pEndFrameInfo) {
        hr = E_POINTER;
        return hr;
    }

    // make sure that we have a valid motion-comp connection
    hr = CheckValidMCConnection();
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("CheckValidMCConnection failed, hr = 0x%x"), hr));
        return hr;
    }

    ASSERT(m_pIDDVideoAccelerator);

    DDVAEndFrameInfo ddvaEndFrameInfo;
    INITDDSTRUCT(ddvaEndFrameInfo);
    ddvaEndFrameInfo.dwSizeMiscData = pEndFrameInfo->dwSizeMiscData;
    ddvaEndFrameInfo.pMiscData      = pEndFrameInfo->pMiscData;

    hr = m_pIDDVideoAccelerator->EndFrame(&ddvaEndFrameInfo);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("m_pIDDVideoAccelerator->EndFrame failed, hr = 0x%x"),
                hr));
        return hr;
    }

    return hr;
}


/*****************************Private*Routine******************************\
* SurfaceInfoFromTypeAndIndex
*
* Get surface into structure given buffer type and buffer index
*
* History:
* Wed 05/10/2000 - StEstrop - Created
*
\**************************************************************************/
SURFACE_INFO *
CVMRInputPin::SurfaceInfoFromTypeAndIndex(
    DWORD dwTypeIndex,
    DWORD dwBufferIndex
    )
{
    AMTRACE((TEXT("CVMRInputPin::SurfaceInfoFromTypeAndIndex")));

    LPCOMP_SURFACE_INFO pCompSurfInfo;

    // make sure that type-index is less than the number of types
    if ((DWORD)(dwTypeIndex + 1) > m_dwCompSurfTypes) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("dwTypeIndex is invalid, dwTypeIndex = %d,")
                TEXT(" m_dwCompSurfTypes = %d"),
                dwTypeIndex, m_dwCompSurfTypes));
        return NULL;
    }


    // cache the pointer to the list they are interested in
    // Add 1 to allow for uncompressed surfaces
    pCompSurfInfo = m_pCompSurfInfo + (DWORD)(dwTypeIndex + 1);
    ASSERT(pCompSurfInfo);
    if (dwBufferIndex >= pCompSurfInfo->dwAllocated) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("dwBufferIndex is invalid, dwBufferIndex = %d,")
                TEXT(" dwAllocated = %d"),
                dwBufferIndex, pCompSurfInfo->dwAllocated));
        return NULL;
    }
    ASSERT(pCompSurfInfo->dwAllocated != 0);

    // get the pointer to the next available unlocked buffer info struct
    return pCompSurfInfo->pSurfInfo + dwBufferIndex;

}

/******************************Public*Routine******************************\
* GetBuffer
*
* Cycle through the compressed buffers
*
* History:
* Wed 05/10/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRInputPin::GetBuffer(
    DWORD dwTypeIndex,
    DWORD dwBufferIndex,
    BOOL bReadOnly,
    LPVOID *ppBuffer,
    LPLONG lpStride
    )
{
    AMTRACE((TEXT("CVMRInputPin::GetBuffer")));

    HRESULT hr = NOERROR;
    LPSURFACE_INFO pSurfInfo = NULL;
    DDSURFACEDESC2 ddsd;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL,
            TEXT("Entering CVMRInputPin::GetBuffer type %d, index %d"),
            dwTypeIndex, dwBufferIndex));

    CAutoLock cLock(m_pInterfaceLock);

    // make sure that we have a valid motion-comp connection
    hr = CheckValidMCConnection();
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("CheckValidMCConnection failed, hr = 0x%x"), hr));
        return hr;
    }

    if (ppBuffer == NULL || lpStride == NULL) {
        hr = E_POINTER;
        return hr;
    }

    pSurfInfo = SurfaceInfoFromTypeAndIndex(dwTypeIndex, dwBufferIndex);

    if (pSurfInfo == NULL) {
        hr = E_INVALIDARG;
        return hr;
    }

    // Check buffer not already locked
    if (pSurfInfo->pBuffer != NULL) {
        hr = HRESULT_FROM_WIN32(ERROR_BUSY);
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("No more free buffers left or the decoder is releasing")
                TEXT(" buffers out of order, returning E_UNEXPECTED")));
        return hr;
    }

    //  Wait until previous motion comp operation is complete
    while (DDERR_WASSTILLDRAWING ==
           m_pIDDVideoAccelerator->QueryRenderStatus(
                pSurfInfo->pSurface,
                bReadOnly ? DDVA_QUERYRENDERSTATUSF_READ : 0)) {
        Sleep(1);
    }

    //  Now lock the surface
    INITDDSTRUCT(ddsd);

    for (; ;) {
        //  BUGBUG - check for uncompressed surfaces??
        hr = pSurfInfo->pSurface->Lock(NULL, &ddsd, DDLOCK_NOSYSLOCK, NULL);
        if (hr == DDERR_WASSTILLDRAWING) {
            DbgLog((LOG_TRACE, 1, TEXT("Compressed surface is busy")));
            Sleep(1);
        }
        else {
            break;
        }
    }

    if (dwBufferIndex == 0xFFFFFFFF && !bReadOnly) {
        //  Check if surface is being displayed
        //  BUGBUG implement
    }

    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("pSurfInfo->pSurface->Lock failed, hr = 0x%x"), hr));
        return hr;
    }

    pSurfInfo->pBuffer = ddsd.lpSurface;
    *ppBuffer = ddsd.lpSurface;
    *lpStride = ddsd.lPitch;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL,
            TEXT("leaving CVMRInputPin::GetBuffer returned 0x%8.8X"), hr));
    return hr;
}


/******************************Public*Routine******************************\
* ReleaseBuffer
*
* unlock a compressed buffer
*
* History:
* Wed 05/10/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRInputPin::ReleaseBuffer(
    DWORD dwTypeIndex,
    DWORD dwBufferIndex
    )
{
    AMTRACE((TEXT("CVMRInputPin::ReleaseBuffer")));

    HRESULT hr = NOERROR;
    LPSURFACE_INFO pSurfInfo;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL,
            TEXT("Entering CVMRInputPin::ReleaseBuffer type %d, index %d"),
            dwTypeIndex, dwBufferIndex));

    CAutoLock cLock(m_pInterfaceLock);

    // make sure that we have a valid motion-comp connection
    hr = CheckValidMCConnection();
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("CheckValidMCConnection failed, hr = 0x%x"), hr));
        return hr;
    }

    pSurfInfo = SurfaceInfoFromTypeAndIndex(dwTypeIndex, dwBufferIndex);
    if (NULL == pSurfInfo) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("GetInfoFromCookie failed, hr = 0x%x"), hr));
        hr = E_INVALIDARG;
        return hr;
    }
    // make sure there is a valid buffer pointer and it is the same as
    // what we have cached
    if (NULL == pSurfInfo->pBuffer) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("pBuffer is not valid, pBuffer = 0x%x, pSurfInfo->pBuffer")
                TEXT(" = 0x%x"), pSurfInfo->pBuffer, pSurfInfo->pSurface));
        hr = HRESULT_FROM_WIN32(ERROR_NOT_LOCKED);
        return hr;
    }

    //  For some reason IDirectDrawSurface7 wants an LPRECT here
    //  I hope NULL is OK
    hr = pSurfInfo->pSurface->Unlock(NULL);
    if (SUCCEEDED(hr)) {
        pSurfInfo->pBuffer = NULL;
    }
    else {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("pSurfInfo->pSurface->Unlock failed, hr = 0x%x"), hr));
    }

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL,
            TEXT("leaving CVMRInputPin::ReleaseBuffer returned 0x%8.8X"), hr));
    return hr;
}


/******************************Public*Routine******************************\
* Execute
*
* Perform a decode operation
*
* History:
* Wed 05/10/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRInputPin::Execute(
    DWORD dwFunction,
    LPVOID lpPrivateInputData,
    DWORD cbPrivateInputData,
    LPVOID lpPrivateOutputData,
    DWORD cbPrivateOutputData,
    DWORD dwNumBuffers,
    const AMVABUFFERINFO *pamvaBufferInfo
    )
{
    AMTRACE((TEXT("CVMRInputPin::Execute")));

    HRESULT hr = NOERROR;
    DWORD i = 0;
    DDVABUFFERINFO *pddvaBufferInfo = NULL;

    CAutoLock cLock(m_pInterfaceLock);

    // make sure that we have a valid motion-comp connection
    hr = CheckValidMCConnection();
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("CheckValidMCConnection failed, hr = 0x%x"), hr));
        return hr;
    }

    pddvaBufferInfo = (DDVABUFFERINFO *)_alloca(sizeof(DDVABUFFERINFO) * dwNumBuffers);

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL, TEXT("Execute Function %d, %d buffers :"),
            dwFunction, dwNumBuffers));

    for (i = 0; i < dwNumBuffers; i++) {
        DbgLog((LOG_TRACE, VA_TRACE_LEVEL,
                TEXT("    Type(%d) Index(%d) offset(%d) size(%d)"),
                pamvaBufferInfo[i].dwTypeIndex,
                pamvaBufferInfo[i].dwBufferIndex,
                pamvaBufferInfo[i].dwDataOffset,
                pamvaBufferInfo[i].dwDataSize));

        LPSURFACE_INFO pSurfInfo =
        SurfaceInfoFromTypeAndIndex(
                                   pamvaBufferInfo[i].dwTypeIndex,
                                   pamvaBufferInfo[i].dwBufferIndex);

        if (pSurfInfo == NULL) {
            DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                    TEXT("GetInfoFromCookie failed, hr = 0x%x, i = %d"),
                    hr, i));

            hr = E_INVALIDARG;
            return hr;
        }

        INITDDSTRUCT(pddvaBufferInfo[i]);
        pddvaBufferInfo[i].dwDataOffset   = pamvaBufferInfo[i].dwDataOffset;
        pddvaBufferInfo[i].dwDataSize     = pamvaBufferInfo[i].dwDataSize;
        pddvaBufferInfo[i].pddCompSurface = pSurfInfo->pSurface;
    }

    ASSERT(m_pIDDVideoAccelerator);


    hr = m_pIDDVideoAccelerator->Execute(dwFunction,
                                         lpPrivateInputData,
                                         cbPrivateInputData,
                                         lpPrivateOutputData,
                                         cbPrivateOutputData,
                                         dwNumBuffers,
                                         pddvaBufferInfo);

    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("m_pIDDVideoAccelerator->Execute failed, hr = 0x%x"),
                hr));
        return hr;
    }

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL,
            TEXT("leaving CVMRInputPin::Execute returned 0x%8.8X"), hr));
    return hr;
}

/******************************Public*Routine******************************\
* QueryRenderStatus
*
* QueryRenderStatus of a particular (possibly a set of) macro block
* dwNumBlocks is an IN parameter
*
* pdwCookies is an IN parameter which is array (of length dwNumBlocks)
* of cookies which server as identifiers for the corresponding members of
* pddvaMacroBlockInfo
*
* pddvaMacroBlockInfo is an IN parameter which is array (of length
* dwNumBlocks) of structures only valid to call this after the pins
* are connected
*
* History:
* Wed 05/10/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRInputPin::QueryRenderStatus(
    DWORD dwTypeIndex,
    DWORD dwBufferIndex,
    DWORD dwFlags
    )
{
    AMTRACE((TEXT("CVMRInputPin::QueryRenderStatus")));

    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL,
            TEXT("Entering CVMRInputPin::QueryRenderStatus - type(%d), ")
            TEXT("buffer(%d), flags(0x%8.8X)"),
            dwTypeIndex, dwBufferIndex, dwFlags));

    CAutoLock cLock(m_pInterfaceLock);

    LPSURFACE_INFO pSurfInfo =
    SurfaceInfoFromTypeAndIndex(dwTypeIndex, dwBufferIndex);

    if (pSurfInfo == NULL) {
        hr = E_OUTOFMEMORY;
        return hr;
    }

    // make sure that we have a valid motion-comp connection
    hr = CheckValidMCConnection();
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("CheckValidMCConnection failed, hr = 0x%x"), hr));
        return hr;
    }

    hr = m_pIDDVideoAccelerator->QueryRenderStatus(pSurfInfo->pSurface, dwFlags);
    if (FAILED(hr) && hr != DDERR_WASSTILLDRAWING) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("m_pIDDVideoAccelerator->QueryRenderStatus")
                TEXT(" failed, hr = 0x%x"), hr));
        return hr;
    }

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL,
            TEXT("leaving CVMRInputPin::QueryRenderStatus returned 0x%8.8X"),
            hr));

    if (hr == DDERR_WASSTILLDRAWING) {
        hr = E_PENDING;
    }

    return hr;
}


/*****************************Private*Routine******************************\
* FlipDVASurface
*
* Flips our internal surface pointers to match those used by DDraw.
*
* History:
* Mon 12/04/2000 - StEstrop - Created
*
\**************************************************************************/
void
CVMRInputPin::FlipDVASurface(
    DWORD dwFlipToIndex,
    DWORD dwFlipFromIndex
    )
{
    AMTRACE((TEXT("CVMRInputPin::FlipDVASurface")));

    LPDIRECTDRAWSURFACE7 pTempSurface;

    // we should have successfully called flip by this point, swap the two
    pTempSurface = m_pCompSurfInfo[0].pSurfInfo[dwFlipToIndex].pSurface;

    m_pCompSurfInfo[0].pSurfInfo[dwFlipToIndex].pSurface =
            m_pCompSurfInfo[0].pSurfInfo[dwFlipFromIndex].pSurface;

    m_pCompSurfInfo[0].pSurfInfo[dwFlipFromIndex].pSurface = pTempSurface;
}



/******************************Public*Routine******************************\
* DisplayFrame
*
* This function needs re-writting and possible moving into the AP object.
*
* History:
* Wed 05/10/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRInputPin::DisplayFrame(
    DWORD dwFlipToIndex,
    IMediaSample *pMediaSample)
{
    AMTRACE((TEXT("CVMRInputPin::DisplayFrame")));

#if defined( EHOME_WMI_INSTRUMENTATION )
    PERFLOG_STREAMTRACE(
        1,
        PERFINFO_STREAMTRACE_VMR_END_DECODE,
        0, 0, 0, 0, 0 );
#endif

    HRESULT hr = NOERROR;

    DWORD dwNumUncompFrames = m_dwBackBufferCount + 1;
    DWORD dwFlipFromIndex = 0, i = 0;
    SURFACE_INFO *pSurfInfo;

    DbgLog((LOG_TRACE, VA_TRACE_LEVEL,
            TEXT("Entering CVMRInputPin::DisplayFrame - index %d"),
            dwFlipToIndex));

    CAutoLock cLock(m_pInterfaceLock);

    // make sure that we have a valid motion-comp connection
    hr = CheckValidMCConnection();
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                TEXT("CheckValidMCConnection failed, hr = 0x%x"), hr));
        return hr;
    }

    pSurfInfo = SurfaceInfoFromTypeAndIndex(0xFFFFFFFF, dwFlipToIndex);
    if (pSurfInfo == NULL) {
        hr = E_INVALIDARG;
        DbgLog((LOG_ERROR, VA_ERROR_LEVEL, TEXT("dwFlipToIndex not valid")));
        return hr;
    }

    for (i = 0; i < dwNumUncompFrames; i++) {
        if (IsEqualObject(m_pCompSurfInfo[0].pSurfInfo[i].pSurface, m_pDDS)) {
            dwFlipFromIndex = i;
            break;
        }
    }

    //
    // If we are in pass thru mode it is very important that we
    // know whether a Flip completed or not.  If are in mixer mode
    // we have to be notified when the mixer has finished with the sample
    //

    if (m_pRenderer->m_VMRModePassThru) {
        m_pRenderer->m_hrSurfaceFlipped = E_FAIL;
    }
    else {
        ResetEvent(m_hDXVAEvent);
    }


    //
    // Create our temp VMR sample and intialize it from the sample
    // specified by the upstream decoder, copy across all the relevant
    // properties.
    //

    IMediaSample2 *pSample2;
    CVMRMediaSample vmrSamp(TEXT(""), (CBaseAllocator *)-1, &hr, NULL, 0, m_hDXVAEvent);

    if (SUCCEEDED(pMediaSample->QueryInterface(IID_IMediaSample2, (void **)&pSample2))) {

        AM_SAMPLE2_PROPERTIES SampleProps;
        hr = pSample2->GetProperties(sizeof(m_SampleProps), (PBYTE)&SampleProps);
        pSample2->Release();

        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                    TEXT("GetProperties on the supplied ")
                    TEXT("media sample failed hr = %#X"), hr));
            return hr;
        }

        hr = vmrSamp.SetProps(SampleProps, pSurfInfo->pSurface);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                    TEXT("SetProperties on the VMR mixer ")
                    TEXT("media sample failed hr = %#X"), hr));
            return hr;
        }
    }
    else
    {

        REFERENCE_TIME rtSTime = 0, rtETime = 0;
        if (VFW_E_SAMPLE_TIME_NOT_SET ==
                pMediaSample->GetTime(&rtSTime, &rtETime)) {

            vmrSamp.SetTime(NULL, NULL);
        }
        else {
            vmrSamp.SetTime(&rtSTime, &rtETime);
        }

        AM_MEDIA_TYPE *pMediaType;
        hr = pMediaSample->GetMediaType(&pMediaType);

        if (hr == E_OUTOFMEMORY) {
            DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                    TEXT("Out off memory calling GetMediaType ")
                    TEXT("on the media sample")));
            return hr;
        }

        if (hr == S_OK) {

            hr = vmrSamp.SetMediaType(pMediaType);
            DeleteMediaType(pMediaType);

            if (hr != S_OK) {
                DbgLog((LOG_ERROR, VA_ERROR_LEVEL,
                        TEXT("SetMediaType on the VMR mixer ")
                        TEXT("media sample failed hr = %#X"), hr));
                return hr;
            }
        }

        vmrSamp.SetSurface(pSurfInfo->pSurface);
    }


    //
    // We do not want to hold any locks during Receive
    //
    m_pInterfaceLock->Unlock();
    hr = Receive(&vmrSamp);
    m_pInterfaceLock->Lock();


    //
    // If we are in pass thru mode a DDraw flip may have
    // occurred.  DDraw switches the memory under the pointers
    // during a flip so mimic that in our list - but only if the
    // flip actually happened.
    //

    if (m_pRenderer->m_VMRModePassThru) {

        if (m_pRenderer->m_hrSurfaceFlipped == DD_OK) {
            FlipDVASurface(dwFlipToIndex, dwFlipFromIndex);
        }
    }
    else {

        //
        // wait for the sample to be released by the mixer, but only if the
        // sample was actuall placed onto one of the mixers queues.
        //

        if (hr == S_OK) {

            m_pInterfaceLock->Unlock();
            WaitForSingleObject(m_hDXVAEvent, INFINITE);
            m_pInterfaceLock->Lock();
        }
    }


    DbgLog((LOG_TRACE, VA_TRACE_LEVEL,
            TEXT("leaving CVMRInputPin::DisplayFrame return 0x%8.8X"), hr));

#if defined( EHOME_WMI_INSTRUMENTATION )
    //
    // From BryanW:
    //
    // Seems countintertuitive, however according to StEstrop, this
    // is the way we measure the time spent in the decoder.  This happens
    // to work.
    //
    PERFLOG_STREAMTRACE(
        1,
        PERFINFO_STREAMTRACE_VMR_BEGIN_DECODE,
        0, 0, 0, 0, 0 );
#endif

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\video\vmrallocator.cpp ===
/******************************Module*Header*******************************\
* Module Name: VMRAllocator.cpp
*
*
*
*
* Created: Tue 02/15/2000
* Author:  Stephen Estrop [StEstrop]
*
* Copyright (c) 2000 Microsoft Corporation
\**************************************************************************/
#include <streams.h>
#include <dvdmedia.h>
#include <windowsx.h>

#include "VMRenderer.h"

#if defined(CHECK_FOR_LEAKS)
#include "ifleak.h"
#endif

/******************************Public*Routine******************************\
* CVMRPinAllocator::CVMRPinAllocator
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
CVMRPinAllocator::CVMRPinAllocator(
    CVMRInputPin* pPin,
    CCritSec *pLock,
    HRESULT *phr
    ) :
    CBaseAllocator(NAME("Video Allocator"), NULL, phr, true, true),
    m_pPin(pPin),
    m_pInterfaceLock(pLock)
{
    AMTRACE((TEXT("CVMRPinAllocator::CVMRPinAllocator")));
}


/******************************Public*Routine******************************\
* NonDelegatingAddRef
*
* Overriden to increment the owning object's reference count
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP_(ULONG)
CVMRPinAllocator::NonDelegatingAddRef()
{
    AMTRACE((TEXT("CVMRPinAllocator::NonDelegatingAddRef")));
    return m_pPin->AddRef();
}

/******************************Public*Routine******************************\
* NonDelegatingQueryInterface
*
*
*
* History:
* Thu 12/14/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRPinAllocator::NonDelegatingQueryInterface(REFIID riid,VOID **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;

    hr = CBaseAllocator::NonDelegatingQueryInterface(riid,ppv);

#if defined(CHECK_FOR_LEAKS)
    if (hr == S_OK) {
        _pIFLeak->AddThunk((IUnknown **)ppv, "VMR Allocator Object",  riid);
    }
#endif

    return hr;

}

/******************************Public*Routine******************************\
* NonDelegatingRelease
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP_(ULONG)
CVMRPinAllocator::NonDelegatingRelease()
{
    AMTRACE((TEXT("CVMRPinAllocator::NonDelegatingRelease")));
    return m_pPin->Release();
}


/******************************Public*Routine******************************\
* SetProperties
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRPinAllocator::SetProperties(
    ALLOCATOR_PROPERTIES* pRequest,
    ALLOCATOR_PROPERTIES* pActual
    )
{
    AMTRACE((TEXT("CVMRPinAllocator::SetProperties")));

    HRESULT hr = CBaseAllocator::SetProperties(pRequest, pActual);
    if (SUCCEEDED(hr)) {
        hr = m_pPin->OnSetProperties(pRequest, pActual);
    }
    else {
        DbgLog((LOG_ERROR, 1,
                TEXT("CBaseAllocator::SetProperties failed hr=%#X"), hr));
    }

    if (SUCCEEDED(hr)) {
        hr = m_pPin->m_pRenderer->OnSetProperties(m_pPin);
    }

    return hr;
}


/******************************Public*Routine******************************\
* CVMRPinAllocator::GetBuffer
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRPinAllocator::GetBuffer(
    IMediaSample **ppSample,
    REFERENCE_TIME *pStartTime,
    REFERENCE_TIME *pEndTime,
    DWORD dwFlags
    )
{
    AMTRACE((TEXT("CVMRPinAllocator::GetBuffer")));
    HRESULT hr = S_OK;
    IMediaSample *pSample = NULL;

    hr = CBaseAllocator::GetBuffer(&pSample, pStartTime, pEndTime, dwFlags);
    DbgLog((LOG_TRACE, 2, TEXT("pSample= %#X"), pSample));

    if (SUCCEEDED(hr)) {

        hr = m_pPin->OnGetBuffer(pSample, pStartTime, pEndTime, dwFlags);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 1, TEXT("CVMRPin::OnGetBuffer failed hr= %#X"), hr));
        }
    }
    else {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseAllocator::GetBuffer failed hr= %#X"), hr));
    }

    if (FAILED(hr) && pSample) {
        pSample->Release();
        pSample = NULL;
    }

    *ppSample = pSample;
    return hr;
}


/******************************Public*Routine******************************\
* CVMRPinAllocator::ReleaseBuffer
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRPinAllocator::ReleaseBuffer(
    IMediaSample *pMediaSample
    )
{
    AMTRACE((TEXT("CVMRPinAllocator::ReleaseBuffer")));
    DbgLog((LOG_TRACE, 2, TEXT("pMediaSample= %#X"), pMediaSample));

    CVMRMediaSample* pVMRSample = (CVMRMediaSample*)pMediaSample;
    LPBYTE lpSample;
    HRESULT hr = S_OK;

    if (m_pPin->m_pVidSurfs) {
        CAutoLock l(&m_pPin->m_DeinterlaceLock);
        DWORD i = pVMRSample->GetIndex();
        m_pPin->m_pVidSurfs[i].InUse = FALSE;
    }

    if (S_OK == pVMRSample->IsSurfaceLocked()) {
        hr = pVMRSample->UnlockSurface();
        if (hr == DDERR_SURFACELOST) {
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr)) {

        // Copy of base class code - put at end of the list

        CheckPointer(pMediaSample, E_POINTER);
        ValidateReadPtr(pMediaSample, sizeof(IMediaSample));
        BOOL bRelease = FALSE;
        {
            CAutoLock cal(this);

            /* Put back on the free list */

            CMediaSample **ppTail;
            for (ppTail = &m_lFree.m_List; *ppTail;
                ppTail = &((CVMRMediaSample *)(*ppTail))->Next()) {
            }
            *ppTail = (CMediaSample *)pMediaSample;
            ((CVMRMediaSample *)pMediaSample)->Next() = NULL;
            m_lFree.m_nOnList++;

            if (m_lWaiting != 0) {
                NotifySample();
            }

            // if there is a pending Decommit, then we need to complete it by
            // calling Free() when the last buffer is placed on the free list

            LONG l1 = m_lFree.GetCount();
            if (m_bDecommitInProgress && (l1 == m_lAllocated)) {
                Free();
                m_bDecommitInProgress = FALSE;
                bRelease = TRUE;
            }
        }

        if (m_pNotify) {
            m_pNotify->NotifyRelease();
        }
        // For each buffer there is one AddRef, made in GetBuffer and released
        // here. This may cause the allocator and all samples to be deleted
        if (bRelease)
        {
            Release();
        }
    }

    return hr;
}

/******************************Public*Routine******************************\
* CVMRPinAllocator::Alloc
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRPinAllocator::Alloc()
{
    AMTRACE((TEXT("CVMRPinAllocator::Alloc")));

    ASSERT(m_lAllocated == 0);

    HRESULT hr = S_OK;
    CVMRMediaSample** ppSampleList = NULL;
    LONG lToAllocate;

    lToAllocate = m_lCount;

    if (m_pPin->m_dwBackBufferCount > 1) {
        lToAllocate++;
    }

    ppSampleList = new CVMRMediaSample*[lToAllocate];
    if (!ppSampleList) {
        DbgLog((LOG_ERROR, 1, TEXT("new failed - trying to allocate %d bytes"), lToAllocate));
        return E_OUTOFMEMORY;
    }

    for (LONG i = 0; i < lToAllocate; i++) {

        ppSampleList[i] = new CVMRMediaSample(TEXT("VMRMediaSample"),
                                              this, &hr, NULL, 0);
        if (!ppSampleList[i]) {
            DbgLog((LOG_ERROR, 1, TEXT("new failed - trying to allocate %d bytes"),
                    sizeof(CVMRMediaSample)));
            DbgLog((LOG_ERROR, 1, TEXT("new failed")));
            for (LONG j = 0; j < i; j++ )
                delete ppSampleList[j];
            delete [] ppSampleList;
            return E_OUTOFMEMORY;
        }

        if (FAILED(hr)) {
            delete ppSampleList[i];
            DbgLog((LOG_ERROR, 1, TEXT("CVMRMediaSample constructor failed")));
            break;
        }

        // Add the completed sample to the available list
        m_lAllocated++;
        m_lFree.Add(ppSampleList[i]);
    }

    if (SUCCEEDED(hr)) {
        hr = m_pPin->OnAlloc(ppSampleList, lToAllocate);

        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 1, TEXT("m_pPin->OnAlloc(), hr = 0x%x"), hr));
            Free();
        }
    }

    delete [] ppSampleList;

    return hr;
}


/******************************Public*Routine******************************\
* CVMRPinAllocator::Free()
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
void
CVMRPinAllocator::Free()
{
    AMTRACE((TEXT("CVMRPinAllocator::Free")));

    ASSERT(m_lAllocated == m_lFree.GetCount());
    CVMRMediaSample *pSample;

    while (m_lFree.GetCount() != 0) {
        pSample = (CVMRMediaSample *) m_lFree.RemoveHead();
        delete pSample;
    }

    m_lAllocated = 0;
    DbgLog((LOG_TRACE,2,TEXT("All buffers free on pin#%d"), m_pPin->m_dwPinID));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\video\vmrpin.cpp ===
/******************************Module*Header*******************************\
* Module Name: VMRPin.cpp
*
*
*
*
* Created: Tue 02/15/2000
* Author:  Stephen Estrop [StEstrop]
*
* Copyright (c) 2000 Microsoft Corporat
\**************************************************************************/
#include <streams.h>
#include <dvdmedia.h>
#include <windowsx.h>

#include "VMRenderer.h"
#if defined(CHECK_FOR_LEAKS)
#include "ifleak.h"
#endif

#include <malloc.h>     // for __alloca

#if defined( EHOME_WMI_INSTRUMENTATION )
#include "dxmperf.h"
#endif

/******************************Public*Routine******************************\
* CVMRInputPin::CVMRInputPin
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
#pragma warning(disable:4355)
CVMRInputPin::CVMRInputPin(
    DWORD dwID,
    CVMRFilter* pRenderer,
    CCritSec* pLock,
    HRESULT* phr,
    LPCWSTR pPinName
    ) :
    CBaseInputPin(NAME("New Renderer pin"), pRenderer, pLock, phr, pPinName),
    m_PinAllocator(this, pLock, phr),
    m_pInterfaceLock(pLock),
    m_pRenderer(pRenderer),
    m_bDynamicFormatNeeded(false),
    m_dwPinID(dwID),
    m_pDDS(NULL),
    m_pIOverlay(this),
    m_RenderTransport(AM_IMEMINPUTPIN),
    m_bVideoAcceleratorSupported(FALSE),
    m_bActive(false),
    m_dwBackBufferCount(0),
    m_dwCompSurfTypes(0),
    m_pCompSurfInfo(NULL),
    m_pIDDVAContainer(NULL),
    m_pIDDVideoAccelerator(NULL),
    m_pIVANotify(NULL),
    m_hEndOfStream(NULL),
    m_hDXVAEvent(NULL),
    m_dwDeltaDecode(0),
    m_fInDFC(FALSE),
    m_pVidSurfs(NULL),
    m_pVidHistorySamps(NULL),
    m_dwNumSamples(0),
    m_dwNumHistorySamples(0),
    m_DeinterlaceUserGUIDSet(FALSE),
    m_InterlacedStream(FALSE),
    m_SampleCount(0),
    m_SamplePeriod(0)
{
    AMTRACE((TEXT("CVMRInputPin::CVMRInputPin")));

    ZeroMemory(&m_mcGuid,              sizeof(m_mcGuid));
    ZeroMemory(&m_ddUncompDataInfo,    sizeof(m_ddUncompDataInfo));
    ZeroMemory(&m_ddvaInternalMemInfo, sizeof(m_ddvaInternalMemInfo));

    ZeroMemory(&m_DeinterlaceCaps,     sizeof(m_DeinterlaceCaps));
    ZeroMemory(&m_DeinterlaceGUID,     sizeof(m_DeinterlaceGUID));
    ZeroMemory(&m_DeinterlaceUserGUID, sizeof(m_DeinterlaceUserGUID));

    SetReconnectWhenActive(true);
    FrontBufferStale(FALSE);
    CompletelyConnected(FALSE);

}

/******************************Public*Routine******************************\
* CVMRInputPin::~CVMRInputPin()
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
CVMRInputPin::~CVMRInputPin()
{
    AMTRACE((TEXT("CVMRInputPin::~CVMRInputPin")));
}


/******************************Public*Routine******************************\
* AddRef, Release and QueryInterface
*
* Standard COM stuff
*
* History:
* Mon 05/01/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP_(ULONG)
CVMRInputPin::NonDelegatingAddRef()
{
    return m_pRenderer->AddRef();
}

STDMETHODIMP_(ULONG)
CVMRInputPin::NonDelegatingRelease()
{
    return m_pRenderer->Release();
}

STDMETHODIMP
CVMRInputPin::NonDelegatingQueryInterface(REFIID riid,VOID **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;

    if (riid == IID_IOverlay) {
        hr = GetInterface(&m_pIOverlay, ppv);
    }
    else if (riid == IID_IPinConnection) {
        hr = GetInterface((IPinConnection *)this, ppv);
    }
    else if (riid == IID_IAMVideoAccelerator) {
        hr = GetInterface((IAMVideoAccelerator *)this, ppv);
    }
    else if (riid == IID_IVMRVideoStreamControl) {
        hr = GetInterface((IVMRVideoStreamControl*)this, ppv);
    }
    else {
        hr = CBaseInputPin::NonDelegatingQueryInterface(riid,ppv);
    }

#if defined(CHECK_FOR_LEAKS)
    if (hr == S_OK) {
        _pIFLeak->AddThunk((IUnknown **)ppv, "VMR Pin Object",  riid);
    }
#endif

    return hr;
}


/******************************Public*Routine******************************\
* GetWindowHandle
*
*
*
* History:
* Mon 05/01/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::GetWindowHandle(
    HWND* pHwnd
    )
{
    AMTRACE((TEXT("CVMRInputPin::GetWindowHandle")));
    CAutoLock cRendererLock(&m_pRenderer->m_InterfaceLock);
    CheckPointer(pHwnd, E_POINTER);

    HRESULT hr = VFW_E_WRONG_STATE;

    if ((m_pRenderer->m_VMRMode & VMRMode_Windowed) &&
         m_pRenderer->m_pVideoWindow) {

        *pHwnd = m_pRenderer->m_pVideoWindow->GetWindowHWND();
        hr = S_OK;
    }

    return hr;
}


/******************************Public*Routine******************************\
* DynamicQueryAccept
*
* Do you accept this type chane in your current state?
*
* History:
* Tue 05/09/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRInputPin::DynamicQueryAccept(
    const AM_MEDIA_TYPE *pmt
    )
{
    AMTRACE((TEXT("CVMRInputPin::DynamicQueryAccept")));
    CheckPointer(pmt, E_POINTER);

    CAutoLock cLock(m_pInterfaceLock);

    DbgLog((LOG_TRACE, 0, TEXT("CVMRInputPin::DynamicQueryAccept called")));

    //
    // I want CheckMedia type to behave as though we aren't connected to
    // anything yet - hence the messing about with m_bConnected.
    //
    CMediaType cmt(*pmt);
    BOOL bConnected = IsCompletelyConnected();
    CompletelyConnected(FALSE);
    HRESULT  hr = CheckMediaType(&cmt);
    CompletelyConnected(bConnected);

    return hr;
}

/******************************Public*Routine******************************\
* NotifyEndOfStream
*
* Set event when EndOfStream received - do NOT pass it on
* This condition is cancelled by a flush or Stop
*
* History:
* Tue 05/09/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRInputPin::NotifyEndOfStream(
    HANDLE hNotifyEvent
    )
{
    AMTRACE((TEXT("CVMRInputPin::NotifyEndOfStream")));
    CAutoLock cObjectLock(m_pLock);
    m_hEndOfStream = hNotifyEvent;
    return S_OK;
}

/******************************Public*Routine******************************\
* IsEndPin
*
* Are you an 'end pin'
*
* History:
* Tue 05/09/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRInputPin::IsEndPin()
{
    AMTRACE((TEXT("CVMRInputPin::IsEndPin")));
    return S_OK;
}


/******************************Public*Routine******************************\
* DynamicDisconnect
*
*
*
* History:
* Tue 05/09/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRInputPin::DynamicDisconnect()
{
    AMTRACE((TEXT("CVMRInputPin::DynamicDisconnect")));
    CAutoLock cObjectLock(m_pLock);
    DbgLog((LOG_TRACE,2,TEXT("DynamicDisconnect called on Stream %d"), m_dwPinID));
    return CBasePin::DisconnectInternal();
}


/*****************************Private*Routine******************************\
* DynamicReconfigureMEM
*
* Performs a dynamic reconfiguration of the connection between the VMR and
* the filter upstream of this pin for the IMemInputPin connection protocol.
*
* History:
* Tue 05/09/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::DynamicReconfigureMEM(
    IPin * pConnector,
    const AM_MEDIA_TYPE *pmt
    )
{
    AMTRACE((TEXT("CVMRInputPin::DynamicReconfigureMEM")));

    CheckPointer(pmt, E_POINTER);
    CMediaType cmt(*pmt);

    CVMRPinAllocator* pAlloc = NULL;

    //
    // Can only do this if the allocator can be reconfigured
    //

    pAlloc = (CVMRPinAllocator *)m_pAllocator;
    if (!pAlloc) {
        DbgLog((LOG_ERROR, 1,
                TEXT("DynamicReconfigureMEM: Failed because of no allocator")));
        return E_FAIL;
    }


    //
    // If we are in pass thru mode just check that all the samples
    // have been returned to the allocator.  If we are in mixing mode
    // we have to wait until the mixer has finished with any samples
    // that it may have too.
    //

    if (m_dwPinID == 0 && m_pRenderer->m_VMRModePassThru) {

        if (!pAlloc->CanFree()) {
            DbgLog((LOG_ERROR, 1,
                    TEXT("DynamicReconfigureMEM: Failed because allocator can't free")));
            return VFW_E_WRONG_STATE;
        }
    }
    else {

        //
        // TODO:  If the upstream decoder has any samples outstanding then
        // we fail this call.  If the mixer has samples outstanding then
        // we need to wait until its done with them.
        //

    }

    CompletelyConnected(FALSE);

    HRESULT hr = CheckMediaType(&cmt);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1,
                TEXT("DynamicReconfigureMEM: CheckMediaType failed")));
        return hr;
    }

    ALLOCATOR_PROPERTIES Props;
    pAlloc->Decommit();
    pAlloc->GetProperties(&Props);

    if (m_dwPinID == 0 && m_pRenderer->m_VMRModePassThru) {
        m_pRenderer->m_lpRLNotify->FreeSurface(m_pRenderer->m_dwUserID);
        m_pDDS = NULL;
    }
    else {
        ReleaseAllocatedSurfaces();
        RELEASE(m_pDDS);
    }
    FrontBufferStale(FALSE);

    SetMediaType(&cmt);

    ALLOCATOR_PROPERTIES PropsActual;
    Props.cbBuffer = pmt->lSampleSize;
    m_fInDFC = TRUE;
    hr = pAlloc->SetProperties(&Props, &PropsActual);
    m_fInDFC = FALSE;

    if (SUCCEEDED(hr)) {
        hr = pAlloc->Commit();
    }

    m_bDynamicFormatNeeded = true;
    CompletelyConnected(TRUE);

    return hr;

}


/*****************************Private*Routine******************************\
* DynamicReconfigureDVA
*
* Performs a dynamic reconfiguration of the connection between the VMR and
* the filter upstream of this pin for the IAMVideoAccelerator connection
* protocol.
*
* History:
* Tue 05/09/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::DynamicReconfigureDVA(
    IPin * pConnector,
    const AM_MEDIA_TYPE *pmt
    )
{
    AMTRACE((TEXT("CVMRInputPin::DynamicReconfigureDVA")));

    CheckPointer(pmt, E_POINTER);
    CMediaType cmt(*pmt);

    //
    // If we are in mixing mode we have to wait until the mixer has finished
    // with any samples that it may have.
    //

    if (!m_pRenderer->m_VMRModePassThru) {

        //
        // TODO:  If the upstream decoder has any samples outstanding then
        // we fail this call.  If the mixer has samples outstanding then
        // we need to wait until its done with them.
        //

    }

    CompletelyConnected(FALSE);

    HRESULT hr = CheckMediaType(&cmt);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1,
                TEXT("DynamicReconfigureDVA: CheckMediaType failed")));
        return hr;
    }

    VABreakConnect();

    if (m_dwPinID == 0 && m_pRenderer->m_VMRModePassThru) {
        m_pRenderer->m_lpRLNotify->FreeSurface(m_pRenderer->m_dwUserID);
        m_pDDS = NULL;
    }
    else {
        ReleaseAllocatedSurfaces();
        RELEASE(m_pDDS);
    }

    FrontBufferStale(FALSE);
    SetMediaType(&cmt);



    hr = VACompleteConnect(pConnector, &cmt);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1,
                TEXT("DynamicReconfigureDVA: CheckMediaType failed")));
    }
    else {

        // store it in our mediatype as well - this gets done in the SetProperties call
        // in the non-DXVA case.
        m_mtNew = *pmt;
    }

    CompletelyConnected(TRUE);
    return hr;

}

/*****************************Private*Routine******************************\
* TryDynamicReconfiguration
*
*
*
* History:
* Wed 03/28/2001 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::TryDynamicReconfiguration(
    IPin * pConnector,
    const AM_MEDIA_TYPE *pmt
    )
{
    AMTRACE((TEXT("CVMRInputPin::TryDynamicReconfiguration")));

    HRESULT hr;
    if (m_RenderTransport == AM_IMEMINPUTPIN) {
        hr = DynamicReconfigureMEM(pConnector, pmt);
    }
    else {
        hr = DynamicReconfigureDVA(pConnector, pmt);
    }

    return hr;
}

/******************************Public*Routine******************************\
* CVMRInputPin::ReceiveConnection
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRInputPin::ReceiveConnection(
    IPin * pConnector,
    const AM_MEDIA_TYPE *pmt
    )
{
    AMTRACE((TEXT("CVMRInputPin::ReceiveConnection")));
    CAutoLock lck(m_pLock);
    HRESULT hr = S_OK;

    ASSERT(pConnector);
    DbgLog((LOG_TRACE, 1, TEXT("ReceiveConnection called on Pin %d"), m_dwPinID));

    int iNumPinsConnected = m_pRenderer->NumInputPinsConnected();
    if (iNumPinsConnected == 0) {

        //
        // determine what renderering mode we are operating in,
        // in either WINDOWED or WINDOWLESS modes we need to create an
        // AllocatorPresenter object if we have not already done so.
        //

        if (m_pRenderer->m_VMRMode & (VMRMode_Windowed | VMRMode_Windowless) ) {

            if (m_pRenderer->m_lpRLNotify == NULL) {
                hr = m_pRenderer->ValidateIVRWindowlessControlState();
            }
        }

        if (SUCCEEDED(hr)) {
            hr = CBaseInputPin::ReceiveConnection(pConnector, pmt);

            if (FAILED(hr)) {
                DbgLog((LOG_ERROR, 1,
                        TEXT("ReceiveConnection failed on Pin %d reason %#X"),
                        m_dwPinID, hr));
            }
        }

    }
    else {

        if (m_Connected == pConnector) {

            CMediaType mtTmp = m_mtNew;
            hr = TryDynamicReconfiguration(pConnector, pmt);
            if (hr != S_OK) {
                //
                // If we could not reconfigure try to recover the old
                // connection state.
                //
                m_pRenderer->NotifyEvent(EC_VMR_RECONNECTION_FAILED, hr, 0);
                TryDynamicReconfiguration(pConnector, &mtTmp);
            }
        }
        else {

            hr = CBaseInputPin::ReceiveConnection(pConnector, pmt);
            if (FAILED(hr)) {
                DbgLog((LOG_ERROR, 1,
                        TEXT("ReceiveConnection failed on Pin %d reason %#X"),
                        m_dwPinID, hr));
            }
        }
    }

    return hr;
}

/******************************Public*Routine******************************\
* Disconnect
*
* This function implements IPin::Disconnect().  See the DirectShow
* documentation for more information on IPin::Disconnect().
*
* History:
* Tue 03/05/2001 - BEllett - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRInputPin::Disconnect()
{
    AMTRACE((TEXT("CVMRInputPin::Disconnect")));
    CAutoLock cObjectLock(m_pInterfaceLock);
    return DisconnectInternal();
}

/******************************Public*Routine******************************\
* CVMRInputPin::BreakConnect(
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::BreakConnect()
{
    AMTRACE((TEXT("CVMRInputPin::BreakConnect")));
    DbgLog((LOG_TRACE, 1, TEXT("BreakConnect called on Pin %d"), m_dwPinID));

    CAutoLock cLock(m_pInterfaceLock);
    HRESULT hr = S_OK;

    IVMRMixerStream* lpMixStream = m_pRenderer->m_lpMixStream;
    if (!m_pRenderer->m_VMRModePassThru && lpMixStream) {

#ifdef DEBUG
        BOOL fActive;
        lpMixStream->GetStreamActiveState(m_dwPinID, &fActive);
        if (fActive) {
            DbgLog((LOG_ERROR, 1,
                    TEXT("Filter connected to pin %d still ACTIVE!"), m_dwPinID));
        }
#endif
        lpMixStream->SetStreamActiveState(m_dwPinID, FALSE);
        lpMixStream->SetStreamMediaType(m_dwPinID, NULL, FALSE, NULL, NULL);
    }

    if (m_RenderTransport == AM_VIDEOACCELERATOR) {

        //
        // break the motion comp connection
        //
        hr = VABreakConnect();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("VABreakConnect failed, hr = 0x%x"), hr));
        }

    }
    else {
        ASSERT(m_pIVANotify == NULL);
        ASSERT(m_pIDDVideoAccelerator == NULL);
        RELEASE(m_pIDDVAContainer);
    }

    //
    // Release the DDraw surface being used by this pin
    //
    if (m_dwPinID == 0 && m_pRenderer->m_VMRModePassThru) {

        m_pRenderer->m_lpRLNotify->FreeSurface(m_pRenderer->m_dwUserID);
        m_pDDS = NULL;
    }
    else {
        DbgLog((LOG_TRACE, 2,
                TEXT("DDraw surface now freed on Stream %d"), m_dwPinID));
        ReleaseAllocatedSurfaces();
        RELEASE(m_pDDS);
    }
    m_dwBackBufferCount = 0;
    FrontBufferStale(FALSE);

    //
    // Tell the filter about the break connect
    //
    m_pRenderer->BreakConnect(m_dwPinID);

    //
    // Next tell the base classes
    //
    if (SUCCEEDED(hr)) {
        hr = CBaseInputPin::BreakConnect();
    }

    m_RenderTransport = AM_IMEMINPUTPIN;
    CompletelyConnected(FALSE);
    m_SamplePeriod = 0;

    return hr;
}


/******************************Public*Routine******************************\
* CVMRInputPin::CompleteConnect
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::CompleteConnect(
    IPin* pReceivePin
    )
{
    AMTRACE((TEXT("CVMRInputPin::CompleteConnect")));
    DbgLog((LOG_TRACE, 1, TEXT("CompleteConnect called on Pin %d"), m_dwPinID));

    CAutoLock cLock(m_pInterfaceLock);
    HRESULT hr = S_OK;

    // tell the owning filter
    hr = m_pRenderer->CompleteConnect(m_dwPinID, m_mt);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1,
                TEXT("m_pFilter->CompleteConnect failed, hr = 0x%x"), hr));
    }

    // call the base class
    if (SUCCEEDED(hr)) {

        hr = CBaseInputPin::CompleteConnect(pReceivePin);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1,
                    TEXT("CBaseInputPin::CompleteConnect failed, hr = 0x%x"),
                    hr));
        }
    }

    if (SUCCEEDED(hr)) {

        if (m_RenderTransport == AM_VIDEOACCELERATOR) {

            //
            // make sure the motion comp complete connect succeeds
            //
            hr = VACompleteConnect(pReceivePin, &m_mt);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 1,
                        TEXT("VACompleteConnect failed, hr = 0x%x"), hr));
            }

            if (SUCCEEDED(hr)) {
                hr = m_pRenderer->OnSetProperties(this);
            }

        }
        else {

            m_bDynamicFormatNeeded = true;
        }
    }

    if (SUCCEEDED(hr)) {
        CompletelyConnected(TRUE);
    }

    return hr;
}


/******************************Public*Routine******************************\
* CVMRInputPin::SetMediaType
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::SetMediaType(
    const CMediaType *pmt
    )
{
    AMTRACE((TEXT("CVMRInputPin::SetMediaType")));
    HRESULT hr = S_OK;

    hr = CheckMediaType(pmt);

    if (SUCCEEDED(hr)) {
        hr = CBaseInputPin::SetMediaType(pmt);
    }

    if (SUCCEEDED(hr)) {

        m_SamplePeriod = GetAvgTimePerFrame(pmt);

        if (IsSuitableVideoAcceleratorGuid((LPGUID)&pmt->subtype)) {

            if (m_pIVANotify == NULL) {

                //
                // get the IHWVideoAcceleratorNotify interface from
                // the upstream pin
                //
                hr = m_Connected->QueryInterface(IID_IAMVideoAcceleratorNotify,
                                                 (void **)&m_pIVANotify);
            }

            if (SUCCEEDED(hr)) {

                ASSERT(m_pIVANotify);
                m_RenderTransport = AM_VIDEOACCELERATOR;
                DbgLog((LOG_TRACE, 2, TEXT("this is a DX VA connection")));
            }
        }
    }

    return hr;
}

/*****************************Private*Routine******************************\
* CheckInterlaceFlags
*
* this function checks if the InterlaceFlags are suitable or not
*
* History:
* Sat 2/10/2001 - StEstrop - Modified from OVMixer original
*
\**************************************************************************/
HRESULT
CVMRInputPin::CheckInterlaceFlags(
    DWORD dwInterlaceFlags
    )
{
    AMTRACE((TEXT("CVMRInputPin::CheckInterlaceFlags")));
    HRESULT hr = S_OK;

    CAutoLock cLock(m_pLock);

    __try {

        if (dwInterlaceFlags & AMINTERLACE_UNUSED)
        {
            hr = VFW_E_TYPE_NOT_ACCEPTED;
            __leave;
        }

        // check that the display mode is one of the three allowed values
        if (((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) != AMINTERLACE_DisplayModeBobOnly) &&
            ((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) != AMINTERLACE_DisplayModeWeaveOnly) &&
            ((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) != AMINTERLACE_DisplayModeBobOrWeave))
        {
            hr = VFW_E_TYPE_NOT_ACCEPTED;
            __leave;
        }

        // if content is not interlaced, other bits are irrelavant, so we are done
        if (!(dwInterlaceFlags & AMINTERLACE_IsInterlaced))
        {
            __leave;
        }

        // samples are frames, not fields (so we can handle any display mode)
        if (!(dwInterlaceFlags & AMINTERLACE_1FieldPerSample))
        {
            __leave;
        }

        // can handle a stream of just field1 or field2, whatever the display mode
        if (((dwInterlaceFlags & AMINTERLACE_FieldPatternMask) == AMINTERLACE_FieldPatField1Only) ||
            ((dwInterlaceFlags & AMINTERLACE_FieldPatternMask) == AMINTERLACE_FieldPatField2Only))
        {
            __leave;
        }

        // can handle only bob-mode for field samples
        if ((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) == AMINTERLACE_DisplayModeBobOnly)
        {
            __leave;
        }

        // cannot handle only Weave mode or BobOrWeave mode for field samples
        if (((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) == AMINTERLACE_DisplayModeWeaveOnly) ||
             ((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) == AMINTERLACE_DisplayModeBobOrWeave))
        {
            hr = VFW_E_TYPE_NOT_ACCEPTED;
            __leave;
        }

    }
    __finally {

        // we cannot handle bob mode with an offscreen surface or if the driver can't support it
        if (SUCCEEDED(hr))
        {
            if (!m_pRenderer->m_pDeinterlace || m_pRenderer->m_VMRModePassThru) {

                LPDDCAPS_DX7 pDirectCaps = &m_pRenderer->m_ddHWCaps;
                if (pDirectCaps)
                {
                    // call NeedToFlipOddEven with dwTypeSpecificFlags=0, to pretend that the
                    // type-specific-flags is asking us to do bob-mode.

                    if (!(pDirectCaps->dwCaps2 & DDCAPS2_CANFLIPODDEVEN) &&
                         (NeedToFlipOddEven(dwInterlaceFlags, 0, NULL, TRUE)))
                    {
                        hr = VFW_E_TYPE_NOT_ACCEPTED;
                    }
                }
            }
        }
    }

    return hr;
}

/*****************************Private*Routine******************************\
* DynamicCheckMediaType
*
* this function check if the mediatype on a dynamic format change is suitable.
* No lock is taken here. It is the callee's responsibility to maintain integrity!
*
* History:
* Sat 2/10/2001 - StEstrop - Modified from the OVMixer original
*
\**************************************************************************/
HRESULT
CVMRInputPin::DynamicCheckMediaType(
    const CMediaType* pmt
    )
{
    AMTRACE((TEXT("CVMRInputPin::DynamicCheckMediaType")));

    HRESULT hr = VFW_E_TYPE_NOT_ACCEPTED;
    BITMAPINFOHEADER *pNewHeader = NULL, *pOldHeader = NULL;
    DWORD dwOldInterlaceFlags = 0, dwNewInterlaceFlags = 0, dwCompareSize = 0;
    BOOL bOld1FieldPerSample = FALSE, bNew1FieldPerSample = FALSE;
    BOOL b1, b2;

    __try {

        // majortype and SubType are not allowed to change dynamically,
        // format type can change.
        if ((!(IsEqualGUID(pmt->majortype, m_mtNew.majortype))) ||
            (!(IsEqualGUID(pmt->subtype, m_mtNew.subtype))))
        {
            __leave;
        }

        // get the interlace flags of the new mediatype
        hr = GetInterlaceFlagsFromMediaType(pmt, &dwNewInterlaceFlags);
        if (FAILED(hr))
        {
            __leave;
        }

        // get the interlace flags of the new mediatype
        hr = GetInterlaceFlagsFromMediaType(&m_mtNew, &dwOldInterlaceFlags);
        if (FAILED(hr))
        {
            __leave;
        }

        //
        // There are several bugs in the following code !!
        // We goto CleanUp but hr has not been updated with a valid error code!!
        //

        bOld1FieldPerSample = (dwOldInterlaceFlags & AMINTERLACE_IsInterlaced) &&
            (dwOldInterlaceFlags & AMINTERLACE_1FieldPerSample);
        bNew1FieldPerSample = (dwNewInterlaceFlags & AMINTERLACE_IsInterlaced) &&
            (dwNewInterlaceFlags & AMINTERLACE_1FieldPerSample);


        // we do not allow dynamic format changes where you go from 1FieldsPerSample to
        // 2FieldsPerSample or vica-versa since that means reallocating the surfaces.
        if (bNew1FieldPerSample != bOld1FieldPerSample)
        {
            __leave;
        }

        pNewHeader = GetbmiHeader(pmt);
        if (!pNewHeader)
        {
            __leave;
        }

        pOldHeader = GetbmiHeader(&m_mtNew);
        if (!pNewHeader)
        {
            __leave;
        }

        dwCompareSize = FIELD_OFFSET(BITMAPINFOHEADER, biClrUsed);
        ASSERT(dwCompareSize < sizeof(BITMAPINFOHEADER));

        if (memcmp(pNewHeader, pOldHeader, dwCompareSize) != 0)
        {
            __leave;
        }

        hr = S_OK;
    }
    __finally {}

    return hr;
}

/*****************************Private*Routine******************************\
* Special4ccCode
*
* IA44 and AI44 are 8 bits per pixel surfaces that contain 4 bits of alpha
* and 4 bits of palette index information.  They are normally used with
* DX-VA, but this surface type is useful for Line21 and teletext decoders,
* I will allow decoders to connect using this format even though it is hidden
* my DDraw device driver.  Normally we do not allow hidden 4CC surfaces to
* be created because they are almost always some form of private MoComp.
* Unllike the OVMixer the VMR does not support private MoComp interfaces.
*
* History:
* Tue 05/08/2001 - StEstrop - Created
*
\**************************************************************************/
BOOL
Special4ccCode(
    DWORD dw4cc
    )
{
    return dw4cc == '44AI' || dw4cc == '44IA';
}

/******************************Public*Routine******************************\
* CVMRInputPin::CheckMediaType
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::CheckMediaType(
    const CMediaType* pmt
    )
{
    AMTRACE((TEXT("CVMRInputPin::CheckMediaType")));

    // We assume failure - hrRet gets updated at the very end of the
    // __try block
    HRESULT hrRet = VFW_E_TYPE_NOT_ACCEPTED;

    __try {

        HRESULT hr = m_pRenderer->CheckMediaType(pmt);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 1, TEXT("CheckMediaType failed on Pin %d rc=%#X"),
                    m_dwPinID, hr));
            __leave;
        }

        if (IsCompletelyConnected()) {

            hr = DynamicCheckMediaType(pmt);
            if (FAILED(hr)) {
                DbgLog((LOG_ERROR, 1,
                        TEXT("CheckMediaType failed on Pin %d: ")
                        TEXT("DynamicCheckMediaType failed"),
                        m_dwPinID));
                __leave;
            }
        }
        else {

            if (m_pRenderer->m_VMRModePassThru && MEDIASUBTYPE_HASALPHA(*pmt)) {
                DbgLog((LOG_ERROR, 1,
                        TEXT("CheckMediaType failed on Pin %d: Alpha formats ")
                        TEXT("not allowed in pass thru mode"),
                        m_dwPinID));
                __leave;
            }

            if (!IsSuitableVideoAcceleratorGuid(&pmt->subtype)) {

                BITMAPINFOHEADER *pHeader = GetbmiHeader(pmt);
                if (!pHeader) {
                    DbgLog((LOG_ERROR, 1,
                            TEXT("CheckMediaType failed on Pin %d: ")
                            TEXT("could not get valid format field"),
                            m_dwPinID));
                    __leave;
                }


                // Don't accept 4CC not supported by the driver
                if (pHeader->biCompression > BI_BITFIELDS &&
                    !Special4ccCode(pHeader->biCompression)) {

                    LPDIRECTDRAW7 pDDraw = m_pRenderer->m_lpDirectDraw;
                    if (!pDDraw) {
                        DbgLog((LOG_ERROR, 1,
                                TEXT("CheckMediaType failed on Pin %d: ")
                                TEXT("could not get DDraw obj from filter"),
                                m_dwPinID));
                        __leave;
                    }

                    //
                    // We only allow the VMR to create 4CC surfaces that
                    // the driver publically advertises.  The VMR does not
                    // support any forms of mocomp other than DX-VA and HVA.
                    //

                    DWORD dwCodes;
                    BOOL bFound = FALSE;

                    hr = pDDraw->GetFourCCCodes(&dwCodes, NULL);
                    if (FAILED(hr)) {
                        DbgLog((LOG_ERROR, 1,
                                TEXT("CheckMediaType failed on Pin %d: ")
                                TEXT("GetFourCCCodes failed"),
                                m_dwPinID));
                        __leave;
                    }

                    LPDWORD pdwCodes = (LPDWORD)_alloca(dwCodes * sizeof(DWORD));
                    hr = pDDraw->GetFourCCCodes(&dwCodes, pdwCodes);
                    if (FAILED(hr)) {
                        DbgLog((LOG_ERROR, 1,
                                TEXT("CheckMediaType failed on Pin %d: ")
                                TEXT("GetFourCCCodes failed"),
                                m_dwPinID));
                        __leave;
                    }

                    while (dwCodes--) {
                        if (pdwCodes[dwCodes] == pHeader->biCompression) {
                            bFound = TRUE;
                            break;
                        }
                    }

                    if (!bFound) {
                        DbgLog((LOG_ERROR, 1,
                                TEXT("CheckMediaType failed on Pin %d: ")
                                TEXT("4CC(%4.4s) not supported by driver"),
                                m_dwPinID, &pHeader->biCompression));
                        __leave;
                    }
                }
                else {

                    if (m_pRenderer->m_VMRModePassThru) {
                        DDPIXELFORMAT* ddpfM = &m_pRenderer->m_ddpfMonitor;

                        if (pHeader->biBitCount != ddpfM->dwRGBBitCount) {

                            DbgLog((LOG_ERROR, 1,
                                    TEXT("CheckMediaType failed on Pin %d: ")
                                    TEXT("Bit depths don't match"), m_dwPinID));
                            __leave;

                        }

                        if (pHeader->biCompression == BI_BITFIELDS) {

                            const DWORD *pBitMasks = GetBitMasks(pHeader);

                            if (ddpfM->dwRBitMask != pBitMasks[0] ||
                                ddpfM->dwGBitMask != pBitMasks[1] ||
                                ddpfM->dwBBitMask != pBitMasks[2])
                            {
                                 DbgLog((LOG_ERROR, 1,
                                         TEXT("CheckMediaType failed on Pin %d: ")
                                         TEXT("Bitfields don't match"), m_dwPinID));
                                 __leave;
                            }
                        }
                    }
                }
            }
        }

        // make sure the rcSource field is valid
        const RECT* lprc = GetSourceRectFromMediaType(pmt);
        if (!lprc) {
            DbgLog((LOG_ERROR, 1,
                    TEXT("CheckMediaType failed on Pin %d: ")
                    TEXT("Could not get a valid SRC from the media type"),
                    m_dwPinID));
            __leave;
        }

        // make sure the rcTarget field is valid
        lprc = GetTargetRectFromMediaType(pmt);
        if (!lprc) {
            DbgLog((LOG_ERROR, 1,
                    TEXT("CheckMediaType failed on Pin %d: ")
                    TEXT("Could not get a valid DST from the media type"),
                    m_dwPinID));
            __leave;
        }

        if (*pmt->FormatType() == FORMAT_VideoInfo2) {

            VIDEOINFOHEADER2* pVIH2 = (VIDEOINFOHEADER2*)(pmt->pbFormat);
            DWORD dwInterlaceFlags = pVIH2->dwInterlaceFlags;

            hr = CheckInterlaceFlags(dwInterlaceFlags);
            if (FAILED(hr)) {
                DbgLog((LOG_ERROR, 2,
                    TEXT("CheckMediaType failed on Pin %d: ")
                    TEXT("CheckInterlaceFlags failed reason %#X"),
                    m_dwPinID, hr));
                __leave;
            }
        }

        // If we are still here the media type is OK so updatw hrRet to
        // indicate success
        hrRet = S_OK;
    }
    __finally {}

    return hrRet;
}


/******************************Public*Routine******************************\
* CVMRInputPin::GetAllocator
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRInputPin::GetAllocator(
    IMemAllocator **ppAllocator
    )
{
    AMTRACE((TEXT("CVMRInputPin::GetAllocator")));
    CAutoLock cInterfaceLock(m_pInterfaceLock);

    HRESULT hr = S_OK;

    if (m_RenderTransport == AM_VIDEOACCELERATOR) {

        *ppAllocator = NULL;
        hr = VFW_E_NO_ALLOCATOR;
    }
    else {

        ASSERT(m_RenderTransport == AM_IMEMINPUTPIN);

        //
        // Has an allocator been set yet in the base class
        //

        if (m_pAllocator == NULL) {
            m_pAllocator = &m_PinAllocator;
            m_pAllocator->AddRef();
        }

        m_pAllocator->AddRef();
        *ppAllocator = m_pAllocator;
    }

    return hr;
}


/******************************Public*Routine******************************\
* CVMRInputPin::NotifyAllocator
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRInputPin::NotifyAllocator(
    IMemAllocator *pAllocator,
    BOOL bReadOnly
    )
{
    AMTRACE((TEXT("CVMRInputPin::NotifyAllocator")));

    CAutoLock cInterfaceLock(m_pInterfaceLock);

    HRESULT hr = E_FAIL;

    if (m_RenderTransport == AM_VIDEOACCELERATOR) {
        hr = S_OK;
    }
    else {

        ASSERT(m_RenderTransport == AM_IMEMINPUTPIN);

        //
        // we can only work with our own allocator
        //

        if (pAllocator != &m_PinAllocator) {
            DbgLog((LOG_ERROR, 1, TEXT("Can only use our own allocator")));
            hr = E_FAIL;
        }
        else {
            hr = S_OK;
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
* CVMRInputPin::Active
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::Active()
{
    AMTRACE((TEXT("CVMRInputPin::Active")));
    DbgLog((LOG_TRACE, 1, TEXT("Active called on Pin %d"), m_dwPinID));

    HRESULT hr = S_OK;

    CAutoLock lck(m_pLock);
    m_hEndOfStream = NULL;
    FrontBufferStale(TRUE);
    m_SampleCount = 0;

    if (m_Connected) {

        IVMRMixerStream* lpMixStream = m_pRenderer->m_lpMixStream;
        if (lpMixStream) {
            hr = lpMixStream->SetStreamActiveState(m_dwPinID, true);
        }

        if (SUCCEEDED(hr)) {
            m_bActive = TRUE;
            hr = m_pRenderer->Active(m_dwPinID);
        }
    }

    hr = CBaseInputPin::Active();

    //
    // if it is a DX VA connection, this error is ok
    //

    if (m_RenderTransport == AM_VIDEOACCELERATOR && hr == VFW_E_NO_ALLOCATOR) {
        hr = S_OK;
    }


    return hr;
}


/******************************Public*Routine******************************\
* CVMRInputPin::Inactive(
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::Inactive()
{
    AMTRACE((TEXT("CVMRInputPin::Inactive")));
    DbgLog((LOG_TRACE, 1, TEXT("Inactive called on Pin %d"), m_dwPinID));

    // m_pLock and CVMRFilter::m_InterfaceLock are the same lock.
    CAutoLock lck(m_pLock);

    HRESULT hr = S_OK;
    if (m_Connected) {

        IVMRMixerStream* lpMixStream = m_pRenderer->m_lpMixStream;
        if (lpMixStream) {

            hr = lpMixStream->SetStreamActiveState(m_dwPinID, false);
        }

        if (SUCCEEDED(hr)) {
            hr = m_pRenderer->Inactive(m_dwPinID);
            m_bActive = FALSE;
        }
    }

    hr = CBaseInputPin::Inactive();

    //
    // if it is a DX VA connection, this error is ok
    //

    if (m_RenderTransport == AM_VIDEOACCELERATOR && hr == VFW_E_NO_ALLOCATOR) {
        hr = S_OK;
    }


    return hr;
}


/******************************Public*Routine******************************\
* CVMRInputPin::BeginFlush
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRInputPin::BeginFlush()
{
    AMTRACE((TEXT("CVMRInputPin::BeginFlush")));

    HRESULT hr = S_OK;
    CAutoLock cRendererLock(&m_pRenderer->m_InterfaceLock);
    m_hEndOfStream = NULL;
    {
        CAutoLock cSampleLock(&m_pRenderer->m_RendererLock);
        CBaseInputPin::BeginFlush();

        IVMRMixerStream* lpMixStream = m_pRenderer->m_lpMixStream;
        if (lpMixStream) {
            hr = lpMixStream->BeginFlush(m_dwPinID);
        }

        if (SUCCEEDED(hr)) {
            hr = m_pRenderer->BeginFlush(m_dwPinID);
        }

    }

    return hr;
}


/******************************Public*Routine******************************\
* CVMRInputPin::EndFlush
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRInputPin::EndFlush()
{
    AMTRACE((TEXT("CVMRInputPin::EndFlush")));

    CAutoLock cRendererLock(&m_pRenderer->m_InterfaceLock);
    CAutoLock cSampleLock(&m_pRenderer->m_RendererLock);

    HRESULT hr = S_OK;
    FrontBufferStale(TRUE);

    IVMRMixerStream* lpMixStream = m_pRenderer->m_lpMixStream;
    if (lpMixStream) {
        hr = lpMixStream->EndFlush(m_dwPinID);
    }

    if (SUCCEEDED(hr)) {
        hr = m_pRenderer->EndFlush(m_dwPinID);
    }

    if (SUCCEEDED(hr)) {
        hr = CBaseInputPin::EndFlush();
    }

    return hr;
}


/*****************************Private*Routine******************************\
* DoQualityMessage
*
* Send a quality message if required - this is the hack version
* that just passes the lateness
*
* History:
* Thu 08/24/2000 - StEstrop - Created
*
\**************************************************************************/
void
CVMRInputPin::DoQualityMessage()
{
    CAutoLock cLock(m_pInterfaceLock);

    if (m_pRenderer->m_State == State_Running &&
        SampleProps()->dwSampleFlags & AM_SAMPLE_TIMEVALID)
    {
        CRefTime CurTime;
        if (S_OK == m_pRenderer->StreamTime(CurTime))
        {
            const REFERENCE_TIME tStart = SampleProps()->tStart;
            Quality msg;
            msg.Proportion = 1000;
            msg.Type = CurTime > tStart ? Flood : Famine;
            msg.Late = CurTime - tStart;
            msg.TimeStamp = tStart;
            PassNotify(msg);
        }
    }
}

// #define DISPLAYVIDEOINFOHEADER

#if defined(DISPLAYVIDEOINFOHEADER) && defined(DEBUG)
// VIhdr2 debugging
static void DisplayVideoInfoHeader( const VIDEOINFOHEADER2& hdr, const TCHAR* pString )
{
    TCHAR temp[1000];
    TCHAR flags[1000];
    flags[0]= TEXT('\0');

    if( hdr.dwReserved1 & AMCONTROL_PAD_TO_16x9 ) {
        lstrcat( flags, TEXT("PAD_TO_16x9 " ) );
    }
    if( hdr.dwReserved1 & AMCONTROL_PAD_TO_4x3 ) {
        lstrcat( flags, TEXT("PAD_TO_4x3 ") );
    }

    wsprintf( temp, TEXT("rcSrc(%d,%d)-(%d,%d)\n rcDst:(%d,%d)-(%d,%d)\n bmiSize: %dx%d\n Aspect: %dx%d\n dwReserved=%d (%s)"),
        hdr.rcSource.left, hdr.rcSource.top, hdr.rcSource.right, hdr.rcSource.bottom,
        hdr.rcTarget.left, hdr.rcTarget.top, hdr.rcTarget.right, hdr.rcTarget.bottom,
        hdr.bmiHeader.biWidth, hdr.bmiHeader.biHeight,
        hdr.dwPictAspectRatioX, hdr.dwPictAspectRatioY, hdr.dwReserved1, flags );
    DbgAssert( temp, pString, 0 );
}
static void DisplayMediaTypeChange( IMediaSample* pSample, DWORD dwPin )
{
    AM_MEDIA_TYPE* pmt;
    if (S_OK == pSample->GetMediaType(&pmt)) {
        TCHAR Str[32];
        wsprintf(Str, TEXT("VMR pin %d"), dwPin);
        VIDEOINFOHEADER2* pInfo = (VIDEOINFOHEADER2*) (CMediaType *)(pmt)->pbFormat;
        DisplayVideoInfoHeader(*pInfo, Str);
        DeleteMediaType(pmt);
    }

}
#endif

/******************************Public*Routine******************************\
* CVMRInputPin::Receive
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRInputPin::Receive(
    IMediaSample *pSample
    )
{
    AMTRACE((TEXT("CVMRInputPin::Receive")));
    DbgLog((LOG_TRACE, 2, TEXT("pSample= %#X"), pSample));

    HRESULT hr = S_OK;

#if defined( EHOME_WMI_INSTRUMENTATION )
    PERFLOG_STREAMTRACE(
        1,
        PERFINFO_STREAMTRACE_VMR_RECEIVE,
        ULONG_PTR( pSample ), 0, 0, 0, 0 );
#endif

    __try {

        {
            //
            // This function must hold the interface lock because
            // CBaseInputPin::Receive() calls CVMRInputPin::CheckMediaType()
            // and because CBaseInputPin::Receive()  uses m_bRunTimeError.
            //
            // Note that we do not use the CHECK_HR macro here as __leave
            // does not allow the destructor of the CAutoLock object
            // to execute.
            //
            CAutoLock cRendererLock(m_pInterfaceLock);
            hr = CBaseInputPin::Receive(pSample);
        }
        if (hr != S_OK) {
            __leave;
        }

#if defined(DISPLAYVIDEOINFOHEADER) && defined(DEBUG)
        // debugging code for tracking media changes from decoders
        DisplayMediaTypeChange( pSample, m_dwPinID );
#endif

        DoQualityMessage();

        if (m_dwPinID == 0) {

            // Store the media times from this sample
            if (m_pRenderer->m_pPosition) {
                m_pRenderer->m_pPosition->RegisterMediaTime(pSample);
            }
        }

        CVMRMediaSample* pVMRSample = (CVMRMediaSample*)pSample;
        if (S_OK == pVMRSample->IsSurfaceLocked()) {

            hr = pVMRSample->UnlockSurface();
            if (hr != S_OK) {
                DbgLog((LOG_ERROR, 1, TEXT("Receive hr = %#X"), hr));
            }
        }

        FrontBufferStale(FALSE);

        if (SampleProps()->dwSampleFlags & AM_SAMPLE_TYPECHANGED) {

            DbgLog((LOG_TRACE, 1,
                    TEXT("Receive %d: Media sample has AM_SAMPLE_TYPECHANGED flag"),
                    m_dwPinID));
            SetMediaType((CMediaType *)SampleProps()->pMediaType);

        }


        REFERENCE_TIME rtStart, rtEnd;
        hr = pVMRSample->GetTime(&rtStart, &rtEnd);
        BOOL fTimeValid = (hr == S_OK);
        BOOL fLiveStream = FALSE;

#ifdef DEBUG
        if( fTimeValid )
        {
            DbgLog((LOG_TIMING, 3,
                    TEXT("Received video sample timestamped %dms"),
                    (LONG)(rtStart/10000)));
        }
#endif
        switch (hr) {
        case VFW_E_SAMPLE_TIME_NOT_SET:
            fLiveStream = TRUE;
            hr = S_OK;
            break;

        case VFW_S_NO_STOP_TIME:
            fTimeValid = TRUE;
            //
            // if the stop time is not set the base classes set the stop
            // time to be the start time + 1.  This is not useful for
            // de-interlacing as we can't then determine the start
            // time of the second field.
            //
            if (!m_pRenderer->m_VMRModePassThru && m_InterlacedStream) {
                rtEnd = rtStart + m_SamplePeriod;
            }
            hr = S_OK;
            break;
        }

        //
        // Don't process the sample if we are in the middle of a display
        // change, don't queue the sample.
        //

        const DWORD dwPinBit = (1 << m_dwPinID);
        if (SUCCEEDED(hr) && !(m_pRenderer->m_dwDisplayChangeMask & dwPinBit)) {

            DWORD dwInterlaceFlags;
            GetInterlaceFlagsFromMediaType(&m_mt, &dwInterlaceFlags);
            DWORD dwTypeSpecificFlags = m_SampleProps.dwTypeSpecificFlags;


            IVMRMixerStream* lpMixStream = m_pRenderer->m_lpMixStream;
            if (lpMixStream) {

                if (m_InterlacedStream) {

                    CAutoLock l(&m_DeinterlaceLock);

                    if (m_dwNumHistorySamples > 1) {
                        MoveMemory(&m_pVidHistorySamps[0],
                                   &m_pVidHistorySamps[1],
                                    (m_dwNumHistorySamples - 1) *
                                    sizeof(DXVA_VideoSample));
                    }


                    LPDIRECTDRAWSURFACE7 pDDS;
                    pVMRSample->GetSurface(&pDDS);
                    pDDS->Release();

                    DXVA_VideoSample* lpSrcSurf = &m_pVidHistorySamps[m_dwNumHistorySamples - 1];
                    lpSrcSurf->lpDDSSrcSurface = pDDS;
                    lpSrcSurf->rtStart = rtStart;
                    lpSrcSurf->rtEnd   = rtEnd;
                    lpSrcSurf->SampleFormat = MapInterlaceFlags(dwInterlaceFlags,
                                                                dwTypeSpecificFlags);
                    //
                    // We can't generate an output frame yet if we don't have enough
                    // input frames.
                    //
                    if (m_SampleCount++ < m_DeinterlaceCaps.NumForwardRefSamples) {

                        if (pVMRSample->IsDXVASample()) {
                            pVMRSample->SignalReleaseSurfaceEvent();
                        }

                        hr = S_OK;
                        __leave;
                    }

                    DXVA_VideoSample* lpDstSurf = pVMRSample->GetInputSamples();
                    CopyMemory(lpDstSurf, m_pVidHistorySamps,
                               m_dwNumHistorySamples * sizeof(DXVA_VideoSample));

                    //
                    // Fix up the sample times
                    //
                    if (!fLiveStream) {
                        const DWORD& NBRefSamples = m_DeinterlaceCaps.NumBackwardRefSamples;
                        pVMRSample->SetTime(&lpDstSurf[NBRefSamples].rtStart,
                                            &lpDstSurf[NBRefSamples].rtEnd);
                    }
                    pVMRSample->SetNumInputSamples(m_dwNumHistorySamples);
                }

                hr = lpMixStream->QueueStreamMediaSample(m_dwPinID, pSample);
                if (FAILED(hr)) {
                    if (pVMRSample->IsDXVASample()) {
                        pVMRSample->SignalReleaseSurfaceEvent();
                    }
                }

            }
            else {

                ASSERT(m_pRenderer->m_VMRModePassThru);
                if (m_pRenderer->m_VMRModePassThru) {

                    VMRPRESENTATIONINFO m;

                    ZeroMemory(&m, sizeof(m));
                    pVMRSample->GetSurface(&m.lpSurf);

                    if (fTimeValid) {
                        m.rtStart = rtStart;
                        m.rtEnd = rtEnd;
                        m.dwFlags |= VMRSample_TimeValid;
                    }

                    m.dwInterlaceFlags = dwInterlaceFlags;
                    m.dwTypeSpecificFlags = dwTypeSpecificFlags;

                    GetImageAspectRatio(&m_mt,
                                        &m.szAspectRatio.cx,
                                        &m.szAspectRatio.cy);

                    hr = m_pRenderer->m_lpIS->Receive(&m);
                    m.lpSurf->Release();
                }
            }
        }
        else {
            if (pVMRSample->IsDXVASample()) {
                pVMRSample->SignalReleaseSurfaceEvent();
            }
        }
    }
    __finally {

        if (FAILED(hr)) {

            // A deadlock could occur if the caller holds the renderer lock and
            // attempts to acquire the interface lock.
            ASSERT(CritCheckOut(&m_pRenderer->m_RendererLock));

            // The interface lock must be held when the filter is calling
            // IsStopped() or IsFlushing().  The filter must also hold the
            // interface lock because it is using m_bRunTimeError.
            CAutoLock cInterfaceLock(&m_pRenderer->m_InterfaceLock);

            if (!m_bRunTimeError && !IsFlushing() && !IsStopped()) {
                m_pRenderer->RuntimeAbortPlayback(hr);
                m_bRunTimeError = TRUE;
            }
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
* CVMRInputPin::EndOfStream
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRInputPin::EndOfStream()
{
    AMTRACE((TEXT("CVMRInputPin::EndOfStream")));

    CAutoLock cInterfaceLock(&m_pRenderer->m_InterfaceLock);
    CAutoLock cRendererLock(&m_pRenderer->m_RendererLock);

    if (m_hEndOfStream) {
        SetEvent(m_hEndOfStream);
        return S_OK;
    }

    // Make sure we're streaming ok

    HRESULT hr = CheckStreaming();
    if (hr != NOERROR) {
        return hr;
    }

    //
    // Remove this stream active bit in the active streams mask.
    // If there are no more active streams send EOS to the
    // image sync object.
    //
    // Otherwise we are in mixing mode (!m_VMRModePassThru)
    // so just set this mixing stream to NOT Active and
    // carry.
    //

    const DWORD dwPinBit = (1 << m_dwPinID);
    m_pRenderer->m_dwEndOfStreamMask &= ~dwPinBit;

    if (m_pRenderer->m_dwEndOfStreamMask == 0) {

        hr = m_pRenderer->EndOfStream(m_dwPinID);
    }
    else if (!m_pRenderer->m_VMRModePassThru) {

        IVMRMixerStream* lpMixStream = m_pRenderer->m_lpMixStream;
        if (lpMixStream) {
            hr = lpMixStream->SetStreamActiveState(m_dwPinID, false);
        }
    }

    if (SUCCEEDED(hr)) {
        hr = CBaseInputPin::EndOfStream();
    }

    return hr;
}


/******************************Public*Routine******************************\
* CVMRInputPin::SetColorKey
*
*
*
* History:
* Mon 10/30/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::SetColorKey(
      LPDDCOLORKEY Clr
      )
{
    AMTRACE((TEXT("CVMRInputPin::SetColorKey")));

    CAutoLock lck(m_pLock);
    HRESULT hr = VFW_E_NOT_CONNECTED;

    if (ISBADREADPTR(Clr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("SetColorKey: Invalid pointer")));
        return E_POINTER;
    }

    if (m_Connected) {
        IVMRMixerStream* lpMixStream = m_pRenderer->m_lpMixStream;
        if (lpMixStream) {
            hr = lpMixStream->SetStreamColorKey(m_dwPinID, Clr);
        }
        else hr = VFW_E_VMR_NOT_IN_MIXER_MODE;
    }
    return hr;
}

/******************************Public*Routine******************************\
* CVMRInputPin::GetColorKey
*
*
*
* History:
* Mon 10/30/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::GetColorKey(
      DDCOLORKEY* pClr
      )
{
    AMTRACE((TEXT("CVMRInputPin::GetColorKey")));

    CAutoLock lck(m_pLock);
    HRESULT hr = VFW_E_NOT_CONNECTED;
    if (ISBADWRITEPTR(pClr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("GetColorKey: Invalid pointer")));
        return E_POINTER;
    }

    if (m_Connected) {
        IVMRMixerStream* lpMixStream = m_pRenderer->m_lpMixStream;
        if (lpMixStream) {
            hr = lpMixStream->GetStreamColorKey(m_dwPinID, pClr);
        }
        else hr = VFW_E_VMR_NOT_IN_MIXER_MODE;
    }
    return hr;
}

/******************************Public*Routine******************************\
* SetStreamActiveState
*
*
*
* History:
* Tue 08/22/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::SetStreamActiveState(
    BOOL fActive
    )
{
    AMTRACE((TEXT("CVMRInputPin::SetStreamActiveState")));

    CAutoLock lck(m_pLock);
    HRESULT hr = VFW_E_NOT_CONNECTED;

    if (m_Connected) {
        IVMRMixerStream* lpMixStream = m_pRenderer->m_lpMixStream;
        if (lpMixStream) {
            if (m_bActive) {
                hr = lpMixStream->SetStreamActiveState(m_dwPinID, fActive);
            }
            else {
                DbgLog((LOG_ERROR, 1,
                        TEXT("Can't change active state of a stream %d - ")
                        TEXT("FILTER not active"), m_dwPinID ));
            }
        }
        else hr = VFW_E_VMR_NOT_IN_MIXER_MODE;
    }
    return hr;
}

/******************************Public*Routine******************************\
* GetStreamActiveState
*
*
*
* History:
* Tue 08/22/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::GetStreamActiveState(
    BOOL* lpfActive
    )
{
    AMTRACE((TEXT("CVMRInputPin::GetStreamActiveState")));

    CAutoLock lck(m_pLock);
    HRESULT hr = VFW_E_NOT_CONNECTED;

    if (ISBADWRITEPTR(lpfActive))
    {
        DbgLog((LOG_ERROR, 1, TEXT("GetStreamActiveState: Invalid pointer")));
        return E_POINTER;
    }

    if (m_Connected) {
        IVMRMixerStream* lpMixStream = m_pRenderer->m_lpMixStream;
        if (lpMixStream) {
            hr = lpMixStream->GetStreamActiveState(m_dwPinID, lpfActive);
        }
        else hr = VFW_E_VMR_NOT_IN_MIXER_MODE;
    }
    return hr;
}

/*****************************Private*Routine******************************\
* GetStreamInterlaceProperties
*
* Be careful when using this function.
*
* S_OK is used to indicate that lpIsInterlaced correctly reflects the
* interlace format of the stream, the stream can be de-interlaced and
* lpDeintGuid and pCaps contain valid data.
*
* S_FALSE is used to indicate that lpIsInterlaced correctly reflecst the
* interlace format of the stream, but the stream can't be de-interlaced.
*
* All other return values indicate error conditions and the streams
* format cannot be correctly determined.
*
* History:
* Mon 04/01/2002 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::GetStreamInterlaceProperties(
    const AM_MEDIA_TYPE *pMT,
    BOOL* lpIsInterlaced,
    GUID* lpDeintGuid,
    DXVA_DeinterlaceCaps* pCaps
    )
{
    HRESULT hr = S_OK;
    DXVA_DeinterlaceCaps DeinterlaceCaps;
    GUID GuidChosen = GUID_NULL;

    __try {

        DXVA_VideoDesc VideoDesc;
        CHECK_HR(hr = GetVideoDescFromMT(&VideoDesc, pMT));
        *lpIsInterlaced =
            (VideoDesc.SampleFormat != DXVA_SampleProgressiveFrame);

        if (*lpIsInterlaced) {


            //
            // If there is not a de-interlace container available, we have to
            // use Weave mode
            //
            CVMRDeinterlaceContainer* pDeInt = m_pRenderer->m_pDeinterlace;
            if (pDeInt == NULL) {
                hr = S_FALSE;
                __leave;
            }


            //
            // has the user supplied us with a mode to use?
            //
            if (m_DeinterlaceUserGUIDSet) {

                //
                // does the user actually want us to de-interlace at all?
                //
                if (m_DeinterlaceUserGUID == GUID_NULL) {
                    hr = S_FALSE;
                    __leave;
                }

                DeinterlaceCaps.Size = sizeof(DeinterlaceCaps);
                hr = pDeInt->QueryModeCaps(&m_DeinterlaceUserGUID, &VideoDesc,
                                           &DeinterlaceCaps);
                if (hr == S_OK) {
                    GuidChosen = m_DeinterlaceUserGUID;
                    __leave;
                }
            }


            //
            // Still here?  Then either the user has not given us a
            // de-interlace guid to use or the h/w doesn't like his
            // selection - either way we have to find out what the h/w
            // does like.
            //
            const DWORD MaxGuids = 16;
            GUID Guids[MaxGuids];
            DWORD dwNumModes = MaxGuids;
            DWORD i = 0;
            CHECK_HR(hr = pDeInt->QueryAvailableModes(&VideoDesc, &dwNumModes,
                                                      Guids));

            //
            // if the user hasn't supplied a de-interlace mode try the
            // best one provided by the driver.
            //
            if (!m_DeinterlaceUserGUIDSet) {

                DeinterlaceCaps.Size = sizeof(DeinterlaceCaps);
                hr = pDeInt->QueryModeCaps(&Guids[0], &VideoDesc,
                                           &DeinterlaceCaps);
                if (hr == S_OK) {
                    GuidChosen = Guids[0];
                    __leave;
                }
                //
                // we increment i here so that we don't retry this
                // mode in the fallback code below.
                //
                i = 1;
            }

            //
            // Still here? Then its time to kick in to the fallback
            // policy that was specified by the user.
            //

            if (DeinterlacePref_Weave & m_pRenderer->m_dwDeinterlacePrefs) {
                hr = S_FALSE;
                __leave;
            }

            if (DeinterlacePref_BOB & m_pRenderer->m_dwDeinterlacePrefs) {

                DeinterlaceCaps.Size = sizeof(DeinterlaceCaps);
                hr = pDeInt->QueryModeCaps((LPGUID)&DXVA_DeinterlaceBobDevice,
                                           &VideoDesc, &DeinterlaceCaps);
                if (hr == S_OK) {
                    GuidChosen = DXVA_DeinterlaceBobDevice;
                }
                __leave;
            }

            ASSERT(DeinterlacePref_NextBest & m_pRenderer->m_dwDeinterlacePrefs);

            for (; i < dwNumModes; i++) {

                DeinterlaceCaps.Size = sizeof(DeinterlaceCaps);
                hr = pDeInt->QueryModeCaps(&Guids[i], &VideoDesc,
                                           &DeinterlaceCaps);
                if (hr == S_OK) {
                    GuidChosen = Guids[i];
                    break;
                }
            }
        }
    }
    __finally {

        if (hr == S_OK && *lpIsInterlaced) {

            *lpDeintGuid = GuidChosen;
            *pCaps = DeinterlaceCaps;
        }
    }

    return hr;
}


/*****************************Private*Routine******************************\
* OnSetProperties
*
*
*
* History:
* Wed 02/23/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::OnSetProperties(
    ALLOCATOR_PROPERTIES* pReq,
    ALLOCATOR_PROPERTIES* pAct
    )
{
    AMTRACE((TEXT("CVMRInputPin::OnSetProperties")));
    CAutoLock cLock(m_pInterfaceLock);

    DWORD dwNumBuffers = max(pReq->cBuffers, MIN_BUFFERS_TO_ALLOCATE);
    DWORD dwActBuffers = dwNumBuffers;
    LONG lSampleSize;
    IPin *pReceivePin = m_Connected;

    ASSERT(pReceivePin);
    ASSERT(m_RenderTransport != AM_VIDEOACCELERATOR);

    AM_MEDIA_TYPE *pNewMediaType = NULL, *pEMediaType = &m_mt;
    HRESULT hr = E_FAIL;
    LPGUID lpDeinterlaceGUID = NULL;


    //
    // Do some checks to make sure the format block is a VIDEOINFO or
    // VIDEOINFO2 (so it's a video type), and that the format is
    // sufficiently large. We also check that the source filter can
    // actually supply this type.
    //

    __try {

        if (((pEMediaType->formattype == FORMAT_VideoInfo &&
              pEMediaType->cbFormat >= sizeof(VIDEOINFOHEADER)) ||
             (pEMediaType->formattype == FORMAT_VideoInfo2 &&
              pEMediaType->cbFormat >= sizeof(VIDEOINFOHEADER2))) &&
              pReceivePin->QueryAccept(pEMediaType) == S_OK) {

            //
            // Temporary work around for IF09 fourcc surface
            // types.  The AVI decoder wrapper filter needs to be fixed,
            // in the mean time ignore IF09 surface types.
            //
            {
                LPBITMAPINFOHEADER lpHdr = GetbmiHeader(pEMediaType);
                if (!lpHdr) {
                    __leave;
                }

                if (lpHdr->biCompression == MAKEFOURCC('I','F','0','9')) {
                    __leave;
                }

                if (lpHdr->biCompression == MAKEFOURCC('Y','U','V','9')) {
                    __leave;
                }

            }

            DWORD dwSurfFlags;

            if (m_pRenderer->m_VMRModePassThru) {

                SIZE AR;
                LPBITMAPINFOHEADER lpHdr = GetbmiHeader(pEMediaType);

                VMRALLOCATIONINFO p;
                CHECK_HR(hr = GetImageAspectRatio(pEMediaType,
                                                  &p.szAspectRatio.cx,
                                                  &p.szAspectRatio.cy));

                if (pEMediaType->subtype == MEDIASUBTYPE_RGB32_D3D_DX7_RT ||
                    pEMediaType->subtype == MEDIASUBTYPE_RGB16_D3D_DX7_RT) {
                    p.dwFlags = AMAP_3D_TARGET;
                }
                else {
                    p.dwFlags = AMAP_ALLOW_SYSMEM;
                }

                if (dwNumBuffers > 1) {
                    p.dwFlags |= AMAP_DIRECTED_FLIP;
                }

                p.lpHdr = lpHdr;
                p.lpPixFmt = NULL;
                p.dwMinBuffers = dwNumBuffers;
                p.dwMaxBuffers = dwNumBuffers;
                p.szNativeSize.cx = abs(lpHdr->biWidth);
                p.szNativeSize.cy = abs(lpHdr->biHeight);

                CHECK_HR(hr = GetInterlaceFlagsFromMediaType(pEMediaType,
                                                             &p.dwInterlaceFlags));

                CHECK_HR(hr = m_pRenderer->m_lpRLNotify->AllocateSurface(
                                    m_pRenderer->m_dwUserID,
                                    &p,
                                    &dwActBuffers,
                                    &m_pDDS));


                DDSURFACEDESC2 ddSurfaceDesc;
                INITDDSTRUCT(ddSurfaceDesc);
                CHECK_HR(hr = m_pDDS->GetSurfaceDesc(&ddSurfaceDesc));
                CHECK_HR(hr = ConvertSurfaceDescToMediaType(&ddSurfaceDesc,
                                                            pEMediaType,
                                                            &pNewMediaType));
#ifdef DEBUG
                m_pDDS->Lock(NULL, &ddSurfaceDesc,
                             DDLOCK_NOSYSLOCK | DDLOCK_WAIT,
                             (HANDLE)NULL);
                m_pDDS->Unlock(NULL);
                DbgLog((LOG_TRACE, 0,
                        TEXT("Created %u surfaces of type %4.4hs @%#X"),
                        ddSurfaceDesc.dwBackBufferCount + 1,
                        (lpHdr->biCompression == 0) ? "RGB " :
                        ((lpHdr->biCompression == BI_BITFIELDS) ? "BITF" :
                        (LPSTR)&lpHdr->biCompression),
                        ddSurfaceDesc.lpSurface
                        ));
#endif

            }
            else {

                GUID guidDeint;
                DWORD Pool = D3DPOOL_DEFAULT;

                hr = GetStreamInterlaceProperties(pEMediaType,
                                                  &m_InterlacedStream,
                                                  &guidDeint,
                                                  &m_DeinterlaceCaps);
                //
                // don't use the SUCCEEDED macro here as
                // GetStreamInterlaceProperties can return S_FALSE
                //
                if (hr == S_OK && m_InterlacedStream) {

                    DWORD dwRefCount = m_DeinterlaceCaps.NumForwardRefSamples +
                                       m_DeinterlaceCaps.NumBackwardRefSamples;

                    DWORD dwSampCount = 1 + dwRefCount;
                    m_pVidHistorySamps = new DXVA_VideoSample[dwSampCount];
                    if (m_pVidHistorySamps == NULL) {
                        hr = E_OUTOFMEMORY;
                        __leave;
                    }
                    ZeroMemory(m_pVidHistorySamps, (dwSampCount * sizeof(DXVA_VideoSample)));
                    m_dwNumHistorySamples = dwSampCount;

                    Pool = m_DeinterlaceCaps.InputPool;

                    DWORD dwExtraBuffNeeded = (dwNumBuffers > 1);
                    dwNumBuffers += (dwExtraBuffNeeded + dwRefCount);


                    dwSurfFlags = 1;
                    hr = AllocateSurface(pEMediaType,
                                         &m_pVidSurfs,
                                         &dwNumBuffers, &dwSurfFlags,
                                         Pool, &pNewMediaType);
                    if (FAILED(hr)) {
                        m_InterlacedStream = FALSE;
                        ZeroMemory(&m_DeinterlaceCaps, sizeof(m_DeinterlaceCaps));
                        ZeroMemory(&m_DeinterlaceGUID, sizeof(m_DeinterlaceGUID));
                        lpDeinterlaceGUID = NULL;
                    }
                    else {
                        m_DeinterlaceGUID = guidDeint;
                        lpDeinterlaceGUID = &m_DeinterlaceGUID;
                    }
                }
                else {
                    m_InterlacedStream = FALSE;
                }

                if (!m_InterlacedStream) {
                    dwSurfFlags = 0;
                    CHECK_HR(hr = AllocateSurface(pEMediaType,
                                                  &m_pVidSurfs,
                                                  &dwNumBuffers, &dwSurfFlags,
                                                  Pool, &pNewMediaType));
                }

                m_dwNumSamples = dwNumBuffers;
                dwActBuffers = dwNumBuffers;
            }
            m_mtNew = *(CMediaType *)pNewMediaType;

            //
            // free the temporary mediatype
            //
            DeleteMediaType(pNewMediaType);
            pNewMediaType = NULL;

            //
            // Get and save the size of the new sample
            //
            m_lSampleSize = m_mtNew.lSampleSize;

            //
            // make sure the decoder likes this new mediatupe
            //
            DbgLog((LOG_TRACE, 1,
                    TEXT("Pin %d calling QueryAccept on the Decoder"),
                    m_dwPinID ));

            hr = pReceivePin->QueryAccept(&m_mtNew);
            if (hr != S_OK) {
                if (hr == S_FALSE) {
                    hr = E_FAIL;
                }
                DbgLog((LOG_TRACE, 1,
                        TEXT("Decoder on Pin %d rejected media type"),
                        m_dwPinID ));
                __leave;
            }

            if (!m_pRenderer->m_VMRModePassThru) {

                IVMRMixerStream* lpMixStream = m_pRenderer->m_lpMixStream;
                if (lpMixStream) {

                    DbgLog((LOG_TRACE, 1,
                        TEXT("Pin %d calling SetStreamMediaType on the Mixer"),
                        m_dwPinID ));

                    CHECK_HR(hr = lpMixStream->SetStreamMediaType(m_dwPinID,
                                                                  pEMediaType,
                                                                  dwSurfFlags,
                                                                  lpDeinterlaceGUID,
                                                                  &m_DeinterlaceCaps));
                }
            }
        }
    }
    __finally {


        if (hr == S_OK) {


            if (m_pRenderer->m_VMRModePassThru && dwNumBuffers > 1) {
                m_dwBackBufferCount = dwActBuffers - dwNumBuffers;
            }
        }
        else  {

            DbgLog((LOG_ERROR, 1,
                    TEXT("AllocateSurfaces failed, hr = 0x%x"), hr));

            if (m_pRenderer->m_VMRModePassThru) {
                m_pRenderer->m_lpRLNotify->FreeSurface(m_pRenderer->m_dwUserID);
                m_pDDS = NULL;
            }
            else {
                ReleaseAllocatedSurfaces();
                RELEASE(m_pDDS);
            }
            FrontBufferStale(FALSE);

            if (pNewMediaType) {
                DeleteMediaType(pNewMediaType);
            }
        }
    }

    return hr;
}


/*****************************Private*Routine******************************\
* OnAlloc
*
*
*
* History:
* Mon 03/13/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::OnAlloc(
    CVMRMediaSample **ppSampleList,
    LONG lSampleCount
    )
{
    AMTRACE((TEXT("CVMRInputPin::OnAlloc")));

    ASSERT(ppSampleList);
    HRESULT hr = S_OK;

    if (m_pRenderer->m_VMRModePassThru) {

        LPDIRECTDRAWSURFACE7 pBackBuffer = NULL;
        DDSURFACEDESC2 ddSurfaceDesc;
        INITDDSTRUCT(ddSurfaceDesc);

        if (!m_pDDS) {
            return E_OUTOFMEMORY;
        }

        hr = m_pDDS->GetSurfaceDesc(&ddSurfaceDesc);

        if (hr == DD_OK) {

            ddSurfaceDesc.ddsCaps.dwCaps &= ~(DDSCAPS_FRONTBUFFER |
                                              DDSCAPS_VISIBLE);

            if (lSampleCount > 1) {

                LPDIRECTDRAWSURFACE7 pDDrawSurface = m_pDDS;

                for (LONG i = 0; i < lSampleCount; i++) {

                    hr = pDDrawSurface->GetAttachedSurface(&ddSurfaceDesc.ddsCaps,
                                                           &pBackBuffer);
                    if (FAILED(hr)) {
                        break;
                    }

                    //DbgLog((LOG_TRACE, 0, TEXT("buffer %d"), i ));
                    //DumpDDSAddress(TEXT("="), pBackBuffer);

                    ppSampleList[i]->SetSurface(pBackBuffer, m_pDDS);
                    pDDrawSurface = pBackBuffer;
                }
            }
            else {

                ASSERT(lSampleCount == 1);

                //
                // Even though we only have a single sample there may well be a
                // back buffer associated with the DDraw surface.  In which case we
                // have to use it.
                //
                hr = m_pDDS->GetAttachedSurface(&ddSurfaceDesc.ddsCaps,
                                                &pBackBuffer);
                if (hr == DD_OK) {
                    ppSampleList[0]->SetSurface(pBackBuffer, m_pDDS);
                }

                //
                // No back buffer attached to this surface so just use
                // the front buffer.  We are probably in mixer mode when
                // this happens (but its not certain)
                //
                else {
                    ppSampleList[0]->SetSurface(m_pDDS);
                    hr = S_OK;
                }
            }
        }
    }
    else {

        if (!m_pVidSurfs) {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}






/*****************************Private*Routine******************************\
* OnGetBuffer
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::OnGetBuffer(
    IMediaSample *pSample,
    REFERENCE_TIME *pStartTime,
    REFERENCE_TIME *pEndTime,
    DWORD dwFlags
    )
{
    AMTRACE((TEXT("CVMRInputPin::OnGetBuffer")));
    DbgLog((LOG_TRACE, 2, TEXT("pSample= %#X"), pSample));

    ASSERT(m_RenderTransport != AM_VIDEOACCELERATOR);

    LPBYTE lpSample;
    LPDIRECTDRAWSURFACE7 lpSurf;
    LONG lSampleSize;
    HRESULT hr = S_OK;

    CVMRMediaSample* pVMRSample = (CVMRMediaSample*)pSample;

    const DWORD dwPinBit = (1 << m_dwPinID);
    if (m_pRenderer->m_dwDisplayChangeMask & dwPinBit) {

        DbgLog((LOG_TRACE, 1, TEXT("Monitor change in progress")));
        hr = E_FAIL;
    }

    if (S_OK == hr) {

        if (m_dwPinID == 0 && m_pRenderer->m_VMRModePassThru) {

            LPDIRECTDRAWSURFACE7 lpDDrawSurface;
            hr = pVMRSample->GetSurface(&lpDDrawSurface);
            if (hr == S_OK) {

                // DumpDDSAddress(TEXT("Decoding into "), lpDDrawSurface);

                //
                // If we are in Delta Decode mode - turn off the
                // AM_GBF_NOTASYNCPOINT flag.  We are handing
                // fake DD surfaces back to the decoder which always
                // contain complete frames
                //
                if (m_dwDeltaDecode & DELTA_DECODE_MODE_SET) {
                    dwFlags &= ~AM_GBF_NOTASYNCPOINT;
                }

                //
                // Only prepare the back buffer from the front buffer
                // if the front buffer contains a valid image.
                //

                if (IsFrontBufferStale()) {
                    dwFlags &= ~AM_GBF_NOTASYNCPOINT;
                }

                hr = m_pRenderer->m_lpRLNotify->PrepareSurface(
                                                    m_pRenderer->m_dwUserID,
                                                    lpDDrawSurface,
                                                    dwFlags);
                if (hr == S_FALSE) {
                    DbgLog((LOG_TRACE, 1,
                            TEXT("Monitor change in pass thru mode")));
                    hr = E_FAIL;
                }

                //
                // The very first time we see the AM_GBF_NOTASYNCPOINT flag set
                // we have to do some checks to make sure that the AP object is
                // capable of processing the Blt from the front buffer to the
                // back buffer in an optimal manner.  This is only really
                // important if we are using FOURCC surfaces and the
                // COPY_FOURCC flag is not set.
                //
                if ((dwFlags & AM_GBF_NOTASYNCPOINT) &&
                    !(m_dwDeltaDecode & DELTA_DECODE_CHECKED)) {

                    LPBITMAPINFOHEADER lpHdr = GetbmiHeader(&m_mt);
                    if ((lpHdr->biCompression > BI_BITFIELDS) &&
                        !(m_pRenderer->m_ddHWCaps.dwCaps2 & DDCAPS2_COPYFOURCC)) {

                        m_dwDeltaDecode = DELTA_DECODE_MODE_SET;
                        hr = pVMRSample->StartDeltaDecodeState();
                    }
                    else {
                        m_dwDeltaDecode = DELTA_DECODE_CHECKED;
                    }
                }

                RELEASE(lpDDrawSurface);
            }
        }
        else {

            if (dwFlags & AM_GBF_NOTASYNCPOINT) {

                // BUGBUG Blt from the front buffer here, but we don't know
                // which buffer is the front buffer.  Anyway, if the upstream
                // decoder is doing delta decodes it would only request a single
                // buffer when it connected.  If we are in mixing mode we
                // never allocate any extra buffers the need for the Blt is
                // removed.
            }

            //
            // we circle thru the surfaces looking for one that is not
            // in use, when we find a free surface we check to see if the surface
            // is part of a de-interlace history sequnce, if it is we need to get
            // another free surface from our pool of surfaces.
            //
            CAutoLock l(&m_DeinterlaceLock);

            DWORD i;
            for (i = 0; i < m_dwNumSamples; i++) {

                if (!m_pVidSurfs[i].InUse) {

                    DWORD j = (m_dwNumHistorySamples == m_dwNumSamples);

                    for (; j < m_dwNumHistorySamples; j++) {
                        LPDIRECTDRAWSURFACE7 t =
                            (LPDIRECTDRAWSURFACE7)m_pVidHistorySamps[j].lpDDSSrcSurface;
                        if (m_pVidSurfs[i].pSurface == t) {
                            break;
                        }
                    }

                    if (m_dwNumHistorySamples == j) {
                        m_pVidSurfs[i].InUse = TRUE;
                        break;
                    }
                }
            }

            DbgLog((LOG_TRACE,2,TEXT("CVMRInputPin::OnGetBuffer(%d)"), i));

            ASSERT(i < m_dwNumSamples);
            pVMRSample->SetSurface(m_pVidSurfs[i].pSurface);
            pVMRSample->SetIndex(i);
        }
    }

    if (S_OK == hr) {

        if (dwFlags & AM_GBF_NODDSURFACELOCK) {
            lpSample = (LPBYTE)~0;
        }
        else {
            hr = pVMRSample->LockSurface(&lpSample);
        }

        if (SUCCEEDED(hr)) {

            hr = pVMRSample->SetPointer(lpSample, m_lSampleSize);
            if (m_bDynamicFormatNeeded) {

                SetMediaType(&m_mtNew);
                hr = pVMRSample->SetMediaType(&m_mtNew);
                m_bDynamicFormatNeeded = FALSE;
            }
        }
    }

    return hr;
}


/*****************************Private*Routine******************************\
* DeleteAllocatedBuffers
*
*
*
* History:
* Thu 03/14/2002 - StEstrop - Created
*
\**************************************************************************/
void
DeleteAllocatedBuffers(
    SURFACE_INFO* pVidSamps,
    DWORD dwBuffCount
    )
{
   for (DWORD i = 0; i < dwBuffCount; i++) {
       RELEASE(pVidSamps[i].pSurface);
   }

}


/*****************************Private*Routine******************************\
* AllocateSurfaceWorker
*
*
*
* History:
* Wed 02/28/2001 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::AllocateSurfaceWorker(
    SURFACE_INFO* pVidSamps,
    DDSURFACEDESC2* lpddsd,
    DWORD* lpdwBuffCount,
    bool fInterlaced
    )
{
    AMTRACE((TEXT("CVMRInputPin::AllocateSurfaceWorker")));
    LPDIRECTDRAW7 lpDD = m_pRenderer->m_lpDirectDraw;
    HRESULT hr = E_FAIL;

    DWORD dwBuffCountReq = *lpdwBuffCount;
    *lpdwBuffCount = 0;     // assume that we cannot allocate any surfaces

    DbgLog((LOG_TRACE, 1, TEXT("Using DDObj %#X to create surfaces on Pin %d"),
            lpDD, m_dwPinID));

    if (fInterlaced) {

        for (DWORD i = 0; i < dwBuffCountReq; i++) {

            hr = lpDD->CreateSurface(lpddsd, &pVidSamps[i].pSurface, NULL);
            if (hr != DD_OK) {
                DeleteAllocatedBuffers(pVidSamps, i);
                break;
            }
        }
    }
    else {

        bool fAGPMemOK = false;
        if (lpddsd->ddpfPixelFormat.dwFlags & DDPF_RGB) {
            fAGPMemOK = ((m_pRenderer->m_TexCaps & TXTR_AGPRGBMEM) == TXTR_AGPRGBMEM);
        }
        else if (lpddsd->ddpfPixelFormat.dwFlags & DDPF_FOURCC) {
            fAGPMemOK = ((m_pRenderer->m_TexCaps & TXTR_AGPYUVMEM) == TXTR_AGPYUVMEM);
        }


        if (fAGPMemOK &&
            (m_pRenderer->m_dwRenderPrefs & RenderPrefs_PreferAGPMemWhenMixing))
        {
            lpddsd->ddsCaps.dwCaps &= ~DDSCAPS_LOCALVIDMEM;
            lpddsd->ddsCaps.dwCaps |=  DDSCAPS_NONLOCALVIDMEM;

            for (DWORD i = 0; i < dwBuffCountReq; i++) {

                hr = lpDD->CreateSurface(lpddsd, &pVidSamps[i].pSurface, NULL);
                if (hr != DD_OK) {
                    DeleteAllocatedBuffers(pVidSamps, i);
                    break;
                }
            }
        }

        if (hr != DD_OK) {

            lpddsd->ddsCaps.dwCaps &= ~DDSCAPS_NONLOCALVIDMEM;
            lpddsd->ddsCaps.dwCaps |=  DDSCAPS_LOCALVIDMEM;

            for (DWORD i = 0; i < dwBuffCountReq; i++) {

                hr = lpDD->CreateSurface(lpddsd, &pVidSamps[i].pSurface, NULL);
                if (hr != DD_OK) {
                    DeleteAllocatedBuffers(pVidSamps, i);
                    break;
                }
            }
        }

        if (hr != DD_OK && fAGPMemOK) {

            DbgLog((LOG_TRACE, 1,
                    TEXT("AllocateSurface: Failed to allocate VidMem - trying AGPMem")));

            lpddsd->ddsCaps.dwCaps &= ~DDSCAPS_LOCALVIDMEM;
            lpddsd->ddsCaps.dwCaps |=  DDSCAPS_NONLOCALVIDMEM;

            for (DWORD i = 0; i < dwBuffCountReq; i++) {

                hr = lpDD->CreateSurface(lpddsd, &pVidSamps[i].pSurface, NULL);
                if (hr != DD_OK) {
                    DeleteAllocatedBuffers(pVidSamps, i);
                    break;
                }
            }

            if (hr == DD_OK) {
                DbgLog((LOG_TRACE, 1,
                        TEXT("AllocateSurface: AGPMem allocation worked !")));
            }
        }
    }

    if (SUCCEEDED(hr)) {
        *lpdwBuffCount = dwBuffCountReq;
    }

    return hr;
}


/*****************************Private*Routine******************************\
* AllocateSurface
*
* Here is some info about how we go about how we go about allocating
* surfaces when the VMR is in mixing mode.
*
* There are 3 steps to the process:
*
*   1. Convert the incomming DShow media type into a DDraw DDSURFACEDESC2
*      structure.
*   2. Get DDraw to create the surfaces - there are fallbacks relating to the
*      physical location of the memory behind the DDraw surface.
*   3. Perform a reverse mapping of the DDSURFACEDESC2 structure back into a
*      DShow media type and then paint each allocate surface black.
*
* In all case this function only succeeds if we allocate all the requested
* DDraw surfaces.
*
* History:
* Wed 03/08/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRInputPin::AllocateSurface(
    const AM_MEDIA_TYPE* cmt,
    SURFACE_INFO** lplpDDSurfInfo,
    DWORD* lpdwBuffCount,
    DWORD* lpdwSurfFlags,
    DWORD Pool,
    AM_MEDIA_TYPE** ppmt
    )
{
    AMTRACE((TEXT("CVMRInputPin::AllocateSurface")));

    bool fInterlaced = !!*lpdwSurfFlags;
    *lpdwSurfFlags = VMR_SF_NONE;


    LPDDCAPS_DX7 lpddHWCaps = &m_pRenderer->m_ddHWCaps;
    LPBITMAPINFOHEADER lpHeader = GetbmiHeader(cmt);
    if (!lpHeader) {
        DbgLog((LOG_ERROR, 1,
                TEXT("AllocateSurface: Can't get bitmapinfoheader ")
                TEXT("from media type!!")));
        return E_INVALIDARG;
    }

    FOURCCMap amFourCCMap(&cmt->subtype);

    DDSURFACEDESC2 ddsd;
    INITDDSTRUCT(ddsd);
    ddsd.dwFlags = DDSD_CAPS | DDSD_WIDTH | DDSD_HEIGHT | DDSD_PIXELFORMAT;
    ddsd.dwWidth = abs(lpHeader->biWidth);
    ddsd.dwHeight = abs(lpHeader->biHeight);

    // define the pixel format
    ddsd.ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT);

    if (lpHeader->biCompression <= BI_BITFIELDS)
    {
        DWORD dwCaps = DDCAPS_BLTSTRETCH;
        if ((dwCaps & lpddHWCaps->dwCaps) != dwCaps) {
            DbgLog((LOG_ERROR, 1, TEXT("Can't BLT_STRETCH!!")));
            return E_FAIL;
        }

        ddsd.ddpfPixelFormat.dwFourCC = BI_RGB;
        ddsd.ddpfPixelFormat.dwFlags = DDPF_RGB;
        ddsd.ddpfPixelFormat.dwRGBBitCount = lpHeader->biBitCount;

        // Store the masks in the DDSURFACEDESC
        const DWORD *pBitMasks = GetBitMasks(lpHeader);
        ASSERT(pBitMasks);
        ddsd.ddpfPixelFormat.dwRBitMask = pBitMasks[0];
        ddsd.ddpfPixelFormat.dwGBitMask = pBitMasks[1];
        ddsd.ddpfPixelFormat.dwBBitMask = pBitMasks[2];
    }
    else if (lpHeader->biCompression > BI_BITFIELDS &&
             lpHeader->biCompression == amFourCCMap.GetFOURCC())
    {
        DWORD dwCaps = (DDCAPS_BLTFOURCC | DDCAPS_BLTSTRETCH);
        if ((dwCaps & lpddHWCaps->dwCaps) != dwCaps) {
            DbgLog((LOG_ERROR, 1,
                    TEXT("AllocateSurface: DDraw device can't ")
                    TEXT("BLT_FOURCC | BLT_STRETCH!!")));
            return E_FAIL;
        }

        ddsd.ddpfPixelFormat.dwFourCC = lpHeader->biCompression;
        ddsd.ddpfPixelFormat.dwFlags = DDPF_FOURCC;
        ddsd.ddpfPixelFormat.dwYUVBitCount = lpHeader->biBitCount;

        if (Special4ccCode(lpHeader->biCompression)) {
            ddsd.ddpfPixelFormat.dwFlags |= DDPF_PALETTEINDEXED4;
        }
    }
    else
    {
        DbgLog((LOG_ERROR, 1,
                TEXT("AllocateSurface: Supplied mediatype not suitable ")
                TEXT("for either YUV or RGB surfaces")));
        return E_FAIL;
    }

    // try designating as a texture first
    if (fInterlaced) {
        ddsd.ddsCaps.dwCaps = MapPool(Pool);
    }
    else {
        ddsd.ddsCaps.dwCaps = DDSCAPS_TEXTURE | DDSCAPS_VIDEOMEMORY;
    }

    if (MEDIASUBTYPE_ARGB32 == cmt->subtype ||
        MEDIASUBTYPE_AYUV == cmt->subtype ||
        MEDIASUBTYPE_ARGB32_D3D_DX7_RT == cmt->subtype)
    {
        ddsd.ddpfPixelFormat.dwFlags |= DDPF_ALPHAPIXELS;
        ddsd.ddpfPixelFormat.dwRGBAlphaBitMask = 0xff000000;
        ddsd.ddpfPixelFormat.dwRBitMask = 0x00ff0000;
        ddsd.ddpfPixelFormat.dwGBitMask = 0x0000ff00;
        ddsd.ddpfPixelFormat.dwBBitMask = 0x000000ff;
    }
    else if (MEDIASUBTYPE_ARGB1555 == cmt->subtype ||
             MEDIASUBTYPE_ARGB1555_D3D_DX7_RT == cmt->subtype)
    {
        ddsd.ddpfPixelFormat.dwFlags |= DDPF_ALPHAPIXELS;
        ddsd.ddpfPixelFormat.dwRGBAlphaBitMask = 0x8000;
        ddsd.ddpfPixelFormat.dwRBitMask = (0x1f<<10);
        ddsd.ddpfPixelFormat.dwGBitMask = (0x1f<< 5);
        ddsd.ddpfPixelFormat.dwBBitMask = (0x1f<< 0);
    }
    else if (MEDIASUBTYPE_ARGB4444 == cmt->subtype ||
             MEDIASUBTYPE_ARGB4444_D3D_DX7_RT == cmt->subtype)
    {
        ddsd.ddpfPixelFormat.dwFlags |= DDPF_ALPHAPIXELS;
        ddsd.ddpfPixelFormat.dwRGBAlphaBitMask = 0xf000;
        ddsd.ddpfPixelFormat.dwRBitMask = 0x0f00;
        ddsd.ddpfPixelFormat.dwGBitMask = 0x00f0;
        ddsd.ddpfPixelFormat.dwBBitMask = 0x000f;
    }

    if (MEDIASUBTYPE_D3D_DX7_RT(*cmt)) {

        //
        // deinterlacing and D3D surfaces are mutually incompatible.
        //

        if (fInterlaced) {
            return E_FAIL;
        }
        ddsd.ddsCaps.dwCaps |= DDSCAPS_3DDEVICE;
    }

    if ((m_pRenderer->m_TexCaps & TXTR_POWER2) &&
        !Special4ccCode(lpHeader->biCompression) &&
        !fInterlaced) {

        for (ddsd.dwWidth = 1;
             (DWORD)abs(lpHeader->biWidth) > ddsd.dwWidth;
             ddsd.dwWidth <<= 1);

        for (ddsd.dwHeight = 1;
             (DWORD)abs(lpHeader->biHeight) > ddsd.dwHeight;
             ddsd.dwHeight <<= 1);
    }

    //
    // Allocate the surface array;
    //
    DWORD dwBuffCount = *lpdwBuffCount;
    SURFACE_INFO* pVidSurfs = new SURFACE_INFO[dwBuffCount];
    if (pVidSurfs == NULL) {
        return E_OUTOFMEMORY;
    }
    ZeroMemory(pVidSurfs, (dwBuffCount * sizeof(SURFACE_INFO)));


    HRESULT hr = E_FAIL;

#ifdef DEBUG
    if (!fInterlaced && lpHeader->biCompression > BI_BITFIELDS &&
        GetProfileIntA("VMR", "Allow4CCTexture", 1) == 0) {

        ;
    }
    else
#endif
    {
        hr = AllocateSurfaceWorker(pVidSurfs, &ddsd,
                                   &dwBuffCount, fInterlaced);
        if (hr == DD_OK && !fInterlaced) {
            *lpdwSurfFlags = VMR_SF_TEXTURE;
        }
    }

    //
    // There are no fallbacks for interlaced content.
    //
    if (FAILED(hr) && !fInterlaced)
    {
        //
        // if alpha in stream, the surface must be a texture
        // so do not fall back to this code path
        //

        DDPIXELFORMAT* ddpfS = &ddsd.ddpfPixelFormat;
        if (ddpfS->dwRGBAlphaBitMask == 0)
        {
            //
            // If we are creating an RGB surface the pixel format
            // of the surface must match that of the current monitor.
            //

            if (ddpfS->dwFourCC == BI_RGB)
            {
                DDPIXELFORMAT* ddpfM = &m_pRenderer->m_ddpfMonitor;

                if (ddpfM->dwRGBBitCount != ddpfS->dwRGBBitCount ||
                    ddpfM->dwRBitMask    != ddpfS->dwRBitMask    ||
                    ddpfM->dwGBitMask    != ddpfS->dwGBitMask    ||
                    ddpfM->dwBBitMask    != ddpfS->dwBBitMask)
                {
                    delete [] pVidSurfs;
                    *lplpDDSurfInfo = NULL;
                    *lpdwBuffCount = 0;
                    DbgLog((LOG_ERROR, 1,
                            TEXT("AllocateSurface: RGB pixel format does not ")
                            TEXT("match monitor")));
                    return hr;
                }
            }

            ddsd.dwWidth = abs(lpHeader->biWidth);
            ddsd.dwHeight = abs(lpHeader->biHeight);
            ddsd.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_VIDEOMEMORY;
            ddsd.ddsCaps.dwCaps2 = 0;
            dwBuffCount = *lpdwBuffCount;

            hr = AllocateSurfaceWorker(pVidSurfs, &ddsd, &dwBuffCount, false);
        }
    }

    if (SUCCEEDED(hr)) {

        INITDDSTRUCT(ddsd);
        hr = pVidSurfs[0].pSurface->GetSurfaceDesc(&ddsd);

        if (SUCCEEDED(hr)) {
            hr = ConvertSurfaceDescToMediaType(&ddsd, cmt, ppmt);
        }

        if (SUCCEEDED(hr)) {

            for (DWORD i = 0; i < dwBuffCount; i++) {
                PaintDDrawSurfaceBlack(pVidSurfs[i].pSurface);
            }

        }
    }

    if (FAILED(hr)) {

        DeleteAllocatedBuffers(pVidSurfs, dwBuffCount);
        delete [] pVidSurfs;
        pVidSurfs = NULL;
        dwBuffCount = 0;
    }

    *lpdwBuffCount   = dwBuffCount;
    *lplpDDSurfInfo = pVidSurfs;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\video\vmrfilter.cpp ===
/******************************Module*Header*******************************\
* Module Name: VMRFilter.cpp
*
*
*
*
* Created: Tue 02/15/2000
* Author:  Stephen Estrop [StEstrop]
*
* Copyright (c) 2000 Microsoft Corporation
\**************************************************************************/
#include <streams.h>
#include <windowsx.h>
#include <limits.h>

#ifdef FILTER_DLL
#include <initguid.h>
#endif

#include <d3d.h>
#include "VMRenderer.h"
#include "dvdmedia.h"  // for MacroVision prop set, id

#if defined(CHECK_FOR_LEAKS)
#include "ifleak.h"
#endif

#ifndef DECLSPEC_SELECTANY
#if (_MSC_VER >= 1100)
#define DECLSPEC_SELECTANY  __declspec(selectany)
#else
#define DECLSPEC_SELECTANY
#endif
#endif

EXTERN_C const GUID DECLSPEC_SELECTANY IID_IDirectDraw7 =
{
    0x15e65ec0, 0x3b9c, 0x11d2,
    {
        0xb9, 0x2f, 0x00, 0x60, 0x97, 0x97, 0xea, 0x5b
    }
};

#ifndef FILTER_DLL
#include <initguid.h>
#endif

// {565DCEF2-AFC5-11d2-8853-0000F80883E3}
DEFINE_GUID(CLSID_COMQualityProperties,
0x565dcef2, 0xafc5, 0x11d2, 0x88, 0x53, 0x0, 0x0, 0xf8, 0x8, 0x83, 0xe3);

// {A2CA6D57-BE10-45e0-9B81-7523681EC278}
DEFINE_GUID(CLSID_VMRFilterConfigProp,
0xa2ca6d57, 0xbe10, 0x45e0, 0x9b, 0x81, 0x75, 0x23, 0x68, 0x1e, 0xc2, 0x78);

// {DEE51F07-DDFF-4e34-8FA9-1BF49179DB8D}
DEFINE_GUID(CLSID_VMRDeinterlaceProp,
0xdee51f07, 0xddff, 0x4e34, 0x8f, 0xa9, 0x1b, 0xf4, 0x91, 0x79, 0xdb, 0x8d);

// Setup data

const AMOVIESETUP_MEDIATYPE
sudVMRPinTypes =
{
    &MEDIATYPE_Video,           // Major type
    &MEDIASUBTYPE_NULL          // And subtype
};

const AMOVIESETUP_PIN
sudVMRPin =
{
    L"Input",                   // Name of the pin
    TRUE,                       // Is pin rendered
    FALSE,                      // Is an Output pin
    FALSE,                      // Ok for no pins
    FALSE,                      // Can we have many
    &CLSID_NULL,                // Connects to filter
    NULL,                       // Name of pin connect
    1,                          // Number of pin types
    &sudVMRPinTypes             // Details for pins
};

// The video renderer should be called "Video Renderer" for
// compatibility with applications using FindFilterByName (e.g., Shock
// to the System 2)

const AMOVIESETUP_FILTER
sudVMRFilter =
{
    &CLSID_VideoRendererDefault, // Filter CLSID
    L"Video Renderer",           // Filter name
    MERIT_PREFERRED + 1,
    1,                          // Number pins
    &sudVMRPin                  // Pin details
};

#ifdef FILTER_DLL
const AMOVIESETUP_FILTER
sudVMRFilter2 =
{
    &CLSID_VideoMixingRenderer,
    L"Video Mixing Renderer",    // Filter name
    MERIT_PREFERRED + 2,
    1,                          // Number pins
    &sudVMRPin                  // Pin details
};

STDAPI DllRegisterServer()
{
    AMTRACE((TEXT("DllRegisterServer")));
    return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
    AMTRACE((TEXT("DllUnregisterServer")));
    return AMovieDllRegisterServer2( FALSE );
}

CFactoryTemplate g_Templates[] = {
    {
        L"",
        &CLSID_VideoMixingRenderer,
        CVMRFilter::CreateInstance,
        CVMRFilter::InitClass,
        &sudVMRFilter2
    },
    {
        L"",
        &CLSID_VideoRendererDefault,
        CVMRFilter::CreateInstance2,
        NULL,
        &sudVMRFilter
    }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

#endif

// This goes in the factory template table to create new filter instances

CUnknown* CVMRFilter::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    AMTRACE((TEXT("CVMRFilter::CreateInstance")));

    //
    // The VMR is being created explictly via a call to CoCreateInstance
    // with the VMR's class ID.  We don't create the Allocator-Presenter object
    // during the VMR's constructor when in this mode.  This is because the
    // application may have already entered DDraw Exclusive mode.  The
    // default Allocator-Presenter won't work in this DDraw mode which would
    // cause the VMR's constructor to fail.
    //
    CUnknown* pk = new CVMRFilter(NAME("Video Mixing Renderer"),
                                  pUnk, phr, FALSE);

    return pk;
}

// create the VMR or the VR if VMR fails due to 8bpp screen mode. what
// about ddraw.dll failing to load?
//
CUnknown* CVMRFilter::CreateInstance2(LPUNKNOWN pUnk, HRESULT *phr)
{
    AMTRACE((TEXT("CVMRFilter::CreateInstance2")));

    //
    // Create the VMR as the default renderer, in this mode we
    // create the Allocator-Presenter object in the VMR's constructor.
    // Doing this provides early feedback as to whether the VMR can be used
    // in this graphics mode.
    //
    CUnknown* pk = new CVMRFilter(NAME("Video Mixing Renderer"),
                                  pUnk, phr, TRUE);

    if(*phr == VFW_E_DDRAW_CAPS_NOT_SUITABLE) {

#ifndef FILTER_DLL
        delete pk;
        *phr = S_OK;
        CUnknown* CRenderer_CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);
        return CRenderer_CreateInstance(pUnk, phr);
#else
        DbgBreak("8bpp unsupported with separate dlls");
#endif
    }

    return pk;
}


/******************************Public*Routine******************************\
* InitClass
*
*
*
* History:
* Thu 12/14/2000 - StEstrop - Created
*
\**************************************************************************/
#if defined(CHECK_FOR_LEAKS)
// the one and only g_IFLeak object.
CInterfaceLeak  g_IFLeak;

void
CVMRFilter::InitClass(
    BOOL bLoading,
    const CLSID *clsid
    )
{
    if (bLoading) {
        DbgLog(( LOG_TRACE, 0, TEXT("VMR Thunks: Loaded") ));
        g_IFLeak.Init();
    }
    else {
        DbgLog(( LOG_TRACE, 0, TEXT("VMR Thunks: Unloaded") ));
        g_IFLeak.Term();
    }
}
#else
void
CVMRFilter::InitClass(
    BOOL bLoading,
    const CLSID *clsid
    )
{
}
#endif


/*****************************Private*Routine******************************\
* GetMediaPositionInterface
*
*
*
* History:
* Tue 03/28/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::GetMediaPositionInterface(
    REFIID riid,
    void ** ppv
    )
{
    AMTRACE((TEXT("CVMRFilter::GetMediaPositionInterface")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    if (m_pPosition) {
        return m_pPosition->NonDelegatingQueryInterface(riid, ppv);
    }

    HRESULT hr = S_OK;
    m_pPosition = new CRendererPosPassThru(NAME("Renderer CPosPassThru"),
                                           CBaseFilter::GetOwner(),
                                           &hr,
                                           GetPin(0));
    if (m_pPosition == NULL) {
        DbgLog((LOG_ERROR, 1,
                TEXT("CreatePosPassThru failed - no memory") ));
        return E_OUTOFMEMORY;
    }

    if (FAILED(hr)) {
        delete m_pPosition;
        DbgLog((LOG_ERROR, 1,
                TEXT("CreatePosPassThru failed, hr = 0x%x"), hr));
        return E_NOINTERFACE;
    }

    return GetMediaPositionInterface(riid,ppv);
}

/*****************************Private*Routine******************************\
* ModeChangeAllowed
*
*
*
* History:
* Fri 04/07/2000 - StEstrop - Created
*
\**************************************************************************/
BOOL
CVMRFilter::ModeChangeAllowed()
{
    AMTRACE((TEXT("CVMRFilter::ModeChangeAllowed")));

    BOOL fRet = ((m_VMRMode & VMRMode_Windowed) &&
                  0 == NumInputPinsConnected() && m_bModeChangeAllowed);

    DbgLog((LOG_TRACE, 2, TEXT("Allowed = %d"), fRet));

    return fRet;
}

/*****************************Private*Routine******************************\
* SetVMRMode
*
*
*
* History:
* Fri 04/07/2000 - StEstrop - Created
*
\**************************************************************************/
void
CVMRFilter::SetVMRMode(
    DWORD mode
    )
{
    AMTRACE((TEXT("CVMRFilter::SetVMRMode")));

    DbgLog((LOG_TRACE, 2, TEXT("Mode = %d"), mode));

    if (m_bModeChangeAllowed) {

        m_bModeChangeAllowed = FALSE;
        m_VMRMode = mode;

        //
        // If we are going renderless get rid of the default
        // allocator-presenter.
        //
        if (mode == VMRMode_Renderless ) {
            m_pIVMRSurfaceAllocatorNotify.AdviseSurfaceAllocator(0, NULL);
        }

        ASSERT(m_pVideoWindow);

        if (m_VMRMode != VMRMode_Windowed && m_pVideoWindow) {
            m_pVideoWindow->InactivateWindow();
            m_pVideoWindow->DoneWithWindow();
            delete m_pVideoWindow;
            m_pVideoWindow = NULL;
        }
    }
    else {

        ASSERT(m_VMRMode == mode);
    }
}


/******************************Public*Routine******************************\
* NonDelegatingQueryInterface
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::NonDelegatingQueryInterface(
    REFIID riid,
    void ** ppv
    )
{
    AMTRACE((TEXT("CVMRFilter::NonDelegatingQueryInterface")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    //
    // The following 3 interfaces control the rendering mode that
    // the video renderer adopts
    //
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;

    if (riid == IID_IVMRSurfaceAllocatorNotify) {

        if (m_VMRMode == VMRMode_Renderless ) {
            hr = GetInterface(&m_pIVMRSurfaceAllocatorNotify, ppv);
        }
    }
    else if (riid == IID_IBasicVideo || riid == IID_IBasicVideo2 ||
             riid == IID_IVideoWindow) {

        if (m_VMRMode == VMRMode_Windowed) {
            hr = m_pVideoWindow->NonDelegatingQueryInterface(riid,ppv);
        }
    }
    else if (riid == IID_IVMRWindowlessControl) {

        if (m_VMRMode == VMRMode_Windowless ) {
            hr = GetInterface((IVMRWindowlessControl *) this, ppv);
        }
        else if (m_VMRMode == VMRMode_Renderless ) {
            if (ValidateIVRWindowlessControlState() == S_OK) {
                hr = GetInterface((IVMRWindowlessControl *) this, ppv);
            }
        }
    }
    else if (riid == IID_IVMRMixerControl) {

        if (!m_VMRModePassThru && m_lpMixControl) {
            hr = GetInterface((IVMRMixerControl *) this, ppv);
        }
    }

    else if (riid == IID_IVMRDeinterlaceControl) {

        hr = GetInterface((IVMRDeinterlaceControl *)(this), ppv);
    }

    //
    // Need to sort out how to seek when we have multiple input streams
    // feeding us.  Seeking should only be allowed if all the input streams
    // are "seekable"
    //

    else if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking) {

        return GetMediaPositionInterface(riid,ppv);
    }

    else if (riid == IID_IKsPropertySet) {

        hr = GetInterface((IKsPropertySet *)this, ppv);
    }

    else if (riid == IID_IAMFilterMiscFlags) {

        hr = GetInterface((IAMFilterMiscFlags *)this, ppv);
    }

    else if (riid == IID_IQualProp) {

        hr = GetInterface(static_cast<IQualProp *>(this), ppv);
    }

    else if (riid == IID_IQualityControl) {

        hr = GetInterface(static_cast<IQualityControl *>(this), ppv);
    }

    else if (riid == IID_IVMRFilterConfig) {
        hr = GetInterface(static_cast<IVMRFilterConfig *>(this), ppv);
    }

    else if (riid == IID_IVMRFilterConfigInternal) {
        hr = GetInterface(static_cast<IVMRFilterConfigInternal *>(this), ppv);
    }

    else if (riid == IID_IVMRMonitorConfig) {

        if ((m_VMRMode & VMRMode_Windowless) ||
            (m_VMRMode & VMRMode_Windowed)) {

            if (ValidateIVRWindowlessControlState() == S_OK) {
                hr = GetInterface(static_cast<IVMRMonitorConfig *>(this), ppv);
            }
        }
    }

    else if (riid == IID_IVMRMixerBitmap) {
        hr = GetInterface(static_cast<IVMRMixerBitmap *>(this), ppv);
    }

    else if (riid == IID_ISpecifyPropertyPages) {
        hr = GetInterface(static_cast<ISpecifyPropertyPages *>(this), ppv);
    }

    else if (riid == IID_IPersistStream) {
        hr = GetInterface(static_cast<IPersistStream *>(this), ppv);
    }

    else {
        hr = CBaseFilter::NonDelegatingQueryInterface(riid,ppv);

    }

#if defined(CHECK_FOR_LEAKS)
    if (hr == S_OK) {
        _pIFLeak->AddThunk((IUnknown **)ppv, "VMR Filter Object",  riid);
    }
#endif

    return hr;
}

struct VMRHardWareCaps {
    HRESULT     hr2D;
    HRESULT     hr3D;
    DWORD       dwBitDepth;
};


/*****************************Private*Routine******************************\
* D3DEnumDevicesCallback7
*
*
*
* History:
* Tue 01/16/2001 - StEstrop - Created
*
\**************************************************************************/
HRESULT CALLBACK
VMRD3DEnumDevicesCallback7(
    LPSTR lpDeviceDescription,
    LPSTR lpDeviceName,
    LPD3DDEVICEDESC7 lpD3DDeviceDesc,
    LPVOID lpContext
    )
{
    AMTRACE((TEXT("VMRD3DEnumDevicesCallback7")));
    VMRHardWareCaps* pHW = (VMRHardWareCaps*)lpContext;
    if (lpD3DDeviceDesc->deviceGUID == IID_IDirect3DHALDevice) {

        switch (pHW->dwBitDepth) {
        case 16:
            if (lpD3DDeviceDesc->dwDeviceRenderBitDepth & DDBD_16) {
                pHW->hr3D = DD_OK;
            }
            break;

        case 24:
            if (lpD3DDeviceDesc->dwDeviceRenderBitDepth & DDBD_24) {
                pHW->hr3D = DD_OK;
            }
            break;

        case 32:
            if (lpD3DDeviceDesc->dwDeviceRenderBitDepth & DDBD_32) {
                pHW->hr3D = DD_OK;
            }
            break;
        }
    }

    return (HRESULT)D3DENUMRET_OK;
}

/*****************************Private*Routine******************************\
* VMRDDEnumCallbackExA
*
*
*
* History:
* Fri 01/12/2001 - StEstrop - Created
*
\**************************************************************************/
BOOL WINAPI
VMRDDEnumCallbackExA(
    GUID *pGUID,
    LPSTR lpDriverDesc,
    LPSTR lpDriverName,
    LPVOID lpContext,
    HMONITOR  hm
    )
{
    AMTRACE((TEXT("VMRDDEnumCallbackExA")));
    LPDIRECTDRAW7 pDD = NULL;
    LPDIRECT3D7 pD3D = NULL;

    VMRHardWareCaps* pHW = (VMRHardWareCaps*)lpContext;

    __try {
        HRESULT hRet;
        CHECK_HR( hRet = DirectDrawCreateEx(pGUID, (LPVOID *)&pDD,
                                            IID_IDirectDraw7, NULL) );
        DDCAPS ddHWCaps;
        INITDDSTRUCT(ddHWCaps);
        CHECK_HR(hRet = pDD->GetCaps(&ddHWCaps, NULL));

        if (!(ddHWCaps.dwCaps & DDCAPS_NOHARDWARE)) {

            DDSURFACEDESC2 ddsd = {sizeof(DDSURFACEDESC2)};
            CHECK_HR(hRet = pDD->GetDisplayMode(&ddsd));

            if (ddsd.ddpfPixelFormat.dwRGBBitCount > 8) {

                pHW->hr2D = DD_OK;
                pHW->dwBitDepth = ddsd.ddpfPixelFormat.dwRGBBitCount;

                CHECK_HR(hRet = pDD->QueryInterface(IID_IDirect3D7, (LPVOID *)&pD3D));
                pD3D->EnumDevices(VMRD3DEnumDevicesCallback7, lpContext);
            }
        }
    }
    __finally {
        RELEASE(pD3D);
        RELEASE(pDD);
    }

    return TRUE;
}

/*****************************Private*Routine******************************\
* BasicHWCheck
*
* In order for the VMR to operate we need some DDraw h/w and a graphics
* display mode greater than 8bits per pixel.
*
* History:
* Fri 01/12/2001 - StEstrop - Created
*
\**************************************************************************/
VMRHardWareCaps
BasicHWCheck()
{
    AMTRACE((TEXT("BasicHWCheck")));
    VMRHardWareCaps hrDDraw = {VFW_E_DDRAW_CAPS_NOT_SUITABLE,
                               VFW_E_DDRAW_CAPS_NOT_SUITABLE};

    HRESULT hr = DirectDrawEnumerateExA(VMRDDEnumCallbackExA, (LPVOID)&hrDDraw,
                                        DDENUM_ATTACHEDSECONDARYDEVICES);
    if (FAILED(hr)) {
        hrDDraw.hr2D = VFW_E_DDRAW_CAPS_NOT_SUITABLE;
        hrDDraw.hr3D = VFW_E_DDRAW_CAPS_NOT_SUITABLE;
    }

    return hrDDraw;
}


/******************************Public*Routine******************************\
* CVMRFilter::CVMRFilter
*
*
* Turn off "warning C4355: 'this' : used in base member initializer list"
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
#pragma warning(disable:4355)
CVMRFilter::CVMRFilter(
    TCHAR *pName,
    LPUNKNOWN pUnk,
    HRESULT *phr,
    BOOL fDefault
    ) :
    CBaseFilter(pName, pUnk, &m_InterfaceLock, CLSID_VideoMixingRenderer),
    CPersistStream(pUnk, phr),
    m_pIVMRSurfaceAllocatorNotify(this),
    m_pIVMRImagePresenter(this),
    m_pIImageSyncNotifyEvent(this),
    m_VMRMode(VMRMode_Windowed),
    m_VMRModePassThru(true),
    m_fInputPinCountSet(false),
    m_dwNumPins(0),
    m_bModeChangeAllowed(TRUE),
    m_lpRLNotify(NULL),
    m_lpWLControl(NULL),
    m_lpIS(NULL),
    m_lpISControl(NULL),
    m_lpMixControl(NULL),
    m_lpMixBitmap(NULL),
    m_lpMixStream(NULL),
    m_lpPresenter(NULL),
    m_pPresenterConfig(NULL),
    m_pPresenterMonitorConfig(NULL),
    m_lpISQualProp(NULL),
    m_lpDirectDraw(NULL),
    m_hMonitor(NULL),
    m_pPosition(NULL),
    m_pVideoWindow(NULL),
    m_pDeinterlace(NULL),
    m_TexCaps(0),
    m_dwDisplayChangeMask(0),
    m_dwEndOfStreamMask(0),
    m_ARMode(VMR_ARMODE_NONE), // please update CompleteConnect if you change this
    m_bARModeDefaultSet(FALSE),
    m_hr3D(DD_OK),
    m_dwRenderPrefs(0),
    m_dwDeinterlacePrefs(DeinterlacePref_NextBest),
    m_VMRCreateAsDefaultRenderer(fDefault)
{
    AMTRACE((TEXT("CVMRFilter::CVMRFilter")));
    HRESULT hr = S_OK;

    ZeroMemory(m_pInputPins, sizeof(m_pInputPins));
    ZeroMemory(&m_ddHWCaps, sizeof(m_ddHWCaps));
    ZeroMemory(&m_ddpfMonitor, sizeof(m_ddpfMonitor));

#ifdef DEBUG
    if (GetProfileIntA("VMR", "LetterBox", 0) == 1) {
        m_ARMode = VMR_ARMODE_LETTER_BOX;
    }

    if (GetProfileIntA("VMR", "APGMemFirst", 0) == 1) {
        m_dwRenderPrefs = RenderPrefs_PreferAGPMemWhenMixing;
    }
#endif

    __try
    {
        VMRHardWareCaps hrDDraw = BasicHWCheck();
        m_hr3D = hrDDraw.hr3D;
        if (FAILED(hrDDraw.hr2D)) {

            DbgLog((LOG_ERROR, 1,
                    TEXT("The machine does not have the necessary h/w to run the VMR!!")));
            *phr = hrDDraw.hr2D;
            __leave;
        }

        hr = ImageSyncInit();
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 1,
                    TEXT("Image Synchronization initialization FAILED!!")));
            *phr = hr;
            __leave;
        }

        hr = CreateInputPin();
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 1,
                    TEXT("Pin initialization FAILED!!")));
            *phr = hr;
            __leave;
        }

        m_pVideoWindow = new CVMRVideoWindow(this, &m_InterfaceLock, GetOwner(), phr);
        if (FAILED(*phr) || m_pVideoWindow == NULL) {

            DbgLog((LOG_ERROR, 1, TEXT("Can't create Video Window!!")));
            if (m_pVideoWindow == NULL) {
                *phr = E_OUTOFMEMORY;
            }
            __leave;
        }
        hr = m_pVideoWindow->PrepareWindow();
        if (FAILED(hr)) {
            *phr = hr;
            __leave;
        }

        if (m_VMRCreateAsDefaultRenderer) {
            hr = ValidateIVRWindowlessControlState();
            if (FAILED(hr)) {
                DbgLog((LOG_ERROR,1,TEXT("Unloading VMR because default AP creation failed")));
                *phr = VFW_E_DDRAW_CAPS_NOT_SUITABLE;
                __leave;
            }
        }

#ifdef DEBUG
        if (GetProfileIntA("VMR", "FrameRate", 0) == 1) {
            m_pVideoWindow->StartFrameRateTimer();
        }
#endif

    }
    __finally
    {
        if ( FAILED(hr) )
        {
            VMRCleanUp();
        }
    }
}

/*****************************Private*Routine******************************\
* VMRCleanUp
*
*
*
* History:
* Thu 04/05/2001 - StEstrop - Created
*
\**************************************************************************/
void
CVMRFilter::VMRCleanUp()
{
    //  Release passthru
    delete m_pPosition;

    //  Release the Window Manager (if we have one)
    if (m_pVideoWindow) {
        m_pVideoWindow->InactivateWindow();
        m_pVideoWindow->DoneWithWindow();
        delete m_pVideoWindow;
        m_pVideoWindow = NULL;
    }

    RELEASE(m_lpMixBitmap);
    RELEASE(m_lpMixControl);
    RELEASE(m_lpMixStream);
    RELEASE(m_lpRLNotify);
    RELEASE(m_lpPresenter);
    RELEASE(m_pPresenterConfig);
    RELEASE(m_pPresenterMonitorConfig);
    RELEASE(m_lpWLControl);
    RELEASE(m_lpIS);

    if (m_lpISControl) {
        m_lpISControl->SetEventNotify(NULL);
        m_lpISControl->SetImagePresenter(NULL, 0);
        m_lpISControl->SetReferenceClock(NULL);
        RELEASE(m_lpISControl);
    }

    RELEASE(m_lpISQualProp);

    DWORD i;
    for (i = 0; i < m_dwNumPins; i++) {
        delete m_pInputPins[i];
        m_pInputPins[i] = NULL;
    }

    for (i = m_dwNumPins; i < MAX_MIXER_PINS; i++) {
        ASSERT(m_pInputPins[i] == NULL);
    }

    SetDDrawDeviceWorker(NULL, NULL);
}


/******************************Public*Routine******************************\
* CVMRFilter::~CVMRFilter
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
CVMRFilter::~CVMRFilter()
{
    AMTRACE((TEXT("CVMRFilter::~CVMRFilter")));
    VMRCleanUp();
}


/*****************************Private*Routine******************************\
* MixerInit
*
*
*
* History:
* Thu 03/09/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::MixerInit(
    DWORD dwNumStreams
    )
{
    AMTRACE((TEXT("CVMRFilter::MixerInit")));

    // A reference leak will occur if this function is called and m_lpMixControl, m_lpMixBitmap
    // or m_lpMixStream is not NULL.
    ASSERT((NULL == m_lpMixControl) && (NULL == m_lpMixBitmap) && (NULL == m_lpMixStream));

    HRESULT hr;

    __try {

        CHECK_HR(hr = CoCreateInstance(CLSID_VideoMixer,
                                       NULL,
                                       CLSCTX_INPROC_SERVER,
                                       IID_IVMRMixerControlInternal,
                                       (LPVOID*)&m_lpMixControl));

        CHECK_HR(hr = m_lpMixControl->QueryInterface(IID_IVMRMixerBitmap,
                                                     (LPVOID *)&m_lpMixBitmap));

        CHECK_HR(hr = m_lpMixControl->SetNumberOfStreams(dwNumStreams));
        CHECK_HR(hr = m_lpMixControl->SetBackEndImageSync(m_lpIS));

        if (m_lpRLNotify) {
            CHECK_HR(hr = m_lpMixControl->SetBackEndAllocator(m_lpRLNotify, m_dwUserID));
        }

        CHECK_HR(hr = m_lpMixControl->QueryInterface(IID_IVMRMixerStream,
                                                     (LPVOID*)&m_lpMixStream));
    }
    __finally {

        if (FAILED(hr)) {
            RELEASE(m_lpMixControl);
            RELEASE(m_lpMixBitmap);
            RELEASE(m_lpMixStream);
        }
    }

    return hr;
}


/*****************************Private*Routine******************************\
* ImageSyncInit()
*
*
*
* History:
* Thu 03/09/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::ImageSyncInit()
{
    AMTRACE((TEXT("CVMRFilter::ImageSyncInit")));
    HRESULT hr = S_OK;

    hr = CoCreateInstance(CLSID_ImageSynchronization, NULL,
                          CLSCTX_INPROC_SERVER, IID_IImageSync,
                          (LPVOID*)&m_lpIS);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1,
                TEXT("Can't create a Core Video Renderer object!!")));
        return hr;
    }


    hr = m_lpIS->QueryInterface(IID_IImageSyncControl, (LPVOID*)&m_lpISControl);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1,
                TEXT("Can't get an IID_IImageSyncControl!!")));
        return hr;
    }

    if (SUCCEEDED(hr)) {
        hr = m_lpISControl->SetImagePresenter(&m_pIVMRImagePresenter, m_dwUserID);
    }

    if (SUCCEEDED(hr)) {
        hr = m_lpISControl->SetEventNotify(&m_pIImageSyncNotifyEvent);
    }

    if (SUCCEEDED(hr)) {
        hr = m_lpIS->QueryInterface(IID_IQualProp, (LPVOID*)&m_lpISQualProp);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 1,
                    TEXT("Can't get an IID_IQualProp from the Image Sync!!")));
        }
    }

    return hr;
}


/*****************************Private*Routine******************************\
* CreateInputPin
*
*
*
* History:
* Thu 03/09/2000 - StEstrop - Created
* Wed 08/22/2001 - BEllett - Changed function name.
*
\**************************************************************************/
HRESULT
CVMRFilter::CreateInputPin()
{
    // Make sure that we can create another input pin.
    ASSERT(m_dwNumPins < MAX_MIXER_PINS);

    HRESULT hr = S_OK;
    DWORD dwInputPinNum = m_dwNumPins;

    WCHAR wszPinName[32];
    wsprintfW(wszPinName, L"VMR Input%d", dwInputPinNum);
    m_pInputPins[dwInputPinNum] = new CVMRInputPin(dwInputPinNum, this, &m_InterfaceLock,
                                       &hr, wszPinName);
    if (m_pInputPins[dwInputPinNum] == NULL) {
        DbgLog((LOG_ERROR, 1,
                TEXT("Ran out of memory creating input pin!!")));
        return E_OUTOFMEMORY;
    }

    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 1,
                TEXT("Unknown error occurred creating input pin!!")));
        delete m_pInputPins[dwInputPinNum];
        m_pInputPins[dwInputPinNum] = NULL;
        return hr;
    }

    m_dwNumPins++;

    return S_OK;
}


/*****************************Private*Routine******************************\
* CreateExtraInputPins
*
*
*
* History:
* Thu 03/09/2000 - StEstrop - Created
* Wed 08/22/2001 - BEllett - Changed function name, removed redundant code,
*                            and fixed a minor memory leak.
*
\**************************************************************************/
HRESULT
CVMRFilter::CreateExtraInputPins(
    DWORD dwNumPins
    )
{
    HRESULT hr = S_OK;

    for (DWORD i = 0; i < dwNumPins; i++) {
        hr = CreateInputPin();
        if (FAILED(hr)) {
            DestroyExtraInputPins();
            return hr;
        }
    }

    return hr;
}


/*****************************Private*Routine******************************\
* DestroyExtraInputPins
*
*
*
* History:
* Wed 08/22/2001 - BEllett - Created
*
\**************************************************************************/
void
CVMRFilter::DestroyExtraInputPins()
{
    for (DWORD i = 1; i < m_dwNumPins; i++) {
        delete m_pInputPins[i];
        m_pInputPins[i] = NULL;
    }

    m_dwNumPins = 1;

    #ifdef DEBUG
    for (i = m_dwNumPins; i < MAX_MIXER_PINS; i++) {
        ASSERT(m_pInputPins[i] == NULL);
    }
    #endif DEBUG
}


/******************************Public*Routine******************************\
* CVMRFilter::GetPin
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
CBasePin*
CVMRFilter::GetPin(
    int n
    )
{
    AMTRACE((TEXT("CVMRFilter::GetPin")));
    ASSERT(n < (int)m_dwNumPins);
    return m_pInputPins[n];
}


/******************************Public*Routine******************************\
* CVMRFilter::GetPinCount()
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
int
CVMRFilter::GetPinCount()
{
    AMTRACE((TEXT("CVMRFilter::GetPinCount")));
    return m_dwNumPins;
}


/******************************Public*Routine******************************\
* CBaseMediaFilter
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::SetSyncSource(
    IReferenceClock *pClock
    )
{
    AMTRACE((TEXT("CVMRFilter::SetSyncSource")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);
    HRESULT hr = CBaseFilter::SetSyncSource(pClock);
    if (SUCCEEDED(hr)) {
        hr = m_lpISControl->SetReferenceClock(pClock);
    }

    return hr;
}

/******************************Public*Routine******************************\
* CVMRFilter::Stop()
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::Stop()
{
    AMTRACE((TEXT("CVMRFilter::Stop")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    HRESULT hr = CBaseFilter::Stop();

    if (SUCCEEDED(hr)) {
        hr = m_lpISControl->EndImageSequence();
    }

    if (m_lpMixControl) {
        ASSERT(!m_VMRModePassThru);
        m_lpMixControl->WaitForMixerIdle(INFINITE);
    }
    return hr;
}


/******************************Public*Routine******************************\
* CVMRFilter::Pause()
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::Pause()
{
    AMTRACE((TEXT("CVMRFilter::Pause")));

    HRESULT hr = S_OK;
    {
        CAutoLock cInterfaceLock(&m_InterfaceLock);

        int PinsConnected = NumInputPinsConnected();

        if (PinsConnected == 0) {

            m_State = State_Paused;
            return S_OK;
        }

        hr = CBaseFilter::Pause();
        if (SUCCEEDED(hr)) {

            hr = m_lpISControl->CueImageSequence();
        }
    }

    //
    //  DON'T hold the lock while doing these window operations
    //  If we do then we can hang if the window thread ever grabs it
    //  because some of these operation do SendMessage to our window
    //  (it's that simple - think about it)
    //  This should be safe because all this stuff really only references
    //  m_hwnd which doesn't change for the lifetime of this object
    //

    AutoShowWindow();
    return hr;
}


/******************************Public*Routine******************************\
* CVMRFilter::Run
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::Run(
    REFERENCE_TIME StartTime
    )
{
    AMTRACE((TEXT("CVMRFilter::Run")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    if (m_State == State_Running) {
        NOTE("State set");
        return S_OK;
    }

    // Send EC_COMPLETE if we're not connected

    if (NumInputPinsConnected() == 0) {
        DbgLog((LOG_TRACE, 2, TEXT("No pin connection")));
        m_State = State_Running;
        NotifyEvent(EC_COMPLETE, S_OK, 0);
        return S_OK;
    }

    DbgLog((LOG_TRACE, 2, TEXT("Changing state to running")));
    HRESULT hr = CBaseFilter::Run(StartTime);
    if (SUCCEEDED(hr)) {
        hr = m_lpISControl->BeginImageSequence(&StartTime);
    }

    AutoShowWindow();

    return hr;
}


/******************************Public*Routine******************************\
* CVMRFilter::GetState
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::GetState(
    DWORD dwMSecs,
    FILTER_STATE *State
    )
{
    AMTRACE((TEXT("CVMRFilter::GetState")));

    if (NumInputPinsConnected() == 0) {
        *State = m_State;
        return S_OK;
    }

    DWORD dwState;
    HRESULT hr = m_lpISControl->GetImageSequenceState(dwMSecs, &dwState);

    if (SUCCEEDED(hr)) {
        *State = (FILTER_STATE)dwState;
    }
    return hr;
}


/*****************************Private*Routine******************************\
* AutoShowWindow
*
* The auto show flag is used to have the window shown automatically when we
* change state. We do this only when moving to paused or running, when there
* is no outstanding EC_USERABORT set and when the window is not already up
* This can be changed through the IVideoWindow interface AutoShow property.
* If the window is not currently visible then we are showing it because of
* a state change to paused or running, in which case there is no point in
* the video window sending an EC_REPAINT as we're getting an image anyway
*
*
* History:
* Fri 04/21/2000 - StEstrop - Created
*
\**************************************************************************/
void
CVMRFilter::AutoShowWindow()
{
    AMTRACE((TEXT("CVMRFilter::AutoShowWindow")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    if (m_pVideoWindow) {

        ASSERT(m_VMRMode == VMRMode_Windowed);
        if( m_VMRMode & VMRMode_Windowed ) {
            HWND hwnd = m_pVideoWindow->GetWindowHWND();

            if (m_pVideoWindow->IsAutoShowEnabled() == TRUE) {
                BOOL bAbort;
                m_lpISControl->GetAbortSignal(&bAbort);
                if (bAbort == FALSE) {

                    if (IsWindowVisible(hwnd) == FALSE) {

                        NOTE("ExecutingAutoShowWindow");
                        // SetRepaintStatus(FALSE);
                        m_pVideoWindow->PerformanceAlignWindow();
                        m_pVideoWindow->DoShowWindow(SW_SHOWNORMAL);
                        m_pVideoWindow->DoSetWindowForeground(TRUE);
                    }
                }
            }
        }
    }
}


/******************************Public*Routine******************************\
* CVMRFilter::Receive
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::Receive(
    DWORD dwPinID,
    IMediaSample *pMediaSample
    )
{
    AMTRACE((TEXT("CVMRFilter::Receive")));

    if (dwPinID == 0) {

        //
        // Store the media times from this sample
        //

        if (m_pPosition) {
            m_pPosition->RegisterMediaTime(pMediaSample);
        }
    }

    return S_OK;
}


/******************************Public*Routine******************************\
* CVMRFilter::Active
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::Active(
    DWORD dwPinID
    )
{
    AMTRACE((TEXT("CVMRFilter::Active")));

    const DWORD dwPinBit = (1 << dwPinID);
    m_dwEndOfStreamMask |= dwPinBit;

    return S_OK;
}


/******************************Public*Routine******************************\
* CVMRFilter::Inactive
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::Inactive(
    DWORD dwPinID
    )
{
    AMTRACE((TEXT("CVMRFilter::Inactive")));

    if (dwPinID == 0) {
        if (m_pPosition) {
            m_pPosition->ResetMediaTime();
        }
    }
    return S_OK;
}


/******************************Public*Routine******************************\
* CVMRFilter::BeginFlush
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::BeginFlush(
    DWORD dwPinID
    )
{
    AMTRACE((TEXT("CVMRFilter::BeginFlush")));

    HRESULT hr = m_lpISControl->BeginFlush();
    return hr;
}


/******************************Public*Routine******************************\
* CVMRFilter::EndFlush
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::EndFlush(
    DWORD dwPinID
    )
{
    AMTRACE((TEXT("CVMRFilter::EndFlush")));

    if (dwPinID == 0) {
        if (m_pPosition) {
            m_pPosition->ResetMediaTime();
        }
    }

    HRESULT hr = m_lpISControl->EndFlush();
    return hr;
}


/******************************Public*Routine******************************\
* CVMRFilter::EndOfStream
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::EndOfStream(
    DWORD dwPinID
    )
{
    AMTRACE((TEXT("CVMRFilter::EndofStream")));
    return m_lpISControl->EndOfStream();
}


/* -------------------------------------------------------------------------
**  deal with connections
** -------------------------------------------------------------------------
*/


/******************************Public*Routine******************************\
* CVMRFilter::BreakConnect
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::BreakConnect(
    DWORD dwPinID
    )
{
    AMTRACE((TEXT("CVMRFilter::BreakConnect")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    HRESULT hr = S_OK;
    if (NumInputPinsConnected() == 1) {

        // Now deactivate Macrovision, if it was activated
        if (m_MacroVision.GetCPHMonitor())
        {
             // clear MV from display
            m_MacroVision.SetMacroVision(m_hMonitor, 0);

            // reset CP key
            m_MacroVision.StopMacroVision();
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
* CVMRFilter::CheckMediaType
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::CheckMediaType(
    const CMediaType* pmt
    )
{
    AMTRACE((TEXT("CVMRFilter::CheckMediaType")));

    if (pmt->majortype != MEDIATYPE_Video) {

        DbgLog((LOG_ERROR, 1, TEXT("CheckMediaType failed: Major Type not Video")));
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    if (pmt->subtype == MEDIASUBTYPE_RGB8) {
        DbgLog((LOG_ERROR, 1, TEXT("CheckMediaType failed: Minor Type is RGB8")));
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    if (*pmt->FormatType() != FORMAT_VideoInfo &&
        *pmt->FormatType() != FORMAT_VideoInfo2) {

        DbgLog((LOG_ERROR, 1, TEXT("CheckMediaType failed: Format Type is not ")
                              TEXT("FORMAT_VideoInfo | FORMAT_VideoInfo2") ));

        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    return S_OK;
}


/******************************Public*Routine******************************\
* CVMRFilter::RuntimeAbortPlayback
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::RuntimeAbortPlayback(
    HRESULT hr
    )
{
    HRESULT hrRet = S_FALSE;
    AMTRACE((TEXT("CVMRFilter::RuntimeAbortPlayback")));

    // A deadlock could occur if the caller holds the renderer lock and
    // attempts to acquire the interface lock.
    ASSERT(CritCheckOut(&m_RendererLock));


    // The interface lock must be held when the filter is calling
    // IsStopped().
    CAutoLock cRendererLock(&m_InterfaceLock);


    // We do not report errors which occur while the filter is stopping,
    // flushing or if the m_bAbort flag is set .  Errors are expected to
    // occur during these operations and the streaming thread correctly
    // handles the errors.

    BOOL bAbort;
    m_lpISControl->GetAbortSignal(&bAbort);

    if (!IsStopped() && !bAbort) {

        // EC_ERRORABORT's first parameter is the error which caused
        // the event and its' last parameter is 0.  See the Direct
        // Show SDK documentation for more information.

        NotifyEvent(EC_ERRORABORT, hr, 0);

        CAutoLock alRendererLock(&m_RendererLock);

        hrRet = m_lpISControl->RuntimeAbortPlayback();
    }

    return hrRet;
}



/******************************Public*Routine******************************\
* CVMRFilter::OnSetProperties
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::OnSetProperties(
    CVMRInputPin *pReceivePin
    )
{
    AMTRACE((TEXT("CVMRFilter::OnSetProperties")));
    HRESULT hr = S_OK;


    //
    // if we are processing a display change clear this pins bit in
    // the display change mask
    //
    const DWORD dwPinBit = (1 << pReceivePin->m_dwPinID);
    if (m_dwDisplayChangeMask & dwPinBit) {
        m_dwDisplayChangeMask &= ~dwPinBit;
    }
    else if (m_pVideoWindow) {

        ASSERT(m_VMRMode & VMRMode_Windowed);
        if( m_VMRMode & VMRMode_Windowed ) {
            m_pVideoWindow->SetDefaultSourceRect();
            m_pVideoWindow->SetDefaultTargetRect();
            m_pVideoWindow->OnVideoSizeChange();

            // Notify the video window of the CompleteConnect
            m_pVideoWindow->CompleteConnect();
            if (pReceivePin->m_fInDFC) {
                m_pVideoWindow->ActivateWindowAsync(TRUE);
            }
            else {
                m_pVideoWindow->ActivateWindow();
            }
        }
    }

    return hr;
}


/* -------------------------------------------------------------------------
** IVMRSurfaceAllocatorNotify
** -------------------------------------------------------------------------
*/

CVMRFilter::CIVMRSurfaceAllocatorNotify::~CIVMRSurfaceAllocatorNotify()
{
    // All of the references to this object should have been
    // released before the VMR is destroyed.
    ASSERT(0 == m_cRef);
}

/******************************Public*Routine******************************\
* CVMRFilter::AdviseSurfaceAllocator
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::CIVMRSurfaceAllocatorNotify::AdviseSurfaceAllocator(
    DWORD_PTR dwUserID,
    IVMRSurfaceAllocator* lpIVRMSurfaceAllocator
    )
{
    AMTRACE((TEXT("CVMRFilter::CIVMRSurfaceAllocatorNotify::AdviseSurfaceAllocator")));
    CAutoLock cInterfaceLock(&m_pObj->m_InterfaceLock);

    FILTER_STATE State;

    //
    // If the caller hasn't set the VMR's mode yet - fail.
    // The mode has to renderless, we can't have any pins connected,
    // and SetVMRMode has to have called.
    //
    BOOL fOK = ((m_pObj->m_VMRMode & VMRMode_Renderless) &&
                 0 == m_pObj->NumInputPinsConnected() &&
                 !m_pObj->m_bModeChangeAllowed);
    if (!fOK) {
        DbgLog((LOG_ERROR, 1, TEXT("SetVMRMode has not been called")));
        return VFW_E_WRONG_STATE;
    }

    // Make sure we are in a stopped state

    m_pObj->GetState(0, &State);
    if (State != State_Stopped) {
        return VFW_E_NOT_STOPPED;
    }


    HRESULT hr = S_OK;

    if (lpIVRMSurfaceAllocator) {
        lpIVRMSurfaceAllocator->AddRef();
    }

    RELEASE(m_pObj->m_lpWLControl);
    RELEASE(m_pObj->m_lpRLNotify);
    RELEASE(m_pObj->m_lpPresenter);
    RELEASE(m_pObj->m_pPresenterConfig);
    RELEASE(m_pObj->m_pPresenterMonitorConfig);

    m_pObj->m_lpRLNotify = lpIVRMSurfaceAllocator;
    m_pObj->m_dwUserID = dwUserID;

    if (m_pObj->m_lpRLNotify) {

        if (m_pObj->m_lpMixControl) {
            ASSERT(!m_pObj->m_VMRModePassThru);
            hr = m_pObj->m_lpMixControl->SetBackEndAllocator(
                                m_pObj->m_lpRLNotify,
                                m_pObj->m_dwUserID);
        }

        hr = m_pObj->m_lpRLNotify->QueryInterface(
                                    IID_IVMRImagePresenter,
                                    (LPVOID*)&m_pObj->m_lpPresenter);
        if( SUCCEEDED( hr )) {
            m_pObj->m_lpPresenter->QueryInterface(
                        IID_IVMRImagePresenterConfig,
                        (LPVOID*)&m_pObj->m_pPresenterConfig);

            m_pObj->m_lpPresenter->QueryInterface(
                        IID_IVMRMonitorConfig,
                        (LPVOID*)&m_pObj->m_pPresenterMonitorConfig);
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
* CVMRFilter::SetDDrawDevice
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::CIVMRSurfaceAllocatorNotify::SetDDrawDevice(
    LPDIRECTDRAW7 lpDDrawDevice,
    HMONITOR hMonitor
    )
{
    AMTRACE((TEXT("CVMRFilter::CIVMRSurfaceAllocatorNotify::SetDDrawDevice")));
    CAutoLock cInterfaceLock(&m_pObj->m_InterfaceLock);
    if ( ( NULL == lpDDrawDevice ) || ( NULL == hMonitor ) )
    {
        DbgLog((LOG_ERROR, 1, TEXT("NULL device or monitor") ));
        return E_POINTER;
    }
    HRESULT hr = S_OK;
    hr = m_pObj->SetDDrawDeviceWorker(lpDDrawDevice, hMonitor);
    return hr;
}


/******************************Public*Routine******************************\
* CVMRFilter::ChangeDDrawDevice
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::CIVMRSurfaceAllocatorNotify::ChangeDDrawDevice(
    LPDIRECTDRAW7 lpDDrawDevice,
    HMONITOR hMonitor
    )
{
    AMTRACE((TEXT("CVMRFilter::CIVMRSurfaceAllocatorNotify::ChangeDDrawDevice")));
    CAutoLock cInterfaceLock(&m_pObj->m_InterfaceLock);

    HRESULT hr = S_OK;
    hr = m_pObj->SetDDrawDeviceWorker(lpDDrawDevice, hMonitor);


    if (SUCCEEDED(hr)) {

        // The VMR can have at most MAX_MIXER_PINS input pins.
        ASSERT(MAX_MIXER_PINS == NUMELMS(m_pObj->m_pInputPins));
        IPin* apPinLocal[MAX_MIXER_PINS];
        IPin** ppPin = NULL;
        int i, iPinCount;
        const int iPinsCreated = m_pObj->GetPinCount();
        ULONG AllocSize = sizeof(IPin*) * iPinsCreated;
        ppPin = (IPin**)CoTaskMemAlloc(AllocSize);

        if (ppPin) {

            ZeroMemory(ppPin, AllocSize);

            //
            // now tell each input pin to reconnect
            //

            for (iPinCount = 0, i = 0; i < iPinsCreated; i++) {

                //
                // get IPin interface
                //

                if (hr == S_OK && m_pObj->m_pInputPins[i]->IsConnected()) {

                    hr = m_pObj->m_pInputPins[i]->QueryInterface(
                                        IID_IPin, (void**)&ppPin[iPinCount]);

                    ASSERT(SUCCEEDED(hr));
                    ASSERT(ppPin[iPinCount]);

                    apPinLocal[iPinCount] = ppPin[iPinCount];

                    iPinCount++;
                    m_pObj->m_dwDisplayChangeMask |=
                                (1 << m_pObj->m_pInputPins[i]->GetPinID());
                }
            }

            //
            // Pass our input pin array as parameter on the event, we don't free
            // the allocated memory - this is done by the event processing
            // code in the FilterGraph
            //

            if (iPinCount > 0) {
                DbgLog((LOG_ERROR, 1,
                        TEXT("EC_DISPLAY_CHANGED sent %d pins to re-connect"),
                        iPinCount));

                // The VMR cannot access the ppPin array after it calls
                // IMediaEventSink::Notify().  It cannot access the
                // array because IMediaEventSink::Notify() can free the
                // array at any time.
                m_pObj->NotifyEvent(EC_DISPLAY_CHANGED, (LONG_PTR)ppPin,
                                    (LONG_PTR)iPinCount);
            }

            //
            // Release the IPin interfaces
            //

            for (i = 0; i < iPinCount; i++) {
                apPinLocal[i]->Release();
            }


            //
            // Tell the mixer about the display mode change.
            //

            if (SUCCEEDED(hr) && m_pObj->m_lpMixControl) {
                ASSERT(!m_pObj->m_VMRModePassThru);
                hr = m_pObj->m_lpMixControl->DisplayModeChanged();
            }

        }
        else {

            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


/*****************************Private*Routine******************************\
* SetDDrawDeviceWorker
*
*
*
* History:
* Thu 03/09/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::SetDDrawDeviceWorker(
    LPDIRECTDRAW7 lpDDrawDevice,
    HMONITOR hMonitor
    )
{
    AMTRACE((TEXT("CVMRFilter::SetDDrawDeviceWorker")));
    CVMRDeinterlaceContainer* pDeinterlace = NULL;
    HRESULT hr = S_OK;

    if (hMonitor != NULL) {

        MONITORINFO mi;
        mi.cbSize = sizeof(mi);
        if (!GetMonitorInfo(hMonitor, &mi)) {
            return E_INVALIDARG;
        }
    }

    if (lpDDrawDevice) {

        INITDDSTRUCT(m_ddHWCaps);
        hr = lpDDrawDevice->GetCaps((LPDDCAPS)&m_ddHWCaps, NULL);

        if (SUCCEEDED(hr)) {

            DDSURFACEDESC2 ddsd;  // A surface description structure
            INITDDSTRUCT(ddsd);

            hr = lpDDrawDevice->GetDisplayMode(&ddsd);
            if (SUCCEEDED(hr)) {
                CopyMemory(&m_ddpfMonitor, &ddsd.ddpfPixelFormat,
                           sizeof(m_ddpfMonitor));
            }
        }

        m_TexCaps = 0;
        GetTextureCaps(lpDDrawDevice, &m_TexCaps);

        if (SUCCEEDED(hr)) {

            lpDDrawDevice->AddRef();

            //
            // we now try to create the deinterlace container DX-VA
            // device.  We continue on failure (including out of memory
            // failures).
            //

            HRESULT hrT = S_OK;
            pDeinterlace = new CVMRDeinterlaceContainer(lpDDrawDevice, &hrT);
            if (FAILED(hrT) && pDeinterlace) {
                delete pDeinterlace;
                pDeinterlace = NULL;
            }
        }
        else {
            lpDDrawDevice = NULL;
        }
    }

    if (m_lpDirectDraw) {
        m_lpDirectDraw->Release();
    }

    if (m_pDeinterlace) {
        delete m_pDeinterlace;
    }

    m_lpDirectDraw = lpDDrawDevice;
    m_hMonitor = hMonitor;
    m_pDeinterlace = pDeinterlace;

    return hr;
}


/******************************Public*Routine******************************\
* SetBorderColor
*
*
*
* History:
* Thu 11/02/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::CIVMRSurfaceAllocatorNotify::SetBorderColor(
    COLORREF clr
    )
{
    AMTRACE((TEXT("CVMRFilter::CIVMRImagePresenter::SetBorderColor")));

    /** this interface is not needed anymore - set SetBackgroundColor below
    **/
    return S_OK;
}


/******************************Public*Routine******************************\
* CVMRFilter::RestoreDDrawSurfaces
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::CIVMRSurfaceAllocatorNotify::RestoreDDrawSurfaces()
{
    AMTRACE((TEXT("CVMRFilter::CIVMRImagePresenter::RestoreDDrawSurface")));

    //
    // Don't generate EC_NEED_RESTART during a display mode change !
    //
    {
        CAutoLock cInterfaceLock(&m_pObj->m_InterfaceLock);
        if (m_pObj->m_dwDisplayChangeMask) {
            return S_OK;
        }
    }

    m_pObj->NotifyEvent(EC_NEED_RESTART, 0, 0);
    return S_OK;
}



/******************************Public*Routine******************************\
* CVMRFilter::NotifyEvent
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::CIVMRSurfaceAllocatorNotify::NotifyEvent(
    LONG EventCode,
    LONG_PTR lp1,
    LONG_PTR lp2
    )
{
    AMTRACE((TEXT("CVMRFilter::CIVMRImagePresenter::NotifyEvent")));

    switch (EventCode) {
    case EC_VMR_SURFACE_FLIPPED:
        m_pObj->m_hrSurfaceFlipped = (HRESULT)lp1;
        break;

    default:
        m_pObj->NotifyEvent(EventCode, lp1, lp2);
        break;
    }

    return S_OK;
}



/* -------------------------------------------------------------------------
** IImageSyncPresenter
** -------------------------------------------------------------------------
*/

/******************************Public*Routine******************************\
* StartPresenting
*
*
*
* History:
* Fri 03/10/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::CIVMRImagePresenter::StartPresenting(
    DWORD_PTR dwUserID
    )
{
    AMTRACE((TEXT("CVMRFilter::CIVMRImagePresenter::StartPresenting")));
    ASSERT(m_pObj->m_lpRLNotify);
    HRESULT hr = S_OK;
    hr = m_pObj->m_lpPresenter->StartPresenting(m_pObj->m_dwUserID);
    return hr;
}

/******************************Public*Routine******************************\
* StopPresenting
*
*
*
* History:
* Fri 03/10/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::CIVMRImagePresenter::StopPresenting(
    DWORD_PTR dwUserID
    )
{
    AMTRACE((TEXT("CVMRFilter::StopPresenting")));
    ASSERT(m_pObj->m_lpRLNotify);
    HRESULT hr = S_OK;
    hr = m_pObj->m_lpPresenter->StopPresenting(m_pObj->m_dwUserID);
    return hr;
}

/******************************Public*Routine******************************\
* CVMRFilter::PresentImage
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::CIVMRImagePresenter::PresentImage(
    DWORD_PTR dwUserID,
    VMRPRESENTATIONINFO* lpPresInfo
    )
{
    AMTRACE((TEXT("CVMRFilter::PresentImage")));
    ASSERT(m_pObj->m_lpRLNotify);

    ASSERT(lpPresInfo);
    ASSERT(lpPresInfo->lpSurf);

    HRESULT hr = S_OK;
    if (lpPresInfo && lpPresInfo->lpSurf) {
        hr = m_pObj->m_lpPresenter->PresentImage(m_pObj->m_dwUserID, lpPresInfo);
    }
    else {
        hr = E_FAIL;
    }

    return hr;
}

/* -------------------------------------------------------------------------
** IImageSyncNotifyEvent
** -------------------------------------------------------------------------
*/

/******************************Public*Routine******************************\
* NotifyEvent
*
*
*
* History:
* Fri 03/10/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::CIImageSyncNotifyEvent::NotifyEvent(
    long lEventCode,
    LONG_PTR lp1,
    LONG_PTR lp2
    )
{
    AMTRACE((TEXT("CVMRFilter::CIImageSyncNotifyEvent::NotifyEvent")));
    HRESULT hr = S_OK;

    switch (lEventCode) {

    case EC_COMPLETE:
        if (m_pObj->m_pPosition) {
            m_pObj->m_pPosition->EOS();
        }

        // fall thru

    case EC_STEP_COMPLETE:
        hr = m_pObj->NotifyEvent(lEventCode, lp1, lp2);
        break;

    default:
        DbgLog((LOG_ERROR, 0,
                TEXT("Unkown event notified from the image sync object !!")));
        ASSERT(0);
        hr = E_FAIL;
        break;
    }

    return hr;
}

/* -------------------------------------------------------------------------
** IVRWindowlessControl
** -------------------------------------------------------------------------
*/

/*****************************Private*Routine******************************\
* CVMRFilter::CreateDefaultAllocatorPresenter
*
*
*
* History:
* Fri 03/03/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::CreateDefaultAllocatorPresenter()
{
    HRESULT hr = S_OK;

    hr = CoCreateInstance(CLSID_AllocPresenter, NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IVMRSurfaceAllocator,
                          (LPVOID*)&m_lpRLNotify);

    if (SUCCEEDED(hr) && m_lpMixControl) {
        ASSERT(!m_VMRModePassThru);
        hr = m_lpMixControl->SetBackEndAllocator(m_lpRLNotify, m_dwUserID);
    }

    if (SUCCEEDED(hr)) {
        m_lpRLNotify->AdviseNotify(&m_pIVMRSurfaceAllocatorNotify);
    }

    if (SUCCEEDED(hr)) {
        hr = m_lpRLNotify->QueryInterface(IID_IVMRImagePresenter,
                                          (LPVOID*)&m_lpPresenter);

    }

    if (SUCCEEDED(hr)) {

        m_lpRLNotify->QueryInterface(IID_IVMRImagePresenterConfig,
                                          (LPVOID*)&m_pPresenterConfig);

        m_lpRLNotify->QueryInterface(IID_IVMRMonitorConfig,
                                          (LPVOID*)&m_pPresenterMonitorConfig);
    }


    if (FAILED(hr)) {

        if (m_lpMixControl) {
            ASSERT(!m_VMRModePassThru);
            m_lpMixControl->SetBackEndAllocator(NULL, m_dwUserID);
        }

        RELEASE(m_lpRLNotify);
        RELEASE(m_lpPresenter);
        RELEASE(m_pPresenterConfig);
        RELEASE(m_pPresenterMonitorConfig);
    }

    return hr;
}


/*****************************Private*Routine******************************\
* ValidateIVRWindowlessControlState
*
* Checks that the filter is in the correct state to process commands via
* the WindowlessControl interface.
*
* History:
* Tue 02/29/2000 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::ValidateIVRWindowlessControlState()
{
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    AMTRACE((TEXT("CVMRFilter::ValidateIVRWindowlessControlState")));
    HRESULT hr = VFW_E_WRONG_STATE;

    if (m_VMRMode & (VMRMode_Windowed | VMRMode_Windowless) ) {

        hr = S_OK;
        if (!m_lpWLControl) {

            if (!m_lpRLNotify) {

                ASSERT(NumInputPinsConnected() == 0);
                hr = CreateDefaultAllocatorPresenter();
            }

            if (SUCCEEDED(hr)) {
                hr = m_lpRLNotify->QueryInterface(IID_IVMRWindowlessControl,
                                                  (LPVOID*)&m_lpWLControl);
            }

            if (SUCCEEDED(hr)) {

                m_lpWLControl->SetAspectRatioMode(m_ARMode);

                if (m_pVideoWindow) {
                    HWND hwnd = m_pVideoWindow->GetWindowHWND();
                    m_lpWLControl->SetVideoClippingWindow(hwnd);
                }
            }

            if (FAILED(hr)) {
                DbgLog((LOG_ERROR, 1,
                        TEXT("Can't get a WindowLess control interface !!")));
                // ASSERT(!"Can't get a WindowLess control interface !!");
            }
        }
    }
    else {

        ASSERT((m_VMRMode & VMRMode_Renderless) == VMRMode_Renderless);

        //
        // We are in renderless mode, the app should have plugged in an
        // allocator-presenter.  If it has lets see if this allocator-presenter
        // supports the IVMRWindowlessControl interface ?
        //

        if (!m_lpWLControl) {

            if (m_lpRLNotify) {

                hr = m_lpRLNotify->QueryInterface(IID_IVMRWindowlessControl,
                                                  (LPVOID*)&m_lpWLControl);
                if (SUCCEEDED(hr)) {
                    m_lpWLControl->SetAspectRatioMode(m_ARMode);
                }
            }
        }
        else {

            hr = S_OK;
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
* CVMRFilter::GetNativeVideoSize
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::GetNativeVideoSize(
    LONG* lWidth,
    LONG* lHeight,
    LONG* lARWidth,
    LONG* lARHeight
    )
{
    AMTRACE((TEXT("CVMRFilter::GetNativeVideoSize")));

    if ( ISBADWRITEPTR(lWidth) || ISBADWRITEPTR(lHeight) )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Bad pointer")));
        return E_POINTER;
    }

    HRESULT hr = ValidateIVRWindowlessControlState();

    if (SUCCEEDED(hr)) {
        hr = m_lpWLControl->GetNativeVideoSize(lWidth, lHeight,
                                               lARWidth, lARHeight);
    }
    return hr;
}

/******************************Public*Routine******************************\
* CVMRFilter::GetMinIdealVideoSize
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::GetMinIdealVideoSize(
    LONG* lWidth,
    LONG* lHeight
    )
{
    AMTRACE((TEXT("CVMRFilter::GetMinIdealVideoSize")));

    if ( ISBADWRITEPTR(lWidth) || ISBADWRITEPTR(lHeight) )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Bad pointer")));
        return E_POINTER;
    }

    HRESULT hr = ValidateIVRWindowlessControlState();

    if (SUCCEEDED(hr)) {
        hr = m_lpWLControl->GetMinIdealVideoSize(lWidth, lHeight);
    }
    return hr;
}

/******************************Public*Routine******************************\
* CVMRFilter::GetMaxIdealVideoSize
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::GetMaxIdealVideoSize(
    LONG* lWidth,
    LONG* lHeight
    )
{
    AMTRACE((TEXT("CVMRFilter::GetMaxIdealVideoSize")));

    if ( ISBADWRITEPTR(lWidth) || ISBADWRITEPTR(lHeight) )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Bad pointer")));
        return E_POINTER;
    }

    HRESULT hr = ValidateIVRWindowlessControlState();

    if (SUCCEEDED(hr)) {
        hr = m_lpWLControl->GetMaxIdealVideoSize(lWidth, lHeight);
    }
    return hr;
}

/******************************Public*Routine******************************\
* CVMRFilter::SetVideoPosition
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::SetVideoPosition(
    const LPRECT lpSRCRect,
    const LPRECT lpDSTRect
    )
{
    AMTRACE((TEXT("CVMRFilter::SetVideoPosition")));

    if ( ISBADREADPTR(lpSRCRect) && ISBADREADPTR(lpDSTRect) )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Bad pointer")));
        return E_POINTER;
    }

    HRESULT hr = ValidateIVRWindowlessControlState();

    if (SUCCEEDED(hr)) {
        hr = m_lpWLControl->SetVideoPosition(lpSRCRect, lpDSTRect);
    }
    return hr;
}

/******************************Public*Routine******************************\
* CVMRFilter::GetVideoPosition
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::GetVideoPosition(
    LPRECT lpSRCRect,
    LPRECT lpDSTRect
    )
{
    AMTRACE((TEXT("CVMRFilter::GetVideoPosition")));

    if ( ISBADWRITEPTR(lpSRCRect) && ISBADWRITEPTR(lpDSTRect) )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Bad pointer")));
        return E_POINTER;
    }

    HRESULT hr = ValidateIVRWindowlessControlState();

    if (SUCCEEDED(hr)) {
        hr = m_lpWLControl->GetVideoPosition(lpSRCRect, lpDSTRect);
    }
    return hr;
}

/******************************Public*Routine******************************\
* CVMRFilter::GetAspectRatioMode
*
*
*
* History:
* Tue 02/29/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::GetAspectRatioMode(
    DWORD* lpAspectRatioMode
    )
{
    AMTRACE((TEXT("CVMRFilter::GetAspectRationMode")));

    if ( ISBADWRITEPTR(lpAspectRatioMode) )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Bad pointer")));
        return E_POINTER;
    }

    HRESULT hr = ValidateIVRWindowlessControlState();

    if (SUCCEEDED(hr)) {
        hr = m_lpWLControl->GetAspectRatioMode(lpAspectRatioMode);
    }
    return hr;
}

/******************************Public*Routine******************************\
* CVMRFilter::SetAspectRatioMode
*
*
*
* History:
* Tue 02/29/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::SetAspectRatioMode(
    DWORD AspectRatioMode
    )
{
    AMTRACE((TEXT("CVMRFilter::SetAspectRationMode")));

    HRESULT hr = ValidateIVRWindowlessControlState();

    if (SUCCEEDED(hr)) {
        hr = m_lpWLControl->SetAspectRatioMode(AspectRatioMode);
    }

    if( SUCCEEDED(hr )) {
        m_bARModeDefaultSet = TRUE;
    }
    return hr;
}

/******************************Public*Routine******************************\
* CVMRFilter::SetVideoClippingWindow
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::SetVideoClippingWindow(
    HWND hwnd
    )
{
    AMTRACE((TEXT("CVMRFilter::SetWindowHandle")));

    if (!IsWindow(hwnd) )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid HWND")));
        return E_INVALIDARG;
    }

    HRESULT hr = ValidateIVRWindowlessControlState();

    if (SUCCEEDED(hr)) {
        hr = m_lpWLControl->SetVideoClippingWindow(hwnd);
    }
    return hr;
}


/******************************Public*Routine******************************\
* CVMRFilter::RepaintVideo
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::RepaintVideo(
    HWND hwnd,
    HDC hdc
    )
{
    AMTRACE((TEXT("CVMRFilter::RepaintVideo")));

    if (!IsWindow(hwnd) )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid HWND")));
        return E_INVALIDARG;
    }

    if (!hdc) {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid HDC")));
        return E_INVALIDARG;
    }

    HRESULT hr = ValidateIVRWindowlessControlState();

    if (SUCCEEDED(hr)) {
        hr = m_lpWLControl->RepaintVideo(hwnd, hdc);
    }
    return hr;
}


/******************************Public*Routine******************************\
* CVMRFilter::DisplayModeChanged
*
*
*
* History:
* Tue 02/29/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::DisplayModeChanged()
{
    AMTRACE((TEXT("CVMRFilter::DisplayModeChanged")));

    HRESULT hr = ValidateIVRWindowlessControlState();

    if (SUCCEEDED(hr)) {
        hr = m_lpWLControl->DisplayModeChanged();
    }
    return hr;
}

/******************************Public*Routine******************************\
* GetCurrentImage
*
*
*
* History:
* Fri 06/23/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::GetCurrentImage(
    BYTE** lpDib
    )
{
    AMTRACE((TEXT("CVMRFilter::GetCurrentImage")));

    if (ISBADWRITEPTR(lpDib)) {
        DbgLog((LOG_ERROR, 1, TEXT("Bad pointer")));
        return E_POINTER;
    }

    HRESULT hr = ValidateIVRWindowlessControlState();

    if (SUCCEEDED(hr)) {
        hr = m_lpWLControl->GetCurrentImage(lpDib);
    }
    return hr;

}

/******************************Public*Routine******************************\
* CVMRFilter::SetBorderColor
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::SetBorderColor(
    COLORREF Clr
    )
{
    AMTRACE((TEXT("CVMRFilter::SetBorderColor")));

    HRESULT hr = ValidateIVRWindowlessControlState();

    if (SUCCEEDED(hr)) {
        hr = m_lpWLControl->SetBorderColor(Clr);
    }
    return hr;
}

/******************************Public*Routine******************************\
* CVMRFilter::GetBorderColor
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::GetBorderColor(
    COLORREF* lpClr
    )
{
    AMTRACE((TEXT("CVMRFilter::GetBorderColor")));

    HRESULT hr = ValidateIVRWindowlessControlState();

    if (SUCCEEDED(hr)) {
        hr = m_lpWLControl->GetBorderColor(lpClr);
    }
    return hr;
}

/******************************Public*Routine******************************\
* CVMRFilter::SetColorKey
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::SetColorKey(
    COLORREF Clr
    )
{
    AMTRACE((TEXT("CVMRFilter::SetColorKey")));

    HRESULT hr = ValidateIVRWindowlessControlState();

    if (SUCCEEDED(hr)) {
        hr = m_lpWLControl->SetColorKey(Clr);
    }
    return hr;
}

/******************************Public*Routine******************************\
* CVMRFilter::GetColorKey
*
*
*
* History:
* Fri 02/25/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::GetColorKey(
    COLORREF* lpClr
    )
{
    AMTRACE((TEXT("CVMRFilter::GetColorKey")));

    HRESULT hr = ValidateIVRWindowlessControlState();

    if (SUCCEEDED(hr)) {
        hr = m_lpWLControl->GetColorKey(lpClr);
    }
    return hr;
}


/******************************Public*Routine******************************\
* CVMRFilter::SetAlpha
*
*
*
* History:
* Mon 04/24/2000 - GlennE - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::SetAlpha(
    DWORD dwStreamID,
    float Alpha
    )
{
    AMTRACE((TEXT("CVMRFilter::SetAlpha")));

    CAutoLock lck(m_pLock);

    if (dwStreamID > m_dwNumPins) {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid stream ID")));
        return E_INVALIDARG;
    }

    if (!m_lpMixStream) {
        return VFW_E_VMR_NOT_IN_MIXER_MODE;
    }

    return m_lpMixStream->SetStreamAlpha(dwStreamID, Alpha);
}

/******************************Public*Routine******************************\
* CVMRFilter::GetAlpha
*
*
*
* History:
* Mon 04/24/2000 - GlennE - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::GetAlpha(
    DWORD dwStreamID,
    float* pAlpha
    )
{
    AMTRACE((TEXT("CVMRFilter::GetAlpha")));

    CAutoLock lck(m_pLock);

    if (ISBADWRITEPTR(pAlpha))
    {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid pointer")));
        return E_POINTER;
    }

    if (dwStreamID > m_dwNumPins) {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid stream ID")));
        return E_INVALIDARG;
    }

    if (!m_lpMixStream) {
        return VFW_E_VMR_NOT_IN_MIXER_MODE;
    }

    return m_lpMixStream->GetStreamAlpha(dwStreamID, pAlpha);
}

/******************************Public*Routine******************************\
* CVMRFilter::SetZOrder
*
*
*
* History:
* Mon 04/24/2000 - GlennE - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::SetZOrder(
    DWORD dwStreamID,
    DWORD ZOrder
    )
{
    AMTRACE((TEXT("CVMRFilter::SetZOrder")));

    CAutoLock lck(m_pLock);
    HRESULT hr = VFW_E_NOT_CONNECTED;

    if (dwStreamID > m_dwNumPins) {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid stream ID")));
        return E_INVALIDARG;
    }

    if (!m_lpMixStream) {
        return VFW_E_VMR_NOT_IN_MIXER_MODE;
    }
    return m_lpMixStream->SetStreamZOrder(dwStreamID, ZOrder);
}

/******************************Public*Routine******************************\
* CVMRFilter::GetZOrder
*
*
*
* History:
* Mon 04/24/2000 - GlennE - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::GetZOrder(
    DWORD dwStreamID,
    DWORD* pdwZOrder
    )
{
    AMTRACE((TEXT("CVMRFilter::GetZOrder")));

    CAutoLock lck(m_pLock);

    if (dwStreamID > m_dwNumPins) {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid stream ID")));
        return E_INVALIDARG;
    }

    if (ISBADWRITEPTR(pdwZOrder))
    {
        DbgLog((LOG_ERROR, 1, TEXT("GetZOrder: Invalid pointer")));
        return E_POINTER;
    }

    if (!m_lpMixStream) {
        return VFW_E_VMR_NOT_IN_MIXER_MODE;
    }

    return m_lpMixStream->GetStreamZOrder(dwStreamID, pdwZOrder);
}

/******************************Public*Routine******************************\
* CVMRFilter::SetRelativeOutputRect
*
*
*
* History:
* Mon 04/24/2000 - GlennE - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::SetOutputRect(
    DWORD dwStreamID,
    const NORMALIZEDRECT *prDest
    )
{
    AMTRACE((TEXT("CVMRFilter::SetOutputRect")));

    CAutoLock lck(m_pLock);

    if (ISBADREADPTR(prDest))
    {
        DbgLog((LOG_ERROR, 1, TEXT("SetOutputRect: Invalid pointer")));
        return E_POINTER;
    }

    if (dwStreamID > m_dwNumPins) {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid stream ID")));
        return E_INVALIDARG;
    }

    if (!m_lpMixStream) {
        return VFW_E_VMR_NOT_IN_MIXER_MODE;
    }
    return m_lpMixStream->SetStreamOutputRect(dwStreamID, prDest);
}

/******************************Public*Routine******************************\
* CVMRFilter::GetOutputRect
*
*
*
* History:
* Mon 04/24/2000 - GlennE - Created
* Tue 05/16/2000 - nwilt - renamed to GetOutputRect
*
\**************************************************************************/
HRESULT
CVMRFilter::GetOutputRect(
    DWORD dwStreamID,
    NORMALIZEDRECT* pOut
    )
{
    AMTRACE((TEXT("CVMRFilter::GetOutputRect")));

    CAutoLock lck(m_pLock);

    if (ISBADWRITEPTR(pOut))
    {
        DbgLog((LOG_ERROR, 1, TEXT("GetOutputRect: Invalid pointer")));
        return E_POINTER;
    }

    if (dwStreamID > m_dwNumPins) {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid stream ID")));
        return E_INVALIDARG;
    }

    if (!m_lpMixStream) {
        return VFW_E_VMR_NOT_IN_MIXER_MODE;
    }

    return m_lpMixStream->GetStreamOutputRect(dwStreamID, pOut);
}


/******************************Public*Routine******************************\
* SetBackgroundClr
*
*
*
* History:
* Fri 03/02/2001 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::SetBackgroundClr(
    COLORREF clrBkg
    )
{
    AMTRACE((TEXT("CVMRFilter::SetBackgroundClr")));

    CAutoLock lck(m_pLock);
    HRESULT hr = VFW_E_VMR_NOT_IN_MIXER_MODE;

    if (m_lpMixControl) {
        ASSERT(!m_VMRModePassThru);
        hr = m_lpMixControl->SetBackgroundColor(clrBkg);
    }

    return hr;
}

/******************************Public*Routine******************************\
* GetBackgroundClr
*
*
*
* History:
* Fri 03/02/2001 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::GetBackgroundClr(
    COLORREF* lpClrBkg
    )
{
    AMTRACE((TEXT("CVMRFilter::GetBackgroundClr")));
    CAutoLock lck(m_pLock);

    if (ISBADWRITEPTR(lpClrBkg))
    {
        DbgLog((LOG_ERROR, 1, TEXT("GetBackgroundClr: Invalid pointer")));
        return E_POINTER;
    }

    HRESULT hr = VFW_E_VMR_NOT_IN_MIXER_MODE;

    if (m_lpMixControl) {
        ASSERT(!m_VMRModePassThru);
        hr = m_lpMixControl->GetBackgroundColor(lpClrBkg);
    }

    return hr;
}

/******************************Public*Routine******************************\
* SetMixingPrefs
*
*
*
* History:
* Fri 03/02/2001 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::SetMixingPrefs(
    DWORD dwRenderFlags
    )
{
    AMTRACE((TEXT("CVMRFilter::SetMixingPrefs")));
    CAutoLock lck(m_pLock);

    HRESULT hr = VFW_E_VMR_NOT_IN_MIXER_MODE;

    if (m_lpMixControl) {
        ASSERT(!m_VMRModePassThru);
        hr = m_lpMixControl->SetMixingPrefs(dwRenderFlags);
    }

    return hr;
}


/******************************Public*Routine******************************\
* GetMixingPrefs
*
*
*
* History:
* Fri 03/02/2001 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::GetMixingPrefs(
    DWORD* pdwRenderFlags
    )
{
    AMTRACE((TEXT("CVMRFilter::GetMixingPrefs")));
    CAutoLock lck(m_pLock);

    if (ISBADWRITEPTR(pdwRenderFlags))
    {
        DbgLog((LOG_ERROR, 1, TEXT("GetMixingPrefs: Invalid pointer")));
        return E_POINTER;
    }

    HRESULT hr = VFW_E_VMR_NOT_IN_MIXER_MODE;

    if (m_lpMixControl) {
        ASSERT(!m_VMRModePassThru);
        hr = m_lpMixControl->GetMixingPrefs(pdwRenderFlags);
    }

    return hr;
}


/*****************************Private*Routine******************************\
* IsVPMConnectedToUs
*
* check for the VPM - we can't frame step if it is connected to us.
*
* History:
* Wed 06/13/2001 - StEstrop - Created
*
\**************************************************************************/
BOOL
CVMRFilter::IsVPMConnectedToUs()
{
    for (DWORD i = 0; i < m_dwNumPins; i++) {

        if (m_pInputPins[i]->m_Connected) {

            PIN_INFO Inf;
            HRESULT hr = m_pInputPins[i]->m_Connected->QueryPinInfo(&Inf);

            if (SUCCEEDED(hr)) {

                IVPManager* vpm;
                hr = Inf.pFilter->QueryInterface(IID_IVPManager,(LPVOID*)&vpm);
                Inf.pFilter->Release();

                if (SUCCEEDED(hr)) {

                    vpm->Release();
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}



/******************************Public*Routine******************************\
* Set
*
*
*
* History:
* Tue 04/11/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::Set(
    REFGUID guidPropSet,
    DWORD dwPropID,
    LPVOID pInstanceData,
    DWORD cbInstanceData,
    LPVOID pPropData,
    DWORD cbPropData
    )
{
    AMTRACE((TEXT("CVMRFilter::Set")));

    if (guidPropSet == AM_KSPROPSETID_FrameStep)
    {
        if (IsVPMConnectedToUs()) {
            return E_PROP_ID_UNSUPPORTED;
        }

        if (dwPropID != AM_PROPERTY_FRAMESTEP_STEP &&
            dwPropID != AM_PROPERTY_FRAMESTEP_CANCEL &&
            dwPropID != AM_PROPERTY_FRAMESTEP_CANSTEP &&
            dwPropID != AM_PROPERTY_FRAMESTEP_CANSTEPMULTIPLE)
        {
            return E_PROP_ID_UNSUPPORTED;
        }

        switch (dwPropID) {
        case AM_PROPERTY_FRAMESTEP_STEP:
            if (cbPropData < sizeof(AM_FRAMESTEP_STEP)) {
                return E_INVALIDARG;
            }

            if (0 == ((AM_FRAMESTEP_STEP *)pPropData)->dwFramesToStep) {
                return E_INVALIDARG;
            }
            else {
                CAutoLock cLock(&m_InterfaceLock);
                DWORD dwStep = ((AM_FRAMESTEP_STEP *)pPropData)->dwFramesToStep;
                return m_lpISControl->FrameStep(dwStep, 0);
            }
            return S_OK;


        case AM_PROPERTY_FRAMESTEP_CANCEL:
            {
                CAutoLock cLock(&m_InterfaceLock);
                return m_lpISControl->CancelFrameStep();
            }
            return S_OK;

        case AM_PROPERTY_FRAMESTEP_CANSTEP:
        case AM_PROPERTY_FRAMESTEP_CANSTEPMULTIPLE:
            return S_OK;
        }
    }

    if (guidPropSet != AM_KSPROPSETID_CopyProt)
        return E_PROP_SET_UNSUPPORTED;

    if (dwPropID != AM_PROPERTY_COPY_MACROVISION)
        return E_PROP_ID_UNSUPPORTED;

    if (pPropData == NULL)
        return E_INVALIDARG;

    if (cbPropData < sizeof(DWORD))
        return E_INVALIDARG ;

    if (m_MacroVision.SetMacroVision(m_hMonitor, *((LPDWORD)pPropData)))
        return NOERROR;
    else
        return VFW_E_COPYPROT_FAILED;
}

/******************************Public*Routine******************************\
* Get
*
*
*
* History:
* Tue 04/11/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::Get(
    REFGUID guidPropSet,
    DWORD PropID,
    LPVOID pInstanceData,
    DWORD cbInstanceData,
    LPVOID pPropData,
    DWORD cbPropData,
    DWORD *pcbReturned
    )
{
    AMTRACE((TEXT("CVMRFilter::Get")));
    return E_NOTIMPL;
}


/******************************Public*Routine******************************\
* QuerySupported
*
*
*
* History:
* Tue 04/11/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::QuerySupported(
    REFGUID guidPropSet,
    DWORD dwPropID,
    DWORD *pTypeSupport
    )
{
    AMTRACE((TEXT("CVMRFilter::QuerySupported")));

    if (guidPropSet != AM_KSPROPSETID_CopyProt)
        return E_PROP_SET_UNSUPPORTED ;

    if (dwPropID != AM_PROPERTY_COPY_MACROVISION)
        return E_PROP_ID_UNSUPPORTED ;

    if (pTypeSupport)
        *pTypeSupport = KSPROPERTY_SUPPORT_SET ;

    return S_OK;
}

/******************************Public*Routine******************************\
* SetImageCompositor
*
*
*
* History:
* Fri 06/23/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::SetImageCompositor(
    IVMRImageCompositor* lpVMRImgCompositor
    )
{
    AMTRACE((TEXT("CVMRFilter::SetImageCompositor")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    HRESULT hr = VFW_E_VMR_NOT_IN_MIXER_MODE;
    if (m_lpMixControl) {
        ASSERT(!m_VMRModePassThru);
        hr = m_lpMixControl->SetImageCompositor(lpVMRImgCompositor);
    }
    return hr;
}


/******************************Public*Routine******************************\
* SetNumberOfStreams
*
*
*
* History:
* Tue 04/11/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::SetNumberOfStreams(
    DWORD dwMaxStreams
    )
{
    AMTRACE((TEXT("CVMRFilter::SetNumberOfStreams")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    HRESULT hr = VFW_E_WRONG_STATE;

    if (m_hr3D != DD_OK) {

        DbgLog((LOG_ERROR, 1,
                TEXT("This graphics mode does not have the  necessary 3D h/w to perform mix!ing !")));

        return m_hr3D;
    }

    // preempt egregiously bad calls before passing to mixer
    if (dwMaxStreams > MAX_MIXER_STREAMS) {
        DbgLog((LOG_ERROR, 1, TEXT("Too many Mixer Streams !!")));
        return E_INVALIDARG;
    }

    if (!m_fInputPinCountSet && m_VMRModePassThru && !NumInputPinsConnected())
    {
        if (dwMaxStreams > 0) {

            hr = S_OK;
            if (dwMaxStreams > 1) {
                // We subtract one from the number of streams because the
                // first input pin has already been created in the constructor.
                hr = CreateExtraInputPins(dwMaxStreams-1);
            }

            if (SUCCEEDED(hr)) {
                hr = MixerInit(dwMaxStreams);
                if (FAILED(hr)) {
                    DbgLog((LOG_ERROR, 1,
                            TEXT("Mixer initialization FAILED!!")));

                    if (dwMaxStreams > 1) {
                        DestroyExtraInputPins();
                    }
                }
            }
        }
        else {
            DbgLog((LOG_ERROR, 1, TEXT("MaxStreams must be greater than 0")));
            hr = E_INVALIDARG;
        }
    }

    if (SUCCEEDED(hr)) {
        m_fInputPinCountSet = true;
        m_VMRModePassThru = false;
    }

    return hr;
}

/******************************Public*Routine******************************\
* GetNumberOfStreams
*
*
*
* History:
* Tue 04/11/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::GetNumberOfStreams(
    DWORD* pdwMaxStreams
    )
{
    AMTRACE((TEXT("CVMRFilter::GetNumberOfStreams")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    if ( ISBADWRITEPTR(pdwMaxStreams) )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Bad pointer") ));
        return E_POINTER;
    }

    HRESULT hr = VFW_E_VMR_NOT_IN_MIXER_MODE;
    if (m_lpMixControl) {
        ASSERT(!m_VMRModePassThru);
        hr = m_lpMixControl->GetNumberOfStreams(pdwMaxStreams);
    }
    return hr;
}

/******************************Public*Routine******************************\
* SetRenderingPrefs
*
*
*
* History:
* Tue 04/25/2000 - GlennE - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::SetRenderingPrefs(
    DWORD dwRenderingPrefs
    )
{
    AMTRACE((TEXT("CVMRFilter::SetRenderingPrefs")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    if (dwRenderingPrefs & ~RenderPrefs_Mask) {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid rendering pref specified")));
        return E_INVALIDARG;
    }


    HRESULT hr = VFW_E_WRONG_STATE;
    if (m_pPresenterConfig) {

        if (dwRenderingPrefs & RenderPrefs_PreferAGPMemWhenMixing) {
            m_dwRenderPrefs |= RenderPrefs_PreferAGPMemWhenMixing;
        }
        else {
            m_dwRenderPrefs &= ~RenderPrefs_PreferAGPMemWhenMixing;
        }

        // turn of flags that don't effect the AP object.
        dwRenderingPrefs &= ~RenderPrefs_PreferAGPMemWhenMixing;

        hr = m_pPresenterConfig->SetRenderingPrefs(dwRenderingPrefs);
    }
    return hr;
}

/******************************Public*Routine******************************\
* GetRenderingPrefs
*
*
*
* History:
* Tue 04/25/2000 - GlennE - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::GetRenderingPrefs(
    DWORD* pdwRenderingPrefs
    )
{
    AMTRACE((TEXT("CVMRFilter::GetRenderingPrefs")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    if ( ISBADWRITEPTR(pdwRenderingPrefs) )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Bad pointer") ));
        return E_POINTER;
    }

    HRESULT hr = VFW_E_WRONG_STATE;
    if (m_pPresenterConfig) {
        hr = m_pPresenterConfig->GetRenderingPrefs(pdwRenderingPrefs);
        if (SUCCEEDED(hr)) {
            *pdwRenderingPrefs |= m_dwRenderPrefs;
        }
    }

    return hr;
}

/******************************Public*Routine******************************\
* SetRenderingMode
*
*
*
* History:
* Tue 04/25/2000 - GlennE - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::SetRenderingMode(
    DWORD RenderingMode
    )
{
    AMTRACE((TEXT("CVMRFilter::SetRenderingMode")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);
    HRESULT hr = VFW_E_WRONG_STATE;

    if ( ( 0 == RenderingMode ) ||
         ( RenderingMode & ~(VMRMode_Mask) ) ||
         ( RenderingMode & (RenderingMode-1) ) )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid rendering mode") ));
        return E_INVALIDARG;
    }

    //
    // This is the only place where "pass thru" mode can be switched on
    //
    if (ModeChangeAllowed()) {

        SetVMRMode(RenderingMode);

        hr = S_OK;
        if ((RenderingMode & VMRMode_Windowless) || (RenderingMode & VMRMode_Windowed)) {
            hr = ValidateIVRWindowlessControlState();
        }

    }

    return hr;
}

/******************************Public*Routine******************************\
* GetRenderingMode
*
*
*
* History:
* Tue 04/25/2000 - GlennE - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::GetRenderingMode(
    DWORD* pRenderingMode
    )
{
    AMTRACE((TEXT("CVMRFilter::GetRenderingMode")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);
    HRESULT hr = S_OK;

    if ( ISBADWRITEPTR(pRenderingMode) )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Bad pointer") ));
        return E_POINTER;
    }

    *pRenderingMode = m_VMRMode;
    return hr;
}

/******************************Public*Routine******************************\
* GetAspectRatioModePrivate
*
*
* Called by VMRConfigInternal - no longer used
*
* History:
* Fri 01/05/2001 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::GetAspectRatioModePrivate(
    DWORD* lpAspectRatioMode
    )
{
    AMTRACE((TEXT("CVMRFilter::GetAspectRatioModePrivate")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);
    HRESULT hr = S_OK;

    if ( ISBADWRITEPTR(lpAspectRatioMode) )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Bad pointer") ));
        return E_POINTER;
    }

    if (m_lpWLControl) {

        hr = m_lpWLControl->GetAspectRatioMode(lpAspectRatioMode);
    }
    else {
        *lpAspectRatioMode = m_ARMode;
    }
    return hr;
}


/******************************Public*Routine******************************\
* SetAspectRatioModePrivate
*
*
* Called by VMRConfigInternal - no longer used
*
* History:
* Fri 01/05/2001 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::SetAspectRatioModePrivate(
    DWORD AspectRatioMode
    )
{
    AMTRACE((TEXT("CVMRFilter::SetAspectRatioModePrivate")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);
    HRESULT hr = S_OK;

    if (AspectRatioMode != VMR_ARMODE_NONE &&
        AspectRatioMode != VMR_ARMODE_LETTER_BOX) {

        return E_INVALIDARG;
    }

    if (m_lpWLControl) {

        hr = m_lpWLControl->SetAspectRatioMode(AspectRatioMode);
    }
    else {
        m_ARMode = AspectRatioMode;
    }

    return hr;
}

/******************************Public*Routine******************************\
* SetMonitor
*
*
*
* History:
* Tue 04/25/2000 - GlennE - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::SetMonitor(
    const VMRGUID *pGUID
    )
{
    AMTRACE((TEXT("CVMRFilter::SetMonitor")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    HRESULT hr = VFW_E_WRONG_STATE;
    if (m_pPresenterMonitorConfig) {
        hr = m_pPresenterMonitorConfig->SetMonitor( pGUID );
    }
    return hr;
}

/******************************Public*Routine******************************\
* GetMonitor
*
*
*
* History:
* Tue 04/25/2000 - GlennE - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::GetMonitor(
    VMRGUID *pGUID
    )
{
    AMTRACE((TEXT("CVMRFilter::GetMonitor")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    if ( ISBADWRITEPTR(pGUID) )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Bad pointer") ));
        return E_POINTER;
    }

    HRESULT hr = VFW_E_WRONG_STATE;
    if (m_pPresenterMonitorConfig) {
        hr = m_pPresenterMonitorConfig->GetMonitor( pGUID );
    }
    return hr;
}

/******************************Public*Routine******************************\
* SetDefaultMonitor
*
*
*
* History:
* Tue 04/25/2000 - GlennE - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::SetDefaultMonitor(
    const VMRGUID *pGUID
    )
{
    AMTRACE((TEXT("CVMRFilter::SetDefaultMonitor")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    if ( ISBADREADPTR(pGUID) )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Bad pointer") ));
        return E_POINTER;
    }

    HRESULT hr = VFW_E_WRONG_STATE;
    if (m_pPresenterMonitorConfig) {
        hr = m_pPresenterMonitorConfig->SetDefaultMonitor( pGUID );
    }
    return hr;
}

/******************************Public*Routine******************************\
* GetDefaultMonitor
*
*
*
* History:
* Tue 04/25/2000 - GlennE - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::GetDefaultMonitor(
    VMRGUID *pGUID
    )
{
    AMTRACE((TEXT("CVMRFilter::GetDefaultMonitor")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    if ( ISBADWRITEPTR(pGUID) )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Bad pointer") ));
        return E_POINTER;
    }

    HRESULT hr = VFW_E_WRONG_STATE;
    if (m_pPresenterMonitorConfig) {
        hr = m_pPresenterMonitorConfig->GetDefaultMonitor( pGUID );
    }
    return hr;
}

/******************************Public*Routine******************************\
* GetAvailableMonitors
*
*
*
* History:
* Tue 04/25/2000 - GlennE - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::GetAvailableMonitors(
    VMRMONITORINFO* pInfo,
    DWORD dwMaxInfoArraySize,
    DWORD* pdwNumDevices
    )
{
    AMTRACE((TEXT("CVMRFilter::GetAvailableMonitors")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    if ( ISBADWRITEPTR(pdwNumDevices) ||
         ( (NULL != pInfo) && ISBADWRITEARRAY(pInfo,dwMaxInfoArraySize)))
    {
        DbgLog((LOG_ERROR, 1, TEXT("Bad pointer") ));
        return E_POINTER;
    }

    HRESULT hr = VFW_E_WRONG_STATE;
    if (m_pPresenterMonitorConfig) {
        hr = m_pPresenterMonitorConfig->GetAvailableMonitors(pInfo,
                                                             dwMaxInfoArraySize,
                                                             pdwNumDevices);
    }
    return hr;
}

/******************************Public*Routine******************************\
* SetAlphaBitmap
*
*
*
* History:
* Mon 05/15/2000 - nwilt - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::SetAlphaBitmap( const VMRALPHABITMAP *pBmpParms )
{
    AMTRACE((TEXT("CVMRFilter::SetAlphaBitmap")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    HRESULT hr = VFW_E_WRONG_STATE;

    if ( ISBADREADPTR( pBmpParms ) )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Bad pointer") ));
        return E_POINTER;
    }

    if (m_lpMixBitmap) {
        hr =  m_lpMixBitmap->SetAlphaBitmap( pBmpParms );
    }
    return hr;
}

/******************************Public*Routine******************************\
* UpdateAlphaBitmapParameters
*
*
*
* History:
* Mon 10/31/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::UpdateAlphaBitmapParameters( VMRALPHABITMAP *pBmpParms )
{
    AMTRACE((TEXT("CVMRFilter::UpdateAlphaBitmap")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    HRESULT hr = VFW_E_WRONG_STATE;

    if ( ISBADWRITEPTR( pBmpParms ) )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Bad pointer") ));
        return E_POINTER;
    }

    if (m_lpMixBitmap) {
        hr = m_lpMixBitmap->UpdateAlphaBitmapParameters( pBmpParms );
    }

    return hr;
}


/******************************Public*Routine******************************\
* GetAlphaBitmapParameters
*
*
*
* History:
* Mon 05/15/2000 - nwilt - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::GetAlphaBitmapParameters( VMRALPHABITMAP *pBmpParms )
{
    AMTRACE((TEXT("CVMRFilter::GetAlphaBitmap")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    HRESULT hr = VFW_E_WRONG_STATE;

    if ( ISBADWRITEPTR( pBmpParms ) )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Bad pointer") ));
        return E_POINTER;
    }

    if (m_lpMixBitmap) {
        hr = m_lpMixBitmap->GetAlphaBitmapParameters( pBmpParms );
    }

    return hr;
}

/******************************Public*Routine******************************\
* get_FramesDroppedInRenderer
*
*
*
* History:
* Mon 05/22/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::get_FramesDroppedInRenderer(
    int *cFramesDropped
    )
{
    AMTRACE((TEXT("CVMRFilter::get_FramesDroppedInRenderer")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);
    HRESULT hr = E_NOTIMPL;

    if (m_lpISQualProp) {
        hr = m_lpISQualProp->get_FramesDroppedInRenderer(cFramesDropped);
    }

    return hr;
}

/******************************Public*Routine******************************\
* get_FramesDrawn
*
*
*
* History:
* Mon 05/22/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::get_FramesDrawn(
    int *pcFramesDrawn
    )
{
    AMTRACE((TEXT("CVMRFilter::get_FramesDrawn")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);
    HRESULT hr = E_NOTIMPL;

    if (m_lpISQualProp) {
        hr = m_lpISQualProp->get_FramesDrawn(pcFramesDrawn);
    }
    return hr;
}

/******************************Public*Routine******************************\
* get_AvgFrameRate
*
*
*
* History:
* Mon 05/22/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::get_AvgFrameRate(
    int *piAvgFrameRate
    )
{
    AMTRACE((TEXT("CVMRFilter::get_AvgFrameRate")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);
    HRESULT hr = E_NOTIMPL;

    if (m_lpISQualProp) {
        hr = m_lpISQualProp->get_AvgFrameRate(piAvgFrameRate);
    }

    return hr;
}

/******************************Public*Routine******************************\
* get_Jitter
*
*
*
* History:
* Mon 05/22/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::get_Jitter(
    int *piJitter
    )
{
    AMTRACE((TEXT("CVMRFilter::get_Jitter")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);
    HRESULT hr = E_NOTIMPL;

    if (m_lpISQualProp) {
        hr = m_lpISQualProp->get_Jitter(piJitter);
    }

    return hr;
}

/******************************Public*Routine******************************\
* get_AvgSyncOffset
*
*
*
* History:
* Mon 05/22/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::get_AvgSyncOffset(
    int *piAvg
    )
{
    AMTRACE((TEXT("CVMRFilter::get_AvgSyncOffset")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);
    HRESULT hr = E_NOTIMPL;

    if (m_lpISQualProp) {
        hr = m_lpISQualProp->get_AvgSyncOffset(piAvg);
    }

    return hr;
}

/******************************Public*Routine******************************\
* get_DevSyncOffset
*
*
*
* History:
* Mon 05/22/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::get_DevSyncOffset(
    int *piDev
    )
{
    AMTRACE((TEXT("CVMRFilter::get_DevSyncOffset")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);
    HRESULT hr = E_NOTIMPL;

    if (m_lpISQualProp) {
        hr = m_lpISQualProp->get_DevSyncOffset(piDev);
    }

    return hr;
}

/******************************Public*Routine******************************\
* SetSink
*
*
*
* History:
* Mon 05/22/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::SetSink(
    IQualityControl * piqc
    )
{
    AMTRACE((TEXT("CVMRFilter::SetSink")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);
    HRESULT hr = E_NOTIMPL;

    return hr;
}

/******************************Public*Routine******************************\
* Notify
*
*
*
* History:
* Mon 05/22/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::Notify(
    IBaseFilter * pSelf,
    Quality q
    )
{
    AMTRACE((TEXT("CVMRFilter::Notify")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);
    HRESULT hr = E_NOTIMPL;

    return hr;
}

/******************************Public*Routine******************************\
* JoinFilterGraph
*
*
* Override JoinFilterGraph so that, just before leaving
* the graph we can send an EC_WINDOW_DESTROYED event
*
* History:
* Mon 11/06/2000 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::JoinFilterGraph(
    IFilterGraph *pGraph,
    LPCWSTR pName
    )
{
    AMTRACE((TEXT("CVMRFilter::JoinFilterGraph")));

    if (m_VMRMode == VMRMode_Windowed && m_pVideoWindow) {

        // Since we send EC_ACTIVATE, we also need to ensure
        // we send EC_WINDOW_DESTROYED or the resource manager may be
        // holding us as a focus object

        if (!pGraph && m_pGraph) {

            // We were in a graph and now we're not
            // Do this properly in case we are aggregated
            IBaseFilter* pFilter;
            QueryInterface(IID_IBaseFilter,(void **) &pFilter);
            NotifyEvent(EC_WINDOW_DESTROYED, (LPARAM) pFilter, 0);
            pFilter->Release();
        }
    }

    return CBaseFilter::JoinFilterGraph(pGraph, pName);
}

/******************************Public*Routine******************************\
* GetPages
*
*
* Implement ISpecifyPropertyPages interface.
* Returns GUIDs of all supported property pages.
*
* History:
* 3/23/2001 - StRowe - Created
*
\**************************************************************************/
STDMETHODIMP CVMRFilter::GetPages(CAUUID *pPages)
{
    AMTRACE((TEXT("CVMRFilter::GetPages")));

    pPages->cElems = 3;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID)*(pPages->cElems));
    if (pPages->pElems == NULL)
    {
        return E_OUTOFMEMORY;
    }

    pPages->pElems[0] = CLSID_VMRFilterConfigProp;
    pPages->pElems[1] = CLSID_COMQualityProperties;
    pPages->pElems[2] = CLSID_VMRDeinterlaceProp;
    return NOERROR;
}


// CPersistStream
/******************************Public*Routine******************************\
* WriteToStream
*
*
*
* History:
* Fri 03/23/2001 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::WriteToStream(
    IStream *pStream
    )
{
    AMTRACE((TEXT("CVMRFilter::WriteToStream")));
    VMRFilterInfo vmrInfo;

    ZeroMemory(&vmrInfo, sizeof(vmrInfo));
    vmrInfo.dwSize = sizeof(vmrInfo);

    //
    // Only write mixer info if we actually have a mixer !!
    //

    if (m_lpMixControl) {

        vmrInfo.dwNumPins = m_dwNumPins;
        for (DWORD i = 0; i < m_dwNumPins; i++) {

            GetAlpha(i, &vmrInfo.StreamInfo[i].alpha);
            GetZOrder(i, &vmrInfo.StreamInfo[i].zOrder);
            GetOutputRect(i, &vmrInfo.StreamInfo[i].rect);
        }
    }

    return pStream->Write(&vmrInfo, sizeof(vmrInfo), 0);
}

/******************************Public*Routine******************************\
* ReadFromStream
*
*
*
* History:
* Fri 03/23/2001 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::ReadFromStream(
    IStream *pStream
    )
{
    AMTRACE((TEXT("CVMRFilter::ReadFromStream")));
    VMRFilterInfo vmrInfo;
    HRESULT hr = S_OK;

    hr = pStream->Read(&vmrInfo, sizeof(vmrInfo), 0);
    if (FAILED(hr)) {
        return hr;
    }

    if (vmrInfo.dwSize != sizeof(vmrInfo)) {
        return VFW_E_INVALID_FILE_VERSION;
    }

    //
    // zero pins means we are in "pass-thru" mode, so we
    // don't have to restore any more info.
    //

    if (vmrInfo.dwNumPins > 0) {

        hr = SetNumberOfStreams(vmrInfo.dwNumPins);
        if (FAILED(hr)) {
            return hr;
        }

        for (DWORD i = 0; i < vmrInfo.dwNumPins; i++) {

            SetAlpha(i, vmrInfo.StreamInfo[i].alpha);
            SetZOrder(i, vmrInfo.StreamInfo[i].zOrder);
            SetOutputRect(i, &vmrInfo.StreamInfo[i].rect);
        }
    }

    return S_OK;
}


/******************************Public*Routine******************************\
* SizeMax
*
*
*
* History:
* Fri 03/23/2001 - StEstrop - Created
*
\**************************************************************************/
int
CVMRFilter::SizeMax()
{
    AMTRACE((TEXT("CVMRFilter::SizeMax")));
    return sizeof(VMRFilterInfo);
}


/******************************Public*Routine******************************\
* GetClassID
*
*
*
* History:
* Fri 03/23/2001 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::GetClassID(
    CLSID *pClsid
    )
{
    AMTRACE((TEXT("CVMRFilter::GetClassID")));
    return CBaseFilter::GetClassID(pClsid);
}


/******************************Public*Routine******************************\
* CompleteConnect(dwPinID)
*
*
* Notes:
*  Called by the VMR pin on connect.  We use this to override the aspect ratio
*  mode.
*
* History:
* Fri 07/12/2001 - GlennE - Created
*
\**************************************************************************/
HRESULT
CVMRFilter::CompleteConnect(
    DWORD dwPinId,
    const CMediaType& cmt
    )
{
    AMTRACE((TEXT("CVMRFilter::CompleteConnect")));


    if (NumInputPinsConnected() == 1 || dwPinId == 0) {

        //
        // set the default ASPECT ratio mode based on the input type
        //

        if (!m_bARModeDefaultSet) {

            if (cmt.FormatType() && *cmt.FormatType() == FORMAT_VideoInfo2) {

                //
                // Look for the presence of a VideoInfo format type.
                // If we find the upstream filter can propose these types
                // we don't set the aspect ratio mode becuase this filter
                // would have connected to the old renderer not the OVMixer
                // The old renderer didn't perform any aspect ratio correction
                // so we had better not too.
                //

                IPin* pReceivePin = m_pInputPins[dwPinId]->m_Connected;
                IEnumMediaTypes *pEnumMediaTypes = NULL;
                BOOL fVideoInfoAvail = FALSE;

                HRESULT hr = pReceivePin->EnumMediaTypes(&pEnumMediaTypes);
                if (FAILED(hr)) {
                    return hr;
                }

                do {

                    AM_MEDIA_TYPE* pEnumMT;
                    ULONG ulFetched;

                    hr = pEnumMediaTypes->Next(1, &pEnumMT, &ulFetched);
                    if (FAILED(hr) || ulFetched != 1) {
                        break;
                    }

                    fVideoInfoAvail = (pEnumMT->formattype == FORMAT_VideoInfo);
                    DeleteMediaType(pEnumMT);

                } while (!fVideoInfoAvail);

                pEnumMediaTypes->Release();

                if (FAILED(hr)) {
                    return hr;
                }

                if (fVideoInfoAvail) {
                    return S_OK;
                }

                //
                // reset state if set (we don't want to force Windowless
                // unless the app has set it (e.g. auto render won't set the
                // state until we play)
                //
                hr = S_OK;
                if (m_lpWLControl) {

                    hr = ValidateIVRWindowlessControlState();
                    if (SUCCEEDED(hr)) {
                        hr = m_lpWLControl->SetAspectRatioMode(VMR_ARMODE_LETTER_BOX);
                    }
                }

                //
                // if there is no lpWLControl, we set it next time
                // ValidateIVRWindowlessControlState is called
                //
                if (SUCCEEDED(hr)) {
                    m_ARMode = VMR_ARMODE_LETTER_BOX;
                }
            }
        }
    }

    return S_OK;
}


/******************************Private*Routine******************************\
* NumInputPinsConnected
*
*
* History:
* Fri 07/12/2001 - GlennE - Created
*
\**************************************************************************/
int CVMRFilter::NumInputPinsConnected() const
{
    AMTRACE((TEXT("CVMRFilter::NumInputPinsConnected")));
    int iCount = 0;
    for (DWORD i = 0; i < m_dwNumPins; i++) {
        if (m_pInputPins[i]->m_Connected) {
            iCount++;
        }
    }
    return iCount;
}



// IVMRDeinterlaceControl

/*****************************Private*Routine******************************\
* VMRVideoDesc2DXVA_VideoDesc
*
*
*
* History:
* Thu 04/25/2002 - StEstrop - Created
*
\**************************************************************************/
void
VMRVideoDesc2DXVA_VideoDesc(
    DXVA_VideoDesc* lpDXVAVideoDesc,
    const VMRVideoDesc* lpVMRVideoDesc
    )
{
    AMTRACE((TEXT("CVMRFilter::VMRVideoDesc2DXVA_VideoDesc")));

    lpDXVAVideoDesc->Size = sizeof(DXVA_VideoDesc);
    lpDXVAVideoDesc->SampleWidth = lpVMRVideoDesc->dwSampleWidth;
    lpDXVAVideoDesc->SampleHeight = lpVMRVideoDesc->dwSampleHeight;
    if (lpVMRVideoDesc->SingleFieldPerSample) {
        lpDXVAVideoDesc->SampleFormat = DXVA_SampleFieldSingleEven;
    }
    else {
        lpDXVAVideoDesc->SampleFormat = DXVA_SampleFieldInterleavedEvenFirst;
    }
    lpDXVAVideoDesc->d3dFormat = lpVMRVideoDesc->dwFourCC;
    lpDXVAVideoDesc->InputSampleFreq.Numerator   = lpVMRVideoDesc->InputSampleFreq.dwNumerator;
    lpDXVAVideoDesc->InputSampleFreq.Denominator = lpVMRVideoDesc->InputSampleFreq.dwDenominator;
    lpDXVAVideoDesc->OutputFrameFreq.Numerator   = lpVMRVideoDesc->OutputFrameFreq.dwNumerator;
    lpDXVAVideoDesc->OutputFrameFreq.Denominator = lpVMRVideoDesc->OutputFrameFreq.dwDenominator;
}


/******************************Public*Routine******************************\
* GetNumberOfDeinterlaceModes
*
*
*
* History:
* Mon 04/22/2002 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::GetNumberOfDeinterlaceModes(
    VMRVideoDesc* lpVideoDesc,
    LPDWORD lpdwNumDeinterlaceModes,
    LPGUID lpDeinterlaceModes
    )
{
    AMTRACE((TEXT("CVMRFilter::GetNumberOfDeinterlaceModes")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    if (ISBADREADPTR(lpVideoDesc)) {
        return E_POINTER;
    }

    if (ISBADWRITEPTR(lpdwNumDeinterlaceModes)) {
        return E_POINTER;
    }

    if (!m_lpMixStream) {
        return VFW_E_VMR_NOT_IN_MIXER_MODE;
    }

    if (!m_pDeinterlace) {
        return VFW_E_DDRAW_CAPS_NOT_SUITABLE;
    }


    DWORD dwNumModes = MAX_DEINTERLACE_DEVICE_GUIDS;
    GUID Modes[MAX_DEINTERLACE_DEVICE_GUIDS];
    DXVA_VideoDesc VideoDesc;
    VMRVideoDesc2DXVA_VideoDesc(&VideoDesc, lpVideoDesc);

    HRESULT hr = m_pDeinterlace->QueryAvailableModes(&VideoDesc, &dwNumModes,
                                                     Modes);
    if (hr == S_OK) {

        if (lpDeinterlaceModes != NULL) {
            dwNumModes = min(*lpdwNumDeinterlaceModes, dwNumModes);
            CopyMemory(lpDeinterlaceModes, Modes, dwNumModes * sizeof(GUID));
        }
    }

    *lpdwNumDeinterlaceModes = dwNumModes;

    return hr;
}

/******************************Public*Routine******************************\
* GetDeinterlaceModeCaps
*
*
*
* History:
* Mon 04/22/2002 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::GetDeinterlaceModeCaps(
    LPGUID lpDeinterlaceMode,
    VMRVideoDesc* lpVideoDesc,
    VMRDeinterlaceCaps* lpDeinterlaceCaps
    )
{
    AMTRACE((TEXT("CVMRFilter::GetDeinterlaceModeCaps")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    if (ISBADREADPTR(lpDeinterlaceMode)) {
        return E_POINTER;
    }

    if (ISBADREADPTR(lpVideoDesc)) {
        return E_POINTER;
    }

    if (ISBADWRITEPTR(lpDeinterlaceCaps)) {
        return E_POINTER;
    }

    if (!m_lpMixStream) {
        return VFW_E_VMR_NOT_IN_MIXER_MODE;
    }

    if (!m_pDeinterlace) {
        return VFW_E_DDRAW_CAPS_NOT_SUITABLE;
    }

    DXVA_VideoDesc VideoDesc;
    VMRVideoDesc2DXVA_VideoDesc(&VideoDesc, lpVideoDesc);
    DXVA_DeinterlaceCaps DeinterlaceCaps;

    HRESULT hr = m_pDeinterlace->QueryModeCaps(lpDeinterlaceMode,
                                               &VideoDesc, &DeinterlaceCaps);
    if (hr == S_OK) {

        lpDeinterlaceCaps->dwNumPreviousOutputFrames =
            DeinterlaceCaps.NumPreviousOutputFrames;

        lpDeinterlaceCaps->dwNumForwardRefSamples =
            DeinterlaceCaps.NumForwardRefSamples;

        lpDeinterlaceCaps->dwNumBackwardRefSamples =
            DeinterlaceCaps.NumBackwardRefSamples;

        lpDeinterlaceCaps->DeinterlaceTechnology =
            (VMRDeinterlaceTech)DeinterlaceCaps.DeinterlaceTechnology;
    }

    return hr;
}


/******************************Public*Routine******************************\
* GetActualDeinterlaceMode
*
*
*
* History:
* Mon 04/22/2002 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::GetActualDeinterlaceMode(
    DWORD dwStreamID,
    LPGUID lpDeinterlaceMode
    )
{
    AMTRACE((TEXT("CVMRFilter::GetActualDeinterlaceMode")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    if (ISBADWRITEPTR(lpDeinterlaceMode)) {
        return E_POINTER;
    }

    if (dwStreamID > m_dwNumPins) {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid stream ID")));
        return E_INVALIDARG;
    }

    if (!m_lpMixStream) {
        return VFW_E_VMR_NOT_IN_MIXER_MODE;
    }

    *lpDeinterlaceMode = m_pInputPins[dwStreamID]->m_DeinterlaceGUID;

    return S_OK;
}

/******************************Public*Routine******************************\
* GetDeinterlaceMode
*
*
*
* History:
* Mon 04/22/2002 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::GetDeinterlaceMode(
    DWORD dwStreamID,
    LPGUID lpDeinterlaceMode
    )
{
    AMTRACE((TEXT("CVMRFilter::GetDeinterlaceMode")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    if (ISBADWRITEPTR(lpDeinterlaceMode)) {
        return E_POINTER;
    }

    if (dwStreamID > m_dwNumPins) {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid stream ID")));
        return E_INVALIDARG;
    }

    if (!m_lpMixStream) {
        return VFW_E_VMR_NOT_IN_MIXER_MODE;
    }

    HRESULT hr = S_OK;
    if (m_pInputPins[dwStreamID]->m_DeinterlaceUserGUIDSet) {
        *lpDeinterlaceMode = m_pInputPins[dwStreamID]->m_DeinterlaceUserGUID;
    }
    else {
        *lpDeinterlaceMode = GUID_NULL;
        hr = S_FALSE;
    }

    return hr;
}

/******************************Public*Routine******************************\
* SetDeinterlaceMode
*
*
*
* History:
* Mon 04/22/2002 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::SetDeinterlaceMode(
    DWORD dwStreamID,
    LPGUID lpDeinterlaceMode
    )
{
    AMTRACE((TEXT("CVMRFilter::SetDeinterlaceMode")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    if (ISBADREADPTR(lpDeinterlaceMode)) {
        return E_POINTER;
    }

    if (dwStreamID > m_dwNumPins) {
        if (dwStreamID != 0xFFFFFFFF) {
            DbgLog((LOG_ERROR, 1, TEXT("Invalid stream ID")));
            return E_INVALIDARG;
        }
    }

    if (!m_lpMixStream) {
        return VFW_E_VMR_NOT_IN_MIXER_MODE;
    }

    if (dwStreamID == 0xFFFFFFFF) {
        for (DWORD i = 0; i < m_dwNumPins; i++) {
            m_pInputPins[i]->m_DeinterlaceUserGUIDSet = TRUE;
            m_pInputPins[i]->m_DeinterlaceUserGUID = *lpDeinterlaceMode;
        }
    }
    else {
        m_pInputPins[dwStreamID]->m_DeinterlaceUserGUIDSet = TRUE;
        m_pInputPins[dwStreamID]->m_DeinterlaceUserGUID = *lpDeinterlaceMode;
    }

    return S_OK;
}


/******************************Public*Routine******************************\
* GetDeinterlacePrefs
*
*
*
* History:
* Mon 04/22/2002 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::GetDeinterlacePrefs(
    LPDWORD lpdwDeinterlacePrefs
    )
{
    AMTRACE((TEXT("CVMRFilter::GetDeinterlacePrefs")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    if (ISBADWRITEPTR(lpdwDeinterlacePrefs)) {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid pointer passed to GetDeinterlacePrefs")));
        return E_POINTER;
    }

    if (!m_lpMixStream) {
        return VFW_E_VMR_NOT_IN_MIXER_MODE;
    }

    *lpdwDeinterlacePrefs = m_dwDeinterlacePrefs;

    return S_OK;
}


/******************************Public*Routine******************************\
* SetDeinterlacePrefs
*
*
*
* History:
* Mon 04/22/2002 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVMRFilter::SetDeinterlacePrefs(
    DWORD dwDeinterlacePrefs
    )
{
    AMTRACE((TEXT("CVMRFilter::SetDeinterlacePrefs")));
    CAutoLock cInterfaceLock(&m_InterfaceLock);

    if (dwDeinterlacePrefs == 0 || (dwDeinterlacePrefs & ~DeinterlacePref_Mask)) {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid deinterlace pref specified")));
        return E_INVALIDARG;
    }

    if (!m_lpMixStream) {
        return VFW_E_VMR_NOT_IN_MIXER_MODE;
    }

    HRESULT hr = S_OK;
    switch (dwDeinterlacePrefs) {
    case DeinterlacePref_NextBest:
    case DeinterlacePref_BOB:
    case DeinterlacePref_Weave:
        m_dwDeinterlacePrefs = dwDeinterlacePrefs;
        break;

    default:
        hr = E_INVALIDARG;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vmrplyer\app.h ===
/******************************Module*Header*******************************\
* Module Name: app.h
*
* Function prototype for the Video CD Player application.
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/




/* -------------------------------------------------------------------------
** Functions prototypes
** -------------------------------------------------------------------------
*/
int
DoMainLoop(
    void
    );

BOOL
InitApplication(
    HINSTANCE hInstance
    );

BOOL
InitInstance(
    HINSTANCE hInstance,
    int nCmdShow
    );

BOOL
LoadWindowPos(
    LPRECT lprc
    );

BOOL
SaveWindowPos(
    HWND hwnd
    );

void
PatB(
    HDC hdc,
    int x,
    int y,
    int dx,
    int dy,
    DWORD rgb
    );

void
UpdateMpegMovieRect(
    void
    );

void
GetAdjustedClientRect(
    RECT *prc
    );

BOOL
DrawStats(
    HDC hdc
    );

void
CalcMovieRect(
    LPRECT lprc
    );

LPCTSTR
IdStr(
    int idResource
    );

void
UpdateSystemColors(
    void
    );

#if 0
void
DrawShadowRect(
    HDC hdc,
    LPRECT lprc
    );
#endif

void
SetDurationLength(
    REFTIME rt
    );

void
SetCurrentPosition(
    REFTIME rt
    );

TCHAR *
FormatRefTime(
    TCHAR *sz,
    REFTIME rt
    );

void
DoMpegVideoPropertyPage();

void
DoMpegAudioPropertyPage();

/* -------------------------------------------------------------------------
** Registry stuff
** -------------------------------------------------------------------------
*/
int
ProfileIntIn(
   const TCHAR *szKey,
   int iDefault
   );

BOOL
ProfileIntOut(
   const TCHAR *szKey,
   int iDefault
   );

void
ProfileStringOut (
    LPTSTR  szKey,
    LPTSTR  sz
    );

UINT
ProfileStringIn (
    LPTSTR  szKey,
    LPTSTR  szDef,
    LPTSTR  sz,
    DWORD   cb
    );

BOOL
LoadWindowPos(
    LPRECT lprc
    );

BOOL
SaveWindowPos(
    HWND hwnd
    );

HKEY
GetAppKey(
    BOOL fCreate
    );


/* -------------------------------------------------------------------------
** Message crackers
** -------------------------------------------------------------------------
*/
/* void Cls_OnUser(HWND hwnd, WPARAM wParam, LPARAM lParam ) */
#define HANDLE_WM_USER(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd, wParam, lParam), 0L)

/* LRESULT Cls_OnNotify(HWND hwnd, int idFrom, NMHDR FAR* pnmhdr); */
#ifndef HANDLE_WM_NOTIFY
#define HANDLE_WM_NOTIFY(hwnd, wParam, lParam, fn) \
    (fn)((hwnd), (int)(wParam), (NMHDR FAR*)(lParam))
#endif



/* -------------------------------------------------------------------------
** VideoCd window class prototypes
** -------------------------------------------------------------------------
*/
extern "C" LRESULT CALLBACK
VideoCdWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

void
VideoCd_OnClose(
    HWND hwnd
    );

BOOL
VideoCd_OnQueryEndSession(
    HWND hwnd
    );

void
VideoCd_OnDestroy(
    HWND hwnd
    );

void
VideoCd_OnCommand(
    HWND hwnd,
    int id,
    HWND hwndCtl,
    UINT codeNotify
    );

void
VideoCd_OnPaint(
    HWND hwnd
    );

void
VideoCd_OnTimer(
    HWND hwnd,
    UINT id
    );

BOOL
VideoCd_OnCreate(
    HWND hwnd,
    LPCREATESTRUCT lpCreateStruct
    );

void
VideoCd_OnSize(
    HWND hwnd,
    UINT state,
    int cx,
    int cy
    );

void
VideoCd_OnKeyUp(
    HWND hwnd,
    UINT vk,
    BOOL fDown,
    int cRepeat,
    UINT flags
    );

void
VideoCd_OnActivate(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    );

void
VideoCd_OnHScroll(
    HWND hwnd,
    HWND hwndCtl,
    UINT code,
    int pos
    );

void
VideoCd_OnUser(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    );

void
VideoCd_OnSysColorChange(
    HWND hwnd
    );

void
VideoCd_OnMenuSelect(
    HWND hwnd,
    HMENU hmenu,
    int item,
    HMENU hmenuPopup,
    UINT flags
    );

void
VideoCd_OnInitMenuPopup(
    HWND hwnd,
    HMENU hMenu,
    UINT item,
    BOOL fSystemMenu
    );

#ifdef WM_NOTIFY
LRESULT
VideoCd_OnNotify(
    HWND hwnd,
    int idFrom,
    NMHDR FAR* pnmhdr
    );
#endif


void
VideoCd_OnGraphNotify(
    void
    );

void
VideoCd_OnDropFiles(
    HWND hwnd,
    HDROP hdrop);

void
SetPlayButtonsEnableState(
    void
    );



/* -------------------------------------------------------------------------
** Command processing functions
** -------------------------------------------------------------------------
*/

BOOL
VcdPlyerCaptureImage(
    LPCSTR szFile
    );

BOOL
VcdPlayerSetLog(
    void
    );

BOOL
VcdPlayerSetPerfLogFile(
    void
    );

BOOL
VcdPlayerOpenCmd(
    int i
    );

BOOL
VcdPlayerCloseCmd(
    void
    );

BOOL
VcdPlayerPlayCmd(
    void
    );

BOOL
VcdPlayerStopCmd(
    void
    );

BOOL
VcdPlayerPauseCmd(
    void
    );

BOOL
VcdPlayerPauseCmd(
    void
    );

BOOL
VcdPlayerStepCmd(
    void
    );

void
VcdPlayerSeekCmd(
    REFTIME rtSeekBy
    );

void
ProcessOpen(
    TCHAR *achFileName,
    BOOL bPlay = FALSE
    );

int
VcdPlayerChangeTimeFormat(
    int id
    );


/* -------------------------------------------------------------------------
** Recent filename stuff
** -------------------------------------------------------------------------
*/
typedef TCHAR RECENTFILES[MAX_PATH];
#define MAX_RECENT_FILES    5
#define ID_RECENT_FILE_BASE 500

int
GetRecentFiles(
    int LastCount
    );

int
SetRecentFiles(
    TCHAR *FileName,
    int iCount
    );


/* -------------------------------------------------------------------------
** Global Variables
** -------------------------------------------------------------------------
*/
extern int              cxMovie;
extern int              cyMovie;
extern HWND             hwndApp;
extern HWND             g_hwndStatusbar;

extern int              cx;
extern int              cy;
extern int              xOffset;
extern int              yOffset;
extern TCHAR            g_achFileName[];
extern OPENFILENAME     ofn;
extern DWORD            g_State;
extern HANDLE           hRenderLog;
extern int              nRecentFiles;
extern LONG             lMovieOrgX, lMovieOrgY;
extern TCHAR            g_szPerfLog[];
extern int              g_TimeFormat;
extern BOOL             g_bUseThreadedGraph;




/* -------------------------------------------------------------------------
** Constants
** -------------------------------------------------------------------------
*/
#define LEFT_MARGIN 0



/* -------------------------------------------------------------------------
** Video CD Player states
**
**  These are bit flags
** -------------------------------------------------------------------------
*/

#define VCD_PLAYING          0x0001
#define VCD_STOPPED          0x0002
#define VCD_PAUSED           0x0004
#define VCD_SKIP_F           0x0008
#define VCD_SKIP_B           0x0010
#define VCD_FF               0x0020
#define VCD_RW               0x0040
#define VCD_SEEKING          (VCD_FF | VCD_RW)
#define VCD_LOADED           0x0080
#define VCD_NO_CD            0x0100
#define VCD_DATA_CD_LOADED   0x0200
#define VCD_EDITING          0x0400
#define VCD_PAUSED_AND_MOVED 0x0800
#define VCD_PLAY_PENDING     0x1000
#define VCD_WAS_PLAYING      0x2000
#define VCD_IN_USE           0x4000
#define VCD_STEPPING         0x8000

enum {PerformanceTimer = 32, StatusTimer = 33};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vmrplyer\app.cpp ===
/******************************Module*Header*******************************\
* Module Name: app.cpp
*
* A simple Video CD player
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/
#include <streams.h>
#include <atlbase.h>
#include <atlconv.cpp>
#include <mmreg.h>
#include <commctrl.h>

#include "project.h"
#include <initguid.h>
//#include "mpgcodec.h"

#include <stdarg.h>
#include <stdio.h>

/* -------------------------------------------------------------------------
** Global variables that are initialized at run time and then stay constant.
** -------------------------------------------------------------------------
*/
HINSTANCE           hInst;
HICON               hIconVideoCd;
HWND                hwndApp;
HWND                g_hwndToolbar;
HWND                g_hwndStatusbar;
HWND                g_hwndTrackbar;
CMpegMovie          *pMpegMovie;
double              g_TrackBarScale = 1.0;
BOOL                g_bUseThreadedGraph;
BOOL                g_bPlay = FALSE;

int                 dyToolbar, dyStatusbar, dyTrackbar;

MSR_DUMPPROC        *lpDumpProc;
MSR_CONTROLPROC     *lpControlProc;
HINSTANCE           hInstMeasure;

int                 FrameStepCount;


BOOL                g_fEnableAppImage;

FLOAT               g_xPos = 0.25F, g_yPos = 0.25F;
FLOAT               g_xSize = 0.5F, g_ySize = 0.5F;
FLOAT               g_Alpha = 0.5F;


#define STRM_A  0
#define STRM_B  1

typedef struct {
    FLOAT               xPos,  yPos;
    FLOAT               xSize, ySize;
    FLOAT               Alpha;
} STRM_PARAM;

const STRM_PARAM strParamInit[1] = {
    {0.0F, 0.0F, 1.0F, 1.0F, 1.0F}
};

STRM_PARAM strParam[2] = {
    {0.0F, 0.0F, 1.0F, 1.0F, 1.0F},
    {0.0F, 0.0F, 1.0F, 1.0F, 0.0F}
};


void InitStreamParams(int i)
{
    CopyMemory(&strParam[i], strParamInit, sizeof(strParamInit));

    if (i == STRM_B) {

        strParam[STRM_B].Alpha = 0.0F;
    }
}



/* -------------------------------------------------------------------------
** True Globals - these may change during execution of the program.
** -------------------------------------------------------------------------
*/
TCHAR               g_achFileName[MAX_PATH];
TCHAR               g_szPerfLog[MAX_PATH];
OPENFILENAME        ofn;
DWORD               g_State = VCD_NO_CD;
RECENTFILES         aRecentFiles[MAX_RECENT_FILES];
int                 nRecentFiles;
LONG                lMovieOrgX, lMovieOrgY;
int                 g_TimeFormat = IDM_TIME;
HANDLE              hRenderLog = INVALID_HANDLE_VALUE;
TCHAR *		    g_szOtherStuff;
BOOL                g_IsNT;


/* -------------------------------------------------------------------------
** Constants
** -------------------------------------------------------------------------
*/
const TCHAR szClassName[] = TEXT("SJE_VCDPlayer_CLASS");
const TCHAR g_szNULL[]    = TEXT("\0");
const TCHAR g_szEmpty[]   = TEXT("");
const TCHAR g_szMovieX[]  = TEXT("MovieOriginX");
const TCHAR g_szMovieY[]  = TEXT("MovieOriginY");

/*
** these values are defined by the UI gods...
*/
const int   dxBitmap        = 16;
const int   dyBitmap        = 15;
const int   dxButtonSep     = 8;
const TCHAR g_chNULL        = TEXT('\0');


const TBBUTTON tbButtons[DEFAULT_TBAR_SIZE] = {
    { IDX_SEPARATOR,    1,                    0,               TBSTYLE_SEP           },
    { IDX_1,            IDM_MOVIE_PLAY,       TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_2,            IDM_MOVIE_PAUSE,      TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_3,            IDM_MOVIE_STOP,       TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_SEPARATOR,    2,                    0,               TBSTYLE_SEP           },
    { IDX_4,            IDM_MOVIE_PREVTRACK,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_5,            IDM_MOVIE_SKIP_BACK,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_6,            IDM_MOVIE_SKIP_FORE,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_7,            IDM_MOVIE_NEXTTRACK,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_SEPARATOR,    3,                    0,               TBSTYLE_SEP           },
    { IDX_9,            IDM_PERF_NEW,         TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_10,           IDM_PERF_DUMP,        TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_SEPARATOR,    4,                    0,               TBSTYLE_SEP           },
    { IDX_11,           IDM_FULL_SCREEN,      TBSTATE_ENABLED, TBSTYLE_CHECK,  0, 0, 0, -1 },
    { IDX_SEPARATOR,    4,                    0,               TBSTYLE_SEP           },
    { IDX_12,           IDM_MOVIE_STEP,       TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 }
};

const int CX_DEFAULT	      = 310;
const int CY_DEFAULT	      = 120;

const int CX_MOVIE_DEFAULT    = 352;
const int CY_MOVIE_DEFAULT    = 120;



/******************************Public*Routine******************************\
* WinMain
*
*
* Windows recognizes this function by name as the initial entry point
* for the program.  This function calls the application initialization
* routine, if no other instance of the program is running, and always
* calls the instance initialization routine.  It then executes a message
* retrieval and dispatch loop that is the top-level control structure
* for the remainder of execution.  The loop is terminated when a WM_QUIT
* message is received, at which time this function exits the application
* instance by returning the value passed by PostQuitMessage().
*
* If this function must abort before entering the message loop, it
* returns the conventional value NULL.
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
int PASCAL
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLineOld,
    int nCmdShow
    )
{
    USES_CONVERSION;
    lstrcpy(g_szPerfLog, TEXT("c:\\perfdata.log"));
    LPTSTR lpCmdLine = A2T(lpCmdLineOld);

    if ( !hPrevInstance ) {
        if ( !InitApplication( hInstance ) ) {
            return FALSE;
        }
    }

    /*
    ** Perform initializations that apply to a specific instance
    */
    if ( !InitInstance( hInstance, nCmdShow ) ) {
        return FALSE;
    }

    /* Look for options */
    while (lpCmdLine && (*lpCmdLine == '-' || *lpCmdLine == '/')) {
        if (lpCmdLine[1] == 'T') {
            //  No threaded graph
            g_bUseThreadedGraph = TRUE;
            lpCmdLine += 2;
        } else if (lpCmdLine[1] == 'P') {
            g_bPlay = TRUE;
            lpCmdLine += 2;
        } else {
            break;
        }
        while (lpCmdLine[0] == ' ') {
            lpCmdLine++;
        }
    }


    if (lpCmdLine != NULL && lstrlen(lpCmdLine) > 0) {
        ProcessOpen(lpCmdLine, g_bPlay);
        SetPlayButtonsEnableState();
    }

    /*
    ** Acquire and dispatch messages until a WM_QUIT message is received.
    */
    return DoMainLoop();
}


/*****************************Private*Routine******************************\
* DoMainLoop
*
* Process the main message loop
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
int
DoMainLoop(
    void
    )
{
    MSG         msg;
    HANDLE      ahObjects[1];   // handles that need to be waited on
    const int   cObjects = 1;   // no of objects that we are waiting on
    HACCEL      haccel = LoadAccelerators(hInst, MAKEINTRESOURCE(IDR_ACCELERATOR));

    //
    // message loop lasts until we get a WM_QUIT message
    // upon which we shall return from the function
    //

    for ( ;; ) {

        if (pMpegMovie != NULL) {
            ahObjects[0] = pMpegMovie->GetMovieEventHandle();
        }
        else {
            ahObjects[0] = NULL;
        }

        if (ahObjects[0] == NULL) {
            WaitMessage();
        }
        else {

            //
            // wait for any message sent or posted to this queue
            // or for a graph notification
            //
            DWORD result;

            result = MsgWaitForMultipleObjects(cObjects, ahObjects, FALSE,
                                               INFINITE, QS_ALLINPUT);
            if (result != (WAIT_OBJECT_0 + cObjects)) {

                if (result == WAIT_OBJECT_0) {
                    VideoCd_OnGraphNotify();
                }
                continue;
            }
        }

        //
        // When here, we either have a message or no event handle
        // has been created yet.
        //
        // read all of the messages in this next loop
        // removing each message as we read it
        //

        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {

            if (msg.message == WM_QUIT) {
                return (int) msg.wParam;
            }

            if (!TranslateAccelerator(hwndApp, haccel, &msg)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }

} // DoMainLoop


//
// InitAboutString
//
// Obtains the version information from the binary file. Note that if
// we fail we just return. The template for the about dialog has a
// "Version not available" as default.
//
TCHAR *InitAboutString()
{
    //
    // Find the version of this binary
    //
    TCHAR achFileName[MAX_PATH];
    if ( !GetModuleFileName(hInst, achFileName, MAX_PATH) )
        return((TCHAR *)g_szEmpty);

    DWORD dwTemp;
    DWORD dwVerSize = GetFileVersionInfoSize( achFileName, &dwTemp );
    if ( !dwVerSize)
        return((TCHAR *)g_szEmpty);

    HLOCAL hTemp = LocalAlloc( LHND, dwVerSize );
    if (!hTemp)
        return((TCHAR *)g_szEmpty);

    LPVOID lpvVerBuffer = LocalLock( hTemp );
    if (!lpvVerBuffer) {
        LocalFree( hTemp );
        return((TCHAR *)g_szEmpty);
    }

    if ( !GetFileVersionInfo( achFileName, 0L, dwVerSize, lpvVerBuffer ) ) {
        LocalUnlock( hTemp );
        LocalFree( hTemp );
        return((TCHAR *)g_szEmpty);
    }

    // "040904E4" is the code page for US English (Andrew believes).
    LPVOID lpvValue;
    UINT uLen;
    if (VerQueryValue( lpvVerBuffer,
                   TEXT("\\StringFileInfo\\040904E4\\ProductVersion"),
                   (LPVOID *) &lpvValue, &uLen)) {

        //
        // Get creation date of executable (date of build)
        //
        WIN32_FIND_DATA FindFileData;
        HANDLE hFind = FindFirstFile(achFileName, &FindFileData);
        ASSERT(hFind != INVALID_HANDLE_VALUE);
        FindClose(hFind);

        FILETIME ModTime = FindFileData.ftLastWriteTime;
        SYSTEMTIME SysTime;
        FileTimeToSystemTime(&ModTime,&SysTime);
        char szBuildDate[20];
        sprintf(szBuildDate, " - Build: %2.2u%2.2u%2.2u",
              SysTime.wYear % 100, SysTime.wMonth, SysTime.wDay);
        strcat((LPSTR) lpvValue, szBuildDate);
    }

    TCHAR *szAbout = (TCHAR *) _strdup((LPSTR) lpvValue);

    LocalUnlock( hTemp );
    LocalFree( hTemp );

    return(szAbout);
}


/*****************************Private*Routine******************************\
* InitApplication(HANDLE)
*
* This function is called at initialization time only if no other
* instances of the application are running.  This function performs
* initialization tasks that can be done once for any number of running
* instances.
*
* In this case, we initialize a window class by filling out a data
* structure of type WNDCLASS and calling the Windows RegisterClass()
* function.  Since all instances of this application use the same window
* class, we only need to do this when the first instance is initialized.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
InitApplication(
    HINSTANCE hInstance
    )
{
    WNDCLASS  wc;

    hInstMeasure = LoadLibraryA("measure.dll");
    if (hInstMeasure) {
        *(FARPROC *)&lpDumpProc = GetProcAddress(hInstMeasure, "Msr_Dump");
        *(FARPROC *)&lpControlProc = GetProcAddress(hInstMeasure, "Msr_Control");
    }

    /*
    ** Fill in window class structure with parameters that describe the
    ** main window.
    */
    hIconVideoCd     = LoadIcon( hInstance, MAKEINTRESOURCE(IDR_VIDEOCD_ICON) );

    wc.style         = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;
    wc.lpfnWndProc   = VideoCdWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = hIconVideoCd;
    wc.hCursor       = LoadCursor( NULL, IDC_ARROW );
    wc.hbrBackground = (HBRUSH)NULL; // (COLOR_BTNFACE + 1);
    wc.lpszMenuName  = MAKEINTRESOURCE( IDR_MAIN_MENU);
    wc.lpszClassName = szClassName;

    OSVERSIONINFO OSVer;
    OSVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    BOOL bRet = GetVersionEx((LPOSVERSIONINFO) &OSVer);
    ASSERT(bRet);

    g_IsNT = (OSVer.dwPlatformId == VER_PLATFORM_WIN32_NT);

    g_szOtherStuff = InitAboutString();

    /*
    ** Register the window class and return success/failure code.
    */
    return RegisterClass( &wc );

}


/*****************************Private*Routine******************************\
* InitInstance
*
*
* This function is called at initialization time for every instance of
* this application.  This function performs initialization tasks that
* cannot be shared by multiple instances.
*
* In this case, we save the instance handle in a static variable and
* create and display the main program window.
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
InitInstance(
    HINSTANCE hInstance,
    int nCmdShow
    )
{
    HWND    hwnd;
    RECT    rc;
    POINT   pt;

    /*
    ** Save the instance handle in static variable, which will be used in
    ** many subsequence calls from this application to Windows.
    */
    hInst = hInstance;

    if ( ! LoadWindowPos(&rc))
       rc.left = rc.top = CW_USEDEFAULT;

    /*
    ** Create a main window for this application instance.
    */
    hwnd = CreateWindow( szClassName, IdStr(STR_APP_TITLE),
                         WS_THICKFRAME | WS_POPUP | WS_CAPTION  |
                         WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX |
                         WS_CLIPCHILDREN,
                         rc.left, rc.top,
                         rc.right - rc.left, rc.bottom - rc.top,
                         NULL, NULL, hInstance, NULL );

    /*
    ** If window could not be created, return "failure"
    */
    if ( NULL == hwnd ) {
        return FALSE;
    }


    hwndApp = hwnd;
    nRecentFiles = GetRecentFiles(nRecentFiles);

    pt.x = lMovieOrgX =  ProfileIntIn(g_szMovieX, 0);
    pt.y = lMovieOrgY =  ProfileIntIn(g_szMovieY, 0);

    // if we fail to get the working area (screen-tray), then assume
    // the screen is 640x480
    //
    if (!SystemParametersInfo(SPI_GETWORKAREA, 0, &rc, FALSE)) {
        rc.top = rc.left = 0;
        rc.right = 640;
        rc.bottom = 480;
    }

    if (!PtInRect(&rc, pt)) {
        lMovieOrgX = lMovieOrgY = 0L;
    }


    /*
    ** Make the window visible; update its client area; and return "success"
    */
    SetPlayButtonsEnableState();
    ShowWindow( hwnd, nCmdShow );
    UpdateWindow( hwnd );

    return TRUE;
}

/*****************************Private*Routine******************************\
* GetMoviePosition
*
* Place the movie in the centre of the client window.  We do not stretch the
* the movie yet !
*
* History:
* Fri 03/03/2000 - StEstrop - Created
*
\**************************************************************************/
void
GetMoviePosition(
    HWND hwnd,
    long* xPos,
    long* yPos,
    long* pcx,
    long* pcy
    )
{

    RECT rc;
    GetClientRect(hwnd, &rc);

    rc.top += (dyToolbar + dyTrackbar);
    rc.bottom -= dyStatusbar;

//  long cx, cy;
//  pMpegMovie->GetNativeMovieSize(&cx, &cy);
//
//  long wx = rc.right - rc.left;
//  long wy = rc.bottom - rc.top;
//
//  *xPos =  (wx - cx) / 2;
//  *yPos = rc.top + (wy - cy) / 2;
//  *pcx = cx;
//  *pcy = cy;

    *xPos = rc.left;
    *yPos = rc.top;

    *pcx = rc.right - rc.left;
    *pcy = rc.bottom - rc.top;
}


void
RepositionMovie(HWND hwnd)
{
    if (pMpegMovie) {
        long xPos, yPos, cx, cy;
        GetMoviePosition(hwnd, &xPos, &yPos, &cx, &cy);
        pMpegMovie->PutMoviePosition(xPos, yPos, cx, cy);
    }
}

void
VideoCd_OnMove(
    HWND hwnd,
    int x,
    int y
    )
{
    if (pMpegMovie) {
        if (pMpegMovie->GetStateMovie() != State_Running) {
            RepositionMovie(hwnd);
        }
    }
}


/******************************Public*Routine******************************\
* VideoCdWndProc
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
LRESULT CALLBACK
VideoCdWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch ( message ) {

    HANDLE_MSG( hwnd, WM_CREATE,            VideoCd_OnCreate );
    HANDLE_MSG( hwnd, WM_PAINT,             VideoCd_OnPaint );
    HANDLE_MSG( hwnd, WM_COMMAND,           VideoCd_OnCommand );
    HANDLE_MSG( hwnd, WM_CLOSE,             VideoCd_OnClose );
    HANDLE_MSG( hwnd, WM_QUERYENDSESSION,   VideoCd_OnQueryEndSession );
    HANDLE_MSG( hwnd, WM_DESTROY,           VideoCd_OnDestroy );
    HANDLE_MSG( hwnd, WM_SIZE,              VideoCd_OnSize );
    HANDLE_MSG( hwnd, WM_SYSCOLORCHANGE,    VideoCd_OnSysColorChange );
    HANDLE_MSG( hwnd, WM_MENUSELECT,        VideoCd_OnMenuSelect );
    HANDLE_MSG( hwnd, WM_INITMENUPOPUP,     VideoCd_OnInitMenuPopup );
    HANDLE_MSG( hwnd, WM_HSCROLL,           VideoCd_OnHScroll );
    HANDLE_MSG( hwnd, WM_TIMER,             VideoCd_OnTimer );
    HANDLE_MSG( hwnd, WM_NOTIFY,            VideoCd_OnNotify );
    HANDLE_MSG( hwnd, WM_DROPFILES,         VideoCd_OnDropFiles);
    HANDLE_MSG( hwnd, WM_KEYUP,             VideoCd_OnKeyUp);

    HANDLE_MSG( hwnd, WM_MOVE,              VideoCd_OnMove );

    case WM_RBUTTONDBLCLK:
        VcdPlyerCaptureImage("CurrFrame.bmp");
        break;

    case WM_DISPLAYCHANGE:
            if (pMpegMovie) {
                pMpegMovie->DisplayModeChanged();
            }
        break;

    // Note: we do not use HANDLE_MSG here as we want to call
    // DefWindowProc after we have notifed the FilterGraph Resource Manager,
    // otherwise our window will not finish its activation process.

    case WM_ACTIVATE: VideoCd_OnActivate(hwnd, wParam, lParam);

	// IMPORTANT - let this drop through to DefWindowProc

    default:
        return DefWindowProc( hwnd, message, wParam, lParam );
    }

    return 0L;
}


/*****************************Private*Routine******************************\
* VideoCd_OnCreate
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
VideoCd_OnCreate(
    HWND hwnd,
    LPCREATESTRUCT lpCreateStruct
    )
{
    RECT rc;
    int Pane[2];

    InitCommonControls();

    /*
    ** Create the toolbar and statusbar.
    */
    g_hwndToolbar = CreateToolbarEx( hwnd,
                                     WS_VISIBLE | WS_CHILD |
                                     TBSTYLE_TOOLTIPS | CCS_NODIVIDER,
                                     ID_TOOLBAR, NUMBER_OF_BITMAPS,
                                     hInst, IDR_TOOLBAR, tbButtons,
                                     DEFAULT_TBAR_SIZE, dxBitmap, dyBitmap,
                                     dxBitmap, dyBitmap, sizeof(TBBUTTON) );

    if ( g_hwndToolbar == NULL ) {
        return FALSE;
    }


    g_hwndStatusbar = CreateStatusWindow( WS_VISIBLE | WS_CHILD | CCS_BOTTOM,
                                          TEXT("Example Text"),
                                          hwnd, ID_STATUSBAR );

    GetWindowRect(g_hwndToolbar, &rc);
    dyToolbar = rc.bottom - rc.top;

    GetWindowRect(g_hwndStatusbar, &rc);
    dyStatusbar = rc.bottom - rc.top;

    dyTrackbar = 30;

    GetClientRect(hwnd, &rc);
    Pane[0] = (rc.right - rc.left) / 2 ;
    Pane[1] = -1;
    SendMessage(g_hwndStatusbar, SB_SETPARTS, 2, (LPARAM)Pane);


    g_hwndTrackbar = CreateWindowEx(0, TRACKBAR_CLASS, TEXT("Trackbar Control"),
                                    WS_CHILD | WS_VISIBLE |
                                    TBS_AUTOTICKS | TBS_ENABLESELRANGE,
                                    LEFT_MARGIN, dyToolbar - 1,
                                    (rc.right - rc.left) - (2* LEFT_MARGIN),
                                    dyTrackbar, hwnd, (HMENU)ID_TRACKBAR,
                                    hInst, NULL);

    SetDurationLength((REFTIME)0);
    SetCurrentPosition((REFTIME)0);

    SetTimer(hwnd, StatusTimer, 500, NULL);

    if (g_hwndStatusbar == NULL || g_hwndTrackbar == NULL) {
        return FALSE;
    }

    // accept filemanager WM_DROPFILES messages
    DragAcceptFiles(hwnd, TRUE);

    return TRUE;
}

/*****************************Private*Routine******************************\
* VideoCd_OnActivate
*
*
*
* History:
* 18/9/1996 - SteveDav - Created
*
\**************************************************************************/

void
VideoCd_OnActivate(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    )

{
    if ((UINT)LOWORD(wParam)) {
	// we are being activated - tell the Filter graph (for Sound follows focus)
        if (pMpegMovie) {
            pMpegMovie->SetFocus();
        }
    }
}

/*****************************Private*Routine******************************\
* VideoCd_OnKeyUp
*
*
*
* History:
* 23/3/1996 - AnthonyP - Created
*
\**************************************************************************/
void
VideoCd_OnKeyUp(
    HWND hwnd,
    UINT vk,
    BOOL fDown,
    int cRepeat,
    UINT flags
    )
{
    // Catch escape sequences to stop fullscreen mode

    if (vk == VK_ESCAPE) {
        if (pMpegMovie) {
            pMpegMovie->SetFullScreenMode(FALSE);
            SetPlayButtonsEnableState();
        }
    }
}


/*****************************Private*Routine******************************\
* VideoCd_OnHScroll
*
*
*
* History:
* 11/3/1995 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnHScroll(
    HWND hwnd,
    HWND hwndCtl,
    UINT code,
    int pos
    )
{
    static BOOL fWasPlaying = FALSE;
    static BOOL fBeginScroll = FALSE;

    if (pMpegMovie == NULL) {
        return;
    }

    if (hwndCtl == g_hwndTrackbar) {

        REFTIME     rtCurrPos;
        REFTIME     rtTrackPos;
        REFTIME     rtDuration;

        pos = (int)SendMessage(g_hwndTrackbar, TBM_GETPOS, 0, 0);
        rtTrackPos = (REFTIME)pos * g_TrackBarScale;

        switch (code) {
        case TB_BOTTOM:
            rtDuration = pMpegMovie->GetDuration();
            rtCurrPos = pMpegMovie->GetCurrentPosition();
            VcdPlayerSeekCmd(rtDuration - rtCurrPos);
            SetCurrentPosition(pMpegMovie->GetCurrentPosition());
            break;

        case TB_TOP:
            rtCurrPos = pMpegMovie->GetCurrentPosition();
            VcdPlayerSeekCmd(-rtCurrPos);
            SetCurrentPosition(pMpegMovie->GetCurrentPosition());
            break;

        case TB_LINEDOWN:
            VcdPlayerSeekCmd(10.0);
            SetCurrentPosition(pMpegMovie->GetCurrentPosition());
            break;

        case TB_LINEUP:
            VcdPlayerSeekCmd(-10.0);
            SetCurrentPosition(pMpegMovie->GetCurrentPosition());
            break;

        case TB_ENDTRACK:
            fBeginScroll = FALSE;
            if (fWasPlaying) {
                VcdPlayerPauseCmd();
                fWasPlaying = FALSE;
            }
            break;

        case TB_THUMBTRACK:
            if (!fBeginScroll) {
                fBeginScroll = TRUE;
                fWasPlaying = (g_State & VCD_PLAYING);
                if (fWasPlaying) {
                    VcdPlayerPauseCmd();
                }
            }
        case TB_PAGEUP:
        case TB_PAGEDOWN:
            rtCurrPos = pMpegMovie->GetCurrentPosition();
            VcdPlayerSeekCmd(rtTrackPos - rtCurrPos);
            SetCurrentPosition(pMpegMovie->GetCurrentPosition());
            break;
        }
    }
}


/*****************************Private*Routine******************************\
* VideoCd_OnTimer
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnTimer(
    HWND hwnd,
    UINT id
    )
{
    HDC     hdc;

    if (pMpegMovie && pMpegMovie->StatusMovie() == MOVIE_PLAYING) {

        switch (id) {
        case StatusTimer:
            {
                REFTIME rt = pMpegMovie->GetCurrentPosition();
                SetCurrentPosition(rt);

                if (1)
                {
                    TCHAR   szFmt[64];
                    TCHAR   sz[64];
                    long cx, cy;

                    pMpegMovie->GetNativeMovieSize(&cx, &cy);
                    wsprintf(sz, TEXT("%s"), FormatRefTime(szFmt, rt));

                    HDC hdc = GetDC(hwndApp);
                    HBITMAP hbmp = CreateCompatibleBitmap(hdc, 128, 128);
                    HBITMAP hbmpVmr = LoadBitmap(hInst, MAKEINTRESOURCE(IDR_VMR));
                    HDC hdcBmp = CreateCompatibleDC(hdc);
                    HDC hdcVMR = CreateCompatibleDC(hdc);
                    ReleaseDC(hwndApp, hdc);

                    HBITMAP hbmpold = (HBITMAP)SelectObject(hdcBmp, hbmp);
                    hbmpVmr = (HBITMAP)SelectObject(hdcVMR, hbmpVmr);
                    BitBlt(hdcBmp, 0, 0, 128, 128, hdcVMR, 0, 0, SRCCOPY);
                    DeleteObject(SelectObject(hdcVMR, hbmpVmr));
                    DeleteDC(hdcVMR);

                    RECT rc;
                    SetRect(&rc, 0, 0, 128, 32);
                    SetBkColor(hdcBmp, RGB(0, 0, 128));
                    SetTextColor(hdcBmp, RGB(255, 255, 255));

                    DrawText(hdcBmp, sz, lstrlen(sz), &rc, DT_CENTER | DT_VCENTER | DT_SINGLELINE );

                    VMRALPHABITMAP bmpInfo;
                    ZeroMemory(&bmpInfo, sizeof(bmpInfo) );
                    bmpInfo.dwFlags = VMRBITMAP_HDC | VMRBITMAP_SRCCOLORKEY;
                    bmpInfo.hdc = hdcBmp;
                    SetRect(&rc, 0, 0, 128, 128);
                    bmpInfo.rSrc = rc;

                    bmpInfo.rDest.left = g_xPos;
                    bmpInfo.rDest.top = g_yPos;
                    bmpInfo.rDest.right = g_xPos + g_xSize;
                    bmpInfo.rDest.bottom = g_yPos + g_ySize;

                    if (g_fEnableAppImage) {
                        bmpInfo.fAlpha = g_Alpha;
                    }
                    else {
                        bmpInfo.fAlpha = 0.0F;
                    }
                    bmpInfo.clrSrcKey = 0;

                    pMpegMovie->SetAppImage(&bmpInfo);


                    DeleteObject(SelectObject(hdcBmp, hbmpold));
                    DeleteDC(hdcBmp);
                }
            }
            break;
        }
    }
}




/*****************************Private*Routine******************************\
* VideoCd_OnPaint
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnPaint(
    HWND hwnd
    )
{
    PAINTSTRUCT ps;
    HDC         hdc;
    RECT        rc1;
    RECT        rc2;

    /*
    ** Draw a frame around the movie playback area.
    */
    GetClientRect(hwnd, &rc2);


    hdc = BeginPaint( hwnd, &ps );

    if (pMpegMovie) {

        long xPos, yPos, cx, cy;
        GetMoviePosition(hwnd, &xPos, &yPos, &cx, &cy);
        SetRect(&rc1, xPos, yPos, xPos + cx, yPos + cy);

        HRGN rgnClient = CreateRectRgnIndirect(&rc2);
        HRGN rgnVideo  = CreateRectRgnIndirect(&rc1);
        CombineRgn(rgnClient, rgnClient, rgnVideo, RGN_DIFF);

        HBRUSH hbr = GetSysColorBrush(COLOR_BTNFACE);
        FillRgn(hdc, rgnClient, hbr);
        DeleteObject(hbr);
        DeleteObject(rgnClient);
        DeleteObject(rgnVideo);

        pMpegMovie->RepaintVideo(hwnd, hdc);
    }
    else {
        FillRect(hdc, &rc2, (HBRUSH)(COLOR_BTNFACE + 1));
    }

    EndPaint( hwnd, &ps );
}

void
UpdateAppImage()
{
    VMRALPHABITMAP bmpInfo;
    ZeroMemory(&bmpInfo, sizeof(bmpInfo) );
    bmpInfo.rDest.left = g_xPos;
    bmpInfo.rDest.top = g_yPos;
    bmpInfo.rDest.right = g_xPos + g_xSize;
    bmpInfo.rDest.bottom = g_yPos + g_ySize;

    bmpInfo.dwFlags = VMRBITMAP_SRCCOLORKEY;
    bmpInfo.clrSrcKey = 0;

    if (!g_fEnableAppImage) {
        bmpInfo.fAlpha = 0.0F;
    }
    else {
        bmpInfo.fAlpha = g_Alpha;
    }
    pMpegMovie->UpdateAppImage(&bmpInfo);
}

BOOL CALLBACK
AppImgDlgProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HWND hwndT;
    int pos;
    TCHAR sz[32];

    switch (uMsg) {
    case WM_INITDIALOG:

        hwndT = GetDlgItem(hwnd, IDC_XPOS_TRK );
        pos = int(1000 * g_xPos);
        SendMessage(hwndT, TBM_SETRANGE, TRUE, MAKELONG(0, (WORD)(1000)));
        SendMessage(hwndT, TBM_SETPOS, TRUE, (LPARAM)(pos));
        _stprintf(sz, TEXT("%.3f"), g_xPos);
        SetWindowText(hwndT, sz);
        SetDlgItemText(hwnd, IDC_XPOS, sz);

        pos = int(1000 * g_yPos);
        hwndT = GetDlgItem(hwnd, IDC_YPOS_TRK );
        SendMessage(hwndT, TBM_SETRANGE, TRUE, MAKELONG(0, (WORD)(1000)));
        SendMessage(hwndT, TBM_SETPOS, TRUE, (LPARAM)(pos));
        _stprintf(sz, TEXT("%.3f"), g_yPos);
        SetWindowText(hwndT, sz);
        SetDlgItemText(hwnd, IDC_YPOS, sz);

        pos = int(1000 * g_xSize);
        hwndT = GetDlgItem(hwnd, IDC_XSIZE_TRK );
        SendMessage(hwndT, TBM_SETRANGE, TRUE, MAKELONG(0, (WORD)(1000)));
        SendMessage(hwndT, TBM_SETPOS, TRUE, (LPARAM)(pos));
        _stprintf(sz, TEXT("%.3f"), g_xSize);
        SetWindowText(hwndT, sz);
        SetDlgItemText(hwnd, IDC_XSIZE, sz);

        pos = int(1000 * g_ySize);
        hwndT = GetDlgItem(hwnd, IDC_YSIZE_TRK );
        SendMessage(hwndT, TBM_SETRANGE, TRUE, MAKELONG(0, (WORD)(1000)));
        SendMessage(hwndT, TBM_SETPOS, TRUE, (LPARAM)(pos));
        _stprintf(sz, TEXT("%.3f"), g_ySize);
        SetDlgItemText(hwnd, IDC_YSIZE, sz);

        pos = int(1000 * g_Alpha);
        hwndT = GetDlgItem(hwnd, IDC_ALPHA_TRK2 );
        SendMessage(hwndT, TBM_SETRANGE, TRUE, MAKELONG(0, (WORD)(1000)));
        SendMessage(hwndT, TBM_SETPOS, TRUE, (LPARAM)(pos));
        _stprintf(sz, TEXT("%.3f"), g_Alpha);
        SetDlgItemText(hwnd, IDC_ALPHA, sz);

        Button_SetCheck(GetDlgItem(hwnd, IDC_IMAGE_ENABLE ), g_fEnableAppImage);
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            EndDialog(hwnd, 1);
            break;

        case IDC_IMAGE_ENABLE:
            g_fEnableAppImage =
                Button_GetCheck(GetDlgItem(hwnd, IDC_IMAGE_ENABLE ));
            UpdateAppImage();
            break;
        }
        return TRUE;

    case WM_HSCROLL:
        {
            HWND hwndCtrl = (HWND)lParam;

            if (GetDlgItem(hwnd, IDC_ALPHA_TRK2 ) == hwndCtrl) {
                pos = (int)SendMessage(hwndCtrl, TBM_GETPOS, 0, 0);
                g_Alpha = (FLOAT)pos / 1000.0F;
                UpdateAppImage();
                _stprintf(sz, TEXT("%.3f"), g_Alpha);
                SetDlgItemText(hwnd, IDC_ALPHA, sz);
            }
            else if (GetDlgItem(hwnd, IDC_XPOS_TRK ) == hwndCtrl) {
                pos = (int)SendMessage(hwndCtrl, TBM_GETPOS, 0, 0);
                g_xPos = (FLOAT)pos / 1000.0F;
                UpdateAppImage();
                _stprintf(sz, TEXT("%.3f"), g_xPos);
                SetDlgItemText(hwnd, IDC_XPOS, sz);
            }
            else if (GetDlgItem(hwnd, IDC_YPOS_TRK ) == hwndCtrl) {
                pos = (int)SendMessage(hwndCtrl, TBM_GETPOS, 0, 0);
                g_yPos = (FLOAT)pos / 1000.0F;
                UpdateAppImage();
                _stprintf(sz, TEXT("%.3f"), g_yPos);
                SetDlgItemText(hwnd, IDC_YPOS, sz);
            }
            else if (GetDlgItem(hwnd, IDC_XSIZE_TRK ) == hwndCtrl) {
                pos = (int)SendMessage(hwndCtrl, TBM_GETPOS, 0, 0);
                g_xSize = (FLOAT)pos / 1000.0F;
                UpdateAppImage();
                _stprintf(sz, TEXT("%.3f"), g_xSize);
                SetDlgItemText(hwnd, IDC_XSIZE, sz);
            }
            else if (GetDlgItem(hwnd, IDC_YSIZE_TRK ) == hwndCtrl) {
                pos = (int)SendMessage(hwndCtrl, TBM_GETPOS, 0, 0);
                g_ySize = (FLOAT)pos / 1000.0F;
                UpdateAppImage();
                _stprintf(sz, TEXT("%.3f"), g_ySize);
                SetDlgItemText(hwnd, IDC_YSIZE, sz);
            }
        }
        return TRUE;


    default:
        return FALSE;
    }
}

void
UpdatePinAlpha(int strmID)
{
    STRM_PARAM* p = &strParam[strmID];

    if (pMpegMovie && pMpegMovie->m_pMixControl)
        pMpegMovie->m_pMixControl->SetAlpha(strmID, p->Alpha );
}

void
UpdatePinPos(int strmID)
{
    STRM_PARAM* p = &strParam[strmID];
    NORMALIZEDRECT r = {p->xPos, p->yPos, p->xPos + p->xSize, p->yPos + p->ySize};

    if (pMpegMovie && pMpegMovie->m_pMixControl)
        pMpegMovie->m_pMixControl->SetOutputRect(strmID, &r);
}



BOOL CALLBACK
TransDlgProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    TCHAR sz[32];
    HWND hwndT;
    int pos;

    static int strmID;
    STRM_PARAM* p = &strParam[strmID];

    switch (uMsg) {
    case WM_INITDIALOG:

        strmID = (int)lParam;
        p = &strParam[strmID];

        SetWindowText(hwnd, TEXT("Video Transition Properties"));
        ShowWindow(GetDlgItem(hwnd, IDC_IMAGE_ENABLE ), SW_HIDE);

        hwndT = GetDlgItem(hwnd, IDC_XPOS_TRK );
        pos = int(10000 * p->xPos) + 10000;
        SendMessage(hwndT, TBM_SETRANGE, TRUE, MAKELONG(0, (WORD)(20000)));
        SendMessage(hwndT, TBM_SETPOS, TRUE, (LPARAM)(pos));
        _stprintf(sz, TEXT("%.3f"), p->xPos);
        SetWindowText(hwndT, sz);
        SetDlgItemText(hwnd, IDC_XPOS, sz);

        pos = int(10000 * p->yPos) + 10000;
        hwndT = GetDlgItem(hwnd, IDC_YPOS_TRK );
        SendMessage(hwndT, TBM_SETRANGE, TRUE, MAKELONG(0, (WORD)(20000)));
        SendMessage(hwndT, TBM_SETPOS, TRUE, (LPARAM)(pos));
        _stprintf(sz, TEXT("%.3f"), p->yPos);
        SetWindowText(hwndT, sz);
        SetDlgItemText(hwnd, IDC_YPOS, sz);

        pos = int(10000 * p->xSize) + 10000;
        hwndT = GetDlgItem(hwnd, IDC_XSIZE_TRK );
        SendMessage(hwndT, TBM_SETRANGE, TRUE, MAKELONG(0, (WORD)(20000)));
        SendMessage(hwndT, TBM_SETPOS, TRUE, (LPARAM)(pos));
        _stprintf(sz, TEXT("%.3f"), p->xSize);
        SetWindowText(hwndT, sz);
        SetDlgItemText(hwnd, IDC_XSIZE, sz);

        pos = int(10000 * p->ySize) + 10000;
        hwndT = GetDlgItem(hwnd, IDC_YSIZE_TRK );
        SendMessage(hwndT, TBM_SETRANGE, TRUE, MAKELONG(0, (WORD)(20000)));
        SendMessage(hwndT, TBM_SETPOS, TRUE, (LPARAM)(pos));
        _stprintf(sz, TEXT("%.3f"), p->ySize);
        SetWindowText(hwndT, sz);
        SetDlgItemText(hwnd, IDC_YSIZE, sz);

        pos = int(10000 * p->Alpha);
        hwndT = GetDlgItem(hwnd, IDC_ALPHA_TRK2 );
        SendMessage(hwndT, TBM_SETRANGE, TRUE, MAKELONG(0, (WORD)(10000)));
        SendMessage(hwndT, TBM_SETPOS, TRUE, (LPARAM)(pos));
        _stprintf(sz, TEXT("%.3f"), p->Alpha);
        SetWindowText(hwndT, sz);
        SetDlgItemText(hwnd, IDC_ALPHA, sz);
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            EndDialog(hwnd, 1);
            break;
        }
        return TRUE;

    case WM_HSCROLL:
        {
            HWND hwndCtrl = (HWND)lParam;

            if (GetDlgItem(hwnd, IDC_ALPHA_TRK2 ) == hwndCtrl) {
                pos = (int)SendMessage(hwndCtrl, TBM_GETPOS, 0, 0);
                p->Alpha = (FLOAT)pos / 10000.0F;
                UpdatePinAlpha(strmID);
                _stprintf(sz, TEXT("%.3f"), p->Alpha);
                SetDlgItemText(hwnd, IDC_ALPHA, sz);
            }
            else if (GetDlgItem(hwnd, IDC_XPOS_TRK ) == hwndCtrl) {
                pos = (int)SendMessage(hwndCtrl, TBM_GETPOS, 0, 0);
                p->xPos = ((FLOAT)pos - 10000.F) / 10000.0F;
                UpdatePinPos(strmID);
                _stprintf(sz, TEXT("%.3f"), p->xPos);
                SetDlgItemText(hwnd, IDC_XPOS, sz);
            }
            else if (GetDlgItem(hwnd, IDC_YPOS_TRK ) == hwndCtrl) {
                pos = (int)SendMessage(hwndCtrl, TBM_GETPOS, 0, 0);
                p->yPos = ((FLOAT)pos - 10000.F) / 10000.0F;
                UpdatePinPos(strmID);
                _stprintf(sz, TEXT("%.3f"), p->yPos);
                SetDlgItemText(hwnd, IDC_YPOS, sz);
            }
            else if (GetDlgItem(hwnd, IDC_XSIZE_TRK ) == hwndCtrl) {
                pos = (int)SendMessage(hwndCtrl, TBM_GETPOS, 0, 0);
                p->xSize = ((FLOAT)pos - 10000.F) / 10000.0F;
                UpdatePinPos(strmID);
                _stprintf(sz, TEXT("%.3f"), p->xSize);
                SetDlgItemText(hwnd, IDC_XSIZE, sz);
            }
            else if (GetDlgItem(hwnd, IDC_YSIZE_TRK ) == hwndCtrl) {
                pos = (int)SendMessage(hwndCtrl, TBM_GETPOS, 0, 0);
                p->ySize = ((FLOAT)pos - 10000.F) / 10000.0F;
                UpdatePinPos(strmID);
                _stprintf(sz, TEXT("%.3f"), p->ySize);
                SetDlgItemText(hwnd, IDC_YSIZE, sz);
            }
        }
        return TRUE;

    default:
        return FALSE;
    }
}



/*****************************Private*Routine******************************\
* VideoCd_OnCommand
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnCommand(
    HWND hwnd,
    int id,
    HWND hwndCtl,
    UINT codeNotify
    )
{
    switch (id) {

    case IDM_FILE_SET_LOG:
        VcdPlayerSetLog();    // set RenderFile log
        break;

    case IDM_FILE_SET_PERF_LOG:
        VcdPlayerSetPerfLogFile();    // set perf log
        break;

    case IDM_FILE_OPEN:
        VcdPlayerOpenCmd(STRM_A);
        break;

    case IDM_FILE_OPEN2:
        VcdPlayerOpenCmd(STRM_B);
        break;

    case IDM_FILE_CLOSE:
        VcdPlayerCloseCmd();
        QzFreeUnusedLibraries();
        break;

    case IDM_FILE_EXIT:
        PostMessage( hwnd, WM_CLOSE, 0, 0L );
        break;

    case IDM_MOVIE_PLAY:
        VcdPlayerPlayCmd();
        break;

    case IDM_MOVIE_STOP:
        VcdPlayerStopCmd();
        break;

    case IDM_MOVIE_PAUSE:
        VcdPlayerPauseCmd();
        break;

    case IDM_MOVIE_SKIP_FORE:
        VcdPlayerSeekCmd(1.0);
        break;

    case IDM_MOVIE_SKIP_BACK:
        VcdPlayerSeekCmd(-1.0);
        break;

    case IDM_MOVIE_PREVTRACK:
        if (pMpegMovie) {
            VcdPlayerSeekCmd(-pMpegMovie->GetCurrentPosition());
        }
        break;

    case IDM_MOVIE_STEP:
        VcdPlayerStepCmd();
        break;

    case IDM_TIME:
    case IDM_FRAME:
    case IDM_FIELD:
    case IDM_SAMPLE:
    case IDM_BYTES:
        if (pMpegMovie) {
            g_TimeFormat = VcdPlayerChangeTimeFormat(id);
        }
        break;

    case IDM_MOVIE_NEXTTRACK:
        if (pMpegMovie) {
            REFTIME rtDur = pMpegMovie->GetDuration();
            REFTIME rtPos = pMpegMovie->GetCurrentPosition();
            VcdPlayerSeekCmd(rtDur - rtPos);
        }
        break;

    case IDM_PERF_NEW:
        if (lpControlProc) (*lpControlProc)(MSR_RESET_ALL);
        break;

    case IDM_PERF_DUMP:
        if (lpDumpProc) {

            HANDLE hFile;
            hFile = CreateFile(g_szPerfLog, GENERIC_WRITE, 0, NULL,
                               CREATE_ALWAYS, 0, NULL);
            (*lpDumpProc)(hFile);
            CloseHandle(hFile);
        }
        break;

    case IDM_FULL_SCREEN:
        if (pMpegMovie) {
            BOOL bFullScreen = (BOOL) SendMessage( g_hwndToolbar, TB_ISBUTTONCHECKED, IDM_FULL_SCREEN, 0 );
            pMpegMovie->SetFullScreenMode(bFullScreen);
        }
        break;

    case IDM_MOVIE_ALIGN:
        {
            RECT rc, rcWnd;
            HWND hwndRenderer = FindWindow(TEXT("VideoRenderer"), NULL);
            if (hwndRenderer) {
                GetClientRect(hwndRenderer, &rc);
                GetWindowRect(hwndRenderer, &rcWnd);

                MapWindowPoints(hwndRenderer, HWND_DESKTOP, (LPPOINT)&rc, 2);
                rcWnd.left -= rc.left & 3;
                rcWnd.top  -= rc.top  & 3;

                SetWindowPos(hwndRenderer, NULL, rcWnd.left, rcWnd.top, 0, 0,
                             SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);
            }
        }
        break;


    case IDM_APP_IMAGE:
        {
            DialogBox(hInst, MAKEINTRESOURCE(IDD_AUDIOPROP), hwnd, AppImgDlgProc);
        }
        break;

    case IDM_STREAM_A:
        {
            DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_AUDIOPROP), hwnd,
                           TransDlgProc, (LPARAM)STRM_A);
        }
        break;

    case IDM_STREAM_B:
        {
            DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_AUDIOPROP), hwnd,
                           TransDlgProc, (LPARAM)STRM_B);
        }
        break;

    case IDM_HELP_ABOUT:
        {
            TCHAR  szApp[STR_MAX_STRING_LEN];
            TCHAR  szOtherStuff[STR_MAX_STRING_LEN];

            lstrcpy( szApp, IdStr(STR_APP_TITLE) );
            lstrcat( szApp, TEXT("#") );
            if (g_IsNT)
		lstrcat( szApp, TEXT("Windows NT") );
	    // for some reason ShellAbout prints OS uner Win95 but not NT
	    // else
	    //	strcat( szApp, "Windows 95" );
            lstrcpy( szOtherStuff, IdStr(STR_APP_TITLE) );
            lstrcat( szOtherStuff, TEXT("\n") );
            lstrcat( szOtherStuff, g_szOtherStuff );
            ShellAbout( hwnd, szApp, szOtherStuff, hIconVideoCd );
        }
        break;

    default:
        if (id > ID_RECENT_FILE_BASE
         && id <= (ID_RECENT_FILE_BASE + MAX_RECENT_FILES + 1)) {

            ProcessOpen(aRecentFiles[id - ID_RECENT_FILE_BASE - 1]);
        } else if (id >= 2000 && id <= 2050) {
	    pMpegMovie->SelectStream(id - 2000);
	}
	break;
	
    }

    SetPlayButtonsEnableState();
}




/******************************Public*Routine******************************\
* VideoCd_OnDestroy
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnDestroy(
    HWND hwnd
    )
{
    PostQuitMessage( 0 );
}




/******************************Public*Routine******************************\
* VideoCd_OnClose
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnClose(
    HWND hwnd
    )
{

    // stop accepting dropped filenames
    DragAcceptFiles(hwnd, FALSE);

    VcdPlayerCloseCmd();
    ProfileIntOut(g_szMovieX, lMovieOrgX);
    ProfileIntOut(g_szMovieY, lMovieOrgY);

    SaveWindowPos( hwnd );
    DestroyWindow( hwnd );
}

BOOL
VideoCd_OnQueryEndSession(
    HWND hwnd
    )
{
    SaveWindowPos( hwnd );
    return TRUE;
}


/******************************Public*Routine******************************\
* VideoCd_OnSize
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnSize(
    HWND hwnd,
    UINT state,
    int dx,
    int dy
    )
{
    if (IsWindow(g_hwndStatusbar)) {

        int Pane[2] = {dx/2-8, -1};

        SendMessage(g_hwndStatusbar, WM_SIZE, 0, 0L);
        SendMessage(g_hwndStatusbar, SB_SETPARTS, 2, (LPARAM)Pane);
    }

    if (IsWindow(g_hwndTrackbar)) {
        SetWindowPos(g_hwndTrackbar, HWND_TOP, LEFT_MARGIN, dyToolbar - 1,
                     dx - (2 * LEFT_MARGIN), dyTrackbar, SWP_NOZORDER );
    }

    if (IsWindow(g_hwndToolbar)) {
        SendMessage( g_hwndToolbar, WM_SIZE, 0, 0L );
    }

    RepositionMovie(hwnd);
}


/*****************************Private*Routine******************************\
* VideoCd_OnSysColorChange
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnSysColorChange(
    HWND hwnd
    )
{
    FORWARD_WM_SYSCOLORCHANGE(g_hwndToolbar, SendMessage);
    FORWARD_WM_SYSCOLORCHANGE(g_hwndStatusbar, SendMessage);
}




/*****************************Private*Routine******************************\
* VideoCd_OnInitMenuPopup
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnInitMenuPopup(
    HWND hwnd,
    HMENU hMenu,
    UINT item,
    BOOL fSystemMenu
    )
{
    UINT uFlags;

    switch (item) {

    case 0: // File menu
        if (g_State & (VCD_IN_USE | VCD_NO_CD | VCD_DATA_CD_LOADED)) {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        EnableMenuItem(hMenu, IDM_FILE_CLOSE, uFlags );

        if (lpControlProc == NULL) {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        EnableMenuItem(hMenu, IDM_FILE_SET_PERF_LOG, uFlags );
        break;

    case 1: // Properties menu
        break;

    case 2: // Time formats menu

        // Can only change time format when stopped
    {
        EMpegMovieMode State = MOVIE_NOTOPENED;
        if (pMpegMovie) {
            State = pMpegMovie->StatusMovie();
        }
	

        if (State && pMpegMovie->IsTimeSupported()) {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        EnableMenuItem(hMenu, IDM_TIME, uFlags );

        if (State && pMpegMovie->IsTimeFormatSupported(TIME_FORMAT_FRAME)) {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        EnableMenuItem(hMenu, IDM_FRAME, uFlags );

        if (State && pMpegMovie->IsTimeFormatSupported(TIME_FORMAT_FIELD)) {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        EnableMenuItem(hMenu, IDM_FIELD, uFlags );

        if (State && pMpegMovie->IsTimeFormatSupported(TIME_FORMAT_SAMPLE)) {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        EnableMenuItem(hMenu, IDM_SAMPLE, uFlags );

        if (State && pMpegMovie->IsTimeFormatSupported(TIME_FORMAT_BYTE)) {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        EnableMenuItem(hMenu, IDM_BYTES, uFlags );

        CheckMenuItem(hMenu, IDM_BYTES, MF_BYCOMMAND | MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_SAMPLE, MF_BYCOMMAND | MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_FRAME, MF_BYCOMMAND | MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_FIELD, MF_BYCOMMAND | MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_TIME, MF_BYCOMMAND | MF_UNCHECKED);
        CheckMenuItem(hMenu, g_TimeFormat, MF_BYCOMMAND | MF_CHECKED);
    }
	break;
	
    case 3: // streams menu

	if (pMpegMovie && pMpegMovie->m_pStreamSelect) {
	    DWORD	cStreams;

	    pMpegMovie->m_pStreamSelect->Count(&cStreams);

	    for (DWORD i = 0; i < cStreams; i++) {
		DWORD dwFlags;
		
		pMpegMovie->m_pStreamSelect->Info(i, NULL, &dwFlags, NULL, NULL, NULL, NULL, NULL);

		CheckMenuItem(hMenu, 2000+i, MF_BYCOMMAND |
			      ((dwFlags & AMSTREAMSELECTINFO_ENABLED) ? MF_CHECKED : MF_UNCHECKED));
	    }
	}
	
        break;
    }
}


/*****************************Private*Routine******************************\
* VideoCd_OnGraphNotify
*
* This is where we get any notifications from the filter graph.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnGraphNotify(
    void
    )
{
    long    lEventCode;
    HDC     hdc;

    lEventCode = pMpegMovie->GetMovieEventCode();
    switch (lEventCode) {
    case EC_FULLSCREEN_LOST:
        pMpegMovie->SetFullScreenMode(FALSE);
        SetPlayButtonsEnableState();
        break;

    case EC_STEP_COMPLETE:
        g_State &= ~VCD_STEPPING;
        SetPlayButtonsEnableState();
        {
            char sz[80];
            wsprintfA(sz, "VCDPLYER: step %d completed \n", FrameStepCount);
            OutputDebugStringA(sz);
        }
        break;

    case EC_COMPLETE:
    case EC_USERABORT:
    case EC_ERRORABORT:
        VcdPlayerStopCmd();
        SetPlayButtonsEnableState();
//      hdc = GetDC(hwndApp);
//      DrawStats(hdc);
//      ReleaseDC(hwndApp, hdc);
        break;

    default:
        break;
    }
}


/*****************************Private*Routine******************************\
* VideoCd_OnNotify
*
* This is where we get the text for the little tooltips
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
LRESULT
VideoCd_OnNotify(
    HWND hwnd,
    int idFrom,
    NMHDR FAR* pnmhdr
    )
{
    switch (pnmhdr->code) {

    case TTN_NEEDTEXT:
        {
            LPTOOLTIPTEXT   lpTt;

            lpTt = (LPTOOLTIPTEXT)pnmhdr;
            LoadString( hInst, (UINT) lpTt->hdr.idFrom, lpTt->szText,
                        sizeof(lpTt->szText) );
        }
        break;
    }

    return 0;
}




/*****************************Private*Routine******************************\
* VideoCd_OnMenuSelect
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnMenuSelect(
    HWND hwnd,
    HMENU hmenu,
    int item,
    HMENU hmenuPopup,
    UINT flags
    )
{

    TCHAR szString[STR_MAX_STRING_LEN + 1];

    /*
    ** Is it time to end the menu help ?
    */

    if ( (flags == 0xFFFFFFFF) && (hmenu == NULL) ) {

        SendMessage(g_hwndStatusbar, SB_SIMPLE, 0, 0L);
    }

    /*
    ** Do we have a separator, popup or the system menu ?
    */
    else if ( flags & MF_POPUP ) {

        SendMessage(g_hwndStatusbar, SB_SIMPLE, 0, 0L);
    }

    else if (flags & MF_SYSMENU) {

        switch (item) {

        case SC_RESTORE:
            lstrcpy( szString, IdStr(STR_SYSMENU_RESTORE) );
            break;

        case SC_MOVE:
            lstrcpy( szString, IdStr(STR_SYSMENU_MOVE) );
            break;

        case SC_MINIMIZE:
            lstrcpy( szString, IdStr(STR_SYSMENU_MINIMIZE) );
            break;

        case SC_MAXIMIZE:
            lstrcpy( szString, IdStr(STR_SYSMENU_MAXIMIZE) );
            break;

        case SC_TASKLIST:
            lstrcpy( szString, IdStr(STR_SYSMENU_TASK_LIST) );
            break;

        case SC_CLOSE:
            lstrcpy( szString, IdStr(STR_SYSMENU_CLOSE) );
            break;
        }

        SendMessage( g_hwndStatusbar, SB_SETTEXT, SBT_NOBORDERS|255,
                     (LPARAM)(LPTSTR)szString );
        SendMessage( g_hwndStatusbar, SB_SIMPLE, 1, 0L );
        UpdateWindow(g_hwndStatusbar);

    }

    /*
    ** Hopefully its one of ours
    */
    else {

        if ((flags & MF_SEPARATOR)) {

            szString[0] = g_chNULL;
        }
        else {

            lstrcpy( szString, IdStr(item + MENU_STRING_BASE) );

        }

        SendMessage( g_hwndStatusbar, SB_SETTEXT, SBT_NOBORDERS|255,
                     (LPARAM)(LPTSTR)szString );
        SendMessage( g_hwndStatusbar, SB_SIMPLE, 1, 0L );
        UpdateWindow(g_hwndStatusbar);
    }
}

/*****************************Private*Routine******************************\
* VideoCd_OnDropFiles
*
* -- handle a file-manager drop of a filename to indicate a movie we should
*    open.
*
*
* History:
* 22-01-96 - GeraintD - Created
*
\**************************************************************************/
void
VideoCd_OnDropFiles(
    HWND hwnd,
    HDROP hdrop)
{
    // if there is more than one file, simply open the first one

    // find the length of the path (plus the null
    int cch = DragQueryFile(hdrop, 0, NULL, 0) + 1;
    TCHAR * pName = new TCHAR[cch];

    DragQueryFile(hdrop, 0, pName, cch);

    // open the file
    ProcessOpen(pName);

    // update the toolbar state
    SetPlayButtonsEnableState();

    // free up used resources
    delete [] pName;
    DragFinish(hdrop);
}


/******************************Public*Routine******************************\
* SetPlayButtonsEnableState
*
* Sets the play buttons enable state to match the state of the current
* cdrom device.  See below...
*
*
*                 VCD Player buttons enable state table
* Ŀ
* E=Enabled D=Disabled       Play  Pause  Eject  Stop   Other 
* Ĵ
* Disk in use                 D     D      D       D      D   
* Ĵ
* No video cd or data cdrom   D     D      E       D      D   
* Ĵ
* Video cd (playing)          D     E      E       E      E   
* Ĵ
* Video cd (paused)           E     D      E       E      E   
* Ĵ
* Video cd (stopped)          E     D      E       D      E   
* 
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
SetPlayButtonsEnableState(
    void
    )
{
    BOOL    fEnable, fPress;
    BOOL    fVideoCdLoaded;

    /*
    ** Do we have a video cd loaded.
    */
    if (g_State & (VCD_NO_CD | VCD_DATA_CD_LOADED | VCD_IN_USE)) {
        fVideoCdLoaded = FALSE;
    }
    else {
        fVideoCdLoaded = TRUE;
    }


    /*
    ** Do the play button
    */
    if ( fVideoCdLoaded
      && ((g_State & VCD_STOPPED) || (g_State & VCD_PAUSED))) {

        fEnable = TRUE;
    }
    else {
        fEnable = FALSE;
    }
    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON, IDM_MOVIE_PLAY, fEnable );


    /*
    ** Do the stop button
    */
    if ( fVideoCdLoaded
      && ((g_State & VCD_PLAYING) || (g_State & VCD_PAUSED))) {

        fEnable = TRUE;
    }
    else {
        fEnable = FALSE;
    }
    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON, IDM_MOVIE_STOP, fEnable );


    /*
    ** Do the pause button
    */
    if ( fVideoCdLoaded && (g_State & VCD_PLAYING) ) {
        fEnable = TRUE;
    }
    else {
        fEnable = FALSE;
    }
    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON, IDM_MOVIE_PAUSE, fEnable );


    fEnable = FALSE;
    if (fVideoCdLoaded && pMpegMovie->CanMovieFrameStep()) {
        if (!(g_State & VCD_STEPPING)) {
            fEnable = TRUE;
        }
    }
    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON, IDM_MOVIE_STEP, fEnable );
    /*
    ** Do the remaining buttons
    */

    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON,
                 IDM_MOVIE_SKIP_FORE, fVideoCdLoaded );

    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON,
                 IDM_MOVIE_SKIP_BACK, fVideoCdLoaded );

    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON,
                 IDM_MOVIE_NEXTTRACK, fVideoCdLoaded );

    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON,
                 IDM_MOVIE_PREVTRACK, fVideoCdLoaded );


    /*
    ** Do the fullscreen button
    */
    if ( fVideoCdLoaded && pMpegMovie->IsFullScreenMode() ) {
        fPress = TRUE;
    }
    else {
        fPress = FALSE;
    }
    SendMessage( g_hwndToolbar, TB_CHECKBUTTON, IDM_FULL_SCREEN, MAKELONG(fPress,0) );
    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON, IDM_FULL_SCREEN, fVideoCdLoaded );


    //
    // do "new log" and "dump log" buttons
    //
    SendMessage( g_hwndToolbar, TB_HIDEBUTTON,
                 IDM_PERF_NEW, lpControlProc == NULL);

    SendMessage( g_hwndToolbar, TB_HIDEBUTTON,
                 IDM_PERF_DUMP, lpDumpProc == NULL);
}


/*****************************Private*Routine******************************\
* GetAdjustedClientRect
*
* Calculate the size of the client rect and then adjusts it to take into
* account the space taken by the toolbar and status bar.
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
GetAdjustedClientRect(
    RECT *prc
    )
{
    RECT    rcTool;

    GetClientRect(hwndApp, prc);

    GetWindowRect(g_hwndToolbar, &rcTool);
    prc->top += (rcTool.bottom - rcTool.top);

    GetWindowRect(g_hwndTrackbar, &rcTool);
    prc->top += (rcTool.bottom - rcTool.top);

    GetWindowRect(g_hwndStatusbar, &rcTool);
    prc->bottom -= (rcTool.bottom - rcTool.top);
}


/******************************Public*Routine******************************\
* IdStr
*
* Loads the given string resource ID into the passed storage.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
LPCTSTR
IdStr(
    int idResource
    )
{
    static TCHAR    chBuffer[ STR_MAX_STRING_LEN ];

    if (LoadString(hInst, idResource, chBuffer, STR_MAX_STRING_LEN) == 0) {
        return g_szEmpty;
    }

    return chBuffer;

}

/*+ GetAppKey
 *
 *-=================================================================*/

static TCHAR cszWindow[] = TEXT("Window");
static TCHAR cszAppKey[] = TEXT("Software\\Microsoft\\Multimedia Tools\\VCDPlayer");

HKEY
GetAppKey(
    BOOL fCreate
    )
{
    HKEY hKey = 0;

    if (fCreate) {
       if (RegCreateKey(HKEY_CURRENT_USER, cszAppKey, &hKey) == ERROR_SUCCESS)
          return hKey;
    }
    else {
       if (RegOpenKey(HKEY_CURRENT_USER, cszAppKey, &hKey) == ERROR_SUCCESS)
          return hKey;
    }

    return NULL;
}

/*+ ProfileIntIn
 *
 *-=================================================================*/

int
ProfileIntIn(
    const TCHAR *szKey,
    int iDefault
    )
{
    DWORD dwType;
    int   iValue;
    BYTE  aData[20];
    DWORD cb;
    HKEY  hKey;

    if (!(hKey = GetAppKey(TRUE))) {
        return iDefault;
    }

    *(UINT *)&aData = 0;
    cb = sizeof(aData);

    if (RegQueryValueEx (hKey, szKey, NULL, &dwType, aData, &cb)) {
       iValue = iDefault;
    }
    else {

        if (dwType == REG_DWORD || dwType == REG_BINARY) {
            iValue = *(int *)&aData;
        }
        else if (dwType == REG_SZ) {
            iValue = atoi((LPSTR)aData);
        }
    }

    RegCloseKey (hKey);
    return iValue;
}


/*+ ProfileIntOut
 *
 *-=================================================================*/

BOOL
ProfileIntOut (
    const TCHAR *szKey,
    int iVal
    )
{
    HKEY  hKey;
    BOOL  bRet = FALSE;

    hKey = GetAppKey(TRUE);
    if (hKey) {
        RegSetValueEx(hKey, szKey, 0, REG_DWORD, (LPBYTE)&iVal, sizeof(DWORD));
        RegCloseKey (hKey);
        bRet = TRUE;
    }
    return bRet;
}


/*+ ProfileString
 *
 *-=================================================================*/

UINT
ProfileStringIn (
    LPTSTR  szKey,
    LPTSTR  szDef,
    LPTSTR  sz,
    DWORD   cb
    )
{
    HKEY  hKey;
    DWORD dwType;

    if (!(hKey = GetAppKey (FALSE)))
    {
        lstrcpy (sz, szDef);
        return lstrlen (sz);
    }

    if (RegQueryValueEx(hKey, szKey, NULL, &dwType, (LPBYTE)sz, &cb) || dwType != REG_SZ)
    {
        lstrcpy (sz, szDef);
        cb = lstrlen (sz);
    }

    RegCloseKey (hKey);
    return cb;
}

void
ProfileStringOut (
    LPTSTR  szKey,
    LPTSTR  sz
    )
{
    HKEY  hKey;

    hKey = GetAppKey(TRUE);
    if (hKey)
        RegSetValueEx(hKey, szKey, 0, REG_SZ, (LPBYTE)sz,
                      sizeof(TCHAR) * (lstrlen(sz)+1));

    RegCloseKey (hKey);
}


/*+ LoadWindowPos
 *
 * retrieve the window position information from dragn.ini
 *
 *-=================================================================*/

#ifndef SPI_GETWORKAREA
 #define SPI_GETWORKAREA 48  // because NT doesnt have this define yet
#endif

BOOL
LoadWindowPos(
    LPRECT lprc
    )
{
    static RECT rcDefault = {0,0,CX_DEFAULT * 2,CY_DEFAULT * 4};
    RECT  rcScreen;
    RECT  rc;
    HKEY  hKey = GetAppKey(FALSE);

    // read window placement from the registry.
    //
    *lprc = rcDefault;
    if (hKey)
    {
        DWORD cb;
        DWORD dwType;

        cb = sizeof(rc);
        if ( ! RegQueryValueEx(hKey, cszWindow, NULL, &dwType, (LPBYTE)&rc, &cb)
            && dwType == REG_BINARY && cb == sizeof(RECT))
        {
            *lprc = rc;
        }

        RegCloseKey (hKey);
    }

    // if we fail to get the working area (screen-tray), then assume
    // the screen is 640x480
    //
    if ( ! SystemParametersInfo(SPI_GETWORKAREA, 0, &rcScreen, FALSE))
    {
        rcScreen.top = rcScreen.left = 0;
        rcScreen.right = 640;
        rcScreen.bottom = 480;
    }

    // if the proposed window position is outside the screen,
    // use the default placement
    //
    if ( ! IntersectRect(&rc, &rcScreen, lprc)) {
        *lprc = rcDefault;
    }

    return ! IsRectEmpty (lprc);
}


/*+ SaveWindowPos
 *
 * store the window position information in dragn.ini
 *
 *-=================================================================*/

BOOL
SaveWindowPos(
    HWND hwnd
    )
{
    WINDOWPLACEMENT wpl;
    HKEY  hKey = GetAppKey(TRUE);

    if (!hKey) {
       return FALSE;
    }

    // save the current size and position of the window to the registry
    //
    ZeroMemory (&wpl, sizeof(wpl));
    wpl.length = sizeof(wpl);
    GetWindowPlacement (hwnd, &wpl);


    RegSetValueEx( hKey, cszWindow, 0, REG_BINARY,
                   (LPBYTE)&wpl.rcNormalPosition,
                   sizeof(wpl.rcNormalPosition));

    RegCloseKey (hKey);
    return TRUE;
}


/*****************************Private*Routine******************************\
* GetRecentFiles
*
* Reads at most MAX_RECENT_FILES from vcdplyer.ini. Returns the number
* of files actually read.  Updates the File menu to show the "recent" files.
*
* History:
* 26-10-95 - StephenE - Created
*
\**************************************************************************/
int
GetRecentFiles(
    int iLastCount
    )
{
    int     i;
    TCHAR   FileName[MAX_PATH];
    TCHAR   szKey[32];
    HMENU   hSubMenu;

    //
    // Delete the files from the menu
    //
    hSubMenu = GetSubMenu(GetMenu(hwndApp), 0);

    // Delete the separator at slot 3 and all the other recent file entries

    if (iLastCount != 0) {
        DeleteMenu(hSubMenu, 3, MF_BYPOSITION);

        for (i = 1; i <= iLastCount; i++) {
            DeleteMenu(hSubMenu, ID_RECENT_FILE_BASE + i, MF_BYCOMMAND);
        }
    }


    for (i = 1; i <= MAX_RECENT_FILES; i++) {

        DWORD   len;
        TCHAR   szMenuName[MAX_PATH + 3];

        wsprintf(szKey, TEXT("File %d"), i);
        len = ProfileStringIn(szKey, TEXT(""), FileName, MAX_PATH * sizeof(TCHAR));
        if (len == 0) {
            i = i - 1;
            break;
        }

        lstrcpy(aRecentFiles[i - 1], FileName);
        wsprintf(szMenuName, TEXT("&%d %s"), i, FileName);

        if (i == 1) {
            InsertMenu(hSubMenu, 3, MF_SEPARATOR | MF_BYPOSITION, (UINT)-1, NULL );
        }

        InsertMenu(hSubMenu, 3 + i, MF_STRING | MF_BYPOSITION,
                   ID_RECENT_FILE_BASE + i, szMenuName );
    }

    //
    // i is the number of recent files in the array.
    //
    return i;
}


/*****************************Private*Routine******************************\
* SetRecentFiles
*
* Writes the most recent files to the vcdplyer.ini file.  Purges the oldest
* file if necessary.
*
* History:
* 26-10-95 - StephenE - Created
*
\**************************************************************************/
int
SetRecentFiles(
    TCHAR *FileName,    // File name to add
    int iCount          // Current count of files
    )
{
    TCHAR   FullPathFileName[MAX_PATH];
    TCHAR   *lpFile;
    TCHAR   szKey[32];
    int     iCountNew;
    int     i;

    //
    // Check for dupes - we don't allow them !
    //
    for (i = 0; i < iCount; i++) {
        if (0 == lstrcmpi(FileName, aRecentFiles[i])) {
            return iCount;
        }
    }

    //
    // Throw away the oldest entry
    //
    MoveMemory(&aRecentFiles[1], &aRecentFiles[0],
               sizeof(aRecentFiles) - sizeof(aRecentFiles[1]));

    //
    // Copy in the full path of the new file.
    //
    GetFullPathName(FileName, MAX_PATH, FullPathFileName, &lpFile);
    lstrcpy(aRecentFiles[0], FullPathFileName);

    //
    // Update the count of files, saturate to MAX_RECENT_FILES.
    //
    iCountNew = min(iCount + 1, MAX_RECENT_FILES);

    //
    // Clear the old stuff and the write out the recent files to disk
    //
    for (i = 1; i <= iCountNew; i++) {
        wsprintf(szKey, TEXT("File %d"), i);
        ProfileStringOut(szKey, aRecentFiles[i - 1]);
    }

    //
    // Update the file menu
    //
    GetRecentFiles(iCount);

    return iCountNew;  // the updated count of files.
}

/*****************************Private*Routine******************************\
* SetDurationLength
*
* Updates pane 0 on the status bar
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
void
SetDurationLength(
    REFTIME rt
    )
{
    TCHAR   szFmt[64];
    TCHAR   sz[64];

    g_TrackBarScale = 1.0;
    while (rt / g_TrackBarScale > 30000) {
        g_TrackBarScale *= 10;
    }

    SendMessage(g_hwndTrackbar, TBM_SETRANGE, TRUE,
                MAKELONG(0, (WORD)(rt / g_TrackBarScale)));

    SendMessage(g_hwndTrackbar, TBM_SETTICFREQ, (WPARAM)((int)(rt / g_TrackBarScale) / 9), 0);
    SendMessage(g_hwndTrackbar, TBM_SETPAGESIZE, 0, (LPARAM)((int)(rt / g_TrackBarScale) / 9));

    wsprintf(sz, TEXT("Length: %s"), FormatRefTime(szFmt, rt));
    SendMessage(g_hwndStatusbar, SB_SETTEXT, 0, (LPARAM)sz);
}


/*****************************Private*Routine******************************\
* SetCurrentPosition
*
* Updates pane 1 on the status bar
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
void
SetCurrentPosition(
    REFTIME rt
    )
{
    TCHAR   szFmt[64];
    TCHAR   sz[64];

    SendMessage(g_hwndTrackbar, TBM_SETPOS, TRUE, (LPARAM)(rt / g_TrackBarScale));

    wsprintf(sz, TEXT("Elapsed: %s"), FormatRefTime(szFmt, rt));
    SendMessage(g_hwndStatusbar, SB_SETTEXT, 1, (LPARAM)sz);
}


/*****************************Private*Routine******************************\
* FormatRefTime
*
* Formats the given RefTime into the passed in character buffer,
* returns a pointer to the character buffer.
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
TCHAR *
FormatRefTime(
    TCHAR *sz,
    REFTIME rt
    )
{
    // If we are not seeking in time then format differently

    if (pMpegMovie && pMpegMovie->GetTimeFormat() != TIME_FORMAT_MEDIA_TIME) {
        wsprintf(sz,TEXT("%s"),(LPCTSTR) CDisp ((LONGLONG) rt,CDISP_DEC));
        return sz;
    }

    int hrs, mins, secs;

    rt += 0.49;

    hrs  =  (int)rt / 3600;
    mins = ((int)rt % 3600) / 60;
    secs = ((int)rt % 3600) % 60;

    wsprintf(sz, TEXT("%02d:%02d:%02d h:m:s"),hrs, mins, secs);

#if 0
#ifdef UNICODE
    swprintf(sz, L"%02d:%02d:%02d h:m:s", rt);
#else
    sprintf(sz, "%02d:%02d:%02d h:m:s", hrs, mins, secs);
#endif
#endif


    return sz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vmrplyer\makefile.inc ===
# NOTE:
# this directory contains a makefile which contains a single line that
# includes the global build process makefile.def. If the
# NTTARGETFILE1 or NTTARGETFILE0 environment
# variable is set then makefile.def includes makefile.inc from the current
# directory. This makefile.inc creates an extra target for nmake to create
# when it is run. NTTARGETFILE0 is built before everything else, and
# NTTARGETFILE1 is built after everything else.

copyfiles:
  @if exist obj\$(TARGET_DIRECTORY)\$(TARGETNAME).exe  \
    copy obj\$(TARGET_DIRECTORY)\$(TARGETNAME).exe     \
         $(SDK_ROOT)\bin\$(DBG_RTL)\*.*


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\video\vmrmacvis.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
//
// VRMacVis.cpp:  Video Renderer's Macrovision support code
//

#include <streams.h>
#include <windowsx.h>
#include "vmrenderer.h"

// The magic GUID for Macrovision etc enabling (from winuser.h). It has
// not been given a name there and so is used here directly.
//
static const GUID guidVidParam =
    {0x2c62061, 0x1097, 0x11d1, {0x92, 0xf, 0x0, 0xa0, 0x24, 0xdf, 0x15, 0x6e}} ;

CVMRRendererMacroVision::CVMRRendererMacroVision(void) :
    m_dwCPKey(0),
    m_hMon(NULL)
{
    DbgLog((LOG_TRACE, 5, TEXT("CVMRRendererMacroVision::CVMRRendererMacroVision()"))) ;
}


CVMRRendererMacroVision::~CVMRRendererMacroVision(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CVMRRendererMacroVision::~CVMRRendererMacroVision()"))) ;
    ASSERT(0 == m_dwCPKey  &&  NULL == m_hMon) ;
}


BOOL
CVMRRendererMacroVision::StopMacroVision()
{
    if (0 == m_dwCPKey)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Copy prot key was not acquired. Nothing to release."))) ;
        return TRUE ;  // success, what else?
    }

    if (NULL == m_hMon)
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: No GUID available while MV bit was already set."))) ;
        return TRUE ;  // FALSE??
    }

    LONG             lRet ;
    VIDEOPARAMETERS  VidParams ;
    DEVMODE          DevMode ;
    DISPLAY_DEVICE   dd ;
    ZeroMemory(&dd, sizeof(dd)) ;
    dd.cb = sizeof(dd) ;

    HMONITOR hMon = m_hMon;
    if (NULL == hMon)
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("MonitorFromWindow(0x%p, ..) returned NULL (Error: %ld)"),
                (void *)m_hMon, GetLastError())) ;
        return FALSE ;
    }

    MONITORINFOEX  mi ;
    mi.cbSize = sizeof(mi) ;
    if (! GetMonitorInfo(hMon, &mi) )
    {
        DbgLog((LOG_ERROR, 0, TEXT("GetMonitorInfo() failed (Error: %ld)"),
                GetLastError())) ;
        return FALSE ;
    }
    DbgLog((LOG_TRACE, 3, TEXT("DeviceName: '%s'"), mi.szDevice)) ;
    ZeroMemory(&DevMode, sizeof(DevMode)) ;
    DevMode.dmSize = sizeof(DevMode) ;

    ZeroMemory(&VidParams, sizeof(VidParams)) ;
    VidParams.Guid      = guidVidParam ;
    VidParams.dwCommand = VP_COMMAND_GET ;

    lRet = ChangeDisplaySettingsEx(mi.szDevice, &DevMode, NULL,
                                   CDS_VIDEOPARAMETERS | CDS_NORESET | CDS_UPDATEREGISTRY,
                                   &VidParams) ;
    if (DISP_CHANGE_SUCCESSFUL != lRet)
    {
        DbgLog((LOG_ERROR, 0, TEXT("ChangeDisplaySettingsEx(_GET) failed (%ld)"), lRet)) ;
        return FALSE ;
    }

    if (! ( (VidParams.dwFlags & VP_FLAGS_COPYPROTECT) &&
            (VidParams.dwCPType & VP_CP_TYPE_APS_TRIGGER) &&
            (VidParams.dwTVStandard & VidParams.dwCPStandard) ) )
    {
        // How did we acquire CP key in teh first place?
        DbgLog((LOG_ERROR, 0,
            TEXT("Copy prot weird error case (dwFlags=0x%lx, dwCPType=0x%lx, dwTVStandard=0x%lx, dwCPStandard=0x%lx"),
                VidParams.dwFlags, VidParams.dwCPType, VidParams.dwTVStandard, VidParams.dwCPStandard)) ;
        return FALSE ;
    }

    VidParams.dwCommand    = VP_COMMAND_SET ;
    VidParams.dwFlags      = VP_FLAGS_COPYPROTECT ;
    VidParams.dwCPType     = VP_CP_TYPE_APS_TRIGGER ;
    VidParams.dwCPCommand  = VP_CP_CMD_DEACTIVATE ;
    VidParams.dwCPKey      = m_dwCPKey ;
    VidParams.bCP_APSTriggerBits = (BYTE) 0 ;  // some value
    lRet = ChangeDisplaySettingsEx(mi.szDevice, &DevMode, NULL,
                                   CDS_VIDEOPARAMETERS | CDS_NORESET | CDS_UPDATEREGISTRY,
                                   &VidParams) ;
    if (DISP_CHANGE_SUCCESSFUL != lRet)
    {
        DbgLog((LOG_ERROR, 0, TEXT("ChangeDisplaySettingsEx() failed (%ld)"), lRet)) ;
        return FALSE ;
    }

    DbgLog((LOG_TRACE, 1, TEXT("Macrovision deactivated on key %lu"), m_dwCPKey)) ;
    m_hMon  = NULL ;
    m_dwCPKey = 0 ;     // no CP set now

    return TRUE ;
}


//
// This function applies Macrovision based on the input parameter dwCPBits.
// hWnd is the handle of the window in which content is played back.
//
// Returns TRUE on success and FALSE on any failure.
//
BOOL
CVMRRendererMacroVision::SetMacroVision(
    HMONITOR hMon,
    DWORD dwCPBits
    )
{
    DbgLog((LOG_TRACE, 5, TEXT("CVMRRendererMacroVision::SetMacroVision(0x%p, 0x%lx)"),
            (LPVOID)hMon, dwCPBits)) ;

    //
    // If MV is currently not set at all and the new CP bits is 0 (which happens
    // when from the Nav we reset the MV bits on start / stop of playback), we
    // don't really need to do anything -- MV not started and doesn't need to be
    // started.  So just leave queitly...
    //
    if (0 == m_dwCPKey  &&  // no key acquired so far
        0 == dwCPBits)      // MV CPBits is 0
    {
        DbgLog((LOG_TRACE, 1, TEXT("Copy prot is not enabled now and new CP bits is 0 -- so skip it."))) ;
        return TRUE ;  // we don't need to do anything, so success.
    }

    //
    // May be we need to actually do something here
    //
    LONG             lRet ;
    VIDEOPARAMETERS  VidParams ;
    DEVMODE          DevMode ;
    DISPLAY_DEVICE   dd ;
    ZeroMemory(&dd, sizeof(dd)) ;
    dd.cb = sizeof(dd) ;

    if (NULL == hMon)
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("MonitorFromWindow(0x%p, ..) returned NULL (Error: %ld)"),
                (void*)hMon, GetLastError())) ;
        return FALSE ;
    }

    MONITORINFOEX  mi ;
    mi.cbSize = sizeof(mi) ;
    if (! GetMonitorInfo(hMon, &mi) )
    {
        DbgLog((LOG_ERROR, 0, TEXT("GetMonitorInfo() failed (Error: %ld)"),
                GetLastError())) ;
        return FALSE ;
    }
    DbgLog((LOG_TRACE, 3, TEXT("DeviceName: '%s'"), mi.szDevice)) ;

    ZeroMemory(&DevMode, sizeof(DevMode)) ;
    DevMode.dmSize = sizeof(DevMode) ;

    ZeroMemory(&VidParams, sizeof(VidParams)) ;
    VidParams.Guid      = guidVidParam ;
    VidParams.dwCommand = VP_COMMAND_GET ;

    lRet = ChangeDisplaySettingsEx(mi.szDevice, &DevMode, NULL,
                                   CDS_VIDEOPARAMETERS | CDS_NORESET | CDS_UPDATEREGISTRY,
                                   &VidParams) ;
    if (DISP_CHANGE_SUCCESSFUL != lRet)
    {
        DbgLog((LOG_ERROR, 0, TEXT("ChangeDisplaySettingsEx(_GET) failed (%ld)"), lRet)) ;
        return FALSE ;
    }

    if (0 == VidParams.dwFlags ||
        VP_TV_STANDARD_WIN_VGA == VidParams.dwTVStandard)
    {
        DbgLog((LOG_TRACE, 1, TEXT("** Copy protection NOT required (dwFlags=0x%lx, dwTVStandard=0x%lx"),
                VidParams.dwFlags, VidParams.dwTVStandard));
        return TRUE ;
    }

    //
    // Check to see if
    // a) the device supports copy prot
    // b) CP type is APS trigger
    // c) current TV standard and CP standard have commonality.
    // If so, apply copy prot. Otherwise error.
    //
    if ( (VidParams.dwFlags & VP_FLAGS_COPYPROTECT) &&
         (VidParams.dwCPType & VP_CP_TYPE_APS_TRIGGER) &&
         (VidParams.dwTVStandard & VidParams.dwCPStandard) )
    {
        DbgLog((LOG_TRACE, 3,
            TEXT("** Copy prot needs to be applied (dwFlags=0x%lx, dwCPType=0x%lx, dwTVStandard=0x%lx, dwCPStandard=0x%lx"),
                VidParams.dwFlags, VidParams.dwCPType, VidParams.dwTVStandard, VidParams.dwCPStandard)) ;

        VidParams.dwCommand = VP_COMMAND_SET ;          // do we have to set it again??
        VidParams.dwFlags   = VP_FLAGS_COPYPROTECT ;
        VidParams.dwCPType  = VP_CP_TYPE_APS_TRIGGER ;
        VidParams.bCP_APSTriggerBits = (BYTE) (dwCPBits & 0xFF) ;

        // Check if we already have a copy prot key; if not, get one now
        if (0 == m_dwCPKey)  // no key acquired so far
        {
            // Acquire a new key (that also aplies it, so no separate Set reqd)
            VidParams.dwCPCommand = VP_CP_CMD_ACTIVATE ;
            VidParams.dwCPKey     = 0 ;
            lRet = ChangeDisplaySettingsEx(mi.szDevice, &DevMode, NULL,
                                           CDS_VIDEOPARAMETERS | CDS_NORESET | CDS_UPDATEREGISTRY,
                                           &VidParams) ;
            if (DISP_CHANGE_SUCCESSFUL != lRet)
            {
                DbgLog((LOG_ERROR, 0,
                    TEXT("** ChangeDisplaySettingsEx() failed (%ld) to activate copy prot"), lRet)) ;
                return FALSE ;
            }

            m_dwCPKey = VidParams.dwCPKey ;
            DbgLog((LOG_TRACE, 3, TEXT("** Copy prot activated. Key value is %lu"), m_dwCPKey)) ;
        }
        else  // key already acquired
        {
            // apply the copy prot bits specified in the content
            VidParams.dwCPCommand = VP_CP_CMD_CHANGE ;
            VidParams.dwCPKey     = m_dwCPKey ;
            DbgLog((LOG_TRACE, 5, TEXT("** Going to call ChangeDisplaySettingsEx(_SET)..."))) ;
            lRet = ChangeDisplaySettingsEx(mi.szDevice, &DevMode, NULL,
                                           CDS_VIDEOPARAMETERS | CDS_NORESET | CDS_UPDATEREGISTRY,
                                           &VidParams) ;
            if (DISP_CHANGE_SUCCESSFUL != lRet)
            {
                DbgLog((LOG_ERROR, 0,
                    TEXT("** ChangeDisplaySettingsEx() failed (%ld) to set copy prot bits (%lu)"),
                    lRet, dwCPBits)) ;
                return FALSE ;
            }
            else
                DbgLog((LOG_TRACE, 3, TEXT("** Copy prot bits (0x%lx) applied"), dwCPBits)) ;
        }
    }
    else
    {
        DbgLog((LOG_ERROR, 0,
            TEXT("** Copy prot error case (dwFlags=0x%lx, dwCPType=0x%lx, dwTVStandard=0x%lx, dwCPStandard=0x%lx"),
                VidParams.dwFlags, VidParams.dwCPType, VidParams.dwTVStandard, VidParams.dwCPStandard)) ;
        return FALSE ;
    }

    m_hMon = hMon;

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vmrplyer\project.h ===
/******************************Module*Header*******************************\
* Module Name: project.h
*
*  Master header file that includes all the other header files used by the
* project.  This enables compiled headers to work using build.
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1996  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/

#include "app.h"
#include "vcdplyer.h"
#include "resource.h"


void InitStreamParams(int i);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vmrplyer\commands.cpp ===
/******************************Module*Header*******************************\
* Module Name: commands.cpp
*
*  Processes commands from the user.
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/
#include <streams.h>
#include <mmreg.h>
#include <commctrl.h>

#include "project.h"
// #include "mpgcodec.h"
#include <stdio.h>


BOOL GetAMErrorText(HRESULT hr, TCHAR *Buffer, DWORD dwLen);

extern CMpegMovie *pMpegMovie;

typedef     LPBITMAPINFOHEADER PDIB;

#define BFT_BITMAP 0x4d42   /* 'BM' */
#define DibNumColors(lpbi)      ((lpbi)->biClrUsed == 0 && (lpbi)->biBitCount <= 8 \
                                    ? (int)(1 << (int)(lpbi)->biBitCount)          \
                                    : (int)(lpbi)->biClrUsed)

#define DibSize(lpbi)           ((lpbi)->biSize + (lpbi)->biSizeImage + (int)(lpbi)->biClrUsed * sizeof(RGBQUAD))

#define DibPaletteSize(lpbi)    (DibNumColors(lpbi) * sizeof(RGBQUAD))


/******************************Public*Routine******************************\
* VcdPlyerCaptureImage
*
*
*
* History:
* Tue 01/02/2001 - StEstrop - Created
*
\**************************************************************************/
BOOL
VcdPlyerCaptureImage(
    LPCSTR szFile
    )
{
    if (pMpegMovie) {

        BYTE* lpCurrImage = NULL;

        if (pMpegMovie->GetCurrentImage(&lpCurrImage) == S_OK) {

            BITMAPFILEHEADER    hdr;
            HFILE               fh;
            OFSTRUCT            of;
            DWORD               dwSize;
            PDIB                pdib = (PDIB)lpCurrImage;

            fh = OpenFile(szFile,&of,OF_CREATE|OF_READWRITE);

            if (fh == -1)
                return FALSE;

            dwSize = DibSize(pdib);

            hdr.bfType          = BFT_BITMAP;
            hdr.bfSize          = dwSize + sizeof(BITMAPFILEHEADER);
            hdr.bfReserved1     = 0;
            hdr.bfReserved2     = 0;
            hdr.bfOffBits       = (DWORD)sizeof(BITMAPFILEHEADER) + pdib->biSize +
                                  DibPaletteSize(pdib);

            _lwrite(fh,(LPCSTR)(LPVOID)&hdr,sizeof(BITMAPFILEHEADER));
            _hwrite(fh,(LPCSTR)(LPVOID)pdib,dwSize);

            _lclose(fh);

            CoTaskMemFree(lpCurrImage);
            return TRUE;
        }
    }

    return FALSE;

}



/******************************Public*Routine******************************\
* VcdPlayerOpenCmd
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
VcdPlayerOpenCmd(
    int strmID
    )
{
    static BOOL fFirstTime = TRUE;
    BOOL fRet;
    TCHAR achFileName[MAX_PATH];
    TCHAR achFilter[MAX_PATH];
    LPTSTR lp;

    if (fFirstTime) {

        ofn.lStructSize = sizeof(ofn);
        ofn.hwndOwner = hwndApp;
        ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST |
                    OFN_SHAREAWARE | OFN_PATHMUSTEXIST;
    }

    lstrcpy(achFilter, IdStr(STR_FILE_FILTER) );
    ofn.lpstrFilter = achFilter;

    /*
    ** Convert the resource string into to something suitable for
    ** GetOpenFileName ie.  replace '#' characters with '\0' characters.
    */
    for (lp = achFilter; *lp; lp++ ) {
        if (*lp == TEXT('#')) {
            *lp = TEXT('\0');
        }
    }

    ofn.lpstrFile = achFileName;
    ofn.nMaxFile = sizeof(achFileName) / sizeof(TCHAR);
    ZeroMemory(achFileName, sizeof(achFileName));

    fRet = GetOpenFileName(&ofn);
    if ( fRet ) {

        if (strmID == 0) {
            fFirstTime = FALSE;
            ProcessOpen(achFileName);
        }
        else {
            if (pMpegMovie) {
                pMpegMovie->RenderSecondFile(achFileName);
            }
        }

        InitStreamParams(strmID);

    }

    return fRet;
}



/******************************Public*Routine******************************\
* VcdPlayerSetLog
*
*
*
* History:
* 11-04-94 - LaurieGr - Created
*
\**************************************************************************/
BOOL
VcdPlayerSetLog(
    void
    )
{

    BOOL fRet;
    TCHAR achFileName[MAX_PATH];
    TCHAR achFilter[MAX_PATH];
    LPTSTR lp;
    OPENFILENAME opfn;

    ZeroMemory(&opfn, sizeof(opfn));

    opfn.lStructSize = sizeof(opfn);
    opfn.hwndOwner = hwndApp;
    opfn.Flags = OFN_HIDEREADONLY | OFN_SHAREAWARE | OFN_PATHMUSTEXIST;

    lstrcpy(achFilter, IdStr(STR_FILE_LOG_FILTER) );
    opfn.lpstrFilter = achFilter;

    /*
    ** Convert the resource string into to something suitable for
    ** GetOpenFileName ie.  replace '#' characters with '\0' characters.
    */
    for (lp = achFilter; *lp; lp++ ) {
        if (*lp == TEXT('#')) {
            *lp = TEXT('\0');
        }
    }

    opfn.lpstrFile = achFileName;
    opfn.nMaxFile = sizeof(achFileName) / sizeof(TCHAR);
    ZeroMemory(achFileName, sizeof(achFileName));

    fRet = GetOpenFileName(&opfn);
    if ( fRet ) {
        hRenderLog = CreateFile( achFileName
                               , GENERIC_WRITE
                               , 0    // no sharing
                               , NULL // no security
                               , OPEN_ALWAYS
                               , 0    // no attributes, no flags
                               , NULL // no template
                               );
        if (hRenderLog==INVALID_HANDLE_VALUE) {
            volatile int Err = GetLastError();
            fRet = FALSE;
        }
        // Seek to end of file
        SetFilePointer(hRenderLog, 0, NULL, FILE_END);
    }

    return fRet;
}

/******************************Public*Routine******************************\
* VcdPlayerSetPerfLogFile
*
*
*
* History:
* 30-05-96 - StephenE - Created
*
\**************************************************************************/
BOOL
VcdPlayerSetPerfLogFile(
    void
    )
{

    BOOL fRet;
    TCHAR achFileName[MAX_PATH];
    TCHAR achFilter[MAX_PATH];
    LPTSTR lp;
    OPENFILENAME opfn;

    ZeroMemory(&opfn, sizeof(opfn));

    opfn.lStructSize = sizeof(opfn);
    opfn.hwndOwner = hwndApp;
    opfn.Flags = OFN_HIDEREADONLY | OFN_SHAREAWARE | OFN_PATHMUSTEXIST;

    lstrcpy(achFilter, IdStr(STR_FILE_PERF_LOG) );
    opfn.lpstrFilter = achFilter;

    /*
    ** Convert the resource string into to something suitable for
    ** GetOpenFileName ie.  replace '#' characters with '\0' characters.
    */
    for (lp = achFilter; *lp; lp++ ) {
        if (*lp == TEXT('#')) {
            *lp = TEXT('\0');
        }
    }

    opfn.lpstrFile = achFileName;
    opfn.nMaxFile = sizeof(achFileName) / sizeof(TCHAR);
    lstrcpy(achFileName, g_szPerfLog);

    fRet = GetOpenFileName(&opfn);
    if ( fRet ) {
        lstrcpy(g_szPerfLog, achFileName);
    }

    return fRet;
}



/******************************Public*Routine******************************\
* VcdPlayerCloseCmd
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
VcdPlayerCloseCmd(
    void
    )
{
    if (pMpegMovie) {

        LONG cx, cy;

        g_State = VCD_NO_CD;
        pMpegMovie->GetMoviePosition(&lMovieOrgX, &lMovieOrgY, &cx, &cy);
        pMpegMovie->StopMovie();
        pMpegMovie->CloseMovie();

        SetDurationLength((REFTIME)0);
        SetCurrentPosition((REFTIME)0);

        delete pMpegMovie;
        pMpegMovie = NULL;
    }
    InvalidateRect( hwndApp, NULL, FALSE );
    UpdateWindow( hwndApp );
    return TRUE;
}


/******************************Public*Routine******************************\
* VcdPlayerPlayCmd
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
VcdPlayerPlayCmd(
    void
    )
{
    BOOL fStopped = (g_State & VCD_STOPPED);
    BOOL fPaused  = (g_State & VCD_PAUSED);

    if ( (fStopped || fPaused) ) {

        // HDC hdc;
        // RECT rc;


        //
        // Clear out the old stats from the main window
        //
        // hdc = GetDC(hwndApp);
        // GetAdjustedClientRect(&rc);
        // FillRect(hdc, &rc, (HBRUSH)(COLOR_BTNFACE + 1));
        // ReleaseDC(hwndApp, hdc);

        if (pMpegMovie) {
            pMpegMovie->PlayMovie();
        }

        g_State &= ~(fStopped ? VCD_STOPPED : VCD_PAUSED);
        g_State |= VCD_PLAYING;
    }

    return TRUE;
}


/******************************Public*Routine******************************\
* VcdPlayerPlayCmd
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
VcdPlayerStopCmd(
    void
    )
{
    BOOL fPlaying = (g_State & VCD_PLAYING);
    BOOL fPaused  = (g_State & VCD_PAUSED);

    if ( (fPlaying || fPaused) ) {

        if (pMpegMovie) {
            pMpegMovie->StopMovie();
            pMpegMovie->SetFullScreenMode(FALSE);
            SetCurrentPosition(pMpegMovie->GetCurrentPosition());
        }

        g_State &= ~(fPlaying ? VCD_PLAYING : VCD_PAUSED);
        g_State |= VCD_STOPPED;
    }
    return TRUE;
}


/******************************Public*Routine******************************\
* VcdPlayerStepCmd
*
*
*
* History:
* Wed 10/20/1999 - StEstrop (AKA StephenE) - Created
*
\**************************************************************************/
BOOL
VcdPlayerStepCmd(
    void
    )
{
    if (pMpegMovie) {
        if (pMpegMovie->FrameStepMovie()) {
            g_State |= VCD_STEPPING;
            return TRUE;
        }
    }
    return FALSE;
}


/******************************Public*Routine******************************\
* VcdPlayerPauseCmd
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
VcdPlayerPauseCmd(
    void
    )
{
    BOOL fPlaying = (g_State & VCD_PLAYING);
    BOOL fPaused  = (g_State & VCD_PAUSED);

    if (fPlaying) {

        if (pMpegMovie) {
            pMpegMovie->PauseMovie();
            SetCurrentPosition(pMpegMovie->GetCurrentPosition());
        }

        g_State &= ~VCD_PLAYING;
        g_State |= VCD_PAUSED;
    }
    else if (fPaused) {

        if (pMpegMovie) {
            pMpegMovie->PlayMovie();
        }

        g_State &= ~VCD_PAUSED;
        g_State |= VCD_PLAYING;
    }

    return TRUE;
}

/******************************Public*Routine******************************\
* VcdPlayerSeekCmd
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
VcdPlayerSeekCmd(
    REFTIME rtSeekBy
    )
{
    REFTIME rt;
    REFTIME rtDur;

    rtDur = pMpegMovie->GetDuration();
    rt = pMpegMovie->GetCurrentPosition() + rtSeekBy;

    rt = max(0, min(rt, rtDur));

    pMpegMovie->SeekToPosition(rt,TRUE);
    SetCurrentPosition(pMpegMovie->GetCurrentPosition());
}


extern void RepositionMovie(HWND hwnd);

/******************************Public*Routine******************************\
* ProcessOpen
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
ProcessOpen(
    TCHAR *achFileName,
    BOOL bPlay
    )
{
    /*
    ** If we currently have a video loaded we need to discard it here.
    */
    if ( g_State & VCD_LOADED) {
        VcdPlayerCloseCmd();
    }

    lstrcpy(g_achFileName, achFileName);

    pMpegMovie = new CMpegMovie(hwndApp);
    if (pMpegMovie) {

        HRESULT hr = pMpegMovie->OpenMovie(g_achFileName);
        if (SUCCEEDED(hr)) {

            TCHAR achTmp[MAX_PATH];
            LONG  x, y, cx, cy;

            nRecentFiles = SetRecentFiles(achFileName, nRecentFiles);

            wsprintf( achTmp, IdStr(STR_APP_TITLE_LOADED),
                      g_achFileName );
            g_State = (VCD_LOADED | VCD_STOPPED);

            // SetDurationLength(pMpegMovie->GetDuration());
            g_TimeFormat = VcdPlayerChangeTimeFormat(g_TimeFormat);

            RepositionMovie(hwndApp);
            pMpegMovie->SetBorderClr(RGB(0x00, 0x80, 0x80));

            //  If play
            if (bPlay) {
                pMpegMovie->PlayMovie();
            }
        }
        else {
            TCHAR Buffer[MAX_ERROR_TEXT_LEN];

            if (GetAMErrorText(hr, Buffer, MAX_ERROR_TEXT_LEN)) {
                MessageBox( hwndApp, Buffer,
                            IdStr(STR_APP_TITLE), MB_OK );
            }
            else {
                MessageBox( hwndApp,
                            TEXT("Failed to open the movie; ")
                            TEXT("either the file was not found or ")
                            TEXT("the wave device is in use"),
                            IdStr(STR_APP_TITLE), MB_OK );
            }

            pMpegMovie->CloseMovie();
            delete pMpegMovie;
            pMpegMovie = NULL;
        }
    }

    InitStreamParams(0);

    InvalidateRect( hwndApp, NULL, FALSE );
    UpdateWindow( hwndApp );
}


/******************************Public*Routine******************************\
* VcdPlayerChangeTimeFormat
*
* Tries to change the time format to id.  Returns the time format that
* actually got set.  This may differ from id if the graph does not support
* the requested time format.
*
* History:
* 15-04-96 - AnthonyP - Created
*
\**************************************************************************/
int
VcdPlayerChangeTimeFormat(
    int id
    )
{
    // Menu items are disabled while we are playing

    BOOL    bRet = FALSE;
    int     idActual = id;

    ASSERT(pMpegMovie);
    ASSERT(pMpegMovie->StatusMovie() != MOVIE_NOTOPENED);

    // Change the time format with the filtergraph

    switch (id) {
    case IDM_FRAME:
        bRet = pMpegMovie->SetTimeFormat(TIME_FORMAT_FRAME);
        break;

    case IDM_FIELD:
        bRet = pMpegMovie->SetTimeFormat(TIME_FORMAT_FIELD);
        break;

    case IDM_SAMPLE:
        bRet = pMpegMovie->SetTimeFormat(TIME_FORMAT_SAMPLE);
        break;

    case IDM_BYTES:
        bRet = pMpegMovie->SetTimeFormat(TIME_FORMAT_BYTE);
        break;
    }

    if (!bRet) {
        // IDM_TIME and all other cases,  everyone should support IDM_TIME
        bRet = pMpegMovie->SetTimeFormat(TIME_FORMAT_MEDIA_TIME);
        ASSERT(bRet);
        idActual = IDM_TIME;
    }

    // Pause the movie to get a current position

    SetDurationLength(pMpegMovie->GetDuration());
    SetCurrentPosition(pMpegMovie->GetCurrentPosition());

    return idActual;
}


const TCHAR quartzdllname[] = TEXT("quartz.dll");
#ifdef UNICODE
const char  amgeterrorprocname[] = "AMGetErrorTextW";
#else
const char  amgeterrorprocname[] = "AMGetErrorTextA";
#endif

BOOL GetAMErrorText(HRESULT hr, TCHAR *Buffer, DWORD dwLen)
{
    HMODULE hInst = GetModuleHandle(quartzdllname);
    if (hInst) {
        AMGETERRORTEXTPROC lpProc;
        *((FARPROC *)&lpProc) = GetProcAddress(hInst, amgeterrorprocname);
        if (lpProc) {
            return 0 != (*lpProc)(hr, Buffer, dwLen);
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vmrplyer\vcdplyer.cpp ===
/******************************Module*Header*******************************\
* Module Name: vcdplyer.cpp
*
* A simple Video CD player
*
*
* Created: 30-10-95
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/
#include <streams.h>
#include <mmreg.h>
#include <commctrl.h>

#include "project.h"
//#include "mpgcodec.h"

#include <stdarg.h>
#include <stdio.h>
#include "AllocLib.h"

extern int FrameStepCount;
#include <initguid.h>
#include <d3d.h>

// {B87BEB7B-8D29-423f-AE4D-6582C10175AC}
DEFINE_GUID(CLSID_VideoMixingRenderer,
0xb87beb7b, 0x8d29, 0x423f, 0xae, 0x4d, 0x65, 0x82, 0xc1, 0x1, 0x75, 0xac);

// {0eb1088c-4dcd-46f0-878f-39dae86a51b7}
DEFINE_GUID(IID_IVMRWindowlessControl,
0x0eb1088c,0x4dcd,0x46f0,0x87,0x8f,0x39,0xda,0xe8,0x6a,0x51,0xb7);

// { fd501041-8ebe-11ce-8183-00aa00577da1 }
DEFINE_GUID(CLSID_BouncingBall,
0xfd501041, 0x8ebe, 0x11ce, 0x81, 0x83, 0x00, 0xaa, 0x00, 0x57, 0x7d, 0xa1);

DEFINE_GUID(IID_IVMRImageCompositor,
0x7a4fb5af, 0x479f, 0x4074, 0xbb, 0x40, 0xce, 0x67, 0x22, 0xe4, 0x3c, 0x82);

DEFINE_GUID(IID_IVMRFilterConfig,
0x9e5530c5, 0x7034, 0x48b4, 0xbb, 0x46, 0x0b, 0x8a, 0x6e, 0xfc, 0x8e, 0x36);


/******************************Public*Routine******************************\
* CMpegMovie
*
* Constructors and destructors
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
CMpegMovie::CMpegMovie(HWND hwndApplication) :
      m_hwndApp(hwndApplication),
      m_MediaEvent(NULL),
      m_Mode(MOVIE_NOTOPENED),
      m_Fg(NULL),
      m_Gb(NULL),
      m_Mc(NULL),
      m_Ms(NULL),
      m_Me(NULL),
      m_Wc(NULL),
      m_pMixControl(NULL),
      m_pStreamSelect(NULL),
      m_bFullScreen(FALSE),
      m_TimeFormat(TIME_FORMAT_MEDIA_TIME)
{
}
CMpegMovie::~CMpegMovie() {}


static HRESULT SetRenderingMode( IBaseFilter* pBaseFilter, VMRMode mode )
{
    // Test VMRConfig, VMRMonitorConfig
    IVMRFilterConfig* pConfig;
    HRESULT hr = pBaseFilter->QueryInterface(IID_IVMRFilterConfig, (LPVOID *)&pConfig);
    if( SUCCEEDED( hr )) {
        pConfig->SetRenderingMode( mode );
        pConfig->SetRenderingPrefs( RenderPrefs_ForceOverlays|RenderPrefs_AllowOverlays);
        pConfig->Release();
    }
    return hr;
}

HRESULT
CMpegMovie::AddVideoMixingRendererToFG()
{
    IBaseFilter* pBF = NULL;
    HRESULT hRes = CoCreateInstance(CLSID_VideoMixingRenderer,
                                    NULL,
                                    CLSCTX_INPROC,
                                    IID_IBaseFilter,
                                    (LPVOID *)&pBF);
    if (SUCCEEDED(hRes)) {

        hRes = m_Fg->AddFilter(pBF, L"Video Mixing Renderer");

        if (SUCCEEDED(hRes)) {

            // Test VMRConfig, VMRMonitorConfig
            IVMRFilterConfig* pConfig;
            HRESULT hRes2 = pBF->QueryInterface(IID_IVMRFilterConfig, (LPVOID *)&pConfig);
            if( SUCCEEDED( hRes2 )) {
                pConfig->SetNumberOfStreams(2);
                //pConfig->SetImageCompositor((IVMRImageCompositor*)this);
                pConfig->SetRenderingMode( VMRMode_Windowless /*| VMRMode_PassThru*/);
                pConfig->SetRenderingPrefs(
                                           RenderPrefs_AllowOverlays);
                //                         RenderPrefs_ForceOverlays);
                //                         RenderPrefs_ForceOffscreen);
                //                         RenderPrefs_DoNotRenderColorKeyAndBorder);
                pConfig->Release();
            }

            IVMRMonitorConfig* pMonitorConfig;
            HRESULT hRes3 = pBF->QueryInterface(IID_IVMRMonitorConfig, (LPVOID *)&pMonitorConfig);
            if( SUCCEEDED( hRes3 )) {
                // STDMETHODIMP SetMonitor( const VMRGUID *pGUID );
                // STDMETHODIMP GetMonitor( VMRGUID *pGUID );
                // STDMETHODIMP SetDefaultMonitor( const VMRGUID *pGUID );
                // STDMETHODIMP GetDefaultMonitor( VMRGUID *pGUID );
                // STDMETHODIMP GetAvailableMonitors( VMRMONITORINFO* pInfo, DWORD dwMaxInfoArraySize, DWORD* pdwNumDevices );
                VMRGUID guid;
                HRESULT hr4 = pMonitorConfig->GetMonitor( &guid );
                pMonitorConfig->Release();
            }

            hRes = pBF->QueryInterface(IID_IVMRWindowlessControl, (LPVOID *)&m_Wc);

        }
    }

    if (pBF) {
        pBF->Release();
    }

    if (SUCCEEDED(hRes)) {
        m_Wc->SetVideoClippingWindow(m_hwndApp);
        m_Wc->SetAspectRatioMode(VMR_ARMODE_LETTER_BOX);
    }
    else {
        if (m_Wc) {
            m_Wc->Release();
            m_Wc = NULL;
        }
    }

    return hRes;
}



HRESULT
CMpegMovie::RenderSecondFile(
    TCHAR* FileName
    )
{
    HRESULT hRes;

    hRes = m_Gb->RenderFile(FileName, NULL);
    if (SUCCEEDED(hRes) && m_pMixControl) {
        m_pMixControl->SetAlpha(1, 0.0f );
    }

    return hRes;
}


/******************************Public*Routine******************************\
* OpenMovie
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
HRESULT
CMpegMovie::OpenMovie(
    TCHAR *lpFileName
    )
{
    IUnknown        *pUnk;
    HRESULT         hres;

    WCHAR           FileName[MAX_PATH];

#ifdef UNICODE
    lstrcpy(FileName, lpFileName);
#else
    swprintf(FileName, L"%hs", lpFileName);
#endif

    hres = CoInitialize(NULL);
    if (hres == S_FALSE) {
        CoUninitialize();
    }

    hres = CoCreateInstance(
        g_bUseThreadedGraph ?
            CLSID_FilterGraph :
            CLSID_FilterGraphNoThread,
        NULL,
        CLSCTX_INPROC,
        IID_IUnknown,
        (LPVOID *)&pUnk);

    if (SUCCEEDED(hres)) {

        m_Mode = MOVIE_OPENED;
        hres = pUnk->QueryInterface(IID_IFilterGraph, (LPVOID *)&m_Fg);
        if (FAILED(hres)) {
            pUnk->Release();
            return hres;
        }

        hres = AddVideoMixingRendererToFG();
        if (FAILED(hres)) {
            m_Fg->Release(); m_Fg = NULL;
            return hres;
        }


        hres = pUnk->QueryInterface(IID_IGraphBuilder, (LPVOID *)&m_Gb);
        if (FAILED(hres)) {
            pUnk->Release();
            m_Fg->Release(); m_Fg = NULL;
            m_Wc->Release(); m_Wc = NULL;
            return hres;
        }

        if (hRenderLog!=INVALID_HANDLE_VALUE) {
            m_Gb->SetLogFile((DWORD_PTR) hRenderLog);
        }

        hres = m_Gb->RenderFile(FileName, NULL);
        if (FAILED(hres)) {
            pUnk->Release();
            m_Fg->Release(); m_Fg = NULL;
            if (m_Wc)
                m_Wc->Release(); m_Wc = NULL;
            m_Gb->Release(); m_Gb = NULL;
            return hres;
        }

        if (hRenderLog!=INVALID_HANDLE_VALUE) {
            CloseHandle(hRenderLog);
            hRenderLog = INVALID_HANDLE_VALUE;
        }

        hres = m_Wc->QueryInterface( IID_IVMRMixerControl, (LPVOID *) &m_pMixControl );
        if (FAILED(hres)) {
            // pUnk->Release();
            // m_Fg->Release(); m_Fg = NULL;
            // m_Wc->Release(); m_Wc = NULL;
            // m_Gb->Release(); m_Gb = NULL;
            // return hres;
            m_pMixControl = NULL;
        }


        hres = pUnk->QueryInterface(IID_IMediaControl, (LPVOID *)&m_Mc);
        if (FAILED(hres)) {
            pUnk->Release();
            m_Fg->Release(); m_Fg = NULL;
            m_Wc->Release(); m_Wc = NULL;
            m_Gb->Release(); m_Gb = NULL;
            return hres;
        }

        //
        // Not being able to get the IMediaEvent interface does
        // necessarly mean that we can't play the graph.
        //
        pUnk->QueryInterface(IID_IMediaEvent, (LPVOID *)&m_Me);
        GetMovieEventHandle();

        pUnk->QueryInterface(IID_IMediaSeeking, (LPVOID *)&m_Ms);

        GetPerformanceInterfaces();

//      if (SUCCEEDED(pUnk->QueryInterface(IID_IVideoWindow, (LPVOID *)&m_Vw))) {
//          m_Vw->put_Caption(FileName);
//          m_Vw->put_AutoShow(0);
//      }

	hres = FindInterfaceFromFilterGraph(IID_IAMStreamSelect, (LPVOID *)&m_pStreamSelect);
	if (SUCCEEDED(hres)) {
	    DWORD cStreams;

	    m_pStreamSelect->Count(&cStreams);

	    DWORD i;

	    int iMenuItemsAdded = 0;

	    HMENU hmenu = GetMenu(m_hwndApp);
	    hmenu = GetSubMenu(hmenu, 3);

	    RemoveMenu(hmenu, 0, MF_BYPOSITION);
	
	    DWORD dwLastGroup;
	
	    for (i = 0; i < cStreams; i++) {
		WCHAR *pwszName;
		DWORD dwGroup;
		DWORD dwFlags;

		m_pStreamSelect->Info(i, NULL, &dwFlags, NULL, &dwGroup, &pwszName, NULL, NULL);

		if (iMenuItemsAdded > 0 && dwGroup != dwLastGroup)
		    InsertMenu(hmenu, iMenuItemsAdded++,
			       MF_SEPARATOR | MF_BYPOSITION, -1, NULL);

		dwLastGroup = dwGroup;

		TCHAR	ach[200];
		if (pwszName) {
#ifndef UNICODE
		    WideCharToMultiByte(CP_ACP,0,pwszName,-1,ach,200,NULL,NULL);
		    CoTaskMemFree(pwszName);
#else
		    lstrcpyW(ach, pwszName);
#endif
		} else {
		    wsprintf(ach, TEXT("Stream %d"), i);
		}

		DWORD dwMenuFlags = MF_STRING | MF_BYPOSITION;
		if (dwFlags & AMSTREAMSELECTINFO_ENABLED)
		    dwMenuFlags |= MF_CHECKED;
		
		InsertMenu(hmenu, iMenuItemsAdded++, dwMenuFlags, 2000+i, ach);
	    }
	}
	
        pUnk->Release();
        return S_OK;

    }
    else {
        m_Fg = NULL;
    }

    return hres;
}


/******************************Public*Routine******************************\
* CloseMovie
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
DWORD
CMpegMovie::CloseMovie(
    )
{
    m_Mode = MOVIE_NOTOPENED;
    m_bFullScreen = FALSE;

    if (m_Mc) {

        if (m_Me) {
            m_MediaEvent = NULL;
            m_Me->Release();
            m_Me = NULL;
        }

        if (m_pMixControl) {
            m_pMixControl->Release();
            m_pMixControl = NULL;
        }

        if (m_Ms) {
            m_Ms->Release();
            m_Ms = NULL;
        }

        if (m_Wc) {
            m_Wc->Release();
            m_Wc = NULL;
        }

	if (m_pStreamSelect) {
	    HMENU hmenu = GetMenu(m_hwndApp);
	    hmenu = GetSubMenu(hmenu, 3);

	    while (RemoveMenu(hmenu, 0, MF_BYPOSITION));
	    InsertMenu(hmenu, 0, MF_BYPOSITION | MF_STRING | MF_GRAYED,
		       -1, TEXT("(not available)"));
	
	    m_pStreamSelect->Release();
	    m_pStreamSelect = NULL;
	}

        m_Mc->Release();
        m_Mc = NULL;

        if (m_Gb) {
            m_Gb->Release();
            m_Gb = NULL;
        }

        if (m_Fg) {
            m_Fg->Release();
            m_Fg = NULL;
        }


    }
    QzUninitialize();
    return 0L;
}


/******************************Public*Routine******************************\
* CMpegMovie::GetNativeMovieSize
*
*
*
* History:
* Fri 03/03/2000 - StEstrop - Created
*
\**************************************************************************/
BOOL
CMpegMovie::GetNativeMovieSize(
    LONG *cx,
    LONG *cy
    )
{
    BOOL    bRet = FALSE;
    if (m_Wc) {
        bRet = (m_Wc->GetNativeVideoSize(cx, cy, NULL, NULL) == S_OK);
    }

    return bRet;
}


/******************************Public*Routine******************************\
* GetMoviePosition
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::GetMoviePosition(
    LONG *x,
    LONG *y,
    LONG *cx,
    LONG *cy
    )
{
    BOOL    bRet = FALSE;

//  if (m_Vw) {
//      bRet = (m_Vw->GetWindowPosition(x, y, cx, cy) == S_OK);
//  }

    return bRet;
}

/******************************Public*Routine******************************\
* PutMoviePosition
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::PutMoviePosition(
    LONG x,
    LONG y,
    LONG cx,
    LONG cy
    )
{
    BOOL    bRet = FALSE;

    RECT rc;
    SetRect(&rc, x, y, x + cx, y + cy);
    if (m_Wc) {
        bRet = (m_Wc->SetVideoPosition(NULL, &rc) == S_OK);
    }


    return bRet;
}


/******************************Public*Routine******************************\
* SetMovieWindowState
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::SetMovieWindowState(
    long uState
    )
{
//  return SUCCEEDED(m_Vw->put_WindowState(uState));
    return FALSE;
}


/******************************Public*Routine******************************\
* SetWindowForeground
*
*
*
* History:
* dd-mm-95 - Anthonyp - Created
*
\**************************************************************************/
BOOL
CMpegMovie::SetWindowForeground(
    long Focus
    )
{
//  return SUCCEEDED(m_Vw->SetWindowForeground(Focus));
    return FALSE;
}


/******************************Public*Routine******************************\
* GetMovieWindowState
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::GetMovieWindowState(
    long *lpuState
    )
{
//  return S_OK == m_Vw->get_WindowState(lpuState);
    return FALSE;
}


/******************************Public*Routine******************************\
* PlayMovie
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::PlayMovie(
    )
{
    REFTIME rt;
    REFTIME rtAbs;
    REFTIME rtDur;

    rt = GetCurrentPosition();
    rtDur = GetDuration();

    //
    // If we are near the end of the movie seek to the start, otherwise
    // stay where we are.
    //
    rtAbs = rt - rtDur;
    if (rtAbs < (REFTIME)0) {
        rtAbs = -rtAbs;
    }

    if (rtAbs < (REFTIME)1) {
        SeekToPosition((REFTIME)0,FALSE);
    }

//  if (m_Vw) {
//      long lVis;
//      m_Vw->get_Visible(&lVis);
//      if (lVis == OAFALSE) {
//          m_Vw->put_Visible(OATRUE);
//      }
//  }

    //
    // Change mode after setting m_Mode but before starting the graph
    //
    m_Mode = MOVIE_PLAYING;
    SetFullScreenMode(m_bFullScreen);
    m_Mc->Run();
    return TRUE;
}


/******************************Public*Routine******************************\
* PauseMovie
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::PauseMovie(
    )
{
    m_Mode = MOVIE_PAUSED;
    m_Mc->Pause();
    return TRUE;
}


/******************************Public*Routine******************************\
* GetStateMovie
*
*
*
* History:
* 15-04-96 - AnthonyP - Created
*
\**************************************************************************/

OAFilterState
CMpegMovie::GetStateMovie(
    )
{
    OAFilterState State;
    m_Mc->GetState(INFINITE,&State);
    return State;
}


/******************************Public*Routine******************************\
* StopMovie
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::StopMovie(
    )
{
    m_Mode = MOVIE_STOPPED;
    m_Mc->Stop();
    return TRUE;
}


/******************************Public*Routine******************************\
* StatusMovie
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
EMpegMovieMode
CMpegMovie::StatusMovie(
    )
{
    if (m_Mc) {

        FILTER_STATE    fs;
        HRESULT         hr;

        hr = m_Mc->GetState(100, (OAFilterState *)&fs);

        // Don't know what the state is so just stay at old state.
        if (hr == VFW_S_STATE_INTERMEDIATE) {
            return m_Mode;
        }

        switch (fs) {

        case State_Stopped:
            m_Mode = MOVIE_STOPPED;
            break;

        case State_Paused:
            m_Mode = MOVIE_PAUSED;
            break;

        case State_Running:
            m_Mode = MOVIE_PLAYING;
            break;
        }
    }

    return m_Mode;
}


/******************************Public*Routine******************************\
* CanMovieFrameStep
*
*
*
* History:
* Wed 10/20/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CMpegMovie::CanMovieFrameStep()
{
    IVideoFrameStep* lpFS;
    HRESULT hr;

    hr = m_Fg->QueryInterface(__uuidof(IVideoFrameStep), (LPVOID *)&lpFS);
    if (SUCCEEDED(hr)) {
        hr = lpFS->CanStep(0L, NULL);
        lpFS->Release();
    }

    return SUCCEEDED(hr);
}


/******************************Public*Routine******************************\
* FrameStepMovie
*
*
*
* History:
* Wed 10/20/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CMpegMovie::FrameStepMovie()
{
    IVideoFrameStep* lpFS;
    HRESULT hr;

    hr = m_Fg->QueryInterface(__uuidof(IVideoFrameStep), (LPVOID *)&lpFS);
    if (SUCCEEDED(hr)) {
        {
            FrameStepCount++;
            char sz[80];
            wsprintfA(sz, "VCDPLYER: executing step %d\n", FrameStepCount);
            OutputDebugStringA(sz);
        }
        hr = lpFS->Step(1, NULL);
        lpFS->Release();
    }


    return SUCCEEDED(hr);
}


/******************************Public*Routine******************************\
* GetMediaEventHandle
*
* Returns the IMediaEvent event hamdle for the filter graph iff the
* filter graph exists.
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
HANDLE
CMpegMovie::GetMovieEventHandle(
    )
{
    HRESULT     hr;

    if (m_Me != NULL) {

        if ( m_MediaEvent == NULL) {
            hr = m_Me->GetEventHandle((OAEVENT *)&m_MediaEvent);
        }
    }
    else {
        m_MediaEvent = NULL;
    }

    return m_MediaEvent;
}


/******************************Public*Routine******************************\
* GetMovieEventCode
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
long
CMpegMovie::GetMovieEventCode()
{
    HRESULT hr;
    long    lEventCode;
	LONG_PTR	lParam1, lParam2;

    if (m_Me != NULL) {
        hr = m_Me->GetEvent(&lEventCode, &lParam1, &lParam2, 0);
        if (SUCCEEDED(hr)) {
            return lEventCode;
        }
    }

    return 0L;
}


/******************************Public*Routine******************************\
* GetDuration
*
* Returns the duration of the current movie
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
REFTIME
CMpegMovie::GetDuration()
{
    HRESULT hr;
    LONGLONG Duration;

    // Should we seek using IMediaSelection

    if (m_TimeFormat != TIME_FORMAT_MEDIA_TIME) {
        hr = m_Ms->GetDuration(&Duration);
        if (SUCCEEDED(hr)) {
            return double(Duration);
        }
    } else if (m_Ms != NULL) {
        hr = m_Ms->GetDuration(&Duration);
        if (SUCCEEDED(hr)) {
            return double(Duration) / UNITS;
        }
    }
    return 0;
}


/******************************Public*Routine******************************\
* GetCurrentPosition
*
* Returns the duration of the current movie
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
REFTIME
CMpegMovie::GetCurrentPosition()
{
    REFTIME rt = (REFTIME)0;
    HRESULT hr;
    LONGLONG Position;

    // Should we return a media position

    if (m_TimeFormat != TIME_FORMAT_MEDIA_TIME) {
        hr = m_Ms->GetPositions(&Position, NULL);
        if (SUCCEEDED(hr)) {
            return double(Position);
        }
    } else if (m_Ms != NULL) {
        hr = m_Ms->GetPositions(&Position, NULL);
        if (SUCCEEDED(hr)) {
            return double(Position) / UNITS;
        }
    }
    return rt;
}


/*****************************Private*Routine******************************\
* SeekToPosition
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::SeekToPosition(
    REFTIME rt,
    BOOL bFlushData
    )
{
    HRESULT hr;
    LONGLONG llTime = LONGLONG( m_TimeFormat == TIME_FORMAT_MEDIA_TIME ? rt * double(UNITS) : rt );

    if (m_Ms != NULL) {

        FILTER_STATE fs;
        m_Mc->GetState(100, (OAFilterState *)&fs);

        m_Ms->SetPositions(&llTime, AM_SEEKING_AbsolutePositioning, NULL, 0);

        // This gets new data through to the renderers

        if (fs == State_Stopped && bFlushData){
            m_Mc->Pause();
            hr = m_Mc->GetState(INFINITE, (OAFilterState *)&fs);
            m_Mc->Stop();
        }

        if (SUCCEEDED(hr)) {
            return TRUE;
        }
    }
    return FALSE;
}


/*****************************Private*Routine******************************\
* GetPerformanceInterfaces
*
*
*
* History:
* 31-10-95 - StephenE - Created
*
\**************************************************************************/
void
CMpegMovie::GetPerformanceInterfaces(
    )
{
}


HRESULT
CMpegMovie::FindInterfaceFromFilterGraph(
    REFIID iid, // interface to look for
    LPVOID *lp  // place to return interface pointer in
    )
{
    IEnumFilters*   pEF;	
    IBaseFilter*        pFilter;

    // Grab an enumerator for the filter graph.
    HRESULT hr = m_Fg->EnumFilters(&pEF);

    if (FAILED(hr)) {
        return hr;
    }

    // Check out each filter.
    while (pEF->Next(1, &pFilter, NULL) == S_OK)
    {
        hr = pFilter->QueryInterface(iid, lp);
        pFilter->Release();

        if (SUCCEEDED(hr)) {
            break;
        }
    }

    pEF->Release();

    return hr;
}


/*****************************Public*Routine******************************\
* SetFullScreenMode
*
*
*
* History:
* 17-03-96 - AnthonyP - Created
*
\**************************************************************************/
void
CMpegMovie::SetFullScreenMode(BOOL bMode)
{
    m_bFullScreen = bMode;

    // Defer until we activate the movie

    if (m_Mode != MOVIE_PLAYING) {
        if (bMode == TRUE) {
            return;
        }
    }

    // Make the change now

//  if (bMode == FALSE) {
//      m_Vw->put_FullScreenMode(OAFALSE);
//      m_Vw->put_MessageDrain((OAHWND) NULL);
//  } else {
//      m_Vw->put_MessageDrain((OAHWND) hwndApp);
//      m_Vw->put_FullScreenMode(OATRUE);
//  }

}


/*****************************Public*Routine******************************\
* IsFullScreenMode
*
*
*
* History:
* 17-03-96 - AnthonyP - Created
*
\**************************************************************************/
BOOL
CMpegMovie::IsFullScreenMode()
{
    return m_bFullScreen;
}


/*****************************Public*Routine******************************\
* IsTimeFormatSupported
*
*
*
* History:
* 12-04-96 - AnthonyP - Created
*
\**************************************************************************/
BOOL
CMpegMovie::IsTimeFormatSupported(GUID Format)
{
    return m_Ms != NULL && m_Ms->IsFormatSupported(&Format) == S_OK;
}


/*****************************Public*Routine******************************\
* IsTimeSupported
*
*
*
* History:
* 12-04-96 - AnthonyP - Created
*
\**************************************************************************/
BOOL
CMpegMovie::IsTimeSupported()
{
    return m_Ms != NULL && m_Ms->IsFormatSupported(&TIME_FORMAT_MEDIA_TIME) == S_OK;
}


/*****************************Public*Routine******************************\
* GetTimeFormat
*
*
*
* History:
* 12-04-96 - AnthonyP - Created
*
\**************************************************************************/
GUID
CMpegMovie::GetTimeFormat()
{
    return m_TimeFormat;
}

/*****************************Public*Routine******************************\
* SetTimeFormat
*
*
*
* History:
* 12-04-96 - AnthonyP - Created
*
\**************************************************************************/
BOOL
CMpegMovie::SetTimeFormat(GUID Format)
{
    HRESULT hr = m_Ms->SetTimeFormat(&Format);
    if (SUCCEEDED(hr)) {
        m_TimeFormat = Format;
    }
    return SUCCEEDED(hr);
}

/******************************Public*Routine******************************\
* SetFocus
*
*
*
* History:
* 18-09-96 - SteveDav - Created
*
\**************************************************************************/
void
CMpegMovie::SetFocus()
{
    if (m_Fg) {

	// Tell the resource manager that we are being made active.  This
	// will then cause the sound to switch to us.  This is especially
	// important when playing audio only files as there is no other
	// playback window.
        IResourceManager* pResourceManager;

        HRESULT hr = m_Fg->QueryInterface(IID_IResourceManager, (void**)&pResourceManager);

        if (SUCCEEDED(hr)) {
            IUnknown* pUnknown;

            hr = m_Fg->QueryInterface(IID_IUnknown, (void**)&pUnknown);

            if (SUCCEEDED(hr)) {
                pResourceManager->SetFocus(pUnknown);
                pUnknown->Release();
            }

            pResourceManager->Release();
        }
    }
}

BOOL CMpegMovie::SelectStream(int iStream)
{
    HRESULT hr = E_NOINTERFACE;

    if (m_pStreamSelect) {
	hr = m_pStreamSelect->Enable(iStream, AMSTREAMSELECTENABLE_ENABLE);
    }

    return SUCCEEDED(hr);
}


/******************************Public*Routine******************************\
* RepaintVideo
*
*
*
* History:
* Tue 02/29/2000 - StEstrop - Created
*
\**************************************************************************/
BOOL
CMpegMovie::RepaintVideo(
    HWND hwnd,
    HDC hdc
    )
{
    BOOL bRet = FALSE;

    if (m_Wc) {
        bRet = (m_Wc->RepaintVideo(hwnd, hdc) == S_OK);
    }

    return bRet;
}


/******************************Public*Routine******************************\
* SetAppImage
*
*
*
* History:
* Tue 05/30/2000 - StEstrop - Created
*
\**************************************************************************/
BOOL
CMpegMovie::SetAppImage(
    VMRALPHABITMAP* lpBmpInfo
    )
{
    IVMRMixerBitmap* pBmp;
    HRESULT hres = m_Wc->QueryInterface(IID_IVMRMixerBitmap, (LPVOID *)&pBmp);
    if (SUCCEEDED(hres)) {

        pBmp->SetAlphaBitmap(lpBmpInfo);
        pBmp->Release();
    }

    return hres;
}

BOOL
CMpegMovie::UpdateAppImage(VMRALPHABITMAP* lpBmpInfo)
{
    IVMRMixerBitmap* pBmp;
    HRESULT hres = m_Wc->QueryInterface(IID_IVMRMixerBitmap, (LPVOID *)&pBmp);
    if (SUCCEEDED(hres)) {

        pBmp->UpdateAlphaBitmapParameters(lpBmpInfo);
        pBmp->Release();
    }

    return hres;
}


void
CMpegMovie::SetBorderClr(COLORREF clr)
{
    m_Wc->SetBorderColor(clr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vmrplyer\vcdplyer.h ===
/******************************Module*Header*******************************\
* Module Name: vcdplyer.h
*
* Function prototype for the Video CD Player application.
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/


/* -------------------------------------------------------------------------
** CMpegMovie - an Mpeg movie playback class.
** -------------------------------------------------------------------------
*/
enum EMpegMovieMode { MOVIE_NOTOPENED = 0x00,
                      MOVIE_OPENED = 0x01,
                      MOVIE_PLAYING = 0x02,
                      MOVIE_STOPPED = 0x03,
                      MOVIE_PAUSED = 0x04 };

struct IMpegAudioDecoder;
struct IMpegVideoDecoder;
struct IQualProp;

class CMpegMovie
{
private:
    // Our state variable - records whether we are opened, playing etc.
    EMpegMovieMode   m_Mode;
    HANDLE           m_MediaEvent;
    HWND             m_hwndApp;
    BOOL             m_bFullScreen;
    GUID             m_TimeFormat;

    IFilterGraph            *m_Fg;
    IGraphBuilder           *m_Gb;
    IMediaControl           *m_Mc;
    IMediaSeeking           *m_Ms;
    IMediaEvent             *m_Me;
    IVMRWindowlessControl   *m_Wc;

    HRESULT AddVideoMixingRendererToFG();
    HRESULT AddBallToFG();
    void GetPerformanceInterfaces();
    HRESULT FindInterfaceFromFilterGraph(
        REFIID iid, // interface to look for
        LPVOID *lp  // place to return interface pointer in
        );

public:
     CMpegMovie(HWND hwndApplication);
    ~CMpegMovie();

    HRESULT         OpenMovie(TCHAR *lpFileName);
    DWORD           CloseMovie();
    BOOL            PlayMovie();
    BOOL            PauseMovie();
    BOOL            StopMovie();
    OAFilterState   GetStateMovie();
    HANDLE          GetMovieEventHandle();
    long            GetMovieEventCode();
    BOOL            PutMoviePosition(LONG x, LONG y, LONG cx, LONG cy);
    BOOL            GetMoviePosition(LONG *x, LONG *y, LONG *cx, LONG *cy);
    BOOL            GetNativeMovieSize(LONG *cx, LONG *cy);
    BOOL            GetMovieWindowState(long *lpuState);
    BOOL            SetMovieWindowState(long uState);
    BOOL            CanMovieFrameStep();
    BOOL            FrameStepMovie();
    REFTIME         GetDuration();
    REFTIME         GetCurrentPosition();
    BOOL            SeekToPosition(REFTIME rt,BOOL bFlushData);
    EMpegMovieMode  StatusMovie();
    void            SetFullScreenMode(BOOL bMode);
    BOOL            IsFullScreenMode();
    BOOL            SetWindowForeground(long Focus);
    BOOL            IsTimeFormatSupported(GUID Format);
    BOOL            IsTimeSupported();
    BOOL            SetTimeFormat(GUID Format);
    GUID            GetTimeFormat();
    void            SetFocus();
    BOOL            ConfigDialog(HWND hwnd);
    BOOL            SelectStream(int iStream);
    BOOL            RepaintVideo(HWND hwnd, HDC hdc);
    BOOL            SetAppImage(VMRALPHABITMAP* lpBmpInfo);
    BOOL            UpdateAppImage(VMRALPHABITMAP* lpBmpInfo);
    void            SetBorderClr(COLORREF clr);

    void            DisplayModeChanged() {
        m_Wc->DisplayModeChanged();
    }

    HRESULT         GetCurrentImage(LPBYTE* lplpDib)
    {
        return m_Wc->GetCurrentImage(lplpDib);
    }

    HRESULT         RenderSecondFile(TCHAR *lpFileName);

    IAMStreamSelect	    *m_pStreamSelect;
    IVMRMixerControl        *m_pMixControl;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vmrplyer\resource.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
//
// These are indexes used by the toolbar.
//
#define IDC_ADEFAULT2                   4013
#define IDC_STATIC                      -1

#define IDX_SEPARATOR                   -1
#define IDX_1                           0
#define IDX_2                           1
#define IDX_3                           2
#define IDX_4                           3
#define IDX_5                           4
#define IDX_6                           5
#define IDX_7                           6
#define IDX_8                           7
#define IDX_9                           8
#define IDX_10                          9
#define IDX_11                          10
#define IDX_12                          11
#define DEFAULT_TBAR_SIZE               16
#define NUMBER_OF_BITMAPS               12


#define ID_STATUSBAR                    8
#define ID_TOOLBAR                      9
#define ID_TRACKBAR                     10

#define IDR_MAIN_MENU                   101
#define IDR_TOOLBAR                     102
#define IDR_VIDEOCD_ICON                103
#define IDR_ACCELERATOR                 104
#define IDR_VMR                         105

#define IDC_XPOS_TRK                    1000
#define IDC_YPOS_TRK                    1001
#define IDC_XPOS                        1002
#define IDC_YPOS                        1003
#define IDC_XSIZE_TRK                   1004
#define IDC_YSIZE_TRK                   1005
#define IDC_XSIZE                       1006
#define IDC_YSIZE                       1007
#define IDC_IMAGE_ENABLE                1008
#define IDC_ALPHA_TRK2                  1009
#define IDC_ALPHA                       1010

#define IDM_FILE_OPEN                   40001
#define IDM_FILE_OPEN2                  40005
#define IDM_FILE_CLOSE                  40002
#define IDM_FILE_EXIT                   40003


#define IDM_APP_IMAGE                   42004
#define IDM_STREAM_A                    42005
#define IDM_STREAM_B                    42009
#define IDM_ALLOW_OVERLAYS              42006
#define IDM_PASS_THRU_MODE              42007
#define IDM_NO_MONITOR_CHANGES          42008


#define IDM_FILE_SET_LOG                40008
#define IDM_FILE_SET_PERF_LOG           40009

#define IDM_HELP_INDEX                  40100
#define IDM_HELP_USING                  40101
#define IDM_HELP_ABOUT                  40102
#define IDM_HELP_SEARCH                 40103

// Different time formats
#define IDM_TIME                        40150
#define IDM_FRAME                       40151
#define IDM_FIELD                       40152
#define IDM_SAMPLE                      40153
#define IDM_BYTES                       40154

// Toolbar commands
#define IDM_MOVIE_STOP                  40010
#define IDM_MOVIE_PLAY                  40011
#define IDM_MOVIE_PREVTRACK             40012
#define IDM_MOVIE_PAUSE                 40013
#define IDM_MOVIE_SKIP_FORE             40014
#define IDM_MOVIE_SKIP_BACK             40015
#define IDM_MOVIE_NEXTTRACK             40016

#define IDM_PERF_NEW                    40017
#define IDM_PERF_DUMP                   40018
#define IDM_FULL_SCREEN                 40019

#define IDM_MOVIE_ALIGN                 40020
#define IDM_MOVIE_STEP                  40021



#define MENU_STRING_BASE                1000

        // File
#define STR_FILE_OPEN           IDM_FILE_OPEN  + MENU_STRING_BASE
#define STR_FILE_CLOSE          IDM_FILE_CLOSE + MENU_STRING_BASE
#define STR_FILE_EXIT           IDM_FILE_EXIT  + MENU_STRING_BASE
#define STR_FILE_SET_LOG        IDM_FILE_SET_LOG  + MENU_STRING_BASE
#define STR_FILE_SET_PERF_LOG   IDM_FILE_SET_PERF_LOG  + MENU_STRING_BASE


        // Properties Menu
#define STR_PROP_VIDEO_DECODER  IDM_VIDEO_DECODER + MENU_STRING_BASE
#define STR_PROP_AUDIO_DECODER  IDM_AUDIO_DECODER + MENU_STRING_BASE
#define STR_PROP_OTHER          IDM_FILTERS + MENU_STRING_BASE

        // Time format menu
#define STR_PROP_IDM_TIME       IDM_TIME      + MENU_STRING_BASE
#define STR_PROP_IDM_FRAME      IDM_FRAME     + MENU_STRING_BASE
#define STR_PROP_IDM_FIELD      IDM_FIELD     + MENU_STRING_BASE
#define STR_PROP_IDM_SAMPLE     IDM_SAMPLE    + MENU_STRING_BASE
#define STR_PROP_IDM_BYTES      IDM_BYTES     + MENU_STRING_BASE

        // Dither Menu          OPTIONS_MENU_BASE


        // Help Menu            HELP_MENU_BASE
#define STR_HELP_INDEX          IDM_HELP_INDEX    + MENU_STRING_BASE
#define STR_HELP_USING          IDM_HELP_USING    + MENU_STRING_BASE
#define STR_HELP_ABOUT          IDM_HELP_ABOUT    + MENU_STRING_BASE
#define STR_HELP_SEARCH         IDM_HELP_SEARCH   + MENU_STRING_BASE


        // System Menu
#define STR_SYSMENU_RESTORE     1800
#define STR_SYSMENU_MOVE        1801
#define STR_SYSMENU_MINIMIZE    1802
#define STR_SYSMENU_CLOSE       1803
#define STR_SYSMENU_MAXIMIZE    1804
#define STR_SYSMENU_TASK_LIST   1805



#define STR_FILE_FILTER         2000
#define STR_APP_TITLE           2001
#define STR_APP_TITLE_LOADED    2002
#define STR_FILE_LOG_FILTER     2003
#define STR_FILE_PERF_LOG       2004


#define MPEG_CODEC_BASE         4000

#define IDD_AUDIOPROP           4000    //  MPEG_CODEC_BASE + 0
#define FULL_FREQ               MPEG_CODEC_BASE + 1
#define HALF_FREQ               MPEG_CODEC_BASE + 2
#define QUARTER_FREQ            MPEG_CODEC_BASE + 3
#define IDC_INTEGER             MPEG_CODEC_BASE + 4
#define D_HIGH                  MPEG_CODEC_BASE + 5
#define D_MEDIUM                MPEG_CODEC_BASE + 6
#define D_LOW                   MPEG_CODEC_BASE + 7
#define STEREO_OUTPUT           MPEG_CODEC_BASE + 8
#define IDC_8_BIT               MPEG_CODEC_BASE + 9
#define IDC_16_BIT              MPEG_CODEC_BASE + 10
#define IDC_ADEFAULT            MPEG_CODEC_BASE + 11
#define IDC_AINFO               MPEG_CODEC_BASE + 12


#define IDD_VIDEOPROP           4008    //  MPEG_CODEC_BASE + 9
#define NO_DECODE               MPEG_CODEC_BASE + 10
#define I_ONLY                  MPEG_CODEC_BASE + 11
#define IP_ONLY                 MPEG_CODEC_BASE + 12
#define IP_1_IN_4_B             MPEG_CODEC_BASE + 13
#define IP_2_IN_4_B             MPEG_CODEC_BASE + 14
#define IP_3_IN_4_B             MPEG_CODEC_BASE + 15
#define IP_ALL_B                MPEG_CODEC_BASE + 16
#define B_HIGH                  MPEG_CODEC_BASE + 17
#define B_MEDIUM                MPEG_CODEC_BASE + 18
#define B_LOW                   MPEG_CODEC_BASE + 19
#define OUTPUT_16BIT            MPEG_CODEC_BASE + 20
#define OUTPUT_8BIT             MPEG_CODEC_BASE + 21
#define CONVERT_OUTPUT          MPEG_CODEC_BASE + 22
#define HI_QUALITY_OUTPUT       MPEG_CODEC_BASE + 23

#define B_GREY                  MPEG_CODEC_BASE + 24
#define IGNORE_QUALITY          MPEG_CODEC_BASE + 25
#define STATS_BUTTON            MPEG_CODEC_BASE + 26
#define ID_DEFAULT              MPEG_CODEC_BASE + 27

#define IDD_VIDEOSTATS          4027    //  MPEG_CODEC_BASE + 28
#define ID_STATSBOX             MPEG_CODEC_BASE + 29
#define ID_REFRESH              MPEG_CODEC_BASE + 30

#define IDD_PROPPAGE            4040    //  MPEG_CODEC_BASE + 40
#define IDC_FILTERS             MPEG_CODEC_BASE + 41
#define IDC_PROPERTIES          MPEG_CODEC_BASE + 42

#define STR_MAX_STRING_LEN      256
#define IDS_FRAMES_DEC          MPEG_CODEC_BASE + 31
#define IDS_PROPORTION          MPEG_CODEC_BASE + 32
#define IDS_IMAGE_SIZE          MPEG_CODEC_BASE + 33
#define IDS_BUFFER_VBV          MPEG_CODEC_BASE + 34
#define IDS_BITRATE             MPEG_CODEC_BASE + 35
#define IDS_PROP_I              MPEG_CODEC_BASE + 36
#define IDS_PROP_P              MPEG_CODEC_BASE + 37
#define IDS_PROP_B              MPEG_CODEC_BASE + 38
#define IDS_SKIP_I              MPEG_CODEC_BASE + 39
#define IDS_SKIP_P              MPEG_CODEC_BASE + 40
#define IDS_SKIP_B              MPEG_CODEC_BASE + 41
#define IDS_NO_DATA             MPEG_CODEC_BASE + 42
#define IDS_NEWLINE             MPEG_CODEC_BASE + 43
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vpm\drect.cpp ===
/******************************Module*Header*******************************\
* Module Name: CVPMFilter.cpp
*
*
*
*
* Created: Tue 02/15/2000
* Author:  Glenn Evans [GlennE]
*
* Copyright (c) 2000 Microsoft Corporation
\**************************************************************************/
#include <streams.h>
#include <DRect.h>


#if 1
#include <math.h>

static double myfloor(double dNumber)
{
    return floor( dNumber );
}
static double myceil(double dNumber)
{
    return ceil( dNumber );
}
#else
// have to define my own floor inorder to avoid pulling in the C runtime
static double myfloor(double dNumber)
{
    // cast it to LONGLONG to get rid of the fraction
    LONGLONG llNumber = (LONGLONG)dNumber;

    if ((dNumber > 0) && ((double)llNumber > dNumber))
    {
        // need to push ccNumber towards zero (eg 5.7)
        return (double)(llNumber-1);
    }
    else if ((dNumber < 0) && ((double)llNumber < dNumber))
    {
        // need to push ccNumber towards zero (eg -5.7)
        return (double)(llNumber+1);
    }
    else
    {
        // numbers like 5.3 or -5.3
        return (double)(llNumber);
    }
}


// have to define my own ceil inorder to avoid pulling in the C runtime
static double myceil(double dNumber)
{
    // cast it to LONGLONG to get rid of the fraction
    LONGLONG llNumber = (LONGLONG)dNumber;

    if ((dNumber > 0) && ((double)llNumber < dNumber))
    {
        // need to push ccNumber away from zero (eg 5.3)
        return (double)(llNumber+1);
    }
    else if ((dNumber < 0) && ((double)llNumber > dNumber))
    {
        // need to push ccNumber away from zero (eg -5.3)
        return (double)(llNumber-1);
    }
    else
    {
        // numbers like 5.7 or -5.7
        return (double)(llNumber);
    }
}
#endif

// this in a way defines the error margin
#define EPSILON 0.0001

// this is a function implemented solely to handle floating point rounding errors.
// dEpsilon defines the error margin. So if a floating point number is within I-e, I+e (inclusive)
// (I is an integer, e is dEpsilon), we return its floor as I itself, otherwise we go to the
// base defintion of myfloor
static double myfloor(double dNumber, double dEpsilon)
{
    if (dNumber > dEpsilon)
        return myfloor(dNumber + dEpsilon);
    else if (dNumber < -dEpsilon)
        return myfloor(dNumber - dEpsilon);
    else
        return 0;
}

// this is a function implemented solely to handle floating point rounding errors.
// dEpsilon defines the error margin. So if a floating point number is within I-e, I+e (inclusive)
// (I is an integer, e is dEpsilon), we return its ceil as I itself, otherwise we go to the
// base defintion of myceil
static double myceil(double dNumber, double dEpsilon)
{
    if (dNumber > dEpsilon)
        return myceil(dNumber - dEpsilon);
    else if (dNumber < -dEpsilon)
        return myceil(dNumber + dEpsilon);
    else
        return 0;
}

DRect::DRect( const RECT& rc )
: m_left( rc.left )
, m_right( rc.right )
, m_top( rc.top )
, m_bottom( rc.bottom )
{
}

RECT DRect::AsRECT() const
{
    RECT rRect;

    rRect.left = (LONG)myfloor(m_left, EPSILON);
    rRect.top = (LONG)myfloor(m_top, EPSILON);
    rRect.right = (LONG)myceil(m_right, EPSILON);
    rRect.bottom = (LONG)myceil(m_bottom, EPSILON);
    return rRect;
}

DRect DRect::IntersectWith( const DRect& drect ) const
{
    return DRect(
     max( drect.m_left, m_left),   max( drect.m_top, m_top),
     min( drect.m_right, m_right), min( drect.m_bottom, m_bottom));
}

// just a helper function to scale a DRECT
void DRect::Scale( double dScaleX, double dScaleY )
{
    m_left *= dScaleX;
    m_right *= dScaleX;
    m_top *= dScaleY;
    m_bottom *= dScaleY;
}

// just a helper function, to get the letterboxed or cropped rect
// Puts the transformed rectangle into pRect.
double DRect::CorrectAspectRatio( double dPictAspectRatio, BOOL bShrink )
{
    double dWidth, dHeight, dNewWidth, dNewHeight;

    dNewWidth = dWidth = GetWidth();
    dNewHeight = dHeight = GetHeight();

    ASSERT( dWidth > 0 );
    ASSERT( dHeight > 0 );

    double dResolutionRatio = dWidth / dHeight;
    double dTransformRatio = dPictAspectRatio / dResolutionRatio;

    // shrinks one dimension to maintain the coorect aspect ratio
    if ( bShrink ) {
        if (dTransformRatio > 1.0) {
            dNewHeight = dNewHeight / dTransformRatio;
        } else if (dTransformRatio < 1.0) {
            dNewWidth = dNewWidth * dTransformRatio;
        }
    } // stretches one dimension to maintain the coorect aspect ratio
    else {
        if (dTransformRatio > 1.0) {
            dNewWidth = dNewWidth * dTransformRatio;
        } else if (dTransformRatio < 1.0) {
            dNewHeight = dNewHeight / dTransformRatio;
        }
    }

    // cut or add equal portions to the changed dimension

    m_left += (dWidth - dNewWidth)/2.0;
    m_right = m_left + dNewWidth;

    m_top += (dHeight - dNewHeight)/2.0;
    m_bottom = m_top + dNewHeight;

    return dTransformRatio;
}


/******************************Private*Routine******************************\
* ClipWith
*
* Clip a destination rectangle & update the scaled source accordingly
*
*
* History:
* Fri 04/07/2000 - GlennE - Created
*
\**************************************************************************/
void
DRect::ClipWith(const DRect& rdWith, DRect *pUpdate )
{
    // figure out src/dest scale ratios
    double dUpdateWidth  = pUpdate->GetWidth();
    double dUpdateHeight = pUpdate->GetHeight();

    double dDestWidth  = GetWidth();
    double dDestHeight = GetHeight();

    // clip destination (and adjust the source when we change the destination)

    // see if we have to clip horizontally
    if( dDestWidth ) {
        if( rdWith.m_left > m_left ) {
            double dDelta = rdWith.m_left - m_left;
            m_left += dDelta;
            double dDeltaSrc = dDelta*dUpdateWidth/dDestWidth;
            pUpdate->m_left += dDeltaSrc;
        }

        if( rdWith.m_right < m_right ) {
            double dDelta = m_right-rdWith.m_right;
            m_right -= dDelta;
            double dDeltaSrc = dDelta*dUpdateWidth/dDestWidth;
            pUpdate->m_right -= dDeltaSrc;
        }
    }
    // see if we have to clip vertically
    if( dDestHeight ) {
        if( rdWith.m_top > m_top ) {
            double dDelta = rdWith.m_top - m_top;
            m_top += dDelta;
            double dDeltaSrc = dDelta*dUpdateHeight/dDestHeight;
            pUpdate->m_top += dDeltaSrc;
        }

        if( rdWith.m_bottom < m_bottom ) {
            double dDelta = m_bottom-rdWith.m_bottom;
            m_bottom -= dDelta;
            double dDeltaSrc = dDelta*dUpdateHeight/dDestHeight;
            pUpdate->m_bottom -= dDeltaSrc;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vpm\khandlearray.cpp ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <KHandleArray.h>
#include <ddkernel.h>
#include <VPMUtil.h>


/*****************************Private*Routine******************************\
* SurfaceCounter
*
* This routine is appropriate as a callback for
* IDirectDrawSurface2::EnumAttachedSurfaces()
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
static HRESULT WINAPI
SurfaceCounter(
    LPDIRECTDRAWSURFACE7 lpDDSurface,
    LPDDSURFACEDESC2 lpDDSurfaceDesc,
    LPVOID lpContext
    )
{
    DWORD& dwCount = *((DWORD *)lpContext);
    dwCount++;

    return DDENUMRET_OK;
}

KernelHandleArray::KernelHandleArray( DWORD dwNumHandles )
: m_dwCount( 0 )
, m_pHandles( ( ULONG_PTR *) CoTaskMemAlloc( dwNumHandles * sizeof( *m_pHandles) ))
{
}

KernelHandleArray::~KernelHandleArray()
{
    if( m_pHandles ) {
        CoTaskMemFree( m_pHandles );
    }
}


/*****************************Private*Routine******************************\
* KernelHandleArray::SurfaceKernelHandle
*
*
* This routine is appropriate as a callback for
* IDirectDrawSurface2::EnumAttachedSurfaces().  The context parameter is a
* block of storage where the first DWORD element is the count of the remaining
* DWORD elements in the block.
*
* Each time this routine is called, it will increment the count, and put a
* kernel handle in the next available slot.
*
* It is assumed that the block of storage is large enough to hold the total
* number of kernel handles. The ::SurfaceCounter callback is one way to
* assure this (see above).
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT WINAPI
KernelHandleArray::SurfaceKernelHandle(
    LPDIRECTDRAWSURFACE7 lpDDSurface,
    LPDDSURFACEDESC2 lpDDSurfaceDesc,
    LPVOID lpContext
    )
{
    IDirectDrawSurfaceKernel *pDDSK = NULL;
    KernelHandleArray* pArray = (KernelHandleArray *)lpContext;
    HRESULT hr;

    AMTRACE((TEXT("::SurfaceKernelHandle")));

    // get the IDirectDrawKernel interface
    hr = lpDDSurface->QueryInterface(IID_IDirectDrawSurfaceKernel,
                                     (LPVOID *)&pDDSK);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("QueryInterface for IDirectDrawSurfaceKernel failed,")
                TEXT(" hr = 0x%x"), hr));
        goto CleanUp;
    }

    // get the kernel handle, using the first element of the context
    // as an index into the array
    ASSERT(pDDSK);
    hr = pDDSK->GetKernelHandle( &pArray->m_pHandles[ pArray->m_dwCount ] );
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("GetKernelHandle from IDirectDrawSurfaceKernel failed,")
                TEXT(" hr = 0x%x"), hr));
        goto CleanUp;
    }
    pArray->m_dwCount++;

    hr = HRESULT( DDENUMRET_OK );

CleanUp:
    // release the kernel ddraw surface handle
    RELEASE (pDDSK);
    return hr;
}

KernelHandleArray::KernelHandleArray( LPDIRECTDRAWSURFACE7 pDDSurf, HRESULT& hr )
: m_pHandles( NULL )
, m_dwCount( 0 )
{
    if( pDDSurf != NULL ) {
        // Count the attached surfaces
        m_dwCount = 1; // includes the surface we already have a pointer to
        hr = pDDSurf->EnumAttachedSurfaces((LPVOID)&m_dwCount, SurfaceCounter);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR,0, TEXT("EnumAttachedSurfaces failed, hr = 0x%x"), hr));
        } else {
            m_pHandles = ( ULONG_PTR *) CoTaskMemAlloc( m_dwCount * sizeof( *m_pHandles) );

            // Allocate a buffer to hold the count and surface handles (count + array of handles)
            // pdwKernelHandleCount is also used as a pointer to the count followed by the array
            //
            if( !m_pHandles ) {
                DbgLog((LOG_ERROR,0,
                        TEXT("Out of memory while retrieving surface kernel handles")));
            } else {
                // Initialize the array with the handle for m_pOutputSurface
                m_dwCount = 0;
                hr = SurfaceKernelHandle( pDDSurf, NULL, this );
                if (hr == HRESULT( DDENUMRET_OK ) ) {
                    hr = pDDSurf->EnumAttachedSurfaces( this, SurfaceKernelHandle);
                    if (FAILED( hr)) {
                        DbgLog((LOG_ERROR,0,
                                TEXT("EnumAttachedSurfaces failed, hr = 0x%x"), hr));
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vpm\formatlist.cpp ===
#include <streams.h>
#include <ddraw.h>
#include <VPMUtil.h>
#include <FormatList.h>

PixelFormatList::PixelFormatList( DWORD dwCount )
: m_dwCount( 0 )
, m_pEntries( NULL )
{
    Reset( dwCount );
}

PixelFormatList::PixelFormatList()
: m_dwCount( 0 )
, m_pEntries( NULL )
{
}

PixelFormatList::PixelFormatList( const PixelFormatList& list )
: m_dwCount( 0 )
, m_pEntries( NULL )
{
    if( Realloc( list.GetCount())) {
        CopyArray( m_pEntries, list.m_pEntries, list.GetCount() );
    }
}

PixelFormatList::~PixelFormatList()
{
    delete [] m_pEntries;
}

BOOL PixelFormatList::Truncate( DWORD dwCount )
{
    ASSERT( dwCount <= m_dwCount );
    if( dwCount <= m_dwCount ) {
        m_dwCount = dwCount;
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL PixelFormatList::Realloc( DWORD dwCount )
{
    delete [] m_pEntries;
    m_dwCount = dwCount;
    m_pEntries = new DDPIXELFORMAT[ dwCount ];
    if( m_pEntries ) {
        return TRUE;
    } else {
        m_dwCount = 0;
        return FALSE;
    }
}

BOOL PixelFormatList::Reset( DWORD dwCount )
{
    BOOL b = Realloc( dwCount );
    if( b ) {
        ZeroArray( m_pEntries, dwCount ); 
        for( DWORD i = 0; i < dwCount; i++ ) {
            m_pEntries[i].dwSize = sizeof(DDPIXELFORMAT);
        }
        return TRUE;
    }
    return b;
}

PixelFormatList& PixelFormatList::operator =( const PixelFormatList& with )
{
    if( Realloc( with.GetCount() )) {
		CopyArray( m_pEntries, with.m_pEntries, with.GetCount());
	}
    return *this;
}

PixelFormatList PixelFormatList::IntersectWith( const PixelFormatList& with ) const
{
    // calculate the maximum number of elements in the interesection
    PixelFormatList lpddIntersectionFormats( max(GetCount(), with.GetCount() ) );
    if (lpddIntersectionFormats.GetEntries() == NULL)
    {
        return lpddIntersectionFormats;
    }

    // find the intersection of the two lists
    DWORD dwNumIntersectionEntries = 0;
    for (DWORD i = 0; i < GetCount(); i++)
    {
        for (DWORD j = 0; j < with.GetCount(); j++)
        {
            if (VPMUtil::EqualPixelFormats(m_pEntries[i], with.m_pEntries[j]))
            {
                lpddIntersectionFormats[dwNumIntersectionEntries]= m_pEntries[i];
                dwNumIntersectionEntries++;
            }
        }
    }
    // truncate the list
    lpddIntersectionFormats.Truncate( dwNumIntersectionEntries );
    return lpddIntersectionFormats;
}

    // generate the union of all of the lists
PixelFormatList PixelFormatList::Union( const PixelFormatList* pLists, DWORD dwCount )
{
    // worst case, every list is unique so max size is the sum of the sizes
    DWORD dwMaxCount=0;
    {for( DWORD i = 0; i < dwCount; i++ ) {
        dwMaxCount += pLists[i].GetCount();
    }}

    // create a new list
    PixelFormatList newList( dwMaxCount );
    if( !newList.GetEntries()) {
        return newList;
    }

    DWORD dwUniqueEntries = 0;
    // do a simple linear compare merge
    {for( DWORD i = 0; i < dwCount; i++ ) {
        const PixelFormatList& curList = pLists[i];

        // merge in every entry of the current list
        for( DWORD j=0; j < curList.GetCount(); j++ ) {
            const DDPIXELFORMAT& toFind = curList[j];

            BOOL bFound = FALSE;
            // see if it already exists
            for( DWORD k=0; k < dwUniqueEntries; k++ ) {
                if( VPMUtil::EqualPixelFormats( newList[k], toFind  ))
                {
                    bFound = TRUE;
                    break;
                }
            }
            // if not, then add it
            if( !bFound ) {
                newList[dwUniqueEntries] = toFind;
                dwUniqueEntries++;
            }
        }
    }}
    newList.Truncate( dwUniqueEntries );
    return newList;
}

DWORD PixelFormatList::FindListContaining( const DDPIXELFORMAT& toFind, const PixelFormatList* pLists, DWORD dwCount )
{
     DWORD i = 0;
     for(; i < dwCount; i++ ) {
        const PixelFormatList& curList = pLists[i];

        // merge in every entry of the current list
        for( DWORD j=0; j < curList.GetCount(); j++ ) {
            if( VPMUtil::EqualPixelFormats( curList[j], toFind  )) {
                return i;
            }
        }
    }
    return i;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vpm\formatlist.h ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
#ifndef __PixelFormatList__
#define __PixelFormatList__


class PixelFormatList
{
public:
    PixelFormatList();
    PixelFormatList( DWORD dwCount );
    PixelFormatList( const PixelFormatList& list );
    ~PixelFormatList();

    PixelFormatList& operator=( const PixelFormatList& list );

    BOOL            Reset( DWORD dwCount );
    BOOL            Truncate( DWORD dwCount );
    DWORD           GetCount() const        { return m_dwCount; }
    DDPIXELFORMAT*  GetEntries()            { return m_pEntries; }
    const DDPIXELFORMAT* GetEntries() const { return m_pEntries; }

    DDPIXELFORMAT&  operator[](int i)            { return m_pEntries[i]; }
    const DDPIXELFORMAT& operator[](int i) const { return m_pEntries[i]; }

    PixelFormatList IntersectWith( const PixelFormatList& with ) const;

    // generate the union of all of the lists
    static PixelFormatList  Union( const PixelFormatList* pLists, DWORD dwCount );

    static DWORD FindListContaining( const DDPIXELFORMAT& ddFormat, const PixelFormatList* pLists, DWORD dwCount );

private:
    BOOL            Realloc( DWORD dwCount );
    DWORD           m_dwCount;
    DDPIXELFORMAT*  m_pEntries;
};

#endif //__PixelFormatList__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vpm\drect.h ===
/******************************Module*Header*******************************\
* Module Name: DRect.h
*
*
*
*
* Created: Tue 05/05/2000
* Author:  GlenneE
*
* Copyright (c) 2000 Microsoft Corporation
\**************************************************************************/
#ifndef __DRect__h
#define __DRect__h

class DRect
{
public:
            DRect( double dLeft, double dTop, double dRight, double dBottom )
                : m_left( dLeft )
                , m_right( dRight )
                , m_top( dTop )
                , m_bottom( dBottom ) {};

            DRect( const RECT& rc );
            DRect() {};
            ~DRect() {};

    // trivial dependency on RECT, covers the maximal area
    RECT    AsRECT() const;

    double  GetWidth() const { return m_right-m_left;}
    double  GetHeight() const { return m_bottom-m_top; }

    bool    IsEmpty() const { return m_left <= m_right || m_top <= m_bottom; }

    DRect   IntersectWith( const DRect& prDRect1 ) const;
    void    Scale( double dScaleX, double dScaleY );
    void    ClipWith(const DRect& prdSrcRect, DRect *pRectToMirrorChangesTo );

    double  CorrectAspectRatio( double dPictAspectRatio, BOOL bShrink );

public:
    double  m_left;
    double  m_top;
    double  m_right;
    double  m_bottom;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vpm\khandlearray.h ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
#ifndef __KHArray__
#define __KHArray__

class KernelHandleArray
{
public:
    KernelHandleArray( DWORD dwNumHandles );
    KernelHandleArray( LPDIRECTDRAWSURFACE7 pDDSurf, HRESULT& hr );

    ~KernelHandleArray();

    DWORD       GetCount() const { return m_dwCount; };
    ULONG_PTR*  GetHandles() { return m_pHandles; };

public:
    DWORD       m_dwCount;
    ULONG_PTR*  m_pHandles;

private:
    static HRESULT WINAPI SurfaceKernelHandle(
        LPDIRECTDRAWSURFACE7 lpDDSurface,
        LPDDSURFACEDESC2 lpDDSurfaceDesc,
        LPVOID lpContext
        );
};

#endif //__KHArray__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vpm\vpinfo.h ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
#ifndef __VP_INFO__
#define __VP_INFO__

// enum to specify, whether the videoport is in a stopped or running state
enum VPInfoState
{	
    VPInfoState_STOPPED,
    VPInfoState_RUNNING
};

enum VPInfoTransform
{
    VPInfoTransform_SHRINK,
    VPInfoTransform_STRETCH
};

enum VPInfoCropState
{	
    VPInfoCropState_None,
    VPInfoCropState_AtVideoPort
};

#ifndef DDVPCAPS_VBIANDVIDEOINDEPENDENT
// Indicates that the VBI and video  can  be controlled by an independent processes.
#define DDVPCAPS_VBIANDVIDEOINDEPENDENT		0x00002000l
#endif


// {0d60e9a1-09cb-4f6f-a6dd-1051debe3c3b}
DEFINE_GUID(IID_IVideoPortInfo,
0x0d60e9a1, 0x09cb, 0x4f6f, 0xa6, 0xdd, 0x10, 0x51, 0xde, 0xbe, 0x3c, 0x3b );

// we end up with header problems when including dvp.h from quartz.cpp, so we just need them for
// these forward declarations.  Its preferrable to defining the GUID twice
struct _AMVPDATAINFO;
struct _DDVIDEOPORTINFO;
struct _DDVIDEOPORTBANDWIDTH;
struct _DDPIXELFORMAT;
struct _DDVIDEOPORTCAPS;

typedef struct _AMVPDATAINFO        AMVPDATAINFO; 
typedef struct _DDVIDEOPORTINFO     DDVIDEOPORTINFO;
typedef struct _DDPIXELFORMAT       DDPIXELFORMAT;
typedef struct _DDVIDEOPORTCAPS     DDVIDEOPORTCAPS;
typedef struct _DDVIDEOPORTBANDWIDTH DDVIDEOPORTBANDWIDTH;

DECLARE_INTERFACE_(IVideoPortInfo, IUnknown)
{
    STDMETHOD (GetRectangles)       (THIS_ RECT *prcSource, RECT *prcDest ) PURE;
    STDMETHOD (GetCropState)        (THIS_ VPInfoCropState* pCropState ) PURE;
    STDMETHOD (GetPixelsPerSecond)  (THIS_ DWORD* pPixelPerSec ) PURE;
    STDMETHOD (GetVPDataInfo)       (THIS_ AMVPDATAINFO* pVPDataInfo ) PURE;
    STDMETHOD (GetVPInfo)           (THIS_ DDVIDEOPORTINFO* pVPInfo ) PURE;
    STDMETHOD (GetVPBandwidth)      (THIS_ DDVIDEOPORTBANDWIDTH* pVPBandwidth ) PURE;
    STDMETHOD (GetVPCaps)           (THIS_ DDVIDEOPORTCAPS* pVPCaps ) PURE;
    STDMETHOD (GetVPInputFormat)    (THIS_ DDPIXELFORMAT* pVPFormat ) PURE;
    STDMETHOD (GetVPOutputFormat)   (THIS_ DDPIXELFORMAT* pVPFormat ) PURE;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vpm\vbiobj.cpp ===
//==========================================================================
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999  All Rights Reserved.
//
//--------------------------------------------------------------------------

#include <streams.h>
#include <ddraw.h>
#include <VBIObj.h>
#include <VPMUtil.h>
#include <vpconfig.h>
#include <ddkernel.h>
#include <KHandleArray.h>
#include <FormatList.h>

//==========================================================================
// constructor
CVBIVideoPort::CVBIVideoPort(LPUNKNOWN pUnk, HRESULT* phr)
    : CUnknown(NAME("VBI Object"), pUnk)
    , m_pDDVPContainer(NULL)
    , m_pOffscreenSurf(NULL)
    , m_pOffscreenSurf1( NULL )
    , m_bConnected(FALSE)
    , m_pIVPConfig(NULL)
    , m_VPState(VP_STATE_NO_VP)
    , m_bFilterRunning(FALSE)
    , m_Communication(KSPIN_COMMUNICATION_SOURCE)
    , m_CategoryGUID(GUID_NULL)
    , m_pDirectDraw(NULL)
    , m_dwPixelsPerSecond(0)
    , m_dwVideoPortId(0)
    , m_pVideoPort(NULL)
    , m_dwDefaultOutputFormat( 0 )
{
    AMTRACE((TEXT("CVBIVideoPort::Constructor")));

    m_Medium.Set = GUID_NULL;
    m_Medium.Id = 0;
    m_Medium.Flags = 0;   

    ZeroStruct( m_capVPDataInfo );
    ZeroStruct( m_svpInfo );
    ZeroStruct( m_vpCaps );
    ZeroStruct( m_vpConnectInfo );

    ZeroStruct( m_ddVPInputVideoFormat );
    ZeroStruct( m_ddVPOutputVideoFormat );
}


//==========================================================================
// destructor
CVBIVideoPort::~CVBIVideoPort()
{
    AMTRACE((TEXT("CVBIVideoPort::Destructor")));

    if (m_bConnected)
    {
        DbgLog((LOG_ERROR, 0, TEXT("Destructor called without calling breakconnect")));
        BreakConnect();
    }

    return;
}


//==========================================================================
// overridden to expose IVPVBINotify and IVideoPortVBIObject
STDMETHODIMP CVBIVideoPort::NonDelegatingQueryInterface(REFIID riid, void** ppv)
{
    HRESULT hr = NOERROR;
    
    if (riid == IID_IVPVBINotify) 
    {
        DbgLog((LOG_TRACE, 4, TEXT("CVBIVideoPort::NonDelegatingQueryInterface(IID_IVPVBINotify)")));
        hr = GetInterface( static_cast<IVPVBINotify*>( this ), ppv);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 0, TEXT("GetInterface(IVPVBINotify*) failed, hr = 0x%x"), hr));
        }
    } 
    else if (riid == IID_IKsPin) 
    {
        DbgLog((LOG_TRACE, 4, TEXT("CVBIVideoPort::NonDelegatingQueryInterface(IID_IKsPin)")));
        hr = GetInterface( static_cast<IKsPin*>( this ), ppv);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 0, TEXT("GetInterface(IKsPin*) failed, hr = 0x%x"), hr));
        }
    } 
    else if (riid == IID_IKsPropertySet) 
    {
        DbgLog((LOG_TRACE, 4, TEXT("CVBIVideoPort::NonDelegatingQueryInterface(IID_IKsPropertySet)")));
        hr = GetInterface( static_cast<IKsPropertySet*>( this ), ppv);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 0, TEXT("GetInterface(IKsPropertySet*) failed, hr = 0x%x"), hr));
        }
    }
    else 
    {
        DbgLog((LOG_TRACE, 4, TEXT("CVBIVideoPort::NonDelegatingQueryInterface(Other)")));
        hr = CUnknown::NonDelegatingQueryInterface(riid, ppv);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 0, TEXT("CUnknown::NonDelegatingQueryInterface failed, hr = 0x%x"), hr));
        }
    }
    return hr;
}


//==========================================================================
// sets the pointer to directdraw
STDMETHODIMP CVBIVideoPort::SetDirectDraw(LPDIRECTDRAW7 pDirectDraw)
{
    CAutoLock cObjectLock(m_pMainObjLock);
    AMTRACE((TEXT("CVBIVideoPort::SetDirectDraw")));

    HRESULT hr = NOERROR;
    m_pDirectDraw = pDirectDraw;
    return hr;
}


//==========================================================================
// sets the pointer to the lock, which would be used to synchronize calls to the object
STDMETHODIMP CVBIVideoPort::SetObjectLock(CCritSec* pMainObjLock)
{
    AMTRACE((TEXT("CVBIVideoPort::SetObjectLock")));
    HRESULT hr = NOERROR;

    if (!pMainObjLock)
    {
        DbgLog((LOG_ERROR, 0, TEXT("pMainObjLock is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }
    
    m_pMainObjLock = pMainObjLock;

CleanUp:
    return hr;
}


//==========================================================================
// check that the mediatype is acceptable
STDMETHODIMP CVBIVideoPort::CheckMediaType(const CMediaType* pmt)
{
    CAutoLock cObjectLock(m_pMainObjLock);
    AMTRACE((TEXT("CVBIVideoPort::CheckMediaType")));

    HRESULT hr = NOERROR;
    
    if  ((pmt->majortype != MEDIATYPE_Video) || (pmt->subtype != MEDIASUBTYPE_VPVBI))
    {
        hr = VFW_E_TYPE_NOT_ACCEPTED;
        goto CleanUp;
    }
    
CleanUp:
    return hr;
}


//==========================================================================
HRESULT CVBIVideoPort::GetMediaType(int iPosition, CMediaType* pmt)
{
    CAutoLock cObjectLock(m_pMainObjLock);
    AMTRACE((TEXT("CVBIVideoPort::GetMediaType")));

    HRESULT hr = S_OK;

    if (iPosition == 0)
    {
        pmt->SetType(&MEDIATYPE_Video);
        pmt->SetSubtype(&MEDIASUBTYPE_VPVBI);
        pmt->SetFormatType(&FORMAT_None);
        pmt->SetSampleSize(1);
        pmt->SetTemporalCompression(FALSE);
    }
    else if (iPosition > 0)  {
        hr = VFW_S_NO_MORE_ITEMS;
    } else { // iPosition < 0
        hr = E_INVALIDARG;
    }
    return hr;
}


//==========================================================================
// 
STDMETHODIMP CVBIVideoPort::CheckConnect(IPin*  pReceivePin)
{
    CAutoLock cObjectLock(m_pMainObjLock);
    AMTRACE((TEXT("CVBIVideoPort::CheckConnect")));

    HRESULT hr = NOERROR;
    PKSMULTIPLE_ITEM pMediumList = NULL;
    IKsPin* pIKsPin = NULL;
    PKSPIN_MEDIUM pMedium = NULL;

    hr = pReceivePin->QueryInterface(IID_IKsPin, (void** )&pIKsPin);
    if (FAILED(hr))
        goto CleanUp;

    ASSERT(pIKsPin);
    hr = pIKsPin->KsQueryMediums(&pMediumList);
    if (FAILED(hr))
        goto CleanUp;

    ASSERT(pMediumList);
    pMedium = (KSPIN_MEDIUM* )(pMediumList+1);
    SetKsMedium((const KSPIN_MEDIUM* )pMedium);

CleanUp:
    RELEASE (pIKsPin);

    if (pMediumList)
    {
        CoTaskMemFree((void*)pMediumList);
        pMediumList = NULL;
    }

    return hr;
}


//==========================================================================
// supposed to be called when the host connects with the decoder
STDMETHODIMP CVBIVideoPort::CompleteConnect(IPin* pReceivePin)
{
    CAutoLock cObjectLock(m_pMainObjLock);
    AMTRACE((TEXT("CVBIVideoPort::CompleteConnect")));
    ASSERT(!m_bConnected);

    HRESULT hr = NOERROR;

    // re-initialize variables
    m_dwPixelsPerSecond = 0;
    ZeroStruct( m_vpConnectInfo );
    ZeroStruct( m_capVPDataInfo );

    if (!m_pDirectDraw)
    {
        DbgLog((LOG_ERROR, 0, TEXT("m_pDirectDraw is NULL")));
        hr = VFW_E_VP_NEGOTIATION_FAILED;
        goto CleanUp;
    }
    
    ASSERT(m_pIVPConfig == NULL);
    RELEASE( m_pIVPConfig );
    hr = pReceivePin->QueryInterface(IID_IVPVBIConfig, (void** )&m_pIVPConfig);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,  TEXT("QueryInterface(IID_IVPVBIConfig) failed, hr = 0x%x"), hr));
        hr = VFW_E_NO_TRANSPORT;
        goto CleanUp;
    }
    ASSERT(m_pIVPConfig);
    
    // create the VP container
    ASSERT(m_pDDVPContainer == NULL);
    hr = m_pDirectDraw->QueryInterface( IID_IDDVideoPortContainer, (LPVOID* )&m_pDDVPContainer);
    if (FAILED(hr)) 
    {
        DbgLog((LOG_ERROR,0,  TEXT("m_pDirectDraw->QueryInterface(IID_IDDVideoPortContainer) failed, hr = 0x%x"), hr));
        hr = VFW_E_VP_NEGOTIATION_FAILED;
        goto CleanUp;
    }

    // negotiate the connection parameters
    // get/set connection info happens here
    hr = NegotiateConnectionParameters();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("NegotiateConnectionParameters failed, hr = 0x%x"), hr));
        hr = VFW_E_VP_NEGOTIATION_FAILED;
        goto CleanUp;
    }
    
    // get the decoder data parameters
    hr = GetDecoderVPDataInfo();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("GetDecoderVPDataInfo failed, hr = 0x%x"), hr));
        hr = VFW_E_VP_NEGOTIATION_FAILED;
        goto CleanUp;
    }

    hr = SetupVideoPort();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("SetupVideoPort failed, hr = 0x%x"), hr));
        hr = VFW_E_VP_NEGOTIATION_FAILED;
        goto CleanUp;
    }

    // Success!
    m_bConnected = TRUE;
    
CleanUp:
    if (FAILED(hr))
        BreakConnect();

    return hr;
}


//==========================================================================
STDMETHODIMP CVBIVideoPort::BreakConnect()
{
    CAutoLock cObjectLock(m_pMainObjLock);
    AMTRACE((TEXT("CVBIVideoPort::BreakConnect")));
    ASSERT(!m_bFilterRunning);

    HRESULT hr = NOERROR;

	if( m_bConnected ) {
		if (m_VPState == VP_STATE_RUNNING)
		{
			DbgLog((LOG_ERROR, 0, TEXT("BreakConnect called while videoport running")));
			StopVideo();
		}

		if (m_VPState == VP_STATE_STOPPED)
		{
			hr = TearDownVideoPort();
			if (FAILED(hr))
			{
				DbgLog((LOG_ERROR, 0, TEXT("TearDownVideoPort failed, hr = 0x%x"), hr));
				return hr;
			}
		}

		// release the videoport container
		RELEASE (m_pDDVPContainer);
    
		// release the IVPConfig interface
		RELEASE (m_pIVPConfig);

		// delete the output Video pixelformat
		ZeroStruct( m_ddVPOutputVideoFormat);

		// delete the input Video pixelformat 
		ZeroStruct( m_ddVPInputVideoFormat);
		m_bConnected = FALSE;
    }
    return hr;
}       


//==========================================================================
// transition from Stop to Pause.
// We do not need to to anything
STDMETHODIMP CVBIVideoPort::Active()
{
    CAutoLock cObjectLock(m_pMainObjLock);
    AMTRACE((TEXT("CVBIVideoPort::Active")));
    ASSERT(m_bConnected);
    ASSERT(!m_bFilterRunning);
    ASSERT(m_VPState != VP_STATE_RUNNING);

    HRESULT hr = NOERROR;

    if (!m_bConnected)
    {
        hr = VFW_E_NOT_CONNECTED;
        DbgLog((LOG_ERROR, 0, TEXT("CVBIVideoPort::Active - not connected")));
        goto CleanUp;
    }

CleanUp:
    return hr;
}


//==========================================================================
// transition (from Pause or Run) to Stop
STDMETHODIMP CVBIVideoPort::Inactive()
{
    CAutoLock cObjectLock(m_pMainObjLock);
    AMTRACE((TEXT("CVBIVideoPort::Inactive")));
    ASSERT(m_bConnected);

    HRESULT hr = NOERROR;
    
    if (!m_bConnected)
    {
        hr = VFW_E_NOT_CONNECTED;
        DbgLog((LOG_ERROR, 0, TEXT("CVBIVideoPort::Inactive - not connected")));
        goto CleanUp;
    }
    
    // Inactive is also called when going from pause to stop, in which case the 
    // VideoPort would have already been stopped in the function RunToPause.
    // Also, we may have been temporarily disconnected from the videoport by
    // a full screen DOS box or a DirectX game, in which case m_VPState would be
    // VP_STATE_RETRYING
    if (m_VPState == VP_STATE_RUNNING)
    {
        ASSERT(m_bFilterRunning);
        // stop the VideoPort
        hr = StopVideo();
        if (FAILED(hr)) 
        {
            DbgLog((LOG_ERROR, 0, TEXT("StopVideo failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

    m_bFilterRunning = FALSE;
    
CleanUp:
    return hr;
}


//==========================================================================
// transition from Pause to Run. We just start the VideoPort.
STDMETHODIMP CVBIVideoPort::Run(REFERENCE_TIME tStart)
{
    CAutoLock cObjectLock(m_pMainObjLock);
    AMTRACE((TEXT("CVBIVideoPort::Run")));
    UNREFERENCED_PARAMETER(tStart);
    ASSERT(m_bConnected);
    ASSERT(!m_bFilterRunning);
    ASSERT(m_VPState != VP_STATE_RUNNING);

    HRESULT hr = NOERROR;

    if (!m_bConnected)
    {
        hr = VFW_E_NOT_CONNECTED;
        DbgLog((LOG_ERROR, 0, TEXT("CVBIVideoPort::Run - not connected")));
        goto CleanUp;
    }

    if (m_VPState == VP_STATE_NO_VP)
    {
        hr = SetupVideoPort();
        if (FAILED(hr)) 
        {
            DbgLog((LOG_ERROR, 0, TEXT("CVBIVideoPort::Run - SetupVideoPort failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

    hr = StartVideo();
    if (FAILED(hr)) 
    {
        DbgLog((LOG_ERROR, 0, TEXT("StartVideo failed, hr = 0x%x"), hr));
		ASSERT( SUCCEEDED(hr));
        goto CleanUp;
    }

    m_bFilterRunning = TRUE;

CleanUp:
    return hr;
}


//==========================================================================
// transition from Run to Pause. We just stop the VideoPort
// Note that transition from Run to Stop is caught by Inactive
STDMETHODIMP CVBIVideoPort::RunToPause()
{
    CAutoLock cObjectLock(m_pMainObjLock);
    AMTRACE((TEXT("CVBIVideoPort::RunToPause")));
    ASSERT(m_bConnected);
    ASSERT(m_bFilterRunning);

    HRESULT hr = NOERROR;
    
    if (!m_bConnected)
    {
        hr = VFW_E_NOT_CONNECTED;
        DbgLog((LOG_ERROR, 0, TEXT("CVBIVideoPort::RunToPause - not connected")));
        goto CleanUp;
    }

    // We may have been temporarily disconnected from the videoport by
    // a full screen DOS box or a DirectX game, in which case m_VPState would be
    // VP_STATE_RETRYING
    if (m_VPState == VP_STATE_RUNNING)
    {
        // stop the VideoPort
        hr = StopVideo();
        if (FAILED(hr)) 
        {
            DbgLog((LOG_ERROR, 0, TEXT("StopVideo failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

    m_bFilterRunning = FALSE;

CleanUp:
    return hr;
}


//==========================================================================
STDMETHODIMP CVBIVideoPort::GetVPDataInfo(AMVPDATAINFO* pAMVPDataInfo)
{
    CAutoLock cObjectLock(m_pMainObjLock);
    AMTRACE((TEXT("CVBIVideoPort::GetVPDataInfo")));

    HRESULT hr = NOERROR;

    if (!m_bConnected)
    {
        hr = VFW_E_NOT_CONNECTED;
        DbgLog((LOG_ERROR, 0, TEXT("CVBIVideoPort::GetVPDataInfo - not connected")));
        goto CleanUp;
    }

    if (!pAMVPDataInfo)
    {
        hr = E_INVALIDARG;
        DbgLog((LOG_ERROR, 2, TEXT("pAMVPDataInfo is NULL")));
        goto CleanUp;
    }
    
    *pAMVPDataInfo = m_capVPDataInfo;
    
CleanUp:
    return hr;
}


//==========================================================================
// this function is used to redo the whole videoport connect process, while the graph
// maybe be running.
STDMETHODIMP CVBIVideoPort::RenegotiateVPParameters()
{
    CAutoLock cObjectLock(m_pMainObjLock);
    DbgLog((LOG_TRACE, 1, TEXT("Entering CVBIVideoPort::RenegotiateVPParameters")));
    ASSERT(m_bConnected);

    HRESULT hr = NOERROR;

    if (!m_bConnected)
    {
        hr = VFW_E_NOT_CONNECTED;
        DbgLog((LOG_ERROR, 0, TEXT("CVBIVideoPort::RenegotiateVPParameters - not connected")));
        goto CleanUp;
    }

    if (m_VPState == VP_STATE_RUNNING)
        StopVideo();

    if (m_VPState == VP_STATE_STOPPED)
        TearDownVideoPort();

    hr = SetupVideoPort();   // always want_vp_setup (if connected)
    if (FAILED(hr)) 
    {
        DbgLog((LOG_ERROR,0, TEXT("SetupVideoPort failed in RenegotiateVPParameters, hr = 0x%x"), hr));
        goto CleanUp;
    }

    if (m_bFilterRunning)
    {
        hr = StartVideo();
        if (FAILED(hr)) 
        {
            DbgLog((LOG_ERROR,0, TEXT("StartVideo failed in RenegotiateVPParameters, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

CleanUp:
    DbgLog((LOG_TRACE, 1, TEXT("Leaving CVBIVideoPort::RenegotiateVPParameters, hr = 0x%x"), hr));

    return hr;
}


//==========================================================================
// IKsPin::Get implementation
STDMETHODIMP CVBIVideoPort::Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData,
	DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData, DWORD* pcbReturned)
{
    HRESULT hr = S_OK;

    AMTRACE((TEXT("CVBIVideoPort::Get")));

    if (guidPropSet != AMPROPSETID_Pin)
    {
        hr = E_PROP_SET_UNSUPPORTED;
        goto CleanUp;
    }

    if ((pPropData == NULL) && (pcbReturned == NULL))
    {
        hr = E_POINTER;
        goto CleanUp;
    }

    if (dwPropID == KSPROPERTY_PIN_CATEGORY)
    {
        if (pcbReturned)
           * pcbReturned = sizeof(GUID);
        if (pPropData != NULL)
        {
            if (cbPropData < sizeof(GUID))
            {
                hr = E_UNEXPECTED;
                goto CleanUp;
            }
           * (GUID* )pPropData = m_CategoryGUID;
        }
    }
    else if (dwPropID == KSPROPERTY_PIN_MEDIUMS)
    {
        if (pcbReturned)
           * pcbReturned = sizeof (KSPIN_MEDIUM);
        if (pPropData != NULL)
        {
            if (cbPropData < sizeof(KSPIN_MEDIUM))
            {
                hr = E_UNEXPECTED;
                goto CleanUp;
            }
           * (KSPIN_MEDIUM* )pPropData = m_Medium;
        }
    }
    else
        hr = E_PROP_ID_UNSUPPORTED;

CleanUp:
    return hr;
}


//==========================================================================
//
STDMETHODIMP CVBIVideoPort::QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD* pTypeSupport)
{
    HRESULT hr = S_OK;

    AMTRACE((TEXT("CVBIVideoPort::QuerySupported")));

    if (guidPropSet != AMPROPSETID_Pin)
    {
        hr = E_PROP_SET_UNSUPPORTED;
        goto CleanUp;
    }

    if ((dwPropID != KSPROPERTY_PIN_CATEGORY) && (dwPropID != KSPROPERTY_PIN_MEDIUMS))
    {
        hr = E_PROP_ID_UNSUPPORTED;
        goto CleanUp;
    }

    if (pTypeSupport)
       * pTypeSupport = KSPROPERTY_SUPPORT_GET;

CleanUp:
    return hr;
}


//==========================================================================
//
STDMETHODIMP CVBIVideoPort::KsQueryMediums(PKSMULTIPLE_ITEM* pMediumList)
{
    // The following special return code notifies the proxy that this pin is
    // not available as a kernel mode connection
    HRESULT hr = S_FALSE;

    AMTRACE((TEXT("CVBIVideoPort::KsQueryMediums")));
   * pMediumList = reinterpret_cast<PKSMULTIPLE_ITEM>(CoTaskMemAlloc(sizeof(**pMediumList)));
    if (!*pMediumList) 
    {
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }
    (*pMediumList)->Count = 0;
    (*pMediumList)->Size = sizeof(**pMediumList);

CleanUp:
    return hr;
}


//==========================================================================
//
STDMETHODIMP CVBIVideoPort::KsQueryInterfaces(PKSMULTIPLE_ITEM* pInterfaceList)
{
    PKSPIN_INTERFACE pInterface;
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVBIVideoPort::KsQueryInterfaces")));

   * pInterfaceList = reinterpret_cast<PKSMULTIPLE_ITEM>(CoTaskMemAlloc(sizeof(**pInterfaceList) + sizeof(*pInterface)));
    if (!*pInterfaceList) 
    {
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }
    (*pInterfaceList)->Count = 1;
    (*pInterfaceList)->Size = sizeof(**pInterfaceList) + sizeof(*pInterface);
    pInterface = reinterpret_cast<PKSPIN_INTERFACE>(*pInterfaceList + 1);
    pInterface->Set = KSINTERFACESETID_Standard;
    pInterface->Id = KSINTERFACE_STANDARD_STREAMING;
    pInterface->Flags = 0;

CleanUp:
    return hr;
}

//==========================================================================
//
STDMETHODIMP CVBIVideoPort::KsGetCurrentCommunication(KSPIN_COMMUNICATION* pCommunication, 
    KSPIN_INTERFACE* pInterface, KSPIN_MEDIUM* pMedium)
{
    AMTRACE((TEXT("CVBIVideoPort::KsGetCurrentCommunication")));

    if (pCommunication != NULL) 
       * pCommunication = m_Communication; 

    if (pInterface != NULL) 
    {
        pInterface->Set = KSINTERFACESETID_Standard;
        pInterface->Id = KSINTERFACE_STANDARD_STREAMING;
        pInterface->Flags = 0;
    }

    if (pMedium != NULL) 
       * pMedium = m_Medium;

    return NOERROR;
}


//==========================================================================
// Called every second or two by the thread in CSurfaceWatcher m_SurfaceWatcher,
// this function checks if we have lost our DDraw surface to a full-screen DOS box
// or a DirectX game. If we have (on this call or a previous one or on a call
// to RenegotiateVPParameters), attempt to get it back.
HRESULT CVBIVideoPort::CheckSurfaces()
{
    CAutoLock cObjectLock(m_pMainObjLock);
    //AMTRACE((TEXT("CVBIVideoPort::CheckSurfaces")));

    HRESULT hr = NOERROR;

    if (!m_bConnected)
    {
        //DbgLog((LOG_TRACE, 2, TEXT("CVBIVideoPort::CheckSurfaces - not connected")));
        goto CleanUp;
    }

    // First, see if we think we have surfaces but have really lost them.
    if (m_VPState != VP_STATE_NO_VP)
    {
        //DbgLog((LOG_TRACE, 1, TEXT("CVBIVideoPort::CheckSurfaces - checking surfaces")));
        if (m_pOffscreenSurf)
        {
            hr = m_pOffscreenSurf->IsLost();
            if (hr == DDERR_SURFACELOST)
            {
                DbgLog((LOG_TRACE, 1, TEXT("CVBIVideoPort::CheckSurfaces - Surface Lost!")));
                if (m_VPState == VP_STATE_RUNNING)
                {
                    hr = StopVideo();
                    if (FAILED(hr))
                    {
                        DbgLog((LOG_ERROR, 0, TEXT("CVBIVideoPort::CheckSurfaces - StopVideo failed (1), hr = 0x%x"), hr));
                        goto CleanUp;
                    }
                }
                TearDownVideoPort();
            }
        }
        else
        {
            DbgLog((LOG_ERROR, 0, TEXT("CVBIVideoPort::CheckSurfaces - no surface!")));
            if (m_VPState == VP_STATE_RUNNING)
            {
                hr = StopVideo();
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR, 0, TEXT("CVBIVideoPort::CheckSurfaces - StopVideo failed (2), hr = 0x%x"), hr));
                    goto CleanUp;
                }
            }
            TearDownVideoPort();
        }
    }

    // Next, check if our state is what we need. May have been changed above, or on a previous
    // call, or on a call to RenegotiateVPParameters.
    if (m_VPState == VP_STATE_NO_VP)
    {
        DbgLog((LOG_TRACE, 1, TEXT("CVBIVideoPort::CheckSurfaces - trying to re-setup videoport")));
        hr = SetupVideoPort();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0, TEXT("CVBIVideoPort::CheckSurfaces - SetupVideoPort failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

    if ((m_VPState == VP_STATE_STOPPED) && m_bFilterRunning)
    {
        hr = StartVideo();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0, TEXT("CVBIVideoPort::CheckSurfaces - StartVideo failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }


CleanUp:
    return NOERROR;
}


//==========================================================================
// this functions negotiates the connection parameters with
// the decoder. 
// Since this function might be called during renegotiation, the
// existing connection parameters are passed in as input and if 
// possible, we try to use the same parameters.
HRESULT CVBIVideoPort::GetVideoPortCaps()
{
    AMTRACE((TEXT("CVBIVideoPort::GetVideoPortCaps")));
    HRESULT hr = NOERROR;

    // vpCaps is scratch memory, results stored in this->m_vpCaps
    ZeroStruct( m_vpCaps );

    // DDVIDEOPORTCAPS vpCaps;
    // INITDDSTRUCT( vpCaps );

    hr = VPMUtil::FindVideoPortCaps( m_pDDVPContainer, &m_vpCaps, m_dwVideoPortId );
    if (FAILED(hr) || S_FALSE == hr )
    {
        DbgLog((LOG_ERROR,0,  TEXT("m_pDDVPContainer->EnumVideoPorts failed, hr = 0x%x"), hr));
        hr = VFW_E_VP_NEGOTIATION_FAILED;
        goto CleanUp;
    }

CleanUp:
    return hr;
}

//==========================================================================
// This functions negotiates the connection parameters with the decoder. 
HRESULT CVBIVideoPort::NegotiateConnectionParameters()
{
    HRESULT hr = NOERROR;
    
    LPDDVIDEOPORTCONNECT lpddCaptureConnect = NULL;
    DWORD dwNumCaptureEntries = 0;
    LPDDVIDEOPORTCONNECT lpddVideoPortConnect = NULL;
    DWORD dwNumVideoPortEntries = 0;
    BOOL bIntersectionFound = FALSE;
    DWORD i, j;
    
    AMTRACE((TEXT("CVBIVideoPort::NegotiateConnectionParameters")));

    ASSERT(m_pIVPConfig);
    ASSERT(m_pDDVPContainer);

    // find the number of entries to be proposed by the decoder
    hr = m_pIVPConfig->GetConnectInfo(&dwNumCaptureEntries, NULL);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("m_pIVPConfig->GetConnectInfo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    ASSERT(dwNumCaptureEntries);
    
    // allocate the necessary memory
    lpddCaptureConnect = (LPDDVIDEOPORTCONNECT) new BYTE [dwNumCaptureEntries*sizeof(DDVIDEOPORTCONNECT)];
    if (lpddCaptureConnect == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("NegotiateConnectionParameters : Out of Memory")));
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }
    
    // memset the allocated memory to zero
    memset(lpddCaptureConnect, 0, dwNumCaptureEntries*sizeof(DDVIDEOPORTCONNECT));
    
    // set the right size in each of the structs.
    for (i = 0; i < dwNumCaptureEntries; i++)
    {
        lpddCaptureConnect[i].dwSize = sizeof(DDVIDEOPORTCONNECT);
    }
    
    // get the entries proposed by the decoder
    hr = m_pIVPConfig->GetConnectInfo(&dwNumCaptureEntries, lpddCaptureConnect);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("m_pIVPConfig->GetConnectInfo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    // find the number of entries supported by the videoport
    hr = m_pDDVPContainer->GetVideoPortConnectInfo(m_dwVideoPortId, &dwNumVideoPortEntries, NULL);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("m_pDDVPContainer->GetVideoPortConnectInfo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    ASSERT(dwNumVideoPortEntries);

    // allocate the necessary memory
    lpddVideoPortConnect = (LPDDVIDEOPORTCONNECT) new BYTE[dwNumVideoPortEntries*sizeof(DDVIDEOPORTCONNECT)];
    if (lpddVideoPortConnect == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("NegotiateConnectionParameters : Out of Memory")));
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    // memset the allocated memory to zero
    memset(lpddVideoPortConnect, 0, dwNumVideoPortEntries*sizeof(DDVIDEOPORTCONNECT));

    // set the right size in each of the structs.
    for (i = 0; i < dwNumVideoPortEntries; i++)
    {
        lpddVideoPortConnect[i].dwSize = sizeof(DDVIDEOPORTCONNECT);
    }

    // get the entries supported by the videoport
    hr = m_pDDVPContainer->GetVideoPortConnectInfo(0, &dwNumVideoPortEntries, lpddVideoPortConnect);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("m_pDDVPContainer->GetVideoPortConnectInfo failed, hr = 0x%x"), hr));
        hr = E_FAIL;
        goto CleanUp;
    }

#ifdef DEBUG
        for (i = 0; i < dwNumCaptureEntries; i++)
            DbgLog((LOG_TRACE, 3, TEXT("lpddCaptureConnect[%d].dwFlags = 0x%x"), i, lpddCaptureConnect[i].dwFlags));
        for (j = 0; j < dwNumVideoPortEntries; j++)
            DbgLog((LOG_TRACE,3,TEXT("lpddVideoPortConnect[%d].dwFlags = 0x%x"), j, lpddVideoPortConnect[j].dwFlags));
#endif
        
        // take the first element of the intersection of the two lists and
        // set that value on the decoder
        for (i = 0; i < dwNumCaptureEntries && !bIntersectionFound; i++)
        {
            for (j = 0; j < dwNumVideoPortEntries && !bIntersectionFound; j++)
            {
                if (lpddCaptureConnect[i].dwPortWidth == lpddVideoPortConnect[j].dwPortWidth &&
                    IsEqualIID(lpddCaptureConnect[i].guidTypeID, lpddVideoPortConnect[j].guidTypeID))
                {
                    // make sure we save the right one (the one from the video port, not the one
                    // from the capture driver)
                    memcpy(&m_vpConnectInfo, (lpddVideoPortConnect+j), sizeof(DDVIDEOPORTCONNECT));
                    hr = m_pIVPConfig->SetConnectInfo(i);
                    if (FAILED(hr))
                    {
                        DbgLog((LOG_ERROR,0,TEXT("m_pIVPConfig->SetConnectInfo failed, hr = 0x%x"), hr));
                        goto CleanUp;
                    }

                    bIntersectionFound = TRUE;
                }
            }
        }

    if (!bIntersectionFound)
    {
        hr = E_FAIL;

        goto CleanUp;
    }
    
    // cleanup
CleanUp:
    delete [] lpddCaptureConnect;
    delete [] lpddVideoPortConnect;
    return hr;
}


//==========================================================================
// This functions gets various data parameters from the decoder
// parameters include dimensions, double-clock, vact etc.
// Also maximum pixel rate the decoder will output.
// This happens after the connnection parameters have been set-up
HRESULT CVBIVideoPort::GetDecoderVPDataInfo()
{
    HRESULT hr = NOERROR;
    DWORD dwMaxPixelsPerSecond = 0;
    AMVPSIZE amvpSize;
    
    AMTRACE((TEXT("CVBIVideoPort::GetDecoderVPDataInfo")));

    // set the size of the struct
    m_capVPDataInfo.dwSize = sizeof(AMVPDATAINFO);
    
    // get the VideoPort data information
    hr = m_pIVPConfig->GetVPDataInfo(&m_capVPDataInfo);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("m_pIVPConfig->GetVPDataInfo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    amvpSize.dwWidth = m_capVPDataInfo.amvpDimInfo.dwVBIWidth;
    amvpSize.dwHeight = m_capVPDataInfo.amvpDimInfo.dwVBIHeight;
    
    // get the maximum pixel rate the decoder will output
    hr = m_pIVPConfig->GetMaxPixelRate(&amvpSize, &dwMaxPixelsPerSecond);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("m_pIVPConfig->GetMaxPixelRate failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    m_dwPixelsPerSecond = dwMaxPixelsPerSecond;
    
CleanUp:
    return hr;
}


//==========================================================================
// Calls DDRAW to actually create the video port.
HRESULT CVBIVideoPort::CreateVideoPort()
{
    HRESULT hr = NOERROR;
    DDVIDEOPORTDESC svpDesc;
    
    AMTRACE((TEXT("CVBIVideoPort::CreateVideoPort")));

    INITDDSTRUCT( svpDesc );
    
    // fill up the fields of the description struct
    svpDesc.dwVBIWidth = m_capVPDataInfo.amvpDimInfo.dwVBIWidth;
    svpDesc.dwFieldHeight = m_capVPDataInfo.amvpDimInfo.dwFieldHeight;
    svpDesc.dwFieldWidth = m_capVPDataInfo.amvpDimInfo.dwFieldWidth;
    
    svpDesc.dwMicrosecondsPerField = m_capVPDataInfo.dwMicrosecondsPerField;
    svpDesc.dwMaxPixelsPerSecond = m_dwPixelsPerSecond;
    svpDesc.dwVideoPortID = m_dwVideoPortId;
    //DAG_TODO: need to use QueryVideoPortStatus
    svpDesc.VideoPortType.dwSize = sizeof(DDVIDEOPORTCONNECT);
    svpDesc.VideoPortType.dwPortWidth = m_vpConnectInfo.dwPortWidth;
    memcpy(&(svpDesc.VideoPortType.guidTypeID), &(m_vpConnectInfo.guidTypeID), sizeof(GUID));
    svpDesc.VideoPortType.dwFlags = 0;
    
    // if the decoder can send double clocked data and the videoport 
    // supports it, then set that property. This field is only valid
    // with an external signal.
    if (m_capVPDataInfo.bEnableDoubleClock &&
        m_vpConnectInfo.dwFlags & DDVPCONNECT_DOUBLECLOCK)
    {
        svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_DOUBLECLOCK;
    }
    
    // if the decoder can give an external activation signal and the 
    // videoport supports it, then set that property. This field is 
    // only valid with an external signal.
    if (m_capVPDataInfo.bEnableVACT && 
        m_vpConnectInfo.dwFlags & DDVPCONNECT_VACT)
    {
        svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_VACT;
    }
    
    // if the decoder can send interlaced data and the videoport 
    // supports it, then set that property.
    // !!!SJF_TODO - should we fail if the decoder can't send interlaced data?
    if (m_capVPDataInfo.bDataIsInterlaced)
    {
        svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_INTERLACED;
    }

    if (m_bHalfLineFix)
    {
        //!!!SJF_TODO - flip polarity back to normal on decoder?
        ASSERT(!m_capVPDataInfo.bFieldPolarityInverted);
        //!!!SJF_TODO - fail if videoport doesn't handle inverted polarity?
        ASSERT(m_vpConnectInfo.dwFlags & DDVPCONNECT_INVERTPOLARITY);
        DbgLog((LOG_TRACE, 3, TEXT("INVERTPOLARITY & HALFLINE")));
        
        svpDesc.VideoPortType.dwFlags |=
            (DDVPCONNECT_INVERTPOLARITY | DDVPCONNECT_HALFLINE);
    }
    
#if 0 // def DEBUG
    DbgLog((LOG_TRACE, 3, TEXT("CreateVideoPort - DDVIDEOPORTDESC")));
    DbgLog((LOG_TRACE, 3, TEXT("dwSize: %d"),svpDesc.dwSize));
    DbgLog((LOG_TRACE, 3, TEXT("dwFieldWidth: %d"),svpDesc.dwFieldWidth));
    DbgLog((LOG_TRACE, 3, TEXT("dwVBIWidth: %d"),svpDesc.dwVBIWidth));
    DbgLog((LOG_TRACE, 3, TEXT("dwFieldHeight: %d"),svpDesc.dwFieldHeight));
    DbgLog((LOG_TRACE, 3, TEXT("dwMicroseconds: %d"),svpDesc.dwMicrosecondsPerField));
    DbgLog((LOG_TRACE, 3, TEXT("dwMaxPixels: %d"),svpDesc.dwMaxPixelsPerSecond));
    DbgLog((LOG_TRACE, 3, TEXT("dwVideoPortID: %d"),svpDesc.dwVideoPortID));
    DbgLog((LOG_TRACE, 3, TEXT("dwReserved1: %d"),svpDesc.dwReserved1));
    DbgLog((LOG_TRACE, 3, TEXT("dwReserved2: %d"),svpDesc.dwReserved2));
    DbgLog((LOG_TRACE, 3, TEXT("dwReserved3: %d"),svpDesc.dwReserved3));
    DbgLog((LOG_TRACE, 3, TEXT("DDVIDEOPORTCONNECT")));
    DbgLog((LOG_TRACE, 3, TEXT("dwSize: %d"),svpDesc.VideoPortType.dwSize));
    DbgLog((LOG_TRACE, 3, TEXT("dwPortWidth: %d"),svpDesc.VideoPortType.dwPortWidth));
    DbgLog((LOG_TRACE, 3, TEXT("dwFlags: 0x%x"),svpDesc.VideoPortType.dwFlags));
    DbgLog((LOG_TRACE, 3, TEXT("GUID: 0x%x"),*((DWORD* )&svpDesc.VideoPortType.guidTypeID)));
    DbgLog((LOG_TRACE, 3, TEXT("dwReserved1: %d"),svpDesc.VideoPortType.dwReserved1));
#endif // DEBUG

    // create the videoport. The first parameter is dwFlags, reserved for 
    // future use by ddraw. The last parameter is pUnkOuter, again must be
    // NULL.
    hr = m_pDDVPContainer->CreateVideoPort(DDVPCREATE_VBIONLY, &svpDesc, &m_pVideoPort, NULL );
    if (FAILED(hr)) 
    {
        DbgLog((LOG_ERROR, 0, TEXT("Unable to create the video port, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
CleanUp:
    return hr;
}


//==========================================================================
// this function is used to allocate an offscreen surface to attach to the 
// videoport. 
// The allocation order it tries is just in decreasing amount of memory
// required.
// (3 buffers, single height)
// (2 buffers, single height)
// (1 buffer , single height).
HRESULT CVBIVideoPort::CreateVPSurface(void)
{
    DWORD dwMaxBuffers;
    HRESULT hr = NOERROR;
    DWORD dwCurHeight = 0, dwCurBuffers = 0;
    
    AMTRACE((TEXT("CVBIVideoPort::CreateVPSurface")));

    ASSERT(m_pDirectDraw);
    
    // we will try to allocate up to 3 buffers (unless the 
    // hardware can handle less than 3)
    dwMaxBuffers = 3;
    if (m_vpCaps.dwNumVBIAutoFlipSurfaces < dwMaxBuffers)
        dwMaxBuffers = m_vpCaps.dwNumVBIAutoFlipSurfaces;
    
    // initialize the fields of ddsdDesc
    DDSURFACEDESC2 ddsdDesc;
    INITDDSTRUCT( ddsdDesc );
    ddsdDesc.dwFlags = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT;
    ddsdDesc.ddpfPixelFormat = m_ddVPOutputVideoFormat;
    ddsdDesc.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN | DDSCAPS_VIDEOMEMORY | DDSCAPS_VIDEOPORT;

    // if we're bob interleaving, the VBI surface seems to need to be doubled too, so always
    // double it (the VBI surface memory is relatively small anyways)
    ddsdDesc.dwHeight = m_dwSurfaceHeight * 2;

    ddsdDesc.dwWidth = m_dwSurfacePitch;
    DbgLog((LOG_TRACE, 3, TEXT("Surface height %d, width %d, max buffers %d"),
        ddsdDesc.dwHeight, ddsdDesc.dwWidth, dwMaxBuffers));

    // we will only try to allocate more than one buffer if the videoport 
    // is cabable of autoflipping 
    if ((m_vpCaps.dwFlags & DDVPD_CAPS) && (m_vpCaps.dwCaps & DDVPCAPS_AUTOFLIP) && dwMaxBuffers > 1)
    {
        ddsdDesc.dwFlags |= DDSD_BACKBUFFERCOUNT;
        ddsdDesc.ddsCaps.dwCaps |= DDSCAPS_COMPLEX | DDSCAPS_FLIP;
        
        for (dwCurBuffers = dwMaxBuffers; !m_pOffscreenSurf &&  dwCurBuffers >= 2; dwCurBuffers--)
        {
            ddsdDesc.dwBackBufferCount = dwCurBuffers-1;

            hr = m_pDirectDraw->CreateSurface(&ddsdDesc, &m_pOffscreenSurf, NULL);
            if (SUCCEEDED(hr))
            {
                hr = m_pOffscreenSurf->QueryInterface( IID_IDirectDrawSurface,  (VOID **)&m_pOffscreenSurf1 );
                if( SUCCEEDED( hr )) {
                    DbgLog((LOG_TRACE, 3, TEXT("allocated %d backbuffers"), ddsdDesc.dwBackBufferCount));
                    goto CleanUp;
                } else {
                    // should never fail, but just in case try again
                    ASSERT( !"VBI Surface doesn't support DDraw1" );
                    RELEASE( m_pOffscreenSurf );
                }
            }
            else
            {
                DbgLog((LOG_ERROR, 0, TEXT("failed to allocate %d backbuffers, hr = 0x%x"),
                    ddsdDesc.dwBackBufferCount, hr));
            }
        }
    }
    
    // we should only reach this point when attempt to allocate multiple
    // buffers failed or no autoflip available
    DbgLog((LOG_ERROR, 0, TEXT("Warning: unable to allocate backbuffers")));
    
    ddsdDesc.dwFlags &= ~DDSD_BACKBUFFERCOUNT;
    ddsdDesc.ddsCaps.dwCaps &= ~(DDSCAPS_COMPLEX | DDSCAPS_FLIP);
    m_svpInfo.dwVPFlags &= ~DDVP_AUTOFLIP;

    hr = m_pDirectDraw->CreateSurface(&ddsdDesc, &m_pOffscreenSurf, NULL);
    if (SUCCEEDED(hr))
    {
        hr = m_pOffscreenSurf->QueryInterface( IID_IDirectDrawSurface,  (VOID **)&m_pOffscreenSurf1 );
        if( SUCCEEDED( hr )) {
            goto CleanUp;
        } else {
            // should never fail, but just in case try again
            ASSERT( !"VBI Surface doesn't support DDraw1" );
            RELEASE( m_pOffscreenSurf );
        }
    }
    
    ASSERT(!m_pOffscreenSurf);
    DbgLog((LOG_ERROR,0,  TEXT("Unable to create offscreen surface")));

CleanUp:
    return hr;
}

//==========================================================================
// this function is used to inform the decoder of the various ddraw kernel handle
// using IVPConfig interface
HRESULT CVBIVideoPort::SetDDrawKernelHandles()
{
    HRESULT hr = NOERROR;
    IDirectDrawKernel* pDDK = NULL;
    IDirectDrawSurfaceKernel* pDDSK = NULL;
    ULONG_PTR* rgKernelHandles = NULL;
    DWORD dwCount = 0;
    ULONG_PTR ddKernelHandle = 0;
    
    AMTRACE((TEXT("CVBIVideoPort::SetDDrawKernelHandles")));

    // get the IDirectDrawKernel interface
    ASSERT(m_pDirectDraw);
    hr = m_pDirectDraw->QueryInterface(IID_IDirectDrawKernel, (LPVOID* )&pDDK);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("QueryInterface for IDirectDrawKernel failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    // get the kernel handle
    ASSERT(pDDK);
    hr = pDDK->GetKernelHandle(&ddKernelHandle);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("GetKernelHandle from IDirectDrawKernel failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    // set the kernel handle to directdraw using IVPConfig
    ASSERT(m_pIVPConfig);
    ASSERT(ddKernelHandle);
    hr = m_pIVPConfig->SetDirectDrawKernelHandle(ddKernelHandle);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("IVPConfig::SetDirectDrawKernelHandle failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    // set the VidceoPort Id using IVPConfig
    ASSERT(m_pIVPConfig);
    hr = m_pIVPConfig->SetVideoPortID(m_dwVideoPortId);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("IVPConfig::SetVideoPortID failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    {
        // should not be NULL
        ASSERT( m_pOffscreenSurf1 );

        KernelHandleArray pArray( m_pOffscreenSurf, hr );

        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,TEXT("GetKernelHandles failed, hr = 0x%x"), hr));
            goto CleanUp;
        }

        // set the kernel handle to the offscreen surface using IVPConfig
        ASSERT(m_pIVPConfig);
        hr = m_pIVPConfig->SetDDSurfaceKernelHandles( pArray.GetCount(), pArray.GetHandles() );
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,TEXT("IVPConfig::SetDDSurfaceKernelHandles failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    
        // call SetSurfaceParameters interface on IVPConfig
        ASSERT(m_pIVPConfig);
        DbgLog((LOG_TRACE, 3, TEXT("SetSurfaceParams(%d,%d,%d)"),
            m_dwSurfacePitch, m_dwSurfaceOriginX, m_dwSurfaceOriginY));
        hr = m_pIVPConfig->SetSurfaceParameters(m_dwSurfacePitch,
            m_dwSurfaceOriginX,m_dwSurfaceOriginY);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,TEXT("IVPConfig::SetSurfaceParameters failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    
CleanUp:
    // release the kernel ddraw handle
    RELEASE (pDDK);
    return hr;
}


/*****************************Private*Routine******************************\
* CVideoPortObj::NegotiatePixelFormat
*
* this function is used to negotiate the pixelformat with the decoder.
* It asks the decoder fot a list of input formats, intersects that list
* with the one the deocoder supports (while maintaining the order) and
* then calls "GetBestFormat" on that list to get the "best" input and
* output format. After that it calls "SetPixelFormat" on the decoder in
* order to inform the decoder of the decision.
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVBIVideoPort::GetInputPixelFormats( PixelFormatList* pList )
{
    AMTRACE((TEXT("CVideoPortObj::NegotiatePixelFormat")));
    CAutoLock cObjectLock(m_pMainObjLock);

    HRESULT hr = NOERROR;
    // find the number of entries to be proposed
    DWORD dwNumProposedEntries = 0;
    hr = m_pIVPConfig->GetVideoFormats(&dwNumProposedEntries, NULL);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetVideoFormats failed, hr = 0x%x"), hr));
        return hr;
    }
    ASSERT(dwNumProposedEntries);

    // find the number of entries supported by the videoport
    DWORD dwNumVPInputEntries = 0;
    hr = m_pVideoPort->GetInputFormats(&dwNumVPInputEntries, NULL, DDVPFORMAT_VBI);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pVideoPort->GetInputFormats failed, hr = 0x%x"), hr));
        return hr;
    }
    ASSERT(dwNumVPInputEntries);

    // allocate the necessary memory
    PixelFormatList lpddProposedFormats(dwNumProposedEntries);
    if (lpddProposedFormats.GetEntries() == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("NegotiatePixelFormat : Out of Memory")));
        hr = E_OUTOFMEMORY;
        return hr;
    }

    // get the entries proposed
    hr = m_pIVPConfig->GetVideoFormats(&dwNumProposedEntries, lpddProposedFormats.GetEntries() );
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetVideoFormats failed, hr = 0x%x"), hr));
        return hr;
    }

    // allocate the necessary memory
    PixelFormatList lpddVPInputFormats(dwNumVPInputEntries);
    if (lpddVPInputFormats.GetEntries() == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("NegotiatePixelFormat : Out of Memory")));
        hr = E_OUTOFMEMORY;
        return hr;
    }

    // get the entries supported by the videoport
    hr = m_pVideoPort->GetInputFormats(&dwNumVPInputEntries,
                                       lpddVPInputFormats.GetEntries(), DDVPFORMAT_VBI);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pVideoPort->GetInputFormats failed, hr = 0x%x"), hr));
        hr = E_FAIL;
        return hr;
    }

    *pList = lpddVPInputFormats.IntersectWith( lpddProposedFormats );

    // the number of entries in the intersection is zero!!
    // Return failure.
    if (pList->GetCount() == 0)
    {
        hr = E_FAIL;
        return hr;
    }

    // call GetBestFormat with whatever search criterion you want
    // DWORD dwBestEntry;
    // hr = GetBestFormat(lpddIntersectionFormats.GetCount(),
    //                    lpddIntersectionFormats.GetEntries(), TRUE, &dwBestEntry,
    //                    &m_ddVPOutputVideoFormat);
    // if (FAILED(hr))
    // {
    //     DbgLog((LOG_ERROR,0,TEXT("GetBestFormat failed, hr = 0x%x"), hr));
    // } else {
    //      hr = SetVPInputPixelFormat( lpddIntersectionFormats[dwBestEntry] )
    // }
    return hr;
}

HRESULT
CVBIVideoPort::GetOutputPixelFormats(
    const PixelFormatList& ddInputFormats,
    PixelFormatList* pddOutputFormats )
{
    HRESULT hr = S_OK;
    AMTRACE((TEXT("CVideoPortObj::GetOutputFormats")));

    CAutoLock cObjectLock(m_pMainObjLock);

    for (DWORD i = 0; i < ddInputFormats.GetCount(); i++)
    {
        // For each input format, figure out the output formats
        DDPIXELFORMAT* pInputFormat = const_cast<DDPIXELFORMAT*>(&ddInputFormats[i]);
        DWORD dwNumOutputFormats;
        hr = m_pVideoPort->GetOutputFormats(pInputFormat,
                                            &dwNumOutputFormats,
                                            NULL, DDVPFORMAT_VBI);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,
                    TEXT("m_pVideoPort->GetOutputFormats failed, hr = 0x%x"),
                    hr));
            break;
        }
        ASSERT(dwNumOutputFormats);

        // allocate the necessary memory
        pddOutputFormats[i].Reset( dwNumOutputFormats );

        if (pddOutputFormats[i].GetEntries() == NULL)
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("new failed, failed to allocate memnory for ")
                    TEXT("lpddOutputFormats in NegotiatePixelFormat")));
            hr = E_OUTOFMEMORY;
            break;
        }

        // get the entries supported by the videoport
        hr = m_pVideoPort->GetOutputFormats(pInputFormat,
                                            &dwNumOutputFormats,
                                            pddOutputFormats[i].GetEntries(),
                                            DDVPFORMAT_VBI);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,
                    TEXT("m_pVideoPort->GetOutputFormats failed, hr = 0x%x"),
                    hr));
            break;
        }
    } // end of outer for loop
    return hr;
}

HRESULT CVBIVideoPort::SetInputPixelFormat( DDPIXELFORMAT& ddFormat )
{
    HRESULT hr = NOERROR;
    // find the number of entries to be proposed
    DWORD dwNumProposedEntries = 0;
    hr = m_pIVPConfig->GetVideoFormats(&dwNumProposedEntries, NULL);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetVideoFormats failed, hr = 0x%x"), hr));
        return hr;
    }
    ASSERT(dwNumProposedEntries);

    PixelFormatList lpddProposedFormats(dwNumProposedEntries);
    if (lpddProposedFormats.GetEntries() == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("NegotiatePixelFormat : Out of Memory")));
        hr = E_OUTOFMEMORY;
        return hr;
    }

    // get the entries proposed
    hr = m_pIVPConfig->GetVideoFormats(&dwNumProposedEntries, lpddProposedFormats.GetEntries() );
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetVideoFormats failed, hr = 0x%x"), hr));
        return hr;
    }

    // set the format the decoder is supposed to be using
    for (DWORD i = 0; i < dwNumProposedEntries; i++)
    {
        if (VPMUtil::EqualPixelFormats(lpddProposedFormats[i], ddFormat ))
        {
            hr = m_pIVPConfig->SetVideoFormat(i);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR,0,
                        TEXT("m_pIVPConfig->SetVideoFormat failed, hr = 0x%x"),
                        hr));
                return hr;
            }
            // cache the input format
            m_ddVPInputVideoFormat = ddFormat;

            break;
        }
    }
    return hr;
}

//==========================================================================
HRESULT CVBIVideoPort::InitializeVideoPortInfo()
{
    HRESULT hr = NOERROR;
    RECT rcVPCrop;

    AMTRACE((TEXT("CVBIVideoPort::InitializeVideoPortInfo")));

    m_dwSurfacePitch = m_capVPDataInfo.amvpDimInfo.dwVBIWidth;
    m_dwSurfaceHeight = m_capVPDataInfo.amvpDimInfo.dwVBIHeight;
    m_dwSurfaceOriginX = m_capVPDataInfo.amvpDimInfo.rcValidRegion.left;
    m_dwSurfaceOriginY = m_capVPDataInfo.amvpDimInfo.rcValidRegion.top;
    m_bHalfLineFix = FALSE;

    // If we ask the videoport to do cropping, the bottom of the cropping
    // region MUST touch but not overlap the top of the cropping region
    // for video set by OVMIXER due to h/w limitations.
    // So, the bottom of our crop region is always dwVBIHeight (or
    // possibly dwVBIHeight+1 if certain halfline fixes are in effect,
    // see below) even if the capture driver hasn't set ValidRegion to
    // include that many lines.
    rcVPCrop.top = 0;
    rcVPCrop.left = 0;
    rcVPCrop.bottom = m_capVPDataInfo.amvpDimInfo.dwVBIHeight;
    rcVPCrop.right = m_capVPDataInfo.amvpDimInfo.dwVBIWidth;

    // Adjust for half-lines
    // Some video decoders send halflines in even or odd field.
    // Some video ports capture halflines, some don't.
    // See Video Line Numbering using VPE by smac
    if (m_vpConnectInfo.dwFlags & DDVPCONNECT_HALFLINE) // e.g. ATI videoport
    {
        if ((m_capVPDataInfo.lHalfLinesOdd == 0) &&
        (m_capVPDataInfo.lHalfLinesEven == 1))  // e.g. Brooktree decoder
        {
            // ATI All In Wonder (AIW) board
            // halfline problem
            DbgLog((LOG_TRACE, 3, TEXT("Setting up for AIW h/w")));
            m_dwSurfaceHeight++;
            rcVPCrop.bottom += 1;
            m_bHalfLineFix = TRUE;
        }
        else if (((m_capVPDataInfo.lHalfLinesOdd == -1) && (m_capVPDataInfo.lHalfLinesEven ==  0)) ||   // e.g. Philips decoder
                 ((m_capVPDataInfo.lHalfLinesOdd ==  0) && (m_capVPDataInfo.lHalfLinesEven == -1)) ||   // e.g. ? decoder
                 ((m_capVPDataInfo.lHalfLinesOdd ==  0) && (m_capVPDataInfo.lHalfLinesEven ==  0)))     // e.g. ? decoder
        {
            // no halfline problem, do nothing
        }
        else
        {
            // YIKES! We have no solution for these cases (if they even exist)!
            DbgLog((LOG_ERROR, 0,TEXT("CVBIVideoPort::InitializeVideoPortInfo: unfixable halfline problem!")));
            hr = VFW_E_VP_NEGOTIATION_FAILED;
            goto CleanUp;
        }
    }
    else    // videoport that doesn't capture halflines
    {
        if ((m_capVPDataInfo.lHalfLinesOdd == -1) &&
            (m_capVPDataInfo.lHalfLinesEven == 0))  // e.g. Philips decoder
        {
            // halfline problem
            m_dwSurfaceHeight++;
            rcVPCrop.top -= 1;
            m_bHalfLineFix = TRUE;
        }
        else if (((m_capVPDataInfo.lHalfLinesOdd ==  0) && (m_capVPDataInfo.lHalfLinesEven ==  1)) ||   // e.g. BT829 decoder
                 ((m_capVPDataInfo.lHalfLinesOdd ==  1) && (m_capVPDataInfo.lHalfLinesEven ==  0)) ||   // e.g. ? decoder
                 ((m_capVPDataInfo.lHalfLinesOdd ==  0) && (m_capVPDataInfo.lHalfLinesEven ==  0)))     // e.g. ? decoder
        {
            // no halfline problem, do nothing
        }
        else
        {
            // YIKES! We have no solution for these cases (if they even exist)!
            DbgLog((LOG_ERROR, 0,TEXT("CVBIVideoPort::InitializeVideoPortInfo: unfixable halfline problem!")));
            hr = VFW_E_VP_NEGOTIATION_FAILED;
            goto CleanUp;
        }
    }

    // Adjust if video discards lines during the VREF period
    if (m_vpConnectInfo.dwFlags & DDVPCONNECT_DISCARDSVREFDATA)
    {
        DbgLog((LOG_TRACE, 3, TEXT("VideoPort discards %d VREF lines"),
            m_capVPDataInfo.dwNumLinesInVREF));
        ASSERT(m_dwSurfaceOriginY >= m_capVPDataInfo.dwNumLinesInVREF);
        m_dwSurfaceOriginY -= m_capVPDataInfo.dwNumLinesInVREF;
        m_dwSurfaceHeight -= m_capVPDataInfo.dwNumLinesInVREF;
        rcVPCrop.bottom -= m_capVPDataInfo.dwNumLinesInVREF;
    }

    // initialize the DDVIDEOPORTINFO struct to be passed to pVideoport->StartVideo
    INITDDSTRUCT( m_svpInfo );

    m_svpInfo.dwVBIHeight = m_dwSurfaceHeight;
    // Assume we're going to be able to autoflip
    m_svpInfo.dwVPFlags = DDVP_AUTOFLIP;
    // pixelformats get filled in in NegotiatePixelFormats

#if 0   // !!!SJF_TODO - ATI says that cropping for VBI is not supported.
    // We always set h/w cropping in the Y direction if we can.
    // For VBI, we don't need to do cropping in the X direction.
    // Can the videoport crop in the Y direction?
    if ((m_vpCaps.dwFlags & DDVPD_FX) && (m_vpCaps.dwFX & DDVPFX_CROPY))
    {
        rcVPCrop.top = m_dwSurfaceOriginY;
        m_dwSurfaceHeight -= m_dwSurfaceOriginY;
        m_dwSurfaceOriginY = 0;

        m_svpInfo.rCrop = rcVPCrop;
        m_svpInfo.dwVPFlags |= DDVP_CROP;

        DbgLog((LOG_TRACE, 3, TEXT("Cropping left top:      (%d,%d)"),
            m_svpInfo.rCrop.left, m_svpInfo.rCrop.top));
        DbgLog((LOG_TRACE, 3, TEXT("Cropping bottom right:  (%d,%d)"),
            m_svpInfo.rCrop.right, m_svpInfo.rCrop.bottom));
    }
    else
    {
        if (m_bHalfLineFix)
        {
            DbgLog((LOG_ERROR, 0,TEXT("CVBIVideoPort::InitializeVideoPortInfo: can't crop to fix halfline problem!")));
            hr = VFW_E_VP_NEGOTIATION_FAILED;
            goto CleanUp;
        }
    }
#endif  // 0

    if (m_bHalfLineFix)
    {
        if (!(m_vpConnectInfo.dwFlags & DDVPCONNECT_INVERTPOLARITY))
        {
            DbgLog((LOG_ERROR, 0, TEXT("CVBIVideoPort::InitializeVideoPortInfo: can't invert polarity to fix halfline problem!")));
            hr = VFW_E_VP_NEGOTIATION_FAILED;
            goto CleanUp;
        }
    }

#if 0 // def DEBUG
    DbgLog((LOG_TRACE, 3, TEXT("m_dwSurfaceHeight:  %d"),m_dwSurfaceHeight));
    DbgLog((LOG_TRACE, 3, TEXT("m_dwSurfacePitch:   %d"),m_dwSurfacePitch));
    DbgLog((LOG_TRACE, 3, TEXT("m_dwSurfaceOriginX: %d"),m_dwSurfaceOriginX));
    DbgLog((LOG_TRACE, 3, TEXT("m_dwSurfaceOriginY: %d"),m_dwSurfaceOriginY));
#endif // DEBUG

CleanUp:

    return hr;
}


//==========================================================================
//
HRESULT CVBIVideoPort::SetupVideoPort()
{
    AMTRACE((TEXT("CVBIVideoPort::SetupVideoPort")));
    ASSERT(m_VPState == VP_STATE_NO_VP);

    HRESULT hr = NOERROR;

    // initialize variables
    ZeroStruct( m_svpInfo );
    ZeroStruct( m_vpCaps );

    // Get the Video Port caps
    hr = GetVideoPortCaps();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("GetVideoPortCaps failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // initalize the DDVideoPortInfo structure
    hr = InitializeVideoPortInfo();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("InitializeVideoPortInfo FAILED, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    // create the video port
    hr = CreateVideoPort();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CreateVideoPort failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    // negotiate the pixel format 
    hr = NegotiatePixelFormat();
    if ( FAILED( hr ))
    {
        DbgLog((LOG_ERROR, 0, TEXT("NegotiatePixelFormat Failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    // Update the m_svpInfo structure which was mostly filled in in
    // InitializeVideoPortInfo
    ASSERT(VPMUtil::EqualPixelFormats(m_ddVPInputVideoFormat, m_ddVPOutputVideoFormat));
    m_svpInfo.lpddpfVBIInputFormat = &m_ddVPInputVideoFormat;
    m_svpInfo.lpddpfVBIOutputFormat = &m_ddVPOutputVideoFormat;


    // create the offscreen surface
    hr = CreateVPSurface();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CreateVPSurface FAILED, hr = 0x%x"), hr));
        hr = VFW_E_OUT_OF_VIDEO_MEMORY;
        goto CleanUp;
    }
    
    // attach the offscreen surface to the videoport
    hr = m_pVideoPort->SetTargetSurface(m_pOffscreenSurf1, DDVPTARGET_VBI);
    if (FAILED(hr)) 
    {
        DbgLog((LOG_ERROR, 0, TEXT("m_pVideoPort->SetTargetSurface failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    // inform the decoder of the ddraw kernel handle, videoport id and surface kernel
    // handle
    hr = SetDDrawKernelHandles();
    if (FAILED(hr)) 
    {
        DbgLog((LOG_ERROR, 0, TEXT("SetDDrawKernelHandles failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    m_VPState = VP_STATE_STOPPED;

CleanUp:
    if (FAILED(hr))
        TearDownVideoPort();


    return hr;
}

HRESULT CVBIVideoPort::NegotiatePixelFormat()
{
    PixelFormatList ddInputVideoFormats;
    HRESULT hr = GetInputPixelFormats( &ddInputVideoFormats );
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("NegotiatePixelFormat Failed, hr = 0x%x"), hr));
    } else {
        PixelFormatList* pddOutputVideoFormats = NULL;
        if( ddInputVideoFormats.GetCount() ) {
            pddOutputVideoFormats = new PixelFormatList[ ddInputVideoFormats.GetCount() ];
            if( !pddOutputVideoFormats ) {
                hr = E_OUTOFMEMORY;
                goto CleanUp;
            }

            hr = GetOutputPixelFormats( ddInputVideoFormats, pddOutputVideoFormats );
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 0,
                        TEXT("NegotiatePixelFormat Failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
            // for every input format, figure out a table of every possible output format
            // Then we can offer a list of possible output formats.  When we need one of them, search
            // the input lists to locate it (and possibly select the conversion with the lowest bandwidth)
            PixelFormatList ddAllOutputVideoFormats = PixelFormatList::Union( pddOutputVideoFormats, ddInputVideoFormats.GetCount() );

            if( ddAllOutputVideoFormats.GetCount() > 0 ) {
			    m_ddVPOutputVideoFormat = ddAllOutputVideoFormats[ m_dwDefaultOutputFormat ];

			    DWORD dwInput = PixelFormatList::FindListContaining(
				    m_ddVPOutputVideoFormat, pddOutputVideoFormats, ddInputVideoFormats.GetCount() );
			    if( dwInput < ddInputVideoFormats.GetCount() ) {
				    hr = SetInputPixelFormat( ddInputVideoFormats[dwInput] );
			    } else {
				    // can't happen
				    hr = E_FAIL;
				    goto CleanUp;
			    }
            }
        }
    }
CleanUp:
    return hr;
}

//==========================================================================
//
HRESULT CVBIVideoPort::TearDownVideoPort()
{
    AMTRACE((TEXT("CVBIVideoPort::TearDownVideoPort")));

    // Release the DirectDraw surface
    RELEASE (m_pOffscreenSurf);
    RELEASE (m_pOffscreenSurf1);

    // release the videoport
    RELEASE (m_pVideoPort);

    m_VPState = VP_STATE_NO_VP;

    return NOERROR;
}


//==========================================================================
//
HRESULT CVBIVideoPort::StartVideo()
{
    AMTRACE((TEXT("CVBIVideoPort::StartVideo")));
    ASSERT(m_VPState == VP_STATE_STOPPED);

    HRESULT hr = NOERROR;
    DWORD dwSignalStatus;

    hr = m_pVideoPort->StartVideo(&m_svpInfo);
    if (FAILED(hr)) 
    {
        DbgLog((LOG_ERROR, 0, TEXT("StartVideo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    m_VPState = VP_STATE_RUNNING;

    DbgLog((LOG_TRACE, 2, TEXT("STARTVIDEO DONE!")));

    // check if the videoport is receiving a signal.
    hr = m_pVideoPort->GetVideoSignalStatus(&dwSignalStatus);
    if (hr != E_NOTIMPL)
    {
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0, TEXT("GetVideoSignalStatus() failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
        else if (dwSignalStatus == DDVPSQ_NOSIGNAL)
        {
            DbgLog((LOG_ERROR, 0, TEXT("GetVideoSignalStatus() returned DDVPSQ_NOSIGNAL, hr = 0x%x"), hr));
            //goto CleanUp;   // SJF_TODO - ignore error for now
        }
    }
    //m_pVideoPort->WaitForSync(DDVPWAIT_END, 0, 0);
    
CleanUp:

    return hr;
}


HRESULT CVBIVideoPort::StopVideo()
{
    AMTRACE((TEXT("CVBIVideoPort::StopVideo")));
    ASSERT(m_VPState == VP_STATE_RUNNING);

    HRESULT hr = NOERROR;

    hr = m_pVideoPort->StopVideo();
    if (FAILED(hr)) 
    {
        DbgLog((LOG_ERROR,0, TEXT("m_pVideoPort->StopVideo failed, hr = 0x%x"), hr));
        //goto CleanUp;
        hr = NOERROR;
    }
    m_VPState = VP_STATE_STOPPED;

//CleanUp:
    return hr;
}

/******************************Public*Routine******************************\
* CVideoPortObj::SetVideoPortID
*
*
*
* History:
* Thu 09/09/1999 - GlennE - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVBIVideoPort::SetVideoPortID( DWORD dwVideoPortId )
{
    AMTRACE((TEXT("CVideoPortObj::SetVideoPortID")));
    CAutoLock cObjectLock(m_pMainObjLock);

    HRESULT hr = S_OK;
    if ( m_dwVideoPortId != dwVideoPortId ) {
        // we can't switch ports when running
        if( m_VPState != VPInfoState_STOPPED ) {
            hr = VFW_E_WRONG_STATE;
        } else {
            if( m_pDDVPContainer ) {
                hr = VPMUtil::FindVideoPortCaps( m_pDDVPContainer, NULL, m_dwVideoPortId );
            } else {
                hr = VPMUtil::FindVideoPortCaps( m_pDirectDraw, NULL, m_dwVideoPortId );
            }
            if( hr == S_OK) {
                m_dwVideoPortId = dwVideoPortId;
            } else if( hr == S_FALSE ) {
                return E_INVALIDARG;
            }// else fail 
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vpm\vbiobj.h ===
//==========================================================================
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------

#ifndef __VBIOBJ__
#define __VBIOBJ__

#include <vptype.h>     // AMVP_MODE
#include <vpnotify.h>   // IVPVBINotify
#include <VPManager.h> // #include <kspin.h>         // IKsPin
#include <dvp.h>

//==========================================================================

interface IVPVBIConfig;

DECLARE_INTERFACE_(IVideoPortVBIObject, IUnknown)
{
    STDMETHOD (SetDirectDraw)(THIS_ LPDIRECTDRAW7 pDirectDraw) PURE;
    STDMETHOD (SetObjectLock)(THIS_ CCritSec *pMainObjLock) PURE;
    STDMETHOD (CheckMediaType)(THIS_ const CMediaType* pmt) PURE;
    STDMETHOD (GetMediaType)(THIS_ int iPosition, CMediaType *pMediaType) PURE;
    STDMETHOD (CheckConnect)(THIS_ IPin *pReceivePin) PURE;
    STDMETHOD (CompleteConnect)(THIS_ IPin *pReceivePin) PURE;
    STDMETHOD (BreakConnect)(THIS_) PURE;
    STDMETHOD (Active)(THIS_) PURE;
    STDMETHOD (Inactive)(THIS_) PURE;
    STDMETHOD (Run)(THIS_ REFERENCE_TIME tStart) PURE;
    STDMETHOD (RunToPause)(THIS_) PURE;
    STDMETHOD (GetVPDataInfo)(THIS_ AMVPDATAINFO *pAMVPDataInfo) PURE;
    STDMETHOD (CheckSurfaces)(THIS_) PURE;
    STDMETHOD (SetVideoPortID)      (THIS_ DWORD dwVideoPortId ) PURE;
};

class PixelFormatList;

//==========================================================================
class CVBIVideoPort
: public CUnknown
, public IVPVBINotify
, public IVideoPortVBIObject
, public IKsPropertySet
, public IKsPin
{
    
public:
    CVBIVideoPort(LPUNKNOWN pUnk, HRESULT *phr);
    ~CVBIVideoPort();
    
    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void ** ppv);

    // IVideoPortVBIObject Interface to the outside world

    STDMETHODIMP SetDirectDraw(LPDIRECTDRAW7 pDirectDraw);
    STDMETHODIMP SetObjectLock(CCritSec *pMainObjLock);
    STDMETHODIMP CheckMediaType(const CMediaType* pmt);
    STDMETHODIMP GetMediaType(int iPosition, CMediaType *pMediaType);
    STDMETHODIMP CheckConnect(IPin * pReceivePin);
    STDMETHODIMP CompleteConnect(IPin *pReceivePin);
    STDMETHODIMP BreakConnect();
    STDMETHODIMP Active();
    STDMETHODIMP Inactive();
    STDMETHODIMP Run(REFERENCE_TIME tStart);
    STDMETHODIMP RunToPause();
    STDMETHODIMP GetVPDataInfo(AMVPDATAINFO *pAMVPDataInfo);
    STDMETHODIMP CheckSurfaces();
    STDMETHODIMP SetVideoPortID( DWORD dwVideoPortId );

    // IVPVBINotify functions here
    STDMETHODIMP RenegotiateVPParameters();

    // IKsPropertySet implementation
    STDMETHODIMP Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData)
        { return E_NOTIMPL; }
    STDMETHODIMP Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData, DWORD *pcbReturned);
    STDMETHODIMP QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD *pTypeSupport);

    // IKsPin implementation
    STDMETHODIMP KsQueryMediums(PKSMULTIPLE_ITEM *pMediumList);
    STDMETHODIMP KsQueryInterfaces(PKSMULTIPLE_ITEM *pInterfaceList);
    STDMETHODIMP KsCreateSinkPinHandle(KSPIN_INTERFACE& Interface, KSPIN_MEDIUM& Medium)
        { return E_UNEXPECTED; }
    STDMETHODIMP KsGetCurrentCommunication(KSPIN_COMMUNICATION *pCommunication, KSPIN_INTERFACE *pInterface, KSPIN_MEDIUM *pMedium);
    STDMETHODIMP KsPropagateAcquire()
        { return NOERROR; }
    STDMETHODIMP KsDeliver(IMediaSample *pSample, ULONG Flags)
        { return E_UNEXPECTED; }
    STDMETHODIMP_(IMemAllocator*) KsPeekAllocator(KSPEEKOPERATION Operation)
        { return NULL; }
    STDMETHODIMP KsReceiveAllocator( IMemAllocator *pMemAllocator)
        { return E_UNEXPECTED; }
    STDMETHODIMP KsRenegotiateAllocator()
        { return E_UNEXPECTED; }
    STDMETHODIMP_(LONG) KsIncrementPendingIoCount()
        { return E_UNEXPECTED; }
    STDMETHODIMP_(LONG) KsDecrementPendingIoCount()
        { return E_UNEXPECTED; }
    STDMETHODIMP KsQualityNotify(ULONG Proportion, REFERENCE_TIME TimeDelta)
        { return E_UNEXPECTED; };
    STDMETHODIMP_(REFERENCE_TIME) KsGetStartTime()
        { return E_UNEXPECTED; };
    STDMETHODIMP KsMediaSamplesCompleted(PKSSTREAM_SEGMENT StreamSegment)
        { return E_UNEXPECTED; }


    // IKsPin stuff
protected:
    KSPIN_MEDIUM m_Medium;
    GUID m_CategoryGUID;
    KSPIN_COMMUNICATION m_Communication;

    // helper functions
    void SetKsMedium(const KSPIN_MEDIUM *pMedium) {m_Medium = *pMedium;};
    void SetKsCategory (const GUID *pCategory) {m_CategoryGUID = *pCategory;};

private:
    // called in CompleteConnect
    HRESULT NegotiateConnectionParameters();
    HRESULT GetDecoderVPDataInfo();

    // All these functions are called from within StartVideo
    HRESULT GetVideoPortCaps();
    static HRESULT CALLBACK EnumCallback (DDVIDEOPORTCAPS* lpCaps, LPVOID lpContext);
    BOOL EqualPixelFormats(DDPIXELFORMAT* lpFormat1, DDPIXELFORMAT* lpFormat2);
    HRESULT GetBestFormat(DWORD dwNumInputFormats, DDPIXELFORMAT* lpddInputFormats,
        LPDWORD lpdwBestEntry, DDPIXELFORMAT* lpddBestOutputFormat);
    HRESULT CreateVideoPort();
    HRESULT CreateVPSurface(void);
    HRESULT SetDDrawKernelHandles();

    HRESULT GetInputPixelFormats( PixelFormatList* pList );
    HRESULT GetOutputPixelFormats( const PixelFormatList& ddInputFormats,
                PixelFormatList* pddOutputFormats );
    HRESULT NegotiatePixelFormat();
    HRESULT SetInputPixelFormat( DDPIXELFORMAT& ddFormat );

    HRESULT InitializeVideoPortInfo();

    // Other internal functions
    HRESULT SetupVideoPort();
    HRESULT TearDownVideoPort();
    HRESULT StartVideo();
    HRESULT StopVideo();

private:
    // Critical sections
    CCritSec*                m_pMainObjLock;                // Lock given by controlling object

    // ddraw stuff
    LPDIRECTDRAW7            m_pDirectDraw;                  // DirectDraw service provider

    // surface related stuff
    LPDIRECTDRAWSURFACE7     m_pOffscreenSurf;
    LPDIRECTDRAWSURFACE     m_pOffscreenSurf1;
    

    // enum to specify, whether the videoport is in a stopped or running state
    // or has been torn down because its surfaces were stolen by a full-screen DOS app
    // or a DirectX app.
    enum VP_STATE {VP_STATE_NO_VP, VP_STATE_STOPPED, VP_STATE_RUNNING};

    // variables to store current state etc
    VP_STATE                m_VPState;
    BOOL                    m_bConnected;
    BOOL                    m_bFilterRunning;
    
    // vp data structures
    IVPVBIConfig*           m_pIVPConfig;
    DWORD                   m_dwVideoPortId;
    DWORD                   m_dwPixelsPerSecond;
    LPDDVIDEOPORTCONTAINER  m_pDDVPContainer;
    LPDIRECTDRAWVIDEOPORT   m_pVideoPort;
    DDVIDEOPORTINFO         m_svpInfo;
    DDVIDEOPORTCAPS         m_vpCaps;
    DDVIDEOPORTCONNECT      m_vpConnectInfo;

    // capture driver structures
    AMVPDATAINFO            m_capVPDataInfo;
    
    // All the pixel formats (Video)
    DWORD                   m_dwDefaultOutputFormat;    // which one we'll assume for the connection
    DDPIXELFORMAT           m_ddVPInputVideoFormat;
    DDPIXELFORMAT           m_ddVPOutputVideoFormat;

    BOOL    m_bHalfLineFix;
    // surface parameters
    DWORD m_dwSurfacePitch;
    DWORD m_dwSurfaceHeight;
    DWORD m_dwSurfaceOriginX;
    DWORD m_dwSurfaceOriginY;


};

#endif //__VBIOBJ__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vpm\vpmanager.h ===
/******************************Module*Header*******************************\
* Module Name: VPManager.h
*
*
*
*
* Created: Tue 05/05/2000
* Author:  GlenneE
*
* Copyright (c) 2000 Microsoft Corporation
\**************************************************************************/
#ifndef __VPManager__h
#define __VPManager__h

// IDirectDrawMediaSample
#include <amstream.h>

// IksPin
#include <ks.h>
#include <ksproxy.h>

#include <dvp.h>

#include <VPMPin.h>

/* -------------------------------------------------------------------------
** CVPManager class declaration
** -------------------------------------------------------------------------
*/
class CVPMOutputPin;
class CVPMInputPin;
class CVBIInputPin;
class PixelFormatList;

class DRect;
class CVPMThread;

struct VPInfo;

class CVPMFilter
: public CBaseFilter
, public ISpecifyPropertyPages
, public IQualProp
, public IAMVideoDecimationProperties
, public IKsPropertySet
, public IVPManager
{
public:
    // COM stuff
    static CUnknown* CreateInstance(LPUNKNOWN, HRESULT* );
    static CUnknown* CreateInstance2(LPUNKNOWN, HRESULT* );

    // (con/de)structors
    CVPMFilter(TCHAR* pName,LPUNKNOWN pUnk,HRESULT* phr );
    virtual ~CVPMFilter();

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void**  ppv);

    // IVPManager
    STDMETHODIMP SetVideoPortIndex( DWORD dwVideoPortIndex );
    STDMETHODIMP GetVideoPortIndex( DWORD* pdwVideoPortIndex );

    // ISpecifyPropertyPages 
    STDMETHODIMP GetPages(CAUUID* pPages);

    // IQualProp property page support
    STDMETHODIMP get_FramesDroppedInRenderer(int* cFramesDropped);
    STDMETHODIMP get_FramesDrawn(int* pcFramesDrawn);
    STDMETHODIMP get_AvgFrameRate(int* piAvgFrameRate);
    STDMETHODIMP get_Jitter(int* piJitter);
    STDMETHODIMP get_AvgSyncOffset(int* piAvg);
    STDMETHODIMP get_DevSyncOffset(int* piDev);

    //
    // IKsPropertySet interface methods
    //
    STDMETHODIMP Set(REFGUID guidPropSet, DWORD PropID, LPVOID pInstanceData,
                     DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData);

    STDMETHODIMP Get(REFGUID guidPropSet, DWORD PropID, LPVOID pInstanceData,
                     DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData,
                     DWORD* pcbReturned);

    STDMETHODIMP QuerySupported(REFGUID guidPropSet,
                                DWORD PropID, DWORD* pTypeSupport);


    virtual HRESULT SetMediaType(DWORD dwPinId, const CMediaType* pmt);
    virtual HRESULT CompleteConnect(DWORD dwPinId);
    virtual HRESULT BreakConnect(DWORD dwPinId);
    virtual HRESULT CheckMediaType(DWORD dwPinId, const CMediaType* mtIn)
                    { return NOERROR; }
    virtual HRESULT EndOfStream(DWORD dwPinId) { return NOERROR; }

    // IAMVideoDecimationProperties
    STDMETHODIMP    QueryDecimationUsage(DECIMATION_USAGE* lpUsage);
    STDMETHODIMP    SetDecimationUsage(DECIMATION_USAGE Usage);

    // CBaseFilter
    int             GetPinCount();
    CBasePin*       GetPin(int n);

public:
    // other non-interface methods

    int             GetPinPosFromId(DWORD dwPinId);

    STDMETHODIMP    Run(REFERENCE_TIME StartTime );
    STDMETHODIMP    Pause();
    STDMETHODIMP    Stop() ;
    STDMETHODIMP    GetState(DWORD dwMSecs,FILTER_STATE* pState);
    HRESULT         EventNotify(DWORD dwPinId,
                                long lEventCode,
                                DWORD_PTR lEventParam1,
                                DWORD_PTR lEventParam2);
    HRESULT         ConfirmPreConnectionState(DWORD dwExcludePinId = -1);
    HRESULT         CanExclusiveMode();

    HRESULT         GetPaletteEntries(DWORD* pdwNumPaletteEntries,
                                              PALETTEENTRY** ppPaletteEntries);
    CImageDisplay*  GetDisplay() { return &m_Display; }
    LPDIRECTDRAW7   GetDirectDraw();
    const DDCAPS*   GetHardwareCaps();
    HRESULT         SignalNewVP( LPDIRECTDRAWVIDEOPORT pVP );
    HRESULT         CurrentInputMediaType(CMediaType* pmt);


    DWORD           KernelCaps() const { return m_dwKernelCaps;}

    HRESULT         ProcessNextSample( const DDVIDEOPORTNOTIFY& notify );
    HRESULT         GetAllOutputFormats( const PixelFormatList**);
    HRESULT         GetOutputFormat( DDPIXELFORMAT*);

    HRESULT         CanColorConvertBlitToRGB( const DDPIXELFORMAT& ddFormat );

    CCritSec&       GetFilterLock() { return m_csFilter; };
    CCritSec&       GetReceiveLock() { return m_csReceive; };
    HRESULT         GetRefClockTime( REFERENCE_TIME* pNow );

    HRESULT         GetVPInfo( VPInfo* pVPInfo );

protected:
    friend class CVPMInputPin;
    void    DeleteInputPin( CBaseInputPin* pPin);
private:
    // helper function to get IBaseVideo from outpun pin
    HRESULT     GetBasicVideoFromOutPin(IBasicVideo** pBasicVideo);

    HRESULT     HandleConnectInputWithoutOutput();
    HRESULT     HandleConnectInputWithOutput();

    HRESULT     CreateThread();

    // ddraw related functions
    HRESULT InitDirectDraw(LPDIRECTDRAW7 pDirectDraw);

    DWORD   ReleaseDirectDraw();
    HRESULT CheckSuitableVersion();
    HRESULT CheckCaps();

    HRESULT SetDirectDraw( LPDIRECTDRAW7 pDirectDraw );


    CCritSec                m_csFilter;             // filter wide lock (use in state changes / filter changes)
    CCritSec                m_csReceive;            // receive lock (use in state changes AND receive)

    // ddraw stuff
    LPDIRECTDRAW7           m_pDirectDraw;          // DirectDraw service provider
    DWORD                   m_dwVideoPortID;        // VP index on the card
    DDCAPS                  m_DirectCaps;           // Actual hardware capabilities
    DDCAPS                  m_DirectSoftCaps;       // Emulted capabilities
    DWORD                   m_dwKernelCaps;         // Kernel caps

    //
    CImageDisplay           m_Display;

    // Pins
    struct Pins {
        Pins( CVPMFilter& filter, HRESULT* phr );
        ~Pins();

        const DWORD             dwCount;
        CVPMInputPin            VPInput;
        CVBIInputPin            VBIInput;
        CVPMOutputPin           Output;           // output pin
    }* m_pPins;

    // Support IMediaSeeking
    IUnknown*                m_pPosition;

    // Support IEnumPinConfig
    DWORD                   m_dwPinConfigNext;


    // Support IAMVideoDecimationProperties
    DECIMATION_USAGE        m_dwDecimation;
#ifdef DEBUG
#define WM_DISPLAY_WINDOW_TEXT  (WM_USER+7837)
    TCHAR                   m_WindowText[80];
#endif

    // Pump thread
    CVPMThread*             m_pThread;
};

#endif //__VPManager__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vpm\vbiinpin.cpp ===
//==========================================================================
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998  All Rights Reserved.
//
//--------------------------------------------------------------------------


#include <streams.h>
#include <ddraw.h>
#include <VBIObj.h>
#include <VPMUtil.h>
#include <VPManager.h>
#include <VPMPin.h>


//==========================================================================
// constructor
CVBIInputPin::CVBIInputPin(TCHAR *pObjectName, CVPMFilter& pFilter, HRESULT *phr, LPCWSTR pPinName, DWORD dwPinNo )
: CBaseInputPin(pObjectName, &pFilter, &pFilter.GetFilterLock(), phr, pPinName)
, CVPMPin( dwPinNo, pFilter )
, m_pIVPObject(NULL)
, m_pIVPNotify(NULL)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("Entering CVBIInputPin::Constructor")));
    
    // create the VideoPort object

    // See combase.cpp(107) for comments on this
    IUnknown* pThisUnknown = reinterpret_cast<LPUNKNOWN>( static_cast<PNDUNKNOWN>(this) );

    m_pVideoPortVBIObject = new CVBIVideoPort( pThisUnknown, phr );
    if( !m_pVideoPortVBIObject ) {
        hr = E_OUTOFMEMORY;
    } else {
        m_pIVPObject = m_pVideoPortVBIObject;
        m_pIVPNotify = m_pVideoPortVBIObject;


        // filter lock is ok since no data is received or sent
	    hr = m_pIVPObject->SetObjectLock( &m_pVPMFilter.GetFilterLock() );
	    if (FAILED(hr))
	    {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->SetObjectLock() failed, hr = 0x%x"), hr));
	    }
    }

    if (FAILED(hr)) {
        *phr = hr;
    }
    // Leaving CVBIInputPin::Constructor")));
    return;
}


//==========================================================================
// destructor
CVBIInputPin::~CVBIInputPin(void)
{
    AMTRACE((TEXT("Entering CVBIInputPin::Destructor")));
    
    delete m_pVideoPortVBIObject;
	m_pVideoPortVBIObject = NULL;
    m_pIVPNotify = NULL;
    m_pIVPObject = NULL;
}


//==========================================================================
// overriden to expose IVPVBINotify, IKsPin, and IKsPropertySet
STDMETHODIMP CVBIInputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = NOERROR;
    
    //AMTRACE((TEXT("Entering CVBIInputPin::NonDelegatingQueryInterface")));
    
    if (riid == IID_IVPVBINotify) {
        hr = GetInterface( static_cast<IVPVBINotify*>( this ), ppv);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 2, TEXT("GetInterface(IVPVBINotify*) failed, hr = 0x%x"), hr));
        }
    } else if (riid == IID_IKsPin ) {
        hr = GetInterface( static_cast<IKsPin*>( m_pVideoPortVBIObject), ppv);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 2, TEXT("m_pVideoPortVBIObject->QueryInterface(IKsPin) failed, hr = 0x%x"), hr));
        }
    } else if (riid == IID_IKsPropertySet) {
        hr = GetInterface( static_cast<IKsPropertySet*>( m_pVideoPortVBIObject), ppv);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 2, TEXT("m_pVideoPortVBIObject->QueryInterface(IKsPin) failed, hr = 0x%x"), hr));
        }
    } else {
        // call the base class
        hr = CBaseInputPin::NonDelegatingQueryInterface(riid, ppv);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 2, TEXT("CBaseInputPin::NonDelegatingQueryInterface failed, hr = 0x%x"), hr));
        }
    } 
    
    return hr;
}


//==========================================================================
// check that the mediatype is acceptable
HRESULT CVBIInputPin::CheckMediaType(const CMediaType* pmt)
{
    CAutoLock cLock( &m_pVPMFilter.GetFilterLock() );
    AMTRACE((TEXT("Entering CVBIInputPin::CheckMediaType")));

    // check if the videoport object likes it
    HRESULT hr = m_pIVPObject->CheckMediaType(pmt);
    return hr;
}


//==========================================================================
HRESULT CVBIInputPin::GetMediaType(int iPosition, CMediaType *pmt)
{
    CAutoLock cLock( &m_pVPMFilter.GetFilterLock() );
    AMTRACE((TEXT("Entering CVBIInputPin::GetMediaType")));

    HRESULT hr = m_pIVPObject->GetMediaType(iPosition, pmt);
    return hr;
}


//==========================================================================
// called after we have agreed a media type to actually set it
HRESULT CVBIInputPin::SetMediaType(const CMediaType* pmt)
{
    CAutoLock cLock( &m_pVPMFilter.GetFilterLock() );
    AMTRACE((TEXT("Entering CVBIInputPin::SetMediaType")));

    HRESULT hr = NOERROR;
    
    // make sure the mediatype is correct
    hr = CheckMediaType(pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CheckMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
    // Set the base class media type (should always succeed)
    hr = CBaseInputPin::SetMediaType(pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CBaseInputPin::SetMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
CleanUp:
    return hr;
}


//==========================================================================
// CheckConnect
HRESULT CVBIInputPin::CheckConnect(IPin * pReceivePin)
{
    CAutoLock cLock( &m_pVPMFilter.GetFilterLock() );
    AMTRACE((TEXT("Entering CVBIInputPin::CheckConnect")));

    HRESULT hr = NOERROR;

    // tell the videoport object 
    hr = m_pIVPObject->CheckConnect(pReceivePin);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->CheckConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // call the base class
    hr = CBaseInputPin::CheckConnect(pReceivePin);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::CheckConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
CleanUp:
    return hr;
}


//==========================================================================
// Complete Connect
HRESULT CVBIInputPin::CompleteConnect(IPin *pReceivePin)
{
    CAutoLock cLock( &m_pVPMFilter.GetFilterLock() );
    AMTRACE((TEXT("Entering CVBIInputPin::CompleteConnect")));

    HRESULT hr = NOERROR;
    CMediaType cMediaType;
    AM_MEDIA_TYPE *pNewMediaType = NULL, *pEnumeratedMediaType = NULL;
    
    // tell the videoport object 
    hr = m_pIVPObject->CompleteConnect(pReceivePin);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("m_pIVPObject->CompleteConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }


    // call the base class
    hr = CBaseInputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CBaseInputPin::CompleteConnect failed, hr = 0x%x"), hr));
        m_pIVPObject->BreakConnect();
        goto CleanUp;
    }
    
CleanUp:
    return hr;
}


//==========================================================================
HRESULT CVBIInputPin::BreakConnect(void)
{
    CAutoLock cLock( &m_pVPMFilter.GetFilterLock() );
    AMTRACE((TEXT("Entering CVBIInputPin::BreakConnect")));

    HRESULT hr = NOERROR;
    
    // tell the videoport object 
    ASSERT(m_pIVPObject);
    hr = m_pIVPObject->BreakConnect();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("m_pIVPObject->BreakConnect failed, hr = 0x%x"), hr));
    }

    // call the base class
    hr = CBaseInputPin::BreakConnect();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CBaseInputPin::BreakConnect failed, hr = 0x%x"), hr));
    }

    return hr;
}


//==========================================================================
// transition from stop to pause state
HRESULT CVBIInputPin::Active(void)
{
    CAutoLock cLock( &m_pVPMFilter.GetFilterLock() );
    AMTRACE((TEXT("Entering CVBIInputPin::Active")));

    HRESULT hr = NOERROR;

    // tell the videoport object 
    hr = m_pIVPObject->Active();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("m_pIVPObject->Active failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // call the base class
    hr = CBaseInputPin::Active();

    // if it is a VP connection, this error is ok
    if (hr == VFW_E_NO_ALLOCATOR)
    {
        hr = NOERROR;
    }

    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CBaseInputPin::Active failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}


//==========================================================================
// transition from pause to stop state
HRESULT CVBIInputPin::Inactive(void)
{
    CAutoLock cLock( &m_pVPMFilter.GetFilterLock() );
    AMTRACE((TEXT("Entering CVBIInputPin::Inactive")));

    HRESULT hr = NOERROR;
    
    // tell the videoport object
    hr = m_pIVPObject->Inactive();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("m_pIVPObject->Inactive failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // call the base class
    hr = CBaseInputPin::Inactive();

    // if it is a VP connection, this error is ok
    if (hr == VFW_E_NO_ALLOCATOR)
    {
        hr = NOERROR;
    }

    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CBaseInputPin::Inactive failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
CleanUp:
    return hr;
}


//==========================================================================
// transition from pause to run state
HRESULT CVBIInputPin::Run(REFERENCE_TIME tStart)
{
    CAutoLock cLock( &m_pVPMFilter.GetFilterLock() );
    AMTRACE((TEXT("Entering CVBIInputPin::Run")));

    HRESULT hr = NOERROR;
    
    // tell the videoport object 
    hr = m_pIVPObject->Run(tStart);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("m_pIVPObject->Run() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // call the base class
    hr = CBaseInputPin::Run(tStart);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CBaseInputPin::Run failed, hr = 0x%x"), hr));
        m_pIVPObject->RunToPause();
        goto CleanUp;
    }
    
CleanUp:
    return hr;
}


//==========================================================================
// transition from run to pause state
HRESULT CVBIInputPin::RunToPause(void)
{
    CAutoLock cLock( &m_pVPMFilter.GetFilterLock() );
    AMTRACE((TEXT("Entering CVBIInputPin::RunToPause")));

    HRESULT hr = NOERROR;

    // tell the videoport object 
    hr = m_pIVPObject->RunToPause();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("m_pIVPObject->RunToPause() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
CleanUp:
    return hr;
}


//==========================================================================
// signals start of flushing on the input pin
HRESULT CVBIInputPin::BeginFlush(void)
{
    CAutoLock cLock( &m_pVPMFilter.GetFilterLock() );
    AMTRACE((TEXT("Entering CVBIInputPin::BeginFlush")));

    HRESULT hr = NOERROR;

    // call the base class
    hr = CBaseInputPin::BeginFlush();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CBaseInputPin::BeginFlush() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
CleanUp:
    return hr;
}


//==========================================================================
// signals end of flushing on the input pin
HRESULT CVBIInputPin::EndFlush(void)
{
    CAutoLock cLock( &m_pVPMFilter.GetFilterLock() );
    AMTRACE((TEXT("Entering CVBIInputPin::EndFlush")));

    HRESULT hr = NOERROR;
    
    // call the base class
    hr = CBaseInputPin::EndFlush();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CBaseInputPin::EndFlush() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    
CleanUp:
    return hr;
}


//==========================================================================
// called when the upstream pin delivers us a sample
HRESULT CVBIInputPin::Receive(IMediaSample *pMediaSample)
{
    CAutoLock cLock( &m_pVPMFilter.GetFilterLock() );
    AMTRACE((TEXT("Entering CVBIInputPin::Receive")));

    HRESULT hr = NOERROR;
    
    hr = CBaseInputPin::Receive(pMediaSample);

    return hr;
}


//==========================================================================
// signals end of data stream on the input pin
STDMETHODIMP CVBIInputPin::EndOfStream(void)
{
    CAutoLock cLock( &m_pVPMFilter.GetFilterLock() );
    AMTRACE((TEXT("Entering CVBIInputPin::EndOfStream")));

    HRESULT hr = NOERROR;

    // Make sure we're streaming ok

    hr = CheckStreaming();
    if (FAILED(hr)) 
    {
        DbgLog((LOG_ERROR, 0, TEXT("CheckStreaming() failed, hr = 0x%x"), hr));
        return hr;
    }

    // call the base class
    hr = CBaseInputPin::EndOfStream();
    if (FAILED(hr)) 
    {
        DbgLog((LOG_ERROR, 0, TEXT("CBaseInputPin::EndOfStream() failed, hr = 0x%x"), hr));
        return hr;
    } 

    return hr;
}


//==========================================================================
// This overrides the CBaseInputPin virtual method to return our allocator
HRESULT CVBIInputPin::GetAllocator(IMemAllocator **ppAllocator)
{
    CAutoLock cLock( &m_pVPMFilter.GetFilterLock() );
    AMTRACE((TEXT("Entering CVBIInputPin::GetAllocator")));

    HRESULT hr = NOERROR;

    if (!ppAllocator)
    {
        DbgLog((LOG_ERROR, 0, TEXT("ppAllocator is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    *ppAllocator = NULL;

CleanUp:
    return hr;
} // GetAllocator


//==========================================================================
// This overrides the CBaseInputPin virtual method to return our allocator
HRESULT CVBIInputPin::NotifyAllocator(IMemAllocator *pAllocator,BOOL bReadOnly)
{
    CAutoLock cLock( &m_pVPMFilter.GetFilterLock() );
    AMTRACE((TEXT("Entering CVBIInputPin::NotifyAllocator")));

    HRESULT hr = NOERROR;

    if (!pAllocator)
    {
        DbgLog((LOG_ERROR, 0, TEXT("ppAllocator is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

CleanUp:
    return hr;
} // NotifyAllocator


//==========================================================================
// sets the pointer to directdraw
HRESULT CVBIInputPin::SetDirectDraw(LPDIRECTDRAW7 pDirectDraw)
{
    CAutoLock cLock( &m_pVPMFilter.GetFilterLock() );
    AMTRACE((TEXT("Entering CVBIInputPin::SetDirectDraw")));

    HRESULT hr = NOERROR;

    m_pDirectDraw = pDirectDraw;

    // tell the videoport object 
    hr = m_pIVPObject->SetDirectDraw(pDirectDraw);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("m_pIVPObject->SetDirectDraw failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}


//==========================================================================
// this function is used to redo the whole videoport connect process, while the graph
// maybe be running.
STDMETHODIMP CVBIInputPin::RenegotiateVPParameters()
{
    CAutoLock cLock( &m_pVPMFilter.GetFilterLock() );
    AMTRACE((TEXT("Entering CVBIInputPin::RenegotiateVPParameters")));

    HRESULT hr = NOERROR;

    // tell the videoport object 
    ASSERT(m_pIVPNotify);
    hr = m_pIVPNotify->RenegotiateVPParameters();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("m_pIVPNotify->RenegotiateVPParameters() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    //return hr;
    return NOERROR;
}

HRESULT CVBIInputPin::SetVideoPortID( DWORD dwIndex )
{
    HRESULT hr = S_OK;
    CAutoLock l(m_pLock);
    if (m_pIVPObject ) {
        hr = m_pIVPObject->SetVideoPortID( dwIndex );
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vpm\vpmextern.h ===
/******************************Module*Header*******************************\
* Module Name: VPMExtern.h
*
*
*
*
* Created: Tue 05/05/2000
* Author:  GlenneE
*
* Copyright (c) 2000 Microsoft Corporation
\**************************************************************************/
#ifndef __VPMExtern__h
#define __VPMExtern__h

// this is so we can avoid including bucket loads of (incompatible) DDraw headers when building
// quartz.cpp
CUnknown* CVPMFilter_CreateInstance(LPUNKNOWN pUnk, HRESULT* phr);

extern const AMOVIESETUP_FILTER sudVPManager;

#endif //__VPMExtern__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vpm\vpmalloc.cpp ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <ddraw.h>
#include <VPManager.h>
#include <VPMPin.h>
#include <VPMUtil.h>
#include <ddkernel.h>

//
//   Flipping surface implementation
//
//   To allow decoders to hold on to surfaces for out of order decode
//   we flip directly to the surface pass on Receive rather than
//   use the default NULL target surface for Flip().
//
//   This works in the following way
//
//   The COMPinputPin::m_pDirectDrawSurface points to the FRONT buffer
//
//   When Receive is called we Flip() the front buffer and because we
//   do an explicit Flip() DirectDraw swaps the memory pointers for the
//   current Front buffer and the surface passed in which is then attached
//   to the front buffer.
//
//   The received buffer is then put at the back of the queue so (correctly)
//   the previous front buffer is now at the back of the queue to be handed
//   to the application
//
//   The allocator actually has one more buffer than was actually requested
//   so the previous front buffer won't actually be requested until the next
//   Receive and hence the previous Flip() has time to complete.
//

//  Video accelerator disable interface


///////////////////////////////////////////
// CLASS CDDrawMediaSample implemented here
///////////////////////////////////////////

// constructor
CDDrawMediaSample::CDDrawMediaSample(TCHAR *pName, CBaseAllocator *pAllocator, HRESULT *phr, LPBYTE pBuffer, LONG length,
                                     bool bKernelFlip)
: CMediaSample(pName, pAllocator, phr, pBuffer, length)
{
    AMTRACE((TEXT("CDDrawMediaSample::Constructor")));

    m_pDirectDrawSurface = NULL;
    m_dwDDrawSampleSize  = 0;
    m_bSurfaceLocked     = FALSE;
    m_bKernelLock        = bKernelFlip;
    SetRect(&m_SurfaceRect, 0, 0, 0, 0);

    memset(&m_DibData, 0, sizeof(DIBDATA));
    m_bInit = FALSE;

    return;
}

// destructor
CDDrawMediaSample::~CDDrawMediaSample(void)
{
    AMTRACE((TEXT("CDDrawMediaSample::Destructor")));

    if (m_pDirectDrawSurface)
    {
        __try {
            m_pDirectDrawSurface->Release() ;  // release surface now
        }
        __except(EXCEPTION_EXECUTE_HANDLER) {
            ;
        }
        m_pDirectDrawSurface = NULL;
    }

    if (m_bInit)
    {
        if (m_DibData.hBitmap)
        {
            EXECUTE_ASSERT(DeleteObject(m_DibData.hBitmap));
        }
        if (m_DibData.hMapping)
        {
            EXECUTE_ASSERT(CloseHandle(m_DibData.hMapping));
        }
    }

    return;
}

HRESULT CDDrawMediaSample::SetDDrawSampleSize(DWORD dwDDrawSampleSize)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputAllocator::SetDDrawSampleSize")));

    m_dwDDrawSampleSize = dwDDrawSampleSize;
    return hr;
}

HRESULT CDDrawMediaSample::GetDDrawSampleSize(DWORD *pdwDDrawSampleSize)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputAllocator::SetDDrawSampleSize")));

    if (!pdwDDrawSampleSize)
    {
        DbgLog((LOG_ERROR, 1, TEXT("Bad Arguments, pdwDDrawSampleSize = NULL")));
        hr = E_POINTER;
        goto CleanUp;
    }

    *pdwDDrawSampleSize = m_dwDDrawSampleSize;

CleanUp:
    return hr;
}

HRESULT CDDrawMediaSample::SetDDrawSurface(LPDIRECTDRAWSURFACE7 pDirectDrawSurface)
{
    HRESULT hr = NOERROR;
    AMTRACE((TEXT("CVPMInputAllocator::SetDDrawSampleSize")));

    if (pDirectDrawSurface)               // only if new surface is not NULL...
        pDirectDrawSurface->AddRef() ;    // ...add a ref count on it

    if (m_pDirectDrawSurface)             // if there was a surface already...
        m_pDirectDrawSurface->Release() ; // ... then release it now

    m_pDirectDrawSurface = pDirectDrawSurface;

    return hr;
}

HRESULT CDDrawMediaSample::GetDDrawSurface(LPDIRECTDRAWSURFACE7 *ppDirectDrawSurface)
{
    HRESULT hr = NOERROR;
    AMTRACE((TEXT("CVPMInputAllocator::SetDDrawSampleSize")));

    if (!ppDirectDrawSurface)
    {
        DbgLog((LOG_ERROR, 1, TEXT("Bad Arguments, ppDirectDrawSurface = NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    *ppDirectDrawSurface = m_pDirectDrawSurface;

CleanUp:
    return hr;
}
// overridden to expose IDirectDrawMediaSample
STDMETHODIMP CDDrawMediaSample::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CDDrawMediaSample::QueryInterface")));

    if (riid == IID_IDirectDrawMediaSample && m_pDirectDrawSurface)
    {
        hr = GetInterface(static_cast<IDirectDrawMediaSample*>(this), ppv);
#ifdef DEBUG
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2, TEXT("GetInterface(IDirectDrawMediaSample*) failed, hr = 0x%x"), hr));
        }
#endif
    }
    else
    {
        hr = CMediaSample::QueryInterface(riid, ppv);
#ifdef DEBUG
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2, TEXT("CUnknown::NonDelegatingQueryInterface failed, hr = 0x%x"), hr));
        }
#endif
    }

    return hr;
}

// Implement IDirectDrawMediaSample
STDMETHODIMP CDDrawMediaSample::GetSurfaceAndReleaseLock(IDirectDrawSurface **ppDirectDrawSurface,
                                                         RECT* pRect)
{
    HRESULT hr = NOERROR;
    BYTE *pBufferPtr;

    AMTRACE((TEXT("CDDrawMediaSample::GetSurfaceAndReleaseLock")));

    // make sure the surface is locked
    if (!m_bSurfaceLocked)
    {
        DbgLog((LOG_ERROR, 4, TEXT("m_bSurfaceLocked is FALSE, can't unlock surface twice, returning E_UNEXPECTED")));
        goto CleanUp;

    }

    // make sure you have a direct draw surface pointer
    if (!m_pDirectDrawSurface)
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pDirectDrawSurface is NULL, returning E_FAIL")));
        hr = E_FAIL;
        goto CleanUp;

    }

    hr = GetPointer(&pBufferPtr);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("GetPointer() failed, hr = 0x%x"), hr));
        goto CleanUp;

    }

    ASSERT(m_pDirectDrawSurface);
    hr = m_pDirectDrawSurface->Unlock(NULL); // TBD: was (LPVOID)pBufferPtr);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pDirectDrawSurface->Unlock failed, hr = 0x%x"), hr));
        goto CleanUp;

    }

    // Can't do this to make the 829/848 work with the ovmixer. The reason is that those
    // drivers unlock the surface just after GetBuffer (to avoid the win16 lock), however
    // there is a bunch of code in the proxy which ASSERTS for a valid pointer value
    /*
    // update the pointer value, however keep the SampleSize around
    hr = SetPointer(NULL, 0);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("SetPointer() failed, hr = 0x%x"), hr));
        goto CleanUp;

    }
    */

    if (ppDirectDrawSurface) {
        hr = m_pDirectDrawSurface->QueryInterface( IID_IDirectDrawSurface7, (VOID**)ppDirectDrawSurface );
        if( FAILED( hr )) {
            ASSERT( FALSE );
            *ppDirectDrawSurface  = NULL;
        }
    } else if (pRect) {
        *pRect = m_SurfaceRect;
    }
    m_bSurfaceLocked = FALSE;

CleanUp:
    return hr;
}

STDMETHODIMP CDDrawMediaSample::LockMediaSamplePointer(void)
{
    HRESULT hr = NOERROR;
    DWORD dwDDrawSampleSize = 0;
    DDSURFACEDESC2 ddSurfaceDesc;
    DWORD dwLockFlags = DDLOCK_WAIT;

    AMTRACE((TEXT("CDDrawMediaSample::LockMediaSamplePointer")));

    // make sure the surface is locked
    if (m_bSurfaceLocked)
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_bSurfaceLocked is TRUE, can't lock surface twice, returning E_UNEXPECTED")));
        hr = E_UNEXPECTED;
        goto CleanUp;

    }

    // make sure you have a direct draw surface pointer
    if (!m_pDirectDrawSurface)
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pDirectDrawSurface is NULL, returning E_FAIL")));
        hr = E_FAIL;
        goto CleanUp;

    }

    // set the dwSize of ddSurfaceDesc
    INITDDSTRUCT(ddSurfaceDesc);

    // lock the surface - no need to grab the win16 lock
    ASSERT(m_pDirectDrawSurface);

    //  Using DDLOCK_NOSYSLOCK caused us to get DDERR_SURFACEBUSY on some of
    //  our blts to the primary for painting the color key so we've
    //  stopped using it for now.

    IDirectDrawSurface7 *pSurface7;
    if (m_bKernelLock && SUCCEEDED(m_pDirectDrawSurface->QueryInterface(
           IID_IDirectDrawSurface7,
           (void **)&pSurface7))) {
        pSurface7->Release();
        dwLockFlags |= DDLOCK_NOSYSLOCK;
    }
    hr = m_pDirectDrawSurface->Lock(
             NULL,
             &ddSurfaceDesc,
             dwLockFlags,
             (HANDLE)NULL);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pDirectDrawSurface->Lock() failed, hr = 0x%x"), hr));
        goto CleanUp;

    }

    hr = GetDDrawSampleSize(&dwDDrawSampleSize);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("GetDDrawSampleSize() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    ASSERT(dwDDrawSampleSize);


    // update the pointer value
    hr = SetPointer((BYTE*)ddSurfaceDesc.lpSurface, dwDDrawSampleSize);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("SetPointer() failed, hr = 0x%x"), hr));
        goto CleanUp;

    }

    m_bSurfaceLocked = TRUE;

CleanUp:
    return hr;
}

// Set the shared memory DIB information
void CDDrawMediaSample::SetDIBData(DIBDATA *pDibData)
{
    ASSERT(pDibData);
    m_DibData = *pDibData;
    m_pBuffer = m_DibData.pBase;
    m_cbBuffer = m_dwDDrawSampleSize;
    m_bInit = TRUE;
}


// Retrieve the shared memory DIB data
DIBDATA *CDDrawMediaSample::GetDIBData()
{
    ASSERT(m_bInit == TRUE);
    return &m_DibData;
}


///////////////////////////////////////////
// CLASS CVPMInputAllocator implemented here
///////////////////////////////////////////

// constructor
CVPMInputAllocator::CVPMInputAllocator(CVPMInputPin& pPin, HRESULT *phr)
: CBaseAllocator(NAME("Video Allocator"), NULL, phr, TRUE, true)
, m_pPin( pPin )
{
    AMTRACE((TEXT("CVPMInputAllocator::Constructor")));

    //  REVIEW don't overwrite a failure code from CBaseAllocator
    return;
}

// destructor
CVPMInputAllocator::~CVPMInputAllocator()
{
    AMTRACE((TEXT("CVPMInputAllocator::Destructor")));
}

// Override this to publicise IDirectDrawMediaSampleAllocator
STDMETHODIMP CVPMInputAllocator::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;

    AMTRACE((TEXT("CVPMInputAllocator::NonDelegatingQueryInterface")));

    CAutoLock cLock( &m_pPin.GetFilter().GetFilterLock() );
    return hr;
}

STDMETHODIMP CVPMInputAllocator::SetProperties(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputAllocator::SetProperties")));

    // call the base class
    hr = CBaseAllocator::SetProperties(pRequest, pActual);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseAllocator::SetProperties() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // tell the pin
    hr = m_pPin.OnSetProperties(pRequest, pActual);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pPin.AllocateSurfaces() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

// called when we receive a sample
HRESULT CVPMInputAllocator::GetBuffer(IMediaSample **ppSample, REFERENCE_TIME *pStartTime,
                                     REFERENCE_TIME *pEndTime, DWORD dwFlags)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputAllocator::GetBuffer")));

    // call the base class
    IMediaSample *pSample = NULL;
    hr = CBaseAllocator::GetBuffer(&pSample,pStartTime,pEndTime,0);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseAllocator::GetBuffer() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // tell the pin
    hr = m_pPin.OnGetBuffer(&pSample, pStartTime, pEndTime, dwFlags);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pPin.OnGetBuffer() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    {
        //  REVIEW why lock?  There are no variables in the allocato
        //  accessed here
        CAutoLock cAllocatorLock(this);
        if (FAILED(hr))
        {
            if (pSample)
            {
                pSample->Release();
            }
            *ppSample = NULL;
        }
        else
        {
            ASSERT(pSample != NULL);
            *ppSample = pSample;
        }
    }
    return hr;
}


// called when the sample is released
HRESULT CVPMInputAllocator::ReleaseBuffer(IMediaSample *pSample)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputAllocator::ReleaseBuffer")));

    // unlock the sample first
    hr = ((CDDrawMediaSample*)pSample)->GetSurfaceAndReleaseLock(NULL, NULL);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("pSample->GetSurfaceAndReleaseLock() failed, hr = 0x%x"), hr));
        // goto CleanUp;
        // if this happens we still have to release the sample to the free list, so don't bail out
    }

    {
        CAutoLock cAllocatorLock(this);

        // Copy of base class code - put at end of the list
        {
            CheckPointer(pSample,E_POINTER);
            ValidateReadPtr(pSample,sizeof(IMediaSample));
            BOOL bRelease = FALSE;
            {
                CAutoLock cal(this);

                /* Put back on the free list */

                CMediaSample **ppTail;
                for (ppTail = &m_lFree.m_List; *ppTail;
                    ppTail = &((CDDrawMediaSample *)(*ppTail))->Next()) {
                }
                *ppTail = (CMediaSample *)pSample;
                ((CDDrawMediaSample *)pSample)->Next() = NULL;
                m_lFree.m_nOnList++;

                if (m_lWaiting != 0) {
                    NotifySample();
                }

                // if there is a pending Decommit, then we need to complete it by
                // calling Free() when the last buffer is placed on the free list

                LONG l1 = m_lFree.GetCount();
                if (m_bDecommitInProgress && (l1 == m_lAllocated)) {
                    Free();
                    m_bDecommitInProgress = FALSE;
                    bRelease = TRUE;
                }
            }

            if (m_pNotify) {
                m_pNotify->NotifyRelease();
            }
            // For each buffer there is one AddRef, made in GetBuffer and released
            // here. This may cause the allocator and all samples to be deleted
            if (bRelease)
            {
                Release();
            }
        }
    }

    return hr;
}

// allocate memory for the sample
HRESULT CVPMInputAllocator::Alloc()
{
    HRESULT hr = NOERROR;
    CDDrawMediaSample **ppSampleList = NULL;
    DWORD i;
    LONG lToAllocate;

    AMTRACE((TEXT("CVPMInputAllocator::Alloc")));

    // call the base class
    hr = CBaseAllocator::Alloc();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseAllocator::Alloc() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // allocate memory for pointers

    lToAllocate = (m_pPin.m_dwBackBufferCount > 1 &&
                   !m_pPin.m_bSyncOnFill &&
                   m_pPin.m_bCanOverAllocateBuffers) ?
             m_lCount + 1 : m_lCount;

    // allocate memory for an array of pointers
    ppSampleList = new CDDrawMediaSample *[lToAllocate];
    if (!ppSampleList)
    {
        DbgLog((LOG_ERROR, 1, TEXT("new BYTE[m_lCount*sizeof(CDDrawMediaSample*)] failed")));
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    for (i = 0; i < (DWORD)(lToAllocate); i++)
    {
        // Create a new sample
        ppSampleList[i] = new CDDrawMediaSample(NAME("Sample"), this, (HRESULT *) &hr, NULL, (LONG) 0,
                                       DDKERNELCAPS_LOCK & m_pPin.m_pVPMFilter.KernelCaps() ?
                                       true : false);

        //  REVIEW - actually hr can't be a failure
        //  so we don't need to delete ppSampleList[i] here
        if (FAILED(hr) || ppSampleList[i] == NULL)
        {
            if (SUCCEEDED(hr))
                hr = E_OUTOFMEMORY;
            DbgLog((LOG_ERROR, 1, TEXT("new CDDrawMediaSample failed, hr = 0x%x"), hr));
            goto CleanUp;
        }

        // this cannot fail
        m_lFree.Add(ppSampleList[i]);
        m_lAllocated++;
    }

    ASSERT(m_lAllocated == lToAllocate);

    // tell the pin
    hr = m_pPin.OnAlloc(ppSampleList, lToAllocate);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pPin.OnAlloc(), hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    delete[] ppSampleList;
    return hr;
}

void CVPMInputAllocator::Free(void)
{
    CDDrawMediaSample *pSample;

    AMTRACE((TEXT("CVPMInputAllocator::Free")));

    /* Should never be deleting this unless all buffers are freed */
    //  REVIEW - might not be true if we failed to allocate a sample
    ASSERT(m_lAllocated == m_lFree.GetCount());

    /* Free up all the CMediaSamples */

    for (;;)
    {
        pSample = (CDDrawMediaSample *) m_lFree.RemoveHead();
        if (pSample != NULL)
        {
            delete pSample;
        }
        else
        {
            break;
        }
    }

    m_lAllocated = 0;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vpm\vpmdecimate.cpp ===
/******************************Module*Header*******************************\
* Module Name: decimate.cpp
*
* Support code for the IDecimateVideoImage and IAMVideoDecimationProperties
*
*
* Created: Thu 07/08/1999
* Author:  Stephen Estrop [StEstrop]
*
* Copyright (c) 1999 Microsoft Corporation
\**************************************************************************/
#include <streams.h>
#include <VPManager.h>
#include <VPMPin.h>
#include <VPMUtil.h>


#if 0
    #undef DBGLOG
    #define DBGLOG(_x_) OutputDebugStringA( _x_ )
#else
    #undef DBGLOG
    #define DBGLOG(_x_)
#endif

/*****************************Private*Routine******************************\
* GetVideoDecimation
*
* Try to get the IDecimateVideoImage interface from our peer filter.
*
* History:
* 05-05-99 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVPMInputPin::GetVideoDecimation(
    IDecimateVideoImage** lplpDVI
    )
{
    AMTRACE((TEXT("CVPMInputPin::GetVideoDecimation")));

    *lplpDVI = NULL;

    if (m_Connected == NULL || !IsConnected()) {
        return E_FAIL;
    }

    PIN_INFO PinInfo;
    HRESULT hr = m_Connected->QueryPinInfo(&PinInfo);
    if (FAILED(hr)) {
        return hr;
    }

    hr = PinInfo.pFilter->QueryInterface(IID_IDecimateVideoImage,
                                         (LPVOID*)lplpDVI);
    PinInfo.pFilter->Release();

    return hr;
}

/*****************************Private*Routine******************************\
* QueryDecimationOnPeer
*
* Check to see if the decoder connected to our input pin is happy
* to decimate to the requested size.  The decoder will return,
* S_OK if it can, S_FALSE if it can't decimate to the requested size
* and would like us to continue using the current decimation size and
* E_FAIL if it can't decimate at all or wants to stop decimating.
*
* History:
* 05-05-99 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVPMInputPin::QueryDecimationOnPeer(
    long lWidth,
    long lHeight
    )
{
    AMTRACE((TEXT("CVPMInputPin::QueryDecimationOnPeer")));

    IDecimateVideoImage* lpDVI;
    HRESULT hr = GetVideoDecimation(&lpDVI);

    if (SUCCEEDED(hr)) {

        hr = lpDVI->SetDecimationImageSize(lWidth, lHeight);
        lpDVI->Release();
    }
    return hr;
}

/*****************************Private*Routine******************************\
* ResetDecimationIfSet()
*
* Resets the decimation to the original size, but only if actually set
* in the first place.
*
* History:
* 05-05-99 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVPMInputPin::ResetDecimationIfSet()
{
    AMTRACE((TEXT("CVPMInputPin::ResetDecimationIfSet")));

    if (m_bDecimating) {

        IDecimateVideoImage* lpDVI;
        HRESULT hr = GetVideoDecimation(&lpDVI);

        if (SUCCEEDED(hr)) {
            hr = lpDVI->ResetDecimationImageSize();
            lpDVI->Release();
            m_bDecimating = FALSE;
            m_lWidth = 0L;
            m_lHeight = 0L;
        }
        else return hr;
    }

    return S_OK;
}


/*****************************Private*Routine******************************\
* Running
*
* Returns TRUE if the filter graph is in the "running" state.
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CVPMInputPin::Running()
{
    return (m_pVPMFilter.m_State == State_Running && CheckStreaming() == S_OK);
}


/*****************************Private*Routine******************************\
* TryDecoderDecimation
*
*
*
* History:
* Thu 07/08/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVPMInputPin::TryDecoderDecimation(
    VPWININFO* pWinInfo
    )
{
    AMTRACE((TEXT("CVPMInputPin::TryDecoderDecimation")));


    ASSERT(Running());


    //
    // We only decimate on the primary pin
    //

    if (m_dwPinId != 0) {

        DBGLOG(("Can only decimate the primary pin\n"));
        DbgLog((LOG_TRACE, 1, TEXT("Can only decimate the primary pin")));
        return E_FAIL;
    }

    //
    // Can only decimate when using default relative position
    //

    // if (m_rRelPos.left != 0 || m_rRelPos.top != 0 ||
    //     m_rRelPos.right != MAX_REL_NUM || m_rRelPos.bottom != MAX_REL_NUM) {
    // 
    //     DBGLOG(("Can only decimate default relative position\n"));
    //     DbgLog((LOG_TRACE, 1, TEXT("Can only decimate default relative position")));

    //     ResetDecimationIfSet();
    //     return E_FAIL;
    // }

    //
    // Must also be using the default source rectangle
    //

    if (WIDTH(&pWinInfo->SrcRect) != m_lSrcWidth ||
        HEIGHT(&pWinInfo->SrcRect) != m_lSrcHeight) {

        DBGLOG(("Can only decimate default source rectangle\n"));
        DbgLog((LOG_TRACE, 1, TEXT("Can only decimate default source rectangle")));

        ResetDecimationIfSet();
        return E_FAIL;
    }

    //
    // Now try asking the upstream decoder if it wants to decimate to
    // the specified image size
    //

    LONG lWidth = WIDTH(&pWinInfo->DestRect);
    LONG lHeight = HEIGHT(&pWinInfo->DestRect);
    HRESULT hr = QueryDecimationOnPeer(lWidth, lHeight);
    if (SUCCEEDED(hr)) {
        m_bDecimating = TRUE;
        m_lWidth = lWidth;
        m_lHeight = lHeight;
    }
    else {
        ResetDecimationIfSet();
        return E_FAIL;
    }

    //
    // Adjust the source rect passed to UpdateOverlay to
    // reflect the image size
    //

    pWinInfo->SrcRect.right = lWidth;
    pWinInfo->SrcRect.bottom = lHeight;

    return S_OK;
}

/*****************************Private*Routine******************************\
* GetOverlayMinStretch
*
* Returns the stretching capabilities of the VGA overlay scaler
*
* History:
* Fri 07/09/1999 - StEstrop - Created
*
\**************************************************************************/
DWORD
CVPMInputPin::GetOverlayMinStretch()
{
    AMTRACE((TEXT("CVPMInputPin::GetOverlayMinStretch")));

    // const DDCAPS* pDirectCaps = NULL;
    // pDirectCaps = m_pVPMFilter->GetHardwareCaps();
    // if ( pDirectCaps )
    //     return pDirectCaps->dwMinOverlayStretch;
    return 1000;
}




/*****************************Private*Routine******************************\
* BeyondOverlayCaps
*
* Determines if the current scale factor is outside the valid scale
* factors for the VGA overlay scaler.
*
* History:
* Thu 07/08/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CVPMInputPin::BeyondOverlayCaps(
    DWORD ScaleFactor
    )
{
    AMTRACE((TEXT("CVPMInputPin::BeyondOverlayCaps")));

    return ScaleFactor < GetOverlayMinStretch();
}



/*****************************Private*Routine******************************\
* CropSourceRect
*
* Crops the video image by adjusting the source rectangle until the ratio
* between the source and target rectangles is within the specified minimum
* scale factor (dwMinZoomFactor)
*
* History:
* Thu 07/08/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVPMInputPin::CropSourceRect(
    VPWININFO* pWinInfo,
    DWORD dwMinZoomFactorX,
    DWORD dwMinZoomFactorY
    )
{
    AMTRACE((TEXT("CVPMInputPin::CropSourceRect")));

#if defined(DEBUG)
    if (GetProfileIntA("OVMixer", "NoCrop", 0))
        return S_FALSE;
#endif

    DWORD dCurZoomFactorX;
    DWORD dCurZoomFactorY;
    VPMUtil::GetCurrentScaleFactor( *pWinInfo, &dCurZoomFactorX, &dCurZoomFactorY);

    // AM_ASPECT_RATIO_MODE amAdjustedARMode = AM_ARMODE_STRETCHED;
    // HRESULT hr = GetAdjustedModeAndAspectRatio(&amAdjustedARMode, NULL, NULL);
    // ASSERT(SUCCEEDED(hr));
    // if (amAdjustedARMode == AM_ARMODE_STRETCHED) {
    LONG srcWidth = WIDTH(&pWinInfo->SrcRect);
    LONG srcHeight = HEIGHT(&pWinInfo->SrcRect);

    if( false ) {

        //
        // if we don't need to maintain the aspect ratio, we clip only as
        // little as possible, so we can maximize the viewing area
        //
        if (dCurZoomFactorX < dwMinZoomFactorX) {

            pWinInfo->SrcRect.right = pWinInfo->SrcRect.left +
                MulDiv(srcWidth, dCurZoomFactorX, 1000);
        }

        if (dCurZoomFactorY < dwMinZoomFactorY) {

            pWinInfo->SrcRect.bottom = pWinInfo->SrcRect.top +
                MulDiv(srcHeight, dCurZoomFactorY, 1000);
        }
    }
    else {

        //
        // in this mode we need to maintain the aspect-ratio. So the clipping
        // in x and y has be to done by reducing the width and height of the
        // source rect by the same factor
        //
        if (dCurZoomFactorX < dwMinZoomFactorX ||
            dCurZoomFactorY < dwMinZoomFactorY) {

            DWORD dwFactor;
            DWORD dwFactorX = MulDiv(dCurZoomFactorX, 1000, dwMinZoomFactorX);
            dwFactor = min(1000, dwFactorX);

            DWORD dwFactorY = MulDiv(dCurZoomFactorY, 1000, dwMinZoomFactorY);
            dwFactor = min(dwFactor, dwFactorY);

            pWinInfo->SrcRect.right = pWinInfo->SrcRect.left +
                MulDiv(srcWidth, dwFactor, 1000);

            pWinInfo->SrcRect.bottom = pWinInfo->SrcRect.top +
                MulDiv(srcHeight, dwFactor, 1000);
        }
    }

    return S_OK;
}


/*****************************Private*Routine******************************\
* ApplyDecimation
*
* Non Video Port case
*
* This is where we enforce the chosen decimation strategy.
*
* History:
* Fri 07/09/1999 - StEstrop - Created
*
\**************************************************************************/
void
CVPMInputPin::ApplyDecimation(
    VPWININFO* pWinInfo
    )
{
    AMTRACE((TEXT("CVPMInputPin::ApplyDecimation")));

    DWORD dwMinStretch = GetOverlayMinStretch();

    if (Running()) {

        DWORD dwScaleFactor = VPMUtil::GetCurrentScaleFactor( *pWinInfo);
        if (VPMUtil::IsDecimationNeeded(dwScaleFactor)) {

            DECIMATION_USAGE dwUsage;
            GetDecimationUsage(&dwUsage);

            switch (dwUsage) {
            case DECIMATION_USE_OVERLAY_ONLY:
            case DECIMATION_LEGACY:
                ResetDecimationIfSet();
                if (BeyondOverlayCaps(dwScaleFactor)) {
                    CropSourceRect(pWinInfo, dwMinStretch, dwMinStretch);
                }
                break;

            case DECIMATION_USE_DECODER_ONLY:
                if (TryDecoderDecimation(pWinInfo) != S_OK) {
                    CropSourceRect(pWinInfo, dwMinStretch, dwMinStretch);
                }
                break;

            case DECIMATION_USE_VIDEOPORT_ONLY:
                ASSERT(FALSE);

                DBGLOG(("This mode makes no sense when not using Video Ports"));
                DBGLOG(("Falling thru to the new default case"));

            case DECIMATION_DEFAULT:
                if (TryDecoderDecimation(pWinInfo) != S_OK) {
                    if (BeyondOverlayCaps(dwScaleFactor)) {
                        CropSourceRect(pWinInfo, dwMinStretch, dwMinStretch);
                    }
                }
                break;
            }
        }
        else {
            ResetDecimationIfSet();
        }
    }

    //
    // If the filter graph is not running we should not ask the decoder
    // to do anymore decimation as the decoder will not be
    // sending anymore frames to us.  So, we should adjust pWinInfo to take
    // into account the decimation that has already been applied and then
    // perform any necessary cropping.
    //

    else {

        if (m_bDecimating) {
            pWinInfo->SrcRect.right = m_lWidth;
            pWinInfo->SrcRect.bottom = m_lHeight;
        }

        DWORD dwScaleFactor = VPMUtil::GetCurrentScaleFactor( *pWinInfo);
        if (BeyondOverlayCaps(dwScaleFactor)) {
            CropSourceRect(pWinInfo, dwMinStretch, dwMinStretch);
        }
    }
}



/******************************Public*Routine******************************\
* GetMinZoomFactors
*
* Gets the minimum X and Y zoom factors for the given overlay and video port
* connection.
*
* History:
* 3/10/1999 - StEstrop - Created
*
\**************************************************************************/
void
CVideoPortObj::GetMinZoomFactors(
    const VPWININFO& winInfo,
    BOOL bColorKeying,
    BOOL bYInterpolating,
    LPDWORD lpMinX,
    LPDWORD lpMinY
    )
{
    AMTRACE((TEXT("CVideoPortObj::GetMinZoomFactors")));
    DWORD dwMinBandWidthZoomFactorX = 0;
    const DDCAPS* pDirectCaps = m_pIVideoPortControl->GetHardwareCaps();

    //
    // if type is DDVPBCAPS_DESTINATION, contraint is terms of min-zoom-factor
    //

    if (m_sBandwidth.dwCaps == DDVPBCAPS_DESTINATION) {

        DbgLog((LOG_TRACE, 1, TEXT("DDVPBCAPS_DESTINATION")));
        dwMinBandWidthZoomFactorX = m_sBandwidth.dwOverlay;

        if (bColorKeying && !bYInterpolating) {

            DbgLog((LOG_TRACE, 1, TEXT("bColorKeying && !bYInterpolating")));
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwColorkey;
        }
        else if (!bColorKeying && bYInterpolating) {

            DbgLog((LOG_TRACE, 1, TEXT("!bColorKeying && bYInterpolating")));
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwYInterpolate;
        }
        else if (bColorKeying && bYInterpolating) {

            DbgLog((LOG_TRACE, 1, TEXT("bColorKeying && bYInterpolating")));
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwYInterpAndColorkey;
        }

        DbgLog((LOG_TRACE, 1,
                TEXT("dwMinBandWidthZoomFactorX=%d"),
                dwMinBandWidthZoomFactorX));
        DbgLog((LOG_TRACE, 1,
                TEXT("m_sBandwidth.dwOverlay   =%d"),
                m_sBandwidth.dwOverlay));

        if (dwMinBandWidthZoomFactorX < m_sBandwidth.dwOverlay)
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwOverlay;
    }
    else {

        //
        // if type is DDVPBCAPS_SOURCE, contraint is that the width of
        // the src-rect of the overlay must not be bigger than
        // m_lImageWidth*(value specified in m_sBandwidth)
        //

        ASSERT(m_sBandwidth.dwCaps == DDVPBCAPS_SOURCE);
        DbgLog((LOG_TRACE, 1, TEXT("DDVPBCAPS_SOURCE")));

        dwMinBandWidthZoomFactorX = m_sBandwidth.dwOverlay;

        if (bColorKeying && !bYInterpolating) {

            DbgLog((LOG_TRACE, 1, TEXT("bColorKeying && !bYInterpolating")));
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwColorkey;
        }
        else if (!bColorKeying && bYInterpolating) {

            DbgLog((LOG_TRACE, 1, TEXT("!bColorKeying && bYInterpolating")));
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwYInterpolate;
        }
        else if (bColorKeying && bYInterpolating) {

            DbgLog((LOG_TRACE, 1, TEXT("bColorKeying && bYInterpolating")));
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwYInterpAndColorkey;
        }

        DbgLog((LOG_TRACE, 1,
                TEXT("dwMinBandWidthZoomFactorX=%d"),
                dwMinBandWidthZoomFactorX));

        DbgLog((LOG_TRACE, 1,
                TEXT("m_sBandwidth.dwOverlay   =%d"),
                m_sBandwidth.dwOverlay));

        if (dwMinBandWidthZoomFactorX > m_sBandwidth.dwOverlay) {
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwOverlay;
        }

        ASSERT(dwMinBandWidthZoomFactorX <= 1000);
        ASSERT(dwMinBandWidthZoomFactorX > 0);

        //
        // since this bandwidth structure was computed by passing m_lImageWidth
        // as a paramter, the constraint is WIDTH(SrcRect of the overlay) <=
        // m_lImageWidth*dMinBandWidthZoomFactorX.
        // Another way of specifying this is terms of min-zoom-factor,
        // taking the current dest rect into account
        //

        DbgLog((LOG_TRACE, 1,
                TEXT("Mucking about with dwMinBandWidthZoomFactorX")));

        if (dwMinBandWidthZoomFactorX < 1000) {
            int iDstWidth = WIDTH(&winInfo.DestRect);
            dwMinBandWidthZoomFactorX = MulABC_DivDE(iDstWidth, 1000, 1000,
                                                     m_lImageWidth,
                                                     dwMinBandWidthZoomFactorX);
        }
        else {
            dwMinBandWidthZoomFactorX = 0;
        }
        DbgLog((LOG_TRACE, 1,
                TEXT("NEW dwMinBandWidthZoomFactorX=%d"),
                dwMinBandWidthZoomFactorX));
    }

    //
    // Calculate the minimum zoom factors first
    // minimum zoom factor in X depends upon the driver's capabilities to
    // stretch the overlay as well as the bandwidth restrictions.
    //

    *lpMinX = pDirectCaps->dwMinOverlayStretch;
    DbgLog((LOG_TRACE, 1, TEXT("dwMinOverlayStretch=%d"), *lpMinX));

    if (*lpMinX < dwMinBandWidthZoomFactorX) {
        *lpMinX = dwMinBandWidthZoomFactorX;
    }
    DbgLog((LOG_TRACE, 1, TEXT("dwMinZoomFactorX=%d"), *lpMinX));

    //
    // minimum zoom factor in Y depends only upon the driver's capabilities
    //
    *lpMinY = pDirectCaps->dwMinOverlayStretch;
}



/*****************************Private*Routine******************************\
* CheckVideoPortAlignment
*
* Checks that the specified pre-scale width is matches the alignment criteria
* set by the video port.
*
* History:
* 3/16/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CVideoPortObj::CheckVideoPortAlignment(
    DWORD dwWidth
    )
{
    AMTRACE((TEXT("CVideoPortObj::CheckVideoPortAlignment")));
    if ((m_vpCaps.dwFlags & DDVPD_ALIGN) &&
         m_vpCaps.dwAlignVideoPortPrescaleWidth > 1) {

        if (dwWidth & (m_vpCaps.dwAlignVideoPortPrescaleWidth - 1)) {

            return FALSE;
        }
    }

    return TRUE;
}

#if defined(DEBUG)
/*****************************Private*Routine******************************\
* CheckVideoPortScaler
*
* Checks that the video port scaler can actual scale the video image to the
* requested capture size.
*
* History:
* 3/16/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CVideoPortObj::CheckVideoPortScaler(
    DECIMATE_MODE DecimationMode,
    DWORD ImageSize,
    DWORD PreScaleSize,
    ULONG ulDeciStep
    )
{
    AMTRACE((TEXT("CVideoPortObj::CheckVideoPortScaler")));
    BOOL fScalerOK = TRUE;

    if (ImageSize != PreScaleSize) {
        switch (DecimationMode) {
        case DECIMATE_ARB:
            break;

        case DECIMATE_INC:
            if (((ulDeciStep * PreScaleSize) % ImageSize) != 0) {

                DbgLog((LOG_ERROR, 1,
                        TEXT("Can't capture at this size")));

                DbgLog((LOG_ERROR, 1,
                        TEXT("%d is not a fraction of %d over %d"),
                        PreScaleSize, ImageSize, ulDeciStep));

                fScalerOK = FALSE;
            }
            break;

        case DECIMATE_BIN:
            {
                DWORD bin = 1;
                while ((ImageSize / bin) > PreScaleSize) {
                    bin *= 2;
                }

                if ((ImageSize % bin) != 0) {

                    DbgLog((LOG_ERROR, 1,
                            TEXT("Can't capture at this size")));

                    DbgLog((LOG_ERROR, 1,
                            TEXT("%d is not a fraction of %d over 2^n"),
                            PreScaleSize, ImageSize));

                    fScalerOK = FALSE;
                }
            }
            break;

        case DECIMATE_NONE:
            DbgLog((LOG_ERROR, 1,
                    TEXT("Can't capture at this width because the ")
                    TEXT("VideoPort can't scale in this direction")));
            fScalerOK = FALSE;
            break;
        }
    }

    return fScalerOK;
}
#endif

/*****************************Private*Routine******************************\
* AdjustSourceSizeForCapture
*
* Only gets called if we are capturing.
*
* First, we must make sure that the video comming over the video port is
* the correct size.  We do this by checking that m_lImageWidth is equal to
* m_cxCapture and that m_lImageHeight is equal to m_cyCapture.
*
* If they differ, then we pre-scale the video to the correct size.  This is
* the only pre-scaling that is performed.  This is normaly only performed
* once when the graph is first run.  The source rectangle is adjusted
* to accomodate the possibly changed video source size.
*
* Second, we determine the current shrink factor and if it is beyond the
* capabilities of the VGA scaler we CROP the source rectangle (maintaining the
* correct aspect ratio) to such a size that the VGA scaler can cope with
* scaling.
*
* History:
* 3/10/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CVideoPortObj::AdjustSourceSizeForCapture(
    VPWININFO* pWinInfo,
    DWORD dwMinZoomFactorX,
    DWORD dwMinZoomFactorY
    )
{
    BOOL fUpdateRequired = FALSE;

    AMTRACE((TEXT("CVideoPortObj::AdjustSourceSizeForCapture")));

    DbgLog((LOG_TRACE, 1, TEXT("Src(%d, %d, %d, %d)"),
            pWinInfo->SrcRect.left, pWinInfo->SrcRect.top,
            pWinInfo->SrcRect.right, pWinInfo->SrcRect.bottom));
    DbgLog((LOG_TRACE, 1, TEXT("Dest(%d, %d, %d, %d)"),
            pWinInfo->DestRect.left, pWinInfo->DestRect.top,
            pWinInfo->DestRect.right, pWinInfo->DestRect.bottom));

    DWORD cyCapture = m_cyCapture;
    if (m_fCaptureInterleaved) {
        cyCapture /= 2;
    }

    //
    // First make sure that we are capturing at the correct size.
    //

    if (m_lDecoderImageWidth == m_cxCapture &&
        m_lDecoderImageHeight == cyCapture) {

        DbgLog((LOG_TRACE, 1, TEXT("Capture size matches image size")));

        //
        // We don't need to pre-scale at the video port, so make sure that it
        // is turned off.
        //
        if (m_svpInfo.dwPrescaleWidth != 0 || m_svpInfo.dwPrescaleHeight != 0) {

            DbgLog((LOG_TRACE, 1, TEXT("Turning off PRE-SCALE")));

            m_svpInfo.dwVPFlags &= ~DDVP_PRESCALE;
            m_svpInfo.dwPrescaleWidth = 0;
            m_svpInfo.dwPrescaleHeight = 0;
            fUpdateRequired = TRUE;
        }

        //
        // Reset the decimation ratio's
        //
        m_dwDeciNumX = 1000; m_dwDeciDenX = 1000;
        m_dwDeciNumY = 1000; m_dwDeciDenY = 1000;
    }
    else {

        //
        // We do need to pre-scale at the video port, make sure that it is
        // turned on.
        //

        if (m_svpInfo.dwPrescaleWidth != m_cxCapture ||
            m_svpInfo.dwPrescaleHeight != cyCapture) {

            DbgLog((LOG_TRACE, 1, TEXT("Turning on PRE-SCALE at (%d, %d)"),
                    m_cxCapture, cyCapture ));

            //
            // Need to do some more checking here.  Basically, I'm relying on
            // the decoder connected to the video port to specify a size that
            // the video port can actually scale to.
            //

            ASSERT(CheckVideoPortAlignment(m_cxCapture) == TRUE);

            ASSERT(CheckVideoPortScaler(m_DecimationModeX, m_lDecoderImageWidth,
                                        m_cxCapture, m_ulDeciStepX) == TRUE);

            ASSERT(CheckVideoPortScaler(m_DecimationModeY, m_lDecoderImageHeight,
                                        cyCapture, m_ulDeciStepY) == TRUE);

            m_svpInfo.dwVPFlags |= DDVP_PRESCALE;
            m_svpInfo.dwPrescaleWidth = m_cxCapture;
            m_svpInfo.dwPrescaleHeight = cyCapture;
            fUpdateRequired = TRUE;
        }


        //
        // Update the decimation ratio's
        //
        m_dwDeciDenX = 1000;
        m_dwDeciNumX = (DWORD)MulDiv(m_cxCapture, m_dwDeciDenX, m_lDecoderImageWidth);
        m_dwDeciDenY = 1000;
        m_dwDeciNumY = (DWORD)MulDiv(cyCapture, m_dwDeciDenY, m_lDecoderImageHeight);


        //
        // make sure that the source rectangle reflects the new source video
        // image file
        //
        RECT &rcSrc  = pWinInfo->SrcRect;
        rcSrc.right  = rcSrc.left + m_cxCapture;
        rcSrc.bottom = rcSrc.top + m_cyCapture;
    }

    //
    // Second, make sure that any shrinking falls within the capabilities
    // of the scaler on the VGA chip, cropping if necessary
    //
    m_pIVideoPortControl->CropSourceRect(pWinInfo, dwMinZoomFactorX, dwMinZoomFactorY);


    DbgLog((LOG_TRACE, 1, TEXT("Src(%d, %d, %d, %d)"),
            pWinInfo->SrcRect.left, pWinInfo->SrcRect.top,
            pWinInfo->SrcRect.right, pWinInfo->SrcRect.bottom));

    return fUpdateRequired;
}


/*****************************Private*Routine******************************\
* Running
*
* Returns TRUE if the filter graph is in the "running" state.
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CVideoPortObj::Running()
{
    AMTRACE((TEXT("CVideoPortObj::Running")));

    return !(m_VPState == VPInfoState_STOPPED && !m_bStart);
}


/*****************************Private*Routine******************************\
* VideoPortDecimationBackend
*
*
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CVideoPortObj::VideoPortDecimationBackend(
    VPWININFO* pWinInfo,
    DWORD dwDecNumX,
    DWORD dwDecDenX,
    DWORD dwDecNumY,
    DWORD dwDecDenY
    )
{
    AMTRACE((TEXT("CVideoPortObj::VideoPortDecimationBackend")));

    //
    // This is the same backend processing as the legacy code,
    // should make this into a function and avoid the code duplication.
    //

    DDVIDEOPORTINFO svpInfo = m_svpInfo;
    if ((dwDecNumX != dwDecDenX) || (dwDecNumY != dwDecDenY)) {

        DbgLog((LOG_TRACE, 1,
                TEXT("prescaling, original image width is %d"),
                m_lImageWidth));

        //
        // Apply the video port pre-scale width factor
        //
        m_svpInfo.dwVPFlags |= DDVP_PRESCALE;
        m_svpInfo.dwPrescaleWidth = MulDiv(m_lImageWidth, dwDecNumX, dwDecDenX);

        //
        // Check the video port is aligned to the specified boundardy
        //
        if (CheckVideoPortAlignment(m_svpInfo.dwPrescaleWidth) == FALSE) {

            DbgLog((LOG_TRACE, 1,
                    TEXT("pre aligned prescale width = %d"),
                    m_svpInfo.dwPrescaleWidth));

            DWORD dwPrescaleWidth = (m_svpInfo.dwPrescaleWidth &
                    (~(m_vpCaps.dwAlignVideoPortPrescaleWidth - 1)));

            dwDecNumX = MulDiv(dwPrescaleWidth, dwDecDenX, m_lImageWidth);
            m_svpInfo.dwPrescaleWidth = dwPrescaleWidth;

            DbgLog((LOG_TRACE, 1,
                    TEXT("Cause of Alignment restrictions, now new")
                    TEXT(" m_svpInfo.dwPrescaleWidth = %d"),
                    m_svpInfo.dwPrescaleWidth));
        }

        m_svpInfo.dwPrescaleHeight =
            MulDiv(m_lImageHeight, dwDecNumY, dwDecDenY);

        DbgLog((LOG_TRACE, 1, TEXT("PrescaleWidth = %d, PrescaleHeight = %d"),
                m_svpInfo.dwPrescaleWidth, m_svpInfo.dwPrescaleHeight));

        // scale the SrcRect by the decimation values computed
        RECT &rcSrc  = pWinInfo->SrcRect;
        rcSrc.left   = MulDiv(rcSrc.left,   dwDecNumX, dwDecDenX);
        rcSrc.right  = MulDiv(rcSrc.right,  dwDecNumX, dwDecDenX);
        rcSrc.top    = MulDiv(rcSrc.top ,   dwDecNumY, dwDecDenY);
        rcSrc.bottom = MulDiv(rcSrc.bottom, dwDecNumY, dwDecDenY);
        DbgLog((LOG_TRACE, 1,
                TEXT("Src(%d, %d, %d, %d)"),
                rcSrc.left, rcSrc.top, rcSrc.right, rcSrc.bottom));
        m_bVPDecimating = TRUE;
    }
    else {
        m_svpInfo.dwVPFlags &= ~DDVP_PRESCALE;
        m_svpInfo.dwPrescaleWidth = 0;
        m_svpInfo.dwPrescaleHeight = 0;
    }

    m_dwDeciNumX = dwDecNumX;
    m_dwDeciDenX = dwDecDenX;
    m_dwDeciNumY = dwDecNumY;
    m_dwDeciDenY = dwDecDenY;

    DbgLog((LOG_TRACE, 1,
            TEXT("m_dwDeciNumX = %d m_dwDeciDenX = %d"),
            m_dwDeciNumX, m_dwDeciDenX));

    DbgLog((LOG_TRACE, 1,
            TEXT("m_dwDeciNumY = %d m_dwDeciDenY = %d"),
            m_dwDeciNumY, m_dwDeciDenY));

    return m_svpInfo.dwVPFlags != svpInfo.dwVPFlags ||
           m_svpInfo.dwPrescaleWidth != svpInfo.dwPrescaleWidth ||
           m_svpInfo.dwPrescaleHeight != svpInfo.dwPrescaleHeight;
}


/*****************************Private*Routine******************************\
* TryVideoPortDecimation
*
*
* History:
* 3/3/1999 - StEstrop - Re-Wrote the original to remove the use of doubles
*
\**************************************************************************/
HRESULT
CVideoPortObj::TryVideoPortDecimation(
    VPWININFO* pWinInfo,
    DWORD dwMinZoomFactorX,
    DWORD dwMinZoomFactorY,
    BOOL* lpUpdateRequired
    )
{
    AMTRACE((TEXT("CVideoPortObj::TryVideoPortDecimation")));

    CAutoLock cObjectLock(m_pMainObjLock);
    CheckPointer(pWinInfo, E_INVALIDARG);


    //
    // By default we don't need to call UpdateVideo on the video port
    //

    *lpUpdateRequired = FALSE;


    //
    // Make sure we do nothing if none of the source is supposed to be visible.
    //

    DWORD dwSrcWidth  = WIDTH(&pWinInfo->SrcRect);
    DWORD dwSrcHeight = HEIGHT(&pWinInfo->SrcRect);

    if (dwSrcWidth == 0 || dwSrcHeight == 0) {
        return E_FAIL;
    }


    //
    // We only decimate at the video port if it supports arbitary scaling
    //

    if (m_DecimationModeX != DECIMATE_ARB ||
        m_DecimationModeY != DECIMATE_ARB) {

        return E_FAIL;
    }


    //
    // Work out the decimation width and height as a pair of ratios,
    // we do this to remain compatible with the legacy code.
    //

    DWORD dwDecNumX = 1000;
    DWORD dwDecNumY = 1000;

    DWORD dwCurZoomX = MulDiv(WIDTH(&pWinInfo->DestRect), 1000, dwSrcWidth);
    DWORD dwCurZoomY = MulDiv(HEIGHT(&pWinInfo->DestRect), 1000, dwSrcHeight);

    if (dwCurZoomX < dwMinZoomFactorX) {
        // note that we round down here
        dwDecNumX = (1000 * dwCurZoomX) / dwMinZoomFactorX;
    }

    if (dwCurZoomY < dwMinZoomFactorY) {
        // note that we round down here
        dwDecNumY = (1000 * dwCurZoomY) / dwMinZoomFactorY;
    }


    *lpUpdateRequired = VideoPortDecimationBackend(pWinInfo, dwDecNumX, 1000,
                                                   dwDecNumY, 1000);
    return S_OK;
}

/*****************************Private*Routine******************************\
* AdjustSourceSize
*
* This function should only adjust the source rectangle if the source rectangle
* is actually larger than the destination rectangle AND the required shrink
* is beyond the capabilities of the scaler on the VGA chip.
*
* There is a special case if we are capturing, this case is identified by
* m_fCapturing being set to TRUE.  In this case we simply pass the parameters
* on to AdjustSourceSizeForCapture defined above.
*
* To ensure that the video image displayed still looks correct we make use of
* the scaling abilities of the video port.  We remove or reduce the shrink by
* reducing the size of the video coming over the video port.  This may be
* done in either the X or Y axis as necessary.
*
* The function first calculates the minimum shrink factor in both x and y
* directions.  The minimum factor in the x direction depends upon the bandwidth
* restrictions of the video port as well as the capabilities of the VGA scaler.
* The minimum shrink factor is scaled by 1000.
*
* Next for each axis we determine the current shrink factor, this is the ratio
* of the destination rectangle to the source rectangle scaled by 1000.
* If the current shrink factor is less than the minimum shrink factor we have to
* use the video port scaler to shrink the source rectangle to such a size that
* the VGA scaler is able to cope with the required scaling operation.
*
* There are three methods of scaling at the video port, the choice of method
* used is determined by querying the video port.  The three methods are:
*
* 1. Arbitrary:
* This means that the video port scaler can shrink the video
* to any requested size.  In this case we simply do all the scaling in the
* video port, the VGA scaler is not really used as the source rectangle is now
* the same size as the destination rectangle.
*
* 2. Increment:
* This means that the video port scaler can shrink the video in increments of
* x / N, where N is a constant integer returned from the video port and x is an
* variable integer in the range from 1 to (N-1).  We adjust the source rectangle
* so that is less than or equal to the destination rectangle.  The VGA scaler is
* then used if any stretching is required.
*
* 3. Binary:
* Here the video port can only shrink the video by a binary factor, that is 1/x,
* where x is a power of 2.  Again we adjust the source rectangle
* so that is less than or equal to the destination rectangle.  The VGA scaler is
* then used if any stretching is required.
*
*
* See additional comments in OVMixer.htm
*
* History:
* 3/3/1999 - StEstrop - Re-Wrote the original to remove the use of doubles
*
\**************************************************************************/
BOOL
CVideoPortObj::AdjustSourceSize(
    VPWININFO* pWinInfo,
    DWORD dwMinZoomFactorX,
    DWORD dwMinZoomFactorY
    )
{
    AMTRACE((TEXT("CVideoPortObj::AdjustSourceSize")));
    CAutoLock cObjectLock(m_pMainObjLock);
    CheckPointer(pWinInfo, FALSE);


    //
    // Make sure we do nothing if none of the source is supposed to be visible.
    //

    DWORD dwSrcWidth  = WIDTH(&pWinInfo->SrcRect);
    DWORD dwSrcHeight = HEIGHT(&pWinInfo->SrcRect);
    if (dwSrcWidth == 0 || dwSrcHeight == 0) {
        return FALSE;
    }


    //
    // Another special case for capturing, see the comments above.
    //
    if (m_fCapturing) {
        return AdjustSourceSizeForCapture(pWinInfo,dwMinZoomFactorX,
                                          dwMinZoomFactorY);
    }


    //
    // Determine the adjustment for the x axis.
    //

    DWORD dwDecNumX = 1000;
    DWORD dwDecDenX = 1000;
    DWORD dwDstWidth  = WIDTH(&pWinInfo->DestRect);
    DWORD dwCurZoomFactorX = MulDiv(dwDstWidth,  1000, dwSrcWidth);

    switch (m_DecimationModeX) {
    case DECIMATE_ARB:
        DbgLog((LOG_TRACE, 1, TEXT("DECIMATE_ARB X")));
        if (dwCurZoomFactorX < dwMinZoomFactorX) {
            dwDecNumX = dwCurZoomFactorX;
        }
        break;

    case DECIMATE_BIN:
        DbgLog((LOG_TRACE, 1, TEXT("DECIMATE_BIN X")));
        while ((DWORD)MulDiv(dwDstWidth, dwDecDenX, dwSrcWidth)
                < dwMinZoomFactorX)
        {
            dwDecDenX *= 2;
        }
        break;

    case DECIMATE_INC:
        DbgLog((LOG_TRACE, 1, TEXT("DECIMATE_INC X")));
        if (dwCurZoomFactorX < dwMinZoomFactorX) {

            dwDecNumX = MulABC_DivDE(dwDstWidth, m_ulDeciStepX, 1000,
                                     dwMinZoomFactorX, dwSrcWidth);
            dwDecDenX = m_ulDeciStepX;

            DbgLog((LOG_TRACE, 1, TEXT("dwDecNumX = %d dwDecDenX = %d"),
                    dwDecNumX, dwDecDenX ));
        }
        break;
    }


    //
    // Determine the adjustment for the y axis.
    //
    DWORD dwDecNumY = 1000;
    DWORD dwDecDenY = 1000;
    DWORD dwDstHeight = HEIGHT(&pWinInfo->DestRect);
    DWORD dwCurZoomFactorY = MulDiv(dwDstHeight, 1000, dwSrcHeight);

    switch (m_DecimationModeY) {
    case DECIMATE_ARB:
        DbgLog((LOG_TRACE, 1, TEXT("DECIMATE_ARB Y")));
        if (dwCurZoomFactorY < dwMinZoomFactorY) {
            dwDecNumY = dwCurZoomFactorY;
        }
        break;

    case DECIMATE_BIN:
        DbgLog((LOG_TRACE, 1, TEXT("DECIMATE_BIN Y")));
        while ((DWORD)MulDiv(dwDecDenY, dwDstWidth, dwSrcWidth)
                < dwMinZoomFactorY)
        {
            dwDecDenY *= 2;
        }
        break;

    case DECIMATE_INC:
        DbgLog((LOG_TRACE, 1, TEXT("DECIMATE_INC Y")));
        if (dwCurZoomFactorY < dwMinZoomFactorY) {

            dwDecNumY = MulABC_DivDE(dwDstHeight, m_ulDeciStepY, 1000,
                                     dwMinZoomFactorY, dwSrcHeight);
            dwDecDenY = m_ulDeciStepY;

            DbgLog((LOG_TRACE, 1, TEXT("dwDecNumY = %d dwDecDenY = %d"),
                    dwDecNumY, dwDecDenY ));
        }
        break;
    }

    return VideoPortDecimationBackend(pWinInfo, dwDecNumX, dwDecDenX,
                                      dwDecNumY, dwDecDenY);
}



/*****************************Private*Routine******************************\
* BeyondOverlayCaps
*
*
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CVideoPortObj::BeyondOverlayCaps(
    DWORD ScaleFactor,
    DWORD xMin,
    DWORD yMin
    )
{
    return ScaleFactor < xMin || ScaleFactor < yMin;
}



/*****************************Private*Routine******************************\
* TryDecoderDecimation
*
*
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVideoPortObj::TryDecoderDecimation(
    VPWININFO* pWinInfo
    )
{
    //
    // Extract the width and height that we are trying to decimate
    // the video image down too
    //

    DWORD dwWidth = WIDTH(&pWinInfo->DestRect);
    DWORD dwHeight = HEIGHT(&pWinInfo->DestRect);


    //
    // Try to use the new IDecimateVideoImage interface on our upstream
    // filter
    //

    IDecimateVideoImage* lpDVI;
    HRESULT hr = m_pIVideoPortControl->GetVideoDecimation(&lpDVI);
    if (SUCCEEDED(hr)) {
        hr = lpDVI->SetDecimationImageSize(dwWidth, dwHeight);
        lpDVI->Release();
    }


    //
    // If that failed try to decimate using the old IVPConfig interface
    //

    if (FAILED(hr)) {

        AMVPSIZE amvpSize;
        amvpSize.dwWidth = dwWidth;
        amvpSize.dwHeight = dwHeight;

        DbgLog((LOG_TRACE, 1,
                TEXT("SetScalingFactors to (%d, %d)"),
                amvpSize.dwWidth, amvpSize.dwHeight));

        hr = m_pIVPConfig->SetScalingFactors(&amvpSize);
    }

    //
    // If we were successful update our state variables
    //
    if (SUCCEEDED(hr)) {

        m_bDecimating = TRUE;
        pWinInfo->SrcRect.right = m_lWidth = dwWidth;
        pWinInfo->SrcRect.bottom = m_lHeight = dwHeight;
    }
    else {
        ResetDecoderDecimationIfSet();
        hr = E_FAIL;
    }

    return hr;
}



/*****************************Private*Routine******************************\
* ResetVPDecimationIfSet
*
*
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CVideoPortObj::ResetVPDecimationIfSet()
{
    BOOL bUpdateRequired = m_bVPDecimating;
    if (m_bVPDecimating) {

        m_svpInfo.dwVPFlags &= ~DDVP_PRESCALE;
        m_svpInfo.dwPrescaleWidth = 0;
        m_svpInfo.dwPrescaleHeight = 0;

        m_bVPDecimating = FALSE;
        m_dwDeciNumX = m_dwDeciDenX = 1000;
        m_dwDeciNumY = m_dwDeciDenY = 1000;
    }

    return bUpdateRequired;
}



/*****************************Private*Routine******************************\
* ResetDecoderDecimationIfSet
*
*
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
void
CVideoPortObj::ResetDecoderDecimationIfSet()
{
    if (m_bDecimating) {

        IDecimateVideoImage* lpDVI;
        HRESULT hr = m_pIVideoPortControl->GetVideoDecimation(&lpDVI);
        if (SUCCEEDED(hr)) {
            hr = lpDVI->ResetDecimationImageSize();
            lpDVI->Release();
        }


        if (FAILED(hr)) {
            AMVPSIZE amvpSize;
            amvpSize.dwWidth = m_lDecoderImageWidth;
            amvpSize.dwHeight = m_lDecoderImageHeight;

            DbgLog((LOG_TRACE,1,
                    TEXT("SetScalingFactors to (%d, %d)"),
                    amvpSize.dwWidth, amvpSize.dwHeight));

            hr = m_pIVPConfig->SetScalingFactors(&amvpSize);
        }

        if (SUCCEEDED(hr)) {
            m_bDecimating = FALSE;
            m_lWidth = 0;
            m_lHeight = 0;
        }
    }
}



/*****************************Private*Routine******************************\
* ApplyDecimation
*
* Video Port case
*
* This is where we enforce the chosen decimation strategy for the Video Port
* case.
*
* History:
* Tue 07/13/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CVideoPortObj::ApplyDecimation(
    VPWININFO* pWinInfo,
    BOOL bColorKeying,
    BOOL bYInterpolating
    )
{
    AMTRACE((TEXT("CVideoPortObj::ApplyDecimation")));
    BOOL bUpdateRequired = FALSE;

    DECIMATION_USAGE dwUsage;
    m_pIVideoPortControl->GetDecimationUsage(&dwUsage);


    //
    // Determine the current min zoom factors givin the current overlay and
    // video port connection
    //

    DWORD dwMinZoomX, dwMinZoomY;
    GetMinZoomFactors( *pWinInfo, bColorKeying, bYInterpolating,
                      &dwMinZoomX, &dwMinZoomY);

    if ((dwUsage == DECIMATION_LEGACY) ||
        (dwUsage == DECIMATION_DEFAULT && m_fCapturing)) {

        bUpdateRequired = AdjustSourceSize(pWinInfo,
                                           dwMinZoomX,
                                           dwMinZoomY);
    }


    else {

        if (Running()) {

            DWORD ScaleFactor = VPMUtil::GetCurrentScaleFactor( *pWinInfo);
            if ( VPMUtil::IsDecimationNeeded(ScaleFactor)) {

                switch (dwUsage) {

                case DECIMATION_USE_OVERLAY_ONLY:
                    bUpdateRequired = ResetVPDecimationIfSet();
                    m_pIVideoPortControl->CropSourceRect(pWinInfo,
                                                  dwMinZoomX,
                                                  dwMinZoomY);
                    break;

                case DECIMATION_USE_DECODER_ONLY:
                    bUpdateRequired = ResetVPDecimationIfSet();
                    if (TryDecoderDecimation(pWinInfo) != S_OK) {
                        m_pIVideoPortControl->CropSourceRect(pWinInfo,
                                                      dwMinZoomX,
                                                      dwMinZoomY);
                    }
                    break;

                case DECIMATION_USE_VIDEOPORT_ONLY:
                    ResetDecoderDecimationIfSet();
                    if (TryVideoPortDecimation(pWinInfo, 1000,
                                               1000,
                                               &bUpdateRequired) != S_OK) {

                        m_pIVideoPortControl->CropSourceRect(pWinInfo,
                                                      dwMinZoomX,
                                                      dwMinZoomY);
                    }
                    break;

                case DECIMATION_DEFAULT:
                    if (TryDecoderDecimation(pWinInfo) != S_OK) {
                        if (BeyondOverlayCaps(ScaleFactor, dwMinZoomX,
                                              dwMinZoomY)) {

                            if (TryVideoPortDecimation(pWinInfo,
                                                       dwMinZoomX,
                                                       dwMinZoomY,
                                                       &bUpdateRequired) != S_OK) {

                                m_pIVideoPortControl->CropSourceRect(pWinInfo,
                                                              dwMinZoomX,
                                                              dwMinZoomY);
                            }
                        }
                    }
                    break;
                }
            }
            else {

                ResetDecoderDecimationIfSet();
                bUpdateRequired = ResetVPDecimationIfSet();
            }
        }


        else {

            if (m_bVPDecimating) {

                //
                // Apply the current pre-scale to the source image.
                //

                RECT &rcSrc = pWinInfo->SrcRect;
                rcSrc.left = MulDiv(rcSrc.left, m_dwDeciNumX, m_dwDeciDenX);
                rcSrc.top = MulDiv(rcSrc.top, m_dwDeciNumY, m_dwDeciDenY);
                rcSrc.right = MulDiv(rcSrc.right, m_dwDeciNumX, m_dwDeciDenX);
                rcSrc.bottom = MulDiv(rcSrc.bottom, m_dwDeciNumY, m_dwDeciDenY);
            }

            if (m_bDecimating) {

                //
                // Apply the current decoder decimation to the source image.
                //

                pWinInfo->SrcRect.right = m_lWidth;
                pWinInfo->SrcRect.bottom = m_lHeight;
            }

            //
            // Then make sure that any shrinking falls within the capabilities
            // of the scaler on the VGA chip, cropping if necessary.
            //

            m_pIVideoPortControl->CropSourceRect(pWinInfo, dwMinZoomX, dwMinZoomY);
        }
    }

    return bUpdateRequired;
}
/******************************Public*Routine******************************\
* MulABC_DivDE
*
* Performs the following calculation:  ((A*B*C) / (D*E)) rounding the result
* to the nearest integer.
*
* History:
* 3/3/1999 - StEstrop - Created
*
\**************************************************************************/
DWORD MulABC_DivDE(DWORD A, DWORD B, DWORD C, DWORD D, DWORD E)
{

    unsigned __int64 Num = (unsigned __int64)A * (unsigned __int64)B;
    unsigned __int64 Den = (unsigned __int64)D * (unsigned __int64)E;

    Num *= (unsigned __int64)C;
    Num += (Den / 2);

    unsigned __int64 Res = Num / Den;

    return (DWORD)Res;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vpm\vpmfilter.cpp ===
/******************************Module*Header*******************************\
* Module Name: CVPMFilter.cpp
*
*
*
*
* Created: Tue 02/15/2000
* Author:  Glenn Evans [GlennE]
*
* Copyright (c) 2000 Microsoft Corporation
\**************************************************************************/
#include <streams.h>
#include <windowsx.h>
#include <limits.h>

// IID_IDirectDraw7
#include <ddraw.h>

#ifdef FILTER_DLL
#include <initguid.h>
DEFINE_GUID(IID_IDirectDraw7, 0x15e65ec0,0x3b9c,0x11d2,0xb9,0x2f,0x00,0x60,0x97,0x97,0xea,0x5b);
#endif

#include <VPManager.h>
#include <VPMExtern.h>
#include <VPMPin.h>
#include "DRect.h"
#include "VPMUtil.h"
#include "VPMThread.h"
#include <VBIObj.h>

// VIDEOINFOHEADER1/2
#include <dvdmedia.h>

// IDirectDrawKernel / GetKernCaps
#include <ddkernel.h>


// Setup data
AMOVIESETUP_MEDIATYPE sudPinOutputTypes[] =
{
    {
        &MEDIATYPE_Video,      // Major type
        &MEDIASUBTYPE_NULL     // Minor type
    }
};
AMOVIESETUP_MEDIATYPE sudPinInputTypesVP[] =
{
    {
        &MEDIATYPE_Video,      // Major type
        &MEDIASUBTYPE_VPVideo  // Minor type
    },
};

AMOVIESETUP_MEDIATYPE sudPinInputTypesVBI[] =
{
    {
        &MEDIATYPE_Video,      // Major type
        &MEDIASUBTYPE_VPVBI    // Minor type
    }
};

AMOVIESETUP_PIN psudPins[] =
{
    {
        L"VPIn",                    // Pin's string name
        FALSE,                      // Is it rendered
        FALSE,                      // Is it an output
        FALSE,                      // Allowed none
        FALSE,                      // Allowed many
        &CLSID_NULL,                // Connects to filter
        L"Output",                  // Connects to pin
        NUMELMS(sudPinInputTypesVP),// Number of types
        sudPinInputTypesVP          // Pin information
    },
    {
        L"VBIIn",                   // Pin's string name
        FALSE,                      // Is it rendered
        FALSE,                      // Is it an output
        FALSE,                      // Allowed none
        FALSE,                      // Allowed many
        &CLSID_NULL,                // Connects to filter
        NULL,                       // Connects to pin
        NUMELMS(sudPinInputTypesVBI),// Number of types
        sudPinInputTypesVBI         // Pin information
    },
    {
        L"Output",                  // Pin's string name
        FALSE,                      // Is it rendered
        TRUE,                       // Is it an output
        FALSE,                      // Allowed none
        FALSE,                      // Allowed many
        &CLSID_NULL,                // Connects to filter
        L"VPIn",                    // Connects to pin
        NUMELMS(sudPinOutputTypes), // Number of types
        sudPinOutputTypes           // Pin information
    }
};

const AMOVIESETUP_FILTER sudVPManager =
{
    &CLSID_VideoPortManager,     // Filter CLSID
    L"Video Port Manager", // Filter name
    MERIT_NORMAL ,    // Filter merit
    sizeof(psudPins) / sizeof(AMOVIESETUP_PIN), // Number pins
    psudPins                  // Pin details
};

#ifdef FILTER_DLL
// List of class IDs and creator functions for the class factory. This
// provides the link between the OLE entry point in the DLL and an object
// being created. The class factory will call the static CreateInstance
//
//  Property set defines for notifying owner.
//
// {7B390654-9F74-11d1-AA80-00C04FC31D60}
//#define DO_INIT_GUID
// DEFINE_GUID(AMPROPSETID_NotifyOwner,
//             0x7b390654, 0x9f74, 0x11d1, 0xaa, 0x80, 0x0, 0xc0, 0x4f, 0xc3, 0x1d, 0x60);
//#undef DO_INIT_GUID

CFactoryTemplate g_Templates[] =
{
    { L"Video Port Manager", &CLSID_VideoPortManager, CVPMFilter::CreateInstance, NULL, &sudVPManager },
    //{ L"", &CLSID_COMQualityProperties,COMQualityProperties::CreateInstance},
    //{ L"", &CLSID_COMPinConfigProperties,COMPinConfigProperties::CreateInstance},
    //{ L"", &CLSID_COMPositionProperties,COMPositionProperties::CreateInstance},
    //{ L"", &CLSID_COMVPInfoProperties,COMVPInfoProperties::CreateInstance}

};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

// DllRegisterSever
HRESULT DllRegisterServer()
{
    return AMovieDllRegisterServer2(TRUE);
} // DllRegisterServer


// DllUnregisterServer
HRESULT DllUnregisterServer()
{
    return AMovieDllRegisterServer2(FALSE);
} // DllUnregisterServer

#endif // FILTER_DLL

// CreateInstance
CUnknown* CVPMFilter_CreateInstance(LPUNKNOWN pUnk, HRESULT* phr)
{
    return CVPMFilter::CreateInstance( pUnk, phr);
}

// This goes in the factory template table to create new filter instances
CUnknown *CVPMFilter::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CVPMFilter(NAME("VideoPort Manager"), pUnk, phr );
} // CreateInstance

#pragma warning(disable:4355)

CVPMFilter::Pins::Pins( CVPMFilter& filter, HRESULT* phr )
: VPInput(NAME("VPManager Input pin"), filter, phr, L"VP Input", 0)
, VBIInput(NAME("VPManager Input pin"), filter, phr, L"VPVBI Input", 1)
, Output( NAME("VPManager Output pin"), filter, phr, L"Output", 2)
, dwCount( 3 )
{
}

CVPMFilter::Pins::~Pins()
{
}

// Constructor
CVPMFilter::CVPMFilter(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr)
: CBaseFilter(pName, pUnk, &this->m_csFilter, CLSID_VideoPortManager, phr)
, m_pPosition(NULL)
, m_dwKernelCaps(0)
, m_dwPinConfigNext(0)
, m_pDirectDraw( NULL )
, m_dwDecimation( DECIMATION_LEGACY )
, m_pPins( NULL )
, m_pThread( NULL )
, m_dwVideoPortID( 0 )
    // create the pins
{
    AMTRACE((TEXT("Entering CVPMFilter::CVPMFilter")));
    m_pPins = new Pins( *this, phr );    // must be init'd after filter constructor since depends on 'this'
    if( !m_pPins ) {
        *phr = E_OUTOFMEMORY;
    } else {
        IncrementPinVersion();

        ZeroStruct( m_DirectCaps );
        ZeroStruct( m_DirectSoftCaps );

        HRESULT hr = NOERROR;
        ASSERT(phr != NULL);

        //
        // Initialize DDraw the MMon structures
        //

        SetDecimationUsage(DECIMATION_DEFAULT);

        // distribute DDraw object to the pins
        hr = InitDirectDraw(NULL);

        // can fail if the hardware caps are not usable
        if( SUCCEEDED( hr ) ) {
            SetDirectDraw( m_pDirectDraw );
        }
    }
}

CVPMFilter::~CVPMFilter()
{
    AMTRACE((TEXT("Entering CVPMFilter::~CVPMFilter")));
    delete m_pThread;
    m_pThread = NULL;

    RELEASE( m_pPosition );
    // release directdraw, Source surface etc.
    ReleaseDirectDraw();

    RELEASE( m_pPosition ); // release IMediaSeeking pass through
    delete m_pPins;
}

// NonDelegatingQueryInterface
STDMETHODIMP CVPMFilter::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    AMTRACE((TEXT("CVPMFilter::NonDelegatingQueryInterface")));
    ValidateReadWritePtr(ppv,sizeof(PVOID));

    if( riid == IID_IVPManager ) {
        return GetInterface( static_cast<IVPManager *>(this), ppv );
    }
    else if (riid == IID_IAMVideoDecimationProperties) {
        return GetInterface( static_cast<IAMVideoDecimationProperties *>( this ), ppv);
    } else if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking) {
        // we should have an input pin by now
        if (m_pPosition == NULL) {
            HRESULT hr = CreatePosPassThru(GetOwner(), FALSE, &m_pPins->VPInput, &m_pPosition);
            if (FAILED(hr)) {
                DbgLog((LOG_ERROR, 1, TEXT("CreatePosPassThru failed, hr = 0x%x"), hr));
                return hr;
            }
        }
        return m_pPosition->QueryInterface(riid, ppv);
    } else if (riid == IID_ISpecifyPropertyPages && 0 != VPMUtil::GetPropPagesRegistryDword( 0) ) {
        return GetInterface( static_cast<ISpecifyPropertyPages *>( this ), ppv);
    } else if (riid == IID_IQualProp) {
        return GetInterface( static_cast<IQualProp *>( this ), ppv);
    } else if (riid == IID_IKsPropertySet) {
        return GetInterface( static_cast<IKsPropertySet *>( this ), ppv);
    }

    CAutoLock lFilter( &GetFilterLock() );

    //
    //  BUGBUG - this is not COM.  This would imply that our input
    //  pin is the same object as our filter

    //  We should proxy these calls

    if (riid == IID_IVPNotify || riid == IID_IVPNotify2 || riid == IID_IVideoPortInfo) {
        ASSERT( !"VPNotify nondel QI'd" );
        return m_pPins->VPInput.NonDelegatingQueryInterface(riid, ppv);
    } else if (riid == IID_IVPVBINotify) {
        ASSERT( !"IID_IVPVBINotify nondel QI'd" );
        return m_pPins->VBIInput.NonDelegatingQueryInterface(riid, ppv);
    }

    return CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
}


// --- ISpecifyPropertyPages ---

STDMETHODIMP CVPMFilter::GetPages(CAUUID *pPages)
{
#if 0
#if defined(DEBUG)
    pPages->cElems = 4+m_dwInputPinCount;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID)*(4+m_dwInputPinCount));
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }

    #define COM_QUAL
    #ifdef COM_QUAL
        pPages->pElems[0]   = CLSID_COMQualityProperties;
    #else
        pPages->pElems[0]   = CLSID_QualityProperties;
    #endif

    pPages->pElems[1] = CLSID_COMPositionProperties;
    pPages->pElems[2] = CLSID_COMVPInfoProperties;
    pPages->pElems[3] = CLSID_COMDecimationProperties;

    // Add PinConfig page for all input pins first
    for (unsigned int i=0; i<m_dwInputPinCount; i++)
    {
        pPages->pElems[4+i] = CLSID_COMPinConfigProperties;
    }
#else
    pPages->cElems = 3+m_dwInputPinCount;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID)*(3+m_dwInputPinCount));
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }

    #define COM_QUAL
    #ifdef COM_QUAL
        pPages->pElems[0]   = CLSID_COMQualityProperties;
    #else
        pPages->pElems[0]   = CLSID_QualityProperties;
    #endif

    pPages->pElems[1] = CLSID_COMPositionProperties;
    pPages->pElems[2] = CLSID_COMVPInfoProperties;

    // Add PinConfig page for all input pins first
    for (unsigned int i=0; i<m_dwInputPinCount; i++)
    {
        pPages->pElems[3+i] = CLSID_COMPinConfigProperties;
    }

#endif
#endif
    return NOERROR;
}

// IQualProp property page support

STDMETHODIMP CVPMFilter::get_FramesDroppedInRenderer(int *cFramesDropped)
{
    // CVPMInputPin *pPin = m_pPins->VPInput;
    // if (pPin && pPin.m_pSyncObj)
    //     return pPin.m_pSyncObj->get_FramesDroppedInRenderer(cFramesDropped);
    return S_FALSE;
}

STDMETHODIMP CVPMFilter::get_FramesDrawn(int *pcFramesDrawn)
{
    // CVPMInputPin *pPin = m_pPins->VPInput;
    // if (pPin && pPin.m_pSyncObj)
    //     return pPin.m_pSyncObj->get_FramesDrawn(pcFramesDrawn);
    return S_FALSE;
}

STDMETHODIMP CVPMFilter::get_AvgFrameRate(int *piAvgFrameRate)
{
    // CVPMInputPin *pPin = m_pPins->VPInput;
    // if (pPin && pPin.m_pSyncObj)
    //     return pPin.m_pSyncObj->get_AvgFrameRate(piAvgFrameRate);
    return S_FALSE;
}

STDMETHODIMP CVPMFilter::get_Jitter(int *piJitter)
{
    // CVPMInputPin *pPin = m_pPins->VPInput;
    // if (pPin && pPin.m_pSyncObj)
    //     return pPin.m_pSyncObj->get_Jitter(piJitter);
    return S_FALSE;
}

STDMETHODIMP CVPMFilter::get_AvgSyncOffset(int *piAvg)
{
    // CVPMInputPin *pPin = m_pPins->VPInput;
    // if (pPin && pPin.m_pSyncObj)
    //     return pPin.m_pSyncObj->get_AvgSyncOffset(piAvg);
    return S_FALSE;
}

STDMETHODIMP CVPMFilter::get_DevSyncOffset(int *piDev)
{
    // CVPMInputPin *pPin = m_pPins->VPInput;
    // if (pPin && pPin.m_pSyncObj)
    //     return pPin.m_pSyncObj->get_DevSyncOffset(piDev);
    return S_FALSE;
}

int CVPMFilter::GetPinCount()
{
    return m_pPins->dwCount;
}

// returns a non-addrefed CBasePin *
CBasePin* CVPMFilter::GetPin(int n)
{
    AMTRACE((TEXT("CVPMFilter::GetPin")));

    CAutoLock lFilter( &GetFilterLock() );

    // check that the pin requested is within range
    if (n >= (int)m_pPins->dwCount)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Bad Pin Requested, n = %d, No. of Pins = %d"),
            n, m_pPins->dwCount+1));
        return NULL;
    }
    switch( n ) {
    case 0:
        return &m_pPins->VPInput;
    case 1:
        return &m_pPins->VBIInput;
    default:
        return &m_pPins->Output;
    }
}

HRESULT CVPMFilter::CreateThread()
{
    if( !m_pThread ) {
        m_pThread = new CVPMThread( this );
        if( !m_pThread ) {
            return E_OUTOFMEMORY;
        }

        LPDIRECTDRAWVIDEOPORT pVP = NULL;
        HRESULT hr = m_pPins->VPInput.m_pIVPObject->GetDirectDrawVideoPort( &pVP );
        m_pThread->SignalNewVP( pVP );
        RELEASE( pVP );
    }
    return S_OK;
}


/******************************Public*Routine******************************\
* CVPMFilter::Run
*
*
*
* History:
* Fri 02/25/2000 - GlennE - Created
*
\**************************************************************************/
STDMETHODIMP
CVPMFilter::Run(
    REFERENCE_TIME StartTime
    )
{
    AMTRACE((TEXT("CVPMFilter::Run")));
    CAutoLock lFilter( &GetFilterLock() );

    if (m_State == State_Running) {
        NOTE("State set");
        return S_OK;
    }

    DbgLog((LOG_TRACE, 2, TEXT("Changing state to running")));
    HRESULT hr = CBaseFilter::Run(StartTime);
    if( SUCCEEDED( hr )) {
        hr = CreateThread();
        if( SUCCEEDED( hr )) {
            hr = m_pThread->Run();
        }
    }
    return hr;
}

// the base classes inform the pins of every state transition except from
// run to pause. Overriding Pause to inform the input pins about that transition also
STDMETHODIMP CVPMFilter::Pause()
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMFilter::Pause")));

    CAutoLock lFilter( &GetFilterLock() );

    switch( m_State ) {
        case State_Paused:
            hr = m_pPins->VPInput.CompleteStateChange(State_Paused);
            if( FAILED(hr)) {
                return hr;
            }
            break;

        case State_Running:
            m_State = State_Paused;
            // set the pointer to DirectDraw and the SourceSurface on All the Input Pins
            if( m_pPins->VPInput.IsConnected() ) {
                hr = m_pPins->VPInput.RunToPause();
                if (FAILED(hr)) {
                    DbgLog((LOG_ERROR, 1, TEXT("GetVPInputPin.RunToPause failed, hr = 0x%x"), hr));
                    return hr;
                }
            }
            if( m_pPins->VBIInput.IsConnected() ) {
                hr = m_pPins->VBIInput.RunToPause();
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR, 1, TEXT("GetVBIInputPin.RunToPause failed, hr = 0x%x"), hr));
                    return hr;
                }
            }
            break;

        default:
            break;
    }
    hr = CBaseFilter::Pause();
    if( SUCCEEDED(hr)) {
        if ( m_State != State_Paused )
        {
            hr = m_pPins->VPInput.CompleteStateChange(State_Paused);
            if( SUCCEEDED( hr )) {
                hr = CreateThread();
            }
            if( SUCCEEDED( hr ) ) {
                // we don't want to hold the filter lock and wait for the thread
                // since we'll deadlock if it uses any of our methods
                hr = m_pThread->Pause();
            }
        }
    }
    return hr;
}

// Overridden the base class Stop() method just to stop MV.
STDMETHODIMP CVPMFilter::Stop()
{
    AMTRACE((TEXT("CVPMFilter::Stop")));

    CAutoLock lFilter( &GetFilterLock() ) ;

    // stop thread BEFORE taking the receive lock (otherwise we'll hold it and the thread
    // could want it to send a sample)
    HRESULT  hr = NOERROR ;
    if( m_pThread ) {
        hr = m_pThread->Stop();
        ASSERT( SUCCEEDED( hr ));
    }

    CAutoLock lReceive( &GetReceiveLock() );
    hr = CBaseFilter::Stop() ;
    return hr ;
}


int CVPMFilter::GetPinPosFromId(DWORD dwPinId)
{
    if ( m_pPins->VPInput.GetPinId() == dwPinId) {
        return 0;
    }
    if ( m_pPins->VBIInput.GetPinId() == dwPinId) {
        return 1;
    }
    if ( m_pPins->Output.GetPinId() == dwPinId) {
        return 2;
    }
    return -1;
}


// reconnect the output pin based on the mediatype of the input pin
HRESULT CVPMFilter::HandleConnectInputWithOutput()
{
    // we won't allow this, you must disconnect the output first
    // Future: We could try a dynamic reconnect on the output...
    return E_FAIL;
#if 0
    return S_OK;
    // find the renderer's pin
    pPeerOutputPin = m_pPins->Output.GetConnected();
    if (pPeerOutputPin == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("ConnectedTo failed")));
        goto CleanUp;
    }
    ASSERT(pPeerOutputPin);

    // find the output pin connection mediatype
    hr = m_pPins->Output.ConnectionMediaType(&outPinMediaType);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("ConnectionMediaType failed")));
        goto CleanUp;
    }


    pHeader = VPMUtil::GetbmiHeader(&outPinMediaType);
    if (!pHeader)
    {
        hr = E_FAIL;
        goto CleanUp;
    }


    // compare the new values with the current ones.
    // See if we need to reconnect at all
    if (pHeader->biWidth != (LONG)m_dwAdjustedVideoWidth ||
        pHeader->biHeight != (LONG)m_dwAdjustedVideoHeight)
    {
        bNeededReconnection = TRUE;
    }

    // If we don't need reconnection, bail out
    if (bNeededReconnection)
    {

        // Ok we do need reconnection, set the right values
        pHeader->biWidth = m_dwAdjustedVideoWidth;
        pHeader->biHeight = m_dwAdjustedVideoHeight;
        if (outPinMediaType.formattype == FORMAT_VideoInfo)
        {
            VIDEOINFOHEADER* pVIHeader = (VIDEOINFOHEADER*)(outPinMediaType.pbFormat);
            SetRect(&pVIHeader->rcSource, 0, 0, m_dwAdjustedVideoWidth, m_dwAdjustedVideoHeight);
            SetRect(&pVIHeader->rcTarget, 0, 0, m_dwAdjustedVideoWidth, m_dwAdjustedVideoHeight);
        }
        else if (outPinMediaType.formattype == FORMAT_VideoInfo2)
        {
            VIDEOINFOHEADER2* pVIHeader = (VIDEOINFOHEADER2*)(outPinMediaType.pbFormat);
            SetRect(&pVIHeader->rcSource, 0, 0, m_dwAdjustedVideoWidth, m_dwAdjustedVideoHeight);
            SetRect(&pVIHeader->rcTarget, 0, 0, m_dwAdjustedVideoWidth, m_dwAdjustedVideoHeight);
        }


        // Query the upstream filter asking if it will accept the new media type.
        hr = pPeerOutputPin->QueryAccept(&outPinMediaType);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,TEXT("m_pVPDraw->QueryAccept failed")));
            goto CleanUp;
        }

        // Reconnect using the new media type.
        hr = ReconnectPin(pPeerOutputPin, &outPinMediaType);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,TEXT("m_pVPDraw->Reconnect failed")));
            goto CleanUp;
        }
    }
#endif
}


HRESULT CVPMFilter::CompleteConnect(DWORD dwPinId)
{
    AMTRACE((TEXT("CVPMFilter::CompleteConnect")));

    CAutoLock lFilter( &GetFilterLock() );
    CAutoLock lReceive( &GetReceiveLock() );

    int iPinPos = GetPinPosFromId(dwPinId);
    ASSERT(iPinPos >= 0 );

    // we only care about format conflicts between the VP & output, VBI isn't an issue (just allocating memory for someone else)
    HRESULT hr;
    if ( m_pPins->VPInput.GetPinId() == dwPinId ) {
        if( !m_pPins->Output.IsConnected() ) {
            hr = HandleConnectInputWithoutOutput();
        } else {
            hr = HandleConnectInputWithOutput();
        }
    } else if( m_pPins->Output.GetPinId() == dwPinId ) {
        if( !m_pPins->VPInput.IsConnected() ) {
            // HandleConnectOutputWithoutInput();
            // We need an input...
            return E_FAIL;
        } else {
            //  HandleConnectOutputWithInput();
            // we have already created a source surface, we restrict format types
            // on the output pin to avoid conversions in the VPM
            return S_OK;
        }
    } else {
        hr = S_OK;
    }
    return hr;
}

HRESULT CVPMFilter::HandleConnectInputWithoutOutput()
{
    AMTRACE((TEXT("CVPMFilter::HandleConnectInputWithoutOutput")));

    CMediaType inPinMediaType;
    CMediaType outPinMediaType;

    IPin *pPeerOutputPin = NULL;

    BOOL bNeededReconnection = FALSE;
    DWORD dwNewWidth = 0, dwNewHeight = 0, dwPictAspectRatioX = 0, dwPictAspectRatioY = 0;
    DRect rdDim;
    RECT rDim;
    BITMAPINFOHEADER *pHeader = NULL;

    // find the input pin connection mediatype
    HRESULT hr = m_pPins->VPInput.CurrentMediaType(&inPinMediaType);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,TEXT("CurrentMediaType failed")));
        goto CleanUp;
    }

    pHeader = VPMUtil::GetbmiHeader(&inPinMediaType);
    if (!pHeader)
    {
        hr = E_FAIL;
        goto CleanUp;
    }

    hr = VPMUtil::GetPictAspectRatio( inPinMediaType, &dwPictAspectRatioX, &dwPictAspectRatioY);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("GetPictAspectRatio failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    ASSERT(dwPictAspectRatioX > 0);
    ASSERT(dwPictAspectRatioY > 0);

    hr = m_pPins->VPInput.AttachVideoPortToSurface();
    // ASSERT( SUCCEEDED( hr) );
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pFilter->AttachVideoPortToSurface failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
CleanUp:
    return hr;
}

HRESULT CVPMFilter::BreakConnect(DWORD dwPinId)
{
    HRESULT hr = NOERROR;
    AMTRACE((TEXT("CVPMFilter::BreakConnect")));

    CAutoLock lFilter( &GetFilterLock() );
    CAutoLock lReceive( &GetReceiveLock() );

    int iPinPos = GetPinPosFromId(dwPinId);
    ASSERT(iPinPos >= 0 );

    // if atleast one pin is connected, we are not going to do anything
    hr = ConfirmPreConnectionState(dwPinId);
    if (FAILED(hr))
    {

        DbgLog((LOG_TRACE, 3, TEXT("filter not in preconnection state, hr = 0x%x"), hr));
        goto CleanUp;
    }


CleanUp:
    return NOERROR;
}

HRESULT CVPMFilter::SetMediaType(DWORD dwPinId, const CMediaType *pmt)
{
    AMTRACE((TEXT("CVPMFilter::SetMediaType")));

    CAutoLock lFilter( &GetFilterLock() );

    // reject all SetMediaTypes if the DDraw object wasn't compatible
    if( m_pDirectDraw ) {
        return NOERROR;
    } else {
        return E_FAIL;
    }
}

// gets events notifications from pins
HRESULT CVPMFilter::EventNotify(    DWORD dwPinId,
                                long lEventCode,
                                DWORD_PTR lEventParam1,
                                DWORD_PTR lEventParam2)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::EventNotify")));

    CAutoLock lFilter( &GetFilterLock() );

    if (lEventCode == EC_COMPLETE)
    {
        IPin *pRendererPin = m_pPins->Output.CurrentPeer();

        //  Output pin may not be connected (for instance
        //  RenegotiateVPParameters can fail while connecting
        if (pRendererPin) {
            pRendererPin->EndOfStream();
        }
    } else {
        NotifyEvent(lEventCode, lEventParam1, lEventParam2);
    }

    return hr;
}

STDMETHODIMP CVPMFilter::GetState(DWORD dwMSecs,FILTER_STATE *pState)
{
    HRESULT hr = NOERROR;

    CAutoLock lFilter( &GetFilterLock() );

    hr = m_pPins->VPInput.GetState(dwMSecs, pState);
    if (hr == E_NOTIMPL)
    {
        hr = CBaseFilter::GetState(dwMSecs, pState);
    }
    return hr;
}



const DDCAPS* CVPMFilter::GetHardwareCaps()
{
    HRESULT hr;

    AMTRACE((TEXT("CVPMFilter::GetHardwareCaps")));

    CAutoLock lFilter( &GetFilterLock() );

    if (!m_pDirectDraw) {
        return NULL;
    } else {
        return &m_DirectCaps;
    }
}

static HRESULT PropagateMediaType( CBaseOutputPin* pOutPin )
{
    // if the output pin is connected and there's a new video port, send a new media type change
    HRESULT hr = S_OK;
    if( pOutPin->IsConnected() ) {
        CMediaType cmt;

        // rebuild media type from current VPInfo
        hr = pOutPin->GetMediaType(0, &cmt );
        if( SUCCEEDED( hr )) {
            IPin* pVMRPin;
            hr =  pOutPin->ConnectedTo( &pVMRPin );
            if( SUCCEEDED( hr )) {
                hr = pVMRPin->ReceiveConnection( pOutPin, &cmt );
                // this should not fail as before we assumed that it would ALWAYS work
                // even when the res mode changed
                ASSERT( SUCCEEDED( hr ));
                pVMRPin->Release();
            }
        }
    }
    return hr;
}

HRESULT CVPMFilter::SignalNewVP( LPDIRECTDRAWVIDEOPORT pVP )
{
    HRESULT hr;

    AMTRACE((TEXT("CVPMFilter::SignalNewVP")));
    CAutoLock lReceive( &GetFilterLock() );

    // tell the thread to remove any references to the videoport
    // This avoids the situation where we do a dynamic reconnect,
    // but the VPM thread is holding onto a sample (so the dynamic reconnect fails)

    if( m_pThread ) {
        hr = m_pThread->SignalNewVP( NULL );
    }

    if( pVP ) {
        hr = PropagateMediaType( &m_pPins->Output );
    }
    if( m_pThread ) {
        hr = m_pThread->SignalNewVP( pVP );
    } else {
        // not really a failure if there isn't a thread
        hr = S_FALSE;
    }
    return hr;
}

static BOOL WINAPI GetPrimaryCallbackEx(
  GUID FAR *lpGUID,
  LPSTR     lpDriverDescription,
  LPSTR     lpDriverName,
  LPVOID    lpContext,
  HMONITOR  hm
)
{
    GUID&  guid = *((GUID *)lpContext);
    if( !lpGUID ) {
        guid = GUID_NULL;
    } else {
        guid = *lpGUID;
    }
    return TRUE;
}

/*****************************Private*Routine******************************\
* CreateDirectDrawObject
*
*
*
* History:
* Fri 08/20/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CreateDirectDrawObject(
    const GUID* pGUID,
    LPDIRECTDRAW7 *ppDirectDraw
    )
{
    UINT ErrorMode = SetErrorMode(SEM_FAILCRITICALERRORS);
    HRESULT hr = DirectDrawCreateEx( const_cast<GUID*>(pGUID), (LPVOID *)ppDirectDraw,
                                            IID_IDirectDraw7, NULL);
    SetErrorMode(ErrorMode);
    return hr;
}


// This function is used to allocate the direct-draw related resources.
// This includes allocating the direct-draw service provider
HRESULT CVPMFilter::InitDirectDraw(LPDIRECTDRAW7 pDirectDraw)
{
    HRESULT hr = NOERROR;
    HRESULT hrFailure = VFW_E_DDRAW_CAPS_NOT_SUITABLE;
    DDSURFACEDESC SurfaceDescP;
    int i;

    AMTRACE((TEXT("CVPMFilter::InitDirectDraw")));

    CAutoLock lFilter( &GetFilterLock() );

    // addref the new ddraw object
    if (pDirectDraw)
    {
        pDirectDraw->AddRef();
    }
    // release the previous direct draw object if any
    ReleaseDirectDraw();

    // if given a valid ddraw object, make a copy of it (we have already addref'd it)
    // else allocate your own
    if (NULL == pDirectDraw)
    {
        // Ask the loader to create an instance
        GUID primary;
        hr = DirectDrawEnumerateExA(GetPrimaryCallbackEx,&primary,DDENUM_ATTACHEDSECONDARYDEVICES);
        if( FAILED(hr)) {
            ASSERT( !"Can't get primary" );
            goto CleanUp;
        }
        hr = CreateDirectDrawObject( &primary, &pDirectDraw);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("Function InitDirectDraw, LoadDirectDraw failed")));
            hr = hrFailure;
            goto CleanUp;
        }
        // Set the cooperation level on the surface to be shared
        hr = pDirectDraw->SetCooperativeLevel(NULL, DDSCL_FPUPRESERVE | DDSCL_NORMAL);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pDirectDraw->SetCooperativeLevel failed")));
            hr = hrFailure;
            goto CleanUp;
        }
    }
    SetDirectDraw( pDirectDraw );

    // Initialise our capabilities structures
    ASSERT(m_pDirectDraw);

    INITDDSTRUCT(m_DirectCaps);
    INITDDSTRUCT(m_DirectSoftCaps);

    // Load the hardware and emulation capabilities
    hr = m_pDirectDraw->GetCaps(&m_DirectCaps,&m_DirectSoftCaps);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pDirectDraw->GetCapsGetCaps failed")));
        hr = hrFailure;
        goto CleanUp;
    }

    // Get the kernel caps only if we have a video port, in which case the driver
    // should implement them.  CheckMediaType verifies that we have a videoport
    // before connecting.
    if( m_DirectCaps.dwCaps2 & DDCAPS2_VIDEOPORT ) {
        IDirectDrawKernel *pDDKernel;
        if (SUCCEEDED(m_pDirectDraw->QueryInterface(
                IID_IDirectDrawKernel, (void **)&pDDKernel))) {
            DDKERNELCAPS ddCaps;
            ddCaps.dwSize = sizeof(ddCaps);
            if (SUCCEEDED(pDDKernel->GetCaps(&ddCaps))) {
                m_dwKernelCaps = ddCaps.dwCaps;
            }
            pDDKernel->Release();
        } else {
            ASSERT( !"Can't get kernel caps");
        }
    }
    // make sure the caps are ok
    hr = CheckCaps();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CheckCaps failed")));
        goto CleanUp;
    }

    // if we have reached this point, we should have a valid ddraw object
    ASSERT(m_pDirectDraw);

CleanUp:

    // anything fails, might as well as release the whole thing
    if (FAILED(hr))
    {
        ReleaseDirectDraw();
    }
    return hr;
}

HRESULT CVPMFilter::CheckCaps()
{
    HRESULT hr = NOERROR;
    DWORD dwMinStretch, dwMaxStretch;

    AMTRACE((TEXT("CVPMFilter::CheckCaps")));

    CAutoLock lReceive( &GetReceiveLock() );

    // Output misc debug info (see below for items we actually check)
    //
    if(m_DirectCaps.dwCaps & DDCAPS_OVERLAY) {
        DbgLog((LOG_TRACE, 1, TEXT("Device does support Overlays")));
    } else {
        DbgLog((LOG_TRACE, 1, TEXT("Device does not support Overlays")));
    }

    // get all direct-draw capabilities
    if (m_DirectCaps.dwCaps & DDCAPS_OVERLAYSTRETCH) {
        DbgLog((LOG_TRACE, 1, TEXT("hardware can support overlay strecthing")));
    } else {
        DbgLog((LOG_TRACE, 1, TEXT("hardware can't support overlay strecthing")));
    }

    // get the alignment restriction on src boundary
    if (m_DirectCaps.dwCaps & DDCAPS_ALIGNBOUNDARYSRC) {
        DbgLog((LOG_TRACE, 1, TEXT("dwAlignBoundarySrc = %d"), m_DirectCaps.dwAlignBoundarySrc));
    } else {
        DbgLog((LOG_TRACE, 1, TEXT("No alignment restriction on BoundarySrc")));
    }

    // get the alignment restriction on dest boundary
    if (m_DirectCaps.dwCaps & DDCAPS_ALIGNBOUNDARYDEST) {
        DbgLog((LOG_TRACE, 1, TEXT("dwAlignBoundaryDest = %d"), m_DirectCaps.dwAlignBoundaryDest));
    } else {
        DbgLog((LOG_TRACE, 1, TEXT("No alignment restriction on BoundaryDest")));
    }

    // get the alignment restriction on src size
    if (m_DirectCaps.dwCaps & DDCAPS_ALIGNSIZESRC) {
        DbgLog((LOG_TRACE, 1, TEXT("dwAlignSizeSrc = %d"), m_DirectCaps.dwAlignSizeSrc));
    } else {
        DbgLog((LOG_TRACE, 1, TEXT("No alignment restriction on SizeSrc")));
    }

    // get the alignment restriction on dest size
    if (m_DirectCaps.dwCaps & DDCAPS_ALIGNSIZEDEST) {
        DbgLog((LOG_TRACE, 1, TEXT("dwAlignSizeDest = %d"), m_DirectCaps.dwAlignSizeDest));
    } else {
        DbgLog((LOG_TRACE, 1, TEXT("No alignment restriction on SizeDest")));
    }

    if (m_DirectCaps.dwMinOverlayStretch) {
        dwMinStretch = m_DirectCaps.dwMinOverlayStretch;
        DbgLog((LOG_TRACE, 1, TEXT("Min Stretch = %d"), dwMinStretch));
    }

    if (m_DirectCaps.dwMaxOverlayStretch) {
        dwMaxStretch = m_DirectCaps.dwMaxOverlayStretch;
        DbgLog((LOG_TRACE, 1, TEXT("Max Stretch = %d"), dwMaxStretch));
    }

    if ((m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSHRINKX)) {
        DbgLog((LOG_TRACE, 1, TEXT("Driver has DDFXCAPS_OVERLAYSHRINKX")));
    }

    if ((m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSHRINKXN)) {
        DbgLog((LOG_TRACE, 1, TEXT("Driver has DDFXCAPS_OVERLAYSHRINKXN")));
    }

    if ((m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSHRINKY)) {
        DbgLog((LOG_TRACE, 1, TEXT("Driver has DDFXCAPS_OVERLAYSHRINKY")));
    }

    if ((m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSHRINKYN)) {
        DbgLog((LOG_TRACE, 1, TEXT("Driver has DDFXCAPS_OVERLAYSHRINKYN")));
    }

    if ((m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSTRETCHX)) {
        DbgLog((LOG_TRACE, 1, TEXT("Driver has DDFXCAPS_OVERLAYSTRETCHX")));
    }

    if ((m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSTRETCHXN)) {
        DbgLog((LOG_TRACE, 1, TEXT("Driver has DDFXCAPS_OVERLAYSTRETCHXN")));
    }

    if ((m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSTRETCHY)) {
        DbgLog((LOG_TRACE, 1, TEXT("Driver has DDFXCAPS_OVERLAYSTRETCHY")));
    }

    if ((m_DirectCaps.dwFXCaps & DDFXCAPS_OVERLAYSTRETCHYN)) {
        DbgLog((LOG_TRACE, 1, TEXT("Driver has DDFXCAPS_OVERLAYSTRETCHYN")));
    }

    if ((m_DirectCaps.dwSVBFXCaps & DDFXCAPS_BLTARITHSTRETCHY)) {
        DbgLog((LOG_TRACE, 1, TEXT("Driver uses arithmetic operations to blt from system to video")));
    } else {
        DbgLog((LOG_TRACE, 1, TEXT("Driver uses pixel-doubling to blt from system to video")));
    }

    //
    // Items that we actually check for ...
    //
    if (m_DirectCaps.dwCaps2 & DDCAPS2_VIDEOPORT) {
        DbgLog((LOG_TRACE, 1, TEXT("Device does support a Video Port")));
    } else {
        DbgLog((LOG_TRACE, 1, TEXT("Device does not support a Video Port --> Failing connection")));
        hr = E_NOTIMPL;
    }

    if( m_dwKernelCaps & DDIRQ_VPORT0_VSYNC ) {
        DbgLog((LOG_TRACE, 1, TEXT("Driver support DDIRQ_VPORT0_VSYNC")));
    } else {
        DbgLog((LOG_TRACE, 1, TEXT("Driver does not support DDIRQ_VPORT0_VSYNC --> Failing VPM connection")));
        hr = E_NOTIMPL;
    }

    if( m_dwKernelCaps & DDKERNELCAPS_FIELDPOLARITY ) {
        DbgLog((LOG_TRACE, 1, TEXT("Driver support DDKERNELCAPS_FIELDPOLARITY")));
    } else {
        DbgLog((LOG_TRACE, 1, TEXT("Driver does not support DDKERNELCAPS_FIELDPOLARITY --> Failing VPM connection")));
        hr = E_NOTIMPL;
    }

    if( m_dwKernelCaps & DDKERNELCAPS_AUTOFLIP ) {
        DbgLog((LOG_TRACE, 1, TEXT("Driver support DDKERNELCAPS_AUTOFLIP")));
    } else {
        DbgLog((LOG_TRACE, 1, TEXT("Driver does not support DDKERNELCAPS_AUTOFLIP --> Failing VPM connection")));
        hr = E_NOTIMPL;
    }


    return hr;
}

//
//  Actually sets the variable & distributes it to the pins
//
HRESULT CVPMFilter::SetDirectDraw( LPDIRECTDRAW7 pDirectDraw )
{
    m_pDirectDraw = pDirectDraw;
    m_pPins->VBIInput.SetDirectDraw( m_pDirectDraw );
    return S_OK;
}

// this function is used to release the resources allocated by the function
// "InitDirectDraw". these include the direct-draw service provider and the
// Source surfaces
DWORD CVPMFilter::ReleaseDirectDraw()
{
    AMTRACE((TEXT("CVPMFilter::ReleaseDirectDraw")));
    DWORD dwRefCnt = 0;

    CAutoLock lFilter( &GetFilterLock() );

    // Release any DirectDraw provider interface
    DbgLog((LOG_TRACE, 1, TEXT("Release DDObj 0x%p\n"), m_pDirectDraw));
    if (m_pDirectDraw)
    {
        dwRefCnt = m_pDirectDraw->Release();
        SetDirectDraw( NULL );
    }

    ZeroStruct( m_DirectCaps );
    ZeroStruct( m_DirectSoftCaps );

    return dwRefCnt;
}

/******************************Public*Routine******************************\
* QueryDecimationUsage
*
*
*
* History:
* Wed 07/07/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVPMFilter::QueryDecimationUsage(
    DECIMATION_USAGE* lpUsage
    )
{
    if (lpUsage) {
        *lpUsage = m_dwDecimation;
        return S_OK;
    }
    return E_POINTER;
}


/******************************Public*Routine******************************\
* SetDecimationUsage
*
*
*
* History:
* Wed 07/07/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVPMFilter::SetDecimationUsage(
    DECIMATION_USAGE Usage
    )
{
    CAutoLock lFilter( &GetFilterLock() );

    switch (Usage) {
    case DECIMATION_LEGACY:
    case DECIMATION_USE_DECODER_ONLY:
    case DECIMATION_USE_OVERLAY_ONLY:
    case DECIMATION_DEFAULT:
        break;

    case DECIMATION_USE_VIDEOPORT_ONLY:
        // only allow this mode if we are actually using a video port
        break;

        // else fall thru

    default:
        return E_INVALIDARG;
    }
    DECIMATION_USAGE dwOldUsage = m_dwDecimation;
    m_dwDecimation = Usage;


    // if (dwOldUsage != m_dwDecimation) {
    //     EventNotify(GetPinCount(), EC_OVMIXER_REDRAW_ALL, 0, 0);
    // }

    return S_OK;
}


/******************************Public*Routine******************************\
* Set
*
* IKsPropertySet interface methods
*
* History:
* Mon 10/18/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVPMFilter::Set(
    REFGUID guidPropSet,
    DWORD dwPropID,
    LPVOID pInstanceData,
    DWORD cbInstanceData,
    LPVOID pPropData,
    DWORD cbPropData
    )
{
    AMTRACE((TEXT("CVPMFilter::Set")));

    return E_PROP_SET_UNSUPPORTED ;
}


/******************************Public*Routine******************************\
* Get
*
* IKsPropertySet interface methods
*
* History:
* Mon 10/18/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVPMFilter::Get(
    REFGUID guidPropSet,
    DWORD dwPropID,
    LPVOID pInstanceData,
    DWORD cbInstanceData,
    LPVOID pPropData,
    DWORD cbPropData,
    DWORD *pcbReturned
    )
{
    AMTRACE((TEXT("CVPMFilter::Get")));
    return E_NOTIMPL;
}


/******************************Public*Routine******************************\
* QuerySupported
*
* IKsPropertySet interface methods
*
* History:
* Mon 10/18/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVPMFilter::QuerySupported(
    REFGUID guidPropSet,
    DWORD dwPropID,
    DWORD *pTypeSupport
    )
{
    AMTRACE((TEXT("CVPMFilter::QuerySupported")));

    if (guidPropSet != AM_KSPROPSETID_FrameStep)
    {
        return E_PROP_SET_UNSUPPORTED;
    }

    if (dwPropID != AM_PROPERTY_FRAMESTEP_STEP &&
        dwPropID != AM_PROPERTY_FRAMESTEP_CANCEL)
    {
        return E_PROP_ID_UNSUPPORTED;
    }

    if (pTypeSupport)
    {
        *pTypeSupport = KSPROPERTY_SUPPORT_SET ;
    }

    return S_OK;
}

LPDIRECTDRAW7 CVPMFilter::GetDirectDraw()
{
    HRESULT hr;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMFilter::GetDirectDraw")));

    CAutoLock lReceive( &GetReceiveLock() );

    if (!m_pDirectDraw)
    {
        hr = InitDirectDraw(NULL);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("Function InitDirectDraw failed, hr = 0x%x"), hr));
        }
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMFilter::GetDirectDraw")));
    ASSERT(m_pDirectDraw);
    return m_pDirectDraw;
}

template< class T >
static bool CheckConnected( T& pPin, DWORD dwExcludePinId )
{
    return ( pPin.GetPinId() != dwExcludePinId) && pPin.IsConnected();
}

HRESULT CVPMFilter::ConfirmPreConnectionState(DWORD dwExcludePinId)
{
    HRESULT hr = NOERROR;
    DWORD i = 0;

    // is the input pin already connected?
    if( CheckConnected( m_pPins->VPInput, dwExcludePinId) )
    {
        hr = VFW_E_ALREADY_CONNECTED;
        DbgLog((LOG_ERROR, 1, TEXT("GetVPInput[i]->IsConnected() , i = %d, returning hr = 0x%x"), i, hr));
        goto CleanUp;
    }
    if( CheckConnected( m_pPins->VBIInput, dwExcludePinId) )
    {
        hr = VFW_E_ALREADY_CONNECTED;
        DbgLog((LOG_ERROR, 1, TEXT("GetVBIInputPin[i]->IsConnected() , i = %d, returning hr = 0x%x"), i, hr));
        goto CleanUp;
    }
    // is the output pin already connected?
    if( CheckConnected( m_pPins->Output, dwExcludePinId) )
    {
        hr = VFW_E_ALREADY_CONNECTED;
        DbgLog((LOG_ERROR, 1, TEXT("GetOutputPin.IsConnected() , returning hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

//
// used by the output pin to publish the input format
//
HRESULT CVPMFilter::CurrentInputMediaType(CMediaType *pmt)
{
    HRESULT hr;
    CAutoLock lFilter( &GetFilterLock() );
    hr = m_pPins->VPInput.CurrentMediaType(pmt);
    return hr;
}

HRESULT CVPMFilter::GetAllOutputFormats( const PixelFormatList** ppList )
{
    HRESULT hr;
    CAutoLock lFilter( &GetFilterLock() );
    hr = m_pPins->VPInput.GetAllOutputFormats( ppList );
    return hr;
}

HRESULT CVPMFilter::GetOutputFormat( DDPIXELFORMAT* pFormat )
{
    HRESULT hr;
    CAutoLock lFilter( &GetFilterLock() );
    hr = m_pPins->VPInput.GetOutputFormat( pFormat );
    return hr;
}

HRESULT CVPMFilter::ProcessNextSample( const DDVIDEOPORTNOTIFY& notify )
{
    AMTRACE((TEXT("CVPMFilter::ProcessNextSample")));
    CAutoLock lReceive( &GetReceiveLock() );

    VPInfo vpInfo = {0};
    HRESULT hr = m_pPins->VPInput.InPin_GetVPInfo( &vpInfo );
    ASSERT( SUCCEEDED(hr )); // can't fail

    bool fSkip = (vpInfo.vpInfo.dwVPFlags && DDVP_INTERLEAVE ) && (notify.lField == 0);
    if( !fSkip ) {

        // get a buffer
        LPDIRECTDRAWSURFACE7 pDestSurface;
        IMediaSample* pSample;

        // this will take care of getting the DDSurf7 (and possibly wrapping non DDSurf7)
        hr = m_pPins->Output.GetNextBuffer( &pDestSurface, &pSample );
        if( SUCCEEDED( hr )) {
            DWORD dwFlags;
            hr = m_pPins->VPInput.DoRenderSample( pSample, pDestSurface, notify, vpInfo );
            pDestSurface->Release();

            if( SUCCEEDED( hr )) {

                // send it
                hr = m_pPins->Output.SendSample( pSample );
                // tell the allocator that we're done with it
            }
            // otherwise we leak the sample if we can't restore the DDraw surface and run out of samples
            pSample->Release();
        }
    }
    return hr;
}

HRESULT CVPMFilter::CanColorConvertBlitToRGB( const DDPIXELFORMAT& ddFormat )
{
    if( m_pDirectDraw ) {
        if( m_DirectCaps.dwCaps & DDCAPS_BLTFOURCC ) {
            return S_OK;
        }

        // use m_DirectCaps, m_DirectSoftCaps
    }
    return E_FAIL;
}


#if 0
HRESULT CVPMFilter::CanStretch( const DDPIXELFORMAT& ddFormat )
{
    if( m_pDirectDraw ) {
        if( ddFormat.dwFourCC ) {
            if( m_DirectCaps.dwCaps2 & (DDCAPS2_COPYFOURCC )) {
                return S_OK;
            } else {
                return E_FAIL;
            }
        }
    }
    return S_OK;
}
#endif


STDMETHODIMP CVPMFilter::GetVideoPortIndex( DWORD* pdwIndex )
{
    AMTRACE((TEXT("CVPMFilter::GetVideoPortIndex")));
    CAutoLock lFilter( &GetFilterLock() );

    HRESULT hr = S_OK;
    if( !pdwIndex ) {
        return E_INVALIDARG;
    }
    *pdwIndex = m_dwVideoPortID;
    return hr;
}

STDMETHODIMP CVPMFilter::SetVideoPortIndex( DWORD dwIndex )
{
    HRESULT hr = NOERROR;
    AMTRACE((TEXT("CVPMFilter::SetVideoPortIndex")));

    CAutoLock lFilter( &GetFilterLock() );
    hr = m_pPins->VPInput.SetVideoPortID( dwIndex );
    if( SUCCEEDED( hr )) {
        hr = m_pPins->VBIInput.SetVideoPortID( dwIndex );

        // if the VP succeeds, there is no reason for the VBI to fail
        ASSERT( SUCCEEDED( hr ));

        if( SUCCEEDED( hr )) {
            m_dwVideoPortID = dwIndex;
        }
    }
    return hr;
}

HRESULT CVPMFilter::GetRefClockTime( REFERENCE_TIME* pNow )
{
    // Private method used by the input pin to determine the timestamp for
    // the next sample.  However, it has the receive lock.
    CAutoLock lFilter( &GetReceiveLock() );

    if( m_pClock ) {
        return m_pClock->GetTime( pNow );
    } else {
        return E_FAIL;
    }
}

HRESULT CVPMFilter::GetVPInfo( VPInfo* pVPInfo )
{
    CAutoLock lFilter( &GetFilterLock() );
    return m_pPins->VPInput.InPin_GetVPInfo( pVPInfo );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vpm\vpmoutpin.cpp ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <ddraw.h>
#include <VPManager.h>
#include <VPMPin.h>
#include <VPMUtil.h>

// VIDEOINFOHDR2
#include <dvdmedia.h>


static HRESULT GetSurfaceFromSample( LPDIRECTDRAWSURFACE7* ppDDSurf7, IMediaSample* pSample )
{
    AMTRACE((TEXT("GetSurfaceFromSample")));
    HRESULT hr = E_FAIL;
    {
        // make sure its a VMRSurfaceAlloc or a DirectDrawSurfaceAlloc for now
        IVMRSurface* pVMRSurf;
        hr = pSample->QueryInterface( IID_IVMRSurface, (VOID **) &pVMRSurf );
        if( SUCCEEDED( hr )) {
            // the AM_GBF_NODDSURFACELOCK flag avoids the need to lock the surface
            hr = pVMRSurf->GetSurface( ppDDSurf7 );
        }
        pVMRSurf->Release();
    }
#if 0
    // try direct draw sample alloc
    if( FAILED(hr)) {
        // make sure its a VMRSurfaceAlloc or a DirectDrawSurfaceAlloc for now
        IDirectDrawMediaSample* pDDSample;
        HRESULT hr = pSample->QueryInterface( IID_IDirectDrawMediaSample, (VOID **) &pDDSample );
        if( SUCCEEDED( hr )) {
            LPDIRECTDRAWSURFACE pDDSurf;
            hr = pDDSample->GetSurfaceAndReleaseLock( &pDDSurf, NULL );
            if( SUCCEEDED( hr )) {
                hr = pDDSurf->QueryInterface( IID_IDirectDrawSurface7, (VOID **) &ppDDSurf7 );
                pDDSurf->Release();
            }
            pDDSample->Release();
        }
    }
#endif
    if( FAILED(hr)) {
        // TBD: create a DDraw wrapper for the surface
        ASSERT(!"VPM: Can't handle non-DDraw sample from downstream filter");
    }
    return hr;
}

// constructor
CVPMOutputPin::CVPMOutputPin(TCHAR *pObjectName, CVPMFilter& pFilter,
                             HRESULT *phr, LPCWSTR pPinName, DWORD dwPinNo)
: CBaseOutputPin(pObjectName, &pFilter, &pFilter.GetFilterLock(), phr, pPinName)
, CVPMPin( dwPinNo, pFilter )
, m_pPosition( NULL )
{
    AMTRACE((TEXT("CVPMOutputPin::Constructor")));
    return;
}

// destructor
CVPMOutputPin::~CVPMOutputPin()
{
    AMTRACE((TEXT("CVPMOutputPin::Destructor")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());
    RELEASE( m_pPosition );
    return;
}

// overriden to expose IMediaPosition and IMediaSeeking control interfaces
STDMETHODIMP CVPMOutputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = NOERROR;



    if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking)
    {
        // we should have an input pin by now
        CAutoLock cLock(&m_pVPMFilter.GetFilterLock());
        if (m_pPosition == NULL)
        {
            hr = CreatePosPassThru(GetOwner(), FALSE, (IPin *)m_pVPMFilter.GetPin(0), &m_pPosition);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 1, TEXT("CreatePosPassThru failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
        }
        hr = m_pPosition->QueryInterface(riid, ppv);
        goto CleanUp;
    }

    // This gets annoying since IMediaSeeking is polled, so move below it
    {
        AMTRACE((TEXT("CVPMOutputPin::NonDelegatingQueryInterface")));
        DbgLog((LOG_TRACE, 5, TEXT("QI'ing CBaseOutputPin")));
        hr = CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 2, TEXT("CBaseOutputPin::NonDelegatingQueryInterface(riid) failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

CleanUp:
    return hr;
}

// check a given transform
HRESULT CVPMOutputPin::CheckMediaType(const CMediaType* pmt)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMOutputPin::CheckMediaType")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    // we only allow a VideoInfoHeader2 connections
    if( pmt->majortype != MEDIATYPE_Video ||
        !VPMUtil::GetVideoInfoHeader2( pmt ) )
    {
        hr = S_FALSE;
        goto CleanUp;
    }

    // Only accept VideoInfoHeader2 format types


    // tell the owning filter
    hr = m_pVPMFilter.CheckMediaType(m_dwPinId, pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 5, TEXT("m_pVPMFilter.CheckMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

enum ENUM_MEDIA_TYPE   {MT_RGB32, MT_RGB24, MT_RGB565, MT_RGB555,
                        MT_LAST };

HRESULT CVPMOutputPin::GetMediaType(int iPosition,CMediaType *pmt)
{
    AMTRACE((TEXT("CVPMOutputPin::GetMediaType")));

    //  Can't be < 0 - it's the base classes calling us
    ASSERT(iPosition >= 0);
    if (iPosition < 0) {
        return E_INVALIDARG;
    }

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());


    DDPIXELFORMAT ddOutputVideoFormat;
    HRESULT hr = m_pVPMFilter.GetOutputFormat( &ddOutputVideoFormat );
    if( FAILED( hr )) {
        // when input pin is not connected, it returns VFW_E_NOT_CONNECTED
        return hr;
    }

    // limit scope of cmt & associated pointers to it
    {
        CMediaType cmt;
        hr = m_pVPMFilter.CurrentInputMediaType( &cmt );
        if( FAILED( hr )) {
            return hr;
        }
        VIDEOINFOHEADER2 *pVideoInfoHeader2;
        if (*cmt.Type() != MEDIATYPE_Video) {
            ASSERT( !"none video type from VPE" );
            pVideoInfoHeader2 = VPMUtil::SetToVideoInfoHeader2( &cmt, sizeof(TRUECOLORINFO) );
            if (pVideoInfoHeader2 == NULL) {
                return E_OUTOFMEMORY;
            }
        } else {
            pVideoInfoHeader2 = VPMUtil::GetVideoInfoHeader2( &cmt );
        }

        // only support the connected VPE format, ignore the lists
        // match the VPE pin for now
        BITMAPINFOHEADER *pHeader = VPMUtil::GetbmiHeader( &cmt );

        if ( ! pHeader )
        {
            return E_FAIL;
        }

        const DDPIXELFORMAT& ddFormat = ddOutputVideoFormat; // (*pddAllOutputVideoFormats)[iPosition];

        DWORD dwFourCC = ddFormat.dwFourCC;

        switch( dwFourCC ) {
            case mmioFOURCC('Y','V','1','2'):
            case mmioFOURCC('Y','U','Y','2'):
            case mmioFOURCC('U','Y','V','Y'):
                pHeader->biBitCount  = (USHORT) ddFormat.dwYUVBitCount;
                break;

            default:
            pHeader->biBitCount = (USHORT) ddFormat.dwRGBBitCount;
            break;
        }
        // map the FourCC code into a guid
        FOURCCMap guid( dwFourCC );
        cmt.SetSubtype(&guid);
        pHeader->biCompression = dwFourCC;

        *pmt = cmt;
        if (pmt->pbFormat == NULL) {
                return E_OUTOFMEMORY;
        }
    }

    // get mode info so we know how many interlace formats to propose
    VPInfo vpInfo;
    hr = m_pVPMFilter.GetVPInfo( &vpInfo );

    VIDEOINFOHEADER2 *pVideoInfoHeader2 = VPMUtil::GetVideoInfoHeader2( pmt );
    pVideoInfoHeader2->dwInterlaceFlags = 0;

    // TBD: we should query the video port for a list of available modes
    //          and set it using the mode.  Right now we'll assume the hardware
    //         can support the videoport's output.
    //
    DWORD dwNumFormats = 1;

    if( iPosition >= (int) dwNumFormats ) {
        return VFW_S_NO_MORE_ITEMS;
    }

    if( SUCCEEDED( hr )) {
        pVideoInfoHeader2->dwPictAspectRatioX = vpInfo.vpDataInfo.dwPictAspectRatioX;
        pVideoInfoHeader2->dwPictAspectRatioY = vpInfo.vpDataInfo.dwPictAspectRatioY;

        switch( vpInfo.mode ) {
            case AMVP_MODE_BOBNONINTERLEAVED:
                pVideoInfoHeader2->dwInterlaceFlags = AMINTERLACE_IsInterlaced | AMINTERLACE_1FieldPerSample | AMINTERLACE_DisplayModeBobOnly;
                break;
            case AMVP_MODE_BOBINTERLEAVED:
                pVideoInfoHeader2->dwInterlaceFlags = AMINTERLACE_IsInterlaced | AMINTERLACE_DisplayModeBobOnly;
                pVideoInfoHeader2->bmiHeader.biHeight *= 2;
                break;
            case AMVP_MODE_WEAVE:
                pVideoInfoHeader2->dwInterlaceFlags = AMINTERLACE_IsInterlaced | AMINTERLACE_FieldPatBothRegular | AMINTERLACE_DisplayModeWeaveOnly;
                pVideoInfoHeader2->bmiHeader.biHeight *= 2;
                break;
            case AMVP_MODE_SKIPEVEN:
                pVideoInfoHeader2->dwInterlaceFlags = AMINTERLACE_1FieldPerSample | AMINTERLACE_FieldPatField1Only;
                break;
            case AMVP_MODE_SKIPODD:
                pVideoInfoHeader2->dwInterlaceFlags = AMINTERLACE_1FieldPerSample | AMINTERLACE_FieldPatField2Only;
                break;
            default:
                ASSERT( !"VPM in an invalid state" );
                pVideoInfoHeader2->dwInterlaceFlags = 0;
                break;
        }
        // AMINTERLACE_Field1First             0x00000004  // else Field 2 is first;  top field in PAL is field 1, top field in NTSC is field 2?
        if( vpInfo.vpDataInfo.bFieldPolarityInverted ) {            // Device inverts the polarity by default
            pVideoInfoHeader2->dwInterlaceFlags |= AMINTERLACE_Field1First;
        }
    } else {
        pVideoInfoHeader2->dwPictAspectRatioX = 1; // (DWORD)(pVideoInfoHeader22->bmiHeader.biWidth * m_seqInfo.lYPelsPerMeter);
        pVideoInfoHeader2->dwPictAspectRatioY = 1; // (DWORD)(pVideoInfoHeader22->bmiHeader.biHeight * m_seqInfo.lXPelsPerMeter);
    }
    return hr;
}

// called after we have agreed a media type to actually set it
HRESULT CVPMOutputPin::SetMediaType(const CMediaType* pmt)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMOutputPin::SetMediaType")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    // make sure the mediatype is correct
    hr = CheckMediaType(pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CheckMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // Set the base class media type (should always succeed)

    // Sets m_mt = *pmt;

    hr = CBaseOutputPin::SetMediaType(pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseOutputPin::SetMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // tell the owning filter
    hr = m_pVPMFilter.SetMediaType(m_dwPinId, pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pVPMFilter.SetMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

// Complete Connect
HRESULT CVPMOutputPin::CompleteConnect(IPin *pReceivePin)
{
    HRESULT hr = NOERROR;
    DWORD dwAdvise = 0, dwInputPinCount = 0, i = 0;
    DDSURFACEDESC SurfaceDescP;
    CVPMInputPin *pInputPin = NULL;
    BOOL bDoDeletePrimSurface = TRUE;

    AMTRACE((TEXT("CVPMOutputPin::CompleteConnect")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    // call the base class
    hr = CBaseOutputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseOutputPin::CompleteConnect failed, hr = 0x%x"),
            hr));
        goto CleanUp;
    }

    ASSERT(m_pAllocator);

    // tell the owning filter
    hr = m_pVPMFilter.CompleteConnect(m_dwPinId);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pVPMFilter.CompleteConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

HRESULT CVPMOutputPin::BreakConnect()
{
    HRESULT hr = NOERROR;
    DWORD dwInputPinCount = 0, i = 0;
    CVPMInputPin *pInputPin;

    AMTRACE((TEXT("CVPMOutputPin::BreakConnect")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    // call the base class
    hr = CBaseOutputPin::BreakConnect();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseOutputPin::BreakConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // tell the owning filter
    hr = m_pVPMFilter.BreakConnect(m_dwPinId);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pVPMFilter.BreakConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

HRESULT CVPMOutputPin::CheckConnect(IPin* pPin)
{
    AMTRACE((TEXT("CVPMOutputPin::CheckConnect")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    HRESULT hr = CBaseOutputPin::CheckConnect( pPin );
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseOutputPin::CheckConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

STDMETHODIMP CVPMOutputPin::Notify(IBaseFilter * pSender, Quality q)
{
    return S_OK;
}



HRESULT CVPMOutputPin::GetNextBuffer( LPDIRECTDRAWSURFACE7* ppSurface, IMediaSample** ppSample )
{
    AMTRACE((TEXT("CVPMOutputPin::GetNextBuffer")));

    CAutoLock cLock(&m_pVPMFilter.GetReceiveLock());
    HRESULT hr = E_FAIL;

    if( m_pAllocator ) {
        hr = m_pAllocator->GetBuffer( ppSample, NULL, NULL, AM_GBF_NODDSURFACELOCK );
        if( SUCCEEDED( hr )) {
            // now see if we can get the surface
            hr = GetSurfaceFromSample( ppSurface, *ppSample );
        }
    }
    return hr;
}

HRESULT CVPMOutputPin::SendSample( IMediaSample* pSample )
{
    AMTRACE((TEXT("CVPMOutputPin::SendSample")));

    // DbgLog((LOG_TRACE, 1, TEXT("CVPMOutputPin::SendSample %x%x"), DWORD( rtStart>>32), DWORD(rtStart) ));

    CAutoLock cLock(&m_pVPMFilter.GetReceiveLock());
    HRESULT hr = E_FAIL;

    if( m_pInputPin ) {
        hr = m_pInputPin->Receive( pSample );
    }
    return hr;
}

// we don't have an allocator, so fail any connections that don't supply one for us
// (we don't want the default one for now);
HRESULT CVPMOutputPin::InitAllocator(IMemAllocator **ppAlloc)
{
    return E_FAIL;
}

HRESULT CVPMOutputPin::DecideBufferSize(IMemAllocator * pAllocator,
                             ALLOCATOR_PROPERTIES *pRequestedProperties)
{
    AMTRACE((TEXT("CVPMOutputPin::DecideBufferSize")));
    // set the size of buffers based on the expected output frame size, and
    // the count of buffers to 1.

    pRequestedProperties->cBuffers = 1;
    pRequestedProperties->cbBuffer = m_mt.GetSampleSize();

    ASSERT(pRequestedProperties->cbBuffer > 0);

    ALLOCATOR_PROPERTIES propActual;
    HRESULT hr = pAllocator->SetProperties(pRequestedProperties, &propActual );
    if (FAILED(hr)) {
        return hr;
    }

    // if (propActual.cbBuffer < (LONG)m_pOutput->CurrentMediaType().GetSampleSize()) {
    //     // can't use this allocator
    //     return E_INVALIDARG;
    // }

    //  We don't really mind if we get > 1 buffer because we always
    //  blt the entire image

    return S_OK;
}

static bool IsVMR( IMemInputPin *pMemPin )
{
    IPin* pPin;
    HRESULT hr = pMemPin->QueryInterface( IID_IPin, (LPVOID*) &pPin );
    if( SUCCEEDED(hr )) {
        PIN_INFO PinInfo;
        hr = pPin->QueryPinInfo(&PinInfo);
        if (SUCCEEDED(hr)) {
            IVMRFilterConfig* pVMRFilterConfig = NULL;

            hr = PinInfo.pFilter->QueryInterface(IID_IVMRFilterConfig, (LPVOID*)&pVMRFilterConfig);
            PinInfo.pFilter->Release();
            if( SUCCEEDED( hr )) {
                pVMRFilterConfig->Release();
            }
        }
        pPin->Release();
    }
    return SUCCEEDED( hr );
}

HRESULT CVPMOutputPin::DecideAllocator(
    IMemInputPin *pPin,
    IMemAllocator **ppAlloc
)
{
    HRESULT hr = NOERROR;

    // make sure downstream filter support IVPMAlloc
    if( IsVMR( pPin ) )
    {
        return CBaseOutputPin::DecideAllocator( pPin, ppAlloc );
    } else {
        return E_FAIL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vpm\vpminpin.cpp ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <ddraw.h>
#include <VPManager.h>
#include "VPMPin.h"
#include <VPMUtil.h>
#include <ddkernel.h>

#include <ksmedia.h>


// IVideoPortControl
#include <VPObj.h>

// AMINTERLACE_*
#include <dvdmedia.h>
#include "DRect.h"

extern "C"
const TCHAR szPropPage[] = TEXT("Property Pages");

//
//   Flipping surface implementation
//
//   To allow decoders to hold on to surfaces for out of order decode
//   we flip directly to the surface pass on Receive rather than
//   use the default NULL target surface for Flip().
//
//   This works in the following way
//
//   The COMPinputPin::m_pDirectDrawSurface points to the FRONT buffer
//
//   When Receive is called we Flip() the front buffer and because we
//   do an explicit Flip() DirectDraw swaps the memory pointers for the
//   current Front buffer and the surface passed in which is then attached
//   to the front buffer.
//
//   The received buffer is then put at the back of the queue so (correctly)
//   the previous front buffer is now at the back of the queue to be handed
//   to the application
//
//   The allocator actually has one more buffer than was actually requested
//   so the previous front buffer won't actually be requested until the next
//   Receive and hence the previous Flip() has time to complete.
//

//  Video accelerator disable interface


//
/////////////////////////////////////
// CLASS CVPMInputPin implemented here
/////////////////////////////////////

// constructor
CVPMInputPin::CVPMInputPin( TCHAR *pObjectName,
                           CVPMFilter& pFilter,
                           HRESULT *phr,
                           LPCWSTR pPinName,
                           DWORD dwPinNo)
: CBaseInputPin(pObjectName, &pFilter, &pFilter.GetFilterLock(), phr, pPinName)
, CVPMPin( dwPinNo, pFilter )
, m_cOurRef( 0 )
, m_pIVPObject( NULL )
, m_pIVPInfo(NULL)
, m_CategoryGUID( GUID_NULL )
, m_Communication( KSPIN_COMMUNICATION_SOURCE )
, m_bStreamingInKernelMode( FALSE )
, m_dwBackBufferCount( 0 )
, m_dwDirectDrawSurfaceWidth( 0 )
, m_dwMinCKStretchFactor( 0 )
, m_bSyncOnFill( FALSE )
, m_bDontFlip( FALSE  )
, m_bDynamicFormatNeeded( TRUE )
, m_bNewPaletteSet( TRUE )
, m_dwInterlaceFlags( 0 )
, m_dwFlipFlag( 0 )
, m_bConnected( FALSE )
, m_bUsingOurAllocator( FALSE )
, m_hMemoryDC( NULL )
, m_bCanOverAllocateBuffers( TRUE )
, m_hEndOfStream( NULL )
, m_bDecimating( FALSE )
, m_lWidth( 0L )
, m_lHeight( 0L )
, m_bRuntimeNegotiationFailed( FALSE)

, m_dwUpdateOverlayFlags( 0 )
, m_dwFlipFlag2( 0 )
, m_trLastFrame( 0 )
, m_lSrcWidth( 0 )
, m_lSrcHeight( 0 )

, m_rtNextSample( 0 )
, m_rtLastRun( 0 )
{
    AMTRACE((TEXT("CVPMInputPin::Constructor")));

    memset( &m_WinInfo, 0, sizeof(m_WinInfo) );
    m_bWinInfoSet = false;

    *phr = S_OK;
    m_Medium.Set = GUID_NULL;
    m_Medium.Id = 0;
    m_Medium.Flags = 0;

    HRESULT hr = NOERROR;
    LPUNKNOWN pUnkOuter;

    SetReconnectWhenActive(true);

#ifdef PERF
    m_PerfFrameFlipped = MSR_REGISTER(TEXT("Frame Drawn"));
#endif

    // See combase.cpp(107) for comments on this
    IUnknown* pThisUnknown = reinterpret_cast<LPUNKNOWN>( static_cast<PNDUNKNOWN>(this) );

    m_pVideoPortObject = new CVideoPortObj( pThisUnknown, phr, this );

    // alias pointer to interfaces (instead of QI'ing)
    m_pIVPObject = m_pVideoPortObject;
    m_pIVPInfo = m_pVideoPortObject;

    hr = m_pIVPObject->SetObjectLock( &m_pVPMFilter.GetFilterLock() );
    if (FAILED(hr))
    {
        *phr = hr;
    }
    return;
}

// destructor
CVPMInputPin::~CVPMInputPin(void)
{
    AMTRACE((TEXT("CVPMInputPin::Destructor")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    // delete the inner object
    delete m_pVideoPortObject;
	m_pVideoPortObject = NULL;
}

// overriden to expose IMediaPosition and IMediaSeeking control interfaces
STDMETHODIMP CVPMInputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::NonDelegatingQueryInterface")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    if (riid == IID_IVPNotify ) {
        hr = GetInterface( static_cast<IVPNotify*>(m_pVideoPortObject), ppv);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPUnknown->QueryInterface failed, hr = 0x%x"), hr));
        }
    } else if (riid == IID_IVPNotify2 ) { 
        hr = GetInterface( static_cast<IVPNotify2*>(m_pVideoPortObject), ppv);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPUnknown->QueryInterface failed, hr = 0x%x"), hr));
        }
    } else if (riid == IID_IKsPin) {
        hr = GetInterface(static_cast<IKsPin *>(this), ppv);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 2, TEXT("GetInterface(IKsPin*) failed, hr = 0x%x"), hr));
        }
    } else if (riid == IID_IKsPropertySet) {
        hr = GetInterface(static_cast<IKsPropertySet *>(this), ppv);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 2, TEXT("GetInterface(IKsPropertySet*) failed, hr = 0x%x"), hr));
        }
    } else if (riid == IID_IPinConnection) {
        hr = GetInterface(static_cast<IPinConnection*>(this), ppv);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 2, TEXT("GetInterface(IPinConnection, ppv) failed, hr = 0x%x"), hr));
        }
    } else if (riid == IID_ISpecifyPropertyPages&& 0 != VPMUtil::GetPropPagesRegistryDword( 0)) {
        return GetInterface(static_cast<ISpecifyPropertyPages *>(this), ppv);
    } else {
        // call the base class
        hr = CBaseInputPin::NonDelegatingQueryInterface(riid, ppv);
        if (FAILED(hr)) {
            DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::NonDelegatingQueryInterface failed, hr = 0x%x"), hr));
        }
    }
    return hr;
}

//
// NonDelegatingAddRef/NonDelegatingRelease
//
//
STDMETHODIMP_(ULONG) CVPMInputPin::NonDelegatingAddRef(void)
{
    return m_pVPMFilter.AddRef();
} // NonDelegatingAddRef


STDMETHODIMP_(ULONG) CVPMInputPin::NonDelegatingRelease(void)
{
    return m_pVPMFilter.Release();
}


// --- ISpecifyPropertyPages ---

STDMETHODIMP CVPMInputPin::GetPages(CAUUID *pPages)
{
#if 0
    pPages->cElems = 1;
    pPages->pElems = (GUID *) CoTaskMemAlloc(sizeof(GUID)*1);
    if (pPages->pElems == NULL) {
        return E_OUTOFMEMORY;
    }
    pPages->pElems[0] = CLSID_COMPinConfigProperties;

    return NOERROR;
#else
    return E_NOTIMPL;
#endif
}


// this function just tells whether each sample consists of one or two fields
BOOL DisplayingFields(DWORD dwInterlaceFlags)
{
   if ((dwInterlaceFlags & AMINTERLACE_IsInterlaced) &&
        (dwInterlaceFlags & AMINTERLACE_1FieldPerSample))
        return TRUE;
    else
        return FALSE;
}


BOOL CheckTypeSpecificFlags(DWORD dwInterlaceFlags, DWORD dwTypeSpecificFlags)
{
    // first determine which field do we want to display here
    if ((dwInterlaceFlags & AMINTERLACE_1FieldPerSample) &&
        ((dwTypeSpecificFlags & AM_VIDEO_FLAG_FIELD_MASK) == AM_VIDEO_FLAG_INTERLEAVED_FRAME))
    {
        return FALSE;
    }

    if ((!(dwInterlaceFlags & AMINTERLACE_1FieldPerSample)) &&
        (((dwTypeSpecificFlags & AM_VIDEO_FLAG_FIELD_MASK) == AM_VIDEO_FLAG_FIELD1) ||
           ((dwTypeSpecificFlags & AM_VIDEO_FLAG_FIELD_MASK) == AM_VIDEO_FLAG_FIELD2)))
    {
        return FALSE;
    }

    if (dwTypeSpecificFlags & AM_VIDEO_FLAG_REPEAT_FIELD)
    {
        return FALSE;
    }

    return TRUE;
}

// given the interlace flags and the type-specific flags, this function determines whether we
// are supposed to display the sample in bob-mode or not. It also tells us, which direct-draw flag
// are we supposed to use when flipping. When displaying an interleaved frame, it assumes we are
// talking about the field which is supposed to be displayed first.
BOOL NeedToFlipOddEven(DWORD dwInterlaceFlags, DWORD dwTypeSpecificFlags, DWORD *pdwFlipFlag)
{
    BOOL bDisplayField1 = TRUE;
    BOOL bField1IsOdd = TRUE;
    BOOL bNeedToFlipOddEven = FALSE;
    DWORD dwFlipFlag = 0;

    // if not interlaced content, mode is not bob
    if (!(dwInterlaceFlags & AMINTERLACE_IsInterlaced))
    {
        bNeedToFlipOddEven = FALSE;
        goto CleanUp;
    }

    // if sample have a single field, then check the field pattern
    if ((dwInterlaceFlags & AMINTERLACE_1FieldPerSample) &&
        (((dwInterlaceFlags & AMINTERLACE_FieldPatternMask) == AMINTERLACE_FieldPatField1Only) ||
         ((dwInterlaceFlags & AMINTERLACE_FieldPatternMask) == AMINTERLACE_FieldPatField2Only)))
    {
        bNeedToFlipOddEven = FALSE;
        goto CleanUp;
    }

    if (((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) == AMINTERLACE_DisplayModeBobOnly) ||
        (((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) == AMINTERLACE_DisplayModeBobOrWeave) &&
         (!(dwTypeSpecificFlags & AM_VIDEO_FLAG_WEAVE))))
    {
        // first determine which field do we want to display here
        if (dwInterlaceFlags & AMINTERLACE_1FieldPerSample)
        {
            // if we are in 1FieldPerSample mode, check which field is it
            ASSERT(((dwTypeSpecificFlags & AM_VIDEO_FLAG_FIELD_MASK) == AM_VIDEO_FLAG_FIELD1) ||
                ((dwTypeSpecificFlags & AM_VIDEO_FLAG_FIELD_MASK) == AM_VIDEO_FLAG_FIELD2));
            bDisplayField1 = ((dwTypeSpecificFlags & AM_VIDEO_FLAG_FIELD_MASK) == AM_VIDEO_FLAG_FIELD1);
        }
        else
        {
            // ok the sample is an interleaved frame
            ASSERT((dwTypeSpecificFlags & AM_VIDEO_FLAG_FIELD_MASK) == AM_VIDEO_FLAG_INTERLEAVED_FRAME);
            bDisplayField1 = (dwTypeSpecificFlags & AM_VIDEO_FLAG_FIELD1FIRST);
        }

        bField1IsOdd = (dwInterlaceFlags & AMINTERLACE_Field1First);

        // if we displaying field 1 and field 1 is odd or we are displaying field2 and field 2 is odd
        // then use DDFLIP_ODD. Exactly the opposite for DDFLIP_EVEN
        if ((bDisplayField1 && bField1IsOdd) || (!bDisplayField1 && !bField1IsOdd))
            dwFlipFlag = DDFLIP_ODD;
        else
            dwFlipFlag = DDFLIP_EVEN;

        bNeedToFlipOddEven = TRUE;
        goto CleanUp;
    }

CleanUp:
    if (pdwFlipFlag)
        *pdwFlipFlag = dwFlipFlag;
    return bNeedToFlipOddEven;
}

// given the interlace flags and the type-specific flags, this function determines whether we
// are supposed to display the sample in bob-mode or not. It also tells us, which direct-draw flag
// are we supposed to use when flipping. When displaying an interleaved frame, it assumes we are
// talking about the field which is supposed to be displayed first.
DWORD GetUpdateOverlayFlags(DWORD dwInterlaceFlags, DWORD dwTypeSpecificFlags)
{
    DWORD dwFlags = DDOVER_SHOW | DDOVER_KEYDEST;
    DWORD dwFlipFlag;

    if (NeedToFlipOddEven(dwInterlaceFlags, dwTypeSpecificFlags, &dwFlipFlag))
    {
        dwFlags |= DDOVER_BOB;
        if (!DisplayingFields(dwInterlaceFlags))
            dwFlags |= DDOVER_INTERLEAVED;
    }
    return dwFlags;
}

// this function checks if the InterlaceFlags are suitable or not
HRESULT CVPMInputPin::CheckInterlaceFlags(DWORD dwInterlaceFlags)
{
    HRESULT hr = NOERROR;


    AMTRACE((TEXT("CVPMInputPin::CheckInterlaceFlags")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    if (dwInterlaceFlags & AMINTERLACE_UNUSED)
    {
        hr = VFW_E_TYPE_NOT_ACCEPTED;
        goto CleanUp;
    }

    // check that the display mode is one of the three allowed values
    if (((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) != AMINTERLACE_DisplayModeBobOnly) &&
        ((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) != AMINTERLACE_DisplayModeWeaveOnly) &&
        ((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) != AMINTERLACE_DisplayModeBobOrWeave))
    {
        hr = VFW_E_TYPE_NOT_ACCEPTED;
        goto CleanUp;
    }

    // if content is not interlaced, other bits are irrelavant, so we are done
    if (!(dwInterlaceFlags & AMINTERLACE_IsInterlaced))
    {
        goto CleanUp;
    }

    // samples are frames, not fields (so we can handle any display mode)
    if (!(dwInterlaceFlags & AMINTERLACE_1FieldPerSample))
    {
        goto CleanUp;
    }

    // can handle a stream of just field1 or field2, whatever the display mode
    if (((dwInterlaceFlags & AMINTERLACE_FieldPatternMask) == AMINTERLACE_FieldPatField1Only) ||
        ((dwInterlaceFlags & AMINTERLACE_FieldPatternMask) == AMINTERLACE_FieldPatField2Only))
    {
        goto CleanUp;
    }

    // can handle only bob-mode for field samples
    if ((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) == AMINTERLACE_DisplayModeBobOnly)
    {
        goto CleanUp;
    }

    // cannot handle only Weave mode or BobOrWeave mode for field samples
    if (((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) == AMINTERLACE_DisplayModeWeaveOnly) ||
         ((dwInterlaceFlags & AMINTERLACE_DisplayModeMask) == AMINTERLACE_DisplayModeBobOrWeave))
    {
        hr = VFW_E_TYPE_NOT_ACCEPTED;
        goto CleanUp;
    }

    // we should have covered all possible scenarios by now, so assert here
    ASSERT(1);

CleanUp:

    // we cannot handle bob mode with an offscreen surface or if the driver can't support it
    if (SUCCEEDED(hr))
    {
        const DDCAPS* pDirectCaps = m_pVPMFilter.GetHardwareCaps();
        if ( pDirectCaps )
        {
            // call NeedToFlipOddEven with dwTypeSpecificFlags=0, to pretend that the
            // type-specific-flags is asking us to do bob-mode.
            bool bCanBob = false;
            if ( !bCanBob && NeedToFlipOddEven(dwInterlaceFlags, 0, NULL)  )
            {
                hr = VFW_E_TYPE_NOT_ACCEPTED;
            }
        }
    }
    return hr;
}

// this function check if the mediatype on a dynamic format change is suitable.
// No lock is taken here. It is the callee's responsibility to maintain integrity!
HRESULT CVPMInputPin::DynamicCheckMediaType(const CMediaType* pmt)
{
    HRESULT hr = VFW_E_TYPE_NOT_ACCEPTED;
    DWORD dwOldInterlaceFlags = 0, dwNewInterlaceFlags = 0, dwCompareSize = 0;
    BOOL bOld1FieldPerSample = FALSE, bNew1FieldPerSample = FALSE;
    BOOL b1, b2;

    AMTRACE((TEXT("CVPMInputPin::DynamicCheckMediaType")));

    // majortype and SubType are not allowed to change dynamically,
    // format type can change.
    CMediaType mtNew;
    hr = m_pIVPObject->CurrentMediaType( &mtNew );

    if (FAILED(hr) ||
	NULL == pmt ||
        (!(IsEqualGUID(pmt->majortype, mtNew.majortype))) ||
        (!(IsEqualGUID(pmt->subtype, mtNew.subtype))))
    {
        goto CleanUp;
    }

    // get the interlace flags of the new mediatype
    hr = VPMUtil::GetInterlaceFlagsFromMediaType( *pmt, &dwNewInterlaceFlags);
    if (FAILED(hr))
    {
        goto CleanUp;
    }

    // get the interlace flags of the new mediatype
    hr = VPMUtil::GetInterlaceFlagsFromMediaType( mtNew, &dwOldInterlaceFlags);
    if (FAILED(hr))
    {
        goto CleanUp;
    }

    //
    // There are several bugs in the following code !!
    // We goto CleanUp but hr has not been updated with a valid error code!!
    //

    bOld1FieldPerSample = (dwOldInterlaceFlags & AMINTERLACE_IsInterlaced) &&
        (dwOldInterlaceFlags & AMINTERLACE_1FieldPerSample);
    bNew1FieldPerSample = (dwNewInterlaceFlags & AMINTERLACE_IsInterlaced) &&
        (dwNewInterlaceFlags & AMINTERLACE_1FieldPerSample);


    // we do not allow dynamic format changes where you go from 1FieldsPerSample to
    // 2FieldsPerSample or vica-versa since that means reallocating the surfaces.
    if (bNew1FieldPerSample != bOld1FieldPerSample)
    {
        goto CleanUp;
    }

    const BITMAPINFOHEADER* pNewHeader = VPMUtil::GetbmiHeader(pmt);
    if (!pNewHeader)
    {
        goto CleanUp;
    }

    const BITMAPINFOHEADER* pOldHeader = VPMUtil::GetbmiHeader(&mtNew);
    if (!pNewHeader)
    {
        goto CleanUp;
    }

    dwCompareSize = FIELD_OFFSET(BITMAPINFOHEADER, biClrUsed);
    ASSERT(dwCompareSize < sizeof(BITMAPINFOHEADER));

    if (memcmp(pNewHeader, pOldHeader, dwCompareSize) != 0)
    {
        goto CleanUp;
    }

    hr = NOERROR;

CleanUp:
    // CVPMInputPin::DynamicCheckMediaType")));
    return hr;
}


// check that the mediatype is acceptable. No lock is taken here. It is the callee's
// responsibility to maintain integrity!
HRESULT CVPMInputPin::CheckMediaType(const CMediaType* pmt)
{
    AMTRACE((TEXT("CVPMInputPin::CheckMediaType")));

    // check if the VP component likes this mediatype
    // check if the videoport object likes it
    HRESULT hr = m_pIVPObject->CheckMediaType(pmt);
    if (FAILED(hr)) {
        DbgLog((LOG_ERROR, 2, TEXT("m_pIVPObject->CheckMediaType failed, hr = 0x%x"), hr));
        ASSERT( hr == VFW_E_TYPE_NOT_ACCEPTED ); // can't fail with anything else
    } else {
        DbgLog((LOG_TRACE, 2, TEXT("m_pIVPObject->CheckMediaType succeeded, bAcceptableVPMediatype is TRUE")));
    }
    return hr;
}

// called after we have agreed a media type to actually set it
HRESULT CVPMInputPin::SetMediaType(const CMediaType* pmt)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::SetMediaType")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    // make sure the mediatype is correct
    hr = CheckMediaType(pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CheckMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    const BITMAPINFOHEADER *pHeader = VPMUtil::GetbmiHeader(pmt);
    if (pHeader)
    {
        // store the interlace flags since we use them again and again
        hr = VPMUtil::GetInterlaceFlagsFromMediaType( *pmt, &m_dwInterlaceFlags);
        ASSERT(SUCCEEDED(hr));

        // store the update overlay flags (give the type specific flag is WEAVE so that for BOB or WEAVE
        // mode, we not bob
        m_dwUpdateOverlayFlags = GetUpdateOverlayFlags(m_dwInterlaceFlags, AM_VIDEO_FLAG_WEAVE);
    }

    // Set the base class media type (should always succeed)
    hr = CBaseInputPin::SetMediaType(pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::SetMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    hr = m_pIVPObject->CheckMediaType(pmt);
    if (SUCCEEDED(hr))
    {
        m_pVPMFilter.SetDecimationUsage(DECIMATION_LEGACY);
        hr = m_pIVPObject->SetMediaType(pmt);
        ASSERT(SUCCEEDED(hr));
    }
   
    // tell the proxy not to allocate buffers if it is a videoport or overlay connection
    SetStreamingInKernelMode(TRUE);

    // tell the owning filter
    hr = m_pVPMFilter.SetMediaType(m_dwPinId, pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pVPMFilter.SetMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }



CleanUp:
    return hr;
}


HRESULT CVPMInputPin::CurrentMediaType(CMediaType *pmt)
{
    ValidateReadWritePtr(pmt,sizeof(AM_MEDIA_TYPE));
    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    /*  Copy constructor of m_mt allocates the memory */
    if (IsConnected())
    {
        if( m_pIVPObject ) {
            return m_pIVPObject->CurrentMediaType( pmt );
        } else {
            // shouldn't happen, we alloc this in our constructor
            pmt->InitMediaType();
            return E_FAIL;
        }
    } else {
        pmt->InitMediaType();
        return VFW_E_NOT_CONNECTED;
    }
}

#ifdef DEBUG
/*****************************Private*Routine******************************\
* VideoFormat2String
*
* Converts a video format block to a string - useful for debugging
*
* History:
* Tue 12/07/1999 - StEstrop - Created
*
\**************************************************************************/
void VideoFormat2String(
    LPTSTR szBuffer,
    const GUID* pFormatType,
    BYTE* pFormat,
    ULONG lFormatLength
    )
{
    if (!pFormat) {
        lstrcpy(szBuffer, TEXT("No format data specified"));
        return;
    }

    //
    // Video Format
    //
    if (IsEqualGUID(*pFormatType, FORMAT_VideoInfo) ||
        IsEqualGUID(*pFormatType, FORMAT_MPEGVideo)) {

        VIDEOINFO * pVideoFormat = (VIDEOINFO *) pFormat;

        wsprintf(szBuffer, TEXT("%4.4hs %dx%d, %d bits"),
                 (pVideoFormat->bmiHeader.biCompression == 0) ? "RGB " :
                 ((pVideoFormat->bmiHeader.biCompression == BI_BITFIELDS) ? "BITF" :
                 (LPSTR) &pVideoFormat->bmiHeader.biCompression),
                 pVideoFormat->bmiHeader.biWidth,
                 pVideoFormat->bmiHeader.biHeight,
                 pVideoFormat->bmiHeader.biBitCount);
    }
    else if (IsEqualGUID(*pFormatType, FORMAT_VideoInfo2) ||
             IsEqualGUID(*pFormatType, FORMAT_MPEG2Video)) {

        VIDEOINFOHEADER2 * pVideoFormat = (VIDEOINFOHEADER2 *) pFormat;

        wsprintf(szBuffer, TEXT("%4.4hs %dx%d, %d bits"),
                 (pVideoFormat->bmiHeader.biCompression == 0) ? "RGB " :
                 ((pVideoFormat->bmiHeader.biCompression == BI_BITFIELDS) ? "BITF" :
                 (LPSTR) &pVideoFormat->bmiHeader.biCompression ),
                 pVideoFormat->bmiHeader.biWidth,
                 pVideoFormat->bmiHeader.biHeight,
                 pVideoFormat->bmiHeader.biBitCount);

    }
    else {
        lstrcpy(szBuffer, TEXT("Unknown format"));
    }
}
#endif
// pConnector is the initiating connecting pin
// pmt is the media type we will exchange
// This function is also called while the graph is running when the
// up stream decoder filter wants to change the size of the
// decoded video.
//
// If the up stream decoder wants to change from one transport
// type to another, eg. from MoComp back to IMemInputPin then it
// should perform a dynamic filter reconnect via the IGraphConfig
// Reconnect method.
//
STDMETHODIMP CVPMInputPin::ReceiveConnection(IPin * pConnector, const AM_MEDIA_TYPE *pmt)
{
    HRESULT hr = NOERROR;
    CVPMInputAllocator * pAlloc = NULL;

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    CheckPointer(pmt, E_POINTER);
    CMediaType cmt(*pmt);

    if (m_Connected != pConnector || pConnector == NULL)
    {
        hr = CBaseInputPin::ReceiveConnection(pConnector, &cmt);
        goto CleanUp;
    }

#ifdef DEBUG
    DbgLog((LOG_TRACE, 2, TEXT("ReceiveConnection when connected")));
    if (pmt)
    {
        TCHAR   szFmt[128];
        VideoFormat2String(szFmt, &pmt->formattype, pmt->pbFormat, pmt->cbFormat);
        DbgLog((LOG_TRACE, 2, TEXT("Format is: %s"), szFmt));
    }
#endif

    {
        /*  Can only do this if the allocator can be reconfigured */
        pAlloc = (CVPMInputAllocator *)m_pAllocator;
        if (!pAlloc)
        {
            hr = E_FAIL;
            DbgLog((LOG_TRACE, 2, TEXT("ReceiveConnection: Failed because of no allocator")));
            goto CleanUp;
        }

        if (!pAlloc->CanFree())
        {
            hr = VFW_E_WRONG_STATE;
            DbgLog((LOG_TRACE, 2, TEXT("ReceiveConnection: Failed because allocator can't free")));
            goto CleanUp;
        }
    }


    m_bConnected = FALSE;

    hr = CheckMediaType(&cmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 2, TEXT("ReceiveConnection: CheckMediaType failed")));
        goto CleanUp;
    }

    ALLOCATOR_PROPERTIES Props;
    {
        pAlloc->Decommit();
        pAlloc->GetProperties(&Props);

    }
    


    // back buffers are not addref'd so just set them to NULL
    m_dwBackBufferCount = 0;
    m_dwDirectDrawSurfaceWidth = 0;
    SetMediaType(&cmt);

    {
        ALLOCATOR_PROPERTIES PropsActual;
        Props.cbBuffer = pmt->lSampleSize;
        hr = pAlloc->SetProperties(&Props, &PropsActual);
        if (SUCCEEDED(hr))
        {
            hr = pAlloc->Commit();
        }
    }

    hr = UpdateMediaType();
    ASSERT(SUCCEEDED(hr));

    m_bConnected = TRUE;


CleanUp:
    return hr;
}

HRESULT CVPMInputPin::CheckConnect(IPin * pReceivePin)
{
    HRESULT hr = NOERROR;
    PKSMULTIPLE_ITEM pMediumList = NULL;
    IKsPin *pIKsPin = NULL;
    PKSPIN_MEDIUM pMedium = NULL;

    AMTRACE((TEXT("CVPMInputPin::CheckConnect")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    hr = pReceivePin->QueryInterface(IID_IKsPin, (void **)&pIKsPin);
    if (SUCCEEDED(hr))
    {
        ASSERT(pIKsPin);
        hr = pIKsPin->KsQueryMediums(&pMediumList);
    }
    if( SUCCEEDED( hr )) {
        ASSERT(pMediumList);
        pMedium = (KSPIN_MEDIUM *)(pMediumList+1);
        SetKsMedium((const KSPIN_MEDIUM *)pMedium);
    }

// CleanUp:

    // call the base class
    hr = CBaseInputPin::CheckConnect(pReceivePin);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::CheckConnect failed, hr = 0x%x"), hr));
    }

    RELEASE(pIKsPin);

    if (pMediumList)
    {
        CoTaskMemFree((void*)pMediumList);
        pMediumList = NULL;
    }

    return hr;
}

HRESULT CVPMInputPin::UpdateMediaType()
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::UpdateMediaType")));
    return hr;
}

// final connect
HRESULT CVPMInputPin::FinalConnect()
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::FinalConnect")));

    if (m_bConnected)
    {
        hr = E_FAIL;
        goto CleanUp;
    }

    // update the mediatype, tell the filter about the updated dimensions
    hr = UpdateMediaType();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("UpdateMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // tell the filter (might involve a reconnection with the output pin)
    hr = m_pVPMFilter.CompleteConnect(m_dwPinId);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pVPMFilter.CompleteConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    m_bConnected = TRUE;

CleanUp:
    return hr;
}

// Complete Connect
HRESULT CVPMInputPin::CompleteConnect(IPin *pReceivePin)
{
    HRESULT hr = NOERROR;
    AMVPDATAINFO amvpDataInfo;
    BITMAPINFOHEADER *pHeader = NULL;

    AMTRACE((TEXT("CVPMInputPin::CompleteConnect")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

   {
        // tell the videoport object
        hr = m_pIVPObject->CompleteConnect(pReceivePin);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->CompleteConnect failed, hr = 0x%x"), hr));
            goto CleanUp;
        }

        m_bRuntimeNegotiationFailed = FALSE;
    }

    // call the base class
    hr = CBaseInputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::CompleteConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    ASSERT(SUCCEEDED(hr));
    {
        // tell the proxy not to allocate buffers if it is a videoport or overlay connection
        SetStreamingInKernelMode(TRUE);

        hr = FinalConnect();
        // ASSERT(SUCCEEDED(hr));
        if( FAILED(hr) ) {
            SetStreamingInKernelMode(FALSE);
            DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::FinalConnect failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

    // the decoders can support a particular property set to tell the ovmixer to not to try to over-allocate
    // buffers incase they want complete control over the buffers etc
    {
        HRESULT hr1 = NOERROR;
        IKsPropertySet *pIKsPropertySet = NULL;
        DWORD dwVal = 0, dwBytesReturned = 0;


        hr1 = pReceivePin->QueryInterface(IID_IKsPropertySet, (void**)&pIKsPropertySet);
        if (SUCCEEDED(hr1))
        {
            ASSERT(pIKsPropertySet);

            if (!pIKsPropertySet)
            {
                DbgLog((LOG_ERROR, 1, TEXT("pIKsPropertySet == NULL, even though QI returned success")));
                goto CleanUp;
            }

            hr1 = pIKsPropertySet->Get( PROPSETID_ALLOCATOR_CONTROL, KSPROPERTY_ALLOCATOR_CONTROL_HONOR_COUNT,
                        NULL, 0, &dwVal, sizeof(dwVal), &dwBytesReturned);
            DbgLog((LOG_TRACE, 2, TEXT("pIKsPropertySet->Get(KSPROPSETID_ALLOCATOR_CONTROL), hr1 = 0x%x, dwVal == %d, dwBytesReturned == %d"),
                hr1, dwVal, dwBytesReturned));


            // if the decoder supports this property
            // and its value is 1 and the decoder supports DDKERNELCAPS_FLIPOVERLAY,
            // than we will do exactly honour its request and the
            // and not make any attempt to allocate more in order to prevent tearing
            //
            if ((SUCCEEDED(hr1)) && (dwVal == 1) && (dwBytesReturned == sizeof(dwVal)) &&
                (DDKERNELCAPS_FLIPOVERLAY & m_pVPMFilter.KernelCaps()))
            {
                DbgLog((LOG_TRACE, 2, TEXT("setting m_bCanOverAllocateBuffers == FALSE")));
                m_bCanOverAllocateBuffers = FALSE;
            }
            pIKsPropertySet->Release();
        }
    }

CleanUp:
    return hr;
}


HRESULT CVPMInputPin::OnSetProperties(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual)
{
    HRESULT hr = NOERROR;

    IPin *pReceivePin = NULL;
    DDSURFACEDESC ddSurfaceDesc;
    IEnumMediaTypes *pEnumMediaTypes = NULL;
    CMediaType cMediaType;
    AM_MEDIA_TYPE *pNewMediaType = NULL, *pEnumeratedMediaType = NULL;
    ULONG ulFetched = 0;
    DWORD dwMaxBufferCount = 0;
    BOOL bFoundSuitableSurface = FALSE;
    BITMAPINFOHEADER *pHeader = NULL;
    LPDDCAPS pDirectCaps = NULL;

    AMTRACE((TEXT("CVPMInputPin::OnSetProperties")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    // this function is only called after the base class CBaseAllocator::SetProperties() has been called
    // with the above parameters, so we don't have to do any parameter validation

    ASSERT(IsConnected());
    pReceivePin = CurrentPeer();
    ASSERT(pReceivePin);

    // we only care about the number of buffers requested, rest everything is ignored
    if (pRequest->cBuffers <= 0)
    {
        hr = E_FAIL;
        goto CleanUp;
    }

CleanUp:
    return hr;
}


HRESULT CVPMInputPin::BreakConnect(void)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::BreakConnect")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());


    {
        // tell the videoport object
        ASSERT(m_pIVPObject);
        hr = m_pIVPObject->BreakConnect();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->BreakConnect failed, hr = 0x%x"), hr));
        }
    }

    
    {
        

        // back buffers are not addref'd so just set them to NULL
        m_dwBackBufferCount = 0;
        m_dwDirectDrawSurfaceWidth = 0;

    }

    // initialize the behaviour to telling the proxy to allocate buffers
    SetStreamingInKernelMode(FALSE);

    m_bUsingOurAllocator = FALSE;
    m_bCanOverAllocateBuffers = TRUE;

    if (m_hMemoryDC)
    {
        EXECUTE_ASSERT(DeleteDC(m_hMemoryDC));
        m_hMemoryDC = NULL;
    }

    // call the base class
    hr = CBaseInputPin::BreakConnect();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::BreakConnect failed, hr = 0x%x"), hr));
    }

    // tell the owning filter
    hr = m_pVPMFilter.BreakConnect(m_dwPinId);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pVPMFilter.BreakConnect failed, hr = 0x%x"), hr));
    }

   
    m_bConnected = FALSE;
//CleanUp:
    return hr;
}

STDMETHODIMP CVPMInputPin::GetState(DWORD dwMSecs,FILTER_STATE *pState)
{
    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    // if not connected or VideoPort Connection or IOverlay connection, then let the base class handle it
    // otherwise (overlay, offcreen, gdi, motion-comp) let the sync object handle it
    return E_NOTIMPL;
}

HRESULT CVPMInputPin::CompleteStateChange(FILTER_STATE OldState)
{
    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());
    return S_OK;
}

// transition from stop to pause state
HRESULT CVPMInputPin::Active(void)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::Active")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());
    m_hEndOfStream = NULL;

    {
        // tell the videoport object
        hr = m_pIVPObject->Active();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->Active failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }

    // call the base class
    hr = CBaseInputPin::Active();
    // if it is a VP connection, this error is ok
    if (hr == VFW_E_NO_ALLOCATOR)
    {
        hr = NOERROR;
    }

    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::Active failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

// transition from pause to stop state
HRESULT CVPMInputPin::Inactive(void)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::Inactive")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    {
        // tell the videoport object
        hr = m_pIVPObject->Inactive();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->Inactive failed, hr = 0x%x"), hr));
            goto CleanUp;
        }

        // make sure that if there is a run time error, stop succeeds
        if (m_bRuntimeNegotiationFailed && hr == VFW_E_NOT_CONNECTED)
        {
            hr = NOERROR;
        }
    }
    
    // call the base class
    hr = CBaseInputPin::Inactive();

    // if it is a VP connection, this error is ok
    if ( hr == VFW_E_NO_ALLOCATOR)
    {
        hr = NOERROR;
    }

    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::Inactive failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

// transition from pause to run state
HRESULT CVPMInputPin::Run(REFERENCE_TIME tStart)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::Run")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    m_bDontFlip = FALSE ;   // need to reset it to do the right things in this session

    {
        // tell the videoport object
        hr = m_pIVPObject->Run(tStart);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->Run() failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    
    // call the base class
    hr = CBaseInputPin::Run(tStart);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::Run failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    // TBD: figure out ... stream time
    m_rtNextSample = 0;
    m_rtLastRun = tStart;

    // just start the src video running, we'll have an output image when we get a sample
    hr = InitVideo();

CleanUp:
    m_trLastFrame = -1;
    return hr;
}

// transition from run to pause state
HRESULT CVPMInputPin::RunToPause(void)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::RunToPause")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    // only if a vp pin
    if( m_pIVPObject ) {
        // tell the videoport object
        hr = m_pIVPObject->RunToPause();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->RunToPause() failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
    }
    
CleanUp:
    return hr;
}



// signals start of flushing on the input pin
HRESULT CVPMInputPin::BeginFlush(void)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::BeginFlush")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());
    m_hEndOfStream = 0;

    if (m_bFlushing)
    {
        return E_FAIL;
    }

    // if the conection is VideoPort or IOverlay, we do not care about flushing
    
    // call the base class
    hr = CBaseInputPin::BeginFlush();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::BeginFlush() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

// signals end of flushing on the input pin
HRESULT CVPMInputPin::EndFlush(void)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::EndFlush")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    if (!m_bFlushing)
    {
        return E_FAIL;
    }

    // if the conection is VideoPort or IOverlay, we do not care about flushing
    

    // call the base class
    hr = CBaseInputPin::EndFlush();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CBaseInputPin::EndFlush() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

// Send a quality message if required - this is the hack version
// that just passes the lateness
void CVPMInputPin::DoQualityMessage()
{
    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    if (m_pVPMFilter.m_State == State_Running &&
        SampleProps()->dwSampleFlags & AM_SAMPLE_TIMEVALID)
    {
        CRefTime CurTime;
        if (S_OK == m_pVPMFilter.StreamTime(CurTime))
        {
            const REFERENCE_TIME tStart = SampleProps()->tStart;
            Quality msg;
            msg.Proportion = 1000;
            msg.Type = CurTime > tStart ? Flood : Famine;
            msg.Late = CurTime - tStart;
            msg.TimeStamp = tStart;
            PassNotify(msg);

            m_trLastFrame = CurTime;
        }
    }
}

// called when the upstream pin delivers us a sample
HRESULT CVPMInputPin::Receive(IMediaSample *pMediaSample)
{
    HRESULT hr = NOERROR;
    BOOL bNeedToFlipOddEven = FALSE;
    BOOL bDisplayingFields = FALSE;
    DWORD dwTypeSpecificFlags = 0;
    LPDIRECTDRAWSURFACE7 pPrimarySurface = NULL;

    AMTRACE((TEXT("CVPMInputPin::Receive")));

    // a videoport connection does not receive samples so bail out
    {
        hr = VFW_E_NOT_SAMPLE_CONNECTION;
        goto CleanUp;
    }

    
CleanUp:
    return hr;
}


HRESULT CVPMInputPin::OnReceiveFirstSample(IMediaSample *pMediaSample)
{
    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    ASSERT( !"OnReceiveFirstSample" );
    return NOERROR;
}

HRESULT CVPMInputPin::InitVideo()
{
    HRESULT hr = m_pIVPObject->StartVideo( &m_WinInfo );
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("m_pIVPObject->StartVideo failed, hr = 0x%x"), hr));
    }
    return hr;
}

// this function just tells whether each sample consists of one or two fields
static HRESULT SetTypeSpecificFlags(IMediaSample *pSample, DWORD dwTypeSpecificFlags )
{
    IMediaSample2 *pSample2 = NULL;

    /* Check for IMediaSample2 */
    HRESULT hr = pSample->QueryInterface(IID_IMediaSample2, (void **)&pSample2);
    if (SUCCEEDED(hr)) {
        AM_SAMPLE2_PROPERTIES SampleProps;
        hr = pSample2->GetProperties(sizeof(SampleProps), (PBYTE)&SampleProps);
        if( SUCCEEDED( hr )) {
            SampleProps.dwTypeSpecificFlags = dwTypeSpecificFlags;
            hr = pSample2->SetProperties(sizeof(SampleProps), (PBYTE)&SampleProps);
        }
        pSample2->Release();
    }
    return hr;
}

static REFERENCE_TIME ScaleMicroToRefTime( DWORD dwMicroseconds )
{
    // Reference time is in 100 ns = 0.1us, so multiply by 10
    ASSERT( 10*1000000 == UNITS );

    switch( dwMicroseconds ) {
    case 16667:
    case 16666: // 60hz
        return 166667;
    case 16683: // 59.94hz
        return 166834;
    case 20000: // 50hz PAL
        return REFERENCE_TIME(dwMicroseconds)*10;

    default:
        ASSERT( !"Missing ref scale" );
        return REFERENCE_TIME(dwMicroseconds)*10;
    }
}

HRESULT CVPMInputPin::DoRenderSample(IMediaSample* pSample, LPDIRECTDRAWSURFACE7 pDDDestSurface, const DDVIDEOPORTNOTIFY& notify,
                                      const VPInfo& vpInfo )
{
    if( !pDDDestSurface ) {
        return E_INVALIDARG;
    }

    AMTRACE((TEXT("CVPMInputPin::DoRenderSample")));

    CAutoLock cLock(&m_pVPMFilter.GetReceiveLock());

    HRESULT hr = S_OK;
    if( SUCCEEDED( hr )) {
        hr = m_pIVPObject->CallUpdateSurface( notify.dwSurfaceIndex, pDDDestSurface );
        if( SUCCEEDED( hr )) {
            REFERENCE_TIME rtStart = m_rtNextSample; // for debugging, assume continuous

            hr = m_pVPMFilter.GetRefClockTime( &rtStart );
            ASSERT( SUCCEEDED( hr ));

            // make time relative to last run time, i.e. timestamps after run begin at 0
            rtStart -= m_rtLastRun;

            // get the actual time
            REFERENCE_TIME rtInterval = ScaleMicroToRefTime( vpInfo.vpDataInfo.dwMicrosecondsPerField );

            // now set the field info
            DWORD dwTypeFlags=0;

#ifdef DEBUG
            static bool checked=false;
#endif
            switch( vpInfo.mode ) {
                case AMVP_MODE_BOBNONINTERLEAVED:
                    switch( notify.lField ) {
                    case 0:
                        dwTypeFlags = AM_VIDEO_FLAG_FIELD1;
                        break;

                    case 1:
                        dwTypeFlags = AM_VIDEO_FLAG_FIELD2;
                        break;

                    case -1:
#ifdef DEBUG
                        if( !checked ) {
                            ASSERT( !"Video driver doesn't known field for sample, VPM assuming Field1" );
                            checked=true;
                        }
#endif
                        dwTypeFlags = AM_VIDEO_FLAG_FIELD1;
                        break;

                    default:
#ifdef DEBUG
                        if( !checked ) {
                            ASSERT( !"Bogus field value returned by video driver for sample, assuming Field1" );
                            checked=true;
                        }
#endif
                        dwTypeFlags = AM_VIDEO_FLAG_FIELD1;
                        break;
                    }
                    break;
                case AMVP_MODE_BOBINTERLEAVED:
                    if( !vpInfo.vpDataInfo.bFieldPolarityInverted ) {           // Device inverts the polarity by default
                        dwTypeFlags = AM_VIDEO_FLAG_FIELD1FIRST;
                    }
                    rtInterval *= 2;    // 2 fields
                    break;
                case AMVP_MODE_WEAVE:
                    dwTypeFlags = AM_VIDEO_FLAG_WEAVE;
                    rtInterval *= 2;    // 2 fields
                    break;
                case AMVP_MODE_SKIPEVEN:
                    dwTypeFlags = AM_VIDEO_FLAG_FIELD1;
                    break;
                case AMVP_MODE_SKIPODD:
                    dwTypeFlags = AM_VIDEO_FLAG_FIELD2;
                    break;
                default:
                    break;
            }

            REFERENCE_TIME rtStop = rtStart+rtInterval;
            // set flags & timestamps
            hr = SetTypeSpecificFlags( pSample, dwTypeFlags);

            hr = pSample->SetTime(&rtStart, &rtStop);
            // assume next sample comes immediately afterwards
            m_rtNextSample += rtInterval;
        }
    }
    return hr;
}

HRESULT CVPMInputPin::StartVideo()
{
    HRESULT hr = m_pIVPObject->StartVideo( &m_WinInfo );
    ASSERT( SUCCEEDED( hr ));

    if (FAILED(hr))
    {

        DbgLog((LOG_ERROR, 0,  TEXT("InPin::StartVideo() failed, hr = %d"), hr & 0xffff));
    } else {
        // hack for now, force a new dest recalc
        SetRect( &m_WinInfo.DestRect, 0,0,0,0);
    }
    return hr;
}

// signals end of data stream on the input pin
STDMETHODIMP CVPMInputPin::EndOfStream(void)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::EndOfStream")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());
    if (m_hEndOfStream) {
        EXECUTE_ASSERT(SetEvent(m_hEndOfStream));
        return S_OK;
    }

    // Make sure we're streaming ok

    hr = CheckStreaming();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CheckStreaming() failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

   {
        // Pass EOS to the filter graph
        hr = m_pVPMFilter.EventNotify(m_dwPinId, EC_COMPLETE, S_OK, 0);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 1, TEXT("m_pVPMFilter.EventNotify failed, hr = 0x%x"), hr));
        }
    }
    

CleanUp:
    return hr;
}

// signals end of data stream on the input pin
HRESULT CVPMInputPin::EventNotify(long lEventCode, DWORD_PTR lEventParam1, DWORD_PTR lEventParam2)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::EventNotify")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    // if (lEventCode == EC_OVMIXER_REDRAW_ALL || lEventCode == EC_REPAINT)
    // {
    //     m_pVPMFilter.EventNotify(m_dwPinId, lEventCode, lEventParam1, lEventParam2);
    //     goto CleanUp;
    // }

    // WARNING : we are assuming here that the input pin will be the first pin to be created
    if (lEventCode == EC_COMPLETE && m_dwPinId == 0)
    {
        m_pVPMFilter.EventNotify(m_dwPinId, lEventCode, lEventParam1, lEventParam2);
        goto CleanUp;
    }

    if (lEventCode == EC_ERRORABORT)
    {
        m_pVPMFilter.EventNotify(m_dwPinId, lEventCode, lEventParam1, lEventParam2);
        m_bRuntimeNegotiationFailed = TRUE;
        goto CleanUp;
    }

    if (lEventCode == EC_STEP_COMPLETE) {
        m_pVPMFilter.EventNotify(m_dwPinId, lEventCode, lEventParam1, lEventParam2);
        goto CleanUp;
    }

CleanUp:
    return hr;
}


/******************************Public*Routine******************************\
* GetCaptureInfo
*
*
*
* History:
* 3/12/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVPMInputPin::GetCaptureInfo(
    BOOL *lpCapturing,
    DWORD *lpdwWidth,
    DWORD *lpdwHeight,
    BOOL *lpInterleave
    )

{
    AMTRACE((TEXT("CVPMInputPin::GetCaptureInfo")));

    HRESULT hr = NOERROR;
    IKsPropertySet *pIKsPropertySet = NULL;
    DWORD dwVal[2], dwBytesReturned = 0;

    *lpCapturing = FALSE;

    if (!m_Connected) {

        DbgLog((LOG_TRACE, 1, TEXT("Input pin not connected!!")));
        hr = E_FAIL;
        goto CleanUp;
    }

#if defined(DEBUG)
    else {
        PIN_INFO PinInfo;
        hr = m_Connected->QueryPinInfo(&PinInfo);
        if (SUCCEEDED(hr)) {
            DbgLog((LOG_TRACE, 1, TEXT("Up stream pin name %ls"), PinInfo.achName));
            PinInfo.pFilter->Release();
        }
    }
#endif

    hr = m_Connected->QueryInterface(IID_IKsPropertySet,
                                     (void**)&pIKsPropertySet);
    if (SUCCEEDED(hr))
    {
        ASSERT(pIKsPropertySet);

        hr = pIKsPropertySet->Set(
                    PROPSETID_ALLOCATOR_CONTROL,
                    AM_KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS,
                    NULL, 0,
                    lpInterleave, sizeof(*lpInterleave));

        if (SUCCEEDED(hr)) {
            hr = pIKsPropertySet->Get(
                        PROPSETID_ALLOCATOR_CONTROL,
                        AM_KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE,
                        NULL, 0,
                        lpInterleave, sizeof(*lpInterleave), &dwBytesReturned);

            if (FAILED(hr) || dwBytesReturned != sizeof(*lpInterleave)) {
                *lpInterleave = FALSE;
            }
        }
        else {
            *lpInterleave = FALSE;
        }


        hr = pIKsPropertySet->Get(
                    PROPSETID_ALLOCATOR_CONTROL,
                    KSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE,
                    NULL, 0, dwVal, sizeof(dwVal), &dwBytesReturned);

        DbgLog((LOG_TRACE, 2,
                TEXT("pIKsPropertySet->Get(")
                TEXT("PROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE),\n")
                TEXT("\thr = 0x%x, dwVal[0] == %d, dwVal[1] == %d, ")
                TEXT("dwBytesReturned == %d"),
                hr, dwVal[0], dwVal[1], dwBytesReturned));


        // if the decoder supports this property then we are capturing
        // and the intended capturing is size is given by
        // dwVal[0] and dwVal[1]
        //
        if (SUCCEEDED(hr) && dwBytesReturned == sizeof(dwVal))
        {
            *lpCapturing = TRUE;
            *lpdwWidth = dwVal[0];
            *lpdwHeight = dwVal[1];

            DbgLog((LOG_TRACE, 1,
                    TEXT("We are CAPTURING, intended size (%d, %d) interleave = %d"),
                    dwVal[0], dwVal[1], *lpInterleave));
        }

        pIKsPropertySet->Release();
    }

CleanUp:
    return hr;
}


/******************************Public*Routine******************************\
* GetDecimationUsage
*
*
*
* History:
* Thu 07/15/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVPMInputPin::GetDecimationUsage(
    DECIMATION_USAGE *lpdwUsage
    )
{
    return m_pVPMFilter.QueryDecimationUsage(lpdwUsage);
}


// This overrides the CBaseInputPin virtual method to return our allocator
HRESULT CVPMInputPin::GetAllocator(IMemAllocator **ppAllocator)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::GetAllocator")));

    if (!ppAllocator)
    {
        DbgLog((LOG_ERROR, 1, TEXT("ppAllocator is NULL")));
        hr = E_POINTER;
        goto CleanUp;
    }

    {
        CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

        // if vp connection, don't return any allocator
        {
            *ppAllocator = NULL;
            hr = VFW_E_NO_ALLOCATOR;
            goto CleanUp;
        }

        
    }

CleanUp:
    return hr;
} // GetAllocator

// This overrides the CBaseInputPin virtual method to return our allocator
HRESULT CVPMInputPin::NotifyAllocator(IMemAllocator *pAllocator,BOOL bReadOnly)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::NotifyAllocator")));

    if (!pAllocator)
    {
        DbgLog((LOG_ERROR, 1, TEXT("ppAllocator is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    {
        CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

        // if vp connection, don't care
        {
            goto CleanUp;
        }
    }

CleanUp:
    return hr;
} // NotifyAllocator

HRESULT CVPMInputPin::OnAlloc(CDDrawMediaSample **ppSampleList, DWORD dwSampleCount)
{
    HRESULT hr = NOERROR;
    DWORD i;
    LPDIRECTDRAWSURFACE7 pDDrawSurface = NULL, pBackBuffer = NULL;
    DDSCAPS ddSurfaceCaps;
    DWORD dwDDrawSampleSize = 0;
    BITMAPINFOHEADER *pHeader = NULL;
    DIBDATA DibData;

    AMTRACE((TEXT("CVPMInputPin::OnAlloc")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    ASSERT(IsConnected());

    // get the image size
    {
        CMediaType mtNew;
        hr = m_pIVPObject->CurrentMediaType( &mtNew );
        if( FAILED( hr )) {
            goto CleanUp;
        }
        pHeader = VPMUtil::GetbmiHeader(&mtNew);
        if ( ! pHeader )
        {
            hr = E_FAIL;
            goto CleanUp;
        }
        dwDDrawSampleSize = pHeader->biSizeImage;
    }
    ASSERT(dwDDrawSampleSize > 0);

    if (!ppSampleList)
    {
        DbgLog((LOG_ERROR, 1, TEXT("ppSampleList is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    for (i = 0; i < dwSampleCount; i++)
    {
        if (!ppSampleList[i])
        {
            DbgLog((LOG_ERROR, 1, TEXT("ppSampleList[%d] is NULL"), i));
            hr = E_INVALIDARG;
            goto CleanUp;
        }

        hr = ppSampleList[i]->SetDDrawSampleSize(dwDDrawSampleSize);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,  TEXT("ppSampleList[%d]->SetSampleSize failed, hr = 0x%x"), i, hr));
            goto CleanUp;
        }

        
    }  // end of for (i < dwSampleCount) loop

CleanUp:
    return hr;
}

// sets the pointer to directdraw
HRESULT CVPMInputPin::OnGetBuffer(IMediaSample **ppSample, REFERENCE_TIME *pStartTime,
                                 REFERENCE_TIME *pEndTime, DWORD dwFlags)
{
    HRESULT hr = NOERROR;
    CDDrawMediaSample *pCDDrawMediaSample = NULL;
    LPDIRECTDRAWSURFACE7 pBackBuffer = NULL;
    DDSURFACEDESC ddSurfaceDesc;
    BOOL bWaitForDraw = FALSE;
    BOOL bPalettised = FALSE;

    AMTRACE((TEXT("CVPMInputPin::OnGetBuffer")));

    // not valid for videoport
    ASSERT( FALSE ) ;


    return hr;
}

// In case of flipping surfaces, gets the back buffer
HRESULT CVPMInputPin::OnReleaseBuffer(IMediaSample *pMediaSample)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVPMInputPin::OnReleaseBuffer")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    
    return hr;
}

/*****************************Private*Routine******************************\
* GetUpstreamFilterName
*
*
*
* History:
* Tue 11/30/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CVPMInputPin::GetUpstreamFilterName(
    TCHAR* FilterName
    )
{
    PIN_INFO PinInfo;

    if (!m_Connected)
    {
        return VFW_E_NOT_CONNECTED;
    }

    HRESULT hr = m_Connected->QueryPinInfo(&PinInfo);
    if (SUCCEEDED(hr))
    {
        FILTER_INFO FilterInfo;
        hr = PinInfo.pFilter->QueryFilterInfo(&FilterInfo);
        if (SUCCEEDED(hr))
        {
            wsprintf(FilterName, TEXT("%ls"), FilterInfo.achName);
            if (FilterInfo.pGraph)
            {
                FilterInfo.pGraph->Release();
            }
        }
        PinInfo.pFilter->Release();
    }

    return hr;
}
HRESULT CVPMInputPin::CreateDDrawSurface(CMediaType *pMediaType, DWORD *pdwMaxBufferCount, LPDIRECTDRAWSURFACE7 *ppDDrawSurface)
{
    HRESULT hr = NOERROR;
    DDSURFACEDESC2 SurfaceDesc;
    DWORD dwInterlaceFlags = 0, dwTotalBufferCount = 0, dwMinBufferCount = 0;
    DDSCAPS ddSurfaceCaps;
    BITMAPINFOHEADER *pHeader;
    FOURCCMap amFourCCMap(pMediaType->Subtype());

   
    AMTRACE((TEXT("CVPMInputPin::CreateDDrawSurface")));

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    LPDIRECTDRAW7 pDirectDraw = m_pVPMFilter.GetDirectDraw();
    ASSERT(pDirectDraw);

    if (!pMediaType)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pMediaType is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (!ppDDrawSurface)
    {
        DbgLog((LOG_ERROR, 1, TEXT("ppDDrawSurface is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    {
        hr = E_INVALIDARG;
        goto CleanUp;
    }

CleanUp:
    return hr;
}

// this function is used to restore the ddraw surface. In the videoport case, we just recreate
// the whole thing from scratch.
HRESULT CVPMInputPin::RestoreDDrawSurface()
{
    HRESULT hr = NOERROR;

    {
        // stop the video
        m_pIVPObject->Inactive();
        // don't have to give up the IVPConfig interface here
        m_pIVPObject->BreakConnect(TRUE);
        // redo the connection process
        hr = m_pIVPObject->CompleteConnect(NULL, TRUE);
    }

    return hr;
}

HRESULT CVPMInputPin::GetSourceAndDest(RECT *prcSource, RECT *prcDest, DWORD *dwWidth, DWORD *dwHeight)
{
    {
        m_pIVPObject->GetRectangles(prcSource, prcDest);
    }
    

    CMediaType mt;
    HRESULT hr = CurrentMediaType(&mt);

    if (SUCCEEDED(hr))
    {
        BITMAPINFOHEADER *pHeader = VPMUtil::GetbmiHeader(&mt);
        if ( ! pHeader )
        {
            hr = E_FAIL;
        }
        else
        {
            *dwWidth = abs(pHeader->biWidth);
            *dwHeight = abs(pHeader->biHeight);
        }
    }

    return hr;
}

STDMETHODIMP CVPMInputPin::Set(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData,
                              LPVOID pPropData, DWORD cbPropData)
{
    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    return E_PROP_SET_UNSUPPORTED ;
}


STDMETHODIMP CVPMInputPin::Get(REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData, DWORD cbInstanceData,
                              LPVOID pPropData, DWORD cbPropData, DWORD *pcbReturned)
{
    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    return E_PROP_SET_UNSUPPORTED;
}


STDMETHODIMP CVPMInputPin::QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD *pTypeSupport)
{
    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    if (AMPROPSETID_Pin == guidPropSet)
    {
        if (AMPROPERTY_PIN_CATEGORY != dwPropID && AMPROPERTY_PIN_MEDIUM != dwPropID )
            return E_PROP_ID_UNSUPPORTED ;

        if (pTypeSupport)
                *pTypeSupport = KSPROPERTY_SUPPORT_GET ;
        return S_OK;
    }
    return E_PROP_SET_UNSUPPORTED ;
}


STDMETHODIMP CVPMInputPin::KsQueryMediums(PKSMULTIPLE_ITEM* pMediumList)
{
    PKSPIN_MEDIUM pMedium;

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    *pMediumList = reinterpret_cast<PKSMULTIPLE_ITEM>(CoTaskMemAlloc(sizeof(**pMediumList) + sizeof(*pMedium)));
    if (!*pMediumList)
    {
        return E_OUTOFMEMORY;
    }
    (*pMediumList)->Count = 1;
    (*pMediumList)->Size = sizeof(**pMediumList) + sizeof(*pMedium);
    pMedium = reinterpret_cast<PKSPIN_MEDIUM>(*pMediumList + 1);
    pMedium->Set   = m_Medium.Set;
    pMedium->Id    = m_Medium.Id;
    pMedium->Flags = m_Medium.Flags;

    // The following special return code notifies the proxy that this pin is
    // not available as a kernel mode connection
    return S_FALSE;
}


STDMETHODIMP CVPMInputPin::KsQueryInterfaces(PKSMULTIPLE_ITEM* pInterfaceList)
{
    PKSPIN_INTERFACE    pInterface;

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    *pInterfaceList = reinterpret_cast<PKSMULTIPLE_ITEM>(CoTaskMemAlloc(sizeof(**pInterfaceList) + sizeof(*pInterface)));
    if (!*pInterfaceList)
    {
        return E_OUTOFMEMORY;
    }
    (*pInterfaceList)->Count = 1;
    (*pInterfaceList)->Size = sizeof(**pInterfaceList) + sizeof(*pInterface);
    pInterface = reinterpret_cast<PKSPIN_INTERFACE>(*pInterfaceList + 1);
    pInterface->Set = KSINTERFACESETID_Standard;
    pInterface->Id = KSINTERFACE_STANDARD_STREAMING;
    pInterface->Flags = 0;
    return NOERROR;
}

STDMETHODIMP CVPMInputPin::KsGetCurrentCommunication(KSPIN_COMMUNICATION* pCommunication, KSPIN_INTERFACE* pInterface, KSPIN_MEDIUM* pMedium)
{
    HRESULT hr = NOERROR;

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    if (!m_bStreamingInKernelMode)
        hr = S_FALSE;

    if (pCommunication != NULL)
    {
        *pCommunication = m_Communication;
    }
    if (pInterface != NULL)
    {
        pInterface->Set = KSINTERFACESETID_Standard;
        pInterface->Id = KSINTERFACE_STANDARD_STREAMING;
        pInterface->Flags = 0;
    }
    if (pMedium != NULL)
    {
        *pMedium = m_Medium;
    }
    return hr;
}

/******************************Public*Routine******************************\
* DynamicQueryAccept
*
* Do you accept this type change in your current state?
*
* History:
* Wed 12/22/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVPMInputPin::DynamicQueryAccept(
    const AM_MEDIA_TYPE *pmt
    )
{
    AMTRACE((TEXT("CVPMInputPin::DynamicQueryAccept")));
    CheckPointer(pmt, E_POINTER);

    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());

    //
    // I want CheckMedia type to behave as though we aren't connected to
    // anything yet - hence the messing about with m_bConnected.
    //
    CMediaType cmt(*pmt);
    BOOL bConnected = m_bConnected;
    m_bConnected = FALSE;
    HRESULT  hr = CheckMediaType(&cmt);
    m_bConnected = bConnected;

    return hr;
}

/******************************Public*Routine******************************\
* NotifyEndOfStream
*
*
* Set event when EndOfStream receive - do NOT pass it on
* This condition is cancelled by a flush or Stop
*
* History:
* Wed 12/22/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVPMInputPin::NotifyEndOfStream(
    HANDLE hNotifyEvent
    )
{
    AMTRACE((TEXT("CVPMInputPin::NotifyEndOfStream")));
    CAutoLock cLock(&m_pVPMFilter.GetFilterLock());
    m_hEndOfStream = hNotifyEvent;
    return S_OK;
}

/******************************Public*Routine******************************\
* IsEndPin
*
* Are you an 'end pin'
*
* History:
* Wed 12/22/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
CVPMInputPin::IsEndPin()
{
    AMTRACE((TEXT("CVPMInputPin::IsEndPin")));
    return S_OK;
}

/******************************Public*Routine******************************\
* DynamicDisconnect
*
* Disconnect while running
*
* History:
* Wed 2/7/1999 - SyonB - Created
*
\**************************************************************************/
STDMETHODIMP
CVPMInputPin::DynamicDisconnect()
{
    AMTRACE((TEXT("CVPMInputPin::DynamicDisconnect")));
    CAutoLock l(m_pLock);
    return CBaseInputPin::DisconnectInternal();
}

HRESULT CVPMInputPin::GetAllOutputFormats( const PixelFormatList** ppList )
{
    HRESULT hr;
    CAutoLock l(m_pLock);
    if (IsConnected() ) {
        hr = m_pIVPObject->GetAllOutputFormats( ppList );
    } else {
        hr = VFW_E_NOT_CONNECTED;
    }
    return hr;
}

HRESULT CVPMInputPin::GetOutputFormat( DDPIXELFORMAT* pFormat )
{
    HRESULT hr;
    CAutoLock l(m_pLock);
    if (IsConnected() ) {
        hr = m_pIVPObject->GetOutputFormat( pFormat );
    } else {
        hr = VFW_E_NOT_CONNECTED;
    }
    return hr;
}

HRESULT CVPMInputPin::SetVideoPortID( DWORD dwIndex )
{
    HRESULT hr = S_OK;
    CAutoLock l(m_pLock);
    if (m_pIVPObject ) {
        hr = m_pIVPObject->SetVideoPortID( dwIndex );
    }
    return hr;
}

HRESULT CVPMInputPin::InPin_GetVPInfo( VPInfo* pVPInfo )
{
    HRESULT hr = E_FAIL;

	// Private: must hold streaming lock
    CAutoLock l(&m_pVPMFilter.GetReceiveLock());
    if (m_pIVPInfo ) {
        hr = m_pIVPInfo->GetVPDataInfo( &pVPInfo->vpDataInfo );
        if( SUCCEEDED( hr )) {
            hr = m_pIVPInfo->GetVPInfo( &pVPInfo->vpInfo );
        }
        if( SUCCEEDED( hr )) {
            hr = m_pIVPObject->GetMode( &pVPInfo->mode );
        }
    }
    return hr;
}

LPDIRECTDRAW7 CVPMInputPin::GetDirectDraw()
{
    return m_pVPMFilter.GetDirectDraw();
}

const DDCAPS* CVPMInputPin::GetHardwareCaps()
{
    return m_pVPMFilter.GetHardwareCaps();
}

HRESULT CVPMInputPin::SignalNewVP( LPDIRECTDRAWVIDEOPORT pVP )
{
    return m_pVPMFilter.SignalNewVP( pVP );
}

//==========================================================================
HRESULT CVPMInputPin::GetMediaType(int iPosition, CMediaType *pmt)
{
    CAutoLock cLock( &m_pVPMFilter.GetFilterLock() );
    AMTRACE((TEXT("Entering CVBIInputPin::GetMediaType")));

    HRESULT hr = m_pIVPObject->GetMediaType(iPosition, pmt);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vpm\vpmpin.h ===
/******************************Module*Header*******************************\
* Module Name: VPManager.h
*
*
*
*
* Created: Tue 05/05/2000
* Author:  GlenneE
*
* Copyright (c) 2000 Microsoft Corporation
\**************************************************************************/
#ifndef __VPMPin__h
#define __VPMPin__h

// IDirectDrawMediaSample
#include <amstream.h>

// IVideoPortControl
#include <VPObj.h>

// IksPin
#include <ks.h>
#include <ksproxy.h>

class CVPMFilter;

struct VPInfo
{
    AMVPDATAINFO    vpDataInfo;
    DDVIDEOPORTINFO vpInfo;
    AMVP_MODE       mode;
};

typedef enum
{
    // AM_KSPROPERTY_ALLOCATOR_CONTROL_HONOR_COUNT = 0,
    // AM_KSPROPERTY_ALLOCATOR_CONTROL_SURFACE_SIZE = 1,

    // Extra flags not in KSPROPERTY_ALLOCATOR_CONTROL

    // W I (informns a capture driver whether interleave capture is possible or
    //      not - a value of 1 means that interleaved capture is supported)
    AM_KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_CAPS = 2,

    // R O (if value == 1, then the ovmixer will turn on the DDVP_INTERLEAVE
    //      flag thus allowing interleaved capture of the video)
    AM_KSPROPERTY_ALLOCATOR_CONTROL_CAPTURE_INTERLEAVE = 3

} AM_KSPROPERTY_ALLOCATOR_CONTROL;

/* -------------------------------------------------------------------------
** CVPManager class declaration
** -------------------------------------------------------------------------
*/
class CVPMFilter;

class CDDrawMediaSample : public CMediaSample, public IDirectDrawMediaSample
{
public:

    CDDrawMediaSample(TCHAR* pName, CBaseAllocator* pAllocator, HRESULT* phr, LPBYTE pBuffer, LONG length,
                      bool bKernelLock);
    ~CDDrawMediaSample();

    /* Note the media sample does not delegate to its owner */
    STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef() { return CMediaSample::AddRef(); }
    STDMETHODIMP_(ULONG) Release() { return CMediaSample::Release(); }

    void SetDIBData(DIBDATA* pDibData);
    DIBDATA* GetDIBData();

    HRESULT SetDDrawSampleSize(DWORD dwDDrawSampleSize);
    HRESULT GetDDrawSampleSize(DWORD* pdwDDrawSampleSize);
    HRESULT SetDDrawSurface(LPDIRECTDRAWSURFACE7 pDirectDrawSurface);
    HRESULT GetDDrawSurface(LPDIRECTDRAWSURFACE7* ppDirectDrawSurface);

    // methods belonging to IDirectDrawMediaSample
    STDMETHODIMP GetSurfaceAndReleaseLock(IDirectDrawSurface** ppDirectDrawSurface, RECT* pRect);
    STDMETHODIMP LockMediaSamplePointer(void);
    
    /*  Hack to get at the list */
    CMediaSample*          &Next() { return m_pNext; }
private:
    DIBDATA                 m_DibData;                      // Information about the DIBSECTION
    LPDIRECTDRAWSURFACE7    m_pDirectDrawSurface;           // pointer to the direct draw surface
    DWORD                   m_dwDDrawSampleSize;            // ddraw sample size
    bool                    m_bInit;                        // Is the DIB information setup
    bool                    m_bSurfaceLocked;               // specifies whether surface is locked or not
    bool                    m_bKernelLock;                  // lock with no sys lock
    RECT                    m_SurfaceRect;                  // the part of the surface that is locked
};

// common functionality to all pins
class CVPMPin
{
public:
    CVPMPin( DWORD dwPinId, CVPMFilter& pFilter )
        : m_dwPinId( dwPinId )
        , m_pVPMFilter( pFilter )
    {}
    DWORD   GetPinId() const
                { return m_dwPinId; };
    CVPMFilter& GetFilter() { return m_pVPMFilter; };

protected:
    DWORD       m_dwPinId;
    CVPMFilter& m_pVPMFilter;
};


class CVPMInputAllocator
: public CBaseAllocator
{
    friend class CVPMInputPin;
public:

    CVPMInputAllocator( CVPMInputPin& pPin, HRESULT* phr);             // Return code
    ~CVPMInputAllocator();

    DECLARE_IUNKNOWN

    STDMETHODIMP CVPMInputAllocator::NonDelegatingQueryInterface(REFIID riid, void** ppv);

    STDMETHODIMP SetProperties(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual);
    STDMETHODIMP GetBuffer(IMediaSample** ppSample, REFERENCE_TIME* pStartTime,
                            REFERENCE_TIME* pEndTime, DWORD dwFlags);
    STDMETHODIMP ReleaseBuffer(IMediaSample* pMediaSample);

    //  Check all samples are returned
    BOOL CanFree() const
    {
        return m_lFree.GetCount() == m_lAllocated;
    }
protected:
    void    Free();
    HRESULT Alloc();

private:
    CVPMInputPin&   m_pPin;
};

class CVPMInputPin
: public CBaseInputPin
, public IKsPin
, public IKsPropertySet
, public ISpecifyPropertyPages
, public IPinConnection
, public IVideoPortControl
, public CVPMPin
{
public:
    CVPMInputPin(TCHAR* pObjectName, CVPMFilter& pFilter,
                    HRESULT* phr, LPCWSTR pPinName,
                    DWORD dwPinNo);
    ~CVPMInputPin();
    friend class CVPMInputAllocator;
    friend class CVPMFilter;

    DECLARE_IUNKNOWN

    STDMETHODIMP         NonDelegatingQueryInterface(REFIID riid, void** ppv);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

    //
    // --- ISpecifyPropertyPages ---
    //
    STDMETHODIMP GetPages(CAUUID* pPages);

    // Override ReceiveConnection to allow format changes while running
    STDMETHODIMP ReceiveConnection(IPin*  pConnector, const AM_MEDIA_TYPE* pmt);

    // connection related functions
    HRESULT CheckConnect(IPin*  pReceivePin);
    HRESULT CompleteConnect(IPin* pReceivePin);
    HRESULT BreakConnect();
    HRESULT GetMediaType(int iPosition,CMediaType* pMediaType);
    HRESULT CheckInterlaceFlags(DWORD dwInterlaceFlags);
    HRESULT DynamicCheckMediaType(const CMediaType* pmt);
    HRESULT CheckMediaType(const CMediaType* mtOut);
    HRESULT SetMediaType(const CMediaType* pmt);
    HRESULT FinalConnect();
    HRESULT UpdateMediaType();

    // streaming functions
    HRESULT         Active();
    HRESULT         Inactive();
    HRESULT         Run(REFERENCE_TIME tStart);
    HRESULT         RunToPause();
    STDMETHODIMP    BeginFlush();
    STDMETHODIMP    EndFlush();
    STDMETHODIMP    Receive(IMediaSample* pMediaSample);
    STDMETHODIMP    EndOfStream(void);
    STDMETHODIMP    GetState(DWORD dwMSecs,FILTER_STATE* pState);
    HRESULT         CompleteStateChange(FILTER_STATE OldState);
    HRESULT         OnReceiveFirstSample(IMediaSample* pMediaSample);

    // blt from source in VPObject to the output surface
    HRESULT         DoRenderSample( IMediaSample* pSample, LPDIRECTDRAWSURFACE7 pDestSurface, const DDVIDEOPORTNOTIFY& notify, const VPInfo& vpInfo );
    HRESULT         AttachVideoPortToSurface()
                    {
                        HRESULT hRes = m_pIVPObject->AttachVideoPortToSurface();
                        if( SUCCEEDED( hRes ) ) {
                            hRes = m_pIVPObject->SignalNewVP();
                        }
                        return hRes;
                    };
    HRESULT         InitVideo();

    // allocator related functions
    BOOL         UsingOurAllocator() { return m_bUsingOurAllocator; }
    STDMETHODIMP GetAllocator(IMemAllocator** ppAllocator);
    STDMETHODIMP NotifyAllocator(IMemAllocator* pAllocator,BOOL bReadOnly);
    HRESULT      OnSetProperties(ALLOCATOR_PROPERTIES* pRequest, ALLOCATOR_PROPERTIES* pActual);
    HRESULT      OnAlloc(CDDrawMediaSample** ppSampleList, DWORD dwSampleCount);
    HRESULT      OnGetBuffer(   IMediaSample** ppSample,
                                REFERENCE_TIME* pStartTime,
                                REFERENCE_TIME* pEndTime,
                                DWORD dwFlags);
    HRESULT      OnReleaseBuffer(IMediaSample* pIMediaSample);
    HRESULT      CreateDDrawSurface(CMediaType* pMediaType,
                                    DWORD* dwMaxBufferCount, 
                                    LPDIRECTDRAWSURFACE7* ppDDrawSurface);

    // some helper functions
    BOOL    IsCompletelyConnected() { return m_bConnected; }
    DWORD   GetPinId() { return m_dwPinId; }
    HRESULT CurrentMediaType(CMediaType* pmt);
    IPin*   CurrentPeer() { return m_Connected; }
    void    DoQualityMessage();
    HRESULT GetSourceAndDest(RECT* prcSource, RECT* prcDest, DWORD* dwWidth, DWORD* dwHeight);
 
    HRESULT RestoreDDrawSurface();
    HRESULT SetVideoPortID( DWORD dwIndex );

    // IPinConnection
    // Do you accept this type change in your current state?
    STDMETHODIMP DynamicQueryAccept(const AM_MEDIA_TYPE* pmt);

    //  Set event when EndOfStream receive - do NOT pass it on
    //  This condition is cancelled by a flush or Stop
    STDMETHODIMP NotifyEndOfStream(HANDLE hNotifyEvent);

    //  Are you an 'end pin'
    STDMETHODIMP IsEndPin();
    STDMETHODIMP DynamicDisconnect();

    // functions belonging to IVideoPortControl
    STDMETHODIMP                        EventNotify(long lEventCode, DWORD_PTR lEventParam1,
                                                DWORD_PTR lEventParam2);
    STDMETHODIMP_(LPDIRECTDRAW7)        GetDirectDraw();
    STDMETHODIMP_(const DDCAPS*)        GetHardwareCaps();

    STDMETHODIMP StartVideo();

    STDMETHODIMP GetCaptureInfo(BOOL* lpCapturing,
                                DWORD* lpdwWidth,DWORD* lpdwHeight,
                                BOOL* lpInterleave);

    STDMETHODIMP GetVideoDecimation(IDecimateVideoImage** lplpDVI);
    STDMETHODIMP GetDecimationUsage(DECIMATION_USAGE* lpdwUsage);

    STDMETHODIMP CropSourceRect(VPWININFO* pWinInfo,
                                DWORD dwMinZoomFactorX,
                                DWORD dwMinZoomFactorY);
    STDMETHODIMP SignalNewVP( LPDIRECTDRAWVIDEOPORT pVP );
    // End IVideoPortControl

    // helper functions
    void SetKsMedium(const KSPIN_MEDIUM* pMedium)
            {m_Medium =* pMedium;}
    void SetKsCategory(const GUID* pCategory)
            {m_CategoryGUID =* pCategory;}
    void SetStreamingInKernelMode(BOOL bStreamingInKernelMode)
            {m_bStreamingInKernelMode = bStreamingInKernelMode;}

    // IKsPropertySet implementation
    STDMETHODIMP Set(   REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData,
                        DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData);
    STDMETHODIMP Get(   REFGUID guidPropSet, DWORD dwPropID, LPVOID pInstanceData,
                        DWORD cbInstanceData, LPVOID pPropData, DWORD cbPropData, DWORD* pcbReturned);
    STDMETHODIMP QuerySupported(REFGUID guidPropSet, DWORD dwPropID, DWORD* pTypeSupport);

    // IKsPin implementation
    virtual STDMETHODIMP KsQueryMediums(PKSMULTIPLE_ITEM* pMediumList);
    virtual STDMETHODIMP KsQueryInterfaces(PKSMULTIPLE_ITEM* pInterfaceList);
    STDMETHODIMP    KsCreateSinkPinHandle(KSPIN_INTERFACE& Interface, KSPIN_MEDIUM& Medium)
                        { return E_UNEXPECTED; }
    STDMETHODIMP    KsGetCurrentCommunication(KSPIN_COMMUNICATION* pCommunication,
                            KSPIN_INTERFACE* pInterface, KSPIN_MEDIUM* pMedium);
    STDMETHODIMP    KsPropagateAcquire()
                        { return NOERROR; }
    STDMETHODIMP    KsDeliver(IMediaSample* pSample, ULONG Flags)
                        { return E_UNEXPECTED; }
    STDMETHODIMP    KsMediaSamplesCompleted(PKSSTREAM_SEGMENT StreamSegment)
                        { return E_UNEXPECTED; }
    STDMETHODIMP_(IMemAllocator*) KsPeekAllocator(KSPEEKOPERATION Operation)
                        { return NULL; }
    STDMETHODIMP    KsReceiveAllocator( IMemAllocator* pMemAllocator)
                        { return E_UNEXPECTED; }
    STDMETHODIMP    KsRenegotiateAllocator()
                        { return E_UNEXPECTED; }
    STDMETHODIMP_(LONG) KsIncrementPendingIoCount()
                        { return E_UNEXPECTED; }
    STDMETHODIMP_(LONG) KsDecrementPendingIoCount()
                        { return E_UNEXPECTED; }
    STDMETHODIMP    KsQualityNotify(ULONG Proportion, REFERENCE_TIME TimeDelta)
                        { return E_UNEXPECTED; }
    STDMETHODIMP_(REFERENCE_TIME) KsGetStartTime()
                        { return E_UNEXPECTED; }

    // possible future VP->Overlay support
    DWORD           GetOverlayMinStretch();

    HRESULT         GetAllOutputFormats( const PixelFormatList** ppList );
    HRESULT         GetOutputFormat( DDPIXELFORMAT *);
    HRESULT         InPin_GetVPInfo( VPInfo* pVPInfo );

private:
    REFERENCE_TIME          m_rtNextSample;
    REFERENCE_TIME          m_rtLastRun;
    
    LONG                    m_cOurRef;                      // We maintain reference counting
    bool                    m_bWinInfoSet;                  // if false, Blt full image to full image
    VPWININFO               m_WinInfo;

public:
    IVideoPortObject*       m_pIVPObject;
    IVideoPortInfo*         m_pIVPInfo;
private:
    CVideoPortObj*          m_pVideoPortObject;

    // variables to implement IKsPin and IKsPropertySet
    KSPIN_MEDIUM            m_Medium;
    GUID                    m_CategoryGUID;
    KSPIN_COMMUNICATION     m_Communication;
    BOOL                    m_bStreamingInKernelMode;

    // ddraw stuff
    DWORD                   m_dwBackBufferCount;
    DWORD                   m_dwDirectDrawSurfaceWidth;
    DWORD                   m_dwMinCKStretchFactor;
    BYTE                    m_bSyncOnFill;
    BYTE                    m_bDontFlip ;
    BYTE                    m_bDynamicFormatNeeded;
    BYTE                    m_bNewPaletteSet;
    DWORD                   m_dwUpdateOverlayFlags;
    DWORD                   m_dwInterlaceFlags;
    DWORD                   m_dwFlipFlag;
    DWORD                   m_dwFlipFlag2;
    BOOL                    m_bConnected;
    BOOL                    m_bUsingOurAllocator;
    HDC                     m_hMemoryDC;
    BOOL                    m_bCanOverAllocateBuffers;

    BOOL                    m_bRuntimeNegotiationFailed;


    // Track frame delivery for QM
    REFERENCE_TIME          m_trLastFrame;

    HRESULT DrawGDISample(IMediaSample* pMediaSample);
    HRESULT DoRenderGDISample(IMediaSample* pMediaSample);

    // Decimation related functions and variables
    HRESULT QueryDecimationOnPeer(long lWidth, long lHeight);

    enum {
        DECIMATION_NOT_SUPPORTED,   // decimation not supported
        DECIMATING_SIZE_SET,        // decimation image size changed
        DECIMATING_SIZE_NOTSET,     // decimation size didn't change
        DECIMATING_SIZE_RESET,      // decimation has been reset
    };

    HRESULT ResetDecimationIfSet();
    HRESULT TryDecoderDecimation(VPWININFO* pWinInfo);
    BOOL    BeyondOverlayCaps(DWORD ScaleFactor);
    void    ApplyDecimation(VPWININFO* pWinInfo);
    BOOL    Running();
    HRESULT GetUpstreamFilterName(TCHAR* FilterName);

    BOOL    m_bDecimating;
    LONG    m_lWidth;
    LONG    m_lHeight;
    LONG    m_lSrcWidth;
    LONG    m_lSrcHeight;

    // IPinConnection stuff
    HANDLE  m_hEndOfStream;
};


class CVPMOutputPin
: public CBaseOutputPin
, public CVPMPin
{
public:
                CVPMOutputPin(TCHAR* pObjectName, CVPMFilter& pFilter,
                            HRESULT* phr, LPCWSTR pPinName, DWORD dwPinNo);
                ~CVPMOutputPin();

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void**  ppv);

    HRESULT     CompleteConnect(IPin* pReceivePin);
    HRESULT     BreakConnect();
    HRESULT     CheckMediaType(const CMediaType* mtOut);
    HRESULT     GetMediaType(int iPosition,CMediaType* pmtOut);
    HRESULT     SetMediaType(const CMediaType* pmt);
    HRESULT     CheckConnect(IPin*  pPin);

    // override Notify method to keep base classes happy
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q);

    // HRESULT Active() { return NOERROR; }    // override this as we don't have any allocator
    // HRESULT Inactive() { return NOERROR; }  // override this as we don't have any allocator

    HRESULT     InitAllocator(IMemAllocator** ppAlloc);
    HRESULT     DecideBufferSize(IMemAllocator*  pAlloc, ALLOCATOR_PROPERTIES*  pProp);
    IPin*       CurrentPeer()
                    { return m_Connected; }
    HRESULT     DecideAllocator( IMemInputPin *pPin, IMemAllocator **ppAlloc );

    // get the next sample/surface to blt into
    HRESULT     GetNextBuffer( LPDIRECTDRAWSURFACE7* ppSurface, IMediaSample** pSample );
    HRESULT     SendSample( IMediaSample* pSample );

private:
    IUnknown*               m_pPosition;
};

interface IVideoPortVBIObject;
interface IVPVBINotify;
class CVBIVideoPort;

//==========================================================================
class CVBIInputPin
: public CBaseInputPin
, public IVPVBINotify
, public CVPMPin
{
public:
    CVBIInputPin(TCHAR* pObjectName, CVPMFilter& pFilter,
        HRESULT* phr, LPCWSTR pPinName, DWORD dwID );
    ~CVBIInputPin();

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void** ppv);
    
    // connection related functions
    HRESULT CheckConnect(IPin*  pReceivePin);
    HRESULT CompleteConnect(IPin* pReceivePin);
    HRESULT BreakConnect();
    HRESULT CheckMediaType(const CMediaType* mtOut);
    HRESULT GetMediaType(int iPosition, CMediaType* pMediaType);
    HRESULT SetMediaType(const CMediaType* pmt);

    // streaming functions
    HRESULT     Active();
    HRESULT     Inactive();
    HRESULT     Run(REFERENCE_TIME tStart);
    HRESULT     RunToPause();
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();
    STDMETHODIMP Receive(IMediaSample* pMediaSample);
    STDMETHODIMP EndOfStream(void);

    // allocator related functions
    STDMETHODIMP GetAllocator(IMemAllocator** ppAllocator);
    STDMETHODIMP NotifyAllocator(IMemAllocator* pAllocator,BOOL bReadOnly);

    // some helper fnctions
    CMediaType&     CurrentMediaType() { return m_mt; }
    IPin*           CurrentPeer() { return m_Connected; }
    HRESULT         EventNotify(long lEventCode, DWORD_PTR lEventParam1, DWORD_PTR lEventParam2);

    // ddraw, overlay related functions
    HRESULT         SetDirectDraw(LPDIRECTDRAW7 pDirectDraw);

    // IVPVBINotify functions
    STDMETHODIMP    RenegotiateVPParameters();

    HRESULT         SetVideoPortID( DWORD dwIndex );

private:
    // VideoPort related stuff
    CVBIVideoPort*          m_pVideoPortVBIObject;

    IVideoPortVBIObject*    m_pIVPObject;
    IVPVBINotify*           m_pIVPNotify;

    // ddraw stuff
    LPDIRECTDRAW7           m_pDirectDraw;  // DirectDraw service provide
};

#endif //__VPMPin__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vpm\vpmthread.h ===
// Copyright (c) 1997 - 2000  Microsoft Corporation.  All Rights Reserved.
#ifndef _CVPMThread
#define _CVPMThread

class CVPMFilter;
class CAMEvent;
struct VPNotifyData;

class CVPMThread
{
public:
    CVPMThread( CVPMFilter* pFilter );
    ~CVPMThread();

    HRESULT Run();
    HRESULT Pause();
    HRESULT Stop();
    HRESULT SignalNewVP( LPDIRECTDRAWVIDEOPORT pVP );

    static DWORD WINAPI StaticThreadProc(LPVOID);

protected:
    virtual DWORD   ThreadProc();

private:
    void            ProcessEvents( LPDDVIDEOPORTNOTIFY pNotify);

    HRESULT         AdvanceTimer();

    HANDLE          m_hThread;
    DWORD           m_dwThreadID;

    CVPMFilter*     m_pFilter;
    IReferenceClock*    m_pClock;
    bool            m_fProcessFrames;   // nonzero means process frames, zero means do not.
    DWORD           m_dwCount;
    VPNotifyData*   m_pVPData;

    // mini client server message queue
    struct Message {
        enum Type {
            kVP,
            kEndThread,
            kGraphState
        };
                    Message( Type type )
                    : m_Type( type )
                    {}
        virtual     ~Message() {};
        void        Reply( HRESULT hr );

        Message*    m_pNext;
        CAMEvent    m_eReply;
        HRESULT     m_hrResult;

        Type        m_Type;

    };
    struct MsgQueue: public CCritSec
    {
        MsgQueue();
        CAMEvent        m_ePost;
        Message*        m_pMsgList;

        void            Insert( Message* pMessage );
        Message*        Remove();
    } m_MsgQueue;

    struct VPMessage: public Message
    {
        VPMessage( LPDIRECTDRAWVIDEOPORT pVP )
        : Message( kVP )
        , m_pVP( pVP )
        {}
        LPDIRECTDRAWVIDEOPORT   m_pVP;
    };

    struct EndThreadMessage: public Message
    {
        EndThreadMessage()
        : Message( kEndThread )
        {};
    };

    struct GraphStateMessage: public Message
    {
        GraphStateMessage( FILTER_STATE fs )
        : Message( kGraphState )
        , m_state( fs )
        {};
        FILTER_STATE    m_state;
    };

    HRESULT         Post( Message* pMessage );
private:
    HRESULT ProcessMessage( Message* pMessage, bool* pfQuit );
    HRESULT ProcessVPMsg( VPMessage* pVPMsg );
    HRESULT ProcessGraphStateMsg( GraphStateMessage* pStateMsg );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vpm\vpmthread.cpp ===
// Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include "dvp.h"
#include "vpmthread.h"
#include "VPManager.h"
#include "vpmpin.h"
#include "VPMUtil.h"

struct VPNotifyData
{
    VPNotifyData();

    HRESULT Init( LPDIRECTDRAWVIDEOPORT pVP );
    void    Reset();

    LPDIRECTDRAWVIDEOPORT pVP;
    LPDIRECTDRAWVIDEOPORTNOTIFY pNotify;
    HANDLE              hevSampleAvailable;
    DDVIDEOPORTNOTIFY   vpNotify;
};

VPNotifyData::VPNotifyData()
: pNotify( NULL )
, hevSampleAvailable( NULL )
, pVP( NULL )
{
    ZeroStruct( vpNotify );
    vpNotify.lField=1234; // stick in an invalid value that we can catch later (we except -1,0 or 1)
}

HRESULT VPNotifyData::Init( LPDIRECTDRAWVIDEOPORT pInVP )
{
    Reset();
    if( pInVP ) {
        pVP = pInVP;
        // add a ref since we're keeping 
        pVP->AddRef();

        HRESULT hr = pVP->QueryInterface( IID_IDirectDrawVideoPortNotify, (LPVOID *) &pNotify );
        if( SUCCEEDED( hr )) {
            hr = pNotify->AcquireNotification( &hevSampleAvailable, &vpNotify );
        } else {
            ASSERT( !"Failed IDirectDrawVideoPortNotify" );
        }
        if( SUCCEEDED( hr )) {
            // what does this do ? Signals the kernel we have it & advances to next frame ?
            vpNotify.lDone = 1;
        } else {
            ASSERT( !"Failed AcquireNotification" );
        }
        return hr;
    } else {
        return S_OK;
    }
}

void VPNotifyData::Reset()
{
    // Owning object told us the video port object changed.
    if ( pNotify && hevSampleAvailable ) {
        pNotify->ReleaseNotification( hevSampleAvailable );
    }
    hevSampleAvailable  = NULL;
    RELEASE( pNotify );
    RELEASE( pVP );
}

CVPMThread::CVPMThread( CVPMFilter* pFilter )
: m_hThread( NULL )
, m_dwThreadID( 0 )
, m_pFilter( pFilter )
, m_fProcessFrames( false )
, m_dwCount( 0 )
, m_pVPData( new VPNotifyData )
{
    AMTRACE((TEXT("CVPMThread::CVPMThread")));

    m_hThread = CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE) StaticThreadProc, this, 0, &m_dwThreadID );
}

CVPMThread::~CVPMThread()
{
    AMTRACE((TEXT("CVPMThread::~CVPMThread")));
    if ( m_hThread )
    {
        EndThreadMessage msg;
        Post( &msg );
        WaitForSingleObject( m_hThread, INFINITE );
    }
    delete m_pVPData;
}

void CVPMThread::ProcessEvents( LPDDVIDEOPORTNOTIFY pNotify  )
{
    // must check process frames AND pVP, since ksproxy can tell us to reconfigure while
    // running, which discards the videoport (so fProcessFrames = true & pVP = NULL)
    if( m_fProcessFrames && m_pVPData->pVP ) {
        HRESULT hr = m_pFilter->ProcessNextSample( *pNotify );
        // HR can come back as DDERR_SURFACELOST if we're in a DX game / fullscreen DOS box
        // for now, just keep going since we don't know when we get back
        // from the dx game
    }
    InterlockedExchange( &pNotify->lDone, 1 );
}

EXTERN_C const GUID DECLSPEC_SELECTANY IID_IDirectDrawVideoPortNotify \
        = { 0xA655FB94,0x0589,0x4E57,0xB3,0x33,0x56,0x7A,0x89,0x46,0x8C,0x88 };

DWORD WINAPI
CVPMThread::StaticThreadProc(LPVOID pContext)
{
    CVPMThread *pThis = (CVPMThread *) pContext;
    return pThis->ThreadProc();
}


DWORD
CVPMThread::ThreadProc()
{
    AMTRACE((TEXT("CVPMThread::ThreadProc")));

    if( m_pVPData ) {
        // Notes:
        //  The video port notifications can occur before we have created the target surface.
        //  - IVPMFilter::ProcessNextSample must decide if the surface is present
        __try
        {
            for(;;)
            {
                HANDLE hHandles[] = {m_MsgQueue.m_ePost, m_pVPData->hevSampleAvailable };
                int numHandles = m_pVPData->pVP ? (int)NUMELMS(hHandles) : (int)NUMELMS(hHandles)-1;
                // Bob interleave is 1/30 sec, so run default timer at twice that (15fps)
                DWORD dwWaitStatus = WaitForMultipleObjects( numHandles, hHandles, FALSE, 66 /*ms*/ );

                switch( dwWaitStatus ) {
                case WAIT_OBJECT_0:
                {
                    Message* pMessage = m_MsgQueue.Remove();
                    if( pMessage ) {
                        bool fQuit;
                        HRESULT hr = ProcessMessage( pMessage, &fQuit );
                        pMessage->Reply( hr );
                        if( fQuit ) {
                            // VPMThread ending
                            ASSERT( m_MsgQueue.Remove() == NULL ); // should be empty
		                    DbgLog((LOG_ERROR, 1, TEXT("VPM Thread leaving") ));
                            __leave;
                        }
                    }
                    break;
                }
                case WAIT_OBJECT_0+1:
                case WAIT_TIMEOUT: // acts like a timer
                {
                    ProcessEvents( &m_pVPData->vpNotify );
                    break;
                }
                default:
                    // Windows message to die
                    ASSERT( !"VPMThread error" );
                    break;
                }
            }
        }
        __finally
        {
            m_pVPData->Reset();
        }
    }
	DbgLog((LOG_ERROR, 1, TEXT("VPM Thread exiting") ));
    return 0;
}

HRESULT
CVPMThread::Run()
{
    GraphStateMessage msg( State_Running );
    return Post( &msg );
}

HRESULT
CVPMThread::Pause()
{
    GraphStateMessage msg( State_Paused );
    return Post( &msg );
}

HRESULT
CVPMThread::Stop()
{
    GraphStateMessage msg( State_Stopped );
    return Post( &msg );
}

HRESULT
CVPMThread::SignalNewVP( LPDIRECTDRAWVIDEOPORT pVP )
{
    VPMessage msg( pVP );
    return Post( &msg );
}

CVPMThread::MsgQueue::MsgQueue()
: m_pMsgList( NULL )
{
}

void CVPMThread::MsgQueue::Insert( Message* pMessage )
{

    CAutoLock lock(this);
    Message* pNode = m_pMsgList;

    // pre-end list
    pMessage->m_pNext = NULL;
    // find last node
    if( pNode ) {
        // find last node
        while( pNode->m_pNext ) {
            pNode = pNode->m_pNext;
        }
        // add after last node
        pNode->m_pNext = pMessage;
    } else {
        // empty list, insert at start
        m_pMsgList = pMessage;
    }
}

CVPMThread::Message* CVPMThread::MsgQueue::Remove()  // remove head
{
    CAutoLock lock(this);
    if( m_pMsgList ) {
        Message* pMsg = m_pMsgList;
        m_pMsgList = pMsg->m_pNext;
        return pMsg;
    } else {
        return NULL;
    }
}

HRESULT CVPMThread::Post( Message* pMessage )
{
    if( GetCurrentThreadId() == m_dwThreadID ) {
        // just execute the message if we're asking ourselves
        bool fIgnoreMe;
        return ProcessMessage( pMessage, &fIgnoreMe );
    } else {
        // otherwise ask server
        m_MsgQueue.Insert( pMessage );
        m_MsgQueue.m_ePost.Set();
        pMessage->m_eReply.Wait();
        return pMessage->m_hrResult;
    }
}

void CVPMThread::Message::Reply( HRESULT hr )
{
    m_hrResult = hr;
    m_eReply.Set();
}

HRESULT CVPMThread::ProcessMessage( Message* pMessage, bool* pfQuit )
{
    *pfQuit = false;

    switch( pMessage->m_Type )
    {
    case Message::kEndThread:
        *pfQuit = true;
        return S_OK;

    case Message::kVP:
        return ProcessVPMsg( static_cast<VPMessage*>( pMessage ) );

    case Message::kGraphState:
        return ProcessGraphStateMsg( static_cast<GraphStateMessage*>( pMessage ) );

    default:
        ASSERT( !"Unknown message type" );
        return E_UNEXPECTED;
    }
}

HRESULT CVPMThread::ProcessVPMsg( VPMessage* pVPMsg )
{
    // Owning object told us the video port object changed.
    return m_pVPData->Init( pVPMsg->m_pVP );
}

HRESULT CVPMThread::ProcessGraphStateMsg( GraphStateMessage* pStateMsg )
{
    switch( pStateMsg->m_state ) {
    case State_Running:
        m_fProcessFrames = true;
        break;
    case State_Paused:
    case State_Stopped:
        m_fProcessFrames = false;
        break;

    default:
        ASSERT( !"Unknown state" );
        m_fProcessFrames = false;
        return E_INVALIDARG;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vpm\vpmutil.cpp ===
/******************************Module*Header*******************************\
* Module Name: CVPMFilter.cpp
*
*
*
*
* Created: Tue 02/15/2000
* Author:  Glenn Evans [GlennE]
*
* Copyright (c) 2000 Microsoft Corporation
\**************************************************************************/
#include <streams.h>
#include <windowsx.h>
#include <limits.h>

#ifdef FILTER_DLL
#include <initguid.h>
#endif

#include "VPMUtil.h"
#include "DRect.h"

#include <VPManager.h>
#include <VPMPin.h>

// VIDEOINFOHEADER1/2
#include <dvdmedia.h>

const TCHAR chRegistryKey[] = TEXT("Software\\Microsoft\\Multimedia\\ActiveMovie Filters\\VideoPort Manager");
#define PALETTE_VERSION                     1

const BITMAPINFOHEADER *VPMUtil::GetbmiHeader( const CMediaType *pMediaType )
{
    return GetbmiHeader( const_cast<CMediaType *>(pMediaType) );
}

BITMAPINFOHEADER *VPMUtil::GetbmiHeader( CMediaType *pMediaType)
{
    BITMAPINFOHEADER *pHeader = NULL;

    if (!pMediaType)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pMediaType is NULL")));
        goto CleanUp;
    }

    if (!(pMediaType->pbFormat))
    {
        DbgLog((LOG_ERROR, 1, TEXT("pMediaType->pbFormat is NULL")));
        goto CleanUp;
    }

    if ((pMediaType->formattype == FORMAT_VideoInfo) &&
        (pMediaType->cbFormat >= sizeof(VIDEOINFOHEADER)))
    {
        pHeader = &(((VIDEOINFOHEADER*)(pMediaType->pbFormat))->bmiHeader);
        goto CleanUp;
    }


    if ((pMediaType->formattype == FORMAT_VideoInfo2) &&
        (pMediaType->cbFormat >= sizeof(VIDEOINFOHEADER2)))

    {
        pHeader = &(((VIDEOINFOHEADER2*)(pMediaType->pbFormat))->bmiHeader);
        goto CleanUp;
    }
CleanUp:
    return pHeader;
}

// Return the bit masks for the true colour VIDEOINFO or VIDEOINFO2 provided
const DWORD *VPMUtil::GetBitMasks(const CMediaType *pMediaType)
{
    static DWORD FailMasks[] = {0,0,0};
    const DWORD *pdwBitMasks = NULL;

    if (!pMediaType)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pMediaType is NULL")));
        goto CleanUp;
    }

    const BITMAPINFOHEADER *pHeader = GetbmiHeader(pMediaType);
    if (!pHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pHeader is NULL")));
        goto CleanUp;
    }

    if (pHeader->biCompression != BI_RGB)
    {
        pdwBitMasks = (const DWORD *)((LPBYTE)pHeader + pHeader->biSize);
        goto CleanUp;

    }

    ASSERT(pHeader->biCompression == BI_RGB);
    switch (pHeader->biBitCount)
    {
    case 16:
        {
            pdwBitMasks = bits555;
            break;
        }
    case 24:
        {
            pdwBitMasks = bits888;
            break;
        }

    case 32:
        {
            pdwBitMasks = bits888;
            break;
        }
    default:
        {
            pdwBitMasks = FailMasks;
            break;
        }
    }

CleanUp:
    return pdwBitMasks;
}

// Return the pointer to the byte after the header
const BYTE* VPMUtil::GetColorInfo(const CMediaType *pMediaType)
{
    BYTE *pColorInfo = NULL;

    if (!pMediaType)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pMediaType is NULL")));
        goto CleanUp;
    }

    const BITMAPINFOHEADER *pHeader = GetbmiHeader(pMediaType);
    if (!pHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pHeader is NULL")));
        goto CleanUp;
    }

    pColorInfo = ((LPBYTE)pHeader + pHeader->biSize);

CleanUp:
    return pColorInfo;
}

// checks whether the mediatype is palettised or not
HRESULT VPMUtil::IsPalettised(const CMediaType& mediaType, BOOL *pPalettised)
{
    HRESULT hr = NOERROR;

    if (!pPalettised)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pPalettised is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    const BITMAPINFOHEADER *pHeader = GetbmiHeader(&mediaType);
    if (!pHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pHeader is NULL")));
        hr = E_FAIL;
        goto CleanUp;
    }

    if (pHeader->biBitCount <= iPALETTE)
        *pPalettised = TRUE;
    else
        *pPalettised = FALSE;

CleanUp:
    return hr;
}

HRESULT VPMUtil::GetPictAspectRatio(const CMediaType& mediaType, DWORD *pdwPictAspectRatioX, DWORD *pdwPictAspectRatioY)
{
    HRESULT hr = NOERROR;

    if (!(mediaType.pbFormat))
    {
        DbgLog((LOG_ERROR, 1, TEXT("mediaType.pbFormat is NULL")));
        goto CleanUp;
    }

    if (!pdwPictAspectRatioX)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pdwPictAspectRatioX is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (!pdwPictAspectRatioY)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pdwPictAspectRatioY is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }


    if ((mediaType.formattype == FORMAT_VideoInfo) &&
        (mediaType.cbFormat >= sizeof(VIDEOINFOHEADER)))
    {
        *pdwPictAspectRatioX = abs(((VIDEOINFOHEADER*)(mediaType.pbFormat))->bmiHeader.biWidth);
        *pdwPictAspectRatioY = abs(((VIDEOINFOHEADER*)(mediaType.pbFormat))->bmiHeader.biHeight);
        goto CleanUp;
    }

    if ((mediaType.formattype == FORMAT_VideoInfo2) &&
        (mediaType.cbFormat >= sizeof(VIDEOINFOHEADER2)))
    {
        *pdwPictAspectRatioX = ((VIDEOINFOHEADER2*)(mediaType.pbFormat))->dwPictAspectRatioX;
        *pdwPictAspectRatioY = ((VIDEOINFOHEADER2*)(mediaType.pbFormat))->dwPictAspectRatioY;
        goto CleanUp;
    }

CleanUp:
    return hr;
}



// get the InterlaceFlags from the mediatype. If the format is VideoInfo, it returns
// the flags as zero.
HRESULT VPMUtil::GetInterlaceFlagsFromMediaType(const CMediaType& mediaType, DWORD *pdwInterlaceFlags)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("GetInterlaceFlagsFromMediaType")));

    if (!pdwInterlaceFlags)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pRect is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    // get the header just to make sure the mediatype is ok
    const BITMAPINFOHEADER *pHeader = GetbmiHeader(&mediaType);
    if (!pHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pHeader is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    if (mediaType.formattype == FORMAT_VideoInfo)
    {
        *pdwInterlaceFlags = 0;
    }
    else if (mediaType.formattype == FORMAT_VideoInfo2)
    {
        *pdwInterlaceFlags = ((VIDEOINFOHEADER2*)(mediaType.pbFormat))->dwInterlaceFlags;
    }

CleanUp:
    return hr;
}

// this function just tells whether each sample consists of one or two fields
static BOOL DisplayingFields(DWORD dwInterlaceFlags)
{
   if ((dwInterlaceFlags & AMINTERLACE_IsInterlaced) &&
        (dwInterlaceFlags & AMINTERLACE_1FieldPerSample))
        return TRUE;
    else
        return FALSE;
}

// get the rcSource from the mediatype
// if rcSource is empty, it means take the whole image
HRESULT VPMUtil::GetSrcRectFromMediaType(const CMediaType& mediaType, RECT *pRect)
{
    HRESULT hr = NOERROR;
    LONG dwWidth = 0, dwHeight = 0;

    AMTRACE((TEXT("GetSrcRectFromMediaType")));

    if (!pRect)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pRect is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    const BITMAPINFOHEADER *pHeader = GetbmiHeader(&mediaType);
    if (!pHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pHeader is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    dwWidth = abs(pHeader->biWidth);
    dwHeight = abs(pHeader->biHeight);

    ASSERT((mediaType.formattype == FORMAT_VideoInfo) || (mediaType.formattype == FORMAT_VideoInfo2));

    if (mediaType.formattype == FORMAT_VideoInfo)
    {
        *pRect = ((VIDEOINFOHEADER*)(mediaType.pbFormat))->rcSource;
    }
    else if (mediaType.formattype == FORMAT_VideoInfo2)
    {
        *pRect = ((VIDEOINFOHEADER2*)(mediaType.pbFormat))->rcSource;
    }

    DWORD dwInterlaceFlags;
    if (SUCCEEDED(GetInterlaceFlagsFromMediaType(mediaType, &dwInterlaceFlags)) &&
       DisplayingFields(dwInterlaceFlags)) {

        // we do not check if pRect->right > dwWidth, because the dwWidth might be the
        // pitch at this time
        if (pRect->left < 0   ||
            pRect->top < 0    ||
            pRect->right < 0   ||
            (pRect->bottom / 2) > (LONG)dwHeight ||
            pRect->left > pRect->right ||
            pRect->top > pRect->bottom)
        {
            DbgLog((LOG_ERROR, 1, TEXT("rcSource of mediatype is invalid")));
            hr = E_INVALIDARG;
            goto CleanUp;
        }
    }
    else {
        // we do not check if pRect->right > dwWidth, because the dwWidth might be the
        // pitch at this time
        if (pRect->left < 0   ||
            pRect->top < 0    ||
            pRect->right < 0   ||
            pRect->bottom > (LONG)dwHeight ||
            pRect->left > pRect->right ||
            pRect->top > pRect->bottom)
        {
            DbgLog((LOG_ERROR, 1, TEXT("rcSource of mediatype is invalid")));
            hr = E_INVALIDARG;
            goto CleanUp;
        }
    }

    // An empty rect means the whole image, Yuck!
    if (IsRectEmpty(pRect))
        SetRect(pRect, 0, 0, dwWidth, dwHeight);

    // if either the width or height is zero then better set the whole
    // rect to be empty so that the callee can catch it that way
    if (WIDTH(pRect) == 0 || HEIGHT(pRect) == 0)
        SetRect(pRect, 0, 0, 0, 0);

CleanUp:
    return hr;
}


// this also comes in useful when using the IEnumMediaTypes interface so
// that you can copy a media type, you can do nearly the same by creating
// a CMediaType object but as soon as it goes out of scope the destructor
// will delete the memory it allocated (this takes a copy of the memory)

AM_MEDIA_TYPE* VPMUtil::AllocVideoMediaType(const AM_MEDIA_TYPE * pmtSource, GUID formattype)
{
    DWORD dwFormatSize = 0;
    BYTE *pFormatPtr = NULL;
    AM_MEDIA_TYPE *pMediaType = NULL;
    HRESULT hr = NOERROR;

    if (formattype == FORMAT_VideoInfo)
        dwFormatSize = sizeof(VIDEOINFO);
    else if (formattype == FORMAT_VideoInfo2)
        dwFormatSize = sizeof(TRUECOLORINFO) + sizeof(VIDEOINFOHEADER2) + 4;    // actually this should be sizeof sizeof(VIDEOINFO2) once we define that

    pMediaType = (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));
    if (!pMediaType)
    {
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    pFormatPtr = (BYTE *)CoTaskMemAlloc(dwFormatSize);
    if (!pFormatPtr)
    {
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    if (pmtSource)
    {
        *pMediaType = *pmtSource;
        pMediaType->cbFormat = dwFormatSize;
        CopyMemory(pFormatPtr, pmtSource->pbFormat, pmtSource->cbFormat);
    }
    else
    {
        ZeroStruct( *pMediaType );
        ZeroMemory(pFormatPtr, dwFormatSize);
        pMediaType->majortype = MEDIATYPE_Video;
        pMediaType->formattype = formattype;
        pMediaType->cbFormat = dwFormatSize;
    }
    pMediaType->pbFormat = pFormatPtr;

CleanUp:
    if (FAILED(hr))
    {
        if (pMediaType)
        {
            CoTaskMemFree((PVOID)pMediaType);
            pMediaType = NULL;
        }
        if (!pFormatPtr)
        {
            CoTaskMemFree((PVOID)pFormatPtr);
            pFormatPtr = NULL;
        }
    }
    return pMediaType;
}

// Helper function converts a DirectDraw surface to a media type.
// The surface description must have:
//  Height
//  Width
//  lPitch
//  PixelFormat

// Initialise our output type based on the DirectDraw surface. As DirectDraw
// only deals with top down display devices so we must convert the height of
// the surface returned in the DDSURFACEDESC into a negative height. This is
// because DIBs use a positive height to indicate a bottom up image. We also
// initialise the other VIDEOINFO fields although they're hardly ever needed

AM_MEDIA_TYPE *VPMUtil::ConvertSurfaceDescToMediaType(const LPDDSURFACEDESC pSurfaceDesc, BOOL bInvertSize, CMediaType cMediaType)
{
    HRESULT hr = NOERROR;
    AM_MEDIA_TYPE *pMediaType = NULL;

    if ((*cMediaType.FormatType() != FORMAT_VideoInfo ||
        cMediaType.FormatLength() < sizeof(VIDEOINFOHEADER)) &&
        (*cMediaType.FormatType() != FORMAT_VideoInfo2 ||
        cMediaType.FormatLength() < sizeof(VIDEOINFOHEADER2)))
    {
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    pMediaType = AllocVideoMediaType(&cMediaType, cMediaType.formattype);
    if (pMediaType == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    BITMAPINFOHEADER *pbmiHeader = GetbmiHeader((CMediaType*)pMediaType);
    if (!pbmiHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pbmiHeader is NULL, UNEXPECTED!!")));
        hr = E_FAIL;
        goto CleanUp;
    }

    // Convert a DDSURFACEDESC into a BITMAPINFOHEADER (see notes later). The
    // bit depth of the surface can be retrieved from the DDPIXELFORMAT field
    // in the DDpSurfaceDesc-> The documentation is a little misleading because
    // it says the field is permutations of DDBD_*'s however in this case the
    // field is initialised by DirectDraw to be the actual surface bit depth

    pbmiHeader->biSize = sizeof(BITMAPINFOHEADER);

    if (pSurfaceDesc->dwFlags & DDSD_PITCH)
    {
        pbmiHeader->biWidth = pSurfaceDesc->lPitch;
        // Convert the pitch from a byte count to a pixel count.
        // For some weird reason if the format is not a standard bit depth the
        // width field in the BITMAPINFOHEADER should be set to the number of
        // bytes instead of the width in pixels. This supports odd YUV formats
        // like IF09 which uses 9bpp.
        int bpp = pSurfaceDesc->ddpfPixelFormat.dwRGBBitCount;
        if (bpp == 8 || bpp == 16 || bpp == 24 || bpp == 32)
        {
            pbmiHeader->biWidth /= (bpp / 8);   // Divide by number of BYTES per pixel.
        }
    }
    else
    {
        pbmiHeader->biWidth = pSurfaceDesc->dwWidth;
        // BUGUBUG -- Do something odd here with strange YUV pixel formats?  Or does it matter?
    }

    pbmiHeader->biHeight = pSurfaceDesc->dwHeight;
    if (bInvertSize)
    {
        pbmiHeader->biHeight = -pbmiHeader->biHeight;
    }
    pbmiHeader->biPlanes        = 1;
    pbmiHeader->biBitCount      = (USHORT) pSurfaceDesc->ddpfPixelFormat.dwRGBBitCount;
    pbmiHeader->biCompression   = pSurfaceDesc->ddpfPixelFormat.dwFourCC;
    pbmiHeader->biClrUsed       = 0;
    pbmiHeader->biClrImportant  = 0;


    // For true colour RGB formats tell the source there are bit fields
    if (pbmiHeader->biCompression == BI_RGB)
    {
        if (pbmiHeader->biBitCount == 16 || pbmiHeader->biBitCount == 32)
        {
            pbmiHeader->biCompression = BI_BITFIELDS;
        }
    }

    if (pbmiHeader->biBitCount <= iPALETTE)
    {
        pbmiHeader->biClrUsed = 1 << pbmiHeader->biBitCount;
    }

    pbmiHeader->biSizeImage = DIBSIZE(*pbmiHeader);



    // The RGB bit fields are in the same place as for YUV formats
    if (pbmiHeader->biCompression != BI_RGB)
    {
        DWORD *pdwBitMasks = NULL;
        pdwBitMasks = (DWORD*)(VPMUtil::GetBitMasks((const CMediaType *)pMediaType));
        if ( ! pdwBitMasks )
        {
            hr = E_OUTOFMEMORY;
            goto CleanUp;
        }
        // GetBitMasks only returns the pointer to the actual bitmasks
        // in the mediatype if biCompression == BI_BITFIELDS
        pdwBitMasks[0] = pSurfaceDesc->ddpfPixelFormat.dwRBitMask;
        pdwBitMasks[1] = pSurfaceDesc->ddpfPixelFormat.dwGBitMask;
        pdwBitMasks[2] = pSurfaceDesc->ddpfPixelFormat.dwBBitMask;
    }

    // And finish it off with the other media type fields
    pMediaType->subtype = GetBitmapSubtype(pbmiHeader);
    pMediaType->lSampleSize = pbmiHeader->biSizeImage;

    // set the src and dest rects if necessary
    if (pMediaType->formattype == FORMAT_VideoInfo)
    {
        VIDEOINFOHEADER *pVideoInfo = (VIDEOINFOHEADER *)pMediaType->pbFormat;
        VIDEOINFOHEADER *pSrcVideoInfo = (VIDEOINFOHEADER *)cMediaType.pbFormat;

        // if the surface allocated is different than the size specified by the decoder
        // then use the src and dest to ask the decoder to clip the video
        if ((abs(pVideoInfo->bmiHeader.biHeight) != abs(pSrcVideoInfo->bmiHeader.biHeight)) ||
            (abs(pVideoInfo->bmiHeader.biWidth) != abs(pSrcVideoInfo->bmiHeader.biWidth)))
        {
            if (IsRectEmpty(&(pVideoInfo->rcSource)))
            {
                pVideoInfo->rcSource.left = pVideoInfo->rcSource.top = 0;
                pVideoInfo->rcSource.right = pSurfaceDesc->dwWidth;
                pVideoInfo->rcSource.bottom = pSurfaceDesc->dwHeight;
            }
            if (IsRectEmpty(&(pVideoInfo->rcTarget)))
            {
                pVideoInfo->rcTarget.left = pVideoInfo->rcTarget.top = 0;
                pVideoInfo->rcTarget.right = pSurfaceDesc->dwWidth;
                pVideoInfo->rcTarget.bottom = pSurfaceDesc->dwHeight;
            }
        }
    }
    else if (pMediaType->formattype == FORMAT_VideoInfo2)
    {
        VIDEOINFOHEADER2 *pVideoInfo2 = (VIDEOINFOHEADER2 *)pMediaType->pbFormat;
        VIDEOINFOHEADER2 *pSrcVideoInfo2 = (VIDEOINFOHEADER2 *)cMediaType.pbFormat;

        // if the surface allocated is different than the size specified by the decoder
        // then use the src and dest to ask the decoder to clip the video
        if ((abs(pVideoInfo2->bmiHeader.biHeight) != abs(pSrcVideoInfo2->bmiHeader.biHeight)) ||
            (abs(pVideoInfo2->bmiHeader.biWidth) != abs(pSrcVideoInfo2->bmiHeader.biWidth)))
        {
            if (IsRectEmpty(&(pVideoInfo2->rcSource)))
            {
                pVideoInfo2->rcSource.left = pVideoInfo2->rcSource.top = 0;
                pVideoInfo2->rcSource.right = pSurfaceDesc->dwWidth;
                pVideoInfo2->rcSource.bottom = pSurfaceDesc->dwHeight;
            }
            if (IsRectEmpty(&(pVideoInfo2->rcTarget)))
            {
                pVideoInfo2->rcTarget.left = pVideoInfo2->rcTarget.top = 0;
                pVideoInfo2->rcTarget.right = pSurfaceDesc->dwWidth;
                pVideoInfo2->rcTarget.bottom = pSurfaceDesc->dwHeight;
            }
        }
    }

CleanUp:
    if (FAILED(hr))
    {
        if (pMediaType)
        {
            FreeMediaType(*pMediaType);
            pMediaType = NULL;
        }
    }
    return pMediaType;
}

/******************************Public*Routine******************************\
* GetRegistryDword
*
*
*
\**************************************************************************/
int
VPMUtil::GetRegistryDword(
    HKEY hk,
    const TCHAR *pKey,
    int iDefault
)
{
    HKEY hKey;
    LONG lRet;
    int  iRet = iDefault;

    lRet = RegOpenKeyEx(hk, chRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD   dwType, dwLen;

        dwLen = sizeof(iRet);
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, pKey, 0L, &dwType,
                                             (LPBYTE)&iRet, &dwLen)) {
            iRet = iDefault;
        }
        RegCloseKey(hKey);
    }
    return iRet;
}

static const TCHAR szPropPage[] = TEXT("Property Pages");

int
VPMUtil::GetPropPagesRegistryDword( int iDefault )
{
    return VPMUtil::GetRegistryDword(HKEY_CURRENT_USER, szPropPage, iDefault );
}

/******************************Public*Routine******************************\
* SetRegistryDword
*
*
*
\**************************************************************************/
LONG
VPMUtil::SetRegistryDword(
    HKEY hk,
    const TCHAR *pKey,
    int iRet
)
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(hk, chRegistryKey, &hKey);
    if (lRet == ERROR_SUCCESS) {

        lRet = RegSetValueEx(hKey, pKey, 0L, REG_DWORD,
                             (LPBYTE)&iRet, sizeof(iRet));
        RegCloseKey(hKey);
    }
    return lRet;
}


// This function allocates a shared memory block for use by the upstream filter
// generating DIBs to render. The memory block is created in shared
// memory so that GDI doesn't have to copy the memory in BitBlt
HRESULT VPMUtil::CreateDIB(LONG lSize, BITMAPINFO *pBitMapInfo, DIBDATA *pDibData)
{
    HRESULT hr = NOERROR;
    BYTE *pBase = NULL;            // Pointer to the actual image
    HANDLE hMapping = NULL;        // Handle to mapped object
    HBITMAP hBitmap = NULL;        // DIB section bitmap handle
    DWORD dwError = 0;

    AMTRACE((TEXT("CreateDIB")));

    // Create a file mapping object and map into our address space
    hMapping = CreateFileMapping(hMEMORY, NULL,  PAGE_READWRITE,  (DWORD) 0, lSize, NULL);           // No name to section
    if (hMapping == NULL)
    {
        dwError = GetLastError();
        hr = AmHresultFromWin32(dwError);
        goto CleanUp;
    }

    // create the DibSection
    hBitmap = CreateDIBSection((HDC)NULL, pBitMapInfo, DIB_RGB_COLORS,
        (void**) &pBase, hMapping, (DWORD) 0);
    if (hBitmap == NULL || pBase == NULL)
    {
        dwError = GetLastError();
        hr = AmHresultFromWin32(dwError);
        goto CleanUp;
    }

    // Initialise the DIB information structure
    pDibData->hBitmap = hBitmap;
    pDibData->hMapping = hMapping;
    pDibData->pBase = pBase;
    pDibData->PaletteVersion = PALETTE_VERSION;
    GetObject(hBitmap, sizeof(DIBSECTION), (void*)&(pDibData->DibSection));

CleanUp:
    if (FAILED(hr))
    {
        EXECUTE_ASSERT(CloseHandle(hMapping));
    }
    return hr;
}

// DeleteDIB
//
// This function just deletes DIB's created by the above CreateDIB function.
//
HRESULT VPMUtil::DeleteDIB(DIBDATA *pDibData)
{
    if (!pDibData)
    {
        return E_INVALIDARG;
    }

    if (pDibData->hBitmap)
    {
        DeleteObject(pDibData->hBitmap);
    }

    if (pDibData->hMapping)
    {
        CloseHandle(pDibData->hMapping);
    }

    ZeroStruct( *pDibData );

    return NOERROR;
}


// function used to blt the data from the source to the target dc
void VPMUtil::FastDIBBlt(DIBDATA *pDibData, HDC hTargetDC, HDC hSourceDC, RECT *prcTarget, RECT *prcSource)
{
    HBITMAP hOldBitmap = NULL;         // Store the old bitmap
    DWORD dwSourceWidth = 0, dwSourceHeight = 0, dwTargetWidth = 0, dwTargetHeight = 0;

    ASSERT(prcTarget);
    ASSERT(prcSource);

    dwSourceWidth = WIDTH(prcSource);
    dwSourceHeight = HEIGHT(prcSource);
    dwTargetWidth = WIDTH(prcTarget);
    dwTargetHeight = HEIGHT(prcTarget);

    hOldBitmap = (HBITMAP) SelectObject(hSourceDC, pDibData->hBitmap);


    // Is the destination the same size as the source
    if ((dwSourceWidth == dwTargetWidth) && (dwSourceHeight == dwTargetHeight))
    {
        // Put the image straight into the target dc
        BitBlt(hTargetDC, prcTarget->left, prcTarget->top, dwTargetWidth,
               dwTargetHeight, hSourceDC, prcSource->left, prcSource->top,
               SRCCOPY);
    }
    else
    {
        // Stretch the image when copying to the target dc
        StretchBlt(hTargetDC, prcTarget->left, prcTarget->top, dwTargetWidth,
            dwTargetHeight, hSourceDC, prcSource->left, prcSource->top,
            dwSourceWidth, dwSourceHeight, SRCCOPY);
    }

    // Put the old bitmap back into the device context so we don't leak
    SelectObject(hSourceDC, hOldBitmap);
}

// funtion used to transfer pixels from the DIB to the target dc
void VPMUtil::SlowDIBBlt(BYTE *pDibBits, BITMAPINFOHEADER *pHeader, HDC hTargetDC, RECT *prcTarget, RECT *prcSource)
{
    DWORD dwSourceWidth = 0, dwSourceHeight = 0, dwTargetWidth = 0, dwTargetHeight = 0;

    ASSERT(prcTarget);
    ASSERT(prcSource);

    dwSourceWidth = WIDTH(prcSource);
    dwSourceHeight = HEIGHT(prcSource);
    dwTargetWidth = WIDTH(prcTarget);
    dwTargetHeight = HEIGHT(prcTarget);

    // Is the destination the same size as the source
    if ((dwSourceWidth == dwTargetWidth) && (dwSourceHeight == dwTargetHeight))
    {
        UINT uStartScan = 0, cScanLines = pHeader->biHeight;

        // Put the image straight into the target dc
        SetDIBitsToDevice(hTargetDC, prcTarget->left, prcTarget->top, dwTargetWidth,
            dwTargetHeight, prcSource->left, prcSource->top, uStartScan, cScanLines,
            pDibBits, (BITMAPINFO*) pHeader, DIB_RGB_COLORS);
    }
    else
    {
        // if the origin of bitmap is bottom-left, adjust soruce_rect_top
        // to be the bottom-left corner instead of the top-left.
        LONG lAdjustedSourceTop = (pHeader->biHeight > 0) ? (pHeader->biHeight - prcSource->bottom) :
            (prcSource->top);

        // stretch the image into the target dc
        StretchDIBits(hTargetDC, prcTarget->left, prcTarget->top, dwTargetWidth,
            dwTargetHeight, prcSource->left, lAdjustedSourceTop, dwSourceWidth, dwSourceHeight,
            pDibBits, (BITMAPINFO*) pHeader, DIB_RGB_COLORS, SRCCOPY);
    }

}

// get the rcTarget from the mediatype, after converting it to base MAX_REL_NUM
// if rcTarget is empty, it means take the whole image
HRESULT VPMUtil::GetDestRectFromMediaType(const CMediaType& mediaType, RECT *pRect)
{
    HRESULT hr = NOERROR;
    LONG dwWidth = 0, dwHeight = 0;

    DbgLog((LOG_TRACE, 5, TEXT("Entering GetDestRectFromMediaType")));

    if (!pRect)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pRect is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    const BITMAPINFOHEADER *pHeader = GetbmiHeader(&mediaType);
    if (!pHeader)
    {
        DbgLog((LOG_ERROR, 1, TEXT("pHeader is NULL")));
        hr = E_INVALIDARG;
        goto CleanUp;
    }

    dwWidth = abs(pHeader->biWidth);
    dwHeight = abs(pHeader->biHeight);

    ASSERT((mediaType.formattype == FORMAT_VideoInfo) || (mediaType.formattype == FORMAT_VideoInfo2));

    if (mediaType.formattype == FORMAT_VideoInfo)
    {
        *pRect = ((VIDEOINFOHEADER*)(mediaType.pbFormat))->rcTarget;
    }
    else if (mediaType.formattype == FORMAT_VideoInfo2)
    {
        *pRect = ((VIDEOINFOHEADER2*)(mediaType.pbFormat))->rcTarget;
    }

    DWORD dwInterlaceFlags;
    if (SUCCEEDED(GetInterlaceFlagsFromMediaType(mediaType, &dwInterlaceFlags)) &&
       DisplayingFields(dwInterlaceFlags)) {

        // we do not check if pRect->right > dwWidth, because the dwWidth might be the
        // pitch at this time
        if (pRect->left < 0   ||
            pRect->top < 0    ||
            pRect->right < 0   ||
            (pRect->bottom / 2) > (LONG)dwHeight ||
            pRect->left > pRect->right ||
            pRect->top > pRect->bottom)
        {
            DbgLog((LOG_ERROR, 1, TEXT("rcTarget of mediatype is invalid")));
            SetRect(pRect, 0, 0, dwWidth, dwHeight);
            hr = E_INVALIDARG;
            goto CleanUp;
        }
    }
    else {
        // we do not check if pRect->right > dwWidth, because the dwWidth might be the
        // pitch at this time
        if (pRect->left < 0   ||
            pRect->top < 0    ||
            pRect->right < 0   ||
            pRect->bottom > (LONG)dwHeight ||
            pRect->left > pRect->right ||
            pRect->top > pRect->bottom)
        {
            DbgLog((LOG_ERROR, 1, TEXT("rcTarget of mediatype is invalid")));
            SetRect(pRect, 0, 0, dwWidth, dwHeight);
            hr = E_INVALIDARG;
            goto CleanUp;
        }
    }

    // An empty rect means the whole image, Yuck!
    if (IsRectEmpty(pRect))
        SetRect(pRect, 0, 0, dwWidth, dwHeight);

    // if either the width or height is zero then better set the whole
    // rect to be empty so that the callee can catch it that way
    if (WIDTH(pRect) == 0 || HEIGHT(pRect) == 0)
        SetRect(pRect, 0, 0, 0, 0);

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving GetDestRectFromMediaType")));
    return hr;
}

/*****************************Private*Routine******************************\
* IsDecimationNeeded
*
* Decimation is needed if the current minimum scale factor (either vertical
* or horizontal) is less than 1000.
*
* History:
* Thu 07/08/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
VPMUtil::IsDecimationNeeded(
    DWORD ScaleFactor
    )
{
    AMTRACE((TEXT("::IsDecimationNeeded")));
    return ScaleFactor < 1000;
}


/*****************************Private*Routine******************************\
* GetCurrentScaleFactor
*
* Determines the x axis scale factor and the y axis scale factor.
* The minimum of these two values is the limiting scale factor.
*
* History:
* Thu 07/08/1999 - StEstrop - Created
*
\**************************************************************************/
DWORD
VPMUtil::GetCurrentScaleFactor(
    const VPWININFO& winInfo,
    DWORD* lpxScaleFactor,
    DWORD* lpyScaleFactor
    )
{
    AMTRACE((TEXT("::GetCurrentScaleFactor")));

    DWORD dwSrcWidth = WIDTH(&winInfo.SrcRect);
    DWORD dwSrcHeight = HEIGHT(&winInfo.SrcRect);

    DWORD dwDstWidth = WIDTH(&winInfo.DestRect);
    DWORD dwDstHeight = HEIGHT(&winInfo.DestRect);

    DWORD xScaleFactor = MulDiv(dwDstWidth, 1000, dwSrcWidth);
    DWORD yScaleFactor = MulDiv(dwDstHeight, 1000, dwSrcHeight);

    if (lpxScaleFactor) *lpxScaleFactor = xScaleFactor;
    if (lpyScaleFactor) *lpyScaleFactor = yScaleFactor;

    return min(xScaleFactor, yScaleFactor);
}


VIDEOINFOHEADER2* VPMUtil::GetVideoInfoHeader2(CMediaType *pMediaType)
{
    if (pMediaType && pMediaType->formattype == FORMAT_VideoInfo2 ) {
        return (VIDEOINFOHEADER2*)(pMediaType->pbFormat);
    } else {
        return NULL;
    }
}

const VIDEOINFOHEADER2* VPMUtil::GetVideoInfoHeader2(const CMediaType *pMediaType)
{
    if (pMediaType && pMediaType->formattype == FORMAT_VideoInfo2 ) {
        return (VIDEOINFOHEADER2*)(pMediaType->pbFormat);
    } else {
        return NULL;
    }
}

/*****************************Private*Routine******************************\
* VPMUtil::EqualPixelFormats
*
* this is just a helper function used by the "NegotiatePixelFormat"
* function. Just compares two pixel-formats to see if they are the
* same. We can't use a memcmp because of the fourcc codes.
*
*
* History:
* Thu 09/09/1999 - GlennE - Added this comment and cleaned up the code
*
\**************************************************************************/
BOOL
VPMUtil::EqualPixelFormats(
    const DDPIXELFORMAT& ddFormat1,
    const DDPIXELFORMAT& ddFormat2)
{
    AMTRACE((TEXT("VPMUtil::EqualPixelFormats")));

    if (ddFormat1.dwFlags & ddFormat2.dwFlags & DDPF_RGB)
    {
        if (ddFormat1.dwRGBBitCount == ddFormat2.dwRGBBitCount &&
            ddFormat1.dwRBitMask == ddFormat2.dwRBitMask &&
            ddFormat1.dwGBitMask == ddFormat2.dwGBitMask &&
            ddFormat1.dwBBitMask == ddFormat2.dwBBitMask)
        {
            return TRUE;
        }
    }
    else if (ddFormat1.dwFlags & ddFormat2.dwFlags & DDPF_FOURCC)
    {
        if (ddFormat1.dwFourCC == ddFormat2.dwFourCC)
        {
            return TRUE;
        }
    }

    return FALSE;
}

struct VPEnumCallback
{
    VPEnumCallback( DDVIDEOPORTCAPS* pVPCaps, DWORD dwVideoPortId )
        : m_pVPCaps( pVPCaps )
        , m_dwVideoPortId( dwVideoPortId )
        , m_fFound( false )
    {};


    HRESULT CompareCaps( LPDDVIDEOPORTCAPS lpCaps )
    {
        if (lpCaps && !m_fFound ) {
            if( lpCaps->dwVideoPortID == m_dwVideoPortId ) {
                if( m_pVPCaps ) {
                    *m_pVPCaps = *lpCaps;
                }
                m_fFound = true;
            }
        }
        return S_OK;
    }

    static HRESULT CALLBACK    EnumCallback( LPDDVIDEOPORTCAPS lpCaps, LPVOID lpContext )
    {
        VPEnumCallback* thisPtr = (VPEnumCallback*)lpContext;
        if (thisPtr) {
            return thisPtr->CompareCaps( lpCaps );
        } else {
            DbgLog((LOG_ERROR,0,
                    TEXT("lpContext = NULL, THIS SHOULD NOT BE HAPPENING!!!")));
            return E_FAIL;
        }
    }
    DDVIDEOPORTCAPS* m_pVPCaps;
    DWORD            m_dwVideoPortId;
    bool             m_fFound;
};


HRESULT VPMUtil::FindVideoPortCaps( IDDVideoPortContainer* pVPContainer, DDVIDEOPORTCAPS* pVPCaps, DWORD dwVideoPortId )
{
    VPEnumCallback state( pVPCaps, dwVideoPortId );

    HRESULT hr = pVPContainer->EnumVideoPorts(0, NULL, &state, state.EnumCallback );
    if( SUCCEEDED( hr )) {
        if( state.m_fFound ) {
            return hr;
        } else {
            return S_FALSE;
        }
    }
    return hr;
}

HRESULT VPMUtil::FindVideoPortCaps( LPDIRECTDRAW7 pDirectDraw, DDVIDEOPORTCAPS* pVPCaps, DWORD dwVideoPortId )
{
    if( !pDirectDraw ) {
        return E_INVALIDARG;
    } else {
        IDDVideoPortContainer* pDVP = NULL;
        HRESULT hr = pDirectDraw->QueryInterface(IID_IDDVideoPortContainer, (LPVOID *)&pDVP);
        if( SUCCEEDED( hr )) {
            hr = FindVideoPortCaps( pDVP, pVPCaps, dwVideoPortId );
            RELEASE( pDVP );
        }
        return hr;
    }
}

void VPMUtil::FixupVideoInfoHeader2(
    VIDEOINFOHEADER2 *pVideoInfo,
    DWORD dwComppression,
    int nBitCount
    )
{
    ASSERT( pVideoInfo ); // should never be called as NULL
    if ( pVideoInfo )
    {
        LPBITMAPINFOHEADER lpbi = &pVideoInfo->bmiHeader;

        lpbi->biSize          = sizeof(BITMAPINFOHEADER);
        lpbi->biPlanes        = (WORD)1;
        lpbi->biBitCount      = (WORD)nBitCount;
        lpbi->biClrUsed   = 0;
        lpbi->biClrImportant = 0;

        //  From input
        lpbi->biXPelsPerMeter = 0; // m_seqInfo.lXPelsPerMeter;
        lpbi->biYPelsPerMeter = 0; // m_seqInfo.lYPelsPerMeter;

        lpbi->biCompression   = dwComppression;
        lpbi->biSizeImage     = GetBitmapSize(lpbi);

        DWORD dwBPP = DIBWIDTHBYTES(*lpbi);
        ASSERT( dwBPP );

        //
        // The "bit" rate is image size in bytes times 8 (to convert to bits)
        // divided by the AvgTimePerFrame.  This result is in bits per 100 nSec,
        // so we multiply by 10000000 to convert to bits per second, this multiply
        // is combined with "times" 8 above so the calculations becomes:
        //
        // BitRate = (biSizeImage * 80000000) / AvgTimePerFrame
        //
        LARGE_INTEGER li;
        li.QuadPart = pVideoInfo->AvgTimePerFrame;
        pVideoInfo->dwBitRate = MulDiv(lpbi->biSizeImage, 80000000,
                                       li.LowPart);
        pVideoInfo->dwBitErrorRate = 0L;
    }
}

void VPMUtil::InitVideoInfoHeader2(
    VIDEOINFOHEADER2 *pVideoInfo )
{
    ASSERT( pVideoInfo ); // should never be called as NULL
    if ( pVideoInfo )
    {
        LPBITMAPINFOHEADER lpbi = &pVideoInfo->bmiHeader;

        lpbi->biSize          = sizeof(BITMAPINFOHEADER);
        lpbi->biPlanes        = (WORD)0;
        lpbi->biBitCount      = (WORD)0;
        lpbi->biClrUsed   = 0;
        lpbi->biClrImportant = 0;

        //  From input
        lpbi->biXPelsPerMeter = 0; // m_seqInfo.lXPelsPerMeter;
        lpbi->biYPelsPerMeter = 0; // m_seqInfo.lYPelsPerMeter;

        lpbi->biCompression   = 0;
        lpbi->biSizeImage     = GetBitmapSize(lpbi);

        lpbi->biWidth = 0;
        lpbi->biHeight = 0;

        //
        // The "bit" rate is image size in bytes times 8 (to convert to bits)
        // divided by the AvgTimePerFrame.  This result is in bits per 100 nSec,
        // so we multiply by 10000000 to convert to bits per second, this multiply
        // is combined with "times" 8 above so the calculations becomes:
        //
        // BitRate = (biSizeImage * 80000000) / AvgTimePerFrame
        //
        LARGE_INTEGER li;
        li.QuadPart = pVideoInfo->AvgTimePerFrame;
        pVideoInfo->dwBitRate = 0;
        pVideoInfo->dwBitErrorRate = 0L;
    }
}
VIDEOINFOHEADER2* VPMUtil::SetToVideoInfoHeader2( CMediaType* pmt, DWORD dwExtraBytes )
{
    VIDEOINFOHEADER2* pVIH2 = (VIDEOINFOHEADER2 *)pmt->ReallocFormatBuffer(sizeof(VIDEOINFOHEADER2)+dwExtraBytes );
    if( pVIH2 ) {
        ZeroStruct( *pVIH2 );

        pmt->majortype = MEDIATYPE_Video;
        pmt->formattype = FORMAT_VideoInfo2;

        pmt->subtype   = MEDIASUBTYPE_None;
        InitVideoInfoHeader2( pVIH2 );
    }
    return pVIH2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vpm\vpmutil.h ===
/******************************Module*Header*******************************\
* Module Name: VPMUtil.h
*
*
*
*
* Created: Tue 05/05/2000
* Author:  GlenneE
*
* Copyright (c) 2000 Microsoft Corporation
\**************************************************************************/
#ifndef __VPMUtil__h
#define __VPMUtil__h

struct VPWININFO;

// global utility functions for the VPM
struct tagVIDEOINFOHEADER2;
typedef struct tagVIDEOINFOHEADER2 VIDEOINFOHEADER2;
#include <dvp.h>

namespace VPMUtil
{
    int             GetRegistryDword(HKEY hk, const TCHAR *pKey, int iDefault);
    int             GetPropPagesRegistryDword( int iDefault );
    LONG            SetRegistryDword( HKEY hk, const TCHAR *pKey, int iRet );
                                   
    BITMAPINFOHEADER* GetbmiHeader( CMediaType *pMediaType); 
    const BITMAPINFOHEADER* GetbmiHeader(const CMediaType *pMediaType);

    HRESULT         GetPictAspectRatio(const CMediaType& pMediaType, DWORD *pdwPictAspectRatioX, DWORD *pdwPictAspectRatioY);
    const DWORD*    WINAPI GetBitMasks(const CMediaType *pMediaType);
    const BYTE*     GetColorInfo(const CMediaType *pMediaType);
    HRESULT         GetSrcRectFromMediaType(const CMediaType& pMediaType, RECT *pRect);
    HRESULT         GetDestRectFromMediaType(const CMediaType& pMediaType, RECT *pRect);

    AM_MEDIA_TYPE*  AllocVideoMediaType(const AM_MEDIA_TYPE * pmtSource, GUID formattype);
    AM_MEDIA_TYPE*  ConvertSurfaceDescToMediaType(const LPDDSURFACEDESC pSurfaceDesc, BOOL bInvertSize, CMediaType cMediaType);
    HRESULT         IsPalettised(const CMediaType& mediaType, BOOL *pPalettised);
    HRESULT         GetInterlaceFlagsFromMediaType(const CMediaType& mediaType, DWORD *pdwInterlaceFlags);

    HRESULT         CreateDIB(LONG lSize, BITMAPINFO *pBitMapInfo, DIBDATA *pDibData);
    HRESULT         DeleteDIB(DIBDATA *pDibData);
    void            FastDIBBlt(DIBDATA *pDibData, HDC hTargetDC, HDC hSourceDC, RECT *prcTarget, RECT *prcSource);
    void            SlowDIBBlt(BYTE *pDibBits, BITMAPINFOHEADER *pHeader, HDC hTargetDC, RECT *prcTarget, RECT *prcSource);

    // decimation
    BOOL            IsDecimationNeeded( DWORD ScaleFactor );

    DWORD           GetCurrentScaleFactor( const VPWININFO& VPWinInfo,
                                   DWORD* lpxScaleFactor = NULL,
                                   DWORD* lpyScaleFactor = NULL);

    VIDEOINFOHEADER2* GetVideoInfoHeader2(CMediaType *pMediaType);
    const VIDEOINFOHEADER2* GetVideoInfoHeader2(const CMediaType *pMediaType);

    BOOL            EqualPixelFormats( const DDPIXELFORMAT& lpFormat1, const DDPIXELFORMAT& lpFormat2);

    HRESULT         FindVideoPortCaps( IDDVideoPortContainer* pVPContainer, LPDDVIDEOPORTCAPS pVPCaps, DWORD dwVideoPortId );
    HRESULT         FindVideoPortCaps( LPDIRECTDRAW7 pDirectDraw, LPDDVIDEOPORTCAPS pVPCaps, DWORD dwVideoPortId );

    void            FixupVideoInfoHeader2( VIDEOINFOHEADER2 *pVideoInfo, DWORD dwComppression, int nBitCount );
    void            InitVideoInfoHeader2( VIDEOINFOHEADER2 *pVideoInfo );
    VIDEOINFOHEADER2* SetToVideoInfoHeader2( CMediaType* pmt, DWORD dwExtraBytes = 0);
};

template <typename T>
__inline void ZeroStruct(T& t)
{
    ZeroMemory(&t, sizeof(t));
}
template <typename T>
__inline void ZeroArray(T* pArray, unsigned uCount)
{
    ZeroMemory(pArray, sizeof(pArray[0])*uCount);
}
template <typename T>
__inline void CopyArray(T* pDest, const T* pSrc, unsigned uCount)
{
    memcpy( pDest, pSrc, sizeof(pDest[0])*uCount);
}
template <typename T>
__inline void INITDDSTRUCT(T& dd)
{
    ZeroStruct(dd);
    dd.dwSize = sizeof(dd);
}

template<typename T>
__inline void RELEASE( T* &p )
{
    if( p ) {
        p->Release();
        p = NULL;
    }
}

#ifndef CHECK_HR
    #define CHECK_HR(expr) do { if (FAILED(expr)) __leave; } while(0);
#endif

#endif //__VPMUtil__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vpm\vpobj.cpp ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <ddraw.h>
#include <VPObj.h>
#include <VPMUtil.h>
#include <dvp.h>
#include <ddkernel.h>

// VIDEOINFOHEADER2
#include <dvdmedia.h>

#include <FormatList.h>
#include <KHandleArray.h>

/******************************Public*Routine******************************\
* CVideoPortObj
*
* constructor
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
CVideoPortObj::CVideoPortObj( LPUNKNOWN pUnk, HRESULT *phr, IVideoPortControl* pVPControl )
: CUnknown(NAME("VP Object"), pUnk)
, m_bConnected( FALSE )
, m_pIVPConfig( NULL )
, m_bVPSyncMaster( FALSE )
, m_pMainObjLock( NULL )
, m_pIVideoPortControl( pVPControl )
, m_pddOutputVideoFormats( NULL )
, m_dwDefaultOutputFormat( 0 )
, m_dwVideoPortId( 0 )
, m_pDVP( NULL )
, m_pVideoPort( NULL )
{
    AMTRACE((TEXT("CVideoPortObj::Constructor")));
    InitVariables();
}

/******************************Public*Routine******************************\
* ~CVideoPortObj
*
* destructor
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
CVideoPortObj::~CVideoPortObj()
{
    AMTRACE((TEXT("CVideoPortObj::Destructor")));

    if (m_bConnected)
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("Destructor called without calling breakconnect")));
        BreakConnect();
    }

    m_pIVideoPortControl = NULL;
}

/******************************Public*Routine******************************\
* CVideoPortObj::NonDelegatingQueryInterface
*
* overridden to expose IVPNotify and IVPObject
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVideoPortObj::NonDelegatingQueryInterface")));

    if (riid == IID_IVPNotify) {
        hr = GetInterface(static_cast<IVPNotify*>(this), ppv);
    }  else if (riid == IID_IVPNotify2) {
        hr = GetInterface(static_cast<IVPNotify2*>(this), ppv);
    } else {
        hr = CUnknown::NonDelegatingQueryInterface(riid, ppv);
    }

    return hr;
}


/*****************************Private*Routine******************************\
* CVideoPortObj::InitVariables
*
* this function only initializes those variables which are supposed to be reset
* on RecreateVideoport
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
void CVideoPortObj::InitVariables()
{
    AMTRACE((TEXT("CVideoPortObj::InitVariables")));

    delete [] m_pddOutputVideoFormats;
    m_pddOutputVideoFormats = NULL;

    m_ddInputVideoFormats.Reset(0);

    ZeroStruct( m_rcDest );
    ZeroStruct( m_rcSource );

    // image dimensions
    m_lImageWidth = 0;
    m_lImageHeight = 0;
    m_lDecoderImageHeight = 0;
    m_lDecoderImageWidth = 0;

    // Capturing information
    m_fCapturing = FALSE;
    m_fCaptureInterleaved = FALSE;
    m_cxCapture = 0;
    m_cyCapture = 0;

    // overlay surface related stuff
    m_pOutputSurface = NULL;       // DirectDraw overlay surface
    m_pOutputSurface1 = NULL;

    m_pChain = NULL;
    m_dwBackBufferCount = 0;
    m_dwOutputSurfaceWidth = 0;
    m_dwOutputSurfaceHeight = 0;
    // m_dwOverlayFlags = 0;

    // vp variables to store flags, current state etc
    m_bStart = FALSE;
    m_VPState = VPInfoState_STOPPED; // current state: running, stopped
    m_CurrentMode = AMVP_MODE_WEAVE;
    // m_StoredMode = m_CurrentMode;
    m_CropState = VPInfoCropState_None;
    m_dwPixelsPerSecond = 0;
    m_bVSInterlaced = FALSE;
    m_fGarbageLine = false;
    m_fHalfHeightVideo = false;

    // vp data structures
    ASSERT( m_pDVP == NULL );
    RELEASE( m_pDVP );

    ASSERT( m_pVideoPort == NULL );
    RELEASE( m_pVideoPort );

    ZeroStruct( m_svpInfo );
    ZeroStruct( m_sBandwidth );
    ZeroStruct( m_vpCaps );
    ZeroStruct( m_ddConnectInfo );
    ZeroStruct( m_VPDataInfo );

    // All the pixel formats (Video/VBI)
    ZeroStruct( m_ddVPInputVideoFormat );
    ZeroStruct( m_ddVPOutputVideoFormat );

    // can we support the different modes
    m_bCanWeave = FALSE;
    m_bCanBobInterleaved = FALSE;
    m_bCanBobNonInterleaved = FALSE;
    m_bCanSkipOdd = FALSE;
    m_bCanSkipEven = FALSE;
    m_bCantInterleaveHalfline = FALSE;

    // decimation parameters
    m_ulDeciStepX = 0;
    m_dwDeciNumX = m_dwDeciDenX = 1000;
    m_ulDeciStepY = 0;
    m_dwDeciNumY = m_dwDeciDenY = 1000;
    m_DecimationModeX = DECIMATE_NONE;
    m_DecimationModeY = DECIMATE_NONE;

    m_bVPDecimating = FALSE;
    m_bDecimating = FALSE;
    m_lWidth = 0;
    m_lHeight = 0;

    // variables to store the current aspect ratio
    m_dwPictAspectRatioX = 1;
    m_dwPictAspectRatioY = 1;

    // misc
    m_CropState = VPInfoCropState_None;
    m_bStoredWinInfoSet = FALSE;
    ZeroStruct( m_StoredWinInfo );
}


/******************************Public*Routine******************************\
* CVideoPortObj::GetDirectDrawVideoPort
*
*
*
* History:
* Mon 10/16/2000 - NWilt - 
*
\**************************************************************************/
STDMETHODIMP
CVideoPortObj::GetDirectDrawVideoPort(LPDIRECTDRAWVIDEOPORT *ppDirectDrawVideoPort)
{
    AMTRACE((TEXT("CVideoPortObj::GetDirectDrawVideoPort")));
    HRESULT hr = NOERROR;

    CAutoLock cObjectLock(m_pMainObjLock);

    if (!ppDirectDrawVideoPort ) {
        DbgLog((LOG_ERROR, 1,
                TEXT("value of ppDirectDrawVideoPort is invalid,")
                TEXT(" ppDirectDrawVideoPort = NULL")));
        return E_INVALIDARG;
    }
    // remove annoying double indirection since we now asserted its not null
    LPDIRECTDRAWVIDEOPORT& pDirectDrawVideoPort = *ppDirectDrawVideoPort;
    if(!m_bConnected)
    {
        // not connected, this function does not make much sense since the
        // surface wouldn't even have been allocated as yet
        DbgLog((LOG_ERROR, 1, TEXT("not connected, exiting")));
        hr = VFW_E_NOT_CONNECTED;
    } else {
        pDirectDrawVideoPort = m_pVideoPort;
        if(! pDirectDrawVideoPort ) {
            hr = E_FAIL;
        } else {
            pDirectDrawVideoPort->AddRef();
        }
    }

    return hr;
}


/******************************Public*Routine******************************\
* CVideoPortObj::SetObjectLock
*
* sets the pointer to the lock, which would be used to synchronize calls
* to the object.  It is the callee's responsiblility to synchronize this call
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::SetObjectLock(CCritSec *pMainObjLock)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVideoPortObj::SetObjectLock")));

    if (!pMainObjLock)
    {
        DbgLog((LOG_ERROR, 0, TEXT("pMainObjLock is NULL")));
        hr = E_INVALIDARG;
    }
    else {
        m_pMainObjLock = pMainObjLock;
    }

    return hr;
}

/******************************Public*Routine******************************\
* CVideoPortObj::SetMediaType
*
* check that the mediatype is acceptable
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::SetMediaType(const CMediaType* pmt)
{
    AMTRACE((TEXT("CVideoPortObj::SetMediaType")));

    CAutoLock cObjectLock(m_pMainObjLock);
    HRESULT hr =  CheckMediaType(pmt);

#if defined(DEBUG)
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("CheckMediaType failed, hr = 0x%x"), hr));
    }
#endif

    return hr;
}


/******************************Public*Routine******************************\
* CVideoPortObj::CheckMediaType
*
* check that the mediatype is acceptable. No lock is taken here.
* It is the callee's responsibility to maintain integrity!
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::CheckMediaType(const CMediaType* pmt)
{
    AMTRACE((TEXT("CVideoPortObj::CheckMediaType")));

    HRESULT hr = VFW_E_TYPE_NOT_ACCEPTED;
    if ((pmt->majortype == MEDIATYPE_Video) &&
        (pmt->subtype == MEDIASUBTYPE_VPVideo) &&
        (pmt->formattype == FORMAT_None))
    {
        // get the hardware caps
        const DDCAPS* pDirectCaps = m_pIVideoPortControl->GetHardwareCaps();
        if( pDirectCaps ) {
            hr = NOERROR;
        } else {
            // ASSERT( !"Warning: No VPE Support detected on video card" ); 
            DbgLog((LOG_ERROR, 2,
                    TEXT("no VPE support in hardware,")
                    TEXT("so not accepting this mediatype")));
        }
    }
    return hr;
}


HRESULT CVideoPortObj::NegotiatePixelFormat()
{
    HRESULT hr = GetInputPixelFormats( &m_ddInputVideoFormats );
    delete [] m_pddOutputVideoFormats;
    m_pddOutputVideoFormats = NULL;
    if( m_ddInputVideoFormats.GetCount() ) {
        m_pddOutputVideoFormats = new PixelFormatList[ m_ddInputVideoFormats.GetCount() ];
        if( !m_pddOutputVideoFormats ) {
            hr = E_OUTOFMEMORY;
            goto CleanUp;
        }

        hr = GetOutputPixelFormats( m_ddInputVideoFormats, m_pddOutputVideoFormats );
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("NegotiatePixelFormat Failed, hr = 0x%x"), hr));
            goto CleanUp;
        }
        // for every input format, figure out a table of every possible output format
        // Then we can offer a list of possible output formats.  When we need one of them, search
        // the input lists to locate it (and possibly select the conversion with the lowest bandwidth)
        m_ddAllOutputVideoFormats = PixelFormatList::Union( m_pddOutputVideoFormats, m_ddInputVideoFormats.GetCount() );

        // for the input pin connection we need a 'default' format
        // We'll use reconnect after we know what we're connected to.
        //
        //  Typically the VPE only supports one format so all of this is really
        // overkill ...
        if( m_ddAllOutputVideoFormats.GetCount() > 0 ) {
            m_ddVPOutputVideoFormat = m_ddAllOutputVideoFormats[ m_dwDefaultOutputFormat ];

            DWORD dwInput = PixelFormatList::FindListContaining(
                m_ddVPOutputVideoFormat, m_pddOutputVideoFormats, m_ddInputVideoFormats.GetCount() );
            if( dwInput < m_ddInputVideoFormats.GetCount() ) {
                hr = SetInputPixelFormat( m_ddInputVideoFormats[dwInput] );
            } else {
                // can't happen
                hr = E_FAIL;
                goto CleanUp;
            }
        }
    }
CleanUp:
    return hr;
}

/******************************Public*Routine******************************\
* CVideoPortObj::RecreateVideoPort
\**************************************************************************/

HRESULT CVideoPortObj::SetupVideoPort()
{
    AMTRACE((TEXT("CVideoPortObj::SetupVideoPort")));
    HRESULT hr = NOERROR;
    HRESULT hrFailure = VFW_E_VP_NEGOTIATION_FAILED;

    CAutoLock cObjectLock(m_pMainObjLock);

    InitVariables();

    LPDIRECTDRAW7 pDirectDraw = m_pIVideoPortControl->GetDirectDraw();
    ASSERT(pDirectDraw);

    const DDCAPS* pDirectCaps = m_pIVideoPortControl->GetHardwareCaps();
    ASSERT(pDirectCaps);

    ASSERT(m_pIVPConfig);

    // create the VP container
    ASSERT(m_pDVP == NULL);
    ASSERT(pDirectDraw);

    hr = pDirectDraw->QueryInterface(IID_IDDVideoPortContainer, (LPVOID *)&m_pDVP);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                   TEXT("pDirectDraw->QueryInterface(IID_IDDVideoPortContainer)")
                   TEXT(" failed, hr = 0x%x"), hr));
        hr = hrFailure;
        goto CleanUp;
    }


    // Get the Video Port caps
    // DDVIDEOPORTCAPS vpCaps;
    // INITDDSTRUCT(vpCaps);
    hr = VPMUtil::FindVideoPortCaps( m_pDVP, &m_vpCaps, m_dwVideoPortId );

    if (FAILED(hr) || S_FALSE == hr )
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("m_pDVP->EnumVideoPorts failed, hr = 0x%x"), hr));
        hr = hrFailure;
        goto CleanUp;
    }

    // negotiate the connection parameters
    // get/set connection info happens here
    hr = NegotiateConnectionParamaters();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("NegotiateConnectionParamaters failed, hr = 0x%x"), hr));
        hr = hrFailure;
        goto CleanUp;
    }

    //
    // Determine if we are capturing and if we are what the intended
    // capture image size is, first determine if the video port
    // supports interleaving interlaced fields in memory
    //

    BOOL fInterleave;
    if (m_vpCaps.dwFX & DDVPFX_INTERLEAVE) {
        fInterleave = TRUE;
    }
    else {
        fInterleave = FALSE;
    }

    m_pIVideoPortControl->GetCaptureInfo(&m_fCapturing, &m_cxCapture,
                                  &m_cyCapture, &fInterleave);
    m_fCaptureInterleaved = fInterleave;

#if defined(DEBUG)
    if (m_fCapturing) {

        ASSERT(m_cxCapture > 0);
        ASSERT(m_cyCapture > 0);
        DbgLog((LOG_TRACE, 1,
                TEXT("We are CAPTURING, intended size (%d, %d)"),
                m_cxCapture, m_cyCapture));
    }
#endif

    
    for (DWORD i = 0; i < 2; i++)
    {
        AMVPSIZE amvpSize;
        DWORD dwNewWidth = 0;

        ZeroStruct( amvpSize );

        // get the rest of the data parameters
        hr = GetDataParameters();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("GetDataParameters failed, hr = 0x%x"), hr));
            hr = hrFailure;
            goto CleanUp;
        }

        // create the video port
        hr = CreateVideoPort();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("CreateVideoPort failed, hr = 0x%x"), hr));
            hr = hrFailure;
            goto CleanUp;
        }

        // check if we need to crop at videoport or overlay or neither
        hr = DetermineCroppingRestrictions();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("DetermineCroppingRestrictions FAILED, hr = 0x%x"),
                    hr));
            hr = hrFailure;
            goto CleanUp;
        }


        m_lImageWidth  = WIDTH(&m_VPDataInfo.amvpDimInfo.rcValidRegion);
        m_lImageHeight = HEIGHT(&m_VPDataInfo.amvpDimInfo.rcValidRegion);

        m_lDecoderImageWidth = m_lImageWidth;
        m_lDecoderImageHeight = m_lImageHeight;

        if (m_fCapturing) {

            if (m_lImageWidth != m_cxCapture ||
                m_lImageHeight != m_cyCapture) {

                DbgLog((LOG_TRACE, 1,
                        TEXT("Adjust Decoder Image size to CaptureSize")));
            }

            m_lImageWidth = m_cxCapture;
            m_lImageHeight = m_cyCapture;
        }

        m_dwPictAspectRatioX = m_VPDataInfo.dwPictAspectRatioX;
        m_dwPictAspectRatioY = m_VPDataInfo.dwPictAspectRatioY;


        // negotiate the pixel format
        hr = NegotiatePixelFormat();
        
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("NegotiatePixelFormat Failed, hr = 0x%x"), hr));
            hr = hrFailure;
            goto CleanUp;
        }

        // check the vp caps
        hr = CheckDDrawVPCaps();
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("CheckDDrawVPCaps FAILED, hr = 0x%x"), hr));
            // CheckDDrawVPCaps already returns a "proper" error code
            goto CleanUp;
        }

        if (i == 0)
        {

            dwNewWidth = m_VPDataInfo.amvpDimInfo.dwFieldWidth;
            if (m_sBandwidth.dwCaps == DDVPBCAPS_SOURCE &&
                m_sBandwidth.dwYInterpAndColorkey < 900)
            {
                dwNewWidth = MulDiv(dwNewWidth,
                                    m_sBandwidth.dwYInterpAndColorkey, 1000);
            }
            else if (m_sBandwidth.dwCaps == DDVPBCAPS_DESTINATION &&
                     m_sBandwidth.dwYInterpAndColorkey > 1100)
            {
                dwNewWidth = MulDiv(dwNewWidth, 1000,
                                    m_sBandwidth.dwYInterpAndColorkey);
            }

            // VGA can't handle the bandwidth, ask decoder to down-scale
            if (dwNewWidth != m_VPDataInfo.amvpDimInfo.dwFieldWidth)
            {
                amvpSize.dwWidth = dwNewWidth;
                amvpSize.dwHeight = m_VPDataInfo.amvpDimInfo.dwFieldHeight;

                DbgLog((LOG_TRACE,1,
                        TEXT("SetScalingFactors to (%d, %d)"),
                        amvpSize.dwWidth, amvpSize.dwHeight));

                hr = m_pIVPConfig->SetScalingFactors(&amvpSize);
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR,0,
                            TEXT("m_pIVPConfig->SetScalingFactors")
                            TEXT("failed, hr = 0x%x"), hr));
                    break;
                }
                else
                {
                    // release the videoport
                    ASSERT(m_pVideoPort);
                    ReleaseVideoPort();

                    // initialize relevant structs
                    ZeroStruct( m_sBandwidth );
                    ZeroStruct( m_VPDataInfo );
                    ZeroStruct( m_ddVPInputVideoFormat );
                    ZeroStruct( m_ddVPOutputVideoFormat );

                    // initialize decimation parameters
                    m_ulDeciStepX = 0;
                    m_dwDeciNumX = m_dwDeciDenX = 1000;
                    m_DecimationModeX = DECIMATE_NONE;

                    m_ulDeciStepY = 0;
                    m_dwDeciNumY = m_dwDeciDenY = 1000;
                    m_DecimationModeY = DECIMATE_NONE;
                }
            }
            else
            {
                DbgLog((LOG_ERROR,0,TEXT("no need to scale at the decoder")));
                break;
            }
        }
    }


    // iniitalize the DDVideoPortInfo structure
    hr = InitializeVideoPortInfo();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("InitializeVideoPortInfo FAILED, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

#if 0
// quickly open & close to make sure that we have a notification
// The rapid switch doesn't work with most drivers though
static HRESULT CheckVPNotifiyValid( LPDIRECTDRAWVIDEOPORT pVP )
{
    HANDLE              hevSampleAvailable;
    DDVIDEOPORTNOTIFY   vpNotify;
    LPDIRECTDRAWVIDEOPORTNOTIFY pNotify;

    HRESULT hr = pVP->QueryInterface( IID_IDirectDrawVideoPortNotify, (LPVOID *) &pNotify );
    if( SUCCEEDED( hr )) {
        hr = pNotify->AcquireNotification( &hevSampleAvailable, &vpNotify );
        vpNotify.lDone = 1;
        pNotify->ReleaseNotification( hevSampleAvailable );
        RELEASE( pNotify );
    }
    return hr;
}
#endif

HRESULT CVideoPortObj::AttachVideoPortToSurface()
{
    HRESULT hr = S_OK;
    CAutoLock cObjectLock(m_pMainObjLock);

    LPDIRECTDRAW7 pDirectDraw = m_pIVideoPortControl->GetDirectDraw();
    ASSERT(pDirectDraw);

    const DDCAPS* pDirectCaps = m_pIVideoPortControl->GetHardwareCaps();
    ASSERT(pDirectCaps);

#ifdef DEBUG
#define DBGFLAG( f )  DbgLog((LOG_ERROR, 1, TEXT("%s = %s"), TEXT(#f), f ? TEXT("TRUE") : TEXT("FALSE") ))

    DBGFLAG (m_bVSInterlaced);
    DBGFLAG( m_vpCaps.dwCaps & DDVPCAPS_AUTOFLIP );
    DBGFLAG (m_vpCaps.dwFX & DDVPFX_INTERLEAVE);
    DBGFLAG (m_bCantInterleaveHalfline);
    DBGFLAG (pDirectCaps->dwCaps2 & DDCAPS2_CANBOBINTERLEAVED);
    DBGFLAG (pDirectCaps->dwCaps2 & DDCAPS2_CANBOBNONINTERLEAVED);
#undef DBGFLAG
#endif

    BOOL bCanWeave = FALSE;
    BOOL bCanBobInterleaved = FALSE;
    BOOL bCanBobNonInterleaved = FALSE;
    BOOL bTryDoubleHeight = FALSE, bPreferBuffers = FALSE;
    DWORD dwMaxOverlayBuffers;

    // can Weave only if content is non-interlaced (cause of motion
    // artifacts otherwise) and if videoport is capable of flipping and
    // supports interleaved data and if certain halfline scenarios do not
    // preclude interleaving
    //
    if ((!m_bVSInterlaced) &&
        (m_vpCaps.dwCaps & DDVPCAPS_AUTOFLIP) &&
        (m_vpCaps.dwFX & DDVPFX_INTERLEAVE) &&
        (!m_bCantInterleaveHalfline))
    {
        bCanWeave = TRUE;
    }

    // can BobNonInterleaved only if content is interlaced and if videoport is
    // capable of flipping, is capable of bobing interleaved data and supports
    // interleaved data and if certain halfline scenarios do not preclude
    // interleaving
    //
    if ((m_bVSInterlaced) &&
        (m_vpCaps.dwCaps & DDVPCAPS_AUTOFLIP) &&
        (pDirectCaps->dwCaps2 & DDCAPS2_CANBOBINTERLEAVED) &&
        (m_vpCaps.dwFX & DDVPFX_INTERLEAVE) &&
        (!m_bCantInterleaveHalfline))
    {
        bCanBobInterleaved = TRUE;
    }

    // can BobInterleaved only if content is interlaced and if videoport is
    // capable of flipping and is capable of bobing non-interleaved data.
    //
    if ((m_bVSInterlaced) &&
        (m_vpCaps.dwCaps & DDVPCAPS_AUTOFLIP) &&
        (pDirectCaps->dwCaps2 & DDCAPS2_CANBOBNONINTERLEAVED))
    {
        bCanBobNonInterleaved = TRUE;
    }

    // this just means that we would perfer higher number of
    // buffers instead of more height in the event of a conflict
    // (in cases like 2buffer, 1height versus 1buffer, 2height)
    //
    bPreferBuffers = TRUE;

    // we will try to allocate surface of double the field height only if
    // either mode weave or bob-interleaved are possible
    //
    bTryDoubleHeight = bCanWeave || bCanBobInterleaved;

    // 3 buffers prevents any waiting
    dwMaxOverlayBuffers = 3;

    // we will try to allocate multiple buffers only if either mode weave or
    // bob-interleaved or bob-non-interleaved are possible
    //
    if (bCanWeave || bCanBobInterleaved || bCanBobNonInterleaved)
    {
        //try to allocate min(m_vpCaps.dwNumAutoFlipSurfaces,
        // m_vpCaps.dwNumPreferredAutoflip) buffers
        //
        ASSERT(m_vpCaps.dwFlags & DDVPD_AUTOFLIP);
        if (m_vpCaps.dwFlags & DDVPD_PREFERREDAUTOFLIP)
        {
            dwMaxOverlayBuffers = min(m_vpCaps.dwNumAutoFlipSurfaces,
                                      m_vpCaps.dwNumPreferredAutoflip);
        }
        else
        {
            dwMaxOverlayBuffers = min(m_vpCaps.dwNumAutoFlipSurfaces, 3);
        }
    }

    // create the overlay surface
    hr = CreateSourceSurface(bTryDoubleHeight, dwMaxOverlayBuffers, bPreferBuffers);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("CreateVPOverlay FAILED, hr = 0x%x"), hr));
        hr = VFW_E_OUT_OF_VIDEO_MEMORY;
        goto CleanUp;
    }

    // tell the upstream filter the valid data location on the ddraw surface
    hr = SetSurfaceParameters();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("SetSurfaceParameters FAILED, hr = 0x%x"), hr));
        hr = VFW_E_OUT_OF_VIDEO_MEMORY;
        goto CleanUp;
    }

    // attach the overlay surface to the videoport
    hr = ReconnectVideoPortToSurface();
     
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pVideoPort->SetTargetSurface failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    if (!(VPMUtil::EqualPixelFormats( m_ddVPInputVideoFormat, m_ddVPOutputVideoFormat)))
    {
        m_svpInfo.dwVPFlags |= DDVP_CONVERT;
    }
    else
    {
        m_svpInfo.dwVPFlags &= ~DDVP_CONVERT;
    }

    // determine which modes are possible now
    // depends upon the height, number of back buffers etc
    hr = DetermineModeRestrictions();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("DetermineModeRestrictions FAILED, hr = 0x%x"), hr));
        goto CleanUp;
    }
    //
    // try the various modes, this can be folded into DetermineModeRestrictions
    // instead of mindlessly pounding at cases (put into format negotiation code in VPMOutputPin ?)
    //
    hr = SetUpMode( m_CurrentMode );
    if( FAILED( hr )) {
        // switch modes
        AMVP_MODE modes[5]={AMVP_MODE_WEAVE,
                            AMVP_MODE_BOBINTERLEAVED, AMVP_MODE_BOBNONINTERLEAVED,
                            AMVP_MODE_SKIPODD, AMVP_MODE_SKIPEVEN
        };

        for( DWORD dwModeIndex = 0; dwModeIndex < NUMELMS( modes ); dwModeIndex++ ) {
            if( modes[dwModeIndex] != m_CurrentMode ) {
                hr = SetUpMode( modes[dwModeIndex] );
                if( SUCCEEDED(hr )) {
                    m_CurrentMode = modes[dwModeIndex];
                    break;
                }
            }
        }
    }

    // inform the decoder of the ddraw kernel handle, videoport id and surface
    // kernel handle
    hr = SetDDrawKernelHandles();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("SetDDrawKernelHandles failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    return hr;
}

HRESULT CVideoPortObj::SignalNewVP()
{
    // finally notify the capture thread of the new surface
    ASSERT( m_pVideoPort );
    ASSERT( m_pChain );
    ASSERT( m_pChain[0].pDDSurf );
    HRESULT hRes = m_pIVideoPortControl->SignalNewVP( m_pVideoPort );
    return hRes;
}

/******************************Public*Routine******************************\
* CVideoPortObj::CompleteConnect
*
* supposed to be called when the host connects with the decoder
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP 
CVideoPortObj::CompleteConnect(IPin *pReceivePin, BOOL bRenegotiating)
{
    AMTRACE((TEXT("CVideoPortObj::CompleteConnect")));

    HRESULT hr = NOERROR;

    CAutoLock cObjectLock(m_pMainObjLock);

    if (!bRenegotiating)
    {
        InitVariables();

        ASSERT(m_pIVPConfig == NULL);
        hr = pReceivePin->QueryInterface(IID_IVPConfig, (void **)&m_pIVPConfig);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,  TEXT("QueryInterface(IID_IVPConfig) failed, hr = 0x%x"), hr));
            hr = VFW_E_NO_TRANSPORT;
            goto CleanUp;
        }
    }

    ASSERT(m_pIVPConfig);

    hr = SetupVideoPort();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0, TEXT("SetupVideoPort failed, hr = 0x%x"), hr));
        ASSERT(SUCCEEDED(hr));
        goto CleanUp;
    }
    m_bConnected = TRUE;


CleanUp:
    return hr;
}

HRESULT CVideoPortObj::StopUsingVideoPort()
{
    AMTRACE((TEXT("CVideoPortObj::StopUsingVideoPort")));

    HRESULT hr = NOERROR;

    CAutoLock cObjectLock(m_pMainObjLock);

    // release the videoport
    if (m_pVideoPort)
    {
        hr = m_pVideoPort->StopVideo();
        ReleaseVideoPort();
    }

    // release the videoport container
    RELEASE( m_pDVP );

    // Release the DirectDraw overlay surface
    // Must release VideoPort first so that the thread doesn't use this
    hr = DestroyOutputSurfaces();
    return hr;
}

HRESULT
CVideoPortObj::DestroyOutputSurfaces()
{
    // ref counts on m_pChain match primary m_pOutputSurface
    delete [] m_pChain;
    m_pChain = NULL;

    RELEASE( m_pOutputSurface1 );
    RELEASE( m_pOutputSurface );
    return S_OK;
}

/******************************Public*Routine******************************\
* CVideoPortObj::BreakConnect
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP
CVideoPortObj::BreakConnect(BOOL bRenegotiating)
{
    AMTRACE((TEXT("CVideoPortObj::BreakConnect")));

    HRESULT hr = NOERROR;
    unsigned long ulCount;

    CAutoLock cObjectLock(m_pMainObjLock);

    hr = StopUsingVideoPort();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0, TEXT("StopUsingVideoPort failed, hr = 0x%x"), hr));
    }
    if (!bRenegotiating)
    {
        // release the IVPConfig interface
        RELEASE (m_pIVPConfig);
    }

    m_bConnected = FALSE;

    return hr;
}

/******************************Public*Routine******************************\
* CVideoPortObj::Active()
*
*
* transition from Stop to Pause.
* We do not need to to anything unless this is the very first time we are
* showing the overlay
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::Active()
{
    AMTRACE((TEXT("CVideoPortObj::Active")));

    CAutoLock cObjectLock(m_pMainObjLock);
    HRESULT hr = NOERROR;

    ASSERT(m_bConnected);
    ASSERT(m_VPState == VPInfoState_STOPPED);

    if (!m_bConnected)
    {
        hr = VFW_E_NOT_CONNECTED;
        goto CleanUp;
    }

    // make sure that a frame is visible by making an update overlay call
    m_bStart = TRUE;

    // now stop the video, so the user will just see a still frame
    hr = m_pVideoPort->StopVideo();

#if defined(DEBUG)
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pVideoPort->StopVideo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
#endif

CleanUp:
    return hr;
}

/******************************Public*Routine******************************\
* CVideoPortObj::Inactive()
*
* transition (from Pause or Run) to Stop
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::Inactive()
{

    AMTRACE((TEXT("CVideoPortObj::Inactive")));

    HRESULT hr = NOERROR;
    CAutoLock cObjectLock(m_pMainObjLock);

    if (m_bConnected) {

        // Inactive is also called when going from pause to stop, in which case the
        // VideoPort would have already been stopped in the function RunToPause

        if (m_VPState == VPInfoState_RUNNING) {

            // stop the VideoPort
            if( m_pVideoPort )
                hr = m_pVideoPort->StopVideo();
            if (SUCCEEDED(hr)) {
                m_VPState = VPInfoState_STOPPED;
            }
            else {
                DbgLog((LOG_ERROR,0,
                        TEXT("m_pVideoPort->StopVideo failed, hr = 0x%x"), hr));
            }
        }
    }
    else {
        hr = VFW_E_NOT_CONNECTED;
    }

    return hr;
}

/******************************Public*Routine******************************\
* CVideoPortObj::Run
*
* transition from Pause to Run. We just start the VideoPort.
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::Run(REFERENCE_TIME /* tStart */)
{
    AMTRACE((TEXT("CVideoPortObj::Run")));

    CAutoLock cObjectLock(m_pMainObjLock);

    ASSERT(m_bConnected);
    ASSERT(m_VPState == VPInfoState_STOPPED);
    HRESULT hr = S_OK;

    if (m_bConnected)
    {
        // An UpdateOverlay is needed here. One example is, when we are
        // clipping video in Stop/Pause state since we can't do scaling
        // on the videoport. As soon as the user hits play, we should stop
        // clipping the video.

        m_bStart = TRUE;

        m_VPState = VPInfoState_RUNNING;
        // TBD: we need to kick a thread to start pumping frames from the videoport
        // to the output pin
    }
    else {
        hr = VFW_E_NOT_CONNECTED;
    }

    return hr;
}


/******************************Public*Routine******************************\
* CVideoPortObj::RunToPause()
*
* transition from Run to Pause. We just stop the VideoPort
* Note that transition from Run to Stop is caught by Inactive
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::RunToPause()
{

    AMTRACE((TEXT("CVideoPortObj::RunToPause")));

    CAutoLock cObjectLock(m_pMainObjLock);

    ASSERT(m_bConnected);
    //ASSERT(m_VPState == VPInfoState_RUNNING);

    HRESULT hr;
    if (m_bConnected)
    {
        // stop the VideoPort
        hr = m_pVideoPort->StopVideo();
        if (SUCCEEDED(hr)) {

            m_VPState = VPInfoState_STOPPED;
        }
        else {
            DbgLog((LOG_ERROR,0,
                    TEXT("m_pVideoPort->StopVideo failed, hr = 0x%x"), hr));
        }

    }
    else {
        hr = VFW_E_NOT_CONNECTED;
    }

    return hr;
}

/******************************Public*Routine******************************\
* CVideoPortObj::CurrentMediaType
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::CurrentMediaType(AM_MEDIA_TYPE *pMediaType)
{
    AMTRACE((TEXT("CVideoPortObj::CurrentMediaType")));

    CAutoLock cObjectLock(m_pMainObjLock);

    if (m_bConnected) {
        if (pMediaType) {
            VIDEOINFOHEADER2 *pVideoInfoHeader2 = VPMUtil::GetVideoInfoHeader2( (CMediaType *)pMediaType );

            // tweak it if it isn't the correct type
            if( !pVideoInfoHeader2 ) {
                pVideoInfoHeader2 = VPMUtil::SetToVideoInfoHeader2( (CMediaType *)pMediaType );
            }

            if( pVideoInfoHeader2 ) {
                VPMUtil::InitVideoInfoHeader2( pVideoInfoHeader2);

                pVideoInfoHeader2->bmiHeader.biWidth = m_VPDataInfo.amvpDimInfo.rcValidRegion.right -
                                   m_VPDataInfo.amvpDimInfo.rcValidRegion.left;
                pVideoInfoHeader2->bmiHeader.biHeight = m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom -
                                   m_VPDataInfo.amvpDimInfo.rcValidRegion.top;

                pVideoInfoHeader2->dwPictAspectRatioX = m_VPDataInfo.dwPictAspectRatioX;
                pVideoInfoHeader2->dwPictAspectRatioY = m_VPDataInfo.dwPictAspectRatioY;
                return S_OK;
            } else {
                DbgLog((LOG_ERROR, 2, TEXT("not videoheader2")));
                return NOERROR;
            }
        } else {
            DbgLog((LOG_ERROR, 2, TEXT("pMediaType is NULL")));
            return E_INVALIDARG;
        }
    } else {
        return VFW_E_NOT_CONNECTED;
    }
}

/******************************Public*Routine******************************\
* CVideoPortObj::GetRectangles
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::GetRectangles(RECT *prcSource, RECT *prcDest)
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVideoPortObj::GetRectangles")));

    if (prcSource && prcDest) {

        // adjust the source to be bigger to take into account the decimation
        // that's happening
        //
        prcSource->left   = MulDiv(m_rcSource.left,  m_dwDeciDenX, m_dwDeciNumX);
        prcSource->right  = MulDiv(m_rcSource.right, m_dwDeciDenX, m_dwDeciNumX);
        prcSource->top    = MulDiv(m_rcSource.top,   m_dwDeciDenY, m_dwDeciNumY);
        prcSource->bottom = MulDiv(m_rcSource.bottom,m_dwDeciDenY, m_dwDeciNumY);

        *prcDest = m_rcDest;
    }
    else {
        hr = E_INVALIDARG;
        DbgLog((LOG_ERROR, 2, TEXT("prcSource or prcDest is NULL")));
    }

    return hr;
}


STDMETHODIMP CVideoPortObj::GetCropState(VPInfoCropState *pCropState)
{
    *pCropState = m_CropState;
    return NOERROR;
}

STDMETHODIMP CVideoPortObj::GetPixelsPerSecond(DWORD* pPixelPerSec)
{
    *pPixelPerSec = m_dwPixelsPerSecond;
    return NOERROR;
}

STDMETHODIMP CVideoPortObj::GetVPDataInfo(AMVPDATAINFO* pVPDataInfo)
{
    *pVPDataInfo = m_VPDataInfo;
    return NOERROR;
}

STDMETHODIMP CVideoPortObj::GetVPInfo(DDVIDEOPORTINFO* pVPInfo)
{
    *pVPInfo = m_svpInfo;
    return NOERROR;
}

STDMETHODIMP CVideoPortObj::GetVPBandwidth(DDVIDEOPORTBANDWIDTH* pVPBandwidth)
{
    *pVPBandwidth = m_sBandwidth;
    return NOERROR;
}

STDMETHODIMP CVideoPortObj::GetVPCaps(DDVIDEOPORTCAPS* pVPCaps)
{
    *pVPCaps = m_vpCaps;
    return NOERROR;
}

STDMETHODIMP CVideoPortObj::GetVPInputFormat(LPDDPIXELFORMAT pVPFormat)
{
    *pVPFormat = m_ddVPInputVideoFormat;
    return NOERROR;
}

STDMETHODIMP CVideoPortObj::GetVPOutputFormat(LPDDPIXELFORMAT pVPFormat)
{
    *pVPFormat = m_ddVPOutputVideoFormat;
    return NOERROR;
}

/******************************Public*Routine******************************\
* CVideoPortObj::StartVideo
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVideoPortObj::ReconnectVideoPortToSurface()
{
    // not a high frequency event, so always try to reattach
    // if surfaces were lost for some reason, must be reattached
    HRESULT hResult;

	// we need a video port, StartWithRetry will create another videoport
	if( !m_pVideoPort ) {
		return E_FAIL;
	}
    if( !m_pOutputSurface || FAILED( hResult = m_pOutputSurface->Restore() )) { // == DDERR_WRONGMODE with Rage128
        // ASSERT( !"VPM: Can't restore surface, recreating" );
        hResult = AttachVideoPortToSurface();
        if( SUCCEEDED( hResult )) {
            hResult = SignalNewVP();
        }
    } else {
        hResult = m_pVideoPort->SetTargetSurface(m_pOutputSurface1, DDVPTARGET_VIDEO);

        // hack for bug where a running video port caused DDraw to stop it, discards the VPInfo, then tries
        // to start it, but returns E_INVALIDARG since the VPInfo is NULL!!
        if( FAILED( hResult )) {
            hResult = m_pVideoPort->SetTargetSurface(m_pOutputSurface1, DDVPTARGET_VIDEO);
        }
        // ASSERT( SUCCEEDED(hResult)); <- can fail if the videoport was lost during a res mode change (G400)
    }
    return hResult;
}

HRESULT CVideoPortObj::StartVideoWithRetry()
{
    HRESULT hr = E_FAIL;
    // Can be NULL if we call StartWithRetry twice and the VP failed
    if( m_pVideoPort ) {
        hr = m_pVideoPort->StartVideo(&m_svpInfo);
    }

    // This case SUCCEEDS on the G400 

    // Try again with ReconnectToSurf first
    if (FAILED(hr))
    {
        // ASSERT( !"StartWithRetry entering salvage mode" );
        hr = ReconnectVideoPortToSurface();
        if( SUCCEEDED( hr )) {
            hr = m_pVideoPort->StartVideo(&m_svpInfo);
        }
    }
    // Try again with CreateVP then ReconnectToSurf (first case FAILs on the Rage128) 
    if( FAILED(hr)) {
        // ASSERT( !"Recreating videoport" );
        // try replacing the video port
        hr = CreateVideoPort();
        if( SUCCEEDED( hr )) {
            hr = ReconnectVideoPortToSurface();
        }
        if( SUCCEEDED( hr )) {
            hr = m_pVideoPort->StartVideo(&m_svpInfo);
        }
    }
#if 0
    // Try again with SetupVP (CreateVP), ReconnectToSurf first
    // This implies the video port enumerator isn't valid any more.  I don't think
    // this should happen in practice, but just in case.
    if( FAILED(hr)) {
        ASSERT( !"Rebuilding videoport" );
        // really corrupt, start from the beginning
        hr = SetupVideoPort();
        if( SUCCEEDED( hr )) {
            hr = ReconnectVideoPortToSurface();
        }
        if( SUCCEEDED( hr )) {
            hr = m_pVideoPort->StartVideo(&m_svpInfo);
        }
    }
#endif
    return hr;
}

STDMETHODIMP CVideoPortObj::StartVideo(const VPWININFO* pWinInfo )
{
    AMTRACE((TEXT("CVideoPortObj::StartVideo")));

    HRESULT hr = NOERROR;
    if ( m_bStart) {
        VPWININFO CopyWinInfo;
        AMVP_MODE tryMode;

        CAutoLock cObjectLock(m_pMainObjLock);

        // no point making any videoport calls, if the video is stopped
        if (m_VPState == VPInfoState_RUNNING || m_bStart)
        {
            if (m_bStart)
            {
                DWORD dwSignalStatus;
                hr = StartVideoWithRetry();
                if( FAILED( hr )) {
                    hr = StartVideoWithRetry();
                    if( FAILED( hr )) {
                        goto CleanUp;
                    }
                }

                DbgLog((LOG_ERROR,0, TEXT("StartVideo DONE!!!")));

                // check if the videoport is receiving a signal.
                hr = m_pVideoPort->GetVideoSignalStatus(&dwSignalStatus);
                if ((SUCCEEDED(hr)) && (dwSignalStatus == DDVPSQ_SIGNALOK))
                {
                    m_pVideoPort->WaitForSync(DDVPWAIT_END, 0, 0);
                }
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR,0,
                            TEXT("m_pVideoPort->GetVideoSignalStatus() failed,")
                            TEXT(" hr = 0x%x"), hr));
                    hr = NOERROR;
                }


                m_bStart = FALSE;
            }
        }
    }
CleanUp:
    return hr;
}

static bool AreEqual( const DDVIDEOPORTCONNECT& proposed, const DDVIDEOPORTCONNECT& videoport )
{
    return (proposed.dwPortWidth == videoport.dwPortWidth) && 
           IsEqualIID(proposed.guidTypeID, videoport.guidTypeID);
}

/*****************************Private*Routine******************************\
* CVideoPortObj::NegotiateConnectionParamaters
*
* this functions negotiates the connection parameters with
* the decoder.
* Since this function might be called during renegotiation, the
* existing connection parameters are passed in as input and if
* possible, we try to use the same parameters.
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVideoPortObj::NegotiateConnectionParamaters()
{
    AMTRACE((TEXT("CVideoPortObj::NegotiateConnectionParamaters")));

    HRESULT hr = NOERROR;
    LPDDVIDEOPORTCONNECT lpddProposedConnect = NULL;
    DWORD dwNumProposedEntries = 0;
    DDVIDEOPORTSTATUS ddVPStatus = { sizeof(DDVIDEOPORTSTATUS)};
    LPDDVIDEOPORTCONNECT lpddVideoPortConnect = NULL;
    DWORD dwNumVideoPortEntries = 0;
    BOOL bIntersectionFound = FALSE;
    DWORD i, j;


    CAutoLock cObjectLock(m_pMainObjLock);

    ASSERT(m_pIVPConfig);
    ASSERT(m_pDVP);

    // find the number of entries to be proposed
    hr = m_pIVPConfig->GetConnectInfo(&dwNumProposedEntries, NULL);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetConnectInfo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    ASSERT(dwNumProposedEntries);

    // allocate the necessary memory
    lpddProposedConnect = new DDVIDEOPORTCONNECT[dwNumProposedEntries];
    if (lpddProposedConnect == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("NegotiateConnectionParamaters : Out of Memory")));
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    // memset the allocated memory to zero
    ZeroArray(lpddProposedConnect, dwNumProposedEntries );

    // set the right size in each of the structs.
    for (i = 0; i < dwNumProposedEntries; i++)
    {
        lpddProposedConnect[i].dwSize = sizeof(DDVIDEOPORTCONNECT);
    }

    // get the entries proposed
    hr = m_pIVPConfig->GetConnectInfo(&dwNumProposedEntries, lpddProposedConnect);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetConnectInfo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // get the status of the video port
    hr = m_pDVP->QueryVideoPortStatus(m_dwVideoPortId, &ddVPStatus);
    if (FAILED(hr))
    {
        //  Some cards don't implement this so just crash on
        ddVPStatus.bInUse = FALSE;
        DbgLog((LOG_ERROR, 0,
                TEXT("m_pDVP->QueryVideoPortStatus failed, hr = 0x%x"), hr));
//  goto CleanUp;
    }

    // find the number of entries supported by the videoport
    hr = m_pDVP->GetVideoPortConnectInfo(m_dwVideoPortId, &dwNumVideoPortEntries, NULL);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("m_pDVP->GetVideoPortConnectInfo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    ASSERT(dwNumVideoPortEntries);

    // allocate the necessary memory
    lpddVideoPortConnect = new DDVIDEOPORTCONNECT[dwNumVideoPortEntries];
    if (lpddVideoPortConnect == NULL)
    {
        DbgLog((LOG_ERROR,0,
                TEXT("NegotiateConnectionParamaters : Out of Memory")));
        hr = E_OUTOFMEMORY;
        goto CleanUp;
    }

    // memset the allocated memory to zero
    ZeroMemory(lpddVideoPortConnect,
               dwNumVideoPortEntries*sizeof(DDVIDEOPORTCONNECT));

    // set the right size in each of the structs.
    for (i = 0; i < dwNumVideoPortEntries; i++)
    {
        lpddVideoPortConnect[i].dwSize = sizeof(DDVIDEOPORTCONNECT);
    }

    // get the entries supported by the videoport
    hr = m_pDVP->GetVideoPortConnectInfo(m_dwVideoPortId, &dwNumVideoPortEntries,
                                         lpddVideoPortConnect);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pDVP->GetVideoPortConnectInfo failed, hr = 0x%x"), hr));
        hr = E_FAIL;
        goto CleanUp;
    }


    // check if the video port is not already in use
    if (!ddVPStatus.bInUse)
    {

        // take the first element of the intersection of the two lists and
        // set that value on the decoder
        for (i = 0; i < dwNumProposedEntries && !bIntersectionFound; i++)
        {
            for (j = 0; j < dwNumVideoPortEntries && !bIntersectionFound; j++)
            {
                if ( AreEqual( lpddProposedConnect[i], lpddVideoPortConnect[j]) )
                {
                    m_ddConnectInfo = lpddVideoPortConnect[j];
                    hr = m_pIVPConfig->SetConnectInfo(i);
                    if (FAILED(hr))
                    {
                        DbgLog((LOG_ERROR,0,
                                TEXT("m_pIVPConfig->SetConnectInfo")
                                TEXT(" failed, hr = 0x%x"), hr));
                        goto CleanUp;
                    }

                    bIntersectionFound = TRUE;
                }
            }
        }
    }
    else
    {
        // take the first element of the list matching the current status
        for (i = 0; i < dwNumProposedEntries && !bIntersectionFound; i++)
        {
            if ( AreEqual(lpddProposedConnect[i], ddVPStatus.VideoPortType) )
            {
                for (j = 0; j < dwNumVideoPortEntries && !bIntersectionFound; j++)
                {
                    if ( AreEqual(lpddProposedConnect[i], lpddVideoPortConnect[j]) )
                    {
                        m_ddConnectInfo = lpddVideoPortConnect[j];
                        bIntersectionFound = TRUE;
                    }
                }
                break;
            }
        }
    }

    if (!bIntersectionFound)
    {
        hr = E_FAIL;

        goto CleanUp;
    }

    // cleanup
CleanUp:
    delete [] lpddProposedConnect;
    delete [] lpddVideoPortConnect;
    return hr;
}

/*****************************Private*Routine******************************\
* CVideoPortObj::GetDataParameters
*
*
* this functions gets various data parameters from the decoder
* parameters include dimensions, double-clock, vact etc
* Also maximum pixel rate the decoder will output
* this happens after the connnection parameters have been set-up
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVideoPortObj::GetDataParameters()
{
    AMTRACE((TEXT("CVideoPortObj::GetDataParameters")));

    HRESULT hr = NOERROR;
    DWORD dwMaxPixelsPerSecond = 0;
    AMVPSIZE amvpSize;

    CAutoLock cObjectLock(m_pMainObjLock);


    // set the size of the struct
    m_VPDataInfo.dwSize = sizeof(AMVPDATAINFO);

    // get the VideoPort data information
    hr = m_pIVPConfig->GetVPDataInfo(&m_VPDataInfo);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetVPDataInfo failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    /*
    if (m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom > m_VPDataInfo.amvpDimInfo.dwFieldHeight)
    m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom = m_VPDataInfo.amvpDimInfo.dwFieldHeight;
    */

    // if decoder says data is not interlaced
    if (!(m_VPDataInfo.bDataIsInterlaced))
    {
        // this flag does not mean anything
        if (m_VPDataInfo.bFieldPolarityInverted)
        {
            hr = E_FAIL;
            goto CleanUp;
        }

        // these don't mean anything either
        if ((m_VPDataInfo.lHalfLinesOdd != 0) ||
            (m_VPDataInfo.lHalfLinesEven != 0))
        {
            hr = E_FAIL;
            goto CleanUp;
        }
    }

    amvpSize.dwWidth = m_VPDataInfo.amvpDimInfo.dwFieldWidth;
    amvpSize.dwHeight = m_VPDataInfo.amvpDimInfo.dwFieldHeight;

    // get the maximum pixel rate the decoder will output
    hr = m_pIVPConfig->GetMaxPixelRate(&amvpSize, &dwMaxPixelsPerSecond);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetMaxPixelRate failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    m_dwPixelsPerSecond = dwMaxPixelsPerSecond;



    CleanUp:
    DbgLog((LOG_TRACE, 5,TEXT("Leaving CVideoPortObj::GetDataParameters")));
    return hr;
}

static BOOL CanCreateSurface( LPDIRECTDRAW7 pDirectDraw, const DDPIXELFORMAT& ddFormat ) 
{

    // check if output format is suitable for a DDraw output device
   
    DDSURFACEDESC2 ddsdDesc;
    ddsdDesc.dwSize = sizeof(DDSURFACEDESC);
    ddsdDesc.dwFlags = DDSD_CAPS | DDSD_HEIGHT |
                       DDSD_WIDTH | DDSD_PIXELFORMAT;

    ddsdDesc.ddpfPixelFormat = ddFormat;

    ddsdDesc.ddsCaps.dwCaps = // DDSCAPS_OVERLAY |
                              DDSCAPS_VIDEOMEMORY |
                              DDSCAPS_VIDEOPORT;

    // the actual overlay surface created might be of different
    // dimensions, however we are just testing the pixel format
    ddsdDesc.dwWidth = 64;
    ddsdDesc.dwHeight = 64;

    ASSERT(pDirectDraw);
    LPDIRECTDRAWSURFACE7 pSurf;
    HRESULT hr = pDirectDraw->CreateSurface(&ddsdDesc, &pSurf, NULL);
    if( SUCCEEDED( hr )) {
        pSurf->Release();
    }
    return SUCCEEDED( hr );
}

/*****************************Private*Routine******************************\
* CVideoPortObj::GetBestFormat
*
* this function takes a list of inputformats and returns the
* "best" input and output format according to some criterion.
* It also checks if the output formats is suitable by trying
* to allocate a small surface and checking to see if the call
* succeeds. Since this is before the overlay surface has been
* created, that should be a ok. Right now the criterion just
* includes bestbendwidth, or if not that then just the first
* suitable one in the list.
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT
CVideoPortObj::GetOutputPixelFormats(
    const PixelFormatList& ddInputFormats,
    PixelFormatList* pddOutputFormats )
{
    HRESULT hr = S_OK;
    AMTRACE((TEXT("CVideoPortObj::GetOutputFormats")));

    CAutoLock cObjectLock(m_pMainObjLock);

    for (DWORD i = 0; i < ddInputFormats.GetCount(); i++)
    {
        // For each input format, figure out the output formats
        DDPIXELFORMAT* pInputFormat = const_cast<DDPIXELFORMAT*>(&ddInputFormats[i]);
        DWORD dwNumOutputFormats;
        hr = m_pVideoPort->GetOutputFormats(pInputFormat,
                                            &dwNumOutputFormats,
                                            NULL, DDVPFORMAT_VIDEO);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,
                    TEXT("m_pVideoPort->GetOutputFormats failed, hr = 0x%x"),
                    hr));
            break;
        }
        ASSERT(dwNumOutputFormats);

        // allocate the necessary memory
        pddOutputFormats[i].Reset( dwNumOutputFormats );

        if (pddOutputFormats[i].GetEntries() == NULL)
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("new failed, failed to allocate memnory for ")
                    TEXT("lpddOutputFormats in NegotiatePixelFormat")));
            hr = E_OUTOFMEMORY;
            break;
        }

        // get the entries supported by the videoport
        hr = m_pVideoPort->GetOutputFormats(pInputFormat,
                                            &dwNumOutputFormats,
                                            pddOutputFormats[i].GetEntries(),
                                            DDVPFORMAT_VIDEO);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0,
                    TEXT("m_pVideoPort->GetOutputFormats failed, hr = 0x%x"),
                    hr));
            break;
        }
    } // end of outer for loop
    return hr;
}

/*****************************Private*Routine******************************\
* CVideoPortObj::NegotiatePixelFormat
*
* this function is used to negotiate the pixelformat with the decoder.
* It asks the decoder fot a list of input formats, intersects that list
* with the one the deocoder supports (while maintaining the order) and
* then calls "GetBestFormat" on that list to get the "best" input and
* output format. After that it calls "SetPixelFormat" on the decoder in
* order to inform the decoder of the decision.
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVideoPortObj::GetInputPixelFormats( PixelFormatList* pList )
{
    AMTRACE((TEXT("CVideoPortObj::NegotiatePixelFormat")));
    CAutoLock cObjectLock(m_pMainObjLock);

    HRESULT hr = NOERROR;
    // find the number of entries to be proposed
    DWORD dwNumProposedEntries = 0;
    hr = m_pIVPConfig->GetVideoFormats(&dwNumProposedEntries, NULL);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetVideoFormats failed, hr = 0x%x"), hr));
        return hr;
    }
    ASSERT(dwNumProposedEntries);

    // find the number of entries supported by the videoport
    DWORD dwNumVPInputEntries = 0;
    hr = m_pVideoPort->GetInputFormats(&dwNumVPInputEntries, NULL, DDVPFORMAT_VIDEO);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pVideoPort->GetInputFormats failed, hr = 0x%x"), hr));
        return hr;
    }
    ASSERT(dwNumVPInputEntries);

    // allocate the necessary memory
    PixelFormatList lpddProposedFormats(dwNumProposedEntries);
    if (lpddProposedFormats.GetEntries() == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("NegotiatePixelFormat : Out of Memory")));
        hr = E_OUTOFMEMORY;
        return hr;
    }

    // get the entries proposed
    hr = m_pIVPConfig->GetVideoFormats(&dwNumProposedEntries, lpddProposedFormats.GetEntries() );
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetVideoFormats failed, hr = 0x%x"), hr));
        return hr;
    }

    // allocate the necessary memory
    PixelFormatList lpddVPInputFormats(dwNumVPInputEntries);
    if (lpddVPInputFormats.GetEntries() == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("NegotiatePixelFormat : Out of Memory")));
        hr = E_OUTOFMEMORY;
        return hr;
    }

    // get the entries supported by the videoport
    hr = m_pVideoPort->GetInputFormats(&dwNumVPInputEntries,
                                       lpddVPInputFormats.GetEntries(), DDVPFORMAT_VIDEO);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pVideoPort->GetInputFormats failed, hr = 0x%x"), hr));
        hr = E_FAIL;
        return hr;
    }

    *pList = lpddVPInputFormats.IntersectWith( lpddProposedFormats );

    // the number of entries in the intersection is zero!!
    // Return failure.
    if (pList->GetCount() == 0)
    {
        hr = E_FAIL;
        return hr;
    }

    // call GetBestFormat with whatever search criterion you want
    // DWORD dwBestEntry;
    // hr = GetBestFormat(lpddIntersectionFormats.GetCount(),
    //                    lpddIntersectionFormats.GetEntries(), TRUE, &dwBestEntry,
    //                    &m_ddVPOutputVideoFormat);
    // if (FAILED(hr))
    // {
    //     DbgLog((LOG_ERROR,0,TEXT("GetBestFormat failed, hr = 0x%x"), hr));
    // } else {
    //      hr = SetVPInputPixelFormat( lpddIntersectionFormats[dwBestEntry] )
    // }
    return hr;
}

HRESULT CVideoPortObj::SetInputPixelFormat( DDPIXELFORMAT& ddFormat )
{
    HRESULT hr = NOERROR;
    // find the number of entries to be proposed
    DWORD dwNumProposedEntries = 0;
    hr = m_pIVPConfig->GetVideoFormats(&dwNumProposedEntries, NULL);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetVideoFormats failed, hr = 0x%x"), hr));
        return hr;
    }
    ASSERT(dwNumProposedEntries);

    PixelFormatList lpddProposedFormats(dwNumProposedEntries);
    if (lpddProposedFormats.GetEntries() == NULL)
    {
        DbgLog((LOG_ERROR,0,TEXT("NegotiatePixelFormat : Out of Memory")));
        hr = E_OUTOFMEMORY;
        return hr;
    }

    // get the entries proposed
    hr = m_pIVPConfig->GetVideoFormats(&dwNumProposedEntries, lpddProposedFormats.GetEntries() );
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("m_pIVPConfig->GetVideoFormats failed, hr = 0x%x"), hr));
        return hr;
    }

    // set the format the decoder is supposed to be using
    for (DWORD i = 0; i < dwNumProposedEntries; i++)
    {
        if (VPMUtil::EqualPixelFormats(lpddProposedFormats[i], ddFormat ))
        {
            hr = m_pIVPConfig->SetVideoFormat(i);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR,0,
                        TEXT("m_pIVPConfig->SetVideoFormat failed, hr = 0x%x"),
                        hr));
                return hr;
            }
            // cache the input format
            m_ddVPInputVideoFormat = ddFormat;

            break;
        }
    }
    return hr;
}


HRESULT CVideoPortObj::ReleaseVideoPort()
{
    HRESULT hr = S_OK;
    // tell the filter we've yanked the VP so that it doesn't hold onto refs to the VP
    if( m_pIVideoPortControl ) {
        hr = m_pIVideoPortControl->SignalNewVP( NULL );
    }
    // release it ourselves
    RELEASE( m_pVideoPort );
    return hr;
}

/*****************************Private*Routine******************************\
* CVideoPortObj::CreateVideoPort
*
* Displays the Create Video Port dialog and calls DDRAW to actually
* create the port.
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVideoPortObj::CreateVideoPort()
{
    HRESULT hr = NOERROR;
    DDVIDEOPORTDESC svpDesc;
    DWORD dwTemp = 0, dwOldVal = 0;
    DWORD lHalfLinesOdd = 0, lHalfLinesEven = 0;
    AMTRACE((TEXT("CVideoPortObj::CreateVideoPort")));

    CAutoLock cObjectLock(m_pMainObjLock);

    INITDDSTRUCT(svpDesc);

    // if the decoder can send double clocked data and the videoport
    // supports it, then set that property. This field is only valid
    // with an external signal.
    if (m_VPDataInfo.bEnableDoubleClock &&
        m_ddConnectInfo.dwFlags & DDVPCONNECT_DOUBLECLOCK)
    {
        svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_DOUBLECLOCK;
    }
    else
    {
        svpDesc.VideoPortType.dwFlags &= ~DDVPCONNECT_DOUBLECLOCK;
    }

    // if the decoder can give an external activation signal and the
    // videoport supports it, then set that property. This field is
    // only valid with an external signal.
    if (m_VPDataInfo.bEnableVACT &&
        m_ddConnectInfo.dwFlags & DDVPCONNECT_VACT)
    {
        svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_VACT;
    }
    else
    {
        svpDesc.VideoPortType.dwFlags &= ~DDVPCONNECT_VACT;
    }

    // if the decoder can send interlaced data and the videoport
    // supports it, then set that property.
    if (m_VPDataInfo.bDataIsInterlaced)
    {
        svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_INTERLACED;
        m_bVSInterlaced = TRUE;
    }
    else
    {
        svpDesc.VideoPortType.dwFlags &= ~DDVPCONNECT_INTERLACED;
        m_bVSInterlaced = FALSE;
    }

    // handle the VREF stuff here
    if (m_ddConnectInfo.dwFlags & DDVPCONNECT_DISCARDSVREFDATA)
    {
        m_VPDataInfo.amvpDimInfo.rcValidRegion.top -=
                m_VPDataInfo.dwNumLinesInVREF;

        if (m_VPDataInfo.amvpDimInfo.rcValidRegion.top < 0)
            m_VPDataInfo.amvpDimInfo.rcValidRegion.top = 0;
    }

    // handle the halfline stuff here
    lHalfLinesOdd = m_VPDataInfo.lHalfLinesOdd;
    lHalfLinesEven = m_VPDataInfo.lHalfLinesEven;

    // reset both the halfline and the invert polarity bits
    svpDesc.VideoPortType.dwFlags &= ~DDVPCONNECT_HALFLINE;
    svpDesc.VideoPortType.dwFlags &= ~DDVPCONNECT_INVERTPOLARITY;

    // if halflines are being reported assert that the data is interlaced
    if (lHalfLinesOdd != 0 || lHalfLinesEven != 0)
    {
        ASSERT(m_VPDataInfo.bDataIsInterlaced);
    }

    // whenever halflines exist, make sure to set the tell the hal
    if (((lHalfLinesOdd ==  1 || lHalfLinesEven ==  1) && (m_ddConnectInfo.dwFlags & DDVPCONNECT_HALFLINE)) ||
        ((lHalfLinesOdd == -1 || lHalfLinesEven == -1) && (!(m_ddConnectInfo.dwFlags & DDVPCONNECT_HALFLINE))))
    {
        svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_HALFLINE;
    }

    // In this case, the video is forced to move down one line
    // case 2 in scott's document
    if ((lHalfLinesOdd == 0) &&
        (lHalfLinesEven == 1) &&
        (m_ddConnectInfo.dwFlags & DDVPCONNECT_HALFLINE))
    {
        m_VPDataInfo.amvpDimInfo.rcValidRegion.top += 1;
        m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom += 2;
        m_fGarbageLine = true;

        // if the deocder is already not inverting fields and if the VGA supports
        // inverting polarities, then ask the VGA to invert polarities othwise ask
        // decoder to invert polarities.
        if (m_ddConnectInfo.dwFlags & DDVPCONNECT_INVERTPOLARITY)
        {
            svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_INVERTPOLARITY;
        }
        else
        {
            hr = m_pIVPConfig->SetInvertPolarity();
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR,0,
                        TEXT("m_pIVPConfig->SetInvertPolarity failed, hr = 0x%x"),
                        hr));
                goto CleanUp;
            }
        }
    }
    // case 3 and 5 in scott's document
    else if ((lHalfLinesOdd == 1) &&
             (lHalfLinesEven == 0))
    {
        // case 5 (just shift by one, do not reverse polarities
        m_VPDataInfo.amvpDimInfo.rcValidRegion.top += 1;
        m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom += 2;
        m_fGarbageLine = true;
        m_bCantInterleaveHalfline = TRUE;


        // case 3 (shift by one and reverse polarities)
        if (!(m_ddConnectInfo.dwFlags & DDVPCONNECT_HALFLINE))
        {
            // if the deocder is already not inverting fields and if the
            // VGA supports inverting polarities, then ask the VGA to invert
            // polarities othwise ask decoder to invert polarities.
            //
            if (m_ddConnectInfo.dwFlags & DDVPCONNECT_INVERTPOLARITY)
            {
                svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_INVERTPOLARITY;
            }
            else
            {
                hr = m_pIVPConfig->SetInvertPolarity();
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR,0,
                            TEXT("m_pIVPConfig->SetInvertPolarity failed,")
                            TEXT(" hr = 0x%x"),
                            hr));
                    goto CleanUp;
                }
            }
        }
    }
    // case 4 in scott's document
    else if ((lHalfLinesOdd == 0) &&
             (lHalfLinesEven == -1) &&
             (!(m_ddConnectInfo.dwFlags & DDVPCONNECT_HALFLINE)))
    {
        m_VPDataInfo.amvpDimInfo.rcValidRegion.top += 0;
        m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom += 1;
        m_fGarbageLine = true;
    }
    else if (((lHalfLinesOdd ==  0) && (lHalfLinesEven ==  0)) ||
             ((lHalfLinesOdd == -1) && (lHalfLinesEven ==  0) && (m_ddConnectInfo.dwFlags & DDVPCONNECT_HALFLINE)) ||
             ((lHalfLinesOdd ==  0) && (lHalfLinesEven == -1) && (m_ddConnectInfo.dwFlags & DDVPCONNECT_HALFLINE)) || // opposite of case 4
             ((lHalfLinesOdd ==  0) && (lHalfLinesEven ==  1) && (!(m_ddConnectInfo.dwFlags & DDVPCONNECT_HALFLINE)))) // opposite of case 2
    {
        // if the deocder is already inverting fields and if the VGA supports
        // inverting polarities, then ask the VGA to invert polarities
        // othwise ask decoder to invert polarities.
        if (m_VPDataInfo.bFieldPolarityInverted)
        {
            if (m_ddConnectInfo.dwFlags & DDVPCONNECT_INVERTPOLARITY)
            {
                svpDesc.VideoPortType.dwFlags |= DDVPCONNECT_INVERTPOLARITY;
            }
            else
            {
                hr = m_pIVPConfig->SetInvertPolarity();
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR,0,
                            TEXT("m_pIVPConfig->SetInvertPolarity failed,")
                            TEXT(" hr = 0x%x"), hr));
                    goto CleanUp;
                }
            }
        }
    }
    else
    {
        // Potential bug : workaround for current BPC driver
        // hr = E_FAIL; // we can't handle these cases, FAIL
        // goto CleanUp;
    }

    if (m_VPDataInfo.amvpDimInfo.dwFieldHeight <
        (DWORD)m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom)
    {
        m_VPDataInfo.amvpDimInfo.dwFieldHeight =
            m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom;
    }

    if ((m_vpCaps.dwFlags & DDVPD_WIDTH) &&
        (m_VPDataInfo.amvpDimInfo.dwFieldWidth > m_vpCaps.dwMaxWidth))
    {
        m_VPDataInfo.amvpDimInfo.dwFieldWidth = m_vpCaps.dwMaxWidth;
    }

    if ((m_vpCaps.dwFlags & DDVPD_WIDTH) &&
        (m_VPDataInfo.amvpDimInfo.dwVBIWidth > m_vpCaps.dwMaxVBIWidth))
    {
        m_VPDataInfo.amvpDimInfo.dwVBIWidth = m_vpCaps.dwMaxVBIWidth;
    }

    if ((m_vpCaps.dwFlags & DDVPD_HEIGHT) &&
        (m_VPDataInfo.amvpDimInfo.dwFieldHeight > m_vpCaps.dwMaxHeight))
    {
        m_VPDataInfo.amvpDimInfo.dwFieldHeight = m_vpCaps.dwMaxHeight;
    }

    if (m_VPDataInfo.amvpDimInfo.rcValidRegion.right >
        (LONG)m_VPDataInfo.amvpDimInfo.dwFieldWidth)
    {
        m_VPDataInfo.amvpDimInfo.rcValidRegion.right =
                (LONG)m_VPDataInfo.amvpDimInfo.dwFieldWidth;
    }

    if (m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom >
        (LONG)m_VPDataInfo.amvpDimInfo.dwFieldHeight)
    {
        m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom =
            (LONG)m_VPDataInfo.amvpDimInfo.dwFieldHeight;
    }

    // fill up the fields of the description struct
    svpDesc.dwFieldWidth = m_VPDataInfo.amvpDimInfo.dwFieldWidth;
    svpDesc.dwVBIWidth = m_VPDataInfo.amvpDimInfo.dwVBIWidth;
    svpDesc.dwFieldHeight = m_VPDataInfo.amvpDimInfo.dwFieldHeight;

    svpDesc.dwMicrosecondsPerField = m_VPDataInfo.dwMicrosecondsPerField;
    svpDesc.dwMaxPixelsPerSecond = m_dwPixelsPerSecond;
    svpDesc.dwVideoPortID = m_dwVideoPortId;
    svpDesc.VideoPortType.dwSize = sizeof(DDVIDEOPORTCONNECT);
    svpDesc.VideoPortType.dwPortWidth = m_ddConnectInfo.dwPortWidth;
    memcpy(&svpDesc.VideoPortType.guidTypeID, &m_ddConnectInfo.guidTypeID, sizeof(GUID));

    DbgLog((LOG_TRACE, 3, TEXT("svpDesc")));
    DbgLog((LOG_TRACE, 3, TEXT("dwFieldWidth = %u"), svpDesc.dwFieldWidth));
    DbgLog((LOG_TRACE, 3, TEXT("dwVBIWidth   = %u"), svpDesc.dwVBIWidth));
    DbgLog((LOG_TRACE, 3, TEXT("dwFieldHeight= %u"), svpDesc.dwFieldHeight));
    DbgLog((LOG_TRACE, 3, TEXT("dwMicrosecondsPerField= %u"), svpDesc.dwMicrosecondsPerField));
    DbgLog((LOG_TRACE, 3, TEXT("dwMaxPixelsPerSecond= %u"), svpDesc.dwMaxPixelsPerSecond));
    DbgLog((LOG_TRACE, 3, TEXT("dwVideoPortID= %u"), svpDesc.dwVideoPortID));
    DbgLog((LOG_TRACE, 3, TEXT("dwSize= %u"), svpDesc.VideoPortType.dwSize));
    DbgLog((LOG_TRACE, 3, TEXT("dwPortWidth= %u"), svpDesc.VideoPortType.dwPortWidth));

    // create the videoport. The first parameter is dwFlags, reserved for
    // future use by ddraw. The last parameter is pUnkOuter, again must be
    // NULL.
    //
    // use the DDVPCREATE_VIDEOONLY flag only if the hal is capable of
    // streaming VBI on a seperate surface
    //

    ReleaseVideoPort();

    if (m_vpCaps.dwCaps & DDVPCAPS_VBIANDVIDEOINDEPENDENT)
    {
        hr = m_pDVP->CreateVideoPort(DDVPCREATE_VIDEOONLY, &svpDesc,
                                     &m_pVideoPort, NULL);
        ASSERT( hr != DDERR_OUTOFCAPS ); // means videoport is in use, I.E. the VPM has leaked a ref count to the videoport
                                        // usually we forgot a RELEASE
        // ASSERT( SUCCEEDED(hr));
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("m_pDVP->CreateVideoPort(DDVPCREATE_VIDEOONLY)")
                    TEXT(" failed, hr = 0x%x"), hr));
        }
    } else {
        hr = m_pDVP->CreateVideoPort(0, &svpDesc, &m_pVideoPort, NULL);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("m_pDVP->CreateVideoPort(0) failed, hr = 0x%x"), hr));
        }
    }
    // tell the filter about the new VP in ReconnectVideoPortToSurface after we have a new surface

CleanUp:
    return hr;
}


/*****************************Private*Routine******************************\
* CVideoPortObj::DetermineCroppingRestrictions
*
*
* this function is used to check the cropping restrictions at the
* videoport and at the overlay. This function also decides where
* the cropping should be done (at videoport or at overlay).
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVideoPortObj::DetermineCroppingRestrictions()
{
    AMTRACE((TEXT("CVideoPortObj::DetermineCroppingRestrictions")));
    HRESULT hr = NOERROR;

    BOOL bVideoPortCanCrop = TRUE, bOverlayCanCrop = TRUE;
    DWORD dwTemp = 0, dwOldVal = 0;
    DWORD dwCropOriginX = 0, dwCropOriginY = 0;
    DWORD dwCropWidth = 0, dwCropHeight=0;
    const DDCAPS* pDirectCaps = NULL;


    CAutoLock cObjectLock(m_pMainObjLock);

    pDirectCaps = m_pIVideoPortControl->GetHardwareCaps();
    ASSERT(pDirectCaps);

    // cache the cropping paramters
    dwCropOriginX = m_VPDataInfo.amvpDimInfo.rcValidRegion.left;
    dwCropOriginY = m_VPDataInfo.amvpDimInfo.rcValidRegion.top;
    dwCropWidth = (DWORD)(m_VPDataInfo.amvpDimInfo.rcValidRegion.right -
                          m_VPDataInfo.amvpDimInfo.rcValidRegion.left);
    dwCropHeight = (DWORD)(m_VPDataInfo.amvpDimInfo.rcValidRegion.bottom -
                           m_VPDataInfo.amvpDimInfo.rcValidRegion.top);


    // Align the left boundary
    if (bVideoPortCanCrop && (m_vpCaps.dwFlags & DDVPD_ALIGN))
    {
        dwTemp = dwCropOriginX & (m_vpCaps.dwAlignVideoPortCropBoundary-1);
        if (dwTemp != 0)
        {
            dwOldVal = dwCropOriginX;
            dwCropOriginX = dwCropOriginX +
                            m_vpCaps.dwAlignVideoPortCropBoundary - dwTemp;

            m_VPDataInfo.amvpDimInfo.rcValidRegion.left = dwCropOriginX;
            dwCropWidth = (DWORD)(m_VPDataInfo.amvpDimInfo.rcValidRegion.right -
                                  m_VPDataInfo.amvpDimInfo.rcValidRegion.left);
            DbgLog((LOG_TRACE,2,
                    TEXT("Alligning the left cropping boundary from %d to %d"),
                    dwOldVal, dwCropOriginX));
        }
    }

    // Align the width
    if (bVideoPortCanCrop && (m_vpCaps.dwFlags & DDVPD_ALIGN))
    {
        dwTemp = dwCropWidth & (m_vpCaps.dwAlignVideoPortCropWidth-1);
        if (dwTemp != 0)
        {
            dwOldVal = dwCropOriginX;
            dwCropWidth = dwCropWidth - dwTemp;
            m_VPDataInfo.amvpDimInfo.rcValidRegion.right =
                dwCropWidth + (DWORD)(m_VPDataInfo.amvpDimInfo.rcValidRegion.left);
            DbgLog((LOG_TRACE,2,
                    TEXT("Alligning the width of cropping rect from %d to %d"),
                    dwOldVal, dwCropWidth));
        }
    }

    // determine if we can do without any cropping at all
    if (dwCropOriginX == 0 && dwCropOriginY == 0 &&
        dwCropWidth == m_VPDataInfo.amvpDimInfo.dwFieldWidth &&
        dwCropHeight == m_VPDataInfo.amvpDimInfo.dwFieldHeight)
    {
        // hurray we are home free!!!
        DbgLog((LOG_TRACE,1, TEXT("No cropping necessary")));
        m_CropState = VPInfoCropState_None;
        goto CleanUp;
    }

    // determine if the videoport can do the cropping for us

    // Can the videoport crop in the X direction
    if (bVideoPortCanCrop && (m_vpCaps.dwFlags & DDVPD_FX))
    {
        if (dwCropWidth != m_VPDataInfo.amvpDimInfo.dwFieldWidth &&
            (m_vpCaps.dwFX & DDVPFX_CROPX) == 0)
        {
            DbgLog((LOG_ERROR,1, TEXT("VideoPort can't crop, DDVPFX_CROPX == 0")));
            bVideoPortCanCrop = FALSE;
        }
    }

    // Can the videoport crop in the Y direction
    if (bVideoPortCanCrop && (m_vpCaps.dwFlags & DDVPD_FX))
    {
        if (dwCropHeight != m_VPDataInfo.amvpDimInfo.dwFieldHeight &&
            (m_vpCaps.dwFX & DDVPFX_CROPY) == 0 &&
            (m_vpCaps.dwFX & DDVPFX_CROPTOPDATA) == 0)
        {
            DbgLog((LOG_ERROR,1, TEXT("VideoPort can't crop, DDVPFX_CROPY == 0")));
            bVideoPortCanCrop = FALSE;
        }
    }


    // ok, so the videoport can crop for us. So no need to crop at the
    // overlay surface.
    if (bVideoPortCanCrop)
    {
        DbgLog((LOG_TRACE,2, TEXT("Cropping would be done at the videoport")));
        m_CropState = VPInfoCropState_AtVideoPort;
        goto CleanUp;
    }

    // determine if the overlay can do the cropping for us
    ASSERT( !"Cropping must be at overlay ... not supported" );
    // Is left boundary alligned
    if (bOverlayCanCrop && (pDirectCaps->dwCaps & DDCAPS_ALIGNBOUNDARYDEST))
    {
        dwTemp = dwCropOriginX & (pDirectCaps->dwAlignBoundaryDest-1);
        if (dwTemp != 0)
        {
            DbgLog((LOG_ERROR,1,
                    TEXT("Overlay can't crop, Align = %d, Crop.left = %d"),
                    dwTemp, dwCropOriginX));
            bOverlayCanCrop = FALSE;
        }
    }
    if (bOverlayCanCrop && (pDirectCaps->dwCaps & DDCAPS_ALIGNBOUNDARYSRC))
    {
        dwTemp = dwCropOriginX & (pDirectCaps->dwAlignBoundarySrc-1);
        if (dwTemp != 0)
        {
            DbgLog((LOG_ERROR,1,
                    TEXT("Overlay can't crop, Align = %d, Crop.left = %d"),
                    dwTemp, dwCropOriginX));
            bOverlayCanCrop = FALSE;
        }
    }

    // Is Width alligned
    if (bOverlayCanCrop && (pDirectCaps->dwCaps & DDCAPS_ALIGNSIZEDEST))
    {
        dwTemp = dwCropWidth & (pDirectCaps->dwAlignSizeDest -1);
        if (dwTemp != 0)
        {
            DbgLog((LOG_ERROR,1,
                    TEXT("Overlay can't crop, Align = %d, Crop.Width = %d"),
                    dwTemp, dwCropWidth));
            bOverlayCanCrop = FALSE;
        }
    }
    if (bOverlayCanCrop && (pDirectCaps->dwCaps & DDCAPS_ALIGNSIZESRC))
    {
        dwTemp = dwCropWidth & (pDirectCaps->dwAlignSizeSrc -1);
        if (dwTemp != 0)
        {
            DbgLog((LOG_ERROR,1,
                    TEXT("Overlay can't crop, Align = %d, Crop.Width = %d"),
                    dwTemp, dwCropWidth));
            bOverlayCanCrop = FALSE;
        }
    }

    // ok, the videoport was unsuitable but the overlay came through
    // this means more pain for me, no!!!
    if (bOverlayCanCrop)
    {
        hr = E_FAIL;
        goto CleanUp;
    }

    CleanUp:
    return hr;
}

HRESULT CVideoPortObj::RecreateSourceSurfaceChain()
{
    DWORD dwcSurfaces = m_dwBackBufferCount + 1;

    if( !m_pOutputSurface ) {
        return E_POINTER;
    }
    RELEASE( m_pOutputSurface1 );

    // required for SetTargetSurface for videoport
    HRESULT hResult = m_pOutputSurface->QueryInterface( IID_IDirectDrawSurface,  (VOID **)&m_pOutputSurface1 );
    if( FAILED( hResult )) {
        return hResult;
    }

    // otherwise we're leaking surface counts
    delete [] m_pChain;

    m_pChain = new Chain[dwcSurfaces];
    if ( ! m_pChain )
    {
        return E_OUTOFMEMORY;
    }
    m_pChain[0].pDDSurf = m_pOutputSurface;
    m_pChain[0].dwCount =0;
    if ( m_dwBackBufferCount )
    {
        LPDIRECTDRAWSURFACE7 pDDS = m_pOutputSurface;
        LPDIRECTDRAWSURFACE7 pDDSBack;
        for ( UINT i = 1; i < dwcSurfaces; i++ )
        {
            DDSCAPS2 caps = {0};
            m_pChain[i].pDDSurf = NULL;
            m_pChain[i].dwCount =0;

#ifdef DEBUG
            {
                DDSURFACEDESC2 ddSurfaceDesc;
                // get the surface description
                INITDDSTRUCT(ddSurfaceDesc);
                pDDS->GetSurfaceDesc(&ddSurfaceDesc);
            }
#endif

            if( i==1 ) {
                // for first attached get the back buffer
                caps.dwCaps = DDSCAPS_BACKBUFFER;
            } else {
                // for the rest get the complex surfaces
                // (since only the first has DDSCAPS_BACKBUFFER set)
                caps.dwCaps = DDSCAPS_COMPLEX;
            }
            if ( SUCCEEDED( pDDS->GetAttachedSurface( &caps, &pDDSBack ) ) )
            {
                m_pChain[i].pDDSurf = pDDSBack;
                pDDS = pDDSBack;
            } else {
                ASSERT( !"Fatal problem ... can't get attached surface (bug in video driver)" );
                return E_FAIL;
            }
        }
    }

    DbgLog((LOG_TRACE, 1,
            TEXT("Created an offscreen Surface of Width=%d,")
            TEXT(" Height=%d, Total-No-of-Buffers=%d"),
            m_dwOutputSurfaceWidth, m_dwOutputSurfaceHeight,
            dwcSurfaces ));
    return S_OK;
}

/*****************************Private*Routine******************************\
* CVideoPortObj::CreateVPOverlay
*
* this function is used to allocate an overlay surface to attach to the
* videoport.
* The allocation order it tries is just in decreasing amount of memory
* required. Theres is one ambiguity, which is resolved by bPreferBuffers
* (3 buffers, double height)
* (2 buffers, double height)
* (3 buffers, single height)
* (2 buffers, single height) OR (1 buffer , double height) (depends upon bPreferBuffers)
* (1 buffer , single height).
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT
CVideoPortObj::CreateSourceSurface(
    BOOL bTryDoubleHeight,
    DWORD dwMaxBuffers,
    BOOL bPreferBuffers)
{
    DDSURFACEDESC2 ddsdDesc;
    HRESULT hr = NOERROR;
    DWORD dwMaxHeight = 0, dwMinHeight = 0, dwCurHeight = 0, dwCurBuffers = 0;
    LPDIRECTDRAW7 pDirectDraw = NULL;

    AMTRACE((TEXT("CVideoPortObj::CreateVPOverlay")));

    CAutoLock cObjectLock(m_pMainObjLock);

    pDirectDraw = m_pIVideoPortControl->GetDirectDraw();
    ASSERT(pDirectDraw);

    // initialize the fields of ddsdDesc
    INITDDSTRUCT( ddsdDesc );
    ddsdDesc.dwFlags = DDSD_CAPS |
                       DDSD_HEIGHT |
                       DDSD_WIDTH |
                       DDSD_PIXELFORMAT;

    ddsdDesc.ddpfPixelFormat = m_ddVPOutputVideoFormat;

    ddsdDesc.ddsCaps.dwCaps = DDSCAPS_OFFSCREENPLAIN |
                              DDSCAPS_VIDEOMEMORY |
                              DDSCAPS_VIDEOPORT;
    ddsdDesc.dwWidth = m_lImageWidth;


    dwMaxHeight = dwMinHeight = m_lImageHeight;

    // make sure we don't leak the old surface
    DestroyOutputSurfaces();

    // we will try to allocate double height surface, only if the decoder is
    // sending interlaced data, and the videoport supports interlaced data
    // and can interleave interlaced data in memory and bTryDoubleHeight is true
    if (bTryDoubleHeight)
    {
        dwMaxHeight = 2 * m_lImageHeight;
    }
    else
    {
        // make sure that bPreferBuffers is TRUE here, since it is a single
        // height case making it FALSE would not make any sense
        bPreferBuffers = TRUE;
    }

    // we will only try to allocate more than one buffer, if the videoport
    // is cabable of autoflipping
    if (dwMaxBuffers > 1)
    {
        ddsdDesc.dwFlags |= DDSD_BACKBUFFERCOUNT;
        ddsdDesc.ddsCaps.dwCaps |= DDSCAPS_COMPLEX | DDSCAPS_FLIP;

        for (dwCurHeight = dwMaxHeight;
             !m_pOutputSurface && dwCurHeight >= dwMinHeight; dwCurHeight /= 2)
        {
            for (dwCurBuffers = dwMaxBuffers;
                 !m_pOutputSurface &&  dwCurBuffers >= 2; dwCurBuffers--)
            {

                // if the case is (2 buffers, single height) but we prefer
                // more height rather than more buffers, then postpone this
                // case. We will come to it eventually, if the other cases fail.
                if (!bPreferBuffers &&
                    dwCurBuffers == 2 &&
                    dwCurHeight == m_lImageHeight)
                {
                    continue;
                }

                ddsdDesc.dwHeight = dwCurHeight;
                ddsdDesc.dwBackBufferCount = dwCurBuffers-1;

                hr = pDirectDraw->CreateSurface(&ddsdDesc, &m_pOutputSurface, NULL);
                if (SUCCEEDED(hr))
                {
                    m_dwBackBufferCount = dwCurBuffers-1;
                    m_dwOutputSurfaceHeight = ddsdDesc.dwHeight;
                    m_dwOutputSurfaceWidth = ddsdDesc.dwWidth;
                    hr = RecreateSourceSurfaceChain();
                    goto CleanUp;
                }
            }
        }
    }

    // we should only reach this point when attempt to allocate multiple buffers
    // failed or no autoflip available or bPreferBuffers is FALSE


    // case (1 buffer, double height)
    if (dwMaxHeight == 2*m_lImageHeight)
    {
        ddsdDesc.dwHeight = 2*m_lImageHeight;
        ddsdDesc.dwFlags &= ~DDSD_BACKBUFFERCOUNT;
        ddsdDesc.ddsCaps.dwCaps &= ~(DDSCAPS_COMPLEX | DDSCAPS_FLIP);
        ddsdDesc.dwBackBufferCount = 0;

        hr = pDirectDraw->CreateSurface(&ddsdDesc, &m_pOutputSurface, NULL);
        if (SUCCEEDED(hr))
        {
            m_dwBackBufferCount = 0;
            m_dwOutputSurfaceHeight = ddsdDesc.dwHeight;
            m_dwOutputSurfaceWidth = ddsdDesc.dwWidth;
            hr = RecreateSourceSurfaceChain();
            goto CleanUp;
        }
    }

    // case (2 buffer, single height) only if you prefer height to buffers
    if (bPreferBuffers && (dwMaxBuffers > 1) &&
        (m_vpCaps.dwCaps & DDVPCAPS_AUTOFLIP))
    {
        ddsdDesc.dwFlags |= DDSD_BACKBUFFERCOUNT;
        ddsdDesc.ddsCaps.dwCaps |= DDSCAPS_COMPLEX | DDSCAPS_FLIP;

        ddsdDesc.dwHeight = 2*m_lImageHeight;
        ddsdDesc.dwBackBufferCount = 1;
        hr = pDirectDraw->CreateSurface(&ddsdDesc, &m_pOutputSurface, NULL);
        if (SUCCEEDED(hr))
        {
            m_dwBackBufferCount = 1;
            m_dwOutputSurfaceHeight = ddsdDesc.dwHeight;
            m_dwOutputSurfaceWidth = ddsdDesc.dwWidth;
            hr = RecreateSourceSurfaceChain();
            goto CleanUp;
        }
    }

    // case (1 buffer, single height)
    {
        ddsdDesc.dwHeight = m_lImageHeight;
        ddsdDesc.dwFlags &= ~DDSD_BACKBUFFERCOUNT;
        ddsdDesc.ddsCaps.dwCaps &= ~(DDSCAPS_COMPLEX | DDSCAPS_FLIP);
        ddsdDesc.dwBackBufferCount = 0;
        hr = pDirectDraw->CreateSurface(&ddsdDesc, &m_pOutputSurface, NULL);
        if (SUCCEEDED(hr))
        {
            m_dwBackBufferCount = 0;
            m_dwOutputSurfaceHeight = ddsdDesc.dwHeight;
            m_dwOutputSurfaceWidth = ddsdDesc.dwWidth;
            hr = RecreateSourceSurfaceChain();
            goto CleanUp;
        }
    }

    // ASSERT( m_pOutputSurface );
    DbgLog((LOG_TRACE, 1,  TEXT("Unable to create offset output surface")));

CleanUp:
    return hr;
}

static DWORD GetPitch( const DDSURFACEDESC2& ddSurf )
{
    const DDPIXELFORMAT& ddFormat = ddSurf.ddpfPixelFormat;

    if( ddSurf.dwFlags & DDSD_PITCH ) {
        return ddSurf.lPitch;
    } else {
        if( ddFormat.dwFlags & DDPF_FOURCC) {
            if( ddFormat.dwFourCC == mmioFOURCC('U','Y','V','Y') ) {
                return 2* ddSurf.dwWidth;
            }
        }
        return ddSurf.dwWidth;
    }
}


/*****************************Private*Routine******************************\
* CVideoPortObj::SetSurfaceParameters
*
* SetSurfaceParameters used to tell the decoder where the
* valid data is on the surface
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVideoPortObj::SetSurfaceParameters()
{
    HRESULT hr = NOERROR;
    DWORD dwPitch = 0;
    DDSURFACEDESC2 ddSurfaceDesc;

    AMTRACE((TEXT("CVideoPortObj::SetSurfaceParameters")));

    CAutoLock cObjectLock(m_pMainObjLock);

    // get the surface description
    INITDDSTRUCT(ddSurfaceDesc);
    hr = m_pOutputSurface->GetSurfaceDesc(&ddSurfaceDesc);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1,
                TEXT("m_pOutputSurface->GetSurfaceDesc failed, hr = 0x%x"),
                hr));
    }
    else
    {
        ASSERT(ddSurfaceDesc.dwFlags & DDSD_PITCH);
        dwPitch = GetPitch(ddSurfaceDesc);
    }

    hr = m_pIVPConfig->SetSurfaceParameters(dwPitch, 0, 0);

    // right now the proxy maps ERROR_SET_NOT_FOUND to an HRESULT and
    // returns that failure code if the driver does not implement a function
    //
    if (hr == E_NOTIMPL || hr == (HRESULT_FROM_WIN32(ERROR_SET_NOT_FOUND)))
    {
        hr = NOERROR;
        DbgLog((LOG_TRACE, 5,TEXT("SetSurfaceParamters not implemented")));
        goto CleanUp;
    }

    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 5,TEXT("SetSurfaceParamters failed, hr = 0x%x"), hr));
    }

CleanUp:
    return hr;
}



/*****************************Private*Routine******************************\
* CVideoPortObj::InitializeVideoPortInfo
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVideoPortObj::InitializeVideoPortInfo()
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVideoPortObj::InitializeVideoPortInfo")));

    CAutoLock cObjectLock(m_pMainObjLock);

    // initialize the DDVIDEOPORTINFO struct to be passed to start-video
    INITDDSTRUCT(m_svpInfo);
    m_svpInfo.lpddpfInputFormat = &m_ddVPInputVideoFormat;
    m_svpInfo.dwVPFlags = DDVP_AUTOFLIP;

    if (m_CropState == VPInfoCropState_AtVideoPort)
    {
        m_svpInfo.rCrop = m_VPDataInfo.amvpDimInfo.rcValidRegion;
        m_svpInfo.dwVPFlags |= DDVP_CROP;

        // use the VBI height only if the hal is capable of streaming
        // VBI on a seperate surface
        if (m_vpCaps.dwCaps & DDVPCAPS_VBIANDVIDEOINDEPENDENT)
        {
            m_svpInfo.dwVBIHeight = m_VPDataInfo.amvpDimInfo.rcValidRegion.top;
        }
    } else {
        m_svpInfo.dwVPFlags &= ~DDVP_CROP;
    }

    if (m_bVPSyncMaster) {
        m_svpInfo.dwVPFlags |= DDVP_SYNCMASTER;
    } else {
        m_svpInfo.dwVPFlags &= ~DDVP_SYNCMASTER;
    }

    return hr;
}


/*****************************Private*Routine******************************\
* CVideoPortObj::CheckDDrawVPCaps
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVideoPortObj::CheckDDrawVPCaps()
{
    HRESULT hr = NOERROR;
    BOOL bAlwaysColorkey;

    AMTRACE((TEXT("CVideoPortObj::CheckDDrawVPCaps")));

    CAutoLock cObjectLock(m_pMainObjLock);

    // Determine if we should always colorkey, or only when we need to.
    // At issue is the fact that some overlays cannot colorkey and Y
    // interpolate at the same time.  If not, we will only colorkey when
    // we have to.
    m_sBandwidth.dwSize = sizeof(DDVIDEOPORTBANDWIDTH);
    hr = m_pVideoPort->GetBandwidthInfo(&m_ddVPOutputVideoFormat,
                                        m_lImageWidth, m_lImageHeight,
                                        DDVPB_TYPE, &m_sBandwidth);

    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("m_pVideoPort->GetBandwidthInfo FAILED, hr = 0x%x"), hr));
        goto CleanUp;
    }

    if (m_sBandwidth.dwCaps == DDVPBCAPS_SOURCE)
    {
        hr = m_pVideoPort->GetBandwidthInfo(&m_ddVPOutputVideoFormat,
                                            m_lImageWidth, m_lImageHeight,
                                            DDVPB_OVERLAY, &m_sBandwidth);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("m_pVideoPort->GetBandwidthInfo FAILED, hr = 0x%x"),
                    hr));
            goto CleanUp;
        }
        // store the caps info in this struct itself
        m_sBandwidth.dwCaps = DDVPBCAPS_SOURCE;
        if (m_sBandwidth.dwYInterpAndColorkey < m_sBandwidth.dwYInterpolate  &&
            m_sBandwidth.dwYInterpAndColorkey < m_sBandwidth.dwColorkey)
        {
            bAlwaysColorkey = FALSE;
        }
        else
        {
            bAlwaysColorkey = TRUE;
        }
    }
    else
    {
        ASSERT(m_sBandwidth.dwCaps == DDVPBCAPS_DESTINATION);


        DWORD dwImageHeight = m_lImageHeight;
        if (m_fCaptureInterleaved) {
            dwImageHeight /= 2;
        }

        hr = m_pVideoPort->GetBandwidthInfo(&m_ddVPOutputVideoFormat,
                                            m_lImageWidth, dwImageHeight,
                                            DDVPB_VIDEOPORT, &m_sBandwidth);
        if (hr != DD_OK)
        {
            DbgLog((LOG_ERROR, 0,
                    TEXT("GetBandwidthInfo FAILED, hr = 0x%x"), hr));
            goto CleanUp;
        }
        // store the caps info in this struct itself
        m_sBandwidth.dwCaps = DDVPBCAPS_DESTINATION;
        if (m_sBandwidth.dwYInterpAndColorkey > m_sBandwidth.dwYInterpolate &&
            m_sBandwidth.dwYInterpAndColorkey > m_sBandwidth.dwColorkey)
        {
            bAlwaysColorkey = FALSE;
        }
        else
        {
            bAlwaysColorkey = TRUE;
        }
    }

    // determine the decimation properties in the x direction

    // Data can be arbitrarily shrunk
    if (m_vpCaps.dwFX & DDVPFX_PRESHRINKX) {
        m_DecimationModeX = DECIMATE_ARB;
    }

    // Data can be shrunk in increments of 1/x in the X direction
    // (where x is specified in the DDVIDEOPORTCAPS.dwPreshrinkXStep
    else if (m_vpCaps.dwFX & DDVPFX_PRESHRINKXS) {

        m_DecimationModeX = DECIMATE_INC;
        m_ulDeciStepX = m_vpCaps.dwPreshrinkXStep;

        DbgLog((LOG_TRACE, 1,
                TEXT("preshrink X increment %d"), m_vpCaps.dwPreshrinkXStep));
    }

    // Data can be binary shrunk (1/2, 1/4, 1/8, etc.)
    else if (m_vpCaps.dwFX & DDVPFX_PRESHRINKXB) {

        m_DecimationModeX = DECIMATE_BIN;
    }

    // no scaling at all supported !!
    else {

        m_DecimationModeX = DECIMATE_NONE;
    }

    // determine the decimation properties in the y direction

    // Data can be arbitrarily shrunk
    if (m_vpCaps.dwFX & DDVPFX_PRESHRINKY)
    {
        m_DecimationModeY = DECIMATE_ARB;
    }

    // Data can be shrunk in increments of 1/x in the Y direction
    // (where x is specified in the DDVIDEOPORTCAPS.dwPreshrinkYStep
    else if (m_vpCaps.dwFX & DDVPFX_PRESHRINKYS)
    {
        m_DecimationModeY = DECIMATE_INC;
        m_ulDeciStepX = m_vpCaps.dwPreshrinkYStep;
    }

    // Data can be binary shrunk (1/2, 1/4, 1/8, etc.)
    else if (m_vpCaps.dwFX & DDVPFX_PRESHRINKYB)
    {
        m_DecimationModeY = DECIMATE_BIN;
    }

    else {
        m_DecimationModeY = DECIMATE_NONE;
    }

CleanUp:
    return hr;
}




/*****************************Private*Routine******************************\
* CVideoPortObj::DetermineModeRestrictions
*
* Determine if we can bob(interleaved/non), weave, or skip fields
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVideoPortObj::DetermineModeRestrictions()
{
    AMTRACE((TEXT("CVideoPortObj::DetermineModeRestrictions")));
    HRESULT hr = NOERROR;
    const DDCAPS* pDirectCaps = NULL;

    CAutoLock cObjectLock(m_pMainObjLock);

    pDirectCaps = m_pIVideoPortControl->GetHardwareCaps();
    ASSERT(pDirectCaps);

    m_bCanWeave = FALSE;
    m_bCanBobInterleaved = FALSE;
    m_bCanBobNonInterleaved = FALSE;
    m_bCanSkipOdd = FALSE;
    m_bCanSkipEven = FALSE;

    // this is just a policy. Don't weave interlaced content cause of
    // motion artifacts
    if ((!m_bVSInterlaced) &&
        m_dwOutputSurfaceHeight >= m_lImageHeight * 2 &&
        m_dwBackBufferCount > 0)
    {
        m_bCanWeave = TRUE;
        DbgLog((LOG_TRACE, 1, TEXT("Can Weave")));
    }

    if (m_bVSInterlaced &&
        m_dwOutputSurfaceHeight >= m_lImageHeight * 2 &&
        pDirectCaps->dwCaps2 & DDCAPS2_CANBOBINTERLEAVED)
    {
        m_bCanBobInterleaved = TRUE;
        DbgLog((LOG_TRACE, 1, TEXT("Can Bob Interleaved")));
    }

    if (m_bVSInterlaced &&
        m_dwBackBufferCount > 0 &&
        pDirectCaps->dwCaps2 & DDCAPS2_CANBOBNONINTERLEAVED)
    {
        m_bCanBobNonInterleaved = TRUE;
        DbgLog((LOG_TRACE, 1, TEXT("Can Bob NonInterleaved")));
    }

    if (m_vpCaps.dwCaps & DDVPCAPS_SKIPODDFIELDS)
    {
        m_bCanSkipOdd = TRUE;
        DbgLog((LOG_TRACE, 1, TEXT("Can Skip Odd")));
    }

    if (m_vpCaps.dwCaps & DDVPCAPS_SKIPEVENFIELDS)
    {
        m_bCanSkipEven = TRUE;
        DbgLog((LOG_TRACE, 1, TEXT("Can Skip Even")));
    }

    return hr;
}


/*****************************Private*Routine******************************\
* CVideoPortObj::SetDDrawKernelHandles
*
* this function is used to inform the decoder of the various ddraw
* kernel handle using IVPConfig interface
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVideoPortObj::SetDDrawKernelHandles()
{
    HRESULT hr = NOERROR, hrFailure = NOERROR;
    IDirectDrawKernel *pDDK = NULL;
    IDirectDrawSurfaceKernel *pDDSK = NULL;
    DWORD *pdwKernelHandleCount = 0;
    DWORD dwCount = 0;
    ULONG_PTR dwDDKernelHandle = 0;
    LPDIRECTDRAW7 pDirectDraw = NULL;

    AMTRACE((TEXT("CVideoPortObj::SetDDrawKernelHandles")));

    CAutoLock cObjectLock(m_pMainObjLock);

    pDirectDraw = m_pIVideoPortControl->GetDirectDraw();
    ASSERT(pDirectDraw);

    // get the IDirectDrawKernel interface
    hr = pDirectDraw->QueryInterface(IID_IDirectDrawKernel, (LPVOID *)&pDDK);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("QueryInterface for IDirectDrawKernel failed, hr = 0x%x"),
                hr));
        goto CleanUp;
    }

    // get the kernel handle
    ASSERT(pDDK);
    hr = pDDK->GetKernelHandle(&dwDDKernelHandle);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("GetKernelHandle from IDirectDrawKernel failed, hr = 0x%x"),
                hr));
        goto CleanUp;
    }

    // set the kernel handle to directdraw using IVPConfig
    ASSERT(m_pIVPConfig);
    ASSERT(dwDDKernelHandle);
    hr = m_pIVPConfig->SetDirectDrawKernelHandle(dwDDKernelHandle);
    if (FAILED(hr))
    {
        hrFailure = hr;
        DbgLog((LOG_ERROR,0,
                TEXT("IVPConfig::SetDirectDrawKernelHandle failed, hr = 0x%x"),
                hr));
        goto CleanUp;
    }

    // set the VidceoPort Id using IVPConfig
    ASSERT(m_pIVPConfig);
    hr = m_pIVPConfig->SetVideoPortID(m_dwVideoPortId);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0,
                TEXT("IVPConfig::SetVideoPortID failed, hr = 0x%x"), hr));
        goto CleanUp;
    }
    {
        KernelHandleArray pArray( m_pOutputSurface, hr );

        if( SUCCEEDED( hr )) {
            // set the kernel handle to the overlay surface using IVPConfig
            ASSERT(m_pIVPConfig);
            hr = m_pIVPConfig->SetDDSurfaceKernelHandles( pArray.GetCount(), pArray.GetHandles() );
            if (FAILED(hr))
            {
                hrFailure = hr;
                DbgLog((LOG_ERROR,0,
                        TEXT("IVPConfig::SetDirectDrawKernelHandles failed,")
                        TEXT(" hr = 0x%x"), hr));
                goto CleanUp;
            }
        }
    }
CleanUp:
    // release the kernel ddraw handle
    RELEASE (pDDK);
    return hrFailure;
}

/*****************************Private*Routine******************************\
* CVideoPortObj::SetUpMode
*
* This function is designed to be called everytime on an update-overlay call
* not just when the mode changes. This is basically to keep the code simple.
* Certain functions are supposed to be called in sequence,
* (SetUpMode, followedby AdjustSourceSize followedby SetDisplayRects).
* I just call them all everytime, eventhough it is possible to optimize on
* that. The logic is that since UpdateOverlay is so expensive, this is no
* performance hit.
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
HRESULT CVideoPortObj::SetUpMode( AMVP_MODE mode )
{
    HRESULT hr = NOERROR;

    AMTRACE((TEXT("CVideoPortObj::SetUpMode")));

    CAutoLock cObjectLock(m_pMainObjLock);

    switch( mode ) {
        case AMVP_MODE_WEAVE:
        case AMVP_MODE_BOBINTERLEAVED:
        case AMVP_MODE_BOBNONINTERLEAVED:
        case AMVP_MODE_SKIPODD:
        case AMVP_MODE_SKIPEVEN:
        break;
        default:
            DbgLog((LOG_ERROR, 0,
                    TEXT("SetUpMode failed, mode value not valid, mode = %d"),
                    mode));
            hr = E_FAIL;
            goto CleanUp;
    }

    if (mode == AMVP_MODE_WEAVE && !m_bCanWeave)
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("SetUpMode failed, Can't do mode AMVP_MODE_WEAVE")));
        hr = E_FAIL;
        goto CleanUp;
    }
    if (mode == AMVP_MODE_BOBINTERLEAVED && !m_bCanBobInterleaved)
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("SetUpMode failed, Can't do mode AMVP_MODE_BOBINTERLEAVED")));
        hr = E_FAIL;
        goto CleanUp;
    }
    if (mode == AMVP_MODE_BOBNONINTERLEAVED && !m_bCanBobNonInterleaved)
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("SetUpMode failed, Can't do mode AMVP_MODE_BOBNONINTERLEAVED")));
        hr = E_FAIL;
        goto CleanUp;
    }
    if (mode == AMVP_MODE_SKIPODD && !m_bCanSkipOdd)
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("SetUpMode failed, Can't do mode AMVP_MODE_SKIPODD")));
        hr = E_FAIL;
        goto CleanUp;
    }
    if (mode == AMVP_MODE_SKIPEVEN && !m_bCanSkipEven)
    {
        DbgLog((LOG_ERROR, 0,
                TEXT("SetUpMode failed, Can't do mode AMVP_MODE_SKIPEVEN")));
        hr = E_FAIL;
        goto CleanUp;
    }

    // Determine if we should interleave this or not.
    // If we are doing weave, we certainly need to interleave.
    // Bob doesn't really care one way or the other (since it only
    // displays one field at a time), but interleaved makes it much
    // easier to switch from bob to weave.
    if (mode == AMVP_MODE_BOBINTERLEAVED ||
        mode == AMVP_MODE_WEAVE)
    {
        m_svpInfo.dwVPFlags |= DDVP_INTERLEAVE;

        DbgLog((LOG_TRACE, 3, TEXT("Setting VPflag interleaved")));
        m_fHalfHeightVideo = false;
    }
    else
    {
        m_svpInfo.dwVPFlags &= ~DDVP_INTERLEAVE;
        m_fHalfHeightVideo = true;
        // pWinInfo->SrcRect.top /= 2;
        // pWinInfo->SrcRect.bottom /= 2;
    }

    // if there is a garbage line at the top, we must clip it.
    // At this point the source rect is set up for a frame, so increment by 2
    // since we incremented the cropping rect height by 1, decrement the bottom
    // as well
    if (m_fGarbageLine)
    {
        // Done in blit
        //pWinInfo->SrcRect.top += 1;
        //pWinInfo->SrcRect.bottom -= 1;
        DbgLog((LOG_TRACE, 3,
                TEXT("m_fGarbageLine is TRUE, incrementing SrcRect.top")));
    }

    if (mode == AMVP_MODE_SKIPODD)
    {
        m_svpInfo.dwVPFlags |= DDVP_SKIPODDFIELDS;
        DbgLog((LOG_TRACE, 3, TEXT("Setting VPflag SkipOddFields")));
    }
    else
    {
        m_svpInfo.dwVPFlags &= ~DDVP_SKIPODDFIELDS;
    }

    if (mode == AMVP_MODE_SKIPEVEN)
    {
        m_svpInfo.dwVPFlags |= DDVP_SKIPEVENFIELDS;
        DbgLog((LOG_TRACE, 3, TEXT("Setting VPflag SkipEvenFields")));
    }
    else
    {
        m_svpInfo.dwVPFlags &= ~DDVP_SKIPEVENFIELDS;
    }

CleanUp:
    return hr;
}


/******************************Public*Routine******************************\
* CVideoPortObj::RenegotiateVPParameters
*
* this function is used to redo the whole videoport connect process,
* while the graph maybe be running.
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::RenegotiateVPParameters()
{
    HRESULT hr = NOERROR;
    VPInfoState vpOldState;

    AMTRACE((TEXT("CVideoPortObj::RenegotiateVPParameters")));

    CAutoLock cObjectLock(m_pMainObjLock);

    // don't return an error code if not connected
    if (!m_bConnected)
    {
        hr = NOERROR;
        goto CleanUp;
    }

    LPDIRECTDRAW7 pDirectDraw = m_pIVideoPortControl->GetDirectDraw();
    if( pDirectDraw ) {
        if( pDirectDraw->TestCooperativeLevel() != DD_OK ) {
            // Don't alter the videoport while in exclusive mode, otherwise
            // the DXG kernel layer drifts out of sync with DDraw
            return S_OK;
        }
    }

    // store the old state, we will need to restore it later
    vpOldState = m_VPState;

    if (m_VPState == VPInfoState_RUNNING)
    {
        m_VPState = VPInfoState_STOPPED;
    }

    // release everything except IVPConfig 
    hr = StopUsingVideoPort();


    // redo the connection process
    hr = SetupVideoPort();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0, TEXT("CompleteConnect failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // also notifies VPMThread about new VP & surfaces
    hr = AttachVideoPortToSurface();
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR,0, TEXT("AttachVideoPortToSurface failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

    // if the video was previously running, make sure that a frame is
    // visible by making an update overlay call
    if (vpOldState == VPInfoState_RUNNING)
    {
        m_bStart = TRUE;

        hr = m_pIVideoPortControl->StartVideo();

        ASSERT( SUCCEEDED(hr));
        if (FAILED(hr))
        {
           DbgLog((LOG_ERROR,0,
                   TEXT("Start video failed failed, hr = 0x%x"), hr));
           goto CleanUp;
        }

#if 0 // hack to get the Rage128 playing video again, probably the software autoflipping
        // is broken.  After a aspect ratio change or res mode change, the autoflipping doesn't start up again
        hr = m_pVideoPort->StopVideo();

        // ATI seems to want another set of stop/start's to actually start
        // autoflipping again...
        m_bStart = TRUE;
        hr = m_pIVideoPortControl->StartVideo();
#endif

        m_VPState = VPInfoState_RUNNING;
    }
    // send a dynamic reconnect to the downstream filter

    if( SUCCEEDED( hr )) {
        hr = SignalNewVP();
    }

CleanUp:
    if (FAILED(hr))
    {
        hr = VFW_E_VP_NEGOTIATION_FAILED;
        BreakConnect(TRUE);

        m_pIVideoPortControl->EventNotify(EC_COMPLETE, S_OK, 0);
        m_pIVideoPortControl->EventNotify(EC_ERRORABORT, hr, 0);
    }

    return hr;
}


/******************************Public*Routine******************************\
* CVideoPortObj::SetDeinterlaceMode
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::SetDeinterlaceMode(AMVP_MODE mode)
{
    AMTRACE((TEXT("CVideoPortObj::SetMode")));
    return E_NOTIMPL;
}

/******************************Public*Routine******************************\
* CVideoPortObj::GetDeinterlaceMode
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::GetDeinterlaceMode(AMVP_MODE *pMode)
{
    AMTRACE((TEXT("CVideoPortObj::GetMode")));
    return E_NOTIMPL;
}


/******************************Public*Routine******************************\
* CVideoPortObj::SetVPSyncMaster
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::SetVPSyncMaster(BOOL bVPSyncMaster)
{
    HRESULT hr = NOERROR;
    AMTRACE((TEXT("CVideoPortObj::SetVPSyncMaster")));

    CAutoLock cObjectLock(m_pMainObjLock);

    // if value has not changed, no need to do anything
    if (m_bVPSyncMaster != bVPSyncMaster)
    {
        // store the new value
        m_bVPSyncMaster = bVPSyncMaster;

        // if not connected, connection process will take care of updating the
        // m_svpInfo struct
        if (!m_bConnected)
            goto CleanUp;

        // update the m_svpInfo struct
        if (m_bVPSyncMaster) {
            m_svpInfo.dwVPFlags |= DDVP_SYNCMASTER;
        }
        else {
            m_svpInfo.dwVPFlags &= ~DDVP_SYNCMASTER;
        }

        // if video is stopped currently, no need to do anything else
        if (m_VPState == VPInfoState_STOPPED)
            goto CleanUp;

        // Call UpdateVideo to make sure the change is reflected immediately
        ASSERT( m_svpInfo.dwVPFlags & DDVP_AUTOFLIP );
        hr = m_pVideoPort->UpdateVideo(&m_svpInfo);
        if (FAILED(hr))
        {
            DbgLog((LOG_ERROR,0, TEXT("UpdateVideo failed, hr = 0x%x"), hr));
        }
    }

CleanUp:
    return hr;
}


/******************************Public*Routine******************************\
* CVideoPortObj::GetVPSyncMaster
*
*
*
* History:
* Thu 09/09/1999 - StEstrop - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::GetVPSyncMaster(BOOL *pbVPSyncMaster)
{
    HRESULT hr = NOERROR;
    AMTRACE((TEXT("CVideoPortObj::SetVPSyncMaster")));

    CAutoLock cObjectLock(m_pMainObjLock);

    if (pbVPSyncMaster) {
        *pbVPSyncMaster = m_bVPSyncMaster;
    }
    else {
        hr = E_INVALIDARG;
    }

    return hr;
}

/******************************Public*Routine******************************\
* CVideoPortObj::GetVPSyncMaster
*
*
*
* History:
* Thu 09/09/1999 - GlennE - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::GetAllOutputFormats( const PixelFormatList** ppList )
{
    AMTRACE((TEXT("CVideoPortObj::GetAllOutputFormats")));
    CAutoLock cObjectLock(m_pMainObjLock);

    *ppList = &m_ddAllOutputVideoFormats;
    return S_OK;
}

STDMETHODIMP CVideoPortObj::GetOutputFormat( DDPIXELFORMAT* pFormat )
{
    AMTRACE((TEXT("CVideoPortObj::GetOutputFormat")));
    CAutoLock cObjectLock(m_pMainObjLock);

    *pFormat = m_ddVPOutputVideoFormat;
    return S_OK;
}

/******************************Public*Routine******************************\
* CVideoPortObj::SetVideoPortID
*
*
*
* History:
* Thu 09/09/1999 - GlennE - Added this comment and cleaned up the code
*
\**************************************************************************/
STDMETHODIMP CVideoPortObj::SetVideoPortID( DWORD dwVideoPortId )
{
    AMTRACE((TEXT("CVideoPortObj::SetVideoPortID")));
    CAutoLock cObjectLock(m_pMainObjLock);

    HRESULT hr = S_OK;
    if ( m_dwVideoPortId != dwVideoPortId ) {
        // we can't switch ports when running
        if( m_VPState != VPInfoState_STOPPED ) {
            hr = VFW_E_WRONG_STATE;
        } else {
            if( m_pDVP ) {
                hr = VPMUtil::FindVideoPortCaps( m_pDVP, NULL, m_dwVideoPortId );
            } else {
                LPDIRECTDRAW7 pDirectDraw = m_pIVideoPortControl->GetDirectDraw();
                hr = VPMUtil::FindVideoPortCaps( pDirectDraw, NULL, m_dwVideoPortId );
            }
            if( hr == S_OK) {
                m_dwVideoPortId = dwVideoPortId;
            } else if( hr == S_FALSE ) {
                return E_INVALIDARG;
            }// else fail 
        }
    }
    return hr;
}

static HRESULT GetRectFromImage( LPDIRECTDRAWSURFACE7 pSurf, RECT* pRect )
{
    // assume entire dest for now ....
    DDSURFACEDESC2 ddsd;
    INITDDSTRUCT( ddsd );
    HRESULT hr = pSurf->GetSurfaceDesc( &ddsd );
    if ( SUCCEEDED(hr) ) {
        pRect->left = 0;
        pRect->top = 0;
        pRect->right = ddsd.dwWidth;
        pRect->bottom = ddsd.dwHeight;
    }
    return hr;
}

#ifdef DEBUG
// #define DEBUG_BLTS
#endif

#ifdef DEBUG_BLTS
static BYTE Clamp(float clr)
{
    if (clr < 0.0f) {
        return (BYTE)0;
    } else if (clr > 255.0f) {
        return (BYTE)255;
    } else {
        return (BYTE)clr;
    }
}

static RGBQUAD
ConvertYCrCbToRGB(
    int y,
    int cr,
    int cb
    )
{
    RGBQUAD rgbq;

    float r = (1.1644f * (y-16)) + (1.5960f * (cr-128));
    float g = (1.1644f * (y-16)) - (0.8150f * (cr-128)) - (0.3912f * (cb-128));
    float b = (1.1644f * (y-16))                        + (2.0140f * (cb-128));


    rgbq.rgbBlue  = Clamp(b);
    rgbq.rgbGreen = Clamp(g);
    rgbq.rgbRed   = Clamp(r);
    rgbq.rgbReserved = 0; // Alpha

    return rgbq;
}

static void MyCopyBlt( const DDSURFACEDESC2& ddsdS, const RECT* pSrcRect,
						   const DDSURFACEDESC2& ddsdT, const RECT* pDestRect, const UINT pixelSize )
{
    const LONG srcPitch = ddsdS.lPitch;
    const LONG destPitch = ddsdT.lPitch;

    const BYTE* pSrc = (BYTE *)ddsdS.lpSurface + pSrcRect->left * pixelSize;
    BYTE* pDest = (BYTE *)ddsdT.lpSurface + pDestRect->left * pixelSize;

    const UINT LineLength = (pSrcRect->right - pSrcRect->left) * pixelSize;

    for( INT y=pSrcRect->top; y < pSrcRect->bottom; y++ ) {
        CopyMemory( pDest + y * destPitch, pSrc + y * srcPitch, LineLength );
    }

}

static void CopyYUY2LineToRGBA( BYTE* pDest, const BYTE* pSrc, UINT width )
{
    while( width > 0 ) {
        int  y0 = (int)pSrc[0];
        int  cb = (int)pSrc[1];
        int  y1 = (int)pSrc[2];
        int  cr = (int)pSrc[3];

        pSrc += 4;

        RGBQUAD r = ConvertYCrCbToRGB(y0, cr, cb);
        pDest[0] = r.rgbBlue;
        pDest[1] = r.rgbGreen;
        pDest[2] = r.rgbRed;
        pDest[3] = 0; // Alpha

        pDest +=4;

        width--;
        if( width > 0 ) {
            pDest[0] = r.rgbBlue;
            pDest[1] = r.rgbGreen;
            pDest[2] = r.rgbRed;
            pDest[3] = 0; // Alpha

            pDest +=4;
            width--;
        }
    }   
}

static void MyCopyYUY2ToRGBA( const DDSURFACEDESC2& ddsdS, const RECT* pSrcRect,
						   const DDSURFACEDESC2& ddsdT, const RECT* pDestRect )
{
    const LONG srcPitch = ddsdS.lPitch;
    const LONG destPitch = ddsdT.lPitch;

    ASSERT( (pSrcRect->left & 1) == 0 ); // can only convert on even edges for now
    ASSERT( (pSrcRect->right & 1) == 0 ); // can only convert on even edges for now
    
    const BYTE* pSrc = (BYTE *)ddsdS.lpSurface + pSrcRect->left * 2;
    BYTE* pDest = (BYTE *)ddsdT.lpSurface + pDestRect->left * 4;

    const UINT LineWidth = (pSrcRect->right - pSrcRect->left);

    for( INT y=pSrcRect->top; y < pSrcRect->bottom; y++ ) {
        CopyYUY2LineToRGBA( pDest + y * destPitch, pSrc + y * srcPitch, LineWidth );
    }

}

static void MyCopyYUY2Blt( const DDSURFACEDESC2& ddsdS, const RECT* pSrcRect,
						   const DDSURFACEDESC2& ddsdT, const RECT* pDestRect )
{
	MyCopyBlt( ddsdS, pSrcRect, ddsdT, pDestRect,2 );
}

static void MyCopyUYVYBlt( const DDSURFACEDESC2& ddsdS, const RECT* pSrcRect,
						   const DDSURFACEDESC2& ddsdT, const RECT* pDestRect )
{
	MyCopyBlt( ddsdS, pSrcRect, ddsdT, pDestRect,2 );
}

// handy debugging routine to test faulty UYVY blits
static HRESULT MyCopyUYVYSurf( LPDIRECTDRAWSURFACE7 pDestSurf, const RECT* pDestRect, LPDIRECTDRAWSURFACE7 pSrcSurf, const RECT* pSrcRect )
{
    DDSURFACEDESC2 ddsdS = {sizeof(ddsdS)};
    DDSURFACEDESC2 ddsdT = {sizeof(ddsdT)};

    HRESULT hr = pSrcSurf->Lock(NULL, &ddsdS, DDLOCK_NOSYSLOCK, NULL);
    ASSERT( SUCCEEDED( hr));
    if (hr != DD_OK) {
        return hr;
    }

    hr = pDestSurf->Lock(NULL, &ddsdT, DDLOCK_NOSYSLOCK, NULL);
    ASSERT( SUCCEEDED( hr));
    if (hr != DD_OK) {
        pSrcSurf->Unlock(NULL);
        return hr;
    }

    ASSERT( WIDTH( pSrcRect ) == WIDTH( pDestRect) );
    ASSERT( HEIGHT( pSrcRect ) == HEIGHT( pDestRect) );

    // we should not do conversions in the VPM, let the VMR do the work
    ASSERT( ddsdS.ddpfPixelFormat.dwFourCC == ddsdT.ddpfPixelFormat.dwFourCC );

	if( ddsdS.ddpfPixelFormat.dwFourCC == MAKEFOURCC('U', 'Y', 'V', 'Y' ) &&
		ddsdT.ddpfPixelFormat.dwFourCC == MAKEFOURCC('U', 'Y', 'V', 'Y' ) ) {
		MyCopyUYVYBlt( ddsdS, pSrcRect, ddsdT, pDestRect );
	} else
	if( ddsdS.ddpfPixelFormat.dwFourCC == MAKEFOURCC('Y', 'U', 'Y', '2' ) &&
		ddsdT.ddpfPixelFormat.dwFourCC == MAKEFOURCC('Y', 'U', 'Y', '2' ) ) {
		MyCopyYUY2Blt( ddsdS, pSrcRect, ddsdT, pDestRect );
    } else {
	// if( ddsdS.ddpfPixelFormat.dwFourCC == MAKEFOURCC('Y', 'U', 'Y', '2' ) &&
	//	ddsdT.ddpfPixelFormat.dwFourCC == 0 ) {
	// 	MyCopyYUY2ToRGBA( ddsdS, pSrcRect, ddsdT, pDestRect );
	// } else {
		ASSERT( !"Can't handle MyBlt format" );
	}

    pSrcSurf->Unlock(NULL);
    pDestSurf->Unlock(NULL);
    return S_OK;
}

#endif

static LPDIRECTDRAW7 GetDDrawFromSurface( LPDIRECTDRAWSURFACE7 pDestSurface )
{
    IUnknown  *pDDrawObjUnk ;
    HRESULT hr = pDestSurface->GetDDInterface((LPVOID*)&pDDrawObjUnk) ;
    if (SUCCEEDED(hr) ) {
        LPDIRECTDRAW7 pDDObj;
        hr = pDDrawObjUnk->QueryInterface(IID_IDirectDraw7, (LPVOID *) &pDDObj);
        pDDrawObjUnk->Release();
        if( SUCCEEDED( hr )) {
            return pDDObj;
        }
    }
    return NULL;
}

HRESULT CVideoPortObj::CallUpdateSurface( DWORD dwSourceIndex, LPDIRECTDRAWSURFACE7 pDestSurface )
{
    if ( dwSourceIndex > m_dwBackBufferCount ) {
        ASSERT( !"Invalid source index" );
        return E_INVALIDARG;
    }
    //Debug: use the previous surface
    // DWORD dwNumSurfaces= m_dwBackBufferCount+1;
    // dwSourceIndex = (dwNumSurfaces+dwSourceIndex-1) % dwNumSurfaces;

    ASSERT( m_pChain );
    LPDIRECTDRAWSURFACE7 pSourceSurface = m_pChain[dwSourceIndex].pDDSurf;

    // if we fail at this point, something is really wrong
    ASSERT( pDestSurface );
    ASSERT( pSourceSurface );

    if( !pSourceSurface || !pDestSurface ) {
        return E_FAIL;
    }
    // gather stats to verify distribution of surfaces
    m_pChain[dwSourceIndex].dwCount++;

    HRESULT hr = S_OK;

    RECT rSrc = m_VPDataInfo.amvpDimInfo.rcValidRegion;

    if( m_CropState == VPInfoCropState_AtVideoPort ) {
        // if cropping at the videoport, final image is translated back to (0,0)
        rSrc.right = WIDTH( &rSrc );
        rSrc.bottom = HEIGHT( &rSrc );
        rSrc.left = 0;
        rSrc.top = 0;
    }
    if( m_fGarbageLine ) {
        // crop top line
        rSrc.top ++;
        rSrc.bottom --;
    }
    if( !m_fHalfHeightVideo ) {
        // Bob interleaved or weave, so grab both fields (rcValidRegion is 0..240)
        rSrc.top *=2;
        rSrc.bottom *=2;
    }
    // Could watch the media type, however this is more reliable.
#ifdef DEBUG
    // Make sure the source fits into the destination
    {
        RECT rDest;
        hr = GetRectFromImage( pDestSurface, &rDest );
        if( SUCCEEDED( hr )) {
            ASSERT( rDest.bottom >= rSrc.bottom );
            ASSERT( rDest.right >= rSrc.right );
        }
    }
#endif

    RECT rDest = rSrc;


#ifdef DEBUG_BLTS
    // debugging to track down faulty BltFourCC blits
    hr = MyCopyUYVYSurf( pDestSurface, &rDest, pSourceSurface, &rSrc );
#else
    hr = pDestSurface->Blt(&rDest, pSourceSurface, &rSrc, DDBLT_WAIT, NULL);
#endif
    // retry on lost surface
    if ( DDERR_SURFACELOST == hr )
    {
        LPDIRECTDRAW7 pDirectDraw = m_pIVideoPortControl->GetDirectDraw();
        if( pDirectDraw && pDirectDraw->TestCooperativeLevel() == DD_OK ) {
            // otherwise the kernel dxg.sys is out of sync with DDraw
            ASSERT( pDestSurface->IsLost() == DDERR_SURFACELOST ||  pSourceSurface->IsLost() == DDERR_SURFACELOST );

            // check the destination.  If we can't restore it, then we don't want to even both with the source

            hr = pDestSurface->IsLost();
            if( hr == DDERR_SURFACELOST ) {
                // restore the DestSurface (passed to us, possibly a different DDrawObject)
                // We can't just restore the surface since it could be an implicit surface that is part of a flipping
                // chain, so we have to tell DDraw to restore everything on that thread

                LPDIRECTDRAW7 pDestDirectDraw = GetDDrawFromSurface( pDestSurface );
                if( pDestDirectDraw ) {
                    hr = pDestDirectDraw->RestoreAllSurfaces();
                    pDestDirectDraw->Release();
                }
                if( SUCCEEDED( hr )) {
                    hr = pDestSurface->IsLost();
                }
            }

            if( hr != DDERR_SURFACELOST ) {
                // valid destination, fix the source
                hr = pSourceSurface->IsLost();

                if( hr == DDERR_SURFACELOST ) {
                    hr = m_pOutputSurface->Restore();
                    if( FAILED( hr )) {
                        DbgLog((LOG_ERROR, 0,  TEXT("CallUpdateSurface Blt() restore source failed, hr = %d"), hr & 0xffff));
                    } else {
                        // kick the videoport (G400 seems to stop playing)

                        // the surfaces are disconnected from the video port when they are lost, so reconnect them
                        hr = StartVideoWithRetry();
                    }
                    if( SUCCEEDED( hr )) {
				        // recompute the source image pointer incase StartVideoWithRetry recreated the surfaces
				        pSourceSurface = m_pChain[dwSourceIndex].pDDSurf;
                    }
                }
                if( SUCCEEDED( hr ) ) {
                    hr = pDestSurface->Blt(&rDest,
                                        pSourceSurface, &rSrc,
                                        DDBLT_WAIT, NULL);
                }
            }
        } else {
#ifdef DEBUG
            // HRESULT coop= pDirectDraw ? pDirectDraw->TestCooperativeLevel() : E_FAIL;
            // DbgLog((LOG_ERROR, 0,  TEXT("TestCoopLevel failed, hr = %d"), coop & 0xffff));
#endif
        }
    } else {
        ASSERT( SUCCEEDED( hr ));
    }
    // filter DERR_SURFACELOST since in DOS boxes, we'll continually fail the blit
    if (DDERR_SURFACELOST != hr  && FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0,  TEXT("CallUpdateSurface Blt() failed, hr = %d"), hr & 0xffff));
    }
    return hr;
}

HRESULT CVideoPortObj::GetMode( AMVP_MODE* pMode )
{
    *pMode = m_CurrentMode;
    return S_OK;
}

//==========================================================================
HRESULT CVideoPortObj::GetMediaType(int iPosition, CMediaType* pmt)
{
    CAutoLock cObjectLock(m_pMainObjLock);
    AMTRACE((TEXT("CVideoPortObj::GetMediaType")));

    HRESULT hr = S_OK;

    if (iPosition == 0)
    {
        pmt->SetType(&MEDIATYPE_Video);
        pmt->SetSubtype(&MEDIASUBTYPE_VPVideo);
        pmt->SetFormatType(&FORMAT_None);
        pmt->SetSampleSize(1);
        pmt->SetTemporalCompression(FALSE);
    }
    else if (iPosition > 0)  {
        hr = VFW_S_NO_MORE_ITEMS;
    } else { // iPosition < 0
        hr = E_INVALIDARG;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\vpm\vpobj.h ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
#ifndef __VP_OBJECT__
#define __VP_OBJECT__

#include "vpinfo.h"
#include <dvp.h>
#include <vptype.h>

// IVPNotify2
#include <vpnotify.h>

// IVPConfig
#include <vpconfig.h>

// AMVP_MODE
#include <vpinfo.h>

#include <formatlist.h>

// #define EC_OVMIXER_REDRAW_ALL 0x100
// #define EC_UPDATE_MEDIATYPE 0x101

struct VPDRAWFLAGS
{
    BOOL bDoUpdateVideoPort;
    BOOL bDoTryDecimation;
    BOOL bDoTryAutoFlipping;
};

struct VPWININFO
{
    POINT TopLeftPoint;
    RECT SrcRect;
    RECT DestRect;
    RECT SrcClipRect;
    RECT DestClipRect;
};

DECLARE_INTERFACE_(IVideoPortObject, IUnknown)
{
    STDMETHOD (GetDirectDrawVideoPort)(THIS_ LPDIRECTDRAWVIDEOPORT* ppDirectDrawVideoPort ) PURE;
    STDMETHOD (SetObjectLock)       (THIS_ CCritSec* pMainObjLock ) PURE;
    STDMETHOD (SetMediaType)        (THIS_ const CMediaType* pmt ) PURE;
    STDMETHOD (CheckMediaType)      (THIS_ const CMediaType* pmt ) PURE;
    STDMETHOD (GetMediaType)        (THIS_ int iPosition, CMediaType *pMediaType) PURE;
    STDMETHOD (CompleteConnect)     (THIS_ IPin* pReceivePin, BOOL bRenegotiating = FALSE ) PURE;
    STDMETHOD (BreakConnect)        (THIS_ BOOL bRenegotiating = FALSE ) PURE;
    STDMETHOD (Active)              (THIS_ ) PURE;
    STDMETHOD (Inactive)            (THIS_ ) PURE;
    STDMETHOD (Run)                 (THIS_ REFERENCE_TIME tStart ) PURE;
    STDMETHOD (RunToPause)          (THIS_ ) PURE;
    STDMETHOD (CurrentMediaType)    (THIS_ AM_MEDIA_TYPE* pmt ) PURE;
    STDMETHOD (GetRectangles)       (THIS_ RECT* prcSource, RECT* prcDest) PURE;
    STDMETHOD (AttachVideoPortToSurface) (THIS_) PURE;
    STDMETHOD (SignalNewVP) (THIS_) PURE;
    STDMETHOD (GetAllOutputFormats) (THIS_ const PixelFormatList**) PURE;
    STDMETHOD (GetOutputFormat)     (THIS_ DDPIXELFORMAT*) PURE;
    STDMETHOD (StartVideo)          (THIS_ const VPWININFO* pWinInfo ) PURE;
    STDMETHOD (SetVideoPortID)      (THIS_ DWORD dwVideoPortId ) PURE;
    STDMETHOD (CallUpdateSurface)   (THIS_ DWORD dwSourceIndex, LPDIRECTDRAWSURFACE7 pDestSurface ) PURE;
    STDMETHOD (GetMode)             (THIS_ AMVP_MODE* pMode ) PURE;
};


DECLARE_INTERFACE_(IVideoPortControl, IUnknown)
{
    STDMETHOD (EventNotify)(THIS_
                            long lEventCode,
                            DWORD_PTR lEventParam1,
                            DWORD_PTR lEventParam2
                           ) PURE;

    STDMETHOD_(LPDIRECTDRAW7, GetDirectDraw) (THIS_ ) PURE;

    STDMETHOD_(const DDCAPS*, GetHardwareCaps) (THIS_
                                          ) PURE;

    STDMETHOD(GetCaptureInfo)(THIS_
                             BOOL* lpCapturing,
                             DWORD* lpdwWidth,
                             DWORD* lpdwHeight,
                             BOOL* lpInterleaved) PURE;

    STDMETHOD(GetVideoDecimation)(THIS_
                                  IDecimateVideoImage** lplpDVI) PURE;

    STDMETHOD(GetDecimationUsage)(THIS_
                                  DECIMATION_USAGE* lpdwUsage) PURE;

    STDMETHOD(CropSourceRect)(THIS_
                              VPWININFO* pWinInfo,
                              DWORD dwMinZoomFactorX,
                              DWORD dwMinZoomFactorY) PURE;

    STDMETHOD(StartVideo)(THIS_ ) PURE;
    STDMETHOD(SignalNewVP)(THIS_ LPDIRECTDRAWVIDEOPORT pVP) PURE;
};

class PixelFormatList;

class CVideoPortObj
: public CUnknown
, public IVPNotify2         // public
, public IVideoPortObject   // private between this videoport (on the input pin) & the VPM filter
, public IVideoPortInfo     // private to get stats on video port
{

public:
    CVideoPortObj(LPUNKNOWN pUnk, HRESULT* phr, IVideoPortControl* pVPControl );
    ~CVideoPortObj();

    DECLARE_IUNKNOWN

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void* * ppv);

    // IVideoPortObject Interface to the outside world
    STDMETHODIMP GetDirectDrawVideoPort(LPDIRECTDRAWVIDEOPORT* ppDirectDrawVideoPort);
    STDMETHODIMP SetObjectLock(CCritSec* pMainObjLock);
    STDMETHODIMP SetMediaType(const CMediaType* pmt);
    STDMETHODIMP CheckMediaType(const CMediaType* pmt);
    STDMETHODIMP GetMediaType(int iPosition, CMediaType *pMediaType);
    STDMETHODIMP CompleteConnect(IPin* pReceivePin, BOOL bRenegotiating = FALSE);
    STDMETHODIMP BreakConnect(BOOL bRenegotiating = FALSE);
    STDMETHODIMP Active();
    STDMETHODIMP Inactive();
    STDMETHODIMP Run(REFERENCE_TIME tStart);
    STDMETHODIMP RunToPause();
    STDMETHODIMP CurrentMediaType(AM_MEDIA_TYPE* pmt);
    STDMETHODIMP GetRectangles(RECT* prcSource, RECT* prcDest);
    STDMETHODIMP AttachVideoPortToSurface();
    STDMETHODIMP SignalNewVP();

    STDMETHODIMP GetAllOutputFormats( const PixelFormatList**);
    STDMETHODIMP GetOutputFormat( DDPIXELFORMAT* );
    STDMETHODIMP StartVideo( const VPWININFO* pWinInfo );
    STDMETHODIMP SetVideoPortID( DWORD dwVideoPortId );
    STDMETHODIMP CallUpdateSurface( DWORD dwSourceIndex, LPDIRECTDRAWSURFACE7 pDestSurface );
    STDMETHODIMP GetMode( AMVP_MODE* pMode );

    // Methods belonging to IVideoPortInfo
    STDMETHODIMP GetCropState(VPInfoCropState* pCropState);
    STDMETHODIMP GetPixelsPerSecond(DWORD* pPixelPerSec);
    STDMETHODIMP GetVPInfo(DDVIDEOPORTINFO* pVPInfo);
    STDMETHODIMP GetVPBandwidth(DDVIDEOPORTBANDWIDTH* pVPBandwidth);
    STDMETHODIMP GetVPCaps(DDVIDEOPORTCAPS* pVPCaps);
    STDMETHODIMP GetVPDataInfo(AMVPDATAINFO* pVPDataInfo);
    STDMETHODIMP GetVPInputFormat(LPDDPIXELFORMAT pVPFormat);
    STDMETHODIMP GetVPOutputFormat(LPDDPIXELFORMAT pVPFormat);

    // IVPNotify functions here
    STDMETHODIMP RenegotiateVPParameters();
    STDMETHODIMP SetDeinterlaceMode(AMVP_MODE mode);
    STDMETHODIMP GetDeinterlaceMode(AMVP_MODE* pMode);

    // functions added in IVPNotify2 here
    STDMETHODIMP SetVPSyncMaster(BOOL bVPSyncMaster);
    STDMETHODIMP GetVPSyncMaster(BOOL* pbVPSyncMaster);

private:
    // used to initialize all class member variables.
    // It is called from the contructor as well as CompleteConnect
    void InitVariables();


    // All these functions are called from within CompleteConnect
    HRESULT NegotiateConnectionParamaters();
    static HRESULT CALLBACK EnumCallback (LPDDVIDEOPORTCAPS lpCaps, LPVOID lpContext);
    HRESULT GetDataParameters();

    HRESULT GetInputPixelFormats( PixelFormatList* pList );
    HRESULT GetOutputPixelFormats( const PixelFormatList& ddInputFormats, PixelFormatList* pddOutputFormats );
    HRESULT SetInputPixelFormat( DDPIXELFORMAT& ddFormat );
    HRESULT NegotiatePixelFormat();

    HRESULT CreateVideoPort();
    HRESULT DetermineCroppingRestrictions();
    HRESULT CreateSourceSurface(BOOL bTryDoubleHeight, DWORD dwMaxBuffers, BOOL bPreferBuffers);
    HRESULT SetSurfaceParameters();
    HRESULT InitializeVideoPortInfo();
    HRESULT CheckDDrawVPCaps();
    HRESULT DetermineModeRestrictions();
    HRESULT SetDDrawKernelHandles();

    HRESULT SetUpMode( AMVP_MODE mode);

    // All these functions are called fro within OnClipChange
    // HRESULT DrawImage(const VPWININFO& pWinInfo, AMVP_MODE mode, const VPDRAWFLAGS& pvpDrawFlags, LPDIRECTDRAWSURFACE7 pDestSurface);


    HRESULT StartVideo();

    // Decimation functions
    BOOL
    ApplyDecimation(
        VPWININFO* pWinInfo,
        BOOL bColorKeying,
        BOOL bYInterpolating
        );

    HRESULT
    TryVideoPortDecimation(
        VPWININFO* pWinInfo,
        DWORD dwMinZoomFactorX,
        DWORD dwMinZoomFactorY,
        BOOL* lpUpdateRequired
        );

    HRESULT
    TryDecoderDecimation(
        VPWININFO* pWinInfo
        );

    void
    GetMinZoomFactors(
        const VPWININFO& pWinInfo,
        BOOL bColorKeying,
        BOOL bYInterpolating,
        LPDWORD lpMinX, LPDWORD lpMinY);


    BOOL
    Running();

    BOOL
    BeyondOverlayCaps(
        DWORD ScaleFactor,
        DWORD dwMinZoomFactorX,
        DWORD dwMinZoomFactorY
        );

    BOOL
    ResetVPDecimationIfSet();

    void
    ResetDecoderDecimationIfSet();

    void CropSourceSize(VPWININFO* pWinInfo, DWORD dwMinZoomFactorX, DWORD dwMinZoomFactorY);
    BOOL AdjustSourceSize(VPWININFO* pWinInfo, DWORD dwMinZoomFactorX, DWORD dwMinZoomFactorY);
    BOOL AdjustSourceSizeForCapture(VPWININFO* pWinInfo, DWORD dwMinZoomFactorX, DWORD dwMinZoomFactorY);
    BOOL AdjustSourceSizeWhenStopped(VPWININFO* pWinInfo,  DWORD dwMinZoomFactorX, DWORD dwMinZoomFactorY);
    BOOL CheckVideoPortAlignment(DWORD dwWidth);

    BOOL
    VideoPortDecimationBackend(
        VPWININFO* pWinInfo,
        DWORD dwDexNumX,
        DWORD dwDexDenX,
        DWORD dwDexNumY,
        DWORD dwDexDenY
        );
    HRESULT ReconnectVideoPortToSurface();
    HRESULT StartVideoWithRetry();

public:
    HRESULT StopUsingVideoPort();
    HRESULT SetupVideoPort();

private:
    HRESULT ReleaseVideoPort();
    HRESULT RecreateSourceSurfaceChain();
    HRESULT DestroyOutputSurfaces();

    // Critical sections
    CCritSec*               m_pMainObjLock;                // Lock given by controlling object
    CCritSec                m_VPObjLock;                    // VP object wide lock
    IVideoPortControl*      m_pIVideoPortControl;

    // window information related stuff
    BOOL                    m_bStoredWinInfoSet;
    VPWININFO               m_StoredWinInfo;

    // image dimensions
    DWORD                   m_lImageWidth;
    DWORD                   m_lImageHeight;
    DWORD                   m_lDecoderImageWidth;
    DWORD                   m_lDecoderImageHeight;

    // info relating to capturing
    BOOL                    m_fCapturing;
    BOOL                    m_fCaptureInterleaved;
    DWORD                   m_cxCapture;
    DWORD                   m_cyCapture;

    // output surface related stuff
    struct Chain {
        LPDIRECTDRAWSURFACE7    pDDSurf;
        DWORD                   dwCount;
    };
    LPDIRECTDRAWSURFACE7    m_pOutputSurface;
    LPDIRECTDRAWSURFACE     m_pOutputSurface1;
    Chain *                 m_pChain;
    DWORD                   m_dwBackBufferCount;
     DWORD                   m_dwOutputSurfaceWidth;
    DWORD                   m_dwOutputSurfaceHeight;
    // DWORD                   m_dwOverlayFlags;

    // vp variables to store flags, current state etc
    IVPConfig*              m_pIVPConfig;
    BOOL                    m_bStart;

    BOOL                    m_bConnected;

    VPInfoState             m_VPState;
    AMVP_MODE               m_CurrentMode;
    // AMVP_MODE               m_StoredMode;
    VPInfoCropState         m_CropState;
    DWORD                   m_dwPixelsPerSecond;
    BOOL                    m_bVSInterlaced;
    bool                    m_fGarbageLine;
    bool                    m_fHalfHeightVideo;
    BOOL                    m_bVPSyncMaster;

    // vp data structures
    DWORD                   m_dwVideoPortId;
    LPDDVIDEOPORTCONTAINER  m_pDVP;
    LPDIRECTDRAWVIDEOPORT   m_pVideoPort;
    DDVIDEOPORTINFO         m_svpInfo;
    DDVIDEOPORTBANDWIDTH    m_sBandwidth;
    DDVIDEOPORTCAPS         m_vpCaps;
    DDVIDEOPORTCONNECT      m_ddConnectInfo;
    AMVPDATAINFO            m_VPDataInfo;

    // All the pixel formats (Video)
    DDPIXELFORMAT           m_ddVPInputVideoFormat;

    DWORD                   m_dwDefaultOutputFormat;    // which one we'll assume for the connection
    DDPIXELFORMAT           m_ddVPOutputVideoFormat;

    PixelFormatList         m_ddInputVideoFormats;
    PixelFormatList*        m_pddOutputVideoFormats;
    PixelFormatList         m_ddAllOutputVideoFormats;

    // can we support the different modes
    BOOL                    m_bCanWeave;
    BOOL                    m_bCanBobInterleaved;
    BOOL                    m_bCanBobNonInterleaved;
    BOOL                    m_bCanSkipOdd;
    BOOL                    m_bCanSkipEven;
    BOOL                    m_bCantInterleaveHalfline;

    // decimation parameters
    enum DECIMATE_MODE {DECIMATE_NONE, DECIMATE_ARB, DECIMATE_BIN, DECIMATE_INC};
#if defined(DEBUG)
    BOOL CheckVideoPortScaler(
        DECIMATE_MODE DecimationMode,
        DWORD ImageSize,
        DWORD PreScaleSize,
        ULONG ulDeciStep);
#endif
    DECIMATE_MODE           m_DecimationModeX;
    DWORD                   m_ulDeciStepX;
    DWORD                   m_dwDeciNumX;
    DWORD                   m_dwDeciDenX;

    DECIMATE_MODE           m_DecimationModeY;
    DWORD                   m_ulDeciStepY;
    DWORD                   m_dwDeciNumY;
    DWORD                   m_dwDeciDenY;

    BOOL                    m_bVPDecimating;
    BOOL                    m_bDecimating;
    LONG                    m_lWidth;
    LONG                    m_lHeight;

    // variables to store the current aspect ratio
    DWORD                   m_dwPictAspectRatioX;
    DWORD                   m_dwPictAspectRatioY;


    RECT                    m_rcSource;
    RECT                    m_rcDest;

};

DWORD MulABC_DivDE(DWORD A, DWORD B, DWORD C, DWORD D, DWORD E);

#endif //__VP_OBJECT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\wm\window.cpp ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
// Implements the CVMRVideoWindow class, Anthony Phillips, January 1995

#include <streams.h>
#include <windowsx.h>
#include <limits.h>
#include <measure.h>
#include <mmsystem.h>
#include <dvdmedia.h> // VIDEOINFO2
#include "..\video\VMRenderer.h"
#include "vmrwinctrl.h"
#include "vmrwindow.h"

//  When we are constructed we create a window and a separate thread to look
//  after it. We also create two device contexts for the window, one for the
//  window client area and another compatible with this for offscreen drawing.
//  Only source formats that match the display device format will be accepted,
//  other formats have to be converted through colour transformation filters.
//  The only exception to this being true colour devices which will normally
//  handle four and eight bit palettised images very efficiently.
//
//  When a connection has been made the output pin may ask us for an allocator
//  We provide an allocator that gives out one or more memory buffers that are
//  shared with GDI. These are created through CreateDIBSection. That requires
//  us to give it the connected source media type format BITMAPINFO structure.
//
//  When we come to rendering the images we have two separate code paths, one
//  for samples allocated with our shared memory allocator and another for the
//  normal memory buffers. As it turns out the shared memory allocator does
//  only marginally faster. However our memory allocator can also return DCI
//  and DirectDraw surfaces which can be drawn by display card hardware. DCI
//  and DirectDraw buffers may still need drawing (although not always as
//  in the case of primary surfaces) and if they do they also get sent to us
//  for synchronising. Our Render method will call the DirectDraw object if
//  it sees a DirectDraw sample, otherwise it passes it to our draw object.
//
//  For shared memory buffers we select the DIB data into the offscreen device
//  context which will also always have the source palette realized in it then
//  we BitBlt from that device context into the window device context. For the
//  normal non shared memory samples we simply call SetDIBitsToDevice and also
//  StretchDIBitsToDevice), GDI first maps the buffer into it's address space
//  (thereby making the buffer shared) and then copies it to the screen.


// Constructor

#pragma warning(disable:4355)

CVMRVideoWindow::CVMRVideoWindow(CVMRFilter *pRenderer,     // The owning renderer
                           CCritSec *pLock,           // Object to lock with
                           LPUNKNOWN pUnk,            // Owning object
                           HRESULT *phr) :            // OLE return code

    CVMRBaseControlWindow(pRenderer,pLock,NAME("Window object"),pUnk,phr),
    CVMRBaseControlVideo(pRenderer,pLock,NAME("Window object"),pUnk,phr),
    m_pRenderer(pRenderer),
    m_pInterfaceLock(pLock),
    m_bTargetSet(FALSE),
    m_pFormat(NULL),
    m_FormatSize(0)
{
    ASSERT(m_pRenderer);
    ASSERT(m_pInterfaceLock);

    // Create a default arrow cursor

    m_hCursor = (HCURSOR) LoadImage((HINSTANCE) NULL,
                                    MAKEINTRESOURCE(OCR_ARROW_DEFAULT),
		                    IMAGE_CURSOR,0,0,0);
}


// Must destroy the window before this destructor

CVMRVideoWindow::~CVMRVideoWindow()
{
    ASSERT(m_hwnd == NULL);
    ASSERT(m_hdc == NULL);
    ASSERT(m_MemoryDC == NULL);

    DestroyCursor(m_hCursor);
    if (m_pFormat)
	QzTaskMemFree(m_pFormat);
}

// Overriden to say what interfaces we support

STDMETHODIMP CVMRVideoWindow::NonDelegatingQueryInterface(REFIID riid,VOID **ppv)
{
    if (riid == IID_IVideoWindow) {
        return CVMRBaseControlWindow::NonDelegatingQueryInterface(riid,ppv);
    } else {
        ASSERT(riid == IID_IBasicVideo || riid == IID_IBasicVideo2);
        return CVMRBaseControlVideo::NonDelegatingQueryInterface(riid,ppv);
    }
}


HRESULT CVMRVideoWindow::PrepareWindow()
{

    // Register our special private messages
    m_VMRActivateWindow = RegisterWindowMessage(VMR_ACTIVATE_WINDOW);

    // RegisterWindowMessage() returns 0 if an error occurs.
    if (0 == m_VMRActivateWindow) {
        return AmGetLastErrorToHResult();
    }
    return CBaseWindow::PrepareWindow();
}

HRESULT CVMRVideoWindow::ActivateWindowAsync(BOOL fAvtivate)
{
    if (PostMessage(m_hwnd, m_VMRActivateWindow, (WPARAM)fAvtivate, 0)) {
        return S_OK;
    }
    return E_FAIL;
}

// Return the default client rectangle we would like

RECT CVMRVideoWindow::GetDefaultRect()
{
    CAutoLock cWindowLock(&m_WindowLock);

    RECT DefaultRect = {0,0,0,0};
    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
    if (lpWLControl) {
        LONG cx, cy;
        lpWLControl->GetNativeVideoSize(&cx, &cy, NULL, NULL);
        SetRect(&DefaultRect, 0, 0, cx, cy);
    }

    return DefaultRect;
}


// We are called when the user moves the cursor over the window client area
// If we are fullscreen then we should hide the pointer so that it matches
// the fullscreen renderer behaviour. We also set a default cursor if we're
// DirectDraw overlays as software cursors won't be visible. This means we
// change the cursor as the mouse is moved but at least a cursor is visible

BOOL CVMRVideoWindow::OnSetCursor(LPARAM lParam)
{
    // The base class that implements IVideoWindow looks after a flag that
    // says whether or not the cursor should be hidden. If so we hide the
    // cursor and return TRUE. Otherwise we pass to DefWindowProc to show
    // the cursor as normal. This is used when our window is stretched up
    // fullscreen to imitate the Modex filter that always hides the cursor

    if (IsCursorHidden() == TRUE) {
        SetCursor(NULL);
        return TRUE;
    }

    // Are DirectDraw colour key overlays visible

//  if ((m_pRenderer->m_DirectDraw.InSoftwareCursorMode() == FALSE) ||
//      (*m_pRenderer->m_mtIn.Subtype() == MEDIASUBTYPE_Overlay))
//  {
        if (LOWORD(lParam) == HTCLIENT) {
            SetCursor(m_hCursor);
            return TRUE;
        }
//  }

    return FALSE;
}


// We override the virtual CBaseWindow OnReceiveMessage call to handle more
// of the Windows messages. The base class handles some stuff like WM_CLOSE
// messages amongst others which we are also interested in. We don't need
// to use WM_SIZE and WM_MOVE messages to position source filters through
// IOverlay (with ADVISE_POSITION) as we poll with timers now. This is done
// because as a child window we cannot be guaranteed to see those messages
// Our global hook sends us WM_FREEZE and WM_THAW messages synchronously as
// it detects window changes in the system that might affect our clip list

LRESULT CVMRVideoWindow::OnReceiveMessage(HWND hwnd,         // Window handle
                                       UINT uMsg,         // Message ID
                                       WPARAM wParam,     // First parameter
                                       LPARAM lParam)     // Other parameter
{

    if (uMsg == m_VMRActivateWindow) {

        if (wParam) {
            CBaseWindow::ActivateWindow();
        }
        else {
            CBaseWindow::InactivateWindow();
        }
        return 0;
    }

    switch (uMsg) {

        // Handle cursors when fullscreen and in overlay mode

        case WM_SETCURSOR:

            if (OnSetCursor(lParam) == TRUE) {
                NOTE("Cursor handled");
                return (LRESULT) 0;
            }
            break;

        // We pass on WM_ACTIVATEAPP messages to the filtergraph so that the
        // IVideoWindow plug in distributor can switch us out of fullscreen
        // mode where appropriate. These messages may also be used by the
        // resource manager to keep track of which renderer has the focus

        case WM_ACTIVATEAPP:
        case WM_ACTIVATE:
        case WM_NCACTIVATE:
        case WM_MOUSEACTIVATE:
        {
            BOOL bActive = TRUE;
            IBaseFilter * const pFilter = m_pRenderer;
            switch (uMsg) {
            case WM_ACTIVATEAPP:
            case WM_NCACTIVATE:
                bActive = (BOOL)wParam;
                break;
            case WM_ACTIVATE:
                bActive = LOWORD(wParam) != WA_INACTIVE;
                break;
            }
            NOTE1("Notification of EC_ACTIVATE (%d)",bActive);
            m_pRenderer->NotifyEvent(EC_ACTIVATE,bActive,
                                     (LPARAM) pFilter);
            NOTE("EC_ACTIVATE signalled to filtergraph");

            break;
        }

        // When we detect a display change we send an EC_DISPLAY_CHANGED
        // message along with our input pin. The filtergraph will stop
        // everyone and reconnect our input pin. When being reconnected
        // we can then accept the media type that matches the new display
        // mode since we may no longer be able to draw the current format

        case WM_DISPLAYCHANGE:

            NOTE("Notification of WM_DISPLAYCHANGE");
            {
                IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
                if (lpWLControl) {
                    lpWLControl->DisplayModeChanged();
                }
                return (LRESULT) 0;
            }


        // Timers are used to have DirectDraw overlays positioned

        case WM_TIMER:
#ifdef DEBUG
            if (wParam ==  FRAME_RATE_TIMER) {

                TCHAR WindowText[64];
                int f;
                m_pRenderer->get_AvgFrameRate(&f);
                wsprintf(WindowText,
                         TEXT("ActiveMovie Window: Frame Rate %d.%.2d / Sec"),
                         f / 100, f % 100 );

                SetWindowText(m_hwnd, WindowText);
            }
#endif
            return (LRESULT) 0;

        case WM_ERASEBKGND:

            OnEraseBackground();
            return (LRESULT) 1;


        case WM_MOVE:
            //
            // The old renderer would pass this message onto the
            // base classes which would post a WM_PAINT message to
            // the window.  Unfortunately, the OnPaint message does
            // an BeginPaint/EndPaint call.  This confuses DDraw's
            // clipper resulting in artifacts being left on the screen.
            //
            {
                IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();

                if (lpWLControl) {

                    if (m_pRenderer->NumInputPinsConnected() > 0) {

                        lpWLControl->RepaintVideo(hwnd, NULL);
                    }
                    else {

                        COLORREF clr;
                        lpWLControl->GetBorderColor(&clr);
                        HDC hdc = GetDC(hwnd);
                        if (hdc) {

                            RECT TargetRect;
                            GetClientRect(m_hwnd, &TargetRect);

                            COLORREF BackColour = SetBkColor(hdc, clr);
                            ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &TargetRect, NULL, 0, NULL);
                            SetBkColor(hdc, BackColour);
                            ReleaseDC(hwnd, hdc);
                        }
                    }
                }
            }
            return (LRESULT)0;

        case WM_SIZE:

            OnSize(LOWORD(lParam),HIWORD(lParam));
            OnUpdateRectangles();
            return (LRESULT) 0;

        // This tells us some of the window's client area has become exposed
        // If our connected filter is doing overlay work then we repaint the
        // background so that it will pick up the window clip changes. Those
        // filters will probably use an ADVISE_POSITION overlay notification

        case WM_PAINT:

            DoRealisePalette();
            OnPaint();
            return (LRESULT) 0;
    }
    return CBaseWindow::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
}


// Used when the palette changes to clear the window

void CVMRVideoWindow::EraseVideoBackground()
{
    NOTE("EraseVideoBackground");
    RECT TargetRect;

    GetTargetRect(&TargetRect);
    COLORREF BackColour = SetBkColor(m_hdc,VIDEO_COLOUR);
    ExtTextOut(m_hdc,0,0,ETO_OPAQUE,&TargetRect,NULL,0,NULL);
    SetBkColor(m_hdc,BackColour);
}


// This erases the background of the video window that does not have any video
// being put in it. During normal processing we ignore paint messages because
// we will soon be putting the next frame over the top of it, however we may
// have the destination rectangle set by the IVideoWindow control interface
// such that there are areas left untouched - this method erases over them
// We must lock the critical section as the control interface may change it

void CVMRVideoWindow::OnEraseBackground()
{
    NOTE("Entering OnErasebackground");

    RECT ClientRect, TargetRect;
    EXECUTE_ASSERT(GetClientRect(m_hwnd,&ClientRect));
    CAutoLock cWindowLock(&m_WindowLock);
    GetTargetRect(&TargetRect);

    // Find that missing region

    HRGN ClientRgn = CreateRectRgnIndirect(&ClientRect);
    HRGN VideoRgn = CreateRectRgnIndirect(&TargetRect);
    HRGN EraseRgn = CreateRectRgn(0,0,0,0);
    HBRUSH hBrush = (HBRUSH) NULL;
    COLORREF Colour;

    if ( ( ! ClientRgn ) || ( ! VideoRgn ) || ( ! EraseRgn ) )
        goto Exit;

    CombineRgn(EraseRgn,ClientRgn,VideoRgn,RGN_DIFF);

    // Create a coloured brush to paint the window

    Colour = GetBorderColour();
    hBrush = CreateSolidBrush(Colour);
    FillRgn(m_hdc,EraseRgn,hBrush);

    // Delete the GDI objects we created
Exit:
    if ( ClientRgn ) DeleteObject( ClientRgn );
    if ( VideoRgn ) DeleteObject( VideoRgn );
    if ( EraseRgn ) DeleteObject( EraseRgn );
    if ( hBrush ) DeleteObject( hBrush );
}


// Initialise the draw object with the changed dimensions, we lock ourselves
// because the destination rectangle can be set via the IVideoWindow control
// interface. If the control interface has set a destination rectangle then
// we don't change it, otherwise we update the rectangle to match the window
// dimensions (in this case the left and top values should always be zero)

BOOL CVMRVideoWindow::OnSize(LONG Width,LONG Height)
{
    NOTE("Entering OnSize");

    CAutoLock cWindowLock(&m_WindowLock);
    if (m_bTargetSet == TRUE) {
        NOTE("Target set");
        return FALSE;
    }

    // Create a target rectangle for the window

    RECT TargetRect = {0,0,Width,Height};
    CBaseWindow::OnSize(Width,Height);
    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
    if (lpWLControl) {
        lpWLControl->SetVideoPosition(NULL, &TargetRect);
    }

    return TRUE;
}


// This method handles the WM_CLOSE message

BOOL CVMRVideoWindow::OnClose()
{
    NOTE("Entering OnClose");

    m_pRenderer->SetAbortSignal(TRUE);
    m_pRenderer->NotifyEvent(EC_USERABORT,0,0);
    return CBaseWindow::OnClose();
}



// This is called when we receive a WM_PAINT message

BOOL CVMRVideoWindow::OnPaint()
{
    NOTE("Entering OnPaint");
    PAINTSTRUCT ps;
    HDC hdc = BeginPaint(m_hwnd,&ps);
    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();

    if (lpWLControl) {

        if (m_pRenderer->NumInputPinsConnected() > 0) {
            lpWLControl->RepaintVideo(m_hwnd, hdc);
        }
        else {
            COLORREF clr;
            lpWLControl->GetBorderColor(&clr);

            RECT TargetRect;
            GetClientRect(m_hwnd, &TargetRect);

            COLORREF BackColour = SetBkColor(hdc, clr);
            ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &TargetRect, NULL, 0, NULL);
            SetBkColor(hdc, BackColour);
        }
    }

    EndPaint(m_hwnd,&ps);
    return TRUE;
}


// The base control video class calls this method when it changes either
// the source or destination rectangles. We update the overlay object as
// so that it notifies the source of the rectangle clip change and then
// invalidate the window so that the video is displayed in the new place

HRESULT CVMRVideoWindow::OnUpdateRectangles()
{
    NOTE("Entering OnUpdateRectangles");
//  m_pRenderer->m_Overlay.NotifyChange(ADVISE_CLIPPING | ADVISE_POSITION);
//  m_pRenderer->m_VideoAllocator.OnDestinationChange();
    PaintWindow(TRUE);
    return NOERROR;
}


// When we call PrepareWindow in our constructor it will call this method as
// it is going to create the window to get our window and class styles. The
// return code is the class name and must be allocated in static storage. We
// specify a normal window during creation although the window styles as well
// as the extended styles may be changed by the application via IVideoWindow

LPTSTR CVMRVideoWindow::GetClassWindowStyles(DWORD *pClassStyles,
                                          DWORD *pWindowStyles,
                                          DWORD *pWindowStylesEx)
{
    *pClassStyles = CS_HREDRAW | CS_VREDRAW | CS_BYTEALIGNCLIENT | CS_DBLCLKS;
    *pWindowStyles = WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN;
    *pWindowStylesEx = (DWORD) 0;
    return WindowClassName;
}


// Return the minimum ideal image size for the current video. This may differ
// to the actual video dimensions because we may be using DirectDraw hardware
// that has specific stretching requirements. For example the Cirrus Logic
// cards have a minimum stretch factor depending on the overlay surface size

STDMETHODIMP
CVMRVideoWindow::GetMinIdealImageSize(long *pWidth,long *pHeight)
{
    CheckPointer(pWidth,E_POINTER);
    CheckPointer(pHeight,E_POINTER);
    FILTER_STATE State;
    CAutoLock cInterfaceLock(m_pInterfaceLock);

    // Must not be stopped for this to work correctly

    m_pRenderer->GetState(0,&State);
    if (State == State_Stopped) {
        return VFW_E_WRONG_STATE;
    }

    GetVideoSize(pWidth,pHeight);

    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
    if (lpWLControl) {
        return lpWLControl->GetMinIdealVideoSize(pWidth, pHeight);
    }

    return S_OK;
}


// Return the maximum ideal image size for the current video. This may differ
// to the actual video dimensions because we may be using DirectDraw hardware
// that has specific stretching requirements. For example the Cirrus Logic
// cards have a maximum stretch factor depending on the overlay surface size

STDMETHODIMP
CVMRVideoWindow::GetMaxIdealImageSize(long *pWidth,long *pHeight)
{
    CheckPointer(pWidth,E_POINTER);
    CheckPointer(pHeight,E_POINTER);
    FILTER_STATE State;
    CAutoLock cInterfaceLock(m_pInterfaceLock);

    // Must not be stopped for this to work correctly

    m_pRenderer->GetState(0,&State);
    if (State == State_Stopped) {
        return VFW_E_WRONG_STATE;
    }

    GetVideoSize(pWidth,pHeight);

    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
    if (lpWLControl) {
        return lpWLControl->GetMaxIdealVideoSize(pWidth, pHeight);
    }

    return S_OK;
}

STDMETHODIMP
CVMRVideoWindow::GetPreferredAspectRatio(long *plAspectX, long *plAspectY)
{
    if (plAspectX == NULL || plAspectY == NULL) {
        return E_POINTER;
    }

    CAutoLock cInterfaceLock(m_pInterfaceLock);

    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
    if (lpWLControl) {
        lpWLControl->GetNativeVideoSize(NULL, NULL, plAspectX, plAspectY);
        return S_OK;
    }

    return E_NOTIMPL;
}


// Return a copy of the current image in the video renderer. The base control
// class implements a helper mathod that takes an IMediaSample interface and
// assuming it is a normal linear buffer copies the relevant section of the
// video into the output buffer provided. The method takes into account any
// source rectangle already specified by calling our GetSourceRect function

HRESULT CVMRVideoWindow::GetStaticImage(long *pVideoSize,long *pVideoImage)
{
#if 0
    NOTE("Entering GetStaticImage");
    IMediaSample *pMediaSample;
    RECT SourceRect;

    // Is there an image available

    pMediaSample = m_pRenderer->GetCurrentSample();
    if (pMediaSample == NULL) {
        return E_UNEXPECTED;
    }

    // Check the image isn't a DirectDraw sample

    if (m_pRenderer->m_VideoAllocator.GetDirectDrawStatus() == TRUE) {
        pMediaSample->Release();
        return E_FAIL;
    }

    // Find a scaled source rectangle for the current bitmap

    m_pRenderer->m_DrawVideo.GetSourceRect(&SourceRect);
    SourceRect = m_pRenderer->m_DrawVideo.ScaleSourceRect(&SourceRect);
    VIDEOINFO *pVideoInfo = (VIDEOINFO *) m_pRenderer->m_mtIn.Format();

    // Call the base class helper method to do the work

    HRESULT hr = CopyImage(pMediaSample,        // Buffer containing image
        (VIDEOINFOHEADER *)pVideoInfo,          // Type representing bitmap
                           pVideoSize,          // Size of buffer for DIB
                           (BYTE*) pVideoImage, // Data buffer for output
                           &SourceRect);        // Current source position

    pMediaSample->Release();
    return hr;
#else
    return E_NOTIMPL;
#endif
}


// The IVideoWindow control interface use this to reset the video destination
// We reset the flag that indicates whether we have a destination rectangle
// set explicitly or not, and then initialise the rectangle with the client
// window dimensions. These fields are used by the window thread when it does
// the drawing and also when it processes WM_SIZE messages (hence the lock)

HRESULT CVMRVideoWindow::SetDefaultTargetRect()
{
    CAutoLock cWindowLock(&m_WindowLock);
    RECT TargetRect;

    // Update the draw objects

    EXECUTE_ASSERT(GetClientRect(m_hwnd,&TargetRect));
    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
    if (lpWLControl) {
        lpWLControl->SetVideoPosition(NULL, &TargetRect);
    }

    m_bTargetSet = FALSE;
    return NOERROR;
}


// Return S_OK if using the default target otherwise S_FALSE

HRESULT CVMRVideoWindow::IsDefaultTargetRect()
{
    CAutoLock cWindowLock(&m_WindowLock);
    return (m_bTargetSet ? S_FALSE : S_OK);
}


// This sets the destination rectangle for the real video. The rectangle may
// be larger or smaller than the video window is and may be offset into it as
// well so we rely on the drawing operations to clip (such as the StretchBlt)

HRESULT CVMRVideoWindow::SetTargetRect(RECT *pTargetRect)
{
    CAutoLock cWindowLock(&m_WindowLock);
    m_bTargetSet = TRUE;

    // Update the draw objects
    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
    if (lpWLControl) {
        lpWLControl->SetVideoPosition(NULL, pTargetRect);
    }

    return NOERROR;
}


// This complements the SetTargetRect method to return the rectangle in use
// as the destination. If we have had no rectangle explicitly set then we
// will return the client window size as updated in the WM_SIZE messages

HRESULT CVMRVideoWindow::GetTargetRect(RECT *pTargetRect)
{
    CAutoLock cWindowLock(&m_WindowLock);
    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
    if (lpWLControl) {
        lpWLControl->GetVideoPosition(NULL, pTargetRect);
    }
    return NOERROR;
}


// Reset the source rectangle to be all the available video

HRESULT CVMRVideoWindow::SetDefaultSourceRect()
{
    CAutoLock cWindowLock(&m_WindowLock);

    RECT SourceRect = GetDefaultRect();

    // Update the draw objects

    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
    if (lpWLControl) {
        lpWLControl->SetVideoPosition(&SourceRect, NULL);
    }

    return NOERROR;
}


// Return S_OK if using the default source otherwise S_FALSE

HRESULT CVMRVideoWindow::IsDefaultSourceRect()
{

    RECT SourceRect;

    // Does the source match the native video size

    RECT VideoRect = GetDefaultRect();
    SIZE VideoSize;

    VideoSize.cx = VideoRect.right - VideoRect.left;
    VideoSize.cy = VideoRect.bottom - VideoRect.top;

    CAutoLock cWindowLock(&m_WindowLock);
    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
    if (lpWLControl) {
        lpWLControl->GetVideoPosition(&SourceRect, NULL);

        // Check the coordinates match the video dimensions

        if (SourceRect.right == VideoSize.cx) {
            if (SourceRect.bottom == VideoSize.cy) {
                if (SourceRect.left == 0) {
                    if (SourceRect.top == 0) {
                        return S_OK;
                    }
                }
            }
        }
    }

    return S_FALSE;
}


// This is called when we want to change the section of the image to draw. We
// use this information in the drawing operation calls later on. We must also
// see if the source and destination rectangles have the same dimensions. If
// not then we must stretch during the drawing rather than doing a pixel copy

HRESULT CVMRVideoWindow::SetSourceRect(RECT *pSourceRect)
{
    CAutoLock cWindowLock(&m_WindowLock);
    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
    if (lpWLControl) {
        lpWLControl->SetVideoPosition(pSourceRect, NULL);
    }
    return NOERROR;
}


// This complements the SetSourceRect method

HRESULT CVMRVideoWindow::GetSourceRect(RECT *pSourceRect)
{
    CAutoLock cWindowLock(&m_WindowLock);
    IVMRWindowlessControl* lpWLControl = m_pRenderer->GetWLControl();
    if (lpWLControl) {
        lpWLControl->GetVideoPosition(pSourceRect, NULL);
    }
    return NOERROR;
}


// We must override this to return a VIDEOINFO representing the video format
// The base class cannot call IPin ConnectionMediaType to get this format as
// dynamic type changes when using DirectDraw have the format show the image
// bitmap in terms of logical positions within a frame buffer surface, so a
// video might be returned as 1024x768 pixels, instead of the native 320x240

VIDEOINFOHEADER *CVMRVideoWindow::GetVideoFormat()
{
#if 0
    if (m_FormatSize < (int)m_pRenderer->m_mtIn.FormatLength()) {
        m_FormatSize = m_pRenderer->m_mtIn.FormatLength();
	if (m_pFormat)
	    QzTaskMemFree(m_pFormat);
        m_pFormat = (VIDEOINFOHEADER *)QzTaskMemAlloc(m_FormatSize);
	if (m_pFormat == NULL) {
	    m_FormatSize = 0;
	    return NULL;
	}
    }
    CopyMemory((PVOID)m_pFormat, (PVOID)m_pRenderer->m_mtIn.Format(),
              				m_pRenderer->m_mtIn.FormatLength());
    m_pFormat->bmiHeader.biWidth = m_pRenderer->m_VideoSize.cx;
    m_pFormat->bmiHeader.biHeight = m_pRenderer->m_VideoSize.cy;
    return m_pFormat;
#else
    return 0;
#endif
}

#ifdef DEBUG
void CVMRVideoWindow::StartFrameRateTimer()
{
    SetTimer(m_hwnd, FRAME_RATE_TIMER, 2000, NULL);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\image2\wm\winctrl.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Video control interface base classes, December 1995

#include <streams.h>

#include "..\video\VMRenderer.h"
#include "vmrwinctrl.h"
#include "vmrwindow.h"


// The control interface methods require us to be connected

#define CheckConnected(filter,code)                     \
{                                                       \
    if (filter == NULL) {                               \
        ASSERT(!TEXT("Filter not set"));                \
    } else if (filter->NumInputPinsConnected() == 0) {  \
        return (code);                                  \
    }                                                   \
}

// This checks to see whether the window has a drain. An application can in
// most environments set the owner/parent of windows so that they appear in
// a compound document context (for example). In this case, the application
// would probably like to be told of any keyboard/mouse messages. Therefore
// we pass these messages on untranslated, returning TRUE if we're successful

BOOL WINAPI VMRPossiblyEatMessage(HWND hwndDrain, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (hwndDrain != NULL && !InSendMessage())
    {
        switch (uMsg)
        {
            case WM_CHAR:
            case WM_DEADCHAR:
            case WM_KEYDOWN:
            case WM_KEYUP:
            case WM_LBUTTONDBLCLK:
            case WM_LBUTTONDOWN:
            case WM_LBUTTONUP:
            case WM_MBUTTONDBLCLK:
            case WM_MBUTTONDOWN:
            case WM_MBUTTONUP:
            case WM_MOUSEACTIVATE:
            case WM_MOUSEMOVE:
            // If we pass this on we don't get any mouse clicks
            //case WM_NCHITTEST:
            case WM_NCLBUTTONDBLCLK:
            case WM_NCLBUTTONDOWN:
            case WM_NCLBUTTONUP:
            case WM_NCMBUTTONDBLCLK:
            case WM_NCMBUTTONDOWN:
            case WM_NCMBUTTONUP:
            case WM_NCMOUSEMOVE:
            case WM_NCRBUTTONDBLCLK:
            case WM_NCRBUTTONDOWN:
            case WM_NCRBUTTONUP:
            case WM_RBUTTONDBLCLK:
            case WM_RBUTTONDOWN:
            case WM_RBUTTONUP:
            case WM_SYSCHAR:
            case WM_SYSDEADCHAR:
            case WM_SYSKEYDOWN:
            case WM_SYSKEYUP:

                DbgLog((LOG_TRACE, 2, TEXT("Forwarding %x to drain")));
                PostMessage(hwndDrain, uMsg, wParam, lParam);

                return TRUE;
        }
    }
    return FALSE;
}


// This class implements the IVideoWindow control functions (dual interface)
// we support a large number of properties and methods designed to allow the
// client (whether it be an automation controller or a C/C++ application) to
// set and get a number of window related properties such as it's position.
// We also support some methods that duplicate the properties but provide a
// more direct and efficient mechanism as many values may be changed in one

CVMRBaseControlWindow::CVMRBaseControlWindow(
                        CVMRFilter *pFilter,         // Owning filter
                        CCritSec *pInterfaceLock,    // Locking object
                        TCHAR *pName,                // Object description
                        LPUNKNOWN pUnk,              // Normal COM ownership
                        HRESULT *phr) :              // OLE return code

    CBaseVideoWindow(pName,pUnk),
    m_pInterfaceLock(pInterfaceLock),
    m_hwndOwner(NULL),
    m_hwndDrain(NULL),
    m_bAutoShow(TRUE),
    m_pFilter(pFilter),
    m_bCursorHidden(FALSE)
{
    ASSERT(m_pFilter);
    ASSERT(m_pInterfaceLock);
    ASSERT(phr);
    m_BorderColour = VIDEO_COLOUR;
}


// Set the title caption on the base window, we don't do any field checking
// as we really don't care what title they intend to have. We can always get
// it back again later with GetWindowText. The only other complication is to
// do the necessary string conversions between ANSI and OLE Unicode strings

STDMETHODIMP CVMRBaseControlWindow::put_Caption(BSTR strCaption)
{
    AMTRACE((TEXT("put_Caption"), 1));
    CheckPointer(strCaption,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
#ifdef UNICODE
    SetWindowText(m_hwnd, strCaption);
#else
    CHAR Caption[CAPTION];

    WideCharToMultiByte(CP_ACP,0,strCaption,-1,Caption,CAPTION,NULL,NULL);
    SetWindowText(m_hwnd, Caption);
#endif
    return NOERROR;
}


// Get the current base window title caption, once again we do no real field
// checking. We allocate a string for the window title to be filled in with
// which ensures the interface doesn't fiddle around with getting memory. A
// BSTR is a normal C string with the length at position (-1), we use the
// WriteBSTR helper function to create the caption to try and avoid OLE32

STDMETHODIMP CVMRBaseControlWindow::get_Caption(BSTR *pstrCaption)
{
    AMTRACE((TEXT("get_Caption"), 1));
    CheckPointer(pstrCaption,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    WCHAR WideCaption[CAPTION];

#ifdef UNICODE
    GetWindowText(m_hwnd,WideCaption,CAPTION);
#else
    // Convert the ASCII caption to a UNICODE string

    TCHAR Caption[CAPTION];
    GetWindowText(m_hwnd,Caption,CAPTION);
    MultiByteToWideChar(CP_ACP,0,Caption,-1,WideCaption,CAPTION);
#endif
    return WriteBSTR(pstrCaption,WideCaption);
}


// Set the window style using GWL_EXSTYLE

STDMETHODIMP CVMRBaseControlWindow::put_WindowStyleEx(long WindowStyleEx)
{
    AMTRACE((TEXT("put_WindowStyleEx"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);

    // Should we be taking off WS_EX_TOPMOST

    if (GetWindowLong(m_hwnd,GWL_EXSTYLE) & WS_EX_TOPMOST) {
        if ((WindowStyleEx & WS_EX_TOPMOST) == 0) {
            SendMessage(m_hwnd,m_ShowStageTop,(WPARAM) FALSE,(LPARAM) 0);
        }
    }

    // Likewise should we be adding WS_EX_TOPMOST

    if (WindowStyleEx & WS_EX_TOPMOST) {
        SendMessage(m_hwnd,m_ShowStageTop,(WPARAM) TRUE,(LPARAM) 0);
        WindowStyleEx &= (~WS_EX_TOPMOST);
        if (WindowStyleEx == 0) return NOERROR;
    }
    return DoSetWindowStyle(WindowStyleEx,GWL_EXSTYLE);
}


// Gets the current GWL_EXSTYLE base window style

STDMETHODIMP CVMRBaseControlWindow::get_WindowStyleEx(long *pWindowStyleEx)
{
    AMTRACE((TEXT("get_WindowStyleEx"), 1));
    CheckPointer(pWindowStyleEx,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    return DoGetWindowStyle(pWindowStyleEx,GWL_EXSTYLE);
}


// Set the window style using GWL_STYLE

STDMETHODIMP CVMRBaseControlWindow::put_WindowStyle(long WindowStyle)
{
    AMTRACE((TEXT("put_WindowStyle"), 1));
    // These styles cannot be changed dynamically

    if ((WindowStyle & WS_DISABLED) ||
        (WindowStyle & WS_ICONIC) ||
        (WindowStyle & WS_MAXIMIZE) ||
        (WindowStyle & WS_MINIMIZE) ||
        (WindowStyle & WS_HSCROLL) ||
        (WindowStyle & WS_VSCROLL)) {

            return E_INVALIDARG;
    }

    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    return DoSetWindowStyle(WindowStyle,GWL_STYLE);
}


// Get the current GWL_STYLE base window style

STDMETHODIMP CVMRBaseControlWindow::get_WindowStyle(long *pWindowStyle)
{
    AMTRACE((TEXT("get_WindowStyle"), 1));
    CheckPointer(pWindowStyle,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    return DoGetWindowStyle(pWindowStyle,GWL_STYLE);
}


// Change the base window style or the extended styles depending on whether
// WindowLong is GWL_STYLE or GWL_EXSTYLE. We must call SetWindowPos to have
// the window displayed in it's new style after the change which is a little
// tricky if the window is not currently visible as we realise it offscreen.
// In most cases the client will call get_WindowStyle before they call this
// and then AND and OR in extra bit settings according to the requirements

HRESULT CVMRBaseControlWindow::DoSetWindowStyle(long Style,long WindowLong)
{
    RECT WindowRect;

    // Get the window's visibility before setting the style
    BOOL bVisible = IsWindowVisible(m_hwnd);
    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&WindowRect));

    // Set the new style flags for the window
    SetWindowLong(m_hwnd,WindowLong,Style);
    UINT WindowFlags = SWP_SHOWWINDOW | SWP_FRAMECHANGED | SWP_NOACTIVATE;
    WindowFlags |= SWP_NOZORDER | SWP_NOSIZE | SWP_NOMOVE;

    // Show the window again in the current position

    if (bVisible == TRUE) {

        SetWindowPos(m_hwnd,            // Base window handle
                     HWND_TOP,          // Just a place holder
                     0,0,0,0,           // Leave size and position
                     WindowFlags);      // Just draw it again

        return NOERROR;
    }

    // Move the window offscreen so the user doesn't see the changes

    MoveWindow((HWND) m_hwnd,                     // Base window handle
               GetSystemMetrics(SM_CXSCREEN),     // Current desktop width
               GetSystemMetrics(SM_CYSCREEN),     // Likewise it's height
               WIDTH(&WindowRect),                // Use the same width
               HEIGHT(&WindowRect),               // Keep height same to
               TRUE);                             // May as well repaint

    // Now show the previously hidden window

    SetWindowPos(m_hwnd,            // Base window handle
                 HWND_TOP,          // Just a place holder
                 0,0,0,0,           // Leave size and position
                 WindowFlags);      // Just draw it again

    EXECUTE_ASSERT(ShowWindow(m_hwnd,SW_HIDE));

    if (GetParent(m_hwnd)) {

        MapWindowPoints(HWND_DESKTOP, GetParent(m_hwnd), (LPPOINT)&WindowRect, 2);
    }

    MoveWindow((HWND) m_hwnd,        // Base window handle
               WindowRect.left,      // Existing x coordinate
               WindowRect.top,       // Existing y coordinate
               WIDTH(&WindowRect),   // Use the same width
               HEIGHT(&WindowRect),  // Keep height same to
               TRUE);                // May as well repaint

    return NOERROR;
}


// Get the current base window style (either GWL_STYLE or GWL_EXSTYLE)

HRESULT CVMRBaseControlWindow::DoGetWindowStyle(long *pStyle,long WindowLong)
{
    *pStyle = GetWindowLong(m_hwnd,WindowLong);
    return NOERROR;
}


// Change the visibility of the base window, this takes the same parameters
// as the ShowWindow Win32 API does, so the client can have the window hidden
// or shown, minimised to an icon, or maximised to play in full screen mode
// We pass the request on to the base window to actually make the change

STDMETHODIMP CVMRBaseControlWindow::put_WindowState(long WindowState)
{
    AMTRACE((TEXT("put_WindowState"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    DoShowWindow(WindowState);
    return NOERROR;
}


// Get the current window state, this function returns a subset of the SW bit
// settings available in ShowWindow, if the window is visible then SW_SHOW is
// set, if it is hidden then the SW_HIDDEN is set, if it is either minimised
// or maximised then the SW_MINIMIZE or SW_MAXIMIZE is set respectively. The
// other SW bit settings are really set commands not readable output values

STDMETHODIMP CVMRBaseControlWindow::get_WindowState(long *pWindowState)
{
    AMTRACE((TEXT("get_WindowState"), 1));
    CheckPointer(pWindowState,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    ASSERT(pWindowState);
    *pWindowState = FALSE;

    // Is the window visible, a window is termed visible if it is somewhere on
    // the current desktop even if it is completely obscured by other windows
    // so the flag is a style for each window set with the WS_VISIBLE bit

    if (IsWindowVisible(m_hwnd) == TRUE) {

        // Is the base window iconic
        if (IsIconic(m_hwnd) == TRUE) {
            *pWindowState |= SW_MINIMIZE;
        }

        // Has the window been maximised
        else if (IsZoomed(m_hwnd) == TRUE) {
            *pWindowState |= SW_MAXIMIZE;
        }

        // Window is normal
        else {
            *pWindowState |= SW_SHOW;
        }

    } else {
        *pWindowState |= SW_HIDE;
    }
    return NOERROR;
}


// This makes sure that any palette we realise in the base window (through a
// media type or through the overlay interface) is done in the background and
// is therefore mapped to existing device entries rather than taking it over
// as it will do when we this window gets the keyboard focus. An application
// uses this to make sure it doesn't have it's palette removed by the window

STDMETHODIMP CVMRBaseControlWindow::put_BackgroundPalette(long BackgroundPalette)
{
    AMTRACE((TEXT("put_BackgroundPalette"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cWindowLock(&m_WindowLock);

    // Check this is a valid automation boolean type

    if (BackgroundPalette != OATRUE) {
        if (BackgroundPalette != OAFALSE) {
            return E_INVALIDARG;
        }
    }

    // Make sure the window realises any palette it has again

    m_bBackground = (BackgroundPalette == OATRUE ? TRUE : FALSE);
    PostMessage(m_hwnd,m_RealizePalette,0,0);
    PaintWindow(FALSE);

    return NOERROR;
}


// This returns the current background realisation setting

STDMETHODIMP
CVMRBaseControlWindow::get_BackgroundPalette(long *pBackgroundPalette)
{
    AMTRACE((TEXT("get_BackgroundPalette"), 1));
    CheckPointer(pBackgroundPalette,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cWindowLock(&m_WindowLock);

    // Get the current background palette setting

    *pBackgroundPalette = (m_bBackground == TRUE ? OATRUE : OAFALSE);
    return NOERROR;
}


// Change the visibility of the base window

STDMETHODIMP CVMRBaseControlWindow::put_Visible(long Visible)
{
    AMTRACE((TEXT("put_Visible"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);

    // Check this is a valid automation boolean type

    if (Visible != OATRUE) {
        if (Visible != OAFALSE) {
            return E_INVALIDARG;
        }
    }

    // Convert the boolean visibility into SW_SHOW and SW_HIDE

    INT Mode = (Visible == OATRUE ? SW_SHOWNORMAL : SW_HIDE);
    DoShowWindow(Mode);
    return NOERROR;
}


// Return OATRUE if the window is currently visible otherwise OAFALSE

STDMETHODIMP CVMRBaseControlWindow::get_Visible(long *pVisible)
{
    AMTRACE((TEXT("get_Visible"), 1));
    CheckPointer(pVisible,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);

    // See if the base window has a WS_VISIBLE style - this will return TRUE
    // even if the window is completely obscured by other desktop windows, we
    // return FALSE if the window is not showing because of earlier calls

    BOOL Mode = IsWindowVisible(m_hwnd);
    *pVisible = (Mode == TRUE ? OATRUE : OAFALSE);
    return NOERROR;
}


// Change the left position of the base window. This keeps the window width
// and height properties the same so it effectively shunts the window left or
// right accordingly - there is the Width property to change that dimension

STDMETHODIMP CVMRBaseControlWindow::put_Left(long Left)
{
    AMTRACE((TEXT("put_Left"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    BOOL bSuccess;
    RECT WindowRect;

    // Get the current window position in a RECT
    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&WindowRect));

    if (GetParent(m_hwnd)) {

        MapWindowPoints(HWND_DESKTOP, GetParent(m_hwnd), (LPPOINT)&WindowRect, 2);
    }

    // Adjust the coordinates ready for SetWindowPos, the window rectangle we
    // get back from GetWindowRect is in left,top,right and bottom while the
    // coordinates SetWindowPos wants are left,top,width and height values

    WindowRect.bottom = WindowRect.bottom - WindowRect.top;
    WindowRect.right = WindowRect.right - WindowRect.left;
    UINT WindowFlags = SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE;

    bSuccess = SetWindowPos(m_hwnd,                // Window handle
                            HWND_TOP,              // Put it at the top
                            Left,                  // New left position
                            WindowRect.top,        // Leave top alone
                            WindowRect.right,      // The WIDTH (not right)
                            WindowRect.bottom,     // The HEIGHT (not bottom)
                            WindowFlags);          // Show window options

    if (bSuccess == FALSE) {
        return E_INVALIDARG;
    }
    return NOERROR;
}


// Return the current base window left position

STDMETHODIMP CVMRBaseControlWindow::get_Left(long *pLeft)
{
    AMTRACE((TEXT("get_Left"), 1));
    CheckPointer(pLeft,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    RECT WindowRect;

    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&WindowRect));
    *pLeft = WindowRect.left;
    return NOERROR;
}


// Change the current width of the base window. This property complements the
// left position property so we must keep the left edge constant and expand or
// contract to the right, the alternative would be to change the left edge so
// keeping the right edge constant but this is maybe a little more intuitive

STDMETHODIMP CVMRBaseControlWindow::put_Width(long Width)
{
    AMTRACE((TEXT("put_Width"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    BOOL bSuccess;
    RECT WindowRect;

    // Adjust the coordinates ready for SetWindowPos, the window rectangle we
    // get back from GetWindowRect is in left,top,right and bottom while the
    // coordinates SetWindowPos wants are left,top,width and height values

    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&WindowRect));

    if (GetParent(m_hwnd)) {

        MapWindowPoints(HWND_DESKTOP, GetParent(m_hwnd), (LPPOINT)&WindowRect, 2);
    }

    WindowRect.bottom = WindowRect.bottom - WindowRect.top;
    UINT WindowFlags = SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE;

    // This seems to have a bug in that calling SetWindowPos on a window with
    // just the width changing causes it to ignore the width that you pass in
    // and sets it to a mimimum value of 110 pixels wide (Windows NT 3.51)

    bSuccess = SetWindowPos(m_hwnd,                // Window handle
                            HWND_TOP,              // Put it at the top
                            WindowRect.left,       // Leave left alone
                            WindowRect.top,        // Leave top alone
                            Width,                 // New WIDTH dimension
                            WindowRect.bottom,     // The HEIGHT (not bottom)
                            WindowFlags);          // Show window options

    if (bSuccess == FALSE) {
        return E_INVALIDARG;
    }
    return NOERROR;
}


// Return the current base window width

STDMETHODIMP CVMRBaseControlWindow::get_Width(long *pWidth)
{
    AMTRACE((TEXT("get_Width"), 1));
    CheckPointer(pWidth,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    RECT WindowRect;

    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&WindowRect));
    *pWidth = WindowRect.right - WindowRect.left;
    return NOERROR;
}


// This allows the client program to change the top position for the window in
// the same way that changing the left position does not affect the width of
// the image so changing the top position does not affect the window height

STDMETHODIMP CVMRBaseControlWindow::put_Top(long Top)
{
    AMTRACE((TEXT("put_Top"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    BOOL bSuccess;
    RECT WindowRect;

    // Get the current window position in a RECT
    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&WindowRect));

    if (GetParent(m_hwnd)) {

        MapWindowPoints(HWND_DESKTOP, GetParent(m_hwnd), (LPPOINT)&WindowRect, 2);
    }

    // Adjust the coordinates ready for SetWindowPos, the window rectangle we
    // get back from GetWindowRect is in left,top,right and bottom while the
    // coordinates SetWindowPos wants are left,top,width and height values

    WindowRect.bottom = WindowRect.bottom - WindowRect.top;
    WindowRect.right = WindowRect.right - WindowRect.left;
    UINT WindowFlags = SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE;

    bSuccess = SetWindowPos(m_hwnd,                // Window handle
                            HWND_TOP,              // Put it at the top
                            WindowRect.left,       // Leave left alone
                            Top,                   // New top position
                            WindowRect.right,      // The WIDTH (not right)
                            WindowRect.bottom,     // The HEIGHT (not bottom)
                            WindowFlags);          // Show window flags

    if (bSuccess == FALSE) {
        return E_INVALIDARG;
    }
    return NOERROR;
}


// Return the current base window top position

STDMETHODIMP CVMRBaseControlWindow::get_Top(long *pTop)
{
    AMTRACE((TEXT("get_Top"), 1));
    CheckPointer(pTop,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    RECT WindowRect;

    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&WindowRect));
    *pTop = WindowRect.top;
    return NOERROR;
}


// Change the height of the window, this complements the top property so when
// we change this we must keep the top position for the base window, as said
// before we could keep the bottom and grow upwards although this is perhaps
// a little more intuitive since we already have a top position property

STDMETHODIMP CVMRBaseControlWindow::put_Height(long Height)
{
    AMTRACE((TEXT("put_Height"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    BOOL bSuccess;
    RECT WindowRect;

    // Adjust the coordinates ready for SetWindowPos, the window rectangle we
    // get back from GetWindowRect is in left,top,right and bottom while the
    // coordinates SetWindowPos wants are left,top,width and height values

    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&WindowRect));

    if (GetParent(m_hwnd)) {

        MapWindowPoints(HWND_DESKTOP, GetParent(m_hwnd), (LPPOINT)&WindowRect, 2);
    }

    WindowRect.right = WindowRect.right - WindowRect.left;
    UINT WindowFlags = SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE;

    bSuccess = SetWindowPos(m_hwnd,                // Window handle
                            HWND_TOP,              // Put it at the top
                            WindowRect.left,       // Leave left alone
                            WindowRect.top,        // Leave top alone
                            WindowRect.right,      // The WIDTH (not right)
                            Height,                // New height dimension
                            WindowFlags);          // Show window flags

    if (bSuccess == FALSE) {
        return E_INVALIDARG;
    }
    return NOERROR;
}


// Return the current base window height

STDMETHODIMP CVMRBaseControlWindow::get_Height(long *pHeight)
{
    AMTRACE((TEXT("get_Height"), 1));
    CheckPointer(pHeight,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    RECT WindowRect;

    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&WindowRect));
    *pHeight = WindowRect.bottom - WindowRect.top;
    return NOERROR;
}


// This can be called to change the owning window. Setting the owner is done
// through this function, however to make the window a true child window the
// style must also be set to WS_CHILD. After resetting the owner to NULL an
// application should also set the style to WS_OVERLAPPED | WS_CLIPCHILDREN.

// We cannot lock the object here because the SetParent causes an interthread
// SendMessage to the owner window. If they are in GetState we will sit here
// incomplete with the critical section locked therefore blocking out source
// filter threads from accessing us. Because the source thread can't enter us
// it can't get buffers or call EndOfStream so the GetState will not complete

STDMETHODIMP CVMRBaseControlWindow::put_Owner(OAHWND Owner)
{
    AMTRACE((TEXT("put_Owner"), 1));
    // Check we are connected otherwise reject the call

    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    m_hwndOwner = (HWND) Owner;
    HWND hwndParent = m_hwndOwner;

    // Add or remove WS_CHILD as appropriate

    LONG Style = GetWindowLong(m_hwnd,GWL_STYLE);
    if (Owner == NULL) {
        Style &= (~WS_CHILD);
    } else {
        Style |= (WS_CHILD);
    }
    SetWindowLong(m_hwnd,GWL_STYLE,Style);

    // Don't call this with the filter locked

    SetParent(m_hwnd,hwndParent);

    PaintWindow(TRUE);
    NOTE1("Changed parent %lx",hwndParent);

    return NOERROR;
}


// This complements the put_Owner to get the current owning window property
// we always return NOERROR although the returned window handle may be NULL
// to indicate no owning window (the desktop window doesn't qualify as one)
// If an application sets the owner we call SetParent, however that returns
// NULL until the WS_CHILD bit is set on, so we store the owner internally

STDMETHODIMP CVMRBaseControlWindow::get_Owner(OAHWND *Owner)
{
    AMTRACE((TEXT("get_Owner"), 1));
    CheckPointer(Owner,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    *Owner = (OAHWND) m_hwndOwner;
    return NOERROR;
}


// And renderer supporting IVideoWindow may have an HWND set who will get any
// keyboard and mouse messages we receive posted on to them. This is separate
// from setting an owning window. By separating the two, applications may get
// messages sent on even when they have set no owner (perhaps it's maximised)

STDMETHODIMP CVMRBaseControlWindow::put_MessageDrain(OAHWND Drain)
{
    AMTRACE((TEXT("put_MessageDrain"), 1));
    // Check we are connected otherwise reject the call

    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    m_hwndDrain = (HWND) Drain;
    return NOERROR;
}


// Return the current message drain

STDMETHODIMP CVMRBaseControlWindow::get_MessageDrain(OAHWND *Drain)
{
    AMTRACE((TEXT("get_MessageDrain"), 1));
    CheckPointer(Drain,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    *Drain = (OAHWND) m_hwndDrain;
    return NOERROR;
}


// This is called by the filter graph to inform us of a message we should know
// is being sent to our owning window. We have this because as a child window
// we do not get certain messages that are only sent to top level windows. We
// must see the palette changed/changing/query messages so that we know if we
// have the foreground palette or not. We pass the message on to our window
// using SendMessage - this will cause an interthread send message to occur

STDMETHODIMP
CVMRBaseControlWindow::NotifyOwnerMessage(OAHWND hwnd,    // Window handle
                                       long uMsg,    // Message ID
                                       LONG_PTR wParam,  // Parameters
                                       LONG_PTR lParam)  // for message
{
    AMTRACE((TEXT("NotifyOwnerMessage"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);

    // Only interested in these Windows messages

    switch (uMsg) {

        case WM_SYSCOLORCHANGE:
        case WM_PALETTECHANGED:
        case WM_PALETTEISCHANGING:
        case WM_QUERYNEWPALETTE:
        case WM_DEVMODECHANGE:
        case WM_DISPLAYCHANGE:
        case WM_ACTIVATEAPP:

            // If we do not have an owner then ignore

            if (m_hwndOwner == NULL) {
                return NOERROR;
            }
            SendMessage(m_hwnd,uMsg,(WPARAM)wParam,(LPARAM)lParam);
	    break;

	// do NOT fwd WM_MOVE. the parameters are the location of the parent
	// window, NOT what the renderer should be looking at.  But we need
	// to make sure the overlay is moved with the parent window, so we
	// do this.
	case WM_MOVE:
	    PostMessage(m_hwnd,WM_PAINT,0,0);
	    break;
    }
    return NOERROR;
}


// Allow an application to have us set the base window in the foreground. We
// have this because it is difficult for one thread to do do this to a window
// owned by another thread. We ask the base window class to do the real work

STDMETHODIMP CVMRBaseControlWindow::SetWindowForeground(long Focus)
{
    AMTRACE((TEXT("SetWindowForeground"), 1));
    // Check this is a valid automation boolean type

    if (Focus != OATRUE) {
        if (Focus != OAFALSE) {
            return E_INVALIDARG;
        }
    }

    // We shouldn't lock as this sends a message

    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    BOOL bFocus = (Focus == OATRUE ? TRUE : FALSE);
    DoSetWindowForeground(bFocus);

    return NOERROR;
}


// This allows a client to set the complete window size and position in one
// atomic operation. The same affect can be had by changing each dimension
// in turn through their individual properties although some flashing will
// occur as each of them gets updated (they are better set at design time)

STDMETHODIMP
CVMRBaseControlWindow::SetWindowPosition(long Left,long Top,long Width,long Height)
{
    AMTRACE((TEXT("SetWindowPosition"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    BOOL bSuccess;

    // Set the new size and position
    UINT WindowFlags = SWP_NOZORDER | SWP_FRAMECHANGED | SWP_NOACTIVATE;

    ASSERT(IsWindow(m_hwnd));
    bSuccess = SetWindowPos(m_hwnd,         // Window handle
                            HWND_TOP,       // Put it at the top
                            Left,           // Left position
                            Top,            // Top position
                            Width,          // Window width
                            Height,         // Window height
                            WindowFlags);   // Show window flags
    ASSERT(bSuccess);
#ifdef DEBUG
    DbgLog((LOG_TRACE, 1, TEXT("SWP failed error %d"), GetLastError(), 1));
#endif
    if (bSuccess == FALSE) {
        return E_INVALIDARG;
    }
    return NOERROR;
}


// This complements the SetWindowPosition to return the current window place
// in device coordinates. As before the same information can be retrived by
// calling the property get functions individually but this is atomic and is
// therefore more suitable to a live environment rather than design time

STDMETHODIMP
CVMRBaseControlWindow::GetWindowPosition(long *pLeft,long *pTop,long *pWidth,long *pHeight)
{
    AMTRACE((TEXT("GetWindowPosition"), 1));
    // Should check the pointers are not NULL

    CheckPointer(pLeft,E_POINTER);
    CheckPointer(pTop,E_POINTER);
    CheckPointer(pWidth,E_POINTER);
    CheckPointer(pHeight,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    RECT WindowRect;

    // Get the current window coordinates

    EXECUTE_ASSERT(GetWindowRect(m_hwnd,&WindowRect));

    // Convert the RECT into left,top,width and height values

    *pLeft = WindowRect.left;
    *pTop = WindowRect.top;
    *pWidth = WindowRect.right - WindowRect.left;
    *pHeight = WindowRect.bottom - WindowRect.top;

    return NOERROR;
}


// When a window is maximised or iconic calling GetWindowPosition will return
// the current window position (likewise for the properties). However if the
// restored size (ie the size we'll return to when normally shown) is needed
// then this should be used. When in a normal position (neither iconic nor
// maximised) then this returns the same coordinates as GetWindowPosition

STDMETHODIMP
CVMRBaseControlWindow::GetRestorePosition(long *pLeft,long *pTop,long *pWidth,long *pHeight)
{
    AMTRACE((TEXT("GetRestorePosition"), 1));
    // Should check the pointers are not NULL

    CheckPointer(pLeft,E_POINTER);
    CheckPointer(pTop,E_POINTER);
    CheckPointer(pWidth,E_POINTER);
    CheckPointer(pHeight,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);

    // Use GetWindowPlacement to find the restore position

    WINDOWPLACEMENT Place;
    Place.length = sizeof(WINDOWPLACEMENT);
    EXECUTE_ASSERT(GetWindowPlacement(m_hwnd,&Place));

    RECT WorkArea;

    // We must take into account any task bar present

    if (SystemParametersInfo(SPI_GETWORKAREA,0,&WorkArea,FALSE) == TRUE) {
        if (GetParent(m_hwnd) == NULL) {
            Place.rcNormalPosition.top += WorkArea.top;
            Place.rcNormalPosition.bottom += WorkArea.top;
            Place.rcNormalPosition.left += WorkArea.left;
            Place.rcNormalPosition.right += WorkArea.left;
        }
    }

    // Convert the RECT into left,top,width and height values

    *pLeft = Place.rcNormalPosition.left;
    *pTop = Place.rcNormalPosition.top;
    *pWidth = Place.rcNormalPosition.right - Place.rcNormalPosition.left;
    *pHeight = Place.rcNormalPosition.bottom - Place.rcNormalPosition.top;

    return NOERROR;
}


// Return the current border colour, if we are playing something to a subset
// of the base window display there is an outside area exposed. The default
// action is to paint this colour in the Windows background colour (defined
// as value COLOR_WINDOW) We reset to this default when we're disconnected

STDMETHODIMP CVMRBaseControlWindow::get_BorderColor(long *Color)
{
    AMTRACE((TEXT("get_BorderColor"), 1));
    CheckPointer(Color,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    *Color = (long) m_BorderColour;
    return NOERROR;
}


// This can be called to set the current border colour

STDMETHODIMP CVMRBaseControlWindow::put_BorderColor(long Color)
{
    AMTRACE((TEXT("put_BorderColor"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);

    // Have the window repainted with the new border colour

    m_BorderColour = (COLORREF) Color;
    PaintWindow(TRUE);
    return NOERROR;
}


// Delegate fullscreen handling to plug in distributor

STDMETHODIMP CVMRBaseControlWindow::get_FullScreenMode(long *FullScreenMode)
{
    AMTRACE((TEXT("get_FullScreenMode"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CheckPointer(FullScreenMode,E_POINTER);
    return E_NOTIMPL;
}


// Delegate fullscreen handling to plug in distributor

STDMETHODIMP CVMRBaseControlWindow::put_FullScreenMode(long FullScreenMode)
{
    AMTRACE((TEXT("put_FullScreenMode"), 1));
    return E_NOTIMPL;
}


// This sets the auto show property, this property causes the base window to
// be displayed whenever we change state. This allows an application to have
// to do nothing to have the window appear but still allow them to change the
// default behaviour if for example they want to keep it hidden for longer

STDMETHODIMP CVMRBaseControlWindow::put_AutoShow(long AutoShow)
{
    AMTRACE((TEXT("put_AutoShow"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);

    // Check this is a valid automation boolean type

    if (AutoShow != OATRUE) {
        if (AutoShow != OAFALSE) {
            return E_INVALIDARG;
        }
    }

    m_bAutoShow = (AutoShow == OATRUE ? TRUE : FALSE);
    return NOERROR;
}


// This can be called to get the current auto show flag. The flag is updated
// when we connect and disconnect and through this interface all of which are
// controlled and serialised by means of the main renderer critical section

STDMETHODIMP CVMRBaseControlWindow::get_AutoShow(long *AutoShow)
{
    AMTRACE((TEXT("get_AutoShow"), 1));
    CheckPointer(AutoShow,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    *AutoShow = (m_bAutoShow == TRUE ? OATRUE : OAFALSE);
    return NOERROR;
}


// Return the minimum ideal image size for the current video. This may differ
// to the actual video dimensions because we may be using DirectDraw hardware
// that has specific stretching requirements. For example the Cirrus Logic
// cards have a minimum stretch factor depending on the overlay surface size

STDMETHODIMP
CVMRBaseControlWindow::GetMinIdealImageSize(long *pWidth,long *pHeight)
{
    AMTRACE((TEXT("GetMinIdealImageSize"), 1));
    CheckPointer(pWidth,E_POINTER);
    CheckPointer(pHeight,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    FILTER_STATE State;

    // Must not be stopped for this to work correctly

    m_pFilter->GetState(0,&State);
    if (State == State_Stopped) {
        return VFW_E_WRONG_STATE;
    }

    RECT DefaultRect = GetDefaultRect();
    *pWidth = WIDTH(&DefaultRect);
    *pHeight = HEIGHT(&DefaultRect);
    return NOERROR;
}


// Return the maximum ideal image size for the current video. This may differ
// to the actual video dimensions because we may be using DirectDraw hardware
// that has specific stretching requirements. For example the Cirrus Logic
// cards have a maximum stretch factor depending on the overlay surface size

STDMETHODIMP
CVMRBaseControlWindow::GetMaxIdealImageSize(long *pWidth,long *pHeight)
{
    AMTRACE((TEXT("GetMaxIdealImageSize"), 1));
    CheckPointer(pWidth,E_POINTER);
    CheckPointer(pHeight,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    FILTER_STATE State;

    // Must not be stopped for this to work correctly

    m_pFilter->GetState(0,&State);
    if (State == State_Stopped) {
        return VFW_E_WRONG_STATE;
    }

    RECT DefaultRect = GetDefaultRect();
    *pWidth = WIDTH(&DefaultRect);
    *pHeight = HEIGHT(&DefaultRect);
    return NOERROR;
}


// Allow an application to hide the cursor on our window

STDMETHODIMP
CVMRBaseControlWindow::HideCursor(long HideCursor)
{
    AMTRACE((TEXT("HideCursor"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);

    // Check this is a valid automation boolean type

    if (HideCursor != OATRUE) {
        if (HideCursor != OAFALSE) {
            return E_INVALIDARG;
        }
    }

    m_bCursorHidden = (HideCursor == OATRUE ? TRUE : FALSE);
    return NOERROR;
}


// Returns whether we have the cursor hidden or not

STDMETHODIMP CVMRBaseControlWindow::IsCursorHidden(long *CursorHidden)
{
    AMTRACE((TEXT("IsCursorHidden"), 1));
    CheckPointer(CursorHidden,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    *CursorHidden = (m_bCursorHidden == TRUE ? OATRUE : OAFALSE);
    return NOERROR;
}


// This class implements the IBasicVideo control functions (dual interface)
// we support a large number of properties and methods designed to allow the
// client (whether it be an automation controller or a C/C++ application) to
// set and get a number of video related properties such as the native video
// size. We support some methods that duplicate the properties but provide a
// more direct and efficient mechanism as many values may be changed in one

CVMRBaseControlVideo::CVMRBaseControlVideo(
                        CVMRFilter *pFilter,        // Owning filter
                        CCritSec *pInterfaceLock,    // Locking object
                        TCHAR *pName,                // Object description
                        LPUNKNOWN pUnk,              // Normal COM ownership
                        HRESULT *phr) :              // OLE return code

    CBaseBasicVideo(pName,pUnk),
    m_pFilter(pFilter),
    m_pInterfaceLock(pInterfaceLock)
{
    ASSERT(m_pFilter);
    ASSERT(m_pInterfaceLock);
    ASSERT(phr);
}

// Return an approximate average time per frame

STDMETHODIMP CVMRBaseControlVideo::get_AvgTimePerFrame(REFTIME *pAvgTimePerFrame)
{
    AMTRACE((TEXT("get_AvgTimePerFrame"), 1));
    CheckPointer(pAvgTimePerFrame,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);

    int n = m_pFilter->GetPinCount();
    for (int i = 0; i < n; i++) {

        CBasePin* pPin = m_pFilter->GetPin(i);
        if (pPin && pPin->IsConnected()) {

            AM_MEDIA_TYPE mt;

            if (S_OK == pPin->ConnectionMediaType(&mt)) {

                COARefTime AvgTime(((VIDEOINFOHEADER*)(mt.pbFormat))->AvgTimePerFrame);
                *pAvgTimePerFrame = (REFTIME)AvgTime;

                FreeMediaType(mt);

                return S_OK;
            }
        }
    }

    return E_FAIL;
}


// Return an approximate bit rate for the video

STDMETHODIMP CVMRBaseControlVideo::get_BitRate(long *pBitRate)
{
    AMTRACE((TEXT("get_BitRate"), 1));
    CheckPointer(pBitRate,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);

    int n = m_pFilter->GetPinCount();
    for (int i = 0; i < n; i++) {

        CBasePin* pPin = m_pFilter->GetPin(i);
        if (pPin && pPin->IsConnected()) {

            AM_MEDIA_TYPE mt;

            if (S_OK == pPin->ConnectionMediaType(&mt)) {

                *pBitRate =
                    ((VIDEOINFOHEADER*)(mt.pbFormat))->dwBitRate;
                FreeMediaType(mt);

                return S_OK;
            }
        }
    }
    return E_FAIL;
}


// Return an approximate bit error rate

STDMETHODIMP CVMRBaseControlVideo::get_BitErrorRate(long *pBitErrorRate)
{
    AMTRACE((TEXT("get_BitErrorRate"), 1));
    CheckPointer(pBitErrorRate,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);

    int n = m_pFilter->GetPinCount();
    for (int i = 0; i < n; i++) {

        CBasePin* pPin = m_pFilter->GetPin(i);
        if (pPin && pPin->IsConnected()) {

            AM_MEDIA_TYPE mt;

            if (S_OK == pPin->ConnectionMediaType(&mt)) {

                *pBitErrorRate =
                    ((VIDEOINFOHEADER*)(mt.pbFormat))->dwBitErrorRate;
                FreeMediaType(mt);

                return S_OK;
            }
        }
    }
    return E_FAIL;
}


// This returns the current video width

STDMETHODIMP CVMRBaseControlVideo::get_VideoWidth(long *pVideoWidth)
{
    AMTRACE((TEXT("get_VideoWidth"), 1));
    CheckPointer(pVideoWidth,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);

    IVMRWindowlessControl* lpWLControl = m_pFilter->GetWLControl();
    if (lpWLControl) {
        LONG cy;
        lpWLControl->GetNativeVideoSize(pVideoWidth, &cy, NULL, NULL);
    }
    return NOERROR;
}


// This returns the current video height

STDMETHODIMP CVMRBaseControlVideo::get_VideoHeight(long *pVideoHeight)
{
    AMTRACE((TEXT("get_VideoHeight"), 1));
    CheckPointer(pVideoHeight,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);

    IVMRWindowlessControl* lpWLControl = m_pFilter->GetWLControl();
    if (lpWLControl) {
        LONG cx;
        lpWLControl->GetNativeVideoSize(&cx, pVideoHeight, NULL, NULL);
    }
    return NOERROR;
}


// This returns the current palette the video is using as an array allocated
// by the user. To remain consistent we use PALETTEENTRY fields to return the
// colours in rather than RGBQUADs that multimedia decided to use. The memory
// is allocated by the user so we simple copy each in turn. We check that the
// number of entries requested and the start position offset are both valid
// If the number of entries evaluates to zero then we return an S_FALSE code

STDMETHODIMP CVMRBaseControlVideo::GetVideoPaletteEntries(long StartIndex,
                                                       long Entries,
                                                       long *pRetrieved,
                                                       long *pPalette)
{
    AMTRACE((TEXT("GetVideoPaletteEntries"), 1));
    CheckPointer(pRetrieved,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);

    *pRetrieved = 0;
    return VFW_E_NO_PALETTE_AVAILABLE;
}


// This returns the current video dimensions as a method rather than a number
// of individual property get calls. For the same reasons as said before we
// cannot access the renderer media type directly as the window object thread
// may be updating it since dynamic format changes may change these values

STDMETHODIMP CVMRBaseControlVideo::GetVideoSize(long *pWidth,long *pHeight)
{
    AMTRACE((TEXT("GetVideoSize"), 1));
    CheckPointer(pWidth,E_POINTER);
    CheckPointer(pHeight,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);

    IVMRWindowlessControl* lpWLControl = m_pFilter->GetWLControl();
    if (lpWLControl) {
        lpWLControl->GetNativeVideoSize(pWidth, pHeight, NULL, NULL);
    }

    return NOERROR;
}


// Set the source video rectangle as left,top,right and bottom coordinates
// rather than left,top,width and height as per OLE automation interfaces
// Then pass the rectangle on to the window object to set the source

STDMETHODIMP
CVMRBaseControlVideo::SetSourcePosition(long Left,long Top,long Width,long Height)
{
    AMTRACE((TEXT("SetSourcePosition"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT SourceRect;
    SourceRect.left = Left;
    SourceRect.top = Top;
    SourceRect.right = Left + Width;
    SourceRect.bottom = Top + Height;

    // Check the source rectangle is valid

    HRESULT hr = CheckSourceRect(&SourceRect);
    if (FAILED(hr)) {
        return hr;
    }

    // Now set the source rectangle

    hr = SetSourceRect(&SourceRect);
    if (FAILED(hr)) {
        return hr;
    }
    return OnUpdateRectangles();
}


// Return the source rectangle in left,top,width and height rather than the
// left,top,right and bottom values that RECT uses (and which the window
// object returns through GetSourceRect) which requires a little work

STDMETHODIMP
CVMRBaseControlVideo::GetSourcePosition(long *pLeft,long *pTop,long *pWidth,long *pHeight)
{
    AMTRACE((TEXT("GetSourcePosition"), 1));
    // Should check the pointers are non NULL

    CheckPointer(pLeft,E_POINTER);
    CheckPointer(pTop,E_POINTER);
    CheckPointer(pWidth,E_POINTER);
    CheckPointer(pHeight,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    RECT SourceRect;

    CAutoLock cInterfaceLock(m_pInterfaceLock);
    GetSourceRect(&SourceRect);

    *pLeft = SourceRect.left;
    *pTop = SourceRect.top;
    *pWidth = WIDTH(&SourceRect);
    *pHeight = HEIGHT(&SourceRect);

    return NOERROR;
}


// Set the video destination as left,top,right and bottom coordinates rather
// than the left,top,width and height uses as per OLE automation interfaces
// Then pass the rectangle on to the window object to set the destination

STDMETHODIMP
CVMRBaseControlVideo::SetDestinationPosition(long Left,long Top,long Width,long Height)
{
    AMTRACE((TEXT("SetDestinationPosition"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT DestinationRect;

    DestinationRect.left = Left;
    DestinationRect.top = Top;
    DestinationRect.right = Left + Width;
    DestinationRect.bottom = Top + Height;

    // Check the target rectangle is valid

    HRESULT hr = CheckTargetRect(&DestinationRect);
    if (FAILED(hr)) {
        return hr;
    }

    // Now set the new target rectangle

    hr = SetTargetRect(&DestinationRect);
    if (FAILED(hr)) {
        return hr;
    }
    return OnUpdateRectangles();
}


// Return the destination rectangle in left,top,width and height rather than
// the left,top,right and bottom values that RECT uses (and which the window
// object returns through GetDestinationRect) which requires a little work

STDMETHODIMP
CVMRBaseControlVideo::GetDestinationPosition(long *pLeft,long *pTop,long *pWidth,long *pHeight)
{
    AMTRACE((TEXT("GetDestinationPosition"), 1));
    // Should check the pointers are not NULL

    CheckPointer(pLeft,E_POINTER);
    CheckPointer(pTop,E_POINTER);
    CheckPointer(pWidth,E_POINTER);
    CheckPointer(pHeight,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    RECT DestinationRect;

    CAutoLock cInterfaceLock(m_pInterfaceLock);
    GetTargetRect(&DestinationRect);

    *pLeft = DestinationRect.left;
    *pTop = DestinationRect.top;
    *pWidth = WIDTH(&DestinationRect);
    *pHeight = HEIGHT(&DestinationRect);

    return NOERROR;
}


// Set the source left position, the source rectangle we get back from the
// window object is a true rectangle in left,top,right and bottom positions
// so all we have to do is to update the left position and pass it back. We
// must keep the current width constant when we're updating this property

STDMETHODIMP CVMRBaseControlVideo::put_SourceLeft(long SourceLeft)
{
    AMTRACE((TEXT("put_SourceLeft"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT SourceRect;
    GetSourceRect(&SourceRect);
    SourceRect.right = SourceLeft + WIDTH(&SourceRect);
    SourceRect.left = SourceLeft;

    // Check the source rectangle is valid

    HRESULT hr = CheckSourceRect(&SourceRect);
    if (FAILED(hr)) {
        return hr;
    }

    // Now set the source rectangle

    hr = SetSourceRect(&SourceRect);
    if (FAILED(hr)) {
        return hr;
    }
    return OnUpdateRectangles();
}


// Return the current left source video position

STDMETHODIMP CVMRBaseControlVideo::get_SourceLeft(long *pSourceLeft)
{
    AMTRACE((TEXT("get_SourceLeft"), 1));
    CheckPointer(pSourceLeft,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT SourceRect;

    GetSourceRect(&SourceRect);
    *pSourceLeft = SourceRect.left;
    return NOERROR;
}


// Set the source width, we get the current source rectangle and then update
// the right position to be the left position (thereby keeping it constant)
// plus the new source width we are passed in (it expands to the right)

STDMETHODIMP CVMRBaseControlVideo::put_SourceWidth(long SourceWidth)
{
    AMTRACE((TEXT("put_SourceWidth"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT SourceRect;
    GetSourceRect(&SourceRect);
    SourceRect.right = SourceRect.left + SourceWidth;

    // Check the source rectangle is valid

    HRESULT hr = CheckSourceRect(&SourceRect);
    if (FAILED(hr)) {
        return hr;
    }

    // Now set the source rectangle

    hr = SetSourceRect(&SourceRect);
    if (FAILED(hr)) {
        return hr;
    }
    return OnUpdateRectangles();
}


// Return the current source width

STDMETHODIMP CVMRBaseControlVideo::get_SourceWidth(long *pSourceWidth)
{
    AMTRACE((TEXT("get_SourceWidth"), 1));
    CheckPointer(pSourceWidth,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT SourceRect;

    GetSourceRect(&SourceRect);
    *pSourceWidth = WIDTH(&SourceRect);
    return NOERROR;
}


// Set the source top position - changing this property does not affect the
// current source height. So changing this shunts the source rectangle up and
// down appropriately. Changing the height complements this functionality by
// keeping the top position constant and simply changing the source height

STDMETHODIMP CVMRBaseControlVideo::put_SourceTop(long SourceTop)
{
    AMTRACE((TEXT("put_SourceTop"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT SourceRect;
    GetSourceRect(&SourceRect);
    SourceRect.bottom = SourceTop + HEIGHT(&SourceRect);
    SourceRect.top = SourceTop;

    // Check the source rectangle is valid

    HRESULT hr = CheckSourceRect(&SourceRect);
    if (FAILED(hr)) {
        return hr;
    }

    // Now set the source rectangle

    hr = SetSourceRect(&SourceRect);
    if (FAILED(hr)) {
        return hr;
    }
    return OnUpdateRectangles();
}


// Return the current top position

STDMETHODIMP CVMRBaseControlVideo::get_SourceTop(long *pSourceTop)
{
    AMTRACE((TEXT("get_SourceTop"), 1));
    CheckPointer(pSourceTop,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT SourceRect;

    GetSourceRect(&SourceRect);
    *pSourceTop = SourceRect.top;
    return NOERROR;
}


// Set the source height

STDMETHODIMP CVMRBaseControlVideo::put_SourceHeight(long SourceHeight)
{
    AMTRACE((TEXT("put_SourceHeight"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT SourceRect;
    GetSourceRect(&SourceRect);
    SourceRect.bottom = SourceRect.top + SourceHeight;

    // Check the source rectangle is valid

    HRESULT hr = CheckSourceRect(&SourceRect);
    if (FAILED(hr)) {
        return hr;
    }

    // Now set the source rectangle

    hr = SetSourceRect(&SourceRect);
    if (FAILED(hr)) {
        return hr;
    }
    return OnUpdateRectangles();
}


// Return the current source height

STDMETHODIMP CVMRBaseControlVideo::get_SourceHeight(long *pSourceHeight)
{
    AMTRACE((TEXT("get_SourceHeight"), 1));
    CheckPointer(pSourceHeight,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT SourceRect;

    GetSourceRect(&SourceRect);
    *pSourceHeight = HEIGHT(&SourceRect);
    return NOERROR;
}


// Set the target left position, the target rectangle we get back from the
// window object is a true rectangle in left,top,right and bottom positions
// so all we have to do is to update the left position and pass it back. We
// must keep the current width constant when we're updating this property

STDMETHODIMP CVMRBaseControlVideo::put_DestinationLeft(long DestinationLeft)
{
    AMTRACE((TEXT("put_DestinationLeft"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT DestinationRect;
    GetTargetRect(&DestinationRect);
    DestinationRect.right = DestinationLeft + WIDTH(&DestinationRect);
    DestinationRect.left = DestinationLeft;

    // Check the target rectangle is valid

    HRESULT hr = CheckTargetRect(&DestinationRect);
    if (FAILED(hr)) {
        return hr;
    }

    // Now set the new target rectangle

    hr = SetTargetRect(&DestinationRect);
    if (FAILED(hr)) {
        return hr;
    }
    return OnUpdateRectangles();
}


// Return the left position for the destination rectangle

STDMETHODIMP CVMRBaseControlVideo::get_DestinationLeft(long *pDestinationLeft)
{
    AMTRACE((TEXT("get_DestinationLeft"), 1));
    CheckPointer(pDestinationLeft,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT DestinationRect;

    GetTargetRect(&DestinationRect);
    *pDestinationLeft = DestinationRect.left;
    return NOERROR;
}


// Set the destination width

STDMETHODIMP CVMRBaseControlVideo::put_DestinationWidth(long DestinationWidth)
{
    AMTRACE((TEXT("put_DestinationWidth"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT DestinationRect;
    GetTargetRect(&DestinationRect);
    DestinationRect.right = DestinationRect.left + DestinationWidth;

    // Check the target rectangle is valid

    HRESULT hr = CheckTargetRect(&DestinationRect);
    if (FAILED(hr)) {
        return hr;
    }

    // Now set the new target rectangle

    hr = SetTargetRect(&DestinationRect);
    if (FAILED(hr)) {
        return hr;
    }
    return OnUpdateRectangles();
}


// Return the width for the destination rectangle

STDMETHODIMP CVMRBaseControlVideo::get_DestinationWidth(long *pDestinationWidth)
{
    AMTRACE((TEXT("get_DestinationWidth"), 1));
    CheckPointer(pDestinationWidth,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT DestinationRect;

    GetTargetRect(&DestinationRect);
    *pDestinationWidth = WIDTH(&DestinationRect);
    return NOERROR;
}


// Set the target top position - changing this property does not affect the
// current target height. So changing this shunts the target rectangle up and
// down appropriately. Changing the height complements this functionality by
// keeping the top position constant and simply changing the target height

STDMETHODIMP CVMRBaseControlVideo::put_DestinationTop(long DestinationTop)
{
    AMTRACE((TEXT("put_DestinationTop"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT DestinationRect;
    GetTargetRect(&DestinationRect);
    DestinationRect.bottom = DestinationTop + HEIGHT(&DestinationRect);
    DestinationRect.top = DestinationTop;

    // Check the target rectangle is valid

    HRESULT hr = CheckTargetRect(&DestinationRect);
    if (FAILED(hr)) {
        return hr;
    }

    // Now set the new target rectangle

    hr = SetTargetRect(&DestinationRect);
    if (FAILED(hr)) {
        return hr;
    }
    return OnUpdateRectangles();
}


// Return the top position for the destination rectangle

STDMETHODIMP CVMRBaseControlVideo::get_DestinationTop(long *pDestinationTop)
{
    AMTRACE((TEXT("get_DestinationTop"), 1));
    CheckPointer(pDestinationTop,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT DestinationRect;

    GetTargetRect(&DestinationRect);
    *pDestinationTop = DestinationRect.top;
    return NOERROR;
}


// Set the destination height

STDMETHODIMP CVMRBaseControlVideo::put_DestinationHeight(long DestinationHeight)
{
    AMTRACE((TEXT("put_DestinationHeight"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT DestinationRect;
    GetTargetRect(&DestinationRect);
    DestinationRect.bottom = DestinationRect.top + DestinationHeight;

    // Check the target rectangle is valid

    HRESULT hr = CheckTargetRect(&DestinationRect);
    if (FAILED(hr)) {
        return hr;
    }

    // Now set the new target rectangle

    hr = SetTargetRect(&DestinationRect);
    if (FAILED(hr)) {
        return hr;
    }
    return OnUpdateRectangles();
}


// Return the height for the destination rectangle

STDMETHODIMP CVMRBaseControlVideo::get_DestinationHeight(long *pDestinationHeight)
{
    AMTRACE((TEXT("get_DestinationHeight"), 1));
    CheckPointer(pDestinationHeight,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    RECT DestinationRect;

    GetTargetRect(&DestinationRect);
    *pDestinationHeight = HEIGHT(&DestinationRect);
    return NOERROR;
}


// Reset the source rectangle to the full video dimensions

STDMETHODIMP CVMRBaseControlVideo::SetDefaultSourcePosition()
{
    AMTRACE((TEXT("SetDefaultSourcePosition"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    HRESULT hr = SetDefaultSourceRect();
    if (FAILED(hr)) {
        return hr;
    }
    return OnUpdateRectangles();
}


// Return S_OK if we're using the default source otherwise S_FALSE

STDMETHODIMP CVMRBaseControlVideo::IsUsingDefaultSource()
{
    AMTRACE((TEXT("IsUsingDefaultSource"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    return IsDefaultSourceRect();
}


// Reset the video renderer to use the entire playback area

STDMETHODIMP CVMRBaseControlVideo::SetDefaultDestinationPosition()
{
    AMTRACE((TEXT("SetDefaultDestinationPosition"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    HRESULT hr = SetDefaultTargetRect();
    if (FAILED(hr)) {
        return hr;
    }
    return OnUpdateRectangles();
}


// Return S_OK if we're using the default target otherwise S_FALSE

STDMETHODIMP CVMRBaseControlVideo::IsUsingDefaultDestination()
{
    AMTRACE((TEXT("IsUsingDefaultDestination"), 1));
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);
    return IsDefaultTargetRect();
}


// Return a copy of the current image in the video renderer

STDMETHODIMP
CVMRBaseControlVideo::GetCurrentImage(long *pBufferSize,long *pVideoImage)
{
    AMTRACE((TEXT("GetCurrentImage"), 1));
    CheckPointer(pBufferSize,E_POINTER);
    CheckConnected(m_pFilter,VFW_E_NOT_CONNECTED);
    CAutoLock cInterfaceLock(m_pInterfaceLock);

    LONG cy;
    LONG cx;
    IVMRWindowlessControl* lpWLControl = m_pFilter->GetWLControl();

    HRESULT hr = E_NOTIMPL;

    if (lpWLControl) {

        hr = lpWLControl->GetNativeVideoSize(&cx, &cy, NULL, NULL);

        if (pVideoImage == NULL) {
            *pBufferSize = sizeof(BITMAPINFOHEADER) + (cx * cy * 4);
        }
        else {

            LPBYTE lpDib;

            hr = lpWLControl->GetCurrentImage(&lpDib);

            if (hr == S_OK) {
                DWORD CopyLen = min((DWORD)*pBufferSize,
                                   sizeof(BITMAPINFOHEADER) + (cx * cy * 4));
                CopyMemory(pVideoImage, lpDib, CopyLen);
                CoTaskMemFree(lpDib);
            }
        }
    }

    return hr;
}


// Called when we change media types either during connection or dynamically
// We inform the filter graph and therefore the application that the video
// size may have changed, we don't bother looking to see if it really has as
// we leave that to the application - the dimensions are the event parameters

HRESULT CVMRBaseControlVideo::OnVideoSizeChange()
{
    AMTRACE((TEXT("OnVideoSizeChange"), 1));
    // Get the video format from the derived class

    LONG lWidth, lHeight;
    HRESULT hr  = GetVideoSize(&lWidth, &lHeight);
    if (NOERROR == hr) {

        WORD Width = (WORD)lWidth;
        WORD Height = (WORD)lHeight;

        return m_pFilter->NotifyEvent(EC_VIDEO_SIZE_CHANGED,
                                      MAKELPARAM(Width,Height), 0);
    }

    return hr;
}


// Set the video source rectangle. We must check the source rectangle against
// the actual video dimensions otherwise when we come to draw the pictures we
// get access violations as GDI tries to touch data outside of the image data
// Although we store the rectangle in left, top, right and bottom coordinates
// instead of left, top, width and height as OLE uses we do take into account
// that the rectangle is used up to, but not including, the right column and
// bottom row of pixels, see the Win32 documentation on RECT for more details

HRESULT CVMRBaseControlVideo::CheckSourceRect(RECT *pSourceRect)
{
    CheckPointer(pSourceRect,E_POINTER);
    LONG Width,Height;
    GetVideoSize(&Width,&Height);

    // Check the coordinates are greater than zero
    // and that the rectangle is valid (left<right, top<bottom)

    if ((pSourceRect->left >= pSourceRect->right) ||
       (pSourceRect->left < 0) ||
       (pSourceRect->top >= pSourceRect->bottom) ||
       (pSourceRect->top < 0)) {

        return E_INVALIDARG;
    }

    // Check the coordinates are less than the extents

    if ((pSourceRect->right > Width) ||
        (pSourceRect->bottom > Height)) {

        return E_INVALIDARG;
    }
    return NOERROR;
}


// Check the target rectangle has some valid coordinates, which amounts to
// little more than checking the destination rectangle isn't empty. Derived
// classes may call this when they have their SetTargetRect method called to
// check the rectangle validity, we do not update the rectangles passed in
// Although we store the rectangle in left, top, right and bottom coordinates
// instead of left, top, width and height as OLE uses we do take into account
// that the rectangle is used up to, but not including, the right column and
// bottom row of pixels, see the Win32 documentation on RECT for more details

HRESULT CVMRBaseControlVideo::CheckTargetRect(RECT *pTargetRect)
{
    // Check the pointer is valid

    if (pTargetRect == NULL) {
        return E_POINTER;
    }

    // These overflow the WIDTH and HEIGHT checks

    if (pTargetRect->left > pTargetRect->right ||
            pTargetRect->top > pTargetRect->bottom) {
                return E_INVALIDARG;
    }

    // Check the rectangle has valid coordinates

    if (WIDTH(pTargetRect) <= 0 || HEIGHT(pTargetRect) <= 0) {
        return E_INVALIDARG;
    }

    ASSERT(IsRectEmpty(pTargetRect) == FALSE);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\lin21dec\l21dbase.cpp ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.

//
// ActiveMovie Line 21 Decoder Filter: Base class code
//

#include <streams.h>
#include <windowsx.h>

// #ifdef FILTER_DLL
#include <initguid.h>
// #endif

#include <IL21Dec.h>
#include "L21DBase.h"
#include "L21DGDI.h"
#include "L21Decod.h"


//
//  CCaptionChar: Caption char base class implementation (non-inline methods)
//

void CCaptionChar::SetChar(UINT16 wChar)
{
    if (wChar != m_wChar)
    {
        SetDirty(TRUE) ;
        m_wChar = wChar ;
    }
}

void CCaptionChar::SetColor(UINT8 uColor)
{
    if (uColor != GetColor())  // color changed
    {
        SetDirty(TRUE) ;
        m_uAttrib &= ~AM_L21_FGCOLOR_MASK ;           // clear old color
        m_uAttrib |= (uColor & AM_L21_FGCOLOR_MASK) ; // set new color
    }
}

void CCaptionChar::SetEffect(UINT8 uEffect)
{
    if (uEffect != GetEffect())
    {
        SetDirty(TRUE) ; 
        m_uAttrib &= ~AM_L21_FGEFFECT_MASK ;            // clear old effect bits
        m_uAttrib |= (uEffect & AM_L21_FGEFFECT_MASK) ; // set new effect value
    }
}

void CCaptionChar::SetItalicized(BOOL bState) 
{
    if (bState) 
        m_uAttrib |= AM_L21_FGEFFECT_ITALICS ;
    else 
        m_uAttrib &= ~AM_L21_FGEFFECT_ITALICS ;
    SetDirty(TRUE) ; 
}

void CCaptionChar::SetUnderLined(BOOL bState)
{
    if (bState) 
        m_uAttrib |= AM_L21_FGEFFECT_UNDERLINE ;
    else 
        m_uAttrib &= ~AM_L21_FGEFFECT_UNDERLINE ;
    SetDirty(TRUE) ; 
}

void CCaptionChar::SetFlashing(BOOL bState)
{
    if (bState) 
        m_uAttrib |= AM_L21_FGEFFECT_FLASHING ;
    else 
        m_uAttrib &= ~AM_L21_FGEFFECT_FLASHING ;
    SetDirty(TRUE) ; 
}

void CCaptionChar::SetDirty(BOOL bState)
{
    if (bState) 
        m_uAttrib |= AM_L21_ATTRIB_DIRTY ;
    else 
        m_uAttrib &= ~AM_L21_ATTRIB_DIRTY ;
}

void CCaptionChar::SetMidRowCode(BOOL bState)
{
    if (bState) 
        m_uAttrib |= AM_L21_ATTRIB_MRC ;
    else 
        m_uAttrib &= ~AM_L21_ATTRIB_MRC ;
}



//
//  CCaptionLine: Base class implementation of a line of CC chars
//
CCaptionLine::CCaptionLine(void)
{
    m_uNumChars = 0 ;
    m_uStartRow = 0 ;  // un-inited
    ClearLine() ;
}

CCaptionLine::CCaptionLine(const UINT uStartRow, const UINT uNumChars /* 0 */)
{
    m_uNumChars = (UINT8)uNumChars ;
    m_uStartRow = (UINT8)uStartRow ;
    ClearLine() ;
}

CCaptionLine& CCaptionLine::operator = (const CCaptionLine& cl)
{
    m_uNumChars = cl.m_uNumChars ;
    m_uStartRow = cl.m_uStartRow ;
    for (int i = 0 ; i < MAX_CAPTION_COLUMNS ; i++)
        cl.GetCaptionChar(i, m_aCapChar[i]) ;
    return *this ;
}

int CCaptionLine::IncNumChars(UINT uNumChars)
{
    m_uNumChars += (uNumChars & 0x3F) ;
    if (m_uNumChars > MAX_CAPTION_COLUMNS)
        m_uNumChars = MAX_CAPTION_COLUMNS ;
    return m_uNumChars ;
}

int CCaptionLine::DecNumChars(UINT uNumChars)
{
    if (uNumChars < m_uNumChars)
        m_uNumChars -= (UINT8)uNumChars ;   // & 0x3F ;
    else       // error ??? or just make it 0 ???
        m_uNumChars = 0 ;
    return m_uNumChars ;
}

void CCaptionLine::SetCaptionChar(UINT uCol, const CCaptionChar &cc)
{
    if (uCol >= (UINT)MAX_CAPTION_COLUMNS)   // error!!
        return ;

    // A Hacky (?) Fix:
    // If this char is for the last (32nd) column then we set the "Dirty"
    // flag on for the char before it so that it gets redrawn causing any
    // prev char in last column to be erased while rendering.
    if ((UINT)MAX_CAPTION_COLUMNS - 1 == uCol)
        m_aCapChar[uCol-1].SetDirty(TRUE) ;  // to cause re-rendering
    m_aCapChar[uCol] = cc  ;
}

CCaptionChar* CCaptionLine::GetCaptionCharPtr(UINT uCol)
{
    if (uCol >= (UINT)MAX_CAPTION_COLUMNS)   // error!!
        return NULL ;
    return &(m_aCapChar[uCol]) ;
}

void CCaptionLine::SetStartRow(UINT uRow)
{
    if (uRow > MAX_CAPTION_ROWS)  // error!! We use 1-based index for Row numbers
    {
        ASSERT(uRow > MAX_CAPTION_ROWS) ;
        return ;
    }
    m_uStartRow = uRow & 0xF ;
    ASSERT(m_uStartRow > 0 && uRow > 0) ;
}

void CCaptionLine::MoveCaptionChars(int iNum)
{
    ASSERT(iNum < MAX_CAPTION_COLUMNS) ;
    int  i ;
    for (i = min(m_uNumChars, MAX_CAPTION_COLUMNS-iNum) - 1 ; i >= 0 ; i--)
        m_aCapChar[i+iNum] = m_aCapChar[i] ;
    CCaptionChar  cc ;
    for (i = 0 ; i < iNum ; i++)
        m_aCapChar[i] = cc ;
    m_uNumChars = min(m_uNumChars+iNum, MAX_CAPTION_COLUMNS) ;
}

void CCaptionLine::ClearLine(void)
{
    CCaptionChar cc ;
    for (UINT u = 0 ; u < MAX_CAPTION_COLUMNS ; u++)
        m_aCapChar[u] = cc ;
    m_uNumChars = 0 ;
    m_uStartRow = 0 ;   // newly added
}



//
//  CRowIndexMap: Mapping of row usage (row to line) class implementation
//
int CRowIndexMap::GetRowIndex(UINT8 uRow)
{
    DbgLog((LOG_TRACE, 5, TEXT("CRowIndexMap::GetRowIndex(%u)"), uRow)) ;

    uRow-- ;   // it's just easier to deal with 0-based index
    
    if (uRow >= MAX_CAPTION_ROWS)
    {
        DbgLog((LOG_ERROR, 2, TEXT("Invalid row number (%u) for row index"), uRow)) ;
        ASSERT(FALSE) ;
        return -1 ;
    }
    
    // Decide if we check the bits in 1st or 2nd DWORD (mask is 1111b)
#if 0
    if (uRow >= 8)
    {
        uRow = (uRow - 8) << 2 ;
        return ( m_adwMap[1] & (0xF << uRow) ) >> uRow ;
    }
    else
    {
        uRow = uRow << 2 ;
        return ( m_adwMap[0] & (0xF << uRow) ) >> uRow ;
    }
#else   // trust me -- it works!!!
    return (m_adwMap[uRow / 8] & (0xF << (4 * (uRow % 8)))) >> (4 * (uRow % 8)) ;
#endif // #if 0
}

void CRowIndexMap::SetRowIndex(UINT uLine, UINT8 uRow)
{
    DbgLog((LOG_TRACE, 5, TEXT("CRowIndexMap::SetRowIndex(%u, %u)"), uLine, uRow)) ;

    uRow-- ;  // it's just easier to deal with 0-based index
    
    if (uRow >= MAX_CAPTION_ROWS  ||
        uLine > MAX_CAPTION_LINES)
    {
        DbgLog((LOG_ERROR, 2, TEXT("Invalid row number (%u)/line (%u) for saving"), uRow, uLine)) ;
        ASSERT(FALSE) ;
        return ;
    }
    
    // Decide if we check the bits in 1st or 2nd DWORD (mask is 1111b)
#if 0
    if (uRow >= 8)
    {
        uRow = (uRow - 8) << 2 ;
        m_adwMap[1] &= ~(0xF << uRow) ;   // just to clear any existing bits there
        m_adwMap[1] |= (uLine << uRow) ;
    }
    else
    {
        uRow = uRow << 2 ;
        m_adwMap[0] &= ~(0xF << uRow) ;   // just to clear any existing bits there
        m_adwMap[0] |= (uLine << uRow) ;
    }
#else   // trust me -- it works!!!
    m_adwMap[uRow / 8] &= ~(0xF   << (4 * (uRow % 8))) ;  // clear any existing bits there
    m_adwMap[uRow / 8] |=  (uLine << (4 * (uRow % 8))) ;  // put new line number in there
#endif // #if 0
}


//
//  CCaptionBuffer: The base caption buffer class implementation
//

CCaptionBuffer::CCaptionBuffer(UINT8 uStyle    /* = AM_L21_CCSTYLE_None */,
                               UINT8 uMaxLines /* = MAX_CAPTION_LINES */)
{
    ClearBuffer() ;
    m_uMaxLines = uMaxLines ;
    m_uCaptionStyle = uStyle ;
}

CCaptionBuffer::CCaptionBuffer(/* const */ CCaptionBuffer &cb)
{
    for (int i = 0 ; i < cb.GetNumLines() ; i++)
        m_aCapLine[i] = cb.GetCaptionLine(i) ;
    m_RowIndex  = cb.m_RowIndex ;
    m_uNumLines = cb.m_uNumLines ;
    m_uMaxLines = cb.m_uMaxLines ;
    m_uCurrCol  = cb.m_uCurrCol ;
    m_uCurrLine = cb.m_uCurrLine ;
    m_uCaptionStyle = cb.m_uCaptionStyle ;
    m_uDirtyState = L21_CAPBUFFER_REDRAWALL ;  // cb.m_uDirtyState ;
}

void CCaptionBuffer::SetCurrCol(int uCurrCol)
{
    m_uCurrCol = uCurrCol & 0x3F ;
    if (m_uCurrCol > MAX_CAPTION_COLUMNS - 1)
        m_uCurrCol = MAX_CAPTION_COLUMNS - 1 ;
}

void CCaptionBuffer::SetCaptionLine(UINT uLine, const CCaptionLine& cl)
{
    if (uLine >= MAX_CAPTION_LINES)
        return ;
    m_aCapLine[uLine] = cl ;
    SetRedrawLine((UINT8)uLine, TRUE) ;
}

void CCaptionBuffer::ClearCaptionLine(UINT uLine)
{
    m_aCapLine[uLine].ClearLine() ;
    SetRedrawLine((UINT8)uLine, TRUE) ;
}

int CCaptionBuffer::IncCurrCol(UINT uNumChars)
{
    m_uCurrCol += (UINT8)uNumChars ;
    if (m_uCurrCol > MAX_CAPTION_COLUMNS - 1)
        m_uCurrCol = MAX_CAPTION_COLUMNS - 1 ;
    
    return m_uCurrCol ;
}

int CCaptionBuffer::DecCurrCol(UINT uNumChars)
{
    if (m_uCurrCol < uNumChars)
        m_uCurrCol  = 0 ;
    else
        m_uCurrCol -= (UINT8)uNumChars ;
    
    return m_uCurrCol ;
}

void CCaptionBuffer::ClearBuffer(void)
{
    for (int i = 0 ; i < MAX_CAPTION_LINES ; i++)
    {
        m_aCapLine[i].ClearLine() ;
        SetStartRow(i, 0) ;
    }
    m_RowIndex.ClearRowIndex() ; ;
    m_uNumLines = 0 ;
    m_uMaxLines = MAX_CAPTION_LINES ;
    m_uCurrCol  = 0 ;
    m_uCurrLine = 0 ;
    m_uDirtyState = L21_CAPBUFFER_REDRAWALL |   // draw everything
                    L21_CAPBUFFER_DIRTY ;       // buffer is dirty
}

void CCaptionBuffer::InitCaptionBuffer(void) 
{
    ClearBuffer() ;
}

int CCaptionBuffer::IncNumLines(int uLines)
{
    m_uNumLines += uLines & 0x7 ;
    // Roll-Up is supposed to allow 1 line more than the max for scrolling
    if (AM_L21_CCSTYLE_RollUp == m_uCaptionStyle)
    {
        if (m_uNumLines > m_uMaxLines+1)
            m_uNumLines = m_uMaxLines+1 ;
    }
    else  // non Roll-Up mode -- Pop-On or Paint-On
    {
        if (m_uNumLines > m_uMaxLines)  // What? Too many lines!!!
        {
            DbgLog((LOG_ERROR, 1, 
                TEXT("WARNING: How did %u lines get created with max of %u lines?"), 
                m_uNumLines, m_uMaxLines)) ;
            m_uNumLines = m_uMaxLines ;  // just to plug the hole!!!
        }
    }
    return m_uNumLines ;
}

int CCaptionBuffer::DecNumLines(int uLines)
{
    if (uLines > m_uNumLines)  // error!!
        return 0 ;
    m_uNumLines -= uLines & 0x7 ;
    return m_uNumLines ;
}

void CCaptionBuffer::RemoveLineFromBuffer(UINT8 uLine, BOOL bUpNextLine)
{
    DbgLog((LOG_TRACE, 5, TEXT("CRowIndexMap::RemoveLineFromBuffer(%u, %u)"), 
            uLine, bUpNextLine)) ;

    int iNumLines = GetNumLines() ;
    int iMaxLines = GetMaxLines() ;
    int iRow ;
    
    if (bUpNextLine)    // if next line should be move up (for Roll-up style)
    {
        // We go upto iNumLines-1 because iNumLines is the not-yet-included line
        for (int i = uLine ; i < iNumLines-1 ; i++)
        {
            iRow = GetStartRow(i) ;     // get the row posn of line i
            SetCaptionLine(i, GetCaptionLine(i+1)) ;  // copy line i+1 data to line i
            SetStartRow(i, iRow) ;  // put prev line i's row # as new line i's row #
        }
    
        // Clear the last line data and row index bits, ONLY IF it's already in
        iRow = GetStartRow(iNumLines-1) ;
        ClearCaptionLine(iNumLines-1) ;
        if (iNumLines <= iMaxLines)  // if the last line is already in
        {
            if (iRow > 0)  // if row # is valid, release it
                m_RowIndex.SetRowIndex(0, (UINT8)iRow) ;
            else           // otherwise something wrong
                ASSERT(FALSE) ; // so that we know
        }
        // Otherwise there is a not-yet-in line hanging, which doesn't have a 
        // row number given yet.  So no need to release that row.
    }
    else    // next line doesn't get moved up (for NON Roll-up style)
    {
        // Release the line-to-be-deleted's row by clearing the index bit
        if ((iRow = GetStartRow(uLine)) > 0)  // (check validity)
            m_RowIndex.SetRowIndex(0, (UINT8)iRow) ;
        else            // that would be weird
            ASSERT(FALSE) ; // so that we know

        // Here we stop at iNumLines-1, because we move all the existing lines to
        // make space for a new line that will start next.
        for (int i = uLine ; i < iNumLines-1 ; i++)
        {
            SetCaptionLine(i, GetCaptionLine(i+1)) ;  // copy line i+1 data to line i
            // Update index bitmap to new row i's start row (+1 because index 
            // bitmap nibble values are 1-based).
            m_RowIndex.SetRowIndex(i+1, (UINT8)GetStartRow(i)) ;
        }
    
        // Clear the last line's data
        ClearCaptionLine(iNumLines-1) ;
    }
    
    // A line is out of the buffer -- so buffer is dirty
    SetBufferDirty(TRUE) ;
    
    // Clear whole DIB section so that no leftover shows up
    SetRedrawAll(TRUE) ;
    
    DecNumLines(1) ;  // now we have 1 line less
    
    // We have removed a line from the buffer; so the current line also
    // needs to be updated to point to the proper line in the caption buffer.
    if (m_uCurrLine == uLine)
        if (uLine == m_uNumLines-1)
            m_uCurrLine-- ;
        else
            ;  // do nothing -- old next line will become new curr line
        else if (m_uCurrLine > uLine)   // if a line above was removed
            m_uCurrLine-- ;             // then move line index up
        else    // a line was deleted below current line
            ;   // do nothing -- doesn't matter at all
        if (m_uCurrLine < 0)  // in case we went too far up
            m_uCurrLine = 0 ; // come down to the ground!!!
}

void CCaptionBuffer::SetStartRow(UINT uLine, UINT uRow)
{
    int iRow = GetStartRow(uLine) ;         // get the currently set row number
    if (iRow == (int)uRow)  // if nothing changed...
        return ;            // ...no point re-doing it
    if (iRow > 0)                           // if it was already set then...
        m_RowIndex.SetRowIndex(0, (UINT8)iRow) ;   // ...clear the row index map bits
    m_aCapLine[uLine].SetStartRow(uRow) ;   // set new row value for the line
    // set row index bits only if specified row > 0; else it's just for clearing
    if (uRow > 0) {
        // use +1 for line # as row index map uses 1-based index for line #s
        m_RowIndex.SetRowIndex(uLine+1, (UINT8)uRow) ; // set index map bits for new row
    }
    else
        ASSERT(FALSE) ;
}

BOOL CCaptionBuffer::IsRedrawLine(UINT8 uLine)
{
    if (uLine >= m_uNumLines)
    {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid line number (%d) to get line redraw info"), uLine)) ;
        return FALSE ;
    }
    return (m_uDirtyState & (0x01 << (L21_CAPBUFFDIRTY_FLAGS + uLine))) ; 
}

void CCaptionBuffer::SetBufferDirty(BOOL bState)
{
    if (bState)
        m_uDirtyState |= (UINT8)L21_CAPBUFFER_DIRTY ;
    else
        m_uDirtyState &= (UINT8)~L21_CAPBUFFER_DIRTY ;
}

void CCaptionBuffer::SetRedrawAll(BOOL bState)
{
    if (bState)
        m_uDirtyState |= (UINT8)L21_CAPBUFFER_REDRAWALL ;
    else
        m_uDirtyState &= (UINT8)~L21_CAPBUFFER_REDRAWALL ;
}

void CCaptionBuffer::SetRedrawLine(UINT8 uLine, BOOL bState)
{
    if (uLine >= m_uNumLines)
    {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid line number (%d) to set line redraw info"), uLine)) ;
        return ;
    }
    if (bState)
        m_uDirtyState |= (UINT8)(0x01 << (L21_CAPBUFFDIRTY_FLAGS + uLine)) ;
    else
        m_uDirtyState &= (UINT8)~(0x01 << (L21_CAPBUFFDIRTY_FLAGS + uLine)) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\inftee\inftee.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1997  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef __INFTEE__
#define __INFTEE__

extern const AMOVIESETUP_FILTER sudInfTee;


class CTee;
class CTeeOutputPin;

// class for the Tee filter's Input pin

class CTeeInputPin : public CBaseInputPin
{
    friend class CTeeOutputPin;
    CTee *m_pTee;                  // Main filter object
    BOOL m_bInsideCheckMediaType;  // Re-entrancy control

public:

    // Constructor and destructor
    CTeeInputPin(TCHAR *pObjName,
                 CTee *pTee,
                 HRESULT *phr,
                 LPCWSTR pPinName);

#ifdef DEBUG
    ~CTeeInputPin();
#endif

    // Used to check the input pin connection
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);
    HRESULT BreakConnect();

    // Reconnect outputs if necessary at end of completion
    virtual HRESULT CompleteConnect(IPin *pReceivePin);

    STDMETHODIMP NotifyAllocator(IMemAllocator *pAllocator, BOOL bReadOnly);

    // Pass through calls downstream
    STDMETHODIMP EndOfStream();
    STDMETHODIMP BeginFlush();
    STDMETHODIMP EndFlush();
    STDMETHODIMP NewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate);

    // Handles the next block of data from the stream
    STDMETHODIMP Receive(IMediaSample *pSample);

};


// Class for the Tee filter's Output pins.

class CTeeOutputPin : public CBaseOutputPin
{
    friend class CTeeInputPin;
    friend class CTee;

    CTee *m_pTee;                  // Main filter object pointer
    IUnknown    *m_pPosition;      // Pass seek calls upstream
    BOOL m_bHoldsSeek;             // Is this the one seekable stream
    COutputQueue *m_pOutputQueue;  // Streams data to the peer pin
    BOOL m_bInsideCheckMediaType;  // Re-entrancy control
    LONG m_cOurRef;                // We maintain reference counting

public:

    // Constructor and destructor

    CTeeOutputPin(TCHAR *pObjName,
                   CTee *pTee,
                   HRESULT *phr,
                   LPCWSTR pPinName,
                   INT PinNumber);

#ifdef DEBUG
    ~CTeeOutputPin();
#endif

    // Override to expose IMediaPosition
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppvoid);

    // Override since the life time of pins and filters are not the same
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

    // Override to enumerate media types
    STDMETHODIMP EnumMediaTypes(IEnumMediaTypes **ppEnum);

    // Check that we can support an output type
    HRESULT CheckMediaType(const CMediaType *pmt);
    HRESULT SetMediaType(const CMediaType *pmt);

    // Negotiation to use our input pins allocator
    HRESULT DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc);
    HRESULT DecideBufferSize(IMemAllocator *pMemAllocator,
                              ALLOCATOR_PROPERTIES * ppropInputRequest);

    // Used to create output queue objects
    HRESULT Active();
    HRESULT Inactive();

    // Overriden to create and destroy output pins
    HRESULT CompleteConnect(IPin *pReceivePin);

    // Overriden to pass data to the output queues
    HRESULT Deliver(IMediaSample *pMediaSample);
    HRESULT DeliverEndOfStream();
    HRESULT DeliverBeginFlush();
    HRESULT DeliverEndFlush();
    HRESULT DeliverNewSegment(
                    REFERENCE_TIME tStart,
                    REFERENCE_TIME tStop,
                    double dRate);


    // Overriden to handle quality messages
    STDMETHODIMP Notify(IBaseFilter *pSender, Quality q);
};


// Class for the Tee filter

class CTee: public CCritSec, public CBaseFilter
{
    // Let the pins access our internal state
    friend class CTeeInputPin;
    friend class CTeeOutputPin;
    typedef CGenericList <CTeeOutputPin> COutputList;

    // Declare an input pin.
    CTeeInputPin m_Input;

    INT m_NumOutputPins;            // Current output pin count
    COutputList m_OutputPinsList;   // List of the output pins
    INT m_NextOutputPinNumber;      // Increases monotonically.
    LONG m_lCanSeek;                // Seekable output pin
    IMemAllocator *m_pAllocator;    // Allocator from our input pin

public:

    CTee(TCHAR *pName,LPUNKNOWN pUnk,HRESULT *hr);
    ~CTee();

    CBasePin *GetPin(int n);
    int GetPinCount();

    // Function needed for the class factory
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);

    // Send EndOfStream if no input connection
    STDMETHODIMP Run(REFERENCE_TIME tStart);
    STDMETHODIMP Pause();
    STDMETHODIMP Stop();

protected:

    // The following manage the list of output pins

    void InitOutputPinsList();
    CTeeOutputPin *GetPinNFromList(int n);
    CTeeOutputPin *CreateNextOutputPin(CTee *pTee);
    void DeleteOutputPin(CTeeOutputPin *pPin);
    int GetNumFreePins();
};

#endif // __INFTEE__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\inftee\inftee.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include <initguid.h>
#include <inftee.h>
#include <tchar.h>
#include <stdio.h>

//
//
// What this sample illustrates
//
// A pass through filter splits a data stream into many output channels
//
// Summary
//
// This is a sample ActiveMovie pass through filter. We have a single input
// pin and can have many output pins. We start with one output pin and each
// time we connect an output pin we spawn another, although we could keep
// doing this ad infinitum we have a top level maximum of INFTEE_MAX_PINS.
// Any data samples our input pin receives will be sent down each output
// pin in turn. Each output pin has a separate thread if necessary (see
// the output queue class in the SDK) to avoid delivery blocking our thread
//
// Demonstration instructions
//
// Start GRAPHEDT available in the ActiveMovie SDK tools. Drag and drop any
// MPEG, AVI or MOV file into the tool and it will be rendered. Then go to
// the filters in the graph and find the filter (box) titled "Video Renderer"
// Then click on the box and hit DELETE. After that go to the Graph menu and
// select "Insert Filters", from the dialog box find and select the "Infinite
// Tee Filter" and then dismiss the dialog. Back in the graph layout find the
// output pin of the filter that was connected to the input of the video
// renderer you just deleted, right click and select "Render". You should
// see it being connected to the input pin of the filter you just inserted
//
// The infinite tee filter will have one output pin connected and will have
// spawned another, right click on this and select Render. A new renderer
// will pop up fo the stream. Do this once or twice more and then click on
// the Pause and Run on the GRAPHEDT frame and you will see the video...
//      .. many times over in different windows
//
// Files
//
// inftee.cpp           Main implementation of the infinite tee
// inftee.def           What APIs the DLL will import and export
// inftee.h             Class definition of the infinite tee
// inftee.rc            Not much, just our version information
// inftee.reg           What goes in the registry to make us work
// makefile             How to build it...
//
//
// Base classes used
//
// CBaseInputPin        Basic IMemInputPin based input pin
// CBaseOutputPin       Used for basic connection stuff
// CBaseFilter          Well we need a filter don't we
// CCritSec             Controls access to output pin list
// COutputQueue         Delivers data on a separate thread
//
//

#define INFTEE_MAX_PINS 1000

// Using this pointer in constructor
#pragma warning(disable:4355)

// Setup data

const AMOVIESETUP_MEDIATYPE sudPinTypes =
{
    &MEDIATYPE_NULL,         // Major CLSID
    &MEDIASUBTYPE_NULL       // Minor type
};

const AMOVIESETUP_PIN psudPins[] =
{
    { L"Input",             // Pin's string name
      FALSE,                // Is it rendered
      FALSE,                // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Output",            // Connects to pin
      1,                    // Number of types
      &sudPinTypes },       // Pin information
    { L"Output",            // Pin's string name
      FALSE,                // Is it rendered
      TRUE,                 // Is it an output
      FALSE,                // Allowed none
      FALSE,                // Allowed many
      &CLSID_NULL,          // Connects to filter
      L"Input",             // Connects to pin
      1,                    // Number of types
      &sudPinTypes }        // Pin information
};

const AMOVIESETUP_FILTER sudInfTee =
{
    &CLSID_InfTee,              // CLSID of filter
    L"Infinite Pin Tee Filter", // Filter's name
    MERIT_DO_NOT_USE,           // Filter merit
    2,                          // Number of pins
    psudPins                    // Pin information
};

#ifdef FILTER_DLL

CFactoryTemplate g_Templates [1] = {
    { L"Infinite Pin Tee"
    , &CLSID_InfTee
    , CTee::CreateInstance
    , NULL
    , &sudInfTee }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

//
// DllRegisterServer
//
STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2( TRUE );
}


//
// DllUnregisterServer
//
STDAPI
DllUnregisterServer()
{
    return AMovieDllRegisterServer2( FALSE );
}

#endif


//
// CreateInstance
//
// Creator function for the class ID
//
CUnknown * WINAPI CTee::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return new CTee(NAME("Infinite Tee Filter"), pUnk, phr);
}


//
// Constructor
//
CTee::CTee(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr) :
    m_OutputPinsList(NAME("Tee Output Pins list")),
    m_lCanSeek(TRUE),
    m_pAllocator(NULL),
    m_NumOutputPins(0),
    m_NextOutputPinNumber(0),
    m_Input(NAME("Input Pin"), this, phr, L"Input"),
    CBaseFilter(NAME("Tee filter"), pUnk, this, CLSID_InfTee)
{
    ASSERT(phr);

    // Create a single output pin at this time
    InitOutputPinsList();

    CTeeOutputPin *pOutputPin = CreateNextOutputPin(this);

    if (pOutputPin != NULL )
    {
        m_NumOutputPins++;
        m_OutputPinsList.AddTail(pOutputPin);
    }
}


//
// Destructor
//
CTee::~CTee()
{
    InitOutputPinsList();
}


//
// GetPinCount
//
int CTee::GetPinCount()
{
    return (1 + m_NumOutputPins);
}


//
// GetPin
//
CBasePin *CTee::GetPin(int n)
{
    if (n < 0)
        return NULL ;

    // Pin zero is the one and only input pin
    if (n == 0)
        return &m_Input;

    // return the output pin at position(n - 1) (zero based)
    return GetPinNFromList(n - 1);
}


//
// InitOutputPinsList
//
void CTee::InitOutputPinsList()
{
    POSITION pos = m_OutputPinsList.GetHeadPosition();
    while(pos)
    {
        CTeeOutputPin *pOutputPin = m_OutputPinsList.GetNext(pos);
        ASSERT(pOutputPin->m_pOutputQueue == NULL);
        pOutputPin->Release();
    }
    m_NumOutputPins = 0;
    m_OutputPinsList.RemoveAll();

} // InitOutputPinsList


//
// CreateNextOutputPin
//
CTeeOutputPin *CTee::CreateNextOutputPin(CTee *pTee)
{
    WCHAR szbuf[20];             // Temporary scratch buffer
    m_NextOutputPinNumber++;     // Next number to use for pin
    HRESULT hr = NOERROR;

    wsprintfW(szbuf, L"Output%d", m_NextOutputPinNumber);

    CTeeOutputPin *pPin = new CTeeOutputPin(NAME("Tee Output"), pTee,
					    &hr, szbuf,
					    m_NextOutputPinNumber);

    if (FAILED(hr) || pPin == NULL) {
        delete pPin;
        return NULL;
    }

    pPin->AddRef();
    return pPin;

} // CreateNextOutputPin


//
// DeleteOutputPin
//
void CTee::DeleteOutputPin(CTeeOutputPin *pPin)
{
    POSITION pos = m_OutputPinsList.GetHeadPosition();
    while(pos) {
        POSITION posold = pos;         // Remember this position
        CTeeOutputPin *pOutputPin = m_OutputPinsList.GetNext(pos);
        if (pOutputPin == pPin) {
            // If this pin holds the seek interface release it
            if (pPin->m_bHoldsSeek) {
                InterlockedExchange(&m_lCanSeek, FALSE);
                pPin->m_bHoldsSeek = FALSE;
                pPin->m_pPosition->Release();
            }

            m_OutputPinsList.Remove(posold);
            ASSERT(pOutputPin->m_pOutputQueue == NULL);
            delete pPin;
            m_NumOutputPins--;
	    IncrementPinVersion();
            break;
        }
    }

} // DeleteOutputPin


//
// GetNumFreePins
//
int CTee::GetNumFreePins()
{
    int n = 0;
    POSITION pos = m_OutputPinsList.GetHeadPosition();
    while(pos) {
        CTeeOutputPin *pOutputPin = m_OutputPinsList.GetNext(pos);
        if (pOutputPin->m_Connected == NULL)
            n++;
    }
    return n;

} // GetNumFreePins


//
// GetPinNFromList
//
CTeeOutputPin *CTee::GetPinNFromList(int n)
{
    // Validate the position being asked for
    if (n >= m_NumOutputPins)
        return NULL;

    // Get the head of the list
    POSITION pos = m_OutputPinsList.GetHeadPosition();

    n++;       // Make the number 1 based

    CTeeOutputPin *pOutputPin;
    while(n) {
        pOutputPin = m_OutputPinsList.GetNext(pos);
        n--;
    }
    return pOutputPin;

} // GetPinNFromList


//
// Stop
//
// Overriden to handle no input connections
//
STDMETHODIMP CTee::Stop()
{
    CBaseFilter::Stop();
    m_State = State_Stopped;
    return NOERROR;
}


//
// Pause
//
// Overriden to handle no input connections
//
STDMETHODIMP CTee::Pause()
{
    CAutoLock cObjectLock(m_pLock);
    HRESULT hr = CBaseFilter::Pause();
    if (m_Input.IsConnected() == FALSE) {
        m_Input.EndOfStream();
    }
    return hr;
}


//
// Run
//
// Overriden to handle no input connections
//
STDMETHODIMP CTee::Run(REFERENCE_TIME tStart)
{
    CAutoLock cObjectLock(m_pLock);
    HRESULT hr = CBaseFilter::Run(tStart);
    if (m_Input.IsConnected() == FALSE) {
        m_Input.EndOfStream();
    }
    return hr;
}

//
// CTeeInputPin constructor
//
CTeeInputPin::CTeeInputPin(TCHAR *pName,
                           CTee *pTee,
                           HRESULT *phr,
                           LPCWSTR pPinName) :
    CBaseInputPin(pName, pTee, pTee, phr, pPinName),
    m_pTee(pTee),
    m_bInsideCheckMediaType(FALSE)
{
    ASSERT(pTee);
}


#ifdef DEBUG
//
// CTeeInputPin destructor
//
CTeeInputPin::~CTeeInputPin()
{
    DbgLog((LOG_TRACE,2,TEXT("CTeeInputPin destructor")));
    ASSERT(m_pTee->m_pAllocator == NULL);
}
#endif


#ifdef DEBUG

//
// DisplayMediaType -- (DEBUG ONLY)
//
void DisplayMediaType(TCHAR *pDescription,const CMediaType *pmt)
{

    // Dump the GUID types and a short description

    DbgLog((LOG_TRACE,2,TEXT("")));
    DbgLog((LOG_TRACE,2,TEXT("%s"),pDescription));
    DbgLog((LOG_TRACE,2,TEXT("")));
    DbgLog((LOG_TRACE,2,TEXT("Media Type Description")));
    DbgLog((LOG_TRACE,2,TEXT("Major type %s"),GuidNames[*pmt->Type()]));
    DbgLog((LOG_TRACE,2,TEXT("Subtype %s"),GuidNames[*pmt->Subtype()]));
    DbgLog((LOG_TRACE,2,TEXT("Subtype description %s"),GetSubtypeName(pmt->Subtype())));
    DbgLog((LOG_TRACE,2,TEXT("Format size %d"),pmt->cbFormat));

    // Dump the generic media types */

    DbgLog((LOG_TRACE,2,TEXT("Fixed size sample %d"),pmt->IsFixedSize()));
    DbgLog((LOG_TRACE,2,TEXT("Temporal compression %d"),pmt->IsTemporalCompressed()));
    DbgLog((LOG_TRACE,2,TEXT("Sample size %d"),pmt->GetSampleSize()));


} // DisplayMediaType

#endif

//
// CheckMediaType
//
HRESULT CTeeInputPin::CheckMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);

    // If we are already inside checkmedia type for this pin, return NOERROR
    // It is possble to hookup two of the tee filters and some other filter
    // like the video effects sample to get into this situation. If we don't
    // detect this situation, we will carry on looping till we blow the stack

    if (m_bInsideCheckMediaType == TRUE)
        return NOERROR;

    m_bInsideCheckMediaType = TRUE;
    HRESULT hr = NOERROR;

#ifdef DEBUG
    // Display the type of the media for debugging perposes
    DisplayMediaType(TEXT("Input Pin Checking"), pmt);
#endif

    // The media types that we can support are entirely dependent on the
    // downstream connections. If we have downstream connections, we should
    // check with them - walk through the list calling each output pin

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();

    while(n) {
        CTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            if (pOutputPin->m_Connected != NULL) {
                // The pin is connected, check its peer
                hr = pOutputPin->m_Connected->QueryAccept(pmt);
                if (hr != NOERROR) {
                    m_bInsideCheckMediaType = FALSE;
                    return VFW_E_TYPE_NOT_ACCEPTED;
                }
            }
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }

    // Either all the downstream pins have accepted or there are none.
    m_bInsideCheckMediaType = FALSE;
    return NOERROR;

} // CheckMediaType


//
// SetMediaType
//
HRESULT CTeeInputPin::SetMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);
    HRESULT hr = NOERROR;

    // Make sure that the base class likes it
    hr = CBaseInputPin::SetMediaType(pmt);
    if (FAILED(hr))
        return hr;

    ASSERT(m_Connected != NULL);
    return NOERROR;

} // SetMediaType


//
// BreakConnect
//
HRESULT CTeeInputPin::BreakConnect()
{
    // Release any allocator that we are holding
    if (m_pTee->m_pAllocator)
    {
        m_pTee->m_pAllocator->Release();
        m_pTee->m_pAllocator = NULL;
    }
    return NOERROR;

} // BreakConnect


//
// NotifyAllocator
//
STDMETHODIMP
CTeeInputPin::NotifyAllocator(IMemAllocator *pAllocator, BOOL bReadOnly)
{
    CAutoLock lock_it(m_pLock);
    if (pAllocator == NULL)
        return E_FAIL;

    // Free the old allocator if any
    if (m_pTee->m_pAllocator)
        m_pTee->m_pAllocator->Release();

    // Store away the new allocator
    pAllocator->AddRef();
    m_pTee->m_pAllocator = pAllocator;

    // Notify the base class about the allocator
    return CBaseInputPin::NotifyAllocator(pAllocator,bReadOnly);

} // NotifyAllocator


//
// EndOfStream
//
HRESULT CTeeInputPin::EndOfStream()
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_pTee->m_NumOutputPins);
    HRESULT hr = NOERROR;

    // Walk through the output pins list, sending the message downstream

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();
    while(n) {
        CTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            hr = pOutputPin->DeliverEndOfStream();
            if (FAILED(hr))
                return hr;
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return(NOERROR);

} // EndOfStream


//
// BeginFlush
//
HRESULT CTeeInputPin::BeginFlush()
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_pTee->m_NumOutputPins);
    HRESULT hr = NOERROR;

    // Walk through the output pins list, sending the message downstream

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();
    while(n) {
        CTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            hr = pOutputPin->DeliverBeginFlush();
            if (FAILED(hr))
                return hr;
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return CBaseInputPin::BeginFlush();

} // BeginFlush


//
// EndFlush
//
HRESULT CTeeInputPin::EndFlush()
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_pTee->m_NumOutputPins);
    HRESULT hr = NOERROR;

    // Walk through the output pins list, sending the message downstream

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();
    while(n) {
        CTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            hr = pOutputPin->DeliverEndFlush();
            if (FAILED(hr))
                return hr;
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return CBaseInputPin::EndFlush();

} // EndFlush

//
// NewSegment
//

HRESULT CTeeInputPin::NewSegment(REFERENCE_TIME tStart,
                                 REFERENCE_TIME tStop,
                                 double dRate)
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_pTee->m_NumOutputPins);
    HRESULT hr = NOERROR;

    // Walk through the output pins list, sending the message downstream

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();
    while(n) {
        CTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            hr = pOutputPin->DeliverNewSegment(tStart, tStop, dRate);
            if (FAILED(hr))
                return hr;
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return CBaseInputPin::NewSegment(tStart, tStop, dRate);

} // NewSegment


//
// Receive
//
HRESULT CTeeInputPin::Receive(IMediaSample *pSample)
{
    CAutoLock lock_it(m_pLock);

    // Check that all is well with the base class
    HRESULT hr = NOERROR;
    hr = CBaseInputPin::Receive(pSample);
    if (hr != NOERROR)
        return hr;

    // Walk through the output pins list, delivering to each in turn

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();
    while(n) {
        CTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            hr = pOutputPin->Deliver(pSample);
            if (hr != NOERROR)
                return hr;
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return NOERROR;

} // Receive


//
// Completed a connection to a pin
//
HRESULT CTeeInputPin::CompleteConnect(IPin *pReceivePin)
{
    HRESULT hr = CBaseInputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr)) {
        return hr;
    }

    // Force any output pins to use our type

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();

    while(n) {
        CTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL) {
            // Check with downstream pin
            if (pOutputPin->m_Connected != NULL) {
                if (m_mt != pOutputPin->m_mt)
                    m_pTee->ReconnectPin(pOutputPin, &m_mt);
            }
        } else {
            // We should have as many pins as the count says we have
            ASSERT(FALSE);
        }
        n--;
    }
    return S_OK;
}


//
// CTeeOutputPin constructor
//
CTeeOutputPin::CTeeOutputPin(TCHAR *pName,
                             CTee *pTee,
                             HRESULT *phr,
                             LPCWSTR pPinName,
                             int PinNumber) :
    CBaseOutputPin(pName, pTee, pTee, phr, pPinName) ,
    m_pOutputQueue(NULL),
    m_bHoldsSeek(FALSE),
    m_pPosition(NULL),
    m_pTee(pTee),
    m_cOurRef(0),
    m_bInsideCheckMediaType(FALSE)
{
    ASSERT(pTee);
}

#ifdef DEBUG
//
// CTeeOutputPin destructor
//
CTeeOutputPin::~CTeeOutputPin()
{
    ASSERT(m_pOutputQueue == NULL);
}
#endif


//
// NonDelegatingQueryInterface
//
// This function is overwritten to expose IMediaPosition and IMediaSelection
// Note that only one output stream can be allowed to expose this to avoid
// conflicts, the other pins will just return E_NOINTERFACE and therefore
// appear as non seekable streams. We have a LONG value that if exchanged to
// produce a TRUE means that we have the honor. If it exchanges to FALSE then
// someone is already in. If we do get it and error occurs then we reset it
// to TRUE so someone else can get it.
//
STDMETHODIMP
CTeeOutputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    CheckPointer(ppv,E_POINTER);
    ASSERT(ppv);
    *ppv = NULL;
    HRESULT hr = NOERROR;

    // See what interface the caller is interested in.
    if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking) {
        if (m_pPosition) {
            if (m_bHoldsSeek == FALSE)
                return E_NOINTERFACE;
            return m_pPosition->QueryInterface(riid, ppv);
        }
    } else
        return CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);

    CAutoLock lock_it(m_pLock);
    ASSERT(m_pPosition == NULL);
    IUnknown *pMediaPosition = NULL;

    // Try to create a seeking implementation
    if (InterlockedExchange(&m_pTee->m_lCanSeek, FALSE) == FALSE)
        return E_NOINTERFACE;

    // Create implementation of this dynamically as sometimes we may never
    // try and seek. The helper object implements IMediaPosition and also
    // the IMediaSelection control interface and simply takes the calls
    // normally from the downstream filter and passes them upstream


    hr = CreatePosPassThru(
                   GetOwner(),
                   FALSE,
                   (IPin *)&m_pTee->m_Input,
                   &pMediaPosition);

    if (pMediaPosition == NULL) {
        InterlockedExchange(&m_pTee->m_lCanSeek, TRUE);
        return E_OUTOFMEMORY;
    }

    if (FAILED(hr)) {
        InterlockedExchange(&m_pTee->m_lCanSeek, TRUE);
        pMediaPosition->Release ();
        return hr;
    }

    m_pPosition = pMediaPosition;
    m_bHoldsSeek = TRUE;
    return NonDelegatingQueryInterface(riid, ppv);

} // NonDelegatingQueryInterface


//
// NonDelegatingAddRef
//
// We need override this method so that we can do proper reference counting
// on our output pin. The base class CBasePin does not do any reference
// counting on the pin in RETAIL.
//
// Please refer to the comments for the NonDelegatingRelease method for more
// info on why we need to do this.
//
STDMETHODIMP_(ULONG) CTeeOutputPin::NonDelegatingAddRef()
{
    CAutoLock lock_it(m_pLock);

#ifdef DEBUG
    // Update the debug only variable maintained by the base class
    m_cRef++;
    ASSERT(m_cRef > 0);
#endif

    // Now update our reference count
    m_cOurRef++;
    ASSERT(m_cOurRef > 0);
    return m_cOurRef;

} // NonDelegatingAddRef


//
// NonDelegatingRelease
//
// CTeeOutputPin overrides this class so that we can take the pin out of our
// output pins list and delete it when its reference count drops to 1 and there
// is atleast two free pins.
//
// Note that CreateNextOutputPin holds a reference count on the pin so that
// when the count drops to 1, we know that no one else has the pin.
//
// Moreover, the pin that we are about to delete must be a free pin(or else
// the reference would not have dropped to 1, and we must have atleast one
// other free pin(as the filter always wants to have one more free pin)
//
// Also, since CBasePin::NonDelegatingAddRef passes the call to the owning
// filter, we will have to call Release on the owning filter as well.
//
// Also, note that we maintain our own reference count m_cOurRef as the m_cRef
// variable maintained by CBasePin is debug only.
//
STDMETHODIMP_(ULONG) CTeeOutputPin::NonDelegatingRelease()
{
    CAutoLock lock_it(m_pLock);

#ifdef DEBUG
    // Update the debug only variable in CBasePin
    m_cRef--;
    ASSERT(m_cRef >= 0);
#endif

    // Now update our reference count
    m_cOurRef--;
    ASSERT(m_cOurRef >= 0);

    // if the reference count on the object has gone to one, remove
    // the pin from our output pins list and physically delete it
    // provided there are atealst two free pins in the list(including
    // this one)

    // Also, when the ref count drops to 0, it really means that our
    // filter that is holding one ref count has released it so we
    // should delete the pin as well.

    if (m_cOurRef <= 1) {
        int n = 2;                     // default forces pin deletion
        if (m_cOurRef == 1) {
            // Walk the list of pins, looking for count of free pins
            n = m_pTee->GetNumFreePins();
        }

        // If there are two free pins, delete this one.
        // NOTE: normall
        if (n >= 2 ) {
            m_cOurRef = 0;
#ifdef DEBUG
            m_cRef = 0;
#endif
            m_pTee->DeleteOutputPin(this);
            return(ULONG) 0;
        }
    }
    return(ULONG) m_cOurRef;

} // NonDelegatingRelease


//
// DecideBufferSize
//
// This has to be present to override the PURE virtual class base function
//
HRESULT CTeeOutputPin::DecideBufferSize(IMemAllocator *pMemAllocator,
                                        ALLOCATOR_PROPERTIES * ppropInputRequest)
{
    return NOERROR;

} // DecideBufferSize


//
// DecideAllocator
//
HRESULT CTeeOutputPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    ASSERT(m_pTee->m_pAllocator != NULL);
    *ppAlloc = NULL;

    // Tell the pin about our allocator, set by the input pin.
    HRESULT hr = NOERROR;
    hr = pPin->NotifyAllocator(m_pTee->m_pAllocator,TRUE);
    if (FAILED(hr))
        return hr;

    // Return the allocator
    *ppAlloc = m_pTee->m_pAllocator;
    m_pTee->m_pAllocator->AddRef();
    return NOERROR;

} // DecideAllocator


//
// CheckMediaType
//
HRESULT CTeeOutputPin::CheckMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);

    // If we are already inside checkmedia type for this pin, return NOERROR
    // It is possble to hookup two of the tee filters and some other filter
    // like the video effects sample to get into this situation. If we
    // do not detect this, we will loop till we blow the stack

    if (m_bInsideCheckMediaType == TRUE)
        return NOERROR;

    m_bInsideCheckMediaType = TRUE;
    HRESULT hr = NOERROR;

#ifdef DEBUG
    // Display the type of the media for debugging purposes
    DisplayMediaType(TEXT("Output Pin Checking"), pmt);
#endif

    // The input needs to have been conneced first
    if (m_pTee->m_Input.m_Connected == NULL) {
        m_bInsideCheckMediaType = FALSE;
        return VFW_E_NOT_CONNECTED;
    }

    // Make sure that our input pin peer is happy with this
    hr = m_pTee->m_Input.m_Connected->QueryAccept(pmt);
    if (hr != NOERROR) {
        m_bInsideCheckMediaType = FALSE;
        return VFW_E_TYPE_NOT_ACCEPTED;
    }

    // Check the format with the other outpin pins

    int n = m_pTee->m_NumOutputPins;
    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();

    while(n) {
        CTeeOutputPin *pOutputPin = m_pTee->m_OutputPinsList.GetNext(pos);
        if (pOutputPin != NULL && pOutputPin != this) {
            if (pOutputPin->m_Connected != NULL) {
                // The pin is connected, check its peer
                hr = pOutputPin->m_Connected->QueryAccept(pmt);
                if (hr != NOERROR) {
                    m_bInsideCheckMediaType = FALSE;
                    return VFW_E_TYPE_NOT_ACCEPTED;
                }
            }
        }
        n--;
    }
    m_bInsideCheckMediaType = FALSE;
    return NOERROR;

} // CheckMediaType


//
// EnumMediaTypes
//
STDMETHODIMP CTeeOutputPin::EnumMediaTypes(IEnumMediaTypes **ppEnum)
{
    CAutoLock lock_it(m_pLock);
    ASSERT(ppEnum);

    // Make sure that we are connected
    if (m_pTee->m_Input.m_Connected == NULL)
        return VFW_E_NOT_CONNECTED;

    // We will simply return the enumerator of our input pin's peer
    return m_pTee->m_Input.m_Connected->EnumMediaTypes(ppEnum);

} // EnumMediaTypes


//
// SetMediaType
//
HRESULT CTeeOutputPin::SetMediaType(const CMediaType *pmt)
{
    CAutoLock lock_it(m_pLock);

#ifdef DEBUG
    // Display the format of the media for debugging purposes
    DisplayMediaType(TEXT("Output pin type agreed"), pmt);
#endif

    // Make sure that we have an input connected
    if (m_pTee->m_Input.m_Connected == NULL)
        return VFW_E_NOT_CONNECTED;

    // Make sure that the base class likes it
    HRESULT hr = NOERROR;
    hr = CBaseOutputPin::SetMediaType(pmt);
    if (FAILED(hr))
        return hr;

    return NOERROR;

} // SetMediaType


//
// CompleteConnect
//
HRESULT CTeeOutputPin::CompleteConnect(IPin *pReceivePin)
{
    CAutoLock lock_it(m_pLock);
    ASSERT(m_Connected == pReceivePin);
    HRESULT hr = NOERROR;

    hr = CBaseOutputPin::CompleteConnect(pReceivePin);
    if (FAILED(hr))
        return hr;

    // If the type is not the same as that stored for the input
    // pin then force the input pins peer to be reconnected

    if (m_mt != m_pTee->m_Input.m_mt)
    {
        hr = m_pTee->ReconnectPin(m_pTee->m_Input.m_Connected, &m_mt);
        if(FAILED(hr)) {
            return hr;
        }
    }


    // Since this pin has been connected up, create another output pin. We
    // will do this only if there are no unconnected pins on us. However
    // CompleteConnect will get called for the same pin during reconnection

    int n = m_pTee->GetNumFreePins();
    ASSERT(n <= 1);
    if (n == 1 || m_pTee->m_NumOutputPins == INFTEE_MAX_PINS)
        return NOERROR;

    // No unconnected pins left so spawn a new one

    CTeeOutputPin *pOutputPin = m_pTee->CreateNextOutputPin(m_pTee);
    if (pOutputPin != NULL )
    {
        m_pTee->m_NumOutputPins++;
        m_pTee->m_OutputPinsList.AddTail(pOutputPin);
	m_pTee->IncrementPinVersion();
    }

    // At this point we should be able to send some
    // notification that we have sprung a new pin

    return NOERROR;

} // CompleteConnect


//
// Active
//
// This is called when we start running or go paused. We create the
// output queue object to send data to our associated peer pin
//
HRESULT CTeeOutputPin::Active()
{
    CAutoLock lock_it(m_pLock);
    HRESULT hr = NOERROR;

    // Make sure that the pin is connected
    if (m_Connected == NULL)
        return NOERROR;

    // Create the output queue if we have to
    if (m_pOutputQueue == NULL)
    {
        m_pOutputQueue = new COutputQueue(m_Connected, &hr, TRUE, FALSE);
        if (m_pOutputQueue == NULL)
            return E_OUTOFMEMORY;

        // Make sure that the constructor did not return any error
        if (FAILED(hr))
        {
            delete m_pOutputQueue;
            m_pOutputQueue = NULL;
            return hr;
        }
    }

    // Pass the call on to the base class
    CBaseOutputPin::Active();
    return NOERROR;

} // Active


//
// Inactive
//
// This is called when we stop streaming
// We delete the output queue at this time
//
HRESULT CTeeOutputPin::Inactive()
{
    CAutoLock lock_it(m_pLock);

    // Delete the output queus associated with the pin.
    if (m_pOutputQueue)
    {
        delete m_pOutputQueue;
        m_pOutputQueue = NULL;
    }

    CBaseOutputPin::Inactive();
    return NOERROR;

} // Inactive


//
// Deliver
//
HRESULT CTeeOutputPin::Deliver(IMediaSample *pMediaSample)
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    pMediaSample->AddRef();
    return m_pOutputQueue->Receive(pMediaSample);

} // Deliver


//
// DeliverEndOfStream
//
HRESULT CTeeOutputPin::DeliverEndOfStream()
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->EOS();
    return NOERROR;

} // DeliverEndOfStream


//
// DeliverBeginFlush
//
HRESULT CTeeOutputPin::DeliverBeginFlush()
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->BeginFlush();
    return NOERROR;

} // DeliverBeginFlush


//
// DeliverEndFlush
//
HRESULT CTeeOutputPin::DeliverEndFlush()
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->EndFlush();
    return NOERROR;

} // DeliverEndFlish

//
// DeliverNewSegment
//
HRESULT CTeeOutputPin::DeliverNewSegment(REFERENCE_TIME tStart,
                                         REFERENCE_TIME tStop,
                                         double dRate)
{
    // Make sure that we have an output queue
    if (m_pOutputQueue == NULL)
        return NOERROR;

    m_pOutputQueue->NewSegment(tStart, tStop, dRate);
    return NOERROR;

} // DeliverNewSegment


//
// Notify
//
STDMETHODIMP CTeeOutputPin::Notify(IBaseFilter *pSender, Quality q)
{
    // We pass the message on, which means that we find the quality sink
    // for our input pin and send it there

    POSITION pos = m_pTee->m_OutputPinsList.GetHeadPosition();
    CTeeOutputPin *pFirstOutput = m_pTee->m_OutputPinsList.GetNext(pos);

    if (this == pFirstOutput) {
	if (m_pTee->m_Input.m_pQSink!=NULL) {
	    return m_pTee->m_Input.m_pQSink->Notify(m_pTee, q);
	} else {

	    // No sink set, so pass it upstream
	    HRESULT hr;
	    IQualityControl * pIQC;

	    hr = VFW_E_NOT_FOUND;
	    if (m_pTee->m_Input.m_Connected) {
		m_pTee->m_Input.m_Connected->QueryInterface(IID_IQualityControl,(void**)&pIQC);

		if (pIQC!=NULL) {
		    hr = pIQC->Notify(m_pTee, q);
		    pIQC->Release();
		}
	    }
	    return hr;
	}
    }

    // Quality management is too hard to do
    return NOERROR;

} // Notify
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\lin21dec\l21dbase.h ===
// Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
//
//  L21DBase.h: Line 21 Decoder Base class code
//

#ifndef _INC_L21DBASE_H
#define _INC_L21DBASE_H

// Just a few macro definitions
#define ABS(x) (((x) > 0) ? (x) : -(x))
#define LPBMIHEADER(bmi) &((bmi)->bmiHeader)
#define DWORDALIGN(n)  (((n) + 3) & ~0x03)
#define ISDWORDALIGNED(n)  (0 == ((n) & 0x03))
#define DWORDALIGNWIDTH(bmih) (((((bmih).biWidth * (bmih).biBitCount) + 31) & ~31) >> 3)
#define MAKECCCHAR(b1, b2)  ((b1) << 8 | (b2))

//
//  Caption character attribs set by PACs and/or mid-row codes
//
#define UINT8   unsigned char
#define UINT16  unsigned short int

#define AM_L21_FGCOLOR_WHITE             0x00
#define AM_L21_FGCOLOR_GREEN             0x01
#define AM_L21_FGCOLOR_BLUE              0x02
#define AM_L21_FGCOLOR_CYAN              0x03
#define AM_L21_FGCOLOR_RED               0x04
#define AM_L21_FGCOLOR_YELLOW            0x05
#define AM_L21_FGCOLOR_MAGENTA           0x06
#define AM_L21_FGCOLOR_MASK              0x07

#define AM_L21_FGEFFECT_ITALICS          0x08
#define AM_L21_FGEFFECT_UNDERLINE        0x10
#define AM_L21_FGEFFECT_FLASHING         0x20
#define AM_L21_FGEFFECT_MASK             0x38

#define AM_L21_ATTRIB_DIRTY              0x40
#define AM_L21_ATTRIB_MRC                0x80

//
// Caption width and height
//
#define CAPTION_OUTPUT_WIDTH  640  /* 320 */
#define CAPTION_OUTPUT_HEIGHT 480  /* 240 */


//
// Forward declarations
//
class CCaptionChar ;
class CCaptionLine ;
class CRowIndexMap ;
class CCaptionBuffer ;
class CPopOnCaption ;


//
//  The max's of rows and columns
//
const int MAX_CAPTION_COLUMNS = 32 ;  // max # of column / line
const int MAX_CAPTION_ROWS    = 15 ;  // number of rows available on screen
const int MAX_CAPTION_LINES   = 4 ;   // max # of caption text at a time
// for text mode, add MAX_TEXT_LINES = 15 ;


//
//  CCaptionChar: The caption char details
//
class CCaptionChar {
private:
    UINT16 m_wChar ;     // actual char
    UINT8  m_uAttrib ;   // CC char attrib bits -- FG color, effect, dirty, MRC etc.
    //
    // The layout of bits (LSB -> MSB) of CC char attribs --
    //    0 - 2: color (0 -> 6 for White -> Magenta)
    //    3 - 5: effects (3: Italics, 4: Underline, 5: Flash)
    //        6: dirty (is the CC char dirty, i.e, needs to written?)
    //        7: is it a mid-row code (carries attrib, shown as opaque space)?
    //
    
public:
    inline CCaptionChar(void) {
        m_wChar   = 0 ;
        m_uAttrib = 0 ;
    } ;
    
    inline UINT16 GetChar(void) const  { return m_wChar ; } ;
    inline CCaptionChar& operator = (const CCaptionChar& cc) {
        m_wChar   = cc.m_wChar ;
        m_uAttrib = cc.m_uAttrib ;
        return *this ;
    } ;
    inline BOOL  operator == (const CCaptionChar& cc) const {
        return (m_wChar   == cc.m_wChar  &&
                m_uAttrib == cc.m_uAttrib) ;
    } ;
    inline BOOL  operator != (const CCaptionChar& cc) const {
        if (*this == cc)  return FALSE ;
        else              return TRUE ;
    } ;
    inline BOOL  IsEqualAttrib(CCaptionChar cc) const {
        return (GetColor()  == cc.GetColor()  &&
                GetEffect() == cc.GetEffect()) ;
    } ;
    inline UINT8 GetColor(void) const      { return  m_uAttrib & AM_L21_FGCOLOR_MASK ; } ;
    inline UINT8 GetEffect(void) const     { return (m_uAttrib & AM_L21_FGEFFECT_MASK) >> 3 ; } ;
    inline BOOL  IsItalicized(void) const  { return (0 != (m_uAttrib & AM_L21_FGEFFECT_ITALICS)) ; } ;
    inline BOOL  IsUnderLined(void) const  { return (0 != (m_uAttrib & AM_L21_FGEFFECT_UNDERLINE)) ; } ;
    inline BOOL  IsFlashing(void) const    { return (0 != (m_uAttrib & AM_L21_FGEFFECT_FLASHING)) ; } ;
    inline BOOL  IsDirty(void) const       { return (0 != (m_uAttrib & AM_L21_ATTRIB_DIRTY)) ; } ;
    inline BOOL  IsMidRowCode(void) const  { return (0 != (m_uAttrib & AM_L21_ATTRIB_MRC)) ; } ;
    void  SetChar(UINT16 wChar) ;
    void  SetColor(UINT8 uColor) ;
    void  SetEffect(UINT8 uEffect) ;
    void  SetItalicized(BOOL bState) ;
    void  SetUnderLined(BOOL bState) ;
    void  SetFlashing(BOOL bState) ;
    void  SetDirty(BOOL bState) ;
    void  SetMidRowCode(BOOL bState) ;

} ;


//
//  CCaptionLine: The caption line details
//
class CCaptionLine {
protected:  // not private
    CCaptionChar m_aCapChar[MAX_CAPTION_COLUMNS] ;  // char details of line
    UINT8        m_uNumChars ;      // number of chars in the line
    UINT8        m_uStartRow ;      // start row of the line
    
public:
    CCaptionLine(void) ;
    CCaptionLine(const UINT uStartRow, const UINT uNumChars = 0) ;
    
    CCaptionLine& operator = (const CCaptionLine& cl) ;
    
    inline int   GetNumChars(void) const  { return m_uNumChars ; } ;
    inline void  SetNumChars(UINT uNumChars)  { m_uNumChars = uNumChars & 0x3F ; } ;
    int IncNumChars(UINT uNumChars) ;
    int DecNumChars(UINT uNumChars) ;
    inline void  GetCaptionChar(UINT uCol, CCaptionChar &cc) const {
        if (uCol >= (UINT)MAX_CAPTION_COLUMNS)   // error!!
            return ;
        cc = m_aCapChar[uCol] ;
    } ;
    void SetCaptionChar(UINT uCol, const CCaptionChar &cc) ;
    CCaptionChar* GetCaptionCharPtr(UINT uCol) ;
    inline int  GetStartRow(void)  { return m_uStartRow ; } ;
    void SetStartRow(UINT uRow) ;
    inline CCaptionChar* GetLineText(void) { return (CCaptionChar *) m_aCapChar ; }
    void MoveCaptionChars(int iNum) ;
    void ClearLine(void) ;

} ;

//
//  CRowIndexMap: Mapping of row usage (row to text line)
//
class CRowIndexMap {
private:
    DWORD         m_adwMap[2] ;  // bit map of row usage
    
public:
    inline CRowIndexMap(void)  { ClearRowIndex() ; }
    
    DWORD GetMap(int i) { 
        if (! (0 == i || 1 == i) )
            return 0 ;
        return m_adwMap[i] ; 
    } ;
    int  GetRowIndex(UINT8 uRow) ;
    void SetRowIndex(UINT uLine, UINT8 uRow) ;
    inline void ClearRowIndex(void)  { m_adwMap[0] = m_adwMap[1] = 0 ; } ;
} ;


//
//  A set of flags and consts for caption buffer dirty state info
//
#define L21_CAPBUFFER_REDRAWALL     0x01
#define L21_CAPBUFFER_DIRTY         0x02
#define L21_CAPBUFFDIRTY_FLAGS      2


//
//  CCaptionBuffer: The caption buffer class details
//
class CCaptionBuffer {
protected:  // private
    CCaptionLine  m_aCapLine[MAX_CAPTION_LINES + 1] ;  // shall we always have an extra line? It's easier this way!!
    CRowIndexMap  m_RowIndex ;     // row index map bits
    UINT8         m_uNumLines ;    // # lines
    UINT8         m_uMaxLines ;    // max # lines (4 or less)
    UINT8         m_uCurrCol ;     // current column on the screen
    UINT8         m_uCurrLine ;    // max 4: maps row # to array index
    UINT8         m_uCaptionStyle ;// 0 = None, 1 = Pop-On, 2 = Paint-On, 3 = Roll-Up
    UINT8         m_uDirtyState ;  // caption buffer dirty state flags
    
public:
    CCaptionBuffer(UINT8 uStyle    = AM_L21_CCSTYLE_None, 
                   UINT8 uMaxLines = MAX_CAPTION_LINES) ;
    CCaptionBuffer(/* const */ CCaptionBuffer &cb) ;
    
    inline int  GetNumLines(void)  { return m_uNumLines ; } ;
    inline int  GetMaxLines(void)  { return m_uMaxLines ; } ;
    inline int  GetCurrRow(void)   { return m_aCapLine[m_uCurrLine].GetStartRow() ; } ;
    inline int  GetCurrCol(void)   { return m_uCurrCol ; } ;  // Why do we need it??
    inline int  GetCurrLine(void)  { return m_uCurrLine ; } ;
    inline int  GetRowIndex(UINT uRow)   { return m_RowIndex.GetRowIndex((UINT8)uRow) ; } ;
    inline int  GetStyle(void)     { return m_uCaptionStyle ; } ;
    
    inline void SetNumLines(int uNumLines)  { m_uNumLines = uNumLines & 0x7 ; } ;
    inline void SetMaxLines(int uMaxLines)  { 
        ASSERT(m_uMaxLines >= 0 && m_uMaxLines <= MAX_CAPTION_LINES) ;
        m_uMaxLines = uMaxLines & 0x7 ; 
    } ;
    inline void SetCurrRow(int uCurrRow)    {
        ASSERT(m_uCurrLine >= 0 && m_uCurrLine < m_uMaxLines) ;
        m_aCapLine[m_uCurrLine].SetStartRow(uCurrRow) ; 
    } ;
    void SetCurrCol(int uCurrCol) ;
    inline void SetCurrLine(int uLine)      { m_uCurrLine = uLine & 0x7 ; } ;
    inline void SetRowIndex(UINT uLine, UINT uRow)   { m_RowIndex.SetRowIndex(uLine, (UINT8)uRow) ; } ;
    inline void SetStyle(UINT8 uStyle)      { m_uCaptionStyle = uStyle ; } ;
    
    inline CCaptionLine& GetCaptionLine(UINT uLine)  {
        // uLine is assumed to have been verified in the caller
        return m_aCapLine[uLine] ;
    } ;
    void SetCaptionLine(UINT uLine, const CCaptionLine& cl) ;
    void ClearCaptionLine(UINT uLine) ;
    int  IncCurrCol(UINT uNumChars) ;
    int  DecCurrCol(UINT uNumChars) ;
    void ClearBuffer(void) ;
    void InitCaptionBuffer(void) ;
    int  IncNumLines(int uLines) ;
    int  DecNumLines(int uLines) ;
    CRowIndexMap& GetRowIndexMap(void)  { return m_RowIndex ; } ;
    void RemoveLineFromBuffer(UINT8 uLine, BOOL bUpNextLine) ;
    
    inline int  GetStartRow(UINT uLine) {
        return m_aCapLine[uLine].GetStartRow() ;
    } ;
    void SetStartRow(UINT uLine, UINT uRow) ;
    inline void GetCaptionChar(UINT uLine, UINT uCol, CCaptionChar& cc) {
        m_aCapLine[uLine].GetCaptionChar(uCol, cc) ;
    } ;
    inline void SetCaptionChar(UINT uLine, UINT uCol, const CCaptionChar& cc) {
        m_aCapLine[uLine].SetCaptionChar(uCol, cc) ;
    } ;
    inline CCaptionChar* GetCaptionCharPtr(UINT uLine, UINT uCol) {
        return m_aCapLine[uLine].GetCaptionCharPtr(uCol) ;
    } ;
    inline int IncNumChars(int uLine, UINT uNumChars) {
        return m_aCapLine[uLine].IncNumChars(uNumChars) ;
    } ;
    inline int DecNumChars(int uLine, UINT uNumChars) {
        return m_aCapLine[uLine].DecNumChars(uNumChars) ;
    } ;
    inline void MoveCaptionChars(int uLine, int iNum) {
        m_aCapLine[uLine].MoveCaptionChars(iNum) ;
    } ;
    
    inline BOOL IsBufferDirty(void)  { return m_uDirtyState & L21_CAPBUFFER_DIRTY ; } ;
    inline BOOL IsRedrawAll(void)    { return m_uDirtyState & L21_CAPBUFFER_REDRAWALL ; } ;

    BOOL IsRedrawLine(UINT8 uLine) ;
    void SetBufferDirty(BOOL bState) ;
    void SetRedrawAll(BOOL bState) ;
    void SetRedrawLine(UINT8 uLine, BOOL bState) ;
} ;

#endif // #ifndef _INC_L21DBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\lin21dec\l21decod.cpp ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.

//
// ActiveMovie Line 21 Decoder Filter: Decoder Logic part
//

#include <streams.h>
#include <windowsx.h>

// #ifdef FILTER_DLL
#include <initguid.h>
// #endif

#include <IL21Dec.h>
#include "L21DBase.h"
#include "L21DGDI.h"
#include "L21Decod.h"


//
//  CLine21DataDecoder class constructor: mainly init of members
//
CLine21DataDecoder::CLine21DataDecoder(AM_LINE21_CCSTYLE eStyle     /* = AM_L21_CCSTYLE_None */,
                                       AM_LINE21_CCSTATE eState     /* = AM_L21_CCSTATE_Off  */,
                                       AM_LINE21_CCSERVICE eService /* = AM_L21_CCSERVICE_None */)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::CLine21DataDecoder()"))) ;
    
#ifdef PERF
    m_idTxt2Bmp = MSR_REGISTER(TEXT("L21DPerf - Text to CC bmp")) ;
    m_idBmp2Out = MSR_REGISTER(TEXT("L21DPerf - Bmp to Output")) ;
    m_idScroll  = MSR_REGISTER(TEXT("L21DPerf - Line Scroll")) ;
#endif // PERF

    InitState() ;
    
    // We separately set some of the passed in values
    SetCaptionStyle(eStyle) ;
}


CLine21DataDecoder::~CLine21DataDecoder(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::~CLine21DataDecoder()"))) ;
    
    // make sure the internal bitmap etc has been released and
    // allocated memory or other resources are not left un-released.
}

//
// Decoder state initializer; will be used also in filter's CompleteConnect()
//
void CLine21DataDecoder::InitState(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::InitState()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    m_pCurrBuff = NULL ;
    
    m_uFieldNum = 1 ;   // field 1 by default
    
    InitCaptionBuffer() ;  // Init the CC data buffers and index

    SetCaptionStyle(AM_L21_CCSTYLE_None) ;
    m_eLastCCStyle = AM_L21_CCSTYLE_None ;
    m_eState = AM_L21_CCSTATE_On ;   // should be _Off by default or eState
    m_eLevel = AM_L21_CCLEVEL_TC2 ;
    m_eUserService = AM_L21_CCSERVICE_Caption1 ;   // _None by default or eService
    
    m_eDataService = AM_L21_CCSERVICE_None ;
    
    m_uCurrFGColor = AM_L21_FGCOLOR_WHITE ;
    m_uCurrFGEffect = 0 ;
    
    m_bExpectRepeat = FALSE ;
    m_chLastByte1 = 0 ;
    m_chLastByte2 = 0 ;
    
    m_bScrolling = FALSE ;
    m_iScrollStartLine = 0 ;
    
    m_bRedrawAlways = FALSE ;  // someone has to be too picky/weird to do it!!
    // m_bCapBufferDirty = FALSE ;
    
    //
    // We should also reset the font stuff for the CGDIWork class,
    // recalculate the char width and height, internal bmp width & height
    // etc.
    //
    m_GDIWork.InitFont() ;
}


void CLine21DataDecoder::FlushInternalStates(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::FlushInternalStates()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    InitCaptionBuffer(m_eCCStyle) ;    // clear caption buffer
    SetRedrawAll(TRUE) ;      // redraw (no) caption on next Receive()
    SetScrollState(FALSE) ;   // turn off scrolling, just to be sure
    SetCaptionStyle(AM_L21_CCSTYLE_None) ;
    m_eLastCCStyle = AM_L21_CCSTYLE_None ;
    
    m_GDIWork.ClearInternalBuffer() ;  // clear internal DIB section
    m_GDIWork.InitColorNLastChar() ;   // reset color etc.
    m_GDIWork.InitFont() ;             // get back to standard font
}


BOOL CLine21DataDecoder::SetServiceState(AM_LINE21_CCSTATE eState)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::SetServiceState(%lu)"), eState)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (eState == m_eState)  // no change of state
        return FALSE ;       // no refresh to be forced
    
    m_eState = eState ;  // save the state for future decoding
    
    //
    // When service is turned off, we must clear the caption buffer(s) and
    // the internal DIB section so that old captions are not shown anymore.
    //
    if (AM_L21_CCSTATE_Off == m_eState)
    {
        FlushInternalStates() ;
        return TRUE ;       // output needs to be refreshed
    }
    return FALSE ;          // output need not be refreshed by force
}


BOOL CLine21DataDecoder::SetCurrentService(AM_LINE21_CCSERVICE eService)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::SetCurrentService(%lu)"), eService)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (eService == m_eUserService)  // no change of service
        return FALSE ;               // no refresh to be forced
    
    m_eUserService = eService ;   // save the service the user wants
    
    //
    // When service "none" is selected (kind of "turn it off"), we must clear the 
    // caption buffer(s) and the internal DIB section so that old captions are 
    // not shown anymore.
    //
    if (AM_L21_CCSERVICE_None == m_eUserService)
    {
        FlushInternalStates() ;
        return TRUE ;       // output needs to be refreshed
    }
    return FALSE ;          // output need not be refreshed by force
}


//
//  Actual caption byte pair decoding algorithm
//
BOOL CLine21DataDecoder::DecodeBytePair(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::DecodeBytePair(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (AM_L21_CCSTATE_Off == m_eState)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Line21 data decoding turned off"))) ;
        return FALSE ;  // we actually didn't decode / generate anything
    }
    
    UINT uCodeType = CheckControlCode(chFirst, chSecond) ;
    if (L21_CONTROLCODE_INVALID != uCodeType)
    {
        // It's a control code (PAC / Mid row code / misc control code)
        return ProcessControlCode(uCodeType, chFirst, chSecond) ;
    }
    else if (IsSpecialChar(chFirst, chSecond))
    {
        // It's a special char represented by the second char
        return ProcessSpecialChar(chFirst, chSecond) ;
    }
    else
    {
        // If the 1st byte is in [0, F] then ignore 1st byte and print 2nd byte
        // as just a printable char
        BOOL  bResult = FALSE ;
        if (! ((chFirst &0x7F) >= 0x0 && (chFirst & 0x7F) <= 0xF) )
        {
            if (! ProcessPrintableChar(chFirst) )
                return FALSE ;
            bResult = TRUE ;
        }
        // If one of the two bytes decode right, we take it as a success
        bResult |= ProcessPrintableChar(chSecond) ;
        m_bExpectRepeat = FALSE ;  // turn it off now
        return bResult ;
    }
}


BOOL CLine21DataDecoder::UpdateCaptionOutput(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::UpdateCaptionOutput()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (m_eCCStyle != AM_L21_CCSTYLE_PopOn  &&  // Pop On style draws only on EOC
        IsCapBufferDirty())                     // otherwise draw when dirty
    {
        PrintTextToBitmap() ;  // check return value? Naah!!
        return TRUE ;          // caption updated
    }
    return FALSE ;  // no caption update
}


BOOL CLine21DataDecoder::IsPAC(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::IsPAC(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // mask off parity bit before code matching
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // now match code with control code list
    if ((0x10 <= chFirst  && 0x17 >= chFirst)  &&
        (0x40 <= chSecond && 0x7F >= chSecond))
        return TRUE ;
    if ((0x18 <= chFirst  && 0x1F >= chFirst)  &&
        (0x40 <= chSecond && 0x7F >= chSecond))
        return TRUE ;
    
    return FALSE ;
}


BOOL CLine21DataDecoder::IsMiscControlCode(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::IsMiscControlCode(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // mask off parity bit before code matching
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // first match with TO1 -> TO3 codes
    if ((0x21 <= chSecond && 0x23 >= chSecond)  &&
        (0x17 == chFirst  ||  0x1F == chFirst))
        return TRUE ;
    
    // Now match with the other misc control code
    if ((0x14 == chFirst  ||  0x15 == chFirst)  &&  
        (0x20 <= chSecond && 0x2F >= chSecond))
        return TRUE ;
    if ((0x1C == chFirst  ||  0x1D == chFirst)  &&  
        (0x20 <= chSecond && 0x2F >= chSecond))
        return TRUE ;

    return FALSE ;
}


BOOL CLine21DataDecoder::IsMidRowCode(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::IsMidRowCode(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // mask off parity bit before code matching
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // Now match with the mid row code list
    if ((0x11 == chFirst)  &&  (0x20 <= chSecond && 0x2F >= chSecond))
        return TRUE ;
    if ((0x19 == chFirst)  &&  (0x20 <= chSecond && 0x2F >= chSecond))
        return TRUE ;
    
    return FALSE ;
}


UINT CLine21DataDecoder::CheckControlCode(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::CheckControlCode(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    if (IsPAC(chFirst, chSecond))
        return L21_CONTROLCODE_PAC ;
    
    if (IsMidRowCode(chFirst, chSecond))
        return L21_CONTROLCODE_MIDROW ;
    
    if (IsMiscControlCode(chFirst, chSecond))
        return L21_CONTROLCODE_MISCCONTROL ;
    
    DbgLog((LOG_TRACE, 3, TEXT("Not a control code"))) ;
    return L21_CONTROLCODE_INVALID ;
}


BOOL CLine21DataDecoder::IsSpecialChar(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::IsSpecialChar(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // Strip the parity bit before determining the service channel
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // now match code with special char list
    if (0x11 == chFirst && (0x30 <= chSecond && 0x3f >= chSecond))
        return TRUE ;
    if (0x19 == chFirst && (0x30 <= chSecond && 0x3f >= chSecond))
        return TRUE ;
    
    return FALSE ;
}


BOOL CLine21DataDecoder::ValidParity(BYTE ch)
{
#if 1
    ch ^= ch >> 4 ;
    ch ^= ch >> 2 ;
    return (0 != (0x01 & (ch ^ (ch >> 1)))) ;
#else
    return TRUE ;
#endif
}


void CLine21DataDecoder::RelocateRollUp(UINT uBaseRow)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::RelocateRollUp(%u)"), uBaseRow)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    if (AM_L21_CCSTYLE_RollUp != m_eCCStyle)
        return ;
    
    int  iMaxLines = GetMaxLines() ;
    int  iNumLines = GetNumLines() ;
    int  iMax ;
    if (m_bScrolling)  // during scrolling go for last but 1 line
    {
        DbgLog((LOG_TRACE, 3, TEXT("Moving base row to %d during scrolling"), uBaseRow)) ;
        if (iNumLines > iMaxLines)
        {
            DbgLog((LOG_TRACE, 3, TEXT("%d lines while max is %d"), iNumLines, iMaxLines)) ;
            iNumLines-- ;  // we don't set the row for the "not-yet-in" line
        }
        iMax = min(iNumLines, iMaxLines) ;
    }
    else               // otherwise go for the last line
    {
        DbgLog((LOG_TRACE, 3, TEXT("Moving base row to %d (not scrolling)"), uBaseRow)) ;
        iMax = min(iNumLines, iMaxLines) ;
    }
    for (int i = 0 ; i < iMax ; i++)
    {
        SetStartRow((UINT8)i, (UINT8)(uBaseRow - (iMax - 1 - i))) ;
    }
}


BOOL CLine21DataDecoder::LineFromRow(UINT uCurrRow)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::LineFromRow(%u)"), uCurrRow)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    int     iLines ;
    
    // If we are in Roll-up mode then we shouldn't try to go through 
    // all the hassle of creating a new line etc. -- it's just a PAC 
    // to specify starting position and/or color; so just do that.
    if (AM_L21_CCSTYLE_RollUp != m_eCCStyle)
    {
        // If the indentation PAC places cursor on an existing row
        
        int   iIndex ;
        iIndex = GetRowIndex((UINT8)uCurrRow) ;
        if (-1 == iIndex)    // some error encountered
            return FALSE ;   // fail decoding
        
        if (0 == iIndex)  // landed in a new row
        {
            iLines = GetNumLines() ;
            SetNewLinePosition(iLines, uCurrRow) ;
            SetRedrawLine((UINT8)iLines, TRUE) ;  // initially set line to be redrawn
        }
        else  // landed in an existing row
        {
            SetCurrLine(iIndex-1) ;  // -1 because row index map is 1-based (it has to be),
            // but the caption line index etc are all 0-based.
        }
        
        // We have to put the cursor at the 1st column
        SetCurrCol(0) ;   // no matter which line it is, go to 1st col (i.e, 0)
    }
    else  // in Roll-up mode
    {
        // If necessary, move entire caption so that the specified row 
        // becomes the new base row.
        iLines = GetNumLines() ;
        if (1 == iLines)  // if this is for the first line
        {
            SetStartRow(0, (UINT8)uCurrRow) ;  // also set the base row to start with
        }
        else              // otherwise just move captions to the specified row
        {
            RelocateRollUp(uCurrRow) ;
            if (GetStartRow(iLines-1) == (int)uCurrRow)  // last line is at current row
                SetScrollState(FALSE) ;             // we should not scroll
            SetCapBufferDirty(TRUE) ; // caption buffer is dirty in a sense
            SetRedrawAll(TRUE) ;      // must be redrawn to show new position
        }
        
        DbgLog((LOG_TRACE, 1, TEXT("Base row for %d lines moved to %d"), iLines, uCurrRow)) ;
    }
    
    return TRUE ;
}


BOOL CLine21DataDecoder::DecodePAC(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::DecodePAC(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    int         iGroup ;
    UINT        uDiff ;
    UINT        uCurrRow ;
    UINT        uCurrCol ;
    UINT        uCol ;
    
    if (AM_L21_CCSTYLE_None == m_eCCStyle)
    {
        DbgLog((LOG_TRACE, 1, TEXT("DecodePAC(): No CC style defined yet. Skipping..."))) ;
        return TRUE ;  // ??
    }

    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 1, TEXT("DecodePAC(): Data for some other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }

    // Turn off parity checking here
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // now locate which of the two groups does 2nd byte belong, if at all!!
    if (chSecond >= 0x40 && chSecond <= 0x5F)
    {
        iGroup = 0 ;
        uDiff = chSecond - 0x40 ;
    }
    else if (chSecond >= 0x60 && chSecond <= 0x7F)
    {
        iGroup = 1 ;
        uDiff = chSecond - 0x60 ;
    }
    else   // invalid 2nd byte for PAC
    {
        DbgLog((LOG_ERROR, 2, TEXT("Invalid 2nd byte for PAC"))) ;
        return FALSE ;
    }
    
    // Valid 2nd byte; now decide based on the 1st byte
    static UINT8 auPACtoRowMap[0x10] = {
        11,  1,  3, 12, 14,  5,  7,  9, 11,  1,  3, 12, 14,  5,  7,  9  // row
     // 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 1A, 1B, 1C, 1D, 1E, 1F  // PAC byte 1
    } ;
    
    if (chFirst >= 0x10  &&  chFirst <= 0x1F)
    {
        // the row number is 1 more if the 2nd byte is in the 60-7F group
        uCurrRow = auPACtoRowMap[chFirst - 0x10] + iGroup  ;
        
        // Now see what happens with the new row specified, if any, in the PAC
        LineFromRow(uCurrRow) ;
    }
    else
    {
        DbgLog((LOG_TRACE, 2, TEXT("Invalid mid-row code in 1st byte"))) ;
        return FALSE ;
    }
    
    // some final decisions...
    m_uCurrFGEffect = 0 ;  // clear all effects as a result of PAC processing
    if (uDiff <= 0x0D)  // color (and underline) spec
        m_uCurrFGColor = uDiff >> 1 ;  // AM_L21_FGCOLOR_xxx are from 0 to 6
    else if (uDiff <= 0x0F)  // 0E, 0F == italics (and underline) spec
    {
        m_uCurrFGEffect |= AM_L21_FGEFFECT_ITALICS ;
        m_uCurrFGColor = AM_L21_FGCOLOR_WHITE ;  // 0
    }
    else  // 10 -> 1F == indent (and underline) spec (no other way)
    {
        // 50 (70) => 0, 52 (72) => 4 etc.
        // last bit of 2nd char determines underline or not
        uCurrCol = ((uDiff - 0x10) & 0xFE) << 1 ;
        if (uCurrCol >= MAX_CAPTION_COLUMNS)
            uCurrCol = MAX_CAPTION_COLUMNS - 1 ;
        
            /*
            int  iCurrLine = GetCurrLine() ;
            if (0 == GetNumCols(iCurrLine)) // if it's a tab indent on clean line
            {
            SetStartCol(iCurrLine, uCurrCol) ; // set start column as spec-ed
            SetCurrCol(0) ;             // and current col to 0
            }
            else if ((uCol = GetStartCol(iCurrLine)) > uCurrCol)  // existing line
            {
            // insert null spaces before currently existing chars as filler
            // (that adjusts the number of chars value too)
            MoveCaptionChars(iCurrLine, uCol - uCurrCol) ;
            SetStartCol(iCurrLine, uCurrCol) ;
            SetCurrCol(0) ;
            }
            else
            SetCurrCol(uCurrCol) ;
        */
        SetCurrCol((UINT8)uCurrCol) ;
        
        m_uCurrFGColor = AM_L21_FGCOLOR_WHITE ;
    }
    
    // at last check underline bit
    if (uDiff & 0x01)
        m_uCurrFGEffect |= AM_L21_FGEFFECT_UNDERLINE ;
    else
        m_uCurrFGEffect &= ~AM_L21_FGEFFECT_UNDERLINE ;
    
    return TRUE ;   // done at last!!!
}


BOOL CLine21DataDecoder::DecodeMidRowCode(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::DecodeMidRowCode(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    BYTE        uValue ;
    
    if (AM_L21_CCSTYLE_None == m_eCCStyle)
    {
        DbgLog((LOG_TRACE, 1, TEXT("DecodeMidRowCode(): No CC style defined yet.  Returning..."))) ;
        return TRUE ;  // ??
    }
    
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 1, TEXT("DecodeMidRowCode(): Data for some other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }

    if (chSecond < 0x20  ||  chSecond > 0x2F)
    {
        DbgLog((LOG_TRACE, 2, TEXT("Invalid mid-row code in 2nd byte"))) ;
        return FALSE ;
    }
    uValue = chSecond - 0x20 ;
    if (uValue & 0x01)
        m_uCurrFGEffect |= AM_L21_FGEFFECT_UNDERLINE ;
    else
        m_uCurrFGEffect &= ~AM_L21_FGEFFECT_UNDERLINE ;
    if (chSecond < 0x2E)   // only color specs
    {
        m_uCurrFGColor = uValue >> 1 ;  // AM_L21_FGCOLOR_xxx are from 0 to 6
        m_uCurrFGEffect &= ~AM_L21_FGEFFECT_ITALICS ;  // color turns off italics
    }
    else   // 2nd byte is 0x2E or 0x2F, i.e, italics specified
        m_uCurrFGEffect |= AM_L21_FGEFFECT_ITALICS ;
    
    // finally, mid-row code introduces a blank space
    PutCharInBuffer(0x20, TRUE) ;  // mark it as MRC too
    return TRUE ;
}


BOOL CLine21DataDecoder::DecodeMiscControlCode(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::DecodeMiscControlCode(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    BOOL        bResult ;
    
    switch (chFirst)
    {
        // case 0x15:
        // case 0x1D:
        //     m_uField = 2 ;   // the data is coming in Field 2
        
    case 0x14:      // misc control code -- channel 1
    case 0x1C:      // ditto -- channel 2
        switch (chSecond)
        {
        case 0x20:   // RCL: Resume Caption Loading
            bResult = HandleRCL(chFirst, chSecond) ;
            break ;
            
        case 0x21:   // BS:  Backspace
            bResult = HandleBS(chFirst, chSecond) ;
            break ;
            
        case 0x22:   // AOF: reserved
        case 0x23:   // AOF: reserved
            DbgLog((LOG_ERROR, 2, TEXT("AOF/AON as Misc ctrl code"))) ;
            return TRUE ;  // just ignore it
            
        case 0x24:   // DER: Delete to End of Row
            bResult = HandleDER(chFirst, chSecond) ;
            break ;
            
        case 0x25:   // RU2: Roll-Up Captions - 2 rows
        case 0x26:   // RU3: Roll-Up Captions - 3 rows
        case 0x27:   // RU4: Roll-Up Captions - 4 rows
            bResult = HandleRU(chFirst, chSecond, 2 + chSecond - 0x25) ;
            break ;
            
        case 0x28:   // FON: Flash On
            bResult = HandleFON(chFirst, chSecond) ;
            break ;
            
        case 0x29:   // RDC: Resume Direct Captioning
            bResult = HandleRDC(chFirst, chSecond) ;
            break ;
            
        case 0x2A:   // TR:  Text Restart
            bResult = HandleTR(chFirst, chSecond) ;
            break ;
            
        case 0x2B:   // RTD: Resume Text Display
            bResult = HandleRTD(chFirst, chSecond) ;
            break ;
            
        case 0x2C:   // EDM: Erase Displayed Memory
            bResult = HandleEDM(chFirst, chSecond) ;
            break ;
            
        case 0x2D:   // CR:  Carriage Return
            bResult = HandleCR(chFirst, chSecond) ;
            break ;
            
        case 0x2E:   // ENM: Erase Non-displayed Memory
            bResult = HandleENM(chFirst, chSecond) ;
            break ;
            
        case 0x2F:   // EOC: End of Caption (flip memories)
            bResult = HandleEOC(chFirst, chSecond) ;
            break ;
            
        default:
            DbgLog((LOG_ERROR, 2, TEXT("Invalid 2nd byte (0x%x) for Misc ctrl code (0x%x)"), 
                chSecond, chFirst)) ;
            return FALSE ;
        }  // end of switch (chSecond)
        break ;
        
        case 0x17:      // misc control code -- channel 1
        case 0x1F:      // ditto -- channel 2
            switch (chSecond)
            {
            case 0x21:   // TO1: Tab Offset 1 column
            case 0x22:   // TO2: Tab Offset 2 columns
            case 0x23:   // TO3: Tab Offset 3 columns
                bResult = HandleTO(chFirst, chSecond, 1 + chSecond - 0x21) ;
                break ;
                
            default:
                DbgLog((LOG_ERROR, 2, TEXT("Invalid 2nd byte (0x%x) for Misc ctrl code (0x%x)"), 
                    chSecond, chFirst)) ;
                return FALSE ;
            }  // end of switch (chSecond)
            break ;
            
        default:
            DbgLog((LOG_ERROR, 2, TEXT("Invalid 1st byte for Misc ctrl code"))) ;
            return FALSE ;
    }  // end of switch (chFirst)
    
    if (AM_L21_CCSTYLE_None == m_eCCStyle)
        DbgLog((LOG_TRACE, 2, TEXT("No CC style defined yet."))) ;
    else
        DbgLog((LOG_TRACE, 3, TEXT("CC style defined now (%d)."), m_eCCStyle)) ;
    
    return bResult ;  // return result of handling above
}


BOOL CLine21DataDecoder::ProcessSpecialChar(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::ProcessSpecialChar(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // Table of special char Unicode values for Truetype font (Lucida Console)
    static UINT16 awSplCharTT[] = {
     0x00ae,    0x00b0,    0x00bd,    0x00bf,    0x2122,    0x00a2,    0x00a3,    0x266b,
     // 30h,       31h,       32h,       33h,       34h,       35h,       36h,       37h,
     0x00e0,    0x0000,    0x00e8,    0x00e2,    0x00ea,    0x00ee,    0x00f4,    0x00fb } ;
     // 38h,       39h,       3Ah,       3Bh,       3Ch,       3Dh,       3Eh,       3Fh 

    // Table of special char for non-Truetype font (Terminal) [alternate chars]
    static UINT16 awSplCharNonTT[] = {
     0x0020,    0x0020,    0x0020,    0x0020,    0x0020,    0x0020,    0x0020,    0x0020,
     // 30h,       31h,       32h,       33h,       34h,       35h,       36h,       37h,
     0x0041,    0x0000,    0x0045,    0x0041,    0x0045,    0x0049,    0x004f,    0x0055 } ;
     // 38h,       39h,       3Ah,       3Bh,       3Ch,       3Dh,       3Eh,       3Fh 

    if (AM_L21_CCSTYLE_None == m_eCCStyle)
    {
        DbgLog((LOG_TRACE, 1, TEXT("ProcessSpecialChar(): No CC style defined yet.  Returning..."))) ;
        return TRUE ;  // ??
    }
                
    if (m_eDataService != m_eUserService)
    {           
        DbgLog((LOG_TRACE, 1, TEXT("Special char for diff channel (%d)"), (int)m_eDataService)) ;
        return TRUE ;  // ??
    }
                
    // Check if it's a repeat of the last special. If so ignore it; else print it.
    if (m_bExpectRepeat)
    {
        if (m_chLastByte1 == (chFirst & 0x7F) && m_chLastByte2 == (chSecond & 0x7F))
        {
            // Got 2nd transmission of the spl char; reset flag and ignore bytepair
            m_bExpectRepeat = FALSE ;
            return TRUE ;
        }
                    
        // Otherwise we got a different spl char pair; process it and expect a
        // repeat of this new pair next time.
    }
    else  // this is the 1st transmission of this spl char pair
    {
        m_bExpectRepeat = TRUE ;
        // now go ahead and process it
    }
                
    //  This pair of bytes may be valid. So we need to remember them to check
    //  against the next such pair for a repeat (of spl chars).
    //  BTW, we store the bytes only after the parity bit is stripped.
    m_chLastByte1 = chFirst & 0x7F ;
    m_chLastByte2 = chSecond & 0x7F ;
                
    ASSERT((chSecond & 0x7F) >= 0x30  &&  (chSecond & 0x7F) <= 0x3F) ;
    if (! ValidParity(chSecond) )
    {
        DbgLog((LOG_TRACE, 1, TEXT("Bad parity for character <%d>"), chSecond)) ;
        ProcessPrintableChar(0x7F) ;  // put special char solid block (7F)
    }
    else
    {
        if (m_GDIWork.IsTTFont())
            PutCharInBuffer(awSplCharTT[(chSecond & 0x7F) - 0x30]) ;
        else
            PutCharInBuffer(awSplCharNonTT[(chSecond & 0x7F) - 0x30]) ;
    }

    return TRUE ;
}


BOOL CLine21DataDecoder::ProcessControlCode(UINT uCodeType,
                                            BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
            TEXT("CLine21DataDecoder::ProcessControlCode(%u, 0x%x, 0x%x)"), 
            uCodeType, chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    // Make sure that the pair has valid parity bits
    if (! ValidParity(chSecond) )
    {
        DbgLog((LOG_TRACE, 1, TEXT("Invalid 2nd byte (%d) of Control Code pair -- ignoring pair"), chSecond)) ;
        return FALSE ;
    }
    
    BOOL  bSuccess = TRUE ;
    if (! ValidParity(chFirst) )
    {
        DbgLog((LOG_TRACE, 1, TEXT("Invalid 2nd byte (%d) of Control Code pair"), chFirst)) ;
        if (m_bExpectRepeat)  // if 2nd transmission of control code
        {
            if ((chSecond & 0x7F) == m_chLastByte2)  // we got the same 2nd byte
            {
                // most likely it's the retransmission garbled up -- ignore them
            }
            else   // different 2nd byte; just print it.
                bSuccess = ProcessPrintableChar((chSecond & 0x7F)) ;
            
            // Turn it off -- either 2nd byte matched => retransmit of control code
            //                or printed 2nd byte as a printable char
            m_bExpectRepeat = FALSE ;
        }
        else  // if 1st transmission of control code
        {
            bSuccess = ProcessPrintableChar(0x7F) && 
                ProcessPrintableChar((chSecond & 0x7F)) ;
        }
        return bSuccess ;
    }
    
    // Check if it's a repeat of the last control code. If so ignore it; else
    // set it so.
    if (m_bExpectRepeat)
    {
        if (m_chLastByte1 == (chFirst & 0x7F) && m_chLastByte2 == (chSecond & 0x7F))
        {
            // Got 2nd transmission of the control code; reset flag and ignore bytepair
            m_bExpectRepeat = FALSE ;
            return TRUE ;
        }
        
        // Otherwise we got a different control code pair; process it and expect a
        // repeat of this new pair next time.
    }
    else  // this is the 1st transmission of this control code pair
    {
        m_bExpectRepeat = TRUE ;
        // now go ahead and process it
    }
    
    //  Looks like this pair of bytes is going to be valid and at least has
    //  valid (odd) parity bits set.  So we need to remember them to check
    //  against the next such pair for a repeat (of control codes).
    //  BTW, we store the bytes only after the parity bit is stripped.
    
    chFirst = chFirst & 0x7F ;
    chSecond = chSecond & 0x7F ;
    
    m_chLastByte1 = chFirst ;
    m_chLastByte2 = chSecond ;
    
    switch (uCodeType)
    {
    case L21_CONTROLCODE_PAC:
        return DecodePAC(chFirst, chSecond) ;
        
    case L21_CONTROLCODE_MIDROW:
        return DecodeMidRowCode(chFirst, chSecond) ;
        
    case L21_CONTROLCODE_MISCCONTROL:
        return DecodeMiscControlCode(chFirst, chSecond) ;
        
    default:
        DbgLog((LOG_TRACE, 1, TEXT("Invalid code type (%u)"), uCodeType)) ;
        return FALSE ;  // not a control code
    }
}


BOOL CLine21DataDecoder::ProcessPrintableChar(BYTE ch)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::ProcessPrintableChar(%x)"), ch)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Printable char (?) for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }
    
    if (AM_L21_CCSTYLE_None == m_eCCStyle)
    {
        DbgLog((LOG_TRACE, 1, TEXT("ProcessPrintableChar(): No CC style defined yet. Skipping..."))) ;
        return FALSE ;
    }
    
    if (! IsStandardChar(ch & 0x7F) )
    {
        DbgLog((LOG_TRACE, 2, TEXT("Not a printable char."))) ;
        return FALSE ;
    }
    
    if (! ValidParity(ch) )  // if a printable char doesn't have valid parity
    {
        DbgLog((LOG_TRACE, 1, TEXT("Bad parity for (probably) printable char <%d>"), ch)) ;
        ch = 0x7F ;            // then replace it with 7Fh.
    }
    
    //
    // There is more twist to it than you think!!! Some special chars
    // are inside the standard char range.
    //
    BOOL  bResult = FALSE ;
    switch (ch & 0x7F)  // we only look at the parity-less bits
    {
        case 0x2A:  // lower-case a with acute accent
            if (m_GDIWork.IsTTFont())
                bResult = PutCharInBuffer(0x00e1) ;
            else   // no TT font -- use 'A' as alternate char
                bResult = PutCharInBuffer(0x0041) ;
            break ;

        case 0x5C:  // lower-case e with acute accent
            if (m_GDIWork.IsTTFont())
                bResult = PutCharInBuffer(0x00e9) ;
            else   // no TT font -- use 'E' as alternate char
                bResult = PutCharInBuffer(0x0045) ;
            break ;

        case 0x5E:  // lower-case i with acute accent
            if (m_GDIWork.IsTTFont())
                bResult = PutCharInBuffer(0x00ed) ;
            else   // no TT font -- use 'I' as alternate char
                bResult = PutCharInBuffer(0x0049) ;
            break ;

        case 0x5F:  // lower-case o with acute accent
            if (m_GDIWork.IsTTFont())
                bResult = PutCharInBuffer(0x00f3) ;
            else   // no TT font -- use 'O' as alternate char
                bResult = PutCharInBuffer(0x004f) ;
            break ;

        case 0x60:  // lower-case u with acute accent
            if (m_GDIWork.IsTTFont())
                bResult = PutCharInBuffer(0x00fa) ;
            else   // no TT font -- use 'U' as alternate char
                bResult = PutCharInBuffer(0x0055) ;
            break ;

        case 0x7B:  // lower-case c with cedilla
            if (m_GDIWork.IsTTFont())
                bResult = PutCharInBuffer(0x00e7) ;
            else   // no TT font -- use 'C' as alternate char
                bResult = PutCharInBuffer(0x0043) ;
            break ;

        case 0x7C:  // division sign
            if (m_GDIWork.IsTTFont())
                bResult = PutCharInBuffer(0x00f7) ;
            else   // no TT font -- use ' ' as alternate char
                bResult = PutCharInBuffer(0x0020) ;
            break ;

        case 0x7D:  // upper-case N with tilde
            if (m_GDIWork.IsTTFont())
                bResult = PutCharInBuffer(0x00d1) ;
            else   // no TT font -- use 'N' as alternate char
                bResult = PutCharInBuffer(0x004e) ;
            break ;

        case 0x7E:  // lower-case n with tilde
            if (m_GDIWork.IsTTFont())
                bResult = PutCharInBuffer(0x00f1) ;
            else   // no TT font -- use 'N' as alternate char
                bResult = PutCharInBuffer(0x004e) ;
            break ;

        case 0x7F:  // solid block
            if (m_GDIWork.IsTTFont())
                bResult = PutCharInBuffer(0x2588) ;
            else   // no TT font -- use ' ' as alternate char
                bResult = PutCharInBuffer(0x0020) ;
            break ;

        default:
            bResult = PutCharInBuffer(MAKECCCHAR(0, ch & 0x7F)) ;
            break ;
    }
    return bResult ;
}


BOOL CLine21DataDecoder::PutCharInBuffer(UINT16 wChar, BOOL bMidRowCode /* = FALSE */)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::PutCharInBuffer(0x%x, %u)"), wChar, bMidRowCode)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // Make sure we have got a PAC or MidRow code specifying our row posn
    // thereby creating a line in which the in param char is going to be put.
    if (0 == GetNumLines())
        return FALSE ;
    
    int          i ;
    CCaptionChar cc ;
    
    cc.SetChar(wChar) ;
    cc.SetColor((UINT8)m_uCurrFGColor) ;
    //
    // If this char is a mid-row code (which is shown as blank in CC) then don't
    // set the underline (mainly) or italicized/flashing attrib for it, because 
    // a space should not (or need not) be shown with such attribs.  We skip the 
    // effect bits altogether for such chars.
    //
    if (bMidRowCode)
        cc.SetEffect(0) ;
    else
        cc.SetEffect((UINT8)m_uCurrFGEffect) ;
    cc.SetMidRowCode(bMidRowCode) ;
    
    i = GetCurrLine() ;
    int  iCurrCol = GetCurrCol() ;
    SetCaptionChar((UINT8)i, (UINT8)iCurrCol, cc) ;
    //
    // If we are overwriting existing chars, the # chars doesn't increase...
    //
    int  iNumCols = GetNumCols(i) ;
    if (iCurrCol >= iNumCols)  // increment # chars by the differenece
        IncNumChars(i, iCurrCol-iNumCols+1) ;
    IncCurrCol(1) ;  // ...but current column goes up anyway.
    
    SetCapBufferDirty(TRUE) ;  // some new caption char added -- ???
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleRCL(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleRCL(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (0x14 == chFirst)
        m_eDataService = AM_L21_CCSERVICE_Caption1 ;
    else
        m_eDataService = AM_L21_CCSERVICE_Caption2 ;
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 1, TEXT("We switched to PopOn of non-selected service. Skipping..."))) ;
        return TRUE ;  // ??
    }

    if (AM_L21_CCSTYLE_PopOn  == m_eCCStyle)    // if already in pop-on mode...
        return TRUE ;                           // ... just ignore
    
    // decodes subsequent chars for pop-on into the non-displayed buffer, 
    // but doesn't affect currently displayed caption
    m_eLastCCStyle = SetCaptionStyle(AM_L21_CCSTYLE_PopOn) ; // gets CapBuffer address based on index
    
    SetRedrawAll(TRUE) ;  // we should redraw the whole caption now -- ???
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleBS(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleBS(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    // We should act ONLY IF the current data channel is Caption(C)/Text(T) which the user
    // has picked and the current byte pair is for the same substream (1 or 2 of C/T).
    if (m_eDataService == m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Backspace for same data and user channel"))) ;
        AM_LINE21_CCSERVICE eService ;
        if (0x14 == chFirst)
            eService = AM_L21_CCSERVICE_Caption1 ;
        else
            eService = AM_L21_CCSERVICE_Caption2 ;
        if (eService != m_eUserService)
        {
            DbgLog((LOG_TRACE, 1, TEXT("Backspace for other channel. Skipping..."))) ;
            return TRUE ;  // ??
        }
    }
    else  // we are getting data for a channel different from what user has opted
    {
        DbgLog((LOG_TRACE, 1, TEXT("Backspace for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }

    UINT  uCurrCol = GetCurrCol() ;
    if (0 == uCurrCol)   // no place to back up anymore
        return TRUE ;
    
    int  iLine = GetCurrLine() ;
    int  n ;
    if (MAX_CAPTION_COLUMNS - 1 == uCurrCol) // at last col
    {
        n = 2 ;  // erase 2 chars (?)
    }
    else   // in the middle of a row
    {
        n = 1 ;
    }
    SetCurrCol(uCurrCol - n) ;
    RemoveCharsInBuffer(n) ;
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleDER(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleDER(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    // We should act ONLY IF the current data channel is Caption(C)/Text(T) which the user
    // has picked and the current byte pair is for the same substream (1 or 2 of C/T).
    if (m_eDataService == m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Delete to End of Row for same data and user channel"))) ;
        AM_LINE21_CCSERVICE eService ;
        if (0x14 == chFirst)
            eService = AM_L21_CCSERVICE_Caption1 ;
        else
            eService = AM_L21_CCSERVICE_Caption2 ;
        if (eService != m_eUserService)
        {
            DbgLog((LOG_TRACE, 1, TEXT("Delete to End of Row for other channel. Skipping..."))) ;
            return TRUE ;  // ??
        }
    }
    else  // we are getting data for a channel different from what user has opted
    {
        DbgLog((LOG_TRACE, 1, TEXT("Delete to End of Row for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }

    RemoveCharsInBuffer(MAX_CAPTION_COLUMNS) ;  // delete as many as you can
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleRU(BYTE chFirst, BYTE chSecond, int iLines)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleRU(%u, %u, %d)"), 
            chFirst, chSecond, iLines)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    if (0x14 == chFirst)
        m_eDataService = AM_L21_CCSERVICE_Caption1 ;
    else
        m_eDataService = AM_L21_CCSERVICE_Caption2 ;
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 1, TEXT("We switched to RU%d of non-selected service. Skipping..."), iLines)) ;
        return TRUE ;  // ??
    }

    int iNumLines ;
    int iBaseRow ;
    
    // Check if the current style is Roll-up
    if (AM_L21_CCSTYLE_RollUp != m_eCCStyle)
    {
        // Now set up for roll-up captioning
        m_eLastCCStyle = SetCaptionStyle(AM_L21_CCSTYLE_RollUp) ;
        iNumLines = IncNumLines(1) ;    // create the 1st line
        iBaseRow = MAX_CAPTION_ROWS ;   // by default base row at row 15
        SetCurrCol(0) ;                 // start at beginning of line
    }
    else  // already in Roll-up mode; don't clear buffer, re-use current base row etc.
    {
        // if the current roll-up window height is more than the one
        // newly specified then remove the extra lines from the top
        iNumLines = GetNumLines() ;
        for (int i = 0 ; i < iNumLines - iLines ; i++)
            MoveCaptionLinesUp() ;
        
        //
        // If we remove even one line from the top, we must not be scrolling
        // anymore, for now.
        //
        if (iNumLines > iLines)
            SetScrollState(FALSE) ;
        
        if (iNumLines > 0)  // if we have lines from prev roll-up sesion
        {
            // save the prev base row value as it's the default base row next
            iNumLines = min(iNumLines, iLines) ;
            iBaseRow = GetStartRow(iNumLines-1) ;
        }
        else  // we were in Roll-up mode, but a EDM came just before the RUx
        {
            // Almost starting from scratch
            iNumLines = IncNumLines(1) ;    // create the 1st line
            iBaseRow = MAX_CAPTION_ROWS ;   // by default base row at row 15
        }

        // Don't change the current column location.
    }
    
    // Set the new values to start with
    SetMaxLines(iLines) ;
    SetCurrLine(iNumLines-1) ;
    SetStartRow((UINT8)(iNumLines-1), (UINT8)iBaseRow) ;
    SetRedrawLine(iNumLines-1, TRUE) ;  // by default new line is to be redrawn
    
    SetRedrawAll(TRUE) ;      // redraw the whole caption
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleFON(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleFON(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // We should act ONLY IF the current data channel is Caption(C)/Text(T) which the user
    // has picked and the current byte pair is for the same substream (1 or 2 of C/T).
    if (m_eDataService == m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("FlashOn for same data and user channel"))) ;
        AM_LINE21_CCSERVICE eService ;
        if (0x14 == chFirst)
            eService = AM_L21_CCSERVICE_Caption1 ;
        else
            eService = AM_L21_CCSERVICE_Caption2 ;
        if (eService != m_eUserService)
        {
            DbgLog((LOG_TRACE, 1, TEXT("FlashOn for other channel. Skipping..."))) ;
            return TRUE ;  // ??
        }
    }
    else  // we are getting data for a channel different from what user has opted
    {
        DbgLog((LOG_TRACE, 1, TEXT("FlashOn for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }

    m_uCurrFGEffect |= AM_L21_FGEFFECT_FLASHING ;
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleRDC(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleRDC(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    if (0x14 == chFirst)
        m_eDataService = AM_L21_CCSERVICE_Caption1 ;
    else
        m_eDataService = AM_L21_CCSERVICE_Caption2 ;
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 1, TEXT("We switched to PaintOn of non-selected service. Skipping..."))) ;
        return TRUE ;  // ??
    }

    if (AM_L21_CCSTYLE_PaintOn == m_eCCStyle)   // if already in paint-on mode...
        return TRUE ;                           // ... just ignore
    
    m_eLastCCStyle = SetCaptionStyle(AM_L21_CCSTYLE_PaintOn) ;

    SetRedrawAll(TRUE) ;  // we should redraw the whole caption now -- ???
    
    return TRUE ;
}


//
// I am not sure what the Text Restart command is supposed to do. But it "sounds
// like" something to do with the text1/2 channels which we don't support now.
//
BOOL CLine21DataDecoder::HandleTR(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleTR(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (0x14 == chFirst)
        m_eDataService = AM_L21_CCSERVICE_Text1 ;
    else
        m_eDataService = AM_L21_CCSERVICE_Text2 ;
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 1, TEXT("We switched to Text mode. Don't do anything."))) ;
        return TRUE ;  // ??
    }

    return TRUE ;
}


BOOL CLine21DataDecoder::HandleRTD(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleRTD(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (0x14 == chFirst)
        m_eDataService = AM_L21_CCSERVICE_Text1 ;
    else
        m_eDataService = AM_L21_CCSERVICE_Text2 ;
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 1, TEXT("We switched to Text mode. Don't do anything."))) ;
        return TRUE ;  // ??
    }
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleEDM(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleEDM(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    AM_LINE21_CCSERVICE eService ;
    if (0x14 == chFirst)
        eService = AM_L21_CCSERVICE_Caption1 ;
    else
        eService = AM_L21_CCSERVICE_Caption2 ;

    //
    // I am not sure what I am doing is right, but this seems to be the only way to
    // achieve how CC is supposed to look.
    // I thought if the decoder is in Text mode and it gets an EDM, it's supposed to
    // ignore it, just like the BS, DER, CR etc commands.  But that leaves junk on
    // screen. So I am interpretting the spec as saying "erase whatever is in display
    // memory whatever mode -- text/CC, you are in".
    //
    if (eService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Erase DispMem for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }
    
    CCaptionBuffer *pDispBuff ;

    // next redraw will show blank caption for non-PopOn style ONLY
    switch (m_eCCStyle)
    {
    case AM_L21_CCSTYLE_RollUp:
        SetScrollState(FALSE) ;  // not scrolling now at least
        // fall through to do more...
        
    case AM_L21_CCSTYLE_PaintOn:
        // when display memory is cleared, the attribs should be cleared too
        m_uCurrFGEffect = 0 ;
        m_uCurrFGColor = AM_L21_FGCOLOR_WHITE ;
        // fall through to do more...
        
    case AM_L21_CCSTYLE_PopOn:
        pDispBuff = GetDisplayBuffer() ;
        ASSERT(pDispBuff) ;
        if (pDispBuff)
            pDispBuff->ClearBuffer() ;
        pDispBuff->SetRedrawAll(TRUE) ;

        break ;
    }
    
    //
    // To clear the screen content we should clear internal DIB section which
    // will in turn cause a (clear) sample to be output erasing currently
    // displayed CC.
    //
    m_GDIWork.ClearInternalBuffer() ;

    return TRUE ;
}


void CLine21DataDecoder::SetNewLinePosition(int iLines, UINT uCurrRow)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::SetNewLinePosition(%d, %u)"), 
            iLines, uCurrRow)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    int     iMaxLines = GetMaxLines() ;
    
    // Check if scroll up is needed or not
    if (iLines >= iMaxLines)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Too many lines. Locate and remove one blank line."))) ;
        
        if (AM_L21_CCSTYLE_RollUp == m_eCCStyle)  // if in roll-up mode
        {
            // We shouldn't be here at all. Anyway, complain and remove the top line.
            DbgLog((LOG_ERROR, 0, 
                TEXT("ERROR: How do we have too many lines in roll-up mode (%d vs. max %d)?"),
                iLines, iMaxLines)) ;
            ASSERT(FALSE) ;  // so that we don't miss it
            RemoveLineFromBuffer(0, TRUE) ; // move line #2 onwards up
            iLines-- ;
        }
        else  // non Roll-up mode
        {
            // See if there is a blank line. If so, remove it to make space
            for (int i = 0 ; i < iLines ; i++)
            {
                if (GetNumCols(i) == 0)
                {
                    DbgLog((LOG_TRACE, 3, TEXT("Found line #%d (1-based) blank -- removed."), i+1)) ;
                    RemoveLineFromBuffer((UINT8)i, FALSE) ; // just remove line; don't move up following lines
                    iLines-- ;
                    break ;    // got one line -- enough.
                }
            }
            
            // HACK HACK: This should never happen, but....
            // If the number of lines is still too many, just overwrite the 
            // last line (Is that good?? Oh well...)
            if ((iLines = GetNumLines()) >= iMaxLines)  // too many lines
            {
                DbgLog((LOG_ERROR, 1, TEXT("ERROR: Too many lines. Removing last line by force."))) ;
                RemoveLineFromBuffer(iLines-1, FALSE) ; // just remove the line
                iLines-- ;  // one less line
                SetCurrCol(0) ;  // we start at the beginning on the line
            }
        }
    }
    
    // Now we have to add a new line and set it up
    IncNumLines(1) ;
    SetCurrLine((UINT8)iLines) ;
    SetStartRow((UINT8)iLines, (UINT8)uCurrRow) ;
}


BOOL CLine21DataDecoder::HandleCR(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleCR(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // We should act ONLY IF the current data channel is Caption(C)/Text(T) which the user
    // has picked and the current byte pair is for the same substream (1 or 2 of C/T).
    if (m_eDataService == m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Carriage Return for same data and user channel"))) ;
        AM_LINE21_CCSERVICE eService ;
        if (0x14 == chFirst)
            eService = AM_L21_CCSERVICE_Caption1 ;
        else
            eService = AM_L21_CCSERVICE_Caption2 ;
        if (eService != m_eUserService)
        {
            DbgLog((LOG_TRACE, 1, TEXT("Carriage Return for other channel. Skipping..."))) ;
            return TRUE ;  // ??
        }
    }
    else  // we are getting data for a channel different from what user has opted
    {
        DbgLog((LOG_TRACE, 1, TEXT("Carriage Return for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }

    // Is it only allowed in roll-up style?  I think so based on the docs.
    
    switch (m_eCCStyle)
    {
    case AM_L21_CCSTYLE_PopOn:
    case AM_L21_CCSTYLE_PaintOn:
        DbgLog((LOG_ERROR, 1, TEXT("INVALID: CR in Pop-on/Paint-on mode!!!"))) ;
        break ;  // or return FALSE ; ???
        
    case AM_L21_CCSTYLE_RollUp:  // This is the real one
        {
            int iRow ;
            int iLines = GetNumLines() ;
            if (0 == iLines)  // no CC line yet -- this is 1st line's data
            {
                iRow = MAX_CAPTION_ROWS ;  // base line's default row position
				SetStartRow((UINT8)iLines, (UINT8)iRow) ;
            }
            else if (1 == iLines)  // there is only 1 line so far
            {
                if (0 == GetNumCols(0))  // blank 1st line
                {
                    RemoveLineFromBuffer(0, TRUE) ; // remove blank 1st line
                    iLines = 0 ;                    // no line left
                }
            }
            else  // there are multiple lines already
            {
                // iRow = GetStartRow(iLines-1) + 1 ;  // +1 to go under last line
                if (m_bScrolling)
                {
                    SkipScrolling() ;
                    iLines = GetNumLines() ;  // we might have scrolled top line off
                }
            }
            if (iLines > 0)  // only if we already have a non-blank line
                SetScrollState(TRUE) ;  // ready to scroll
            IncNumLines(1) ;
            //
            // Number of lines is 1 more than iLines now. So iLines actually
            // points to the last line as a 0-based index.
            //
            SetCurrLine((UINT8)iLines) ;
            SetRedrawLine((UINT8)iLines, TRUE) ;  // new line always to be redrawn
            SetCurrCol(0) ;
            DbgLog((LOG_TRACE, 1, TEXT("New line at row %d after %d lines"), iRow, iLines)) ;
            
            // Make sure to give up all the display attributes and chars 
            // for new row
            // RemoveCharsInBuffer(MAX_CAPTION_COLUMNS) ;  // should we or let it be cleared by a DER?
            m_uCurrFGColor = AM_L21_FGCOLOR_WHITE ;
            m_uCurrFGEffect = 0 ;  // no effect until a PAC/MRC comes
            
            break ;
        }
        
    default:  // Weird!! How did we come here?
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: CR came for unknown mode"))) ;
        break ;
    }
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleENM(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleENM(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    AM_LINE21_CCSERVICE eService ;
    if (0x14 == chFirst)
        eService = AM_L21_CCSERVICE_Caption1 ;
    else
        eService = AM_L21_CCSERVICE_Caption2 ;

    //
    // I am not sure what I am doing is right, but this seems to be the only way to
    // achieve how CC is supposed to look.
    // I thought if the decoder is in Text mode and it gets an ENM, it's supposed to
    // ignore it, just like the BS, DER, CR etc commands.  But that leaves junk on
    // screen. So I am interpretting the spec as saying "erase whatever is in non-display
    // memory whatever mode -- text/CC, you are in".
    //
    if (eService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Erase non-DispMem for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }
    
    // Meant only for Pop-on style back back -- clear non-displayed buffer; 
    // display not affected until EOC
    m_aCCData[1 - GetBufferIndex()].ClearBuffer() ;
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleEOC(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleEOC(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    if (0x14 == chFirst)
        m_eDataService = AM_L21_CCSERVICE_Caption1 ;
    else
        m_eDataService = AM_L21_CCSERVICE_Caption2 ;
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 1, TEXT("We switched to PopOn mode of non-selected channel. skipping..."))) ;
        return TRUE ;  // ??
    }

    if (AM_L21_CCSTYLE_PopOn == m_eCCStyle)  // already in pop-on; flip buffers
    {
        PrintTextToBitmap() ;  // print text to bitmap
        SwapBuffers() ;        // switch 0, 1
        //
        // Also need to update m_pCurrBuff so that we point to
        // the correct one after the above swap.
        // (m_pCurrBuff is set in SetCaptionStyle()).
        //
    }
    else   // change to pop-on style
    {
        m_eLastCCStyle = SetCaptionStyle(AM_L21_CCSTYLE_PopOn) ;
    }

    // Update current buffer pointer based on style and buffer index
    m_pCurrBuff = GetCaptionBuffer() ;
    ASSERT(m_pCurrBuff) ;
    if (m_pCurrBuff)
        m_pCurrBuff->SetRedrawAll(TRUE) ;  // we should redraw the whole caption now
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleTO(BYTE chFirst, BYTE chSecond, int iCols)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleTO(%u, %u, %d)"),
            chFirst, chSecond, iCols)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    // We should act ONLY IF the current data channel is Caption(C)/Text(T) which the user
    // has picked and the current byte pair is for the same substream (1 or 2 of C/T).
    if (m_eDataService == m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Tab Offset %d for same data and user channel"), iCols)) ;
        AM_LINE21_CCSERVICE eService ;
        if (0x17 == chFirst)
            eService = AM_L21_CCSERVICE_Caption1 ;
        else
            eService = AM_L21_CCSERVICE_Caption2 ;
        if (eService != m_eUserService)
        {
            DbgLog((LOG_TRACE, 1, TEXT("Tab Offset %d for other channel. Skipping..."), iCols)) ;
            return TRUE ;  // ??
        }
    }
    else  // we are getting data for a channel different from what user has opted
    {
        DbgLog((LOG_TRACE, 1, TEXT("Tab Offset %d for other channel. Skipping..."), iCols)) ;
        return TRUE ;  // ??
    }
    
    UINT8  uCurrCol  = (UINT8)GetCurrCol() ;
    uCurrCol += (UINT8)iCols ;
    if (uCurrCol >= MAX_CAPTION_COLUMNS)
        uCurrCol = MAX_CAPTION_COLUMNS - 1 ;
    SetCurrCol(uCurrCol) ;
    
    return TRUE ;
}


//
// It checks as well as *updates* the number of chars in a line of caption
//
BOOL CLine21DataDecoder::IsEmptyLine(int iLine)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::IsEmptyLine(%ld)"), iLine)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    CCaptionChar*   pcc ;
    int  iNumChars = GetNumCols(iLine) ;
    BOOL bResult = TRUE ;
    int  i ;
    for (i = iNumChars - 1 ; i >= 0 ; i--) // going backwards (-1 due to 0-based index)
    {
        pcc = GetCaptionCharPtr((UINT8)iLine, (UINT8)i) ;
        ASSERT(pcc) ;
        if (pcc  &&  pcc->GetChar() != 0)  // got one
        {
            bResult = FALSE ;
            break ;  // enough
        }
    }

    if ( !bResult ) // only if there is some chars left on this line
        DecNumChars(iLine, iNumChars - (i + 1)) ;  // reduce # chars by the diff

    return bResult ;
}


BOOL CLine21DataDecoder::RemoveCharsInBuffer(int iNumChars)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::RemoveCharsInBuffer(%d)"), iNumChars)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    int          i, j, k, n ;
    CCaptionChar cc ;
    
    // Just to be sure, check a few things first
    if (GetNumLines() == 0 ||   // no line to delete from
        (n = GetNumCols(GetCurrLine())) == 0)      // no char on current line to delete
        return TRUE ;           // we are done!!
    
    // Prepare the replacement caption char
    cc.SetChar(0) ;  // 0 is transparent space
    cc.SetColor(AM_L21_FGCOLOR_WHITE) ;
    cc.SetEffect(0) ;
    cc.SetDirty(TRUE) ;
    
    // Find the location to clear
    i = GetCurrLine() ;
    j = GetCurrCol() ;
    
    // Check that we are not trying to delete too many chars.
    // Remember: current col + # chars to delete <= MAX.
    if (iNumChars + j > MAX_CAPTION_COLUMNS)  // try it and see!!!
        iNumChars = MAX_CAPTION_COLUMNS - j ;
    
    // Clear the necessary chars
    for (k = 0 ; k < iNumChars ; k++)
    {
        if (j + k < n)          // if a char before the last char is removed, ...
            DecNumChars(i, 1) ; // ... reduce # chars by 1
        SetCaptionChar((UINT8)i, (UINT8)(j+k), cc) ;
    }
    
    if (0 == GetNumCols(i) ||  // # chars left on this line is 0  OR
        IsEmptyLine(i))        // no non-transparent chars on this line
        RemoveLineFromBuffer((UINT8)i, FALSE) ; // delete the line from buffer
    else                     // something left -- so redraw line
        SetRedrawAll(TRUE) ; // I really hate to do it, but I couldn't find a better way
    
    SetCapBufferDirty(TRUE) ;  // some caption char(s) removed
    
    return TRUE ;
}


BOOL CLine21DataDecoder::PrintTextToBitmap(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::PrintTextToBitmap()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    int           i, j ;
    int           r, c ;
    CCaptionChar *pcc ;
    BOOL          bRedrawAll = FALSE ;
    BOOL          bRedrawLine ;
    BOOL          bXparentSpace ;
    UINT16        wChar ;
    
// #define DUMP_BUFFER
#ifdef DUMP_BUFFER
    CHAR    achTestBuffer[MAX_CAPTION_COLUMNS+5] ;
    int     iTest = 0 ;
    DbgLog((LOG_TRACE, 0, TEXT("Caption Buffer Content:"))) ;
#endif // DUMP_BUFFER

    MSR_START(m_idTxt2Bmp) ;

    // We need to print all the CC chars to internal output buffer if
    // - a CC command came that needs a total output refresh  or
    // - we have a totally new internal output buffer
    bRedrawAll = (IsRedrawAll() || m_GDIWork.IsNewIntBuffer()) ;
    if (bRedrawAll)
        m_GDIWork.ClearInternalBuffer() ;
    
    // Draw the chars for all cols of all rows that is dirty
    r = GetNumLines() ;
    for (i = 0 ; i < r ; i++)
    {
        c = GetNumCols(i) ;
        if (0 == c)     // if there is no char on a line, skip drawing it
            continue ;  // try next caption line
        
        // Redraw line if 
        // 1) redraw all flag is set   Or
        // 2) redraw line flag is set
        bRedrawLine = bRedrawAll || IsRedrawLine((UINT8)i) ;
        
        // First skip all the leading transparent spaces and then draw
        // the leading space.
        for (j = 0 ; j < c ; j++)
        {
            pcc = GetCaptionCharPtr((UINT8)i, (UINT8)j) ;
            if (pcc  &&  0 != pcc->GetChar())
            {
                // Add a leading blank space for each caption line, if either
                // a) the whole line is being redrawn   OR
                // b) the non-transparent space char is dirty so that
                //    the char will be drawn on top of the next space.
                if (bRedrawLine || pcc->IsDirty())
                    m_GDIWork.DrawLeadingSpace(i, j) ;
                break ;
            }
#ifdef DUMP_BUFFER
            // ` (back quote) => transparent space for debug output
            achTestBuffer[iTest] = '`' ;
            iTest++ ;
#endif // DUMP_BUFFER
        }
        
        bXparentSpace = FALSE ;  // new line => no transparent char issue
        
        // Now print the dirty chars for the current line of caption
        for ( ; j < c ; j++)
        {
            pcc = GetCaptionCharPtr((UINT8)i, (UINT8)j) ;
            if (NULL == pcc)
            {
                ASSERT(!TEXT("Got bad pointer to CC char")) ;
                continue ;  // proceed to the next char
            }
            wChar = pcc->GetChar() ;
#ifdef DUMP_BUFFER
            // ` (back quote) => transparent space for debug output
            achTestBuffer[iTest] = wChar == 0 ? '`' : (char) (wChar & 0x7F) ;  // dump higher byte
            iTest++ ;
#endif // DUMP_BUFFER
            
            // We draw a char only if we have to, i.e,
            // 1) all the caption chars on the line has to be drawn fresh
            //    Or
            // 2) if a char has changed
            // This saves a lot of time doing ExtTextOut()s.
            if (bRedrawLine || pcc->IsDirty())
            {
                if (0 == wChar)  // got transparent space; set flag, don't draw
                    bXparentSpace = TRUE ;
                else  // not transparent space
                {
                    if (bXparentSpace)  // leading blank after transparent space
                    {
                        m_GDIWork.DrawLeadingSpace(i, j) ; // to draw 1 col behind, don't add 1 to j
                        bXparentSpace = FALSE ;  // it's done
                    }
                    m_GDIWork.WriteChar(i, j+1, *pcc) ;  // column needs to change for each char
                }
                pcc->SetDirty(FALSE) ;   // char no more dirty
            }
        }  // end of for (j)
        
        // Whether the line needed to be redrawn or not, let's clear it now
        SetRedrawLine((UINT8)i, FALSE) ;
        
#ifdef DUMP_BUFFER
        achTestBuffer[iTest] = 0 ;
        DbgLog((LOG_TRACE, 0, TEXT("    <%s>"), achTestBuffer)) ;
        iTest = 0 ;  // for next line
#endif // DUMP_BUFFER
        
    }  // end of for (i)
    
    MSR_STOP(m_idTxt2Bmp) ;

    // If the above steps were done because the caption buffer was 
    // dirty, then now we can mark the caption buffer as 
    // "no-more-dirty" as it has been output in the bitmap form and 
    // has been "redrawn all".
    SetCapBufferDirty(FALSE) ;
    SetRedrawAll(FALSE) ;
    m_GDIWork.ClearNewIntBufferFlag() ;
    
    return TRUE ;
}


void CLine21DataDecoder::SkipScrolling(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::SkipScrolling()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    int iLines = GetNumLines() ;
    SetScrollState(FALSE) ;    // we are no more scrolling
    
    if (iLines > GetMaxLines())  // too many line; remove top line
    {
        // remove the first text line and move subsequent lines up by one
        DbgLog((LOG_TRACE, 1, TEXT("Top line is being scrolled out"))) ;
        MoveCaptionLinesUp() ;
    }
    else   // otherwise move the line(s) up by a row and bring in new line
    {
        iLines-- ;   // last but one line is at base row
        UINT uBaseRow = GetStartRow(iLines-1) ;
        DbgLog((LOG_TRACE, 1, TEXT("Scrolling all lines up by 1 row"))) ;
        // The following call moves all the line up by including the not-yet-in 
        // line at the base row
        RelocateRollUp(uBaseRow) ;  // move all lines one row higher
    }
}


int CLine21DataDecoder::IncScrollStartLine(int iCharHeight)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::IncScrollStartLine(%d)"), 
            iCharHeight)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (0 == m_iScrollStartLine)  // starting to scroll
        MSR_START(m_idScroll) ;

    m_iScrollStartLine += m_GDIWork.GetScrollStep() ;
    if (m_iScrollStartLine > iCharHeight)
    {
        // Scrolling one line is done -- do the standard end of scroll stuff
        DbgLog((LOG_TRACE, 3, TEXT("One full line has been scrolled up"))) ;
        SkipScrolling() ;
        MSR_STOP(m_idScroll) ;  // scrolling ended
    }
    
    return m_iScrollStartLine ;
}


void CLine21DataDecoder::SetScrollState(BOOL bState)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::SetScrollState(%s)"), 
            bState ? "TRUE" : "FALSE")) ;

    if (bState)                      // if turning ON scrolling
    {
        if (!m_bScrolling)           // change scroll line only if NOT scrolling now
            m_iScrollStartLine = 0 ; // start from first line
    }
    else                             // turning if OFF
        m_iScrollStartLine = 0 ;     // back to the start line

    m_bScrolling = bState ;          // set the spec-ed scrolling state
}


void CLine21DataDecoder::MoveCaptionLinesUp(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::MoveCaptionLinesUp()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    RemoveLineFromBuffer(0, TRUE) ; // remove the top line from buffer
    SetCapBufferDirty(TRUE) ;       // a line of text removed -- buffer dirty
}


void CLine21DataDecoder::CompleteScrolling(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::CompleteScrolling()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // For now we are doing a really cheapo solution, but it may work.
    if (m_bScrolling)
        SkipScrolling() ;
}


void CLine21DataDecoder::UpdateBoundingRect(RECT *prectOut, RECT *prectLine)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::UpdateBoundingRect()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    prectOut->top    = min(prectOut->top,    prectLine->top) ;
    prectOut->left   = min(prectOut->left,   prectLine->left) ;
    prectOut->bottom = max(prectOut->bottom, prectLine->bottom) ;
    prectOut->right  = max(prectOut->right,  prectLine->right) ;
}


void CLine21DataDecoder::CalcOutputRect(RECT *prectOut)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::CalcOutputRect()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // We don't check if it's necessary to re-calc the bounding rect. Will
    // checking save time?

    CCaptionBuffer   *pDispBuff = GetDisplayBuffer() ;  // this is mainly for Pop-On captioning
    if (NULL == pDispBuff)
    {
        DbgLog((LOG_TRACE, 2, TEXT("No style specified yet. Set bounding rect to (0, 0, 0, 0)."))) ;
        SetRect(prectOut, 0, 0, 0, 0) ;          // indicates whole bitmap
        return ;
    }
    int  iNumLines = pDispBuff->GetNumLines() ;
    int  iMaxLines = pDispBuff->GetMaxLines() ;
    int  iMax = min(iNumLines, iMaxLines) ;
    if (iNumLines > 0)  // there is some content to output -- specify correct spot
    {
        RECT  rectLine ;
        SetRect(prectOut, 10000, 10000, 0, 0) ;  // init top & left to large, bottom & right to low
        for (int i = 0 ; i < iMax ; i++)
        {
            m_GDIWork.GetOutputLines(pDispBuff->GetStartRow(i), &rectLine) ;
            UpdateBoundingRect(prectOut, &rectLine) ;
        }
   }
    else                // nothing to output -- specify whole bitmap
        SetRect(prectOut, 0, 0, 0, 0) ;          // indicates whole bitmap
}


void CLine21DataDecoder::CopyOutputDIB(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::CopyOutputDIB()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    //
    // Don't copy DIB scanlines unless at least one of the following 
    // is true:
    // a) downstream filter wants a total redraw
    // b) Roll-up style and scrolling
    // c) new DIB section created (old bitmap gone)
    // d) new output sample buffer (last copy is lost)
    // e) new data has been written on output DIB (copy new data)
    //
    if (! (m_bRedrawAlways ||
           (AM_L21_CCSTYLE_RollUp == m_eCCStyle && m_bScrolling) ||  
           m_GDIWork.IsNewIntBuffer() ||
           m_GDIWork.IsNewOutBuffer() ||
           m_GDIWork.IsBitmapDirty()) )
        return ;
    
    // Clear the entire output buffer now
    m_GDIWork.FillOutputBuffer() ;
    
    // Copy by scanlines representing each text line's data
    CCaptionBuffer   *pDispBuff = GetDisplayBuffer() ;  // this is mainly for Pop-On captioning
    if (NULL == pDispBuff)
    {
        DbgLog((LOG_TRACE, 2, TEXT("No style specified yet. Just reseting flags."))) ;
        m_GDIWork.ClearBitmapDirtyFlag() ;   // we are outputting current bitmap anyway
        m_GDIWork.ClearNewIntBufferFlag() ;  // new buffer is cleared and output
        m_GDIWork.ClearNewOutBufferFlag() ;  // current bitmap will be on this out buffer
        return ;
    }
    int  iNumLines = pDispBuff->GetNumLines() ;
    int  iMaxLines = pDispBuff->GetMaxLines() ;
    int  iMax = min(iNumLines, iMaxLines) ;
    if (iNumLines > 0)  // there is some content to output -- specify correct spot
    {
        MSR_START(m_idBmp2Out) ;  // start copying DIB secn data to output buffer

        if (m_bScrolling)   // during scrolling
        {
            if (iNumLines > iMaxLines)  // scrolling a line out
            {
                // Show the bottom scan lines of the top (outgoing) line
                DbgLog((LOG_TRACE, 2, 
                    TEXT("Scrolling: Total %d lines > %d lines max (line 0)"), 
                    iNumLines, iMaxLines)) ;
                m_GDIWork.CopyLine(0, m_iScrollStartLine, pDispBuff->GetStartRow(0), 0) ;
            }
            else   // just scrolling the line up to accomodate the new line
            {
                // Put the bottom line a few scanlines above to simulate scrolling up
                DbgLog((LOG_TRACE, 2,
                    TEXT("Scrolling: Total %d lines <= %d lines max (line 0)"), 
                    iNumLines, iMaxLines)) ;
                m_GDIWork.CopyLine(0, 0, pDispBuff->GetStartRow(0), -m_iScrollStartLine) ;
                iMax-- ;   // don't draw last line (partial line)
            }
        
            // Now show the middle (if any) lines in total
            int iCharHeight = m_GDIWork.GetCharHeight() ;
            for (int i = 1 ; i < iMax ; i++)
            {
                // We put each full line in its predecessor's row with some dest offset
                // to make it come down to its own row.  
                // I wish I could draw that diagram here about how scanlines get copied 
                // from internal DIB section to the output buffer.
                DbgLog((LOG_TRACE, 1, TEXT("Scrolling: Drawing line %d..."), i)) ;
                m_GDIWork.CopyLine(i, 0, pDispBuff->GetStartRow(i-1), 
                    iCharHeight-m_iScrollStartLine) ;
            }
        
            // Last show only the top scan lines of the new (not yet included) line
            DbgLog((LOG_TRACE, 1, TEXT("Scrolling: drawing last line %d"), iNumLines)) ;
            m_GDIWork.CopyLine(iNumLines-1, 0,
                pDispBuff->GetStartRow(iNumLines-2), // -2 as new line shows up
                // in the above line's space
                iCharHeight-m_iScrollStartLine, 
                m_iScrollStartLine) ;
        
            // Move to one scan line down for new output sample
            IncScrollStartLine(iCharHeight) ;  // it's MUCH harder than just ++-ing
        }
        else   // we are not scrolling
        {
            DbgLog((LOG_TRACE, 2,
                TEXT("NOT Scrolling: Total %d lines, %d lines max"), 
                iNumLines, iMaxLines)) ;
            for (int i = 0 ; i < iMax ; i++)
            {
                DbgLog((LOG_TRACE, 1, TEXT("NOT Scrolling: Drawing line %d..."), i)) ;
                m_GDIWork.CopyLine(i, 0, pDispBuff->GetStartRow(i), 0) ;
                // UpdateBoundingRect() ;
            }
        }
        MSR_STOP(m_idBmp2Out) ;  // done copying DIB secn data to output buffer
    }
    else                // nothing to output -- specify whole bitmap
    {
        DbgLog((LOG_TRACE, 3, TEXT("No caption data in buffer."))) ;
    }
    
    // Reset the new internal/external buffer and bitmap dirty flag
    m_GDIWork.ClearBitmapDirtyFlag() ;
    m_GDIWork.ClearNewIntBufferFlag() ;
    m_GDIWork.ClearNewOutBufferFlag() ;
}


//
// Clear both buffers
//
BOOL CLine21DataDecoder::InitCaptionBuffer(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::InitCaptionBuffer(void)"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    m_aCCData[0].InitCaptionBuffer() ;  // clear buffer 0
    m_aCCData[1].InitCaptionBuffer() ;  // clear buffer 1
    SetBufferIndex(0) ;                 // reset CC buffer index
    
    return TRUE ;
}


//
// Clear buffer(s) based on the given style
//
BOOL CLine21DataDecoder::InitCaptionBuffer(AM_LINE21_CCSTYLE eCCStyle)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::InitCaptionBuffer(%d)"), (int)eCCStyle)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    switch (eCCStyle)
    {
    case AM_L21_CCSTYLE_PopOn:
        m_aCCData[0].InitCaptionBuffer() ;
        m_aCCData[1].InitCaptionBuffer() ;
        SetBufferIndex(0) ;   // reset CC buffer index
        break ;
        
    case AM_L21_CCSTYLE_RollUp:
    case AM_L21_CCSTYLE_PaintOn:
        m_aCCData[GetBufferIndex()].InitCaptionBuffer() ;
        break ;
        
    default:
        DbgLog((LOG_ERROR, 1, TEXT("InitCaptionBuffer(): Wrong Style (%d)!!"), eCCStyle)) ;
        return FALSE ;
    }

    return TRUE ;
}

//
// Caption style determines the buffer pointers to hold the caption chars.
// We make m_pCurrBuff point to the approp. buffer based on the new style.
// NOTE: The only other place where m_pCurrBuff may be changed is in 
// CLine21DataDecoder::HandleEOC() which flips the buffers back & front. So
// we also need to change m_pCurrBuff there too.
//
AM_LINE21_CCSTYLE CLine21DataDecoder::SetCaptionStyle(AM_LINE21_CCSTYLE eStyle)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::SetCaptionStyle(%d)"), eStyle)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    switch (eStyle)
    {
    case AM_L21_CCSTYLE_PopOn:
        m_pCurrBuff = &m_aCCData[1 - GetBufferIndex()] ;
        // Set CC style on both the buffers
        m_aCCData[0].SetStyle(eStyle) ;
        m_aCCData[1].SetStyle(eStyle) ;
        break ;
        
    case AM_L21_CCSTYLE_RollUp:
        InitCaptionBuffer() ;
        m_pCurrBuff = &m_aCCData[GetBufferIndex()] ;
        m_pCurrBuff->SetStyle(eStyle) ;  // set CC style on display buffer only
        break ;

    case AM_L21_CCSTYLE_PaintOn:
        if (AM_L21_CCSTYLE_PopOn == m_eCCStyle)   // if switching from PopOn to PaintOn...
            InitCaptionBuffer(eStyle) ;           // ...clear display buffer
        m_pCurrBuff = &m_aCCData[GetBufferIndex()] ;
        m_pCurrBuff->SetStyle(eStyle) ;  // set CC style on display buffer only
        break ;
        
    case AM_L21_CCSTYLE_None:  // This is done in init etc.
        m_pCurrBuff = NULL ;
        // Reset CC style on both the buffers
        m_aCCData[0].SetStyle(AM_L21_CCSTYLE_None) ;
        m_aCCData[1].SetStyle(AM_L21_CCSTYLE_None) ;
        break ;
        
    default:
        DbgLog((LOG_ERROR, 1, TEXT("SetCaptionStyle(): Invalid Style!!"))) ;
        m_pCurrBuff = NULL ;
        // Reset CC style on both the buffers
        m_aCCData[0].SetStyle(AM_L21_CCSTYLE_None) ;
        m_aCCData[1].SetStyle(AM_L21_CCSTYLE_None) ;
        return AM_L21_CCSTYLE_None ;
    }
    AM_LINE21_CCSTYLE  eOldStyle = m_eCCStyle ;
    m_eCCStyle = eStyle ;
    
    //
    // When CC style changes, some internal states also need to cleared
    //
    m_uCurrFGEffect = 0 ;
    m_uCurrFGColor = AM_L21_FGCOLOR_WHITE ;
    SetScrollState(FALSE) ;  // not scrolling now
    
    return eOldStyle ;
}

CCaptionBuffer * CLine21DataDecoder::GetDisplayBuffer(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::GetDisplayBuffer()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    switch (m_eCCStyle)
    {
    case AM_L21_CCSTYLE_PopOn:
    case AM_L21_CCSTYLE_RollUp:
    case AM_L21_CCSTYLE_PaintOn:
        return &m_aCCData[GetBufferIndex()] ;
        
    default:
        DbgLog((LOG_ERROR, 1, TEXT("GetDisplayBuffer(): Wrong Style!!"))) ;
        return NULL ;
    }
}

CCaptionBuffer * CLine21DataDecoder::GetCaptionBuffer(void)
{
    return &m_aCCData[1 - GetBufferIndex()] ;
}


void CLine21DataDecoder::SetBufferIndex(int iIndex)
{
    if (! (0 == iIndex  ||  1 == iIndex) )  // error!!
        return ;
    m_iBuffIndex = iIndex & 0x01 ;
}


void CLine21DataDecoder::ClearBuffer(void)
{
    if (m_pCurrBuff)
        m_pCurrBuff->ClearBuffer() ;
}

void CLine21DataDecoder::RemoveLineFromBuffer(UINT8 uLine, BOOL bUpNextLine)
{
    if (m_pCurrBuff)
        m_pCurrBuff->RemoveLineFromBuffer(uLine, bUpNextLine) ;
}

void CLine21DataDecoder::GetCaptionChar(UINT8 uLine, UINT8 uCol, CCaptionChar& cc)
{
    if (m_pCurrBuff)
        m_pCurrBuff->GetCaptionChar(uLine, uCol, cc) ;
}

void CLine21DataDecoder::SetCaptionChar(const UINT8 uLine, const UINT8 uCol,
                                        const CCaptionChar& cc)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetCaptionChar(uLine, uCol, cc) ;
}

CCaptionChar* CLine21DataDecoder::GetCaptionCharPtr(UINT8 uLine, UINT8 uCol)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetCaptionCharPtr(uLine, uCol) ;
    
    //
    //  Otherwise it's a very bad thing!!!!
    //
    DbgLog((LOG_ERROR, 0, TEXT("WARNING: m_pCurrBuff is NULL inside GetCaptionCharPtr()"))) ;
#ifdef DEBUG
    DebugBreak() ;  // don't want to miss debugging it!!!
#endif // DEBUG
    return NULL ;  // may be we should trap this and not fault
}

int  CLine21DataDecoder::GetMaxLines(void)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetMaxLines() ;
    return 0 ;  // that's best!!!
}

void CLine21DataDecoder::SetMaxLines(UINT uLines)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetMaxLines(uLines) ;
}

int  CLine21DataDecoder::GetNumLines(void)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetNumLines() ;
    return 0 ;
}

void CLine21DataDecoder::SetNumLines(UINT uLines)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetNumLines(uLines) ;
}

int  CLine21DataDecoder::GetNumCols(int iLine)
{
    if (NULL == m_pCurrBuff)
    {
        ASSERT(FALSE) ;
        return 0 ;   // should we??
    }
    
    if (iLine >= GetNumLines())
    {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid line number (%d) ( > Total (%d)"), iLine, GetNumLines())) ;
        ASSERT(FALSE) ;
        return 0 ;
    }
    
    return m_pCurrBuff->GetCaptionLine(iLine).GetNumChars() ;
}


int  CLine21DataDecoder::GetCurrLine(void)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetCurrLine() ;
    ASSERT(FALSE) ;
    return 0 ; // should we??
}

int  CLine21DataDecoder::GetCurrCol(void)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetCurrCol() ;
    ASSERT(FALSE) ;
    return 0 ; // should we??
}

void CLine21DataDecoder::SetCurrLine(UINT8 uLine)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetCurrLine(uLine) ;
}

void CLine21DataDecoder::SetCurrCol(UINT8 uCol)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetCurrCol(uCol) ;
}

int  CLine21DataDecoder::GetStartRow(UINT8 uLine)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetStartRow(uLine & 0x7) ;
    
    //
    // This is very very bad!!!
    //
    DbgLog((LOG_ERROR, 0, TEXT("WARNING: m_pCurrBuff is NULL in GetStartRow()"))) ;
#ifdef DEBUG
    DebugBreak() ;  // don't want to miss debugging it!!!
#endif // DEBUG
    return 0 ;
}

void CLine21DataDecoder::SetStartRow(UINT8 uLine, UINT8 uRow)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetStartRow(uLine & 0x7, uRow) ;
}

int  CLine21DataDecoder::GetRowIndex(UINT8 uRow)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetRowIndex(uRow) ;
    else
    {
        ASSERT(FALSE) ;
        return 0 ;  // should we??
    }
}

void CLine21DataDecoder::SetRowIndex(UINT8 uLine, UINT8 uRow)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetRowIndex(uLine, uRow) ;
}

int CLine21DataDecoder::IncCurrCol(UINT uNumChars)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->IncCurrCol(uNumChars) ;
    ASSERT(FALSE) ;
    return 0 ; // is that OK?
}

int CLine21DataDecoder::DecCurrCol(UINT uNumChars)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->DecCurrCol(uNumChars) ;
    ASSERT(FALSE) ;
    return 0 ;  // is that OK?
}

int CLine21DataDecoder::IncNumChars(UINT uLine, UINT uNumChars)
{
    if (NULL == m_pCurrBuff)
    {
        ASSERT(FALSE) ;
        return 0 ;  // should we??
    }
    
    if (uLine >= (UINT)GetNumLines())
    {
        ASSERT(FALSE) ;
        return 0 ;
    }
    
    return m_pCurrBuff->GetCaptionLine(uLine).IncNumChars(uNumChars) ;
}

int CLine21DataDecoder::DecNumChars(UINT uLine, UINT uNumChars)
{
    if (NULL == m_pCurrBuff)
    {
        ASSERT(FALSE) ;
        return 0 ;  // should we??
    }
    
    if (uLine >= (UINT)GetNumLines())
    {
        ASSERT(FALSE) ;
        return 0 ;
    }
    return m_pCurrBuff->GetCaptionLine(uLine).DecNumChars(uNumChars) ;
}

int CLine21DataDecoder::IncNumLines(UINT uLines)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->IncNumLines(uLines) ;
    return 0 ;
}

int CLine21DataDecoder::DecNumLines(UINT uLines)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->DecNumLines(uLines) ;
    return 0 ;
}

void CLine21DataDecoder::MoveCaptionChars(int iLine, int iNum)
{
    if (m_pCurrBuff)
        m_pCurrBuff->MoveCaptionChars(iLine, iNum) ;
}

BOOL CLine21DataDecoder::IsCapBufferDirty(void)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->IsBufferDirty() ;
    return FALSE ;
}

BOOL CLine21DataDecoder::IsRedrawLine(UINT8 uLine)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->IsRedrawLine(uLine) ;
    return FALSE ;
}

BOOL CLine21DataDecoder::IsRedrawAll(void)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->IsRedrawAll() ;
    return FALSE ;
}

void CLine21DataDecoder::SetCapBufferDirty(BOOL bState)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetBufferDirty(bState) ;
}

void CLine21DataDecoder::SetRedrawLine(UINT8 uLine, BOOL bState)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetRedrawLine(uLine, bState) ;
}

void CLine21DataDecoder::SetRedrawAll(BOOL bState)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetRedrawAll(bState) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\lin21dec\l21dfilt.cpp ===
// Copyright (c) 1996 - 1999  Microsoft Corporation.  All Rights Reserved.

//
// ActiveMovie Line 21 Decoder Filter: Filter Interface
//

#include <streams.h>
#include <windowsx.h>

#ifdef FILTER_DLL
#include <initguid.h>
#endif /* FILTER_DLL */

#include <IL21Dec.h>
#include "L21DBase.h"
#include "L21DGDI.h"
#include "L21Decod.h"
#include "L21DFilt.h"

#include <mpconfig.h>   // IMixerPinConfig at connection


//
//  Setup Data
//
/* const */ AMOVIESETUP_MEDIATYPE sudLine21DecInType  = 
{ 
    &MEDIATYPE_AUXLine21Data,       // MajorType
    &MEDIASUBTYPE_NULL              // MinorType
} ;

/* const */ AMOVIESETUP_MEDIATYPE sudLine21DecOutType = 
{ 
    &MEDIATYPE_Video,               // MajorType
    &MEDIASUBTYPE_NULL              // MinorType
} ;

/* const */ AMOVIESETUP_PIN psudLine21DecPins[] = 
{ 
    { L"Input",                // strName
        FALSE,                   // bRendered
        FALSE,                   // bOutput
        FALSE,                   // bZero
        FALSE,                   // bMany
        &CLSID_NULL,             // clsConnectsToFilter
        L"Output",               // strConnectsToPin
        1,                       // nTypes
        &sudLine21DecInType      // lpTypes
    },
    { L"Output",               // strName
        FALSE,                   // bRendered
        TRUE,                    // bOutput
        FALSE,                   // bZero
        FALSE,                   // bMany
        &CLSID_NULL,             // clsConnectsToFilter
        L"Input",                // strConnectsToPin
        1,                       // nTypes
        &sudLine21DecOutType     // lpTypes
    } 
} ;

const AMOVIESETUP_FILTER sudLine21Dec = 
{ 
    &CLSID_Line21Decoder,         // clsID
    L"Line 21 Decoder",           // strName
    MERIT_NORMAL,                 // dwMerit
    2,                            // nPins
    psudLine21DecPins,            // lpPin
} ;

//  Nothing to say about the output pin

#ifdef FILTER_DLL

// list of class ids and creator functions for class factory
CFactoryTemplate g_Templates[] = 
{
    {   L"Line 21 Decoder",
        &CLSID_Line21Decoder,
        CLine21DecFilter::CreateInstance,
        NULL,
        &sudLine21Dec
    }
} ;

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

//
//  Exported entry points for registration and unregistration (in this case 
//  they only call through to default implmentations).
//
HRESULT DllRegisterServer()
{
    return AMovieDllRegisterServer2(TRUE) ;
}

HRESULT DllUnregisterServer()
{
    return AMovieDllRegisterServer2(FALSE) ;
}

#endif // FILTER_DLL



#ifndef UNALIGNED
#define UNALIGNED   // __unaligned
#endif // UNALIGNED


//
//  CLine21DecFilter class implementation
//

// static member init at file scope
CMessageWindow * CLine21DecFilter::m_pMsgWnd = NULL ;

//
//  Constructor
//
CLine21DecFilter::CLine21DecFilter(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr)
: CTransformFilter(pName, pUnk, CLSID_Line21Decoder),

m_pbOutBuffer(NULL),
m_L21Dec(),
m_eSubTypeIDIn(AM_L21_CCSUBTYPEID_Invalid),
m_eGOP_CCType(GOP_CCTYPE_Unknown),
m_rtTimePerSample((LONGLONG) 166833), // 333667),
m_rtStart((LONGLONG) 0),
m_rtStop((LONGLONG) 0),
m_rtLastSample((LONGLONG) 0),
m_llMediaStart((LONGLONG) 0),
m_llMediaStop((LONGLONG) 0),
m_pviDefFmt(NULL),
m_dwDefFmtSize(0),
m_bMustOutput(FALSE),
m_bDiscontLast(FALSE),
m_uTimerID(0),
m_uTimerCount(0),
m_bTimerClearReqd(FALSE),
m_pPinDown(NULL),
m_bBlendingState(TRUE), // so that we read it once at least
m_dwBlendParam(1000)    // invalid by default -- valid value on setting to FALSE
{
    CAutoLock   Lock(&m_csFilter) ;
    
    DbgLog((LOG_TRACE, 1, 
        TEXT("CLine21DecFilter::CLine21DecFilter() -- Instantiating Line 21 Decoder filter"))) ;
    
    ASSERT(pName) ;
    ASSERT(phr) ;
    
    //
    // Create the message window and make sure that it has been created right; else error out
    //
    if (NULL == m_pMsgWnd)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Message handler window has to be created."))) ;
        m_pMsgWnd = new CMessageWindow ;
        if (NULL == m_pMsgWnd || NULL == m_pMsgWnd->GetHandle())
        {
            DbgLog((LOG_ERROR, 0, TEXT("Timer message handler window creation failed. Can't go ahead."))) ;
            ASSERT(phr) ;
            *phr = E_UNEXPECTED ; // what else to say!!
            return ;
        }
    }
    m_pMsgWnd->AddCount() ;

#ifdef PERF
#pragma message("Building for PERF measurements")
    m_idDelvWait  = MSR_REGISTER(TEXT("L21DPerf - Wait on Deliver")) ;
#endif // PERF
}


//
//  Destructor
//
CLine21DecFilter::~CLine21DecFilter()
{
    CAutoLock   Lock(&m_csFilter) ;
    
    DbgLog((LOG_TRACE, 1, 
        TEXT("CLine21DecFilter::~CLine21DecFilter() -- Destructing Line 21 Decoder filter"))) ;

    // In case the downstream pin interface wasn't released...
    if (m_pPinDown)
    {
        m_pPinDown->Release() ;
        m_pPinDown = NULL ;
    }
    
    // Release all the buffers allocated
    if (m_pviDefFmt)
    {
        delete m_pviDefFmt ;
        m_pviDefFmt = NULL ;
    }
    
    ASSERT(m_pMsgWnd) ;
    if (m_pMsgWnd && m_pMsgWnd->ReleaseCount() <= 0)  // -ve means bad!!!
    {
        delete m_pMsgWnd ;
        m_pMsgWnd = NULL ;
    }
    
    // Make sure we are not holding onto any DDraw surfaces (should be 
    // released during disconnect)
    DbgLog((LOG_TRACE, 1, TEXT("* Destroying the Line 21 Decoder filter *"))) ;
}


//
//  NonDelegatingQueryInterface
//
STDMETHODIMP CLine21DecFilter::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if (ppv)
        *ppv = NULL ;
    
    DbgLog((LOG_TRACE, 6, TEXT("somebody's querying my interface"))) ;
    if (IID_IAMLine21Decoder == riid)
    {
        return GetInterface((IAMLine21Decoder *) this, ppv) ;
    }
    return CTransformFilter::NonDelegatingQueryInterface(riid, ppv) ;
}


//
//  CreateInstance: Goes in the factory template table to create new instances
//
CUnknown * CLine21DecFilter::CreateInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
    return new CLine21DecFilter(TEXT("Line 21 Decoder filter"), pUnk, phr) ;
}


STDMETHODIMP CLine21DecFilter::GetDecoderLevel(AM_LINE21_CCLEVEL *lpLevel)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetDecoderLevel(0x%lx)"), lpLevel)) ;
    // CAutoLock   Lock(&m_csFilter) ;

    if (IsBadWritePtr(lpLevel, sizeof(AM_LINE21_CCLEVEL)))
        return E_INVALIDARG ;
    
    *lpLevel = m_L21Dec.GetDecoderLevel() ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter::GetCurrentService(AM_LINE21_CCSERVICE *lpService)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetCurrentService(0x%lx)"), lpService)) ;
    // CAutoLock   Lock(&m_csFilter) ;

    if (IsBadWritePtr(lpService, sizeof(AM_LINE21_CCSERVICE)))
        return E_INVALIDARG ;
    
    *lpService = m_L21Dec.GetCurrentService() ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter::SetCurrentService(AM_LINE21_CCSERVICE Service)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::SetCurrentService(%lu)"), Service)) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (Service < AM_L21_CCSERVICE_None || Service > AM_L21_CCSERVICE_XDS)
        return E_INVALIDARG ;
    
    if (Service >= AM_L21_CCSERVICE_Text1)  // we don't have support for Text1/2 or XDS now.
        return E_NOTIMPL ;
    
    if (m_L21Dec.SetCurrentService(Service))  // if we must refresh output
        m_bMustOutput = TRUE ;                // then flag it here.

    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter::GetServiceState(AM_LINE21_CCSTATE *lpState)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetServiceState(0x%lx)"), lpState)) ;
    // CAutoLock   Lock(&m_csFilter) ;

    if (IsBadWritePtr(lpState, sizeof(AM_LINE21_CCSTATE)))
        return E_INVALIDARG ;
    
    *lpState = m_L21Dec.GetServiceState() ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter::SetServiceState(AM_LINE21_CCSTATE State)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::SetServiceState(%lu)"), State)) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (State < AM_L21_CCSTATE_Off || State > AM_L21_CCSTATE_On)
        return E_INVALIDARG ;
    
    if (m_L21Dec.SetServiceState(State))  // if we must refresh output
        m_bMustOutput = TRUE ;            // then flag it here.
    
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter::GetOutputFormat(LPBITMAPINFOHEADER lpbmih)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetOutputFormat(0x%lx)"), lpbmih)) ;
    // CAutoLock   Lock(&m_csFilter) ;
    return m_L21Dec.GetOutputFormat(lpbmih) ;
}

STDMETHODIMP CLine21DecFilter::SetOutputFormat(LPBITMAPINFO lpbmi)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::SetOutputFormat(0x%lx)"), lpbmi)) ;
    // CAutoLock   Lock(&m_csFilter) ;

    return E_NOTIMPL ;  // for now, until we do it properly

#if 0
    m_L21Dec.DeleteOutputDC() ;  // delete current DIB section
    
    HRESULT hr = m_L21Dec.SetOutputOutFormat(lpbmi) ;
    if (FAILED(hr))
        return hr ;
    
    // if the format details changed in any way, we should get the default
    // format data again (just to make sure).
    hr = GetDefaultFormatInfo() ;
    
    //
    // ONLY if we are running/paused, we need to create internal DIB section
    //
    if (m_State != State_Stopped)
    {
        if (! m_L21Dec.CreateOutputDC() )  // new DIBSection creation failed
        {
            DbgLog((LOG_ERROR, 0, TEXT("CreateOutputDC() failed!!!"))) ;
            return E_UNEXPECTED ;
        }
    }
    
    return hr ;
#endif // #if 0
}

STDMETHODIMP CLine21DecFilter::GetBackgroundColor(DWORD *pdwPhysColor)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetBackgroundColor(0x%lx)"), pdwPhysColor)) ;
    // CAutoLock   Lock(&m_csFilter) ;

    if (IsBadWritePtr(pdwPhysColor, sizeof(DWORD)))
        return E_INVALIDARG ;
    
    m_L21Dec.GetBackgroundColor(pdwPhysColor) ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter::SetBackgroundColor(DWORD dwPhysColor)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::SetBackgroundColor(0x%lx)"), dwPhysColor)) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (m_L21Dec.SetBackgroundColor(dwPhysColor))  // color key has really changed
    {
        // refill the output buffer only if we are not in stopped state
        if (State_Stopped != m_State)
            m_L21Dec.FillOutputBuffer() ;
    }
    
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter::GetRedrawAlways(LPBOOL lpbOption)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetRedrawAlways(0x%lx)"), lpbOption)) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (IsBadWritePtr(lpbOption, sizeof(BOOL)))
        return E_INVALIDARG ;
    *lpbOption = m_L21Dec.GetRedrawAlways() ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter::SetRedrawAlways(BOOL bOption)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::SetRedrawAlways(%lu)"), bOption)) ;
    CAutoLock   Lock(&m_csFilter) ;

    m_L21Dec.SetRedrawAlways(bOption) ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter::GetDrawBackgroundMode(AM_LINE21_DRAWBGMODE *lpMode)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetDrawBackgroundMode(0x%lx)"), lpMode)) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (IsBadWritePtr(lpMode, sizeof(AM_LINE21_DRAWBGMODE)))
        return E_INVALIDARG ;
    
    *lpMode = m_L21Dec.GetDrawBackgroundMode() ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter::SetDrawBackgroundMode(AM_LINE21_DRAWBGMODE Mode)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::SetDrawBackgroundMode(%lu)"), Mode)) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (Mode < AM_L21_DRAWBGMODE_Opaque  || Mode > AM_L21_DRAWBGMODE_Transparent)
        return E_INVALIDARG ;
    m_L21Dec.SetDrawBackgroundMode(Mode) ;
    return NOERROR ;
}


//
//  VerifyGOPUDPacketData: Private helper method to verify GOP user data
//                         packet integrity.
//
BOOL CLine21DecFilter::VerifyGOPUDPacketData(PAM_L21_GOPUD_PACKET pGOPUDPacket)
{
    return (AM_L21_GOPUD_HDR_STARTCODE == GETGOPUD_L21STARTCODE(pGOPUDPacket->Header) &&  // valid start code
        AM_L21_GOPUD_HDR_INDICATOR == GETGOPUD_L21INDICATOR(pGOPUDPacket->Header) &&  // Line21 indicator
        AM_L21_GOPUD_HDR_RESERVED  == GETGOPUD_L21RESERVED(pGOPUDPacket->Header)  &&  // reserved bits
        GETGOPUD_NUMELEMENTS(pGOPUDPacket) > 0) ;                                     // +ve # elements
}


//
//  VerifyATSCUDPacketData: Private helper method to verify ATSC user data
//                          packet integrity.
//
BOOL CLine21DecFilter::VerifyATSCUDPacketData(PAM_L21_ATSCUD_PACKET pATSCUDPacket)
{
    if (AM_L21_ATSCUD_HDR_STARTCODE  != GETATSCUD_STARTCODE(pATSCUDPacket->Header) ||  // invalid start code
        AM_L21_ATSCUD_HDR_IDENTIFIER != GETATSCUD_IDENTIFIER(pATSCUDPacket->Header))   // not ATSC Identifier
        return FALSE ;

    if (! ISATSCUD_TYPE_EIA(pATSCUDPacket) )   // not EIA-type CC
        return FALSE ;

    // Either EM or valid CC data is acceptable
    return (ISATSCUD_EM_DATA(pATSCUDPacket) ||             // EM data type  OR
            (ISATSCUD_CC_DATA(pATSCUDPacket)  &&           // CC data type  AND
             GETATSCUD_NUMELEMENTS(pATSCUDPacket) > 0)) ;  // +ve # CC elements
}


//
//  DetectGOPPacketDataType: Private helper method to detect if GOP user data
//                           packet is from a DVD disc, ATSC stream or others.
//
GOPPACKET_CCTYPE CLine21DecFilter::DetectGOPPacketDataType(BYTE *pGOPPacket)
{
    if (VerifyGOPUDPacketData((PAM_L21_GOPUD_PACKET) pGOPPacket))
        return GOP_CCTYPE_DVD ;
    else if (VerifyATSCUDPacketData((PAM_L21_ATSCUD_PACKET) pGOPPacket))
        return GOP_CCTYPE_ATSC ;
    else if (IsFillerPacket(pGOPPacket))
        return GOP_CCTYPE_None ;   // not a valid packet -- just ignore it
    else
        return GOP_CCTYPE_Unknown ; // it's some unknown format of CC packet
}


//
//  IsFillerPacket: Private helper method to check if the packet (at least header)
//                  contains only 0 bytes, which means it's a filler.
//
BOOL CLine21DecFilter::IsFillerPacket(BYTE *pGOPPacket)
{
    DWORD  dwStartCode = ((DWORD)(pGOPPacket[0]) << 24 | \
                          (DWORD)(pGOPPacket[1]) << 16 | \
                          (DWORD)(pGOPPacket[2]) <<  8 | \
                          (DWORD)(pGOPPacket[3])) ;

    // If first 4 bytes of packet is NOT the start code (0x1B2) then it's a filler
    return (AM_L21_GOPUD_HDR_STARTCODE != dwStartCode) ;
}


//
// The Timer Story:
//     We needed 2 timers -- one to fire every 33 mSec for completing scrolling and
//     another to fire after 3 Sec to time out CC in byte pair mode.  But we use
//     the "this" pointer (to the CLine21DecFilter object) as the uEventID in the
//     SetTimer() call so that we can access the filter object's properties in 
//     TimerProc (which is essential).
//     We can't create two different timers (with diff IDs) using the same event ID.
//     So we settled for one timer that fires every 30 mSec (close to 33 mSec). We
//     can set up the timer for 
//         (a) scrolling only (DVD) or (b) scrolling and CC erasing (TV).
//     We maintain a flag to differentiate between these two reasons. If we are in the
//     middle scrolling, we always do that. Otherwise if we opted for (a), we just exit
//     TimerProc(); in case (b), we just increment a counter, then see if it's >= 100 
//     as well as the last output sample we have sent down was a NON-clear one then we
//     create a sample to sent down and also turn off the timer.
//
void CALLBACK CLine21DecFilter::TimerProc(HWND hWnd, UINT uMsg, UINT_PTR uID, DWORD dwTime)
{
    DbgLog((LOG_TRACE, 1, TEXT("CLine21DecFilter::TimerProc(0x%p, 0x%lx, %lu, 0x%lx)"),
            (void*)hWnd, uMsg, uID, dwTime)) ;
    
    //
    // Verify that we are not handling some invalid messages
    //
    if (uMsg != WM_TIMER)
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Who sent us this (%lu) message??"), uMsg)) ;
        return ;
    }
    
    // We specified "this" pointer as the ID to SetTimer() so that we get it here
    CLine21DecFilter *pL21Dec = (CLine21DecFilter *) uID ;
    
    CAutoLock  Lock2(&(pL21Dec->m_csFilter)) ;  // don't mess until we are done
    CAutoLock  Lock1(&(pL21Dec->m_csReceive)) ; // don't receive next sample until we are done
    
    if (0 == pL21Dec->m_uTimerID)  // timer has been killed in between
    {
        // that means we are still rolling; just skip the rest -- it's OK
        DbgLog((LOG_TRACE, 1, TEXT("INFO: Timer killed before TimerProc() kicked in"))) ;
        return ;
    }
 
    BOOL   bClearCC = FALSE ;  // assume we are not doing that here

    // First check if we are scrolling
    if (! pL21Dec->m_L21Dec.IsScrolling() )
    {
        DbgLog((LOG_TRACE, 3, TEXT("TimerProc(): Not scrolling now"))) ;
        if (pL21Dec->m_bTimerClearReqd)  // timer is serving dual purpose
        {
            pL21Dec->m_uTimerCount++ ;
            if (pL21Dec->m_uTimerCount < 100)  // 100 means 3 Secs (with 30 mSec timer)
            {
                DbgLog((LOG_TRACE, 3, TEXT("TimerProc(): Timer reqd to erase CC. But not yet time..."))) ;
                return ;
            }
            else  // time to erase old CC
            {
                if (pL21Dec->m_L21Dec.IsOutDIBClear())  // last sample sent down was clear. Turn off timer and get out
                {
                    DbgLog((LOG_TRACE, 1, TEXT("TimerProc(): Clear sample already sent out. Skip the rest."))) ;
                    pL21Dec->FreeTimer() ;
                    return ;
                }
                else  // clear old CC now
                {
                    DbgLog((LOG_TRACE, 1, TEXT("TimerProc(): Old CC needs to be cleared."))) ;
                    // pL21Dec->m_L21Dec.MakeClearSample() ;
                    pL21Dec->m_L21Dec.FlushInternalStates() ;
                    bClearCC = TRUE ;  // set a flag to test at the end of this function
                }
            }
        }
        else  // not scrolling and timer not for clearing old CC. Get out of here.
        {
            DbgLog((LOG_TRACE, 3, TEXT("TimerProc(): Timer not reqd for erasing CC"))) ;
            return ;
        }
    }
    else  // we are scrolling!!!
    {
        DbgLog((LOG_TRACE, 3, TEXT("TimerProc(): We are scrolling now. Deliver next sample."))) ;
        pL21Dec->m_uTimerCount = 0 ;  // non-clear sample is being sent now. Wait for 3 secs more
    }

    //
    // Looks like we got to send a sample down
    //
    DbgLog((LOG_TRACE, 1, TEXT("*** Preparing output sample in TimerProc() ***"))) ;
    HRESULT  hr ;
    IMediaSample  *pOut ;
    hr = pL21Dec->m_pOutput->GetDeliveryBuffer(&pOut, NULL, NULL, 
        pL21Dec->m_bSampleSkipped ? AM_GBF_PREVFRAMESKIPPED : 0) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: GetDeliveryBuffer() on out pin failed (Error 0x%lx)"), hr)) ;
        return ;
    }
    pL21Dec->Transform(NULL, pOut) ;  // check if output buffer changed, use pIn=NULL
    
    // Copy the reqd scan lines from internal output DIBSection for next output sample
    pL21Dec->m_L21Dec.CopyOutputDIB() ;

    // Set time stamps etc. and increment the timestamps by their current difference
    REFERENCE_TIME  rtDiff = pL21Dec->m_rtStop - pL21Dec->m_rtStart ;
    pL21Dec->m_rtStart = pL21Dec->m_rtStop ;
    pL21Dec->m_rtStop = pL21Dec->m_rtStop + rtDiff ;
    hr = pOut->SetTime(&(pL21Dec->m_rtStart), &(pL21Dec->m_rtStop)) ;
    ASSERT(NOERROR == hr) ;
    pOut->SetSyncPoint(FALSE) ;
    pOut->SetDiscontinuity(pL21Dec->m_bSampleSkipped) ;
    pL21Dec->m_bSampleSkipped = FALSE ;
    
    // Now deliver the next output sample
    pL21Dec->SetBlendingState(TRUE) ;  // turn on blending first
    // Can't call MSR_xxx inside a static member function.
    // MSR_START(m_idDelvWait) ;  // delivering output sample
    hr = pL21Dec->m_pOutput->Deliver(pOut) ;
    // MSR_STOP(m_idDelvWait) ;   // done delivering output sample
    pOut->Release() ;
    DbgLog((LOG_TRACE, 1, TEXT("TimerProc(): Deliver() returned 0x%lx"), hr)) ;
    pL21Dec->m_rtLastSample = pL21Dec->m_rtStart ;  // remember this

    if (SUCCEEDED(hr))  // if out sample was delivered right
    {
        DbgLog((LOG_TRACE, 1, TEXT("*** Delivered %s output sample in TimerProc() (for time %s -> %s) ***"),
            bClearCC ? "clear" : "non-clear", 
            (LPCTSTR)CDisp(pL21Dec->m_rtStart), (LPCTSTR)CDisp(pL21Dec->m_rtStop))) ;
        if (bClearCC)    // if a clear sample was sent down,...
        {
            pL21Dec->FreeTimer() ; // ...we don't need a timer any more.
            pL21Dec->SetBlendingState(FALSE) ;  // turn off blending if clear sample delivered above
        }
    }
}


void CLine21DecFilter::SetupTimerIfReqd(BOOL bTimerClearReqd)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::SetupTimerIfReqd(%s)"),
            bTimerClearReqd ? "TRUE" : "FALSE")) ;
    // CAutoLock   Lock(&m_csFilter) ;

    // If we are running AND either we need CC ime-out or we are scrolling 
    if ( State_Running == m_State  &&
         ( bTimerClearReqd  ||
           m_L21Dec.IsScrolling()) )
    {
        // A callback to TimerProc (a static member fn) every 30 mSec.
        // The "this" pointer is passed in to identify decoder instance.
        // Receiving message window will call the TimerProc to do the work.
        m_uTimerID = SetTimer(m_pMsgWnd->GetHandle(), (DWORD_PTR)(LPVOID)this, 30, NULL /* TimerProc */) ;
        if (0 == m_uTimerID)
        {
            DbgLog((LOG_ERROR, 0, TEXT("WARNING: SetTimer(0x%p, 0x%p, ...) failed (Error %ld)"), 
                (LPVOID)m_pMsgWnd->GetHandle(), (LPVOID)this, GetLastError())) ;
            ASSERT(FALSE) ;
        }
        else
        {
            DbgLog((LOG_TRACE, 5, TEXT("SetTimer(0x%lx, ..) created timer 0x%x (%s CC Timeout)"), 
                m_pMsgWnd->GetHandle(), m_uTimerID, bTimerClearReqd ? "Need" : "No")) ;
            m_bTimerClearReqd = bTimerClearReqd ;
            m_uTimerCount = 0 ;  // init timer count here
        }
    }
    else
        DbgLog((LOG_TRACE, 5, TEXT("Timer NOT started as we are not running/scrolling/NoCC-timeout"))) ;
}


void CLine21DecFilter::FreeTimer(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::FreeTimer()"))) ;
    // CAutoLock   Lock(&m_csFilter) ;

    // If we have a valid timer then release it here
    if (m_uTimerID)
    {
        if (0 == KillTimer(m_pMsgWnd->GetHandle(), m_uTimerID))
        {
            DbgLog((LOG_ERROR, 0, TEXT("ERROR: KillTimer(0x%lx, 0x%x) failed (Error %ld)"), 
                m_pMsgWnd->GetHandle(), m_uTimerID, GetLastError())) ;
            ASSERT(FALSE) ;  // just so that we know
        }
        else
        {
            DbgLog((LOG_TRACE, 3, TEXT("TIMER (Id 0x%x) killed"), m_uTimerID)) ;
            m_uTimerID = 0 ;
            m_bTimerClearReqd = FALSE ;  // reset flag and...
            m_uTimerCount = 0 ;          // counter, just for safety
        }
    }
    else
        DbgLog((LOG_TRACE, 5, TEXT("Timer NOT set -- Timer ID=0x%x"), m_uTimerID)) ;
}


BOOL CLine21DecFilter::IsValidFormat(BYTE *pbFormat)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::IsValidFormat(0x%lx)"), pbFormat)) ;
    // CAutoLock   Lock(&m_csFilter) ; -- can't do that as it may cause deadlock

    if (NULL == pbFormat)
        return FALSE ;

    BITMAPINFOHEADER *lpBMIH = HEADER(pbFormat) ;
    if (! ( 8 == lpBMIH->biBitCount || 16 == lpBMIH->biBitCount || 
           24 == lpBMIH->biBitCount || 32 == lpBMIH->biBitCount) )  // bad bitdepth
        return FALSE ;
    if ( !(BI_RGB == lpBMIH->biCompression || BI_BITFIELDS == lpBMIH->biCompression) ) // bad compression
        return FALSE ;
    if (DIBSIZE(*lpBMIH) != lpBMIH->biSizeImage) // invalid dimensions/size
        return FALSE ;

    return TRUE ;  // hopefully it's a valid video info header
}


void CLine21DecFilter::SetBlendingState(BOOL bState)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::SetBlendingState(%s)"), 
            bState ? "TRUE" : "FALSE")) ;
    // CAutoLock   Lock(&m_csFilter) ;

    if (m_bBlendingState == bState)  // nothing to change
        return ;

    if (NULL == m_pPinDown)
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Downstream pin interface is not available"))) ;
        return ;
    }

    IMixerPinConfig  *pMPC ;
    HRESULT hr = m_pPinDown->QueryInterface(IID_IMixerPinConfig, (LPVOID *)&pMPC) ;
    if (FAILED(hr) || NULL == pMPC)
    {
        DbgLog((LOG_TRACE, 5, TEXT("IMixerPinConfig not available on pin %s"),
                (LPCTSTR) CDisp(m_pPinDown))) ;
        return ;
    }
    
    if (bState)  // turn it on -- CC needs to be mixed
    {
        DbgLog((LOG_TRACE, 5, TEXT("Calling SetBlendingParameter(%lu)"), m_dwBlendParam)) ;
        ASSERT( m_dwBlendParam <= 255) ;
        hr = pMPC->SetBlendingParameter(m_dwBlendParam) ;
        ASSERT(SUCCEEDED(hr)) ;
    }
    else         // turn it off -- CC need NOT be mixed
    {
        hr = pMPC->GetBlendingParameter(&m_dwBlendParam) ;
        ASSERT(SUCCEEDED(hr) && m_dwBlendParam <= 255) ;

        DbgLog((LOG_TRACE, 5, TEXT("Calling SetBlendingParameter(0)"))) ;
        hr = pMPC->SetBlendingParameter(0) ;
        ASSERT(SUCCEEDED(hr)) ;
    }
    m_bBlendingState = bState ;  // save last blending operation flag

    pMPC->Release() ;
}


HRESULT CLine21DecFilter::SendOutputSample(IMediaSample *pIn, 
                                           REFERENCE_TIME *prtStart, REFERENCE_TIME *prtStop)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::SendOutputSample(0x%lx, %s, %s)"), 
        pIn, prtStart ? (LPCTSTR)CDisp(*prtStart) : TEXT("NULL"), 
        prtStop ? (LPCTSTR)CDisp(*prtStop) : TEXT("NULL"))) ;
    
    HRESULT        hr ;
    
    // Get the new sample's bounding rect and compare it to the last one
    BOOL  bMTChangeOK = FALSE ;
    RECT  rectNew ;
    m_L21Dec.CalcOutputRect(&rectNew) ;
    if ( !ISRECTEQUAL(rectNew, m_rectLastOutput) )  // bounding rect changed
    {
        DbgLog((LOG_TRACE, 1, 
            TEXT("Bounding rect changed ((%ld, %ld, %ld, %ld) -> (%ld, %ld, %ld, %ld)). Change mediatype on output sample."),
            m_rectLastOutput.left, m_rectLastOutput.top, m_rectLastOutput.right, m_rectLastOutput.bottom,
            rectNew.left, rectNew.top, rectNew.right, rectNew.bottom)) ;
        VIDEOINFOHEADER *pVIH = (VIDEOINFOHEADER *) (m_mtOutput.Format()) ;
        ASSERT(pVIH) ;
        pVIH->rcSource = rectNew ;
        pVIH->rcTarget = rectNew ;
        if (m_pPinDown && S_OK == (hr = m_pPinDown->QueryAccept((AM_MEDIA_TYPE *) &m_mtOutput)))
        {
            DbgLog((LOG_TRACE, 1, TEXT("Mediatype OK to downstream pin. Rect:(L=%ld, T=%ld, R=%ld, B=%ld)"),
                    rectNew.left, rectNew.top, rectNew.right, rectNew.bottom)) ;  // log trace=3
            bMTChangeOK = TRUE ;
        }
        else
        {
            DbgLog((LOG_TRACE, 1, TEXT("Mediatype NOT acceptable (Error 0x%lx) to downstream pin. Skipping rect spec-ing."), hr)) ;
            pVIH->rcSource = m_rectLastOutput ;  // restore old rect
            pVIH->rcTarget = m_rectLastOutput ;  // restore old rect
        }
    }
    
    // Turn on blending param, Deliver the sample, release mediasample i/f and set blending param
    SetBlendingState(TRUE) ;  // turn it on before delivering next sample

    // Get the output sample address before decoding
    IMediaSample  *pOut ;
    hr = m_pOutput->GetDeliveryBuffer(&pOut, NULL, NULL, 
                        m_bSampleSkipped ? AM_GBF_PREVFRAMESKIPPED : 0) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: GetDeliveryBuffer() on out pin failed (Error 0x%lx)"), hr)) ;
        SetBlendingState(! m_L21Dec.IsOutDIBClear() ) ;  // restore blending state
        return NOERROR ;  // no point complaining -- probably the graph is stopping
    }
    Transform(pIn, pOut) ;  // check if output buffer address changed

    hr = pOut->SetTime(prtStart, prtStop) ;  // set the start & stop time on output sample
    ASSERT(SUCCEEDED(hr)) ;

    // Change the bounding rect ONLY IF the new rect was acceptable above
    if (bMTChangeOK)
    {
        hr = pOut->SetMediaType((AM_MEDIA_TYPE *) &m_mtOutput) ;
        ASSERT(SUCCEEDED(hr)) ;
        m_rectLastOutput = rectNew ; // save this for next round
    }

    // The time stamp and other settings now
    if (NULL == pIn)  // preparing out sample w/o valid in sample
    {
        // We assume that it must be a discontinuity as it's a forced output sample
        pOut->SetSyncPoint(TRUE) ;
        pOut->SetDiscontinuity(TRUE) ;
    }
    else  // input sample is valid 
    {
        LONGLONG  *pllMediaStart, *pllMediaStop ;
        if (SUCCEEDED(pIn->GetMediaTime(&m_llMediaStart, &m_llMediaStop)))
        {
            if (m_llMediaStop < m_llMediaStart + m_rtTimePerSample)
                m_llMediaStop = m_llMediaStart + m_rtTimePerSample ;
            pllMediaStart = (LONGLONG *)&m_llMediaStart ;
            pllMediaStop  = (LONGLONG *)&m_llMediaStop ;
        }
        else
        {
            pllMediaStart = pllMediaStop = NULL ;
        }
        hr = pOut->SetMediaTime(pllMediaStart, pllMediaStop) ;
        ASSERT(NOERROR == hr) ;
        
        pOut->SetSyncPoint(pIn->IsSyncPoint() == S_OK) ;
        pOut->SetDiscontinuity(m_bSampleSkipped ||S_OK == pIn->IsDiscontinuity()) ;
    }
    m_bSampleSkipped = FALSE ;
    
    // Copy output bitmap data to output buffer
    m_L21Dec.CopyOutputDIB() ;

    // Now deliver the output sample
    MSR_START(m_idDelvWait) ;  // delivering output sample
    hr = m_pOutput->Deliver(pOut) ;
    MSR_STOP(m_idDelvWait) ;   // done delivering output sample
    if (FAILED(hr))  // Deliver failed for some reason. Eat the error and just go ahead.
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Deliver() of output sample failed (Error 0x%lx)"), hr)) ;
        // Should we send an error notification to the graph?
    }
    pOut->Release() ;  // release the output sample

    SetBlendingState(! m_L21Dec.IsOutDIBClear() ) ;  // turn off/on based on output clear or not
    
    return NOERROR ;
}


// #define PACKET_DUMP
#ifdef PACKET_DUMP  // only for debug builds
//
// A helper function to dump the GOP Packets with Line21 data for internal debugging ONLY
//
void DumpPacket(PAM_L21_GOPUD_PACKET pGOPUDPacket)
{
    AM_L21_GOPUD_ELEMENT Elem ;
    TCHAR                achBuffer[100] ;
    BOOL                 bDumped = TRUE ;
    int                  iElems = GETGOPUD_NUMELEMENTS(pGOPUDPacket) ;
    
    DbgLog((LOG_TRACE, 0, TEXT("# Elements: %d (%2.2x)"), 
        iElems, pGOPUDPacket->Header.bTopField_Rsrvd_NumElems)) ;
    ZeroMemory(achBuffer, sizeof(achBuffer)) ;  // just to clean it
    for (int i = 0 ; i < iElems ; i++)
    {
        Elem = GETGOPUDPACKET_ELEMENT(pGOPUDPacket, i) ;
        wsprintf(achBuffer + 12 * (i % 6), TEXT("(%2.2x %2.2x %2.2x)"), 
            (int)Elem.bMarker_Switch, (int)Elem.chFirst, (int)Elem.chSecond) ;
        if (GETGOPUD_ELEM_MARKERBITS(Elem) == AM_L21_GOPUD_ELEM_MARKERBITS  &&
            GETGOPUD_ELEM_SWITCHBITS(Elem) == AM_L21_GOPUD_ELEM_VALIDFLAG)
            achBuffer[12 * (i % 6) + 10] = TEXT(' ') ;
        else
            achBuffer[12 * (i % 6) + 10] = TEXT('*') ; // indicates bad marker bit
        achBuffer[12 * (i % 6) + 11] = TEXT(' ') ;     // separator space
        bDumped = FALSE ;  // something not dumped yet
        
        if (0 == (i+1) % 6) // 6 elems per line
        {
            DbgLog((LOG_TRACE, 0, achBuffer)) ;
            bDumped = TRUE ;
        }
    }  // end of for (i)
    
    // if there is something that's not been dumped yet, pad it with NULLs to the end
    // and then dump.
    if (!bDumped)
    {
        ZeroMemory(achBuffer + 12 * (i % 6), sizeof(TCHAR) * (100 - 12 * (i % 6))) ;
        DbgLog((LOG_TRACE, 0, achBuffer)) ;
    }
}


//
// A helper function to dump the ATSC Packets with Line21 data for internal debugging ONLY
//
void DumpATSCPacket(PAM_L21_ATSCUD_PACKET pATSCUDPacket)
{
    AM_L21_ATSCUD_ELEMENT Elem ;
    TCHAR                 achBuffer[100] ;
    BOOL                  bDumped = TRUE ;
    int                   iElems = GETATSCUD_NUMELEMENTS(pATSCUDPacket) ;

    DbgLog((LOG_TRACE, 0, TEXT("Data Flags: %sEM, %sCC, %sAdditional"),
        ISATSCUD_EM_DATA(pATSCUDPacket)   ? TEXT("") : TEXT("Not "),
        ISATSCUD_CC_DATA(pATSCUDPacket)   ? TEXT("") : TEXT("Not "),
        ISATSCUD_ADDL_DATA(pATSCUDPacket) ? TEXT("") : TEXT("Not "))) ;
    DbgLog((LOG_TRACE, 0, TEXT("# Elements: %d"), iElems)) ;
    DbgLog((LOG_TRACE, 0, TEXT("EM Data: 0x%x"), GETATSCUD_EM_DATA(pATSCUDPacket))) ;

    if (ISATSCUD_CC_DATA(pATSCUDPacket))  // if CC data present then dump that
    {
        ZeroMemory(achBuffer, sizeof(achBuffer)) ;  // just to clear it
        for (int i = 0 ; i < iElems ; i++)
        {
            Elem = GETATSCUDPACKET_ELEMENT(pATSCUDPacket, i) ;
            wsprintf(achBuffer + 12 * (i % 6), TEXT("(%2.2x %2.2x %2.2x)"),
                (int)Elem.bCCMarker_Valid_Type, (int)Elem.chFirst, (int)Elem.chSecond) ;
            if (ISATSCUD_ELEM_MARKERBITS_VALID(Elem)  &&  ISATSCUD_ELEM_CCVALID(Elem))
                achBuffer[12 * (i % 6) + 10] = ' ' ;
            else
                achBuffer[12 * (i % 6) + 10] = '*' ; // indicates bad marker bit
            achBuffer[12 * (i % 6) + 11] = ' ' ;     // separator space
            bDumped = FALSE ;  // something not dumped yet

            if (0 == (i+1) % 6) // 6 elems per line
            {
                DbgLog((LOG_TRACE, 0, achBuffer)) ;
                bDumped = TRUE ;
            }
        }  // end of for (i)

        // if there is something that's not been dumped yet, pad it with NULLs to the end
        // and then dump.
        if (!bDumped)
        {
            ZeroMemory(achBuffer + 12 * (i % 6), 100 - 12 * (i % 6)) ;
            DbgLog((LOG_TRACE, 0, achBuffer)) ;
        }
    }

    DbgLog((LOG_TRACE, 0, TEXT("Marker bits: 0x%x"), GETATSCUD_MARKERBITS(pATSCUDPacket))) ;
}

#endif // PACKET_DUMP


HRESULT CLine21DecFilter::ProcessGOPPacket_DVD(IMediaSample *pIn)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::ProcessGOPPacket_DVD(0x%lx)"), pIn)) ;

    HRESULT          hr ;
    REFERENCE_TIME  *prtStart, *prtStop ;
    LONGLONG        *pllMediaStart, *pllMediaStop ;
    LONGLONG         llMediaInterval ;
    BOOL             bCapUpdated ;         // has caption been updated?

    // Get the input data packet and verify that the contents are OK
    PAM_L21_GOPUD_PACKET  pGOPUDPacket ;
    hr = pIn->GetPointer((LPBYTE *)&pGOPUDPacket) ;
    ASSERT(hr == NOERROR) ;
    if (! VerifyGOPUDPacketData(pGOPUDPacket) )
    {
        DbgLog((LOG_ERROR, 0, TEXT("Packet verification failed"))) ;
        return S_FALSE ;
    }
    if (pIn->GetActualDataLength() != GETGOPUD_PACKETSIZE(pGOPUDPacket))
    {
        DbgLog((LOG_ERROR, 0,
            TEXT("pIn->GetActualDataLength() [%d] and data size [%d] in packet mismatched"),
            pIn->GetActualDataLength(), GETGOPUD_PACKETSIZE(pGOPUDPacket))) ;
        return S_FALSE ;
    }
    
#ifdef PACKET_DUMP
    DumpPacket(pGOPUDPacket) ;
#endif // PACKET_DUMP

    // The checks are done.
    AM_L21_GOPUD_ELEMENT    Elem ;
    REFERENCE_TIME          rtInterval ;
    int     iElems = GETGOPUD_NUMELEMENTS(pGOPUDPacket) ;
    if (0 == iElems)
    {
        ASSERT(iElems > 0) ;
        return S_OK ;
    }
    
    if (NOERROR == pIn->GetTime(&m_rtStart, &m_rtStop))
    {
        //
        // We need at least 16.7msec/frame in the GOP for each bytepair
        //
        REFERENCE_TIME   rtTemp ;
        rtTemp = m_rtStart + m_rtTimePerSample * iElems ;
        DbgLog((LOG_TRACE, 3, TEXT("Received an input sample (Start=%s, Stop=%s (%s)) discon(%d)"),
            (LPCTSTR)CDisp(m_rtStart), (LPCTSTR)CDisp(rtTemp), (LPCTSTR)CDisp(m_rtStop),
            S_OK == pIn->IsDiscontinuity())) ;
        if (m_rtStop < rtTemp)
            m_rtStop = rtTemp ;
        
        prtStart = (REFERENCE_TIME *)&m_rtStart ;
        prtStop  = (REFERENCE_TIME *)&m_rtStop ;
        rtInterval = (m_rtStop - m_rtStart) / iElems ;
    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("Received an input sample with no timestamp"))) ;
        prtStart = prtStop  = NULL ;
        rtInterval = 0 ;
    }
    
    if (SUCCEEDED(pIn->GetMediaTime(&m_llMediaStart, &m_llMediaStop)))
    {
        //
        // We need at least 33msec/frame in the GOP for each bytepair
        //
        LONGLONG   llTemp ;
        llTemp = m_llMediaStart + m_rtTimePerSample * iElems ;
        if (m_llMediaStop < llTemp)
            m_llMediaStop = llTemp ;
        pllMediaStart   = (LONGLONG *)&m_llMediaStart ;
        pllMediaStop    = (LONGLONG *)&m_llMediaStop ;
        llMediaInterval = (m_llMediaStop - m_llMediaStart) / iElems ;
    }
    else
    {
        pllMediaStart = pllMediaStop = NULL ;
        llMediaInterval = 0 ;
    }
    
    BOOL   bFoundGood = FALSE ;  // until a pair is decoded successfully
    BOOL   bReady ;
    BOOL   bTopFirst = ISGOPUD_TOPFIELDFIRST(pGOPUDPacket) ;
    DbgLog((LOG_TRACE, 5,
            TEXT("Got a Line21 packet with %d elements, %s field first"),
            iElems, bTopFirst ? "Top" : "Bottom")) ;
    for (int i = bTopFirst ? 0 : 1 ;  // if top field is not first,
         i < iElems ; i++)            // pick next field to start with
    {
        m_rtStop = m_rtStart + rtInterval ;  // m_rtTimePerSample ;
        m_llMediaStop = m_llMediaStart + llMediaInterval ;
        Elem = GETGOPUDPACKET_ELEMENT(pGOPUDPacket, i) ;
        if (GETGOPUD_ELEM_MARKERBITS(Elem) == AM_L21_GOPUD_ELEM_MARKERBITS  &&
            GETGOPUD_ELEM_SWITCHBITS(Elem) == AM_L21_GOPUD_ELEM_VALIDFLAG)
        {
            //
            // In the WB titles the bottom field's data has wrong marker 
            // bit set so that we don't try to decode them. But the titles
            // from Columbia/Tristar (and God knows who else) doesn't do
            // that causing us to look at every field's data which causes
            // CC to flash away with the arrival of the next EOC (14 2F),
            // because it's not recognized as the repeat of the last EOC
            // due to the (0, 0) pair with valid marker bit. So we knowingly
            // skip the alternate field's data to avoid this problem.
            //
            if ( (bTopFirst  && (i & 0x01))  ||     // top first & odd index
                 (!bTopFirst && 0 == (i & 0x01)) )  // bottom first & even index
            {
                DbgLog((LOG_TRACE, 5,
                    TEXT("(0x%x, 0x%x) decode skipped for element %d -- the 'other' field"),
                    Elem.chFirst, Elem.chSecond, i)) ;
                // Advance the time stamps anyway
                m_rtStart = m_rtStop ;
                m_llMediaStart = m_llMediaStop ;
                continue ;
            }

            // Now decode this element; if fails (i.e, bad data), just
            // ignore it and try the next element.
            if (! m_L21Dec.DecodeBytePair(Elem.chFirst, Elem.chSecond) )
            {
                // if we must output a sample because:
                // a) we haven't sent down any sample in this play session  or
                // b) we need to refresh the output because some component
                //    set this flag, e.g, 
                //    * SetServiceState(.._Off)  or 
                //    * we got a discontinuity sample
                //    * no valid packet came for last 3 secs
                // So we must deliver one output sample with current caption content.
                if (m_bMustOutput)
                {
                    DbgLog((LOG_TRACE, 1,
                        TEXT("(0x%x, 0x%x) decode failed, but allowing one output sample"),
                        Elem.chFirst, Elem.chSecond)) ;
                }
                else if (m_L21Dec.IsScrolling())
                {
                    DbgLog((LOG_TRACE, 5, 
                        TEXT("(0x%x, 0x%x) decode failed, but scrolling now; so..."),
                        Elem.chFirst, Elem.chSecond)) ;
                }
                else
                {
                    DbgLog((LOG_TRACE, 5, TEXT("(0x%x, 0x%x) decode failed"),
                        Elem.chFirst, Elem.chSecond)) ;
                    
                    // We need to increment the time stamp though;
                    // stop time for this sample is start time for next sample
                    m_rtStart = m_rtStop ;
                    m_llMediaStart = m_llMediaStop ;
                    continue ;  // bad data; proceed to next pair...
                }
            }
            else
            {
                bFoundGood = TRUE ;    // got one good pair
                DbgLog((LOG_TRACE, 5, TEXT("(0x%x, 0x%x) decode succeeded"),
                    Elem.chFirst, Elem.chSecond)) ;
            }
            
            // If we are in non-PopOn mode, update caption, if reqd.
            bCapUpdated = m_L21Dec.UpdateCaptionOutput() ;
            
            // Output a sample only if either
            // a) we must output (the flag is set)   or
            // b) we are in non-PopOn mode and need to update captions   or
            // c) we are in the middle of scrolling   or
            // d) we are in PopOn mode AND caption needs to/should be updated
            if (m_bMustOutput ||                      // (a)
                bCapUpdated   ||                      // (b)
                m_L21Dec.IsScrolling() ||             // (c)
                (bReady = m_L21Dec.IsOutputReady())) // (d)
            {
                DbgLog((LOG_TRACE, 3,
                    TEXT("Preparing output sample because Must=%s, CapUpdtd=%s, Ready=%s"),
                    m_bMustOutput ? "T" : "F", bCapUpdated ? "T" : "F", bReady ? "T" : "F")) ;
                
                // Now send the output sample down
                hr = SendOutputSample(pIn, prtStart, prtStop) ;
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR, 0, TEXT("WARNING: Sending output sample failed (Error 0x%lx)"), hr)) ;
                    // return hr ;
                }
                else
                {
                    DbgLog((LOG_TRACE, 3, 
                        TEXT("Delivered an output sample (Time: Start=%s, Stop=%s)"),
                        (LPCTSTR)CDisp(m_rtStart), (LPCTSTR)CDisp(m_rtStop))) ;
                    m_bMustOutput = FALSE;     // we have output just now
                }
                
                // The DVD titles don't turn off caption when there is no conversation.
                // So we keep track of when we delivered the last output sample, so that
                // in 3 seconds if we don't get the next valid input packet, we flush our
                // buffers and clear CC output by forced delivery of a clear sample.
                m_rtLastSample = m_rtStart ;  // remember this
                
            }  // end of if (should/must we output?)
        }
        else
            DbgLog((LOG_TRACE, 5,
                TEXT("Ignored an element (0x%x, 0x%x, 0x%x) with invalid flag"),
                Elem.bMarker_Switch, Elem.chFirst, Elem.chSecond)) ;
        
        // stop time for this sample is start time for next sample
        m_rtStart = m_rtStop ;
        m_llMediaStart = m_llMediaStop ;
    }  // end of for(i)
    
    //
    // Flush the current caption buffer contents and set the 
    // "must output on next chance" flag so that a clear sample is 
    // delivered next time around, if
    // a) we didn't find any good pair in this packet   AND 
    // b) the last sample we sent down wasn't a clear sample   AND
    // c) it has already been 3 seconds since we sent the last output sample
    //
    if ( ! bFoundGood   && 
         ! m_L21Dec.IsOutDIBClear()  &&
         (m_rtStart > m_rtLastSample + (LONGLONG)30000000))
    {
        DbgLog((LOG_TRACE, 1, TEXT("Long gap after last sample. Clearing CC. (Good=%s, Clear=%s)"),
                bFoundGood ? "T" : "F", m_L21Dec.IsOutDIBClear() ? "T" : "F")) ;
        // m_L21Dec.MakeClearSample() ;
        m_L21Dec.FlushInternalStates() ;
        m_bMustOutput = TRUE ;
    }

    return S_OK ;
}


HRESULT CLine21DecFilter::ProcessGOPPacket_ATSC(IMediaSample *pIn)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::ProcessGOPPacket_ATSC(0x%lx)"), pIn)) ;

    HRESULT          hr ;
    REFERENCE_TIME  *prtStart, *prtStop ;
    LONGLONG        *pllMediaStart, *pllMediaStop ;
    LONGLONG         llMediaInterval ;
    BOOL             bCapUpdated ;         // has caption been updated?

    // Get the input data packet and verify that the contents are OK
    PAM_L21_ATSCUD_PACKET pATSCUDPacket ;
    
    // Get the input data packet and verify that the contents are OK
    hr = pIn->GetPointer((LPBYTE *)&pATSCUDPacket) ;
    ASSERT(hr == NOERROR) ;
    if (! VerifyATSCUDPacketData(pATSCUDPacket) )
    {
        DbgLog((LOG_ERROR, 0, TEXT("ATSC Packet verification failed"))) ;
        return S_FALSE ;
    }
    if (pIn->GetActualDataLength() < GETATSCUD_PACKETSIZE(pATSCUDPacket))
    {
        DbgLog((LOG_ERROR, 0,
            TEXT("pIn->GetActualDataLength() [%d] is less than minm ATSC packet data size [%d]"),
            pIn->GetActualDataLength(), GETATSCUD_PACKETSIZE(pATSCUDPacket))) ;
        return S_FALSE ;
    }
    
#ifdef PACKET_DUMP
    DumpATSCPacket(pATSCUDPacket) ;
#endif // PACKET_DUMP

    // The checks are done.
    AM_L21_ATSCUD_ELEMENT    Elem ;
    REFERENCE_TIME           rtInterval ;
    int     iElems = GETATSCUD_NUMELEMENTS(pATSCUDPacket) ;
    if (0 == iElems)
    {
        ASSERT(iElems > 0) ;
        return S_OK ;
    }
    
    if (NOERROR == pIn->GetTime(&m_rtStart, &m_rtStop))
    {
        //
        // We need at least 16.7msec/frame in the ATSC for each bytepair
        //
        REFERENCE_TIME   rtTemp ;
        rtTemp = m_rtStart + m_rtTimePerSample * iElems ;
        DbgLog((LOG_TRACE, 3, TEXT("Received an input sample (Start=%s, Stop=%s (%s)) discon(%d)"),
            (LPCTSTR)CDisp(m_rtStart), (LPCTSTR)CDisp(rtTemp), (LPCTSTR)CDisp(m_rtStop),
            S_OK == pIn->IsDiscontinuity())) ;
        if (m_rtStop < rtTemp)
            m_rtStop = rtTemp ;
        
        prtStart = (REFERENCE_TIME *)&m_rtStart ;
        prtStop  = (REFERENCE_TIME *)&m_rtStop ;
        rtInterval = (m_rtStop - m_rtStart) / iElems ;
    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("Received an input sample with no timestamp"))) ;
        prtStart = prtStop  = NULL ;
        rtInterval = 0 ;
    }
    
    if (SUCCEEDED(pIn->GetMediaTime(&m_llMediaStart, &m_llMediaStop)))
    {
        //
        // We need at least 33msec/frame in the ATSC for each bytepair
        //
        LONGLONG   llTemp ;
        llTemp = m_llMediaStart + m_rtTimePerSample * iElems ;
        if (m_llMediaStop < llTemp)
            m_llMediaStop = llTemp ;
        pllMediaStart   = (LONGLONG *)&m_llMediaStart ;
        pllMediaStop    = (LONGLONG *)&m_llMediaStop ;
        llMediaInterval = (m_llMediaStop - m_llMediaStart) / iElems ;
    }
    else
    {
        pllMediaStart = pllMediaStop = NULL ;
        llMediaInterval = 0 ;
    }
    
    BOOL   bFoundGood = FALSE ;  // until a pair is decoded successfully
    BOOL   bReady ;
    for (int i = 0 ; i < iElems ; i++)
    {
        m_rtStop = m_rtStart + rtInterval ;  // m_rtTimePerSample ;
        m_llMediaStop = m_llMediaStart + llMediaInterval ;
        Elem = GETATSCUDPACKET_ELEMENT(pATSCUDPacket, i) ;
        if (ISATSCUD_ELEM_MARKERBITS_VALID(Elem)  &&  ISATSCUD_ELEM_CCVALID(Elem))
        {
            // Now decode this element; if fails (i.e, bad data), just
            // ignore it and try the next element.
            if (! m_L21Dec.DecodeBytePair(Elem.chFirst, Elem.chSecond) )
            {
                // if we must output a sample because:
                // a) we haven't sent down any sample in this play session  or
                // b) we need to refresh the output because some component
                //    set this flag, e.g, 
                //    * SetServiceState(.._Off)  or 
                //    * we got a discontinuity sample
                //    * no valid packet came for last 3 secs
                // So we must deliver one output sample with current caption content.
                if (m_bMustOutput)
                {
                    DbgLog((LOG_TRACE, 1,
                        TEXT("(0x%x, 0x%x) decode failed, but allowing one output sample"),
                        Elem.chFirst, Elem.chSecond)) ;
                }
                else if (m_L21Dec.IsScrolling())
                {
                    DbgLog((LOG_TRACE, 5, 
                        TEXT("(0x%x, 0x%x) decode failed, but scrolling now; so..."),
                        Elem.chFirst, Elem.chSecond)) ;
                }
                else
                {
                    DbgLog((LOG_TRACE, 5, TEXT("(0x%x, 0x%x) decode failed"),
                        Elem.chFirst, Elem.chSecond)) ;
                    
                    // We need to increment the time stamp though;
                    // stop time for this sample is start time for next sample
                    m_rtStart = m_rtStop ;
                    m_llMediaStart = m_llMediaStop ;
                    continue ;  // bad data; proceed to next pair...
                }
            }
            else
            {
                bFoundGood = TRUE ;    // got one good pair
                DbgLog((LOG_TRACE, 5, TEXT("(0x%x, 0x%x) decode succeeded"),
                    Elem.chFirst, Elem.chSecond)) ;
            }
            
            // If we are in non-PopOn mode, update caption, if reqd.
            bCapUpdated = m_L21Dec.UpdateCaptionOutput() ;
            
            // Output a sample only if either
            // a) we must output (the flag is set)   or
            // b) we are in non-PopOn mode and need to update captions   or
            // c) we are in the middle of scrolling   or
            // d) we are in PopOn mode AND caption needs to/should be updated
            if (m_bMustOutput ||                      // (a)
                bCapUpdated   ||                      // (b)
                m_L21Dec.IsScrolling() ||             // (c)
                (bReady = m_L21Dec.IsOutputReady())) // (d)
            {
                DbgLog((LOG_TRACE, 3,
                    TEXT("Preparing output sample because Must=%s, CapUpdtd=%s, Ready=%s"),
                    m_bMustOutput ? "T" : "F", bCapUpdated ? "T" : "F", bReady ? "T" : "F")) ;
                
                // Now send the output sample down
                hr = SendOutputSample(pIn, prtStart, prtStop) ;
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR, 0, TEXT("WARNING: Sending output sample failed (Error 0x%lx)"), hr)) ;
                    // return hr ;
                }
                else
                {
                    DbgLog((LOG_TRACE, 3, 
                        TEXT("Delivered an output sample (Time: Start=%s, Stop=%s)"),
                        (LPCTSTR)CDisp(m_rtStart), (LPCTSTR)CDisp(m_rtStop))) ;
                    m_bMustOutput = FALSE;     // we have output just now
                }
                
                // The DVD titles don't turn off caption when there is no conversation.
                // So we keep track of when we delivered the last output sample, so that
                // in 3 seconds if we don't get the next valid input packet, we flush our
                // buffers and clear CC output by forced delivery of a clear sample.
                m_rtLastSample = m_rtStart ;  // remember this
                
            }  // end of if (should/must we output?)
        }
        else
            DbgLog((LOG_TRACE, 5,
                TEXT("Ignored an element (0x%x, 0x%x, 0x%x) with invalid marker/type flag"),
                Elem.bCCMarker_Valid_Type, Elem.chFirst, Elem.chSecond)) ;
        
        // stop time for this sample is start time for next sample
        m_rtStart = m_rtStop ;
        m_llMediaStart = m_llMediaStop ;
    }  // end of for(i)
    
    //
    // Flush the current caption buffer contents and set the 
    // "must output on next chance" flag so that a clear sample is 
    // delivered next time around, if
    // a) we didn't find any good pair in this packet   AND 
    // b) the last sample we sent down wasn't a clear sample   AND
    // c) it has already been 3 seconds since we sent the last output sample
    //
    if ( ! bFoundGood   && 
         ! m_L21Dec.IsOutDIBClear()  &&
         (m_rtStart > m_rtLastSample + (LONGLONG)30000000))
    {
        DbgLog((LOG_TRACE, 1, TEXT("Long gap after last sample. Clearing CC. (Good=%s, Clear=%s)"),
                bFoundGood ? "T" : "F", m_L21Dec.IsOutDIBClear() ? "T" : "F")) ;
        // m_L21Dec.MakeClearSample() ;
        m_L21Dec.FlushInternalStates() ;
        m_bMustOutput = TRUE ;
    }

    return S_OK ;
}


//
//  Receive: It's the real place where the output samples are created by
//           decoding the byte pairs out of the input stream.
//
HRESULT CLine21DecFilter::Receive(IMediaSample * pIn)
{
    CAutoLock   lock(&m_csReceive);
    HRESULT     hr ;
    
    DbgLog((LOG_TRACE, 3, TEXT("CLine21DecFilter::Receive(0x%p)"), pIn)) ;

    //
    // First check if we must do anything at all
    //
    if (!m_bMustOutput  &&                                         // not a must output
        (AM_L21_CCSTATE_Off    == m_L21Dec.GetServiceState()  ||   // CC turned off
         AM_L21_CCSERVICE_None == m_L21Dec.GetCurrentService()))   // no CC selected
    {
        DbgLog((LOG_TRACE, 1, 
            TEXT("Captioning is off AND we don't HAVE TO output. Skipping everything."))) ;
        return NOERROR ;  // we are done with this sample
    }

    // Get the input format info; we'll use the same for output
    ASSERT(m_pOutput != NULL) ;
    
    //
    // The real decoding part is here
    //
    REFERENCE_TIME       *prtStart, *prtStop ;
    BYTE                 *pbInBytePair = NULL ;  // to shut up compiler
    LONG                  lInDataSize ;
    BOOL                  bCapUpdated ;         // has caption been updated?
    
    //
    // Process the sample based on filter's input format type
    //
    switch (m_eSubTypeIDIn)
    {
    case AM_L21_CCSUBTYPEID_BytePair:
        {
            hr = pIn->GetPointer(&pbInBytePair) ;      // Get the input byte pair
            lInDataSize = pIn->GetActualDataLength() ; // se how much data we got
            if (FAILED(hr)  ||  2 != lInDataSize)  // bad data -- complain and just skip it
            {
                DbgLog((LOG_ERROR, 0, TEXT("%d bytes of data sent as Line21 data (hr = 0x%lx)"), 
                    lInDataSize, hr)) ;
                break ;
            }
            
            //
            // m_rtTimePerSample is set to 166833 for DVD GOP packet case.
            // We don't use this member's value here.  If we need in future,
            // we have to set some suitable value here.
            //
            
            if (NOERROR == (hr = pIn->GetTime(&m_rtStart, &m_rtStop)))
            {
                prtStart = (REFERENCE_TIME *)&m_rtStart ;
                prtStop  = (REFERENCE_TIME *)&m_rtStop ;
            }
            else
            {
                DbgLog((LOG_TRACE, 0, TEXT("WARNING: GetTime() failed (Error 0x%lx)"), hr)) ;
                prtStart = prtStop  = NULL ;
            }

            //
            // We are here with some data; so don't need a timer for now
            //
            FreeTimer() ;

            hr = pIn->IsDiscontinuity() ;
            if (S_OK == hr)  // got a discontinuity; flush everything, refresh output
            {
                // If we got a discontinuity in the last sample, we flushed and all.
                // We can skip this one safely.
                if (m_bDiscontLast)
                {
                    DbgLog((LOG_TRACE, 1, TEXT("Got a discontinuity sample after another. Skipping everything."))) ;
                    break ;
                }

                // Flush the internal buffers (caption and output DIB section)
                DbgLog((LOG_TRACE, 0, TEXT("Got a discontinuity sample. Flushing all data..."))) ;
                m_L21Dec.FlushInternalStates() ;
                
                // Send the clear sample down as output
                hr = SendOutputSample(pIn, prtStart, prtStop) ;
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR, 0, TEXT("WARNING: Sending output sample failed (Error 0x%lx)"), hr)) ;
                    return hr ;
                }
                m_rtLastSample = m_rtStart ;  // remember this
                m_bDiscontLast = TRUE ;       // remember we handled a discontinuity
                DbgLog((LOG_TRACE, 1, TEXT("Sent a clear sample for discont."))) ;
                break ;
            }
            DbgLog((LOG_TRACE, 3, TEXT("Got sample with bytes 0x%x, 0x%x (Time: %s -> %s)"),
                    pbInBytePair[0], pbInBytePair[1],
                    (LPCTSTR)CDisp(m_rtStart), (LPCTSTR)CDisp(m_rtStop))) ; // log trace=?
            m_bDiscontLast = FALSE ;       // remember we got a normal sample
            
            // Now decode into the received output sample buffer; if fails, we don't
            // need to do the rest, mostly.
            if (! m_L21Dec.DecodeBytePair(pbInBytePair[0], pbInBytePair[1]) )
            {
                // if we must output a sample such as:
                // a) if we haven't sent down any sample in this play session
                // b) if some component set this flag (e.g, SetServiceState(.._Off)
                //    and as a result we need to refresh the output
                // we need to deliver one output sample with current caption content.
                if (m_bMustOutput)
                {
                    DbgLog((LOG_TRACE, 1,
                        TEXT("(0x%x, 0x%x) decode failed, but allowing one output sample"),
                        pbInBytePair[0], pbInBytePair[1])) ;
                }
                else if (m_L21Dec.IsScrolling())
                {
                    DbgLog((LOG_TRACE, 5, 
                        TEXT("(0x%x, 0x%x) decode failed, but scrolling now; so..."),
                        pbInBytePair[0], pbInBytePair[1])) ;
                }
                else
                {
                    DbgLog((LOG_TRACE, 3, TEXT("(0x%x, 0x%x) decode failed"),
                        pbInBytePair[0], pbInBytePair[1])) ;

                    //
                    // Flush the current caption buffer contents and set the 
                    // "must output on next chance" flag so that a clear sample is 
                    // delivered by the code below, if
                    // a) the last sample we sent down wasn't a clear sample   AND
                    // b) it has already been 6 seconds since we sent the last output sample
                    //
                    if ( ! m_L21Dec.IsOutDIBClear()  &&
                         (m_rtStart > m_rtLastSample + (LONGLONG)60000000))
                    {
                        DbgLog((LOG_TRACE, 0, 
                            TEXT("Long gap after last sample. Clearing CC. (Clear=%s)"),
                            m_L21Dec.IsOutDIBClear() ? "T" : "F")) ;
                        // m_L21Dec.MakeClearSample() ;  --- I would rather flush everything
                        m_L21Dec.FlushInternalStates() ;
                        m_bMustOutput = TRUE ;  // will be delivered below...
                    }
                    // else         // it was just bad data; ignore it and ...
                    //     break ;  // ...proceed to next pair
                }
            }
            else
            {
                DbgLog((LOG_TRACE, 5, TEXT("(0x%x, 0x%x) decode succeeded"),
                        pbInBytePair[0], pbInBytePair[1])) ;
                m_rtLastSample = m_rtStart ;  // remember last valid byte pair time
            }
            
            // Update caption output for non-PopOn mode, if reqd.
            bCapUpdated = m_L21Dec.UpdateCaptionOutput() ;
            
            // Output a sample only if either
            // a) we must output (the flag is set)   or
            // b) we are in non-PopOn mode and need to update captions   or
            // c) we are in the middle of scrolling   or
            // d) we are in PopOn mode AND caption needs to/should be updated
            if (m_bMustOutput ||            // (a)
                bCapUpdated ||              // (b)
                m_L21Dec.IsScrolling() ||   // (c)
                m_L21Dec.IsOutputReady())  // (d)
            {
                hr = SendOutputSample(pIn, prtStart, prtStop) ;
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR, 0, TEXT("WARNING: Sending output sample failed (Error 0x%lx)"), hr)) ;
                    // return hr ;
                }
                else
                {
                    m_bMustOutput = FALSE ;  // we have successfully output a sample
                    m_rtLastSample = m_rtStart ;  // remember this
                    DbgLog((LOG_TRACE, 3, TEXT("Output sample delivered for (0x%x, 0x%x)"),
                            pbInBytePair[0], pbInBytePair[1])) ;
                }
            }  // end if (must/should we output?)
            
            //
            // If we are scrolling, we may need a timer to later tell us it's 
            // time to produce and deliver more output samples, even though there
            // is no input data coming in.
            //
            SetupTimerIfReqd(TRUE) ;  //  CC time-out reqd
            
            break ;
        }
        
        case AM_L21_CCSUBTYPEID_VBIRawData:
            DbgLog((LOG_TRACE, 1, TEXT("Raw byte pair case has not been implemented yet"))) ;
            break ;
            
        case AM_L21_CCSUBTYPEID_GOPPacket:
            {
                //
                // We are here with some data; so don't need a timer for now
                //
                FreeTimer() ;

                // First check if this is a discontinuity sample. If so just clear everything
                hr = pIn->IsDiscontinuity() ;
                if (S_OK == hr)  // got a discontinuity; flush everything, refresh output
                {
                    // If we got a discontinuity in the last sample, we flushed and all.
                    // We can skip this one safely.
                    if (m_bDiscontLast)
                    {
                        DbgLog((LOG_TRACE, 1, TEXT("Got a discontinuity sample after another. Skipping everything."))) ;
                        break ;
                    }

                    if (NOERROR == pIn->GetTime(&m_rtStart, &m_rtStop))
                    {
                        if (m_rtStop < m_rtStart + m_rtTimePerSample)
                            m_rtStop = m_rtStart + m_rtTimePerSample ;
                        DbgLog((LOG_TRACE, 0, TEXT("Received a **discontinuity** : Start=%s, Stop=%s"),
                            (LPCTSTR)CDisp(m_rtStart), (LPCTSTR)CDisp(m_rtStop))) ;
                    }
                    else  // cook up something reasonable
                    {
                        m_rtStart = (REFERENCE_TIME) 0 ;
                        m_rtStop = m_rtStart + m_rtTimePerSample ;
                        DbgLog((LOG_TRACE, 1, TEXT("Cooked up **discontinuity** time as Start=%s, Stop=%s"),
                            (LPCTSTR)CDisp(m_rtStart), (LPCTSTR)CDisp(m_rtStop))) ;
                    }
                    prtStart = (REFERENCE_TIME *)&m_rtStart ;
                    prtStop  = (REFERENCE_TIME *)&m_rtStop ;
                    
                    // Flush the internal buffers (caption and output DIB section)
                    m_L21Dec.FlushInternalStates() ;
                    
                    // Now send the clear sample down
                    hr = SendOutputSample(pIn, prtStart, prtStop) ;
                    if (FAILED(hr))
                    {
                        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Sending clear output sample failed (Error 0x%lx)"), hr)) ;
                        // return hr ;
                    }
                    else
                    {
                        DbgLog((LOG_TRACE, 0, TEXT("Clear output sample delivered for discont."))) ;
                        m_bMustOutput = FALSE ;  // we have just delivered an output sample
                        m_bDiscontLast = TRUE ;  // we handled a disocntinuity sample
                        m_rtLastSample = m_rtStart ;  // remember this
                    }
                    
                    m_rtStart = m_rtStop ;
                    m_llMediaStart = m_llMediaStop ;
                }
                else
                {
                    DbgLog((LOG_TRACE, 5, TEXT("Got a normal CC data sample"))) ;
                    m_bDiscontLast = FALSE ;  // got a normal sample
                }
                
                //
                // Even if it's a discontinuity sample it may have some data too (??).
                // Handle as necessary.  No harm in checking!!!
                //

                BYTE *pbGOPPacket ;
                hr = pIn->GetPointer((LPBYTE *)&pbGOPPacket) ;
                ASSERT(hr == NOERROR) ;
                GOPPACKET_CCTYPE  eGOP_CCType = DetectGOPPacketDataType(pbGOPPacket) ;
                if (GOP_CCTYPE_None != eGOP_CCType  && // NOT filler CC packet  AND...
                    m_eGOP_CCType   != eGOP_CCType)    // change of CC type
                {
                    DbgLog((LOG_TRACE, 3, TEXT("GOPPacket CC type changed from %d to %d"), 
                            m_eGOP_CCType, eGOP_CCType)) ;

                    // Flush internal caption buffers and output sample buffer
                    m_L21Dec.FlushInternalStates() ; // clear CC internal data buffers
                    m_L21Dec.FillOutputBuffer() ;    // clear existing CC on output sample
                    m_bMustOutput  = TRUE ;          // we must output a sample NOW

                    m_eGOP_CCType = eGOP_CCType ;    // switch to new CC type
                }

                switch (m_eGOP_CCType)
                {
                case GOP_CCTYPE_DVD:
                    hr = ProcessGOPPacket_DVD(pIn) ;
                    break ;

                case GOP_CCTYPE_ATSC:
                    hr = ProcessGOPPacket_ATSC(pIn) ;
                    break ;

                default:
                    DbgLog((LOG_TRACE, 3, TEXT("Unknown GOP packet data type (%d)"), m_eGOP_CCType)) ;
                    break ;
                }  // end of switch (.._CCType)

                //
                // If we are scrolling, we may need a timer to later tell us it's 
                // time to produce and deliver more output samples, even though there
                // is no input data coming in.
                //
                SetupTimerIfReqd(FALSE) ;  // CC time-out NOT reqd as (invalid) data keeps coming
                
                break ;
        }  // end of case ..._GOPPacket

        default:  // it's a bad data format type (how could we get into it?)
            DbgLog((LOG_ERROR, 0, TEXT("We are in a totally unexpected format type"))) ;
            return E_FAIL ;  // or E_UNEXPECTED ; ???
    }
    
    //
    // Decoding for this sample is done
    //
    
    return NOERROR ;
}


//
//  Transform: It's mainly a place holder because we HAVE to override it.
//             The actual work is done in Receive() itself. Here we detect
//             if the buffer addres provided by downstream filter's allocator
//             has changed or not; if yes, we have to re-write entire text.
//
HRESULT CLine21DecFilter::Transform(IMediaSample * pIn, IMediaSample * pOut)
{
    DbgLog((LOG_TRACE, 3, TEXT("CLine21DecFilter::Transform(0x%p, 0x%p)"), 
            pIn, pOut)) ;
    
    UNREFERENCED_PARAMETER(pIn) ;
    
    HRESULT   hr ;
    LPBITMAPINFO       lpbiNew ;
    BITMAPINFOHEADER   biCurr ;
    
    // Check if there has been any dynamic format change; if so, adjust output
    // width, height, bitdepth accordingly.
    AM_MEDIA_TYPE  *pmt ;
    hr = pOut->GetMediaType(&pmt) ;
    ASSERT(SUCCEEDED(hr)) ;
    if (S_OK == hr)  // i.e, format has changed
    {
        hr = pOut->SetMediaType(NULL) ; // just to tell OverlayMixer, I am not changing again
        ASSERT(SUCCEEDED(hr)) ;
        m_mtOutput = *pmt ;
        lpbiNew = (LPBITMAPINFO) HEADER(((VIDEOINFO *)(pmt->pbFormat))) ;
        m_L21Dec.GetOutputFormat(&biCurr) ;
        if (0 != memcmp(lpbiNew, &biCurr, sizeof(BITMAPINFOHEADER)))
        {
            // output format has been changed -- update our internel values now
            DbgLog((LOG_TRACE, 2, TEXT("Output format has been dynamically changed"))) ;
            m_L21Dec.DeleteOutputDC() ;  // delete current DIB section first
            m_L21Dec.SetOutputOutFormat(lpbiNew) ;
            GetDefaultFormatInfo() ;  // to pick any change in format data
            
            //
            // We must be running/paused; so we need to create internal DIB section
            //
            ASSERT(m_State != State_Stopped) ;
            if (m_State != State_Stopped)
            {
                if (! m_L21Dec.CreateOutputDC() )  // new DIBSection creation failed
                {
                    DbgLog((LOG_ERROR, 0, TEXT("CreateOutputDC() failed!!!"))) ;
                    return E_UNEXPECTED ;
                }
            }
            
            //
            // If key color has changed, we need to use the new color from now
            //
#pragma message("Most probably the following call is redundant (and risky)")
            DbgLog((LOG_TRACE, 0, TEXT("Should have called GetColorKey() in dyna format change"))) ;
            // GetActualColorKey() ;
        }
        
        m_pOutput->CurrentMediaType() = *pmt ;
        DeleteMediaType(pmt) ;
    }
    
    // Check if the out put buffer has changed; if so, store new buffer address
    LPBYTE      pbOutBuffer ;
    pOut->GetPointer(&pbOutBuffer) ;
    if (m_pbOutBuffer != pbOutBuffer)   // different output buffer this time
    {
        m_pbOutBuffer = pbOutBuffer ;
        m_L21Dec.SetOutputBuffer(pbOutBuffer) ;
    }
    
    return S_OK ;
}


//
//  BeginFlush: We have to implement this as we have overridden Receive()
//
HRESULT CLine21DecFilter::BeginFlush(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::BeginFlush()"))) ;

    CAutoLock   Lock(&m_csFilter) ;
    
    HRESULT     hr = NOERROR ;
    if (NULL != m_pOutput)
    {
        hr = m_pOutput->DeliverBeginFlush() ;
        if (FAILED(hr))
            DbgLog((LOG_ERROR, 0, TEXT("WARNING: DeliverBeginFlush() on out pin failed (Error 0x%lx)"), hr)) ;
    }
    
    return hr ;
}


//
//  EndFlush: We have to implement this as we have overridden Receive()
//
HRESULT CLine21DecFilter::EndFlush(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::EndFlush()"))) ;
    
    CAutoLock   Lock(&m_csFilter) ;
    
    HRESULT     hr = NOERROR ;
    if (NULL != m_pOutput)
    {
        hr = m_pOutput->DeliverEndFlush() ;
        if (FAILED(hr))
            DbgLog((LOG_ERROR, 0, TEXT("WARNING: DeliverEndFlush() on out pin failed (Error 0x%lx)"), hr)) ;
    }
    
    return hr ;
}


//
//  EndOfStream: We have to implement this as we have overridden Receive()
//
HRESULT CLine21DecFilter::EndOfStream(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::EndOfStream()"))) ;
    CAutoLock   Lock(&m_csFilter) ;
    
    HRESULT     hr = NOERROR ;
    
    //
    //  Make sure we are not in the middle of a scrolling. If so,
    //  force a few NULLs (specially in byte pair format) to make 
    //  the scrolling complete.
    //
    //  m_L21Dec.CompleteScrolling() ;  // It doesn't do anything now
    
    // Now send EOS downstream
    if (NULL != m_pOutput)
    {
        hr = m_pOutput->DeliverEndOfStream() ;
        if (FAILED(hr))
            DbgLog((LOG_ERROR, 0, TEXT("WARNING: DeliverEndOfStream() on out pin failed (Error 0x%lx)"), hr)) ;
    }
    
    return hr ;
}


HRESULT CLine21DecFilter::GetDefaultFormatInfo(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetDefaultFormatInfo()"))) ;
    //
    // We can't take the lock in this method, because it is called in Transform()
    // which is called from Receive() causing us to take m_csReceive and then
    // m_csFilter which is opposite of what Stop, Pause etc. methods do thereby
    // causing a potential for deadlock.
    //

    // build a VIDEOINFO struct with default internal BITMAPINFO
    DWORD   dwSize ;
    m_L21Dec.GetDefaultFormatInfo(NULL, &dwSize) ;
    
    if (m_dwDefFmtSize != dwSize + SIZE_PREHEADER)
    {
        if (m_pviDefFmt)
        {
            delete m_pviDefFmt ;
            m_pviDefFmt = NULL ;
            m_dwDefFmtSize = 0 ;
        }
        m_pviDefFmt = (VIDEOINFO *) new BYTE[dwSize + SIZE_PREHEADER] ;
        if (NULL == m_pviDefFmt)
        {
            DbgLog((LOG_ERROR, 0, TEXT("WARNING: Out of memory for format block VIDEOINFO struct"))) ;
            return E_OUTOFMEMORY ;
        }
        m_dwDefFmtSize = dwSize + SIZE_PREHEADER;  // total size of default format data
    }
    
    // We want to get BITMAPINFO part of VIDEOINFO struct from our GDI class
    m_L21Dec.GetDefaultFormatInfo((LPBITMAPINFO) &(m_pviDefFmt->bmiHeader), &dwSize) ; // get default data
    
    // Set the other fields
    LARGE_INTEGER  li ;
    li.QuadPart = (LONGLONG) 333667 ;  // => 29.97 fps
    RECT   rc ;
    rc.left = rc.top = 0 ;
    rc.right = HEADER(m_pviDefFmt)->biWidth ;
    rc.bottom = abs(HEADER(m_pviDefFmt)->biHeight) ;  // just make sure rect fields are +ve
    m_pviDefFmt->rcSource = rc ;
    m_pviDefFmt->rcTarget = rc ;
    m_pviDefFmt->dwBitRate = MulDiv(HEADER(m_pviDefFmt)->biSizeImage, 
        80000000, li.LowPart) ;
    m_pviDefFmt->dwBitErrorRate = 0 ;
    m_pviDefFmt->AvgTimePerFrame = (LONGLONG) 333667L ; // => 29.97 fps
    
    return NOERROR ;
}


//
//  CheckInputType: Check if you can support the input data type
//
HRESULT CLine21DecFilter::CheckInputType(const CMediaType* pmtIn)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::CheckInputType(0x%lx)"), pmtIn)) ;
    // CAutoLock   Lock(&m_csFilter) ; -- shouldn't as that causes deadlock
    
    if (NULL == pmtIn)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Rejecting: media type info is NULL"))) ;
        return E_INVALIDARG ;
    }
    
    //  We only support MEDIATYPE_AUXLine21Data and 
    //  MEDIASUBTYPE_Line21_BytePair or MEDIASUBTYPE_Line21_GOPPacket
    //  or MEDIASUBTYPE_Line21_VBIRawData (never)
    GUID    SubTypeIn = *pmtIn->Subtype() ;
    m_eSubTypeIDIn = MapGUIDToID(&SubTypeIn) ;
    if (! (MEDIATYPE_AUXLine21Data == *pmtIn->Type()  && 
        ISSUBTYPEVALID(m_eSubTypeIDIn)) )
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Rejecting invalid Line 21 Data subtype"))) ;
        return E_INVALIDARG ;
    }
    
    // Check that this is a valid format type
    if (FORMAT_VideoInfo == *pmtIn->FormatType())
    {
        ASSERT(m_pOutput != NULL) ;

        //
        // Make sure the given input format is valid. If not, reject it and use our
        // own default format data.
        //
        if (! IsValidFormat(pmtIn->Format()) )
        {
            DbgLog((LOG_TRACE, 0, TEXT("Invalid format data given -- using our own format data."))) ;
            if (NULL == m_pviDefFmt)
            {
                HRESULT  hr = GetDefaultFormatInfo() ;
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR, 0, TEXT("WARNING: Couldn't get default format data"))) ;
                    return hr ;
                }
            }
            // We should fix the input mediatype too (with the default VideoInfo data).
            m_pInput->CurrentMediaType().SetFormat((LPBYTE) m_pviDefFmt, m_dwDefFmtSize) ;
            m_pOutput->CurrentMediaType().SetFormatType(pmtIn->FormatType()) ;
            m_pOutput->CurrentMediaType().SetFormat((LPBYTE) m_pviDefFmt, m_dwDefFmtSize) ;
        }
        else  // seems to be valid format spec.
        {
            //
            // Get the specified input format info; we'll use the same for output
            //
            if (pmtIn->FormatLength() > 0) // only if there is some format data
            {
                m_pOutput->CurrentMediaType().SetFormatType(pmtIn->FormatType()) ;
                m_pOutput->CurrentMediaType().SetFormat(pmtIn->Format(), pmtIn->FormatLength()) ;
            }
            else
            {
                DbgLog((LOG_ERROR, 0, TEXT("WARNING: FORMAT_VideoInfo and no format block specified."))) ;
// #if 0  // for now
                return E_INVALIDARG ;
// #endif // #if 0
            }
        }
    }
    else if (GUID_NULL   == *pmtIn->FormatType() ||  // wild card
             FORMAT_None == *pmtIn->FormatType())    // no format
    {
        //
        // input pin didn't get a format type info; use our own
        //
        DbgLog((LOG_TRACE, 3, TEXT("No format type specified -- using our own format type."))) ;
        if (NULL == m_pviDefFmt)
        {
            HRESULT  hr = GetDefaultFormatInfo() ;
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 0, TEXT("WARNING: Couldn't get default format data"))) ;
                return hr ;
            }
        }
        m_pOutput->CurrentMediaType().SetFormat((LPBYTE) m_pviDefFmt, m_dwDefFmtSize) ;
    }
    else  // something weird that we don't like
    {
        DbgLog((LOG_TRACE, 3, TEXT("Rejecting invalid format type"))) ;
        // tell what input type too??
        return E_INVALIDARG ;
    }
    
    // some more level 3 debug log here???
    
    // We should branch based on what format type we got, because ..GOPPacket
    // type needs to be unwrapped and parsed whereas the ..BytePair format
    // is to be directly parsed.
    
    // do we have a case for -- return VFW_E_TYPE_NOT_ACCEPTED ???
    
    return NOERROR ;
}


//
//  CheckTransform: check if this input to this output transform is supported
//
HRESULT CLine21DecFilter::CheckTransform(const CMediaType* pmtIn,
                                         const CMediaType* pmtOut)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::CheckTransform(0x%lx, 0x%lx)"), 
            pmtIn, pmtOut)) ;
    // CAutoLock   Lock(&m_csFilter) ; -- shouldn't as that causes deadlock
    
    if (NULL == pmtIn || NULL == pmtOut)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Rejecting: media type info is NULL"))) ;
        return E_INVALIDARG ;
    }
    
    //  We only support MEDIATYPE_AUXLine21Data and 
    //  MEDIASUBTYPE_Line21_BytePair or MEDIASUBTYPE_Line21_GOPPacket
    //  or MEDIASUBTYPE_Line21_VBIRawData (never)
    //  Check that input is a valid subtype type
    //  and format is VideoInfo or None
    GUID SubTypeIn = *pmtIn->Subtype() ;
    m_eSubTypeIDIn = MapGUIDToID(&SubTypeIn) ;
    if (! (MEDIATYPE_AUXLine21Data == *pmtIn->Type()  &&   // line21 data type and...
           ISSUBTYPEVALID(m_eSubTypeIDIn)  &&              // valid subtype (bytepair/GOPPacket) and...
           (FORMAT_VideoInfo == *pmtIn->FormatType() ||    // format VideoInfo  or
            FORMAT_None      == *pmtIn->FormatType() ||    // format None (KS wild card)  or
            GUID_NULL        == *pmtIn->FormatType())) )   // GUID Null (DShow wild card)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Rejecting: input type not Line21 / subtype / formattype invalid"))) ;
        return E_INVALIDARG ;
    }
    
    // and we only accept video as output
    if (MEDIATYPE_Video != *pmtOut->Type())
    {
        DbgLog((LOG_TRACE, 3, TEXT("Rejecting: output type is not VIDEO"))) ;
        return E_INVALIDARG ;
    }
    
    // check output is VIDEOINFO type
    if (FORMAT_VideoInfo != *pmtOut->FormatType())
    {
        DbgLog((LOG_TRACE, 3, TEXT("Rejecting: output format type is not VIDEOINFO"))) ;
        return E_INVALIDARG ;
    }

    //
    //  Verify that the output size specified by the input and output mediatype
    //  are acceptable.
    //
    if ( !IsValidFormat(pmtOut->Format()) ||              // invalid output format data  OR
         !m_L21Dec.IsSizeOK(HEADER(pmtOut->Format()))  || // output size is NOT acceptable  OR
         (FORMAT_VideoInfo == *pmtIn->FormatType() &&     // valid input format type and...
          IsValidFormat(pmtIn->Format()) &&               // valid input format data and...
          !m_L21Dec.IsSizeOK(HEADER(pmtIn->Format()))) )  // output size is NOT acceptable   
    {
        DbgLog((LOG_TRACE, 1, TEXT("Rejecting: Input/output-specified output size is unacceptable"))) ;
        return E_INVALIDARG ;
    }

#if 0
    
#define rcS1 ((VIDEOINFO *)(pmtOut->Format()))->rcSource
#define rcT1 ((VIDEOINFO *)(pmtOut->Format()))->rcTarget
    
    DbgLog((LOG_TRACE, 3,
        TEXT("Input Width x Height x Bitdepth: %ld x %ld x %ld"),
        HEADER(pmtIn->Format())->biWidth,
        HEADER(pmtIn->Format())->biHeight,
        HEADER(pmtIn->Format())->biBitCount)) ;
    DbgLog((LOG_TRACE, 3,
        TEXT("Output Width x Height x Bitdepth: %ld x %ld x %ld"),
        HEADER(pmtOut->Format())->biWidth,
        HEADER(pmtOut->Format())->biHeight,
        HEADER(pmtOut->Format())->biBitCount)) ;
    DbgLog((LOG_TRACE, 3,
        TEXT("rcSrc: (%ld, %ld, %ld, %ld)"),
        rcS1.left, rcS1.top, rcS1.right, rcS1.bottom)) ;
    DbgLog((LOG_TRACE, 3,
        TEXT("rcDst: (%ld, %ld, %ld, %ld)"),
        rcT1.left, rcT1.top, rcT1.right, rcT1.bottom)) ;
    
    DWORD     dwErr ;
    
    // If we've been given rectangles, use What???
    if (!IsRectEmpty(&rcS1) || !IsRectEmpty(&rcT1))
    {
        DbgLog((LOG_TRACE, 4, TEXT("Either source or dest rect is empty"))) ;
        dwErr = 0 ;  // what to do here??
    }
    else
    {
        DbgLog((LOG_TRACE, 4, TEXT("Source or dest rects are not empty")));
        dwErr = 0 ;  // what to do here??
    }
    
    if (dwErr != 0)  // or what to check against??
    {
        DbgLog((LOG_ERROR, 1, TEXT("decoder rejected this transform"))) ;
        return E_FAIL ;
    }
    
#endif // #if 0
    
    return NOERROR ;
}


//
//  CompleteConnect: Overridden to know when a connection is made to this filter
//
HRESULT CLine21DecFilter::CompleteConnect(PIN_DIRECTION dir, IPin *pReceivePin)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::CompleteConnect(%s, 0x%lx)"), 
        dir == PINDIR_INPUT ? TEXT("Input") : TEXT("Output"), pReceivePin)) ;
    CAutoLock   Lock(&m_csFilter) ;

    LPBITMAPINFO    lpbmi ;
    HRESULT         hr ;
    
    if (PINDIR_OUTPUT == dir)
    {
        DbgLog((LOG_TRACE, 5, TEXT("L21D output pin connecting to %s"), (LPCTSTR)CDisp(pReceivePin))) ;

         //
        // This version of the line21 decoder should NOT work with the VMR
        //
        IVMRVideoStreamControl  *pVMRSC ;
        hr = pReceivePin->QueryInterface(IID_IVMRVideoStreamControl, (LPVOID *) &pVMRSC) ;
        if (SUCCEEDED(hr))
        {
            DbgLog((LOG_TRACE, 5, TEXT("Downstream input pin supports IVMR* interface"))) ;
            pVMRSC->Release() ;
            return E_FAIL ;
        }
        else
        {
            DbgLog((LOG_TRACE, 5, TEXT("Downstream input pin does NOT support IVMR* interface"))) ;
        }

       //
        // Now get the the output pin's mediatype and use that for our
        // output size etc.
        //
        const CMediaType  *pmt = &(m_pOutput->CurrentMediaType()) ;
        ASSERT(MEDIATYPE_Video == *pmt->Type()  &&  
            FORMAT_VideoInfo == *pmt->FormatType()) ;
        m_mtOutput = *pmt ;  // this is our output mediatype for now
        if (pmt->FormatLength() > 0)  // only if there is some format data
        {
            lpbmi = (LPBITMAPINFO) HEADER(((VIDEOINFO *)(pmt->Format()))) ;
            ASSERT(lpbmi) ;
            
            // Set the output format info coming from downstream
            m_L21Dec.SetOutputOutFormat(lpbmi) ;
            GetDefaultFormatInfo() ;  // to pick any change in format data
            
            //
            // We are definitely not running/paused. So no need to delete/
            // create output DIB section here at all.
            //
            
            //
            // If are being connected to the OverlayMixer, we need to tell it 
            // that we are a transparent stream that covers the whole output
            // window.
            //
            IMixerPinConfig  *pMPC ;
            hr = pReceivePin->QueryInterface(IID_IMixerPinConfig, (LPVOID *)&pMPC) ;
            if (SUCCEEDED(hr) && pMPC)
            {
                DbgLog((LOG_TRACE, 3, TEXT("Receiving pin supports IMixerPinConfig"))) ;
                hr = pMPC->SetStreamTransparent(TRUE) ;
                ASSERT(SUCCEEDED(hr) || E_NOTIMPL == hr) ;  // as Kapil says
                hr = pMPC->SetRelativePosition(0, 0, 10000, 10000) ; // full window
                ASSERT(SUCCEEDED(hr) || E_NOTIMPL == hr) ;  // as Kapil says
                hr = pMPC->SetAspectRatioMode(AM_ARMODE_STRETCHED_AS_PRIMARY) ; // aspect ratio same as primary
                ASSERT(SUCCEEDED(hr) || hr == E_INVALIDARG) ;  // as Kapil says
                pMPC->Release() ;  // done; let it go.
            }
            else
            {
                DbgLog((LOG_TRACE, 3, TEXT("Downstream pin doesn't support IMixerPinConfig"))) ;
            }
        }
        
        return NOERROR ;
    }
    
    ASSERT(PINDIR_INPUT == dir) ;
    {
        DbgLog((LOG_TRACE, 5, TEXT("L21D input pin connecting to %s"), (LPCTSTR)CDisp(pReceivePin))) ;

        // const CMediaType  *pmt = &(m_pInput->CurrentMediaType()) ;
        AM_MEDIA_TYPE mt ;
        hr = pReceivePin->ConnectionMediaType(&mt) ;
        if (SUCCEEDED(hr))  // ONLY if upstream filter provides mediatype used in the connection
        {
            // If format type (and format data) has been specified then save it as 
            // input-side output format
            if (FORMAT_VideoInfo == mt.formattype  &&
                mt.cbFormat > 0)
            {
                lpbmi = (LPBITMAPINFO) HEADER(((VIDEOINFO *)(mt.pbFormat))) ;
                ASSERT(lpbmi) ;
            
                // Store whatever output format info is specified by upstream filter
                m_L21Dec.SetOutputInFormat(lpbmi) ;
                GetDefaultFormatInfo() ;  // to pick any change in format data
            
                //
                // We are definitely not running/paused. So no need to delete/
                // create output DIB section here at all.
                //
            }

            FreeMediaType(mt) ;
        }  // end of if ()
    }
    
    //
    //  We MUST clear the caption data buffers and any exisiting internal state
    //  now.  This is most important in this cases where the filter has been
    //  used to decode some Line 21 data, disconnected from the source and then 
    //  reconnected again to play another stream of data.
    //
    m_L21Dec.InitState() ;
    m_L21Dec.InitColorNLastChar() ;     // reset color and last char info
    
    return NOERROR ;
}


//
//  BreakConnect: Overridden to know when a connection is broken to our pin
//
HRESULT CLine21DecFilter::BreakConnect(PIN_DIRECTION dir)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::BreakConnect(%s)"), 
            dir == PINDIR_INPUT ? TEXT("Input") : TEXT("Output"))) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (PINDIR_OUTPUT == dir)
    {
        // If not connected yet, just return (but indicate with S_FALSE)
        if (! m_pOutput->IsConnected() )
            return S_FALSE ;
        
        m_L21Dec.SetOutputOutFormat(NULL) ;  // no output format from downstream
        GetDefaultFormatInfo() ;  // to pick any change in format data
        m_pbOutBuffer = NULL ;               // locally cached pointer
        m_L21Dec.SetOutputBuffer(NULL) ;     // output buffer not available now

        //
        // NOTE 1: We are definitely not running/paused. So no need to delete/
        // create output DIB section here.
        //
        
        //
        // NOTE 2: We don't do CBaseOutputPin::BreakConnect(), because the
        // base class code for CTransformOutputPin::BreakConnect() already
        // does that.
        //
        return NOERROR ;
    }
    
    ASSERT(PINDIR_INPUT == dir) ;
    
    // If not connected yet, just return (but indicate with S_FALSE)
    if (! m_pInput->IsConnected() )
        return S_FALSE ;
    
    m_L21Dec.SetOutputInFormat(NULL) ;  // no output format from upstream
    GetDefaultFormatInfo() ;  // to pick any change in format data
    
    //
    // NOTE 1: We are definitely not running/paused. So no need to delete/
    // create output DIB section here.
    //
    
    //
    // NOTE 2: We don't do CBaseOutputPin::BreakConnect(), because the
    // base class code for CTransformOutputPin::BreakConnect() already
    // does that.
    //
    return NOERROR ;
}

//
//  SetMediaType: overriden to know when the media type is actually set
//
HRESULT CLine21DecFilter::SetMediaType(PIN_DIRECTION direction, const CMediaType *pmt)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::SetMediaType(%s, 0x%lx)"), 
            direction == PINDIR_INPUT ? TEXT("Input") : TEXT("Output"), pmt)) ;
    // CAutoLock   Lock(&m_csFilter) ;

    LPTSTR alpszFormatIDs[] = { TEXT("Invalid"), TEXT("BytePair"),
								TEXT("GOPPacket"), TEXT("VBIRawData") } ;
    
    if (PINDIR_OUTPUT == direction)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Output type: %d x %d x %d"),
            HEADER(m_pOutput->CurrentMediaType().Format())->biWidth,
            HEADER(m_pOutput->CurrentMediaType().Format())->biHeight,
            HEADER(m_pOutput->CurrentMediaType().Format())->biBitCount)) ;
        return NOERROR ;
    }
    
    ASSERT(PINDIR_INPUT == direction) ;
    DbgLog((LOG_TRACE, 3, TEXT("Input type: <%s>"),
        alpszFormatIDs[MapGUIDToID(m_pInput->CurrentMediaType().Subtype())])) ;
    
    if (m_pOutput && m_pOutput->IsConnected()) 
    {
        DbgLog((LOG_TRACE, 2, TEXT("*** Changing IN when OUT already connected"))) ;
        DbgLog((LOG_TRACE, 2, TEXT("Reconnecting the output pin..."))) ;
        return m_pGraph->Reconnect(m_pOutput) ;
    }
    
    return NOERROR ;
}


#if 0  // Quality Management is deferred for now as OvMixer always says (Flood, 1000)

//
//  AlterQuality: overriden to handle quality messages and not pass them upstream
//
HRESULT CLine21DecFilter::AlterQuality(Quality q)
{
    DbgLog((LOG_TRACE, 0, TEXT("QM: CLine21DecFilter::AlterQuality(%s, %ld)"), 
            Flood == q.Type ? TEXT("Flood") : TEXT("Famine"), q.Proportion)) ; // log trace=5

    if (1000 == q.Proportion)
    {
        DbgLog((LOG_TRACE, 0, TEXT("QM: Quality is just right.  Don't change anything."))) ; 
        return S_OK ;
    }

    if (Flood == q.Type)    // Flood: too much output
    {
        if (q.Proportion > 500 && q.Proportion <= 900)
        {
            m_iSkipSamples += 1 ;
        }
        else if (q.Proportion > 300 && q.Proportion <= 500)
        {
            m_iSkipSamples += 2 ;
        }
        else if (q.Proportion <= 300)
        {
            m_iSkipSamples += 3 ;
        }
        m_iSkipSamples = min(m_iSkipSamples, 10) ;  // at least 1 in 10 is shown
    }
    else                    // Famine: send more output
    {
        if (q.Proportion > 1200)  // could take 20% more
        {
            m_iSkipSamples-- ;
            if (m_iSkipSamples < 0)
                m_iSkipSamples = 0 ;
        }
    }

    DbgLog((LOG_TRACE, 0, TEXT("QM: Adjusted rate is %d samples are skipped."), m_iSkipSamples)) ; 
    return S_OK ;
}
#endif // #if 0 -- end of commented out AlterQuality() implementation


// Return our preferred output media types (in order)
// remember that we do not need to support all of these formats -
// if one is considered potentially suitable, our CheckTransform method
// will be called to check if it is acceptable right now.
// Remember that the enumerator calling this will stop enumeration as soon as
// it receives a S_FALSE return.
//
//  GetMediaType: Get our preferred media type (in order)
//
HRESULT CLine21DecFilter::GetMediaType(int iPosition, CMediaType *pmt)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetMediaType(%d, 0x%lx)"), 
            iPosition, pmt)) ;
    CAutoLock   Lock(&m_csFilter) ;

    LARGE_INTEGER       li ;
    CMediaType          cmt ;
    LPBITMAPINFOHEADER  lpbi ;
    
    if (NULL == pmt)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Media type is NULL, Sorry!!"))) ;
        return E_INVALIDARG ;
    }
    
    // Output choices depend on the input connected
    if (! m_pInput->CurrentMediaType().IsValid() )
    {
        DbgLog((LOG_TRACE, 3, TEXT("No input type set yet, Sorry!!"))) ;
        return E_FAIL ;
    }
    
    if (iPosition < 0)
    {
        return E_INVALIDARG ;
    }
    
    // Find the format info specified in the input VideoInfo struct
    cmt = m_pInput->CurrentMediaType() ;
    BITMAPINFOHEADER bih ;
    BOOL  bOutKnown = (S_OK == m_L21Dec.GetOutputOutFormat(&bih)) ;
    if (! bOutKnown )
        GetOutputFormat(&bih) ;
    
    BOOL bInKnown = NULL != cmt.Format() && IsValidFormat(cmt.Format()) ; // just to be sure
    VIDEOINFOHEADER vih ;
    if (bInKnown)
        CopyMemory(&vih, (VIDEOINFOHEADER *)(cmt.Format()), sizeof(VIDEOINFOHEADER)) ;
    
    // Offer the decoder's default output format (Video) first
    switch (iPosition)
    {
    case 0:  // RGB 8bpp
        {
            DbgLog((LOG_TRACE, 3, TEXT("Media Type 0: 8 bit RGB"))) ;
            
            // First allocate enough space to hold the pertinent info
            cmt.ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER) + SIZE_PALETTE);
            
            // Use some info from input format and use our choices too
            lpbi = HEADER(cmt.Format()) ;
            if (!bOutKnown && bInKnown) // output format not known and input format spec-ed
                CopyMemory(lpbi, &(vih.bmiHeader), sizeof(BITMAPINFOHEADER)) ;
            else  // if output format known or input format not spec-ed
                CopyMemory(lpbi, &bih, sizeof(BITMAPINFOHEADER)) ;
            lpbi->biBitCount = 8 ;
            lpbi->biCompression = BI_RGB ;
            lpbi->biSizeImage = DIBSIZE(*lpbi) ;
            
            // Get some palette data from system/our own (for non-8 bpp)
            m_L21Dec.GetPaletteForFormat(lpbi) ;  // this sets biClrUsed member
            
            cmt.SetType(&MEDIATYPE_Video) ;
            cmt.SetSubtype(&MEDIASUBTYPE_RGB8) ;
            
            break ;
        }
        
    case 1:  // RGB 16bpp (555)
        {
            DbgLog((LOG_TRACE, 3, TEXT("Media Type 1: 16 bit RGB 555"))) ;
            
            // First allocate enough space to hold the pertinent info
            cmt.ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));
            
            // Use some info from input format and use our choices too
            lpbi = HEADER(cmt.Format()) ;
            if (!bOutKnown && bInKnown) // output format not known and input format spec-ed
                CopyMemory(lpbi, &(vih.bmiHeader), sizeof(BITMAPINFOHEADER)) ;
            else  // if output format known or input format not spec-ed
                CopyMemory(lpbi, &bih, sizeof(BITMAPINFOHEADER)) ;
            lpbi->biBitCount = 16 ;
            lpbi->biCompression = BI_RGB ;
            lpbi->biSizeImage = DIBSIZE(*lpbi) ;
            lpbi->biClrUsed = 0 ;  // for true color modes
            
            // Now set the output mediatype of type Video using the input
            // format info
            cmt.SetType(&MEDIATYPE_Video) ;
            cmt.SetSubtype(&MEDIASUBTYPE_RGB555) ;
            break ;
        }
        
    case 2:  // 16bpp (565)
        {
            DbgLog((LOG_TRACE, 3, TEXT("Media Type 2: 16 bit RGB 565"))) ;
            
            // First allocate enough space to hold the pertinent info
            cmt.ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER) + SIZE_MASKS);
            
            // Use some info from input format and use our choices too
            lpbi = HEADER(cmt.Format()) ;
            if (!bOutKnown && bInKnown) // output format not known and input format spec-ed
                CopyMemory(lpbi, &(vih.bmiHeader), sizeof(BITMAPINFOHEADER)) ;
            else  // if output format known or input format not spec-ed
                CopyMemory(lpbi, &bih, sizeof(BITMAPINFOHEADER)) ;
            lpbi->biBitCount = 16 ;
            lpbi->biCompression = BI_BITFIELDS ;
            lpbi->biSizeImage = DIBSIZE(*lpbi) ;
            lpbi->biClrUsed = 0 ;  // for true color modes
            
            // Set the masks too
            DWORD   *pdw = (DWORD *)(lpbi + 1) ;
            pdw[iRED]    = bits565[iRED] ;
            pdw[iGREEN]  = bits565[iGREEN] ;
            pdw[iBLUE]   = bits565[iBLUE] ;
            
            cmt.SetType(&MEDIATYPE_Video) ;
            cmt.SetSubtype(&MEDIASUBTYPE_RGB565) ;
            break ;
        }
        
    case 3:   // RGB 24bpp
        {
            DbgLog((LOG_TRACE, 3, TEXT("Media Type 3: 24 bit RGB"))) ;
            
            // First allocate enough space to hold the pertinent info
            cmt.ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));
            
            // Use some info from input format and use our choices too
            lpbi = HEADER(cmt.Format()) ;
            if (!bOutKnown && bInKnown) // output format not known and input format spec-ed
                CopyMemory(lpbi, &(vih.bmiHeader), sizeof(BITMAPINFOHEADER)) ;
            else  // if output format known or input format not spec-ed
                CopyMemory(lpbi, &bih, sizeof(BITMAPINFOHEADER)) ;
            lpbi->biBitCount = 24 ;
            lpbi->biCompression = BI_RGB ;
            lpbi->biSizeImage = DIBSIZE(*lpbi) ;
            lpbi->biClrUsed = 0 ;  // for true color modes
            
            cmt.SetType(&MEDIATYPE_Video) ;
            cmt.SetSubtype(&MEDIASUBTYPE_RGB24) ;
            break ;
        }
        
    case 4:  // 32bpp
        {
            DbgLog((LOG_TRACE, 3, TEXT("Media Type 4: 32 bit RGB"))) ;
            
            // First allocate enough space to hold the pertinent info
            cmt.ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER) + SIZE_MASKS);
            
            // Use some info from input format and use our choices too
            lpbi = HEADER(cmt.Format()) ;
            if (!bOutKnown && bInKnown) // output format not known and input format spec-ed
                CopyMemory(lpbi, &(vih.bmiHeader), sizeof(BITMAPINFOHEADER)) ;
            else  // if output format known or input format not spec-ed
                CopyMemory(lpbi, &bih, sizeof(BITMAPINFOHEADER)) ;
            lpbi->biBitCount = 32 ;
            lpbi->biCompression = BI_BITFIELDS ;
            lpbi->biSizeImage = DIBSIZE(*lpbi) ;
            lpbi->biClrUsed = 0 ;  // for true color modes
            
            // Set the masks too
            DWORD   *pdw = (DWORD *)(lpbi + 1) ;
            pdw[iRED]    = bits888[iRED] ;
            pdw[iGREEN]  = bits888[iGREEN] ;
            pdw[iBLUE]   = bits888[iBLUE] ;
            
            cmt.SetType(&MEDIATYPE_Video) ;
            cmt.SetSubtype(&MEDIASUBTYPE_RGB32) ;
            break ;
        }
        
    default:
        return VFW_S_NO_MORE_ITEMS ;
        
    }  // end of switch (iPosition)
    
    // Now set the output formattype and sample size
    cmt.SetSampleSize(lpbi->biSizeImage) ;
    cmt.SetFormatType(&FORMAT_VideoInfo) ;
    
    // The fields of VIDEOINFOHEADER needs to be filled now
    if (! bInKnown ) // if the upstream filter didn't specify anything
    {
        RECT  Rect ;
        Rect.left = 0 ;
        Rect.top = 0 ;
        Rect.right = lpbi->biWidth ;
        Rect.bottom = abs(lpbi->biHeight) ;  // biHeight could be -ve, but rect fields are +ve
        
        // We set some default values for time/frame, src and target rects etc. etc.
        li.QuadPart = (LONGLONG) 333667 ;  // => 29.97 fps
        ((VIDEOINFOHEADER *)(cmt.pbFormat))->AvgTimePerFrame = (LONGLONG) 333667 ;  // => 29.97 fps
        ((VIDEOINFOHEADER *)(cmt.pbFormat))->rcSource = Rect ;
        ((VIDEOINFOHEADER *)(cmt.pbFormat))->rcTarget = Rect ;
    }
    else
        li.QuadPart = vih.AvgTimePerFrame ;
    
    ((VIDEOINFOHEADER *)(cmt.pbFormat))->dwBitRate =
        MulDiv(lpbi->biSizeImage, 80000000, li.LowPart) ;
    ((VIDEOINFOHEADER *)(cmt.pbFormat))->dwBitErrorRate = 0L ;
    
    // Set temporal compression and copy the prepared data now
    cmt.SetTemporalCompression(FALSE) ;
    *pmt = cmt ;
    
    return NOERROR ;
}


//
//  DecideBufferSize: Called from CBaseOutputPin to prepare the allocator's
//                    count of buffers and sizes.  It makes sense only when
//                    the input is connected.
//
HRESULT CLine21DecFilter::DecideBufferSize(IMemAllocator * pAllocator,
                                           ALLOCATOR_PROPERTIES *pProperties)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::DecideBufferSize(0x%lx, 0x%lx)"), 
            pAllocator, pProperties)) ;
    CAutoLock   Lock(&m_csFilter) ;

    // Is the input pin connected
    if (! m_pInput->IsConnected()) 
    {
        return E_UNEXPECTED ;
    }
    
    ASSERT(m_pOutput->CurrentMediaType().IsValid()) ;
    ASSERT(pAllocator) ;
    ASSERT(pProperties) ;
    
    // set the size of buffers based on the expected output bitmap size, and
    // the count of buffers to 1.
    pProperties->cBuffers = 1 ;
    pProperties->cbBuffer = m_pOutput->CurrentMediaType().GetSampleSize() ;
    
    ASSERT(pProperties->cbBuffer) ;
    
    ALLOCATOR_PROPERTIES Actual ;
    HRESULT hr = pAllocator->SetProperties(pProperties, &Actual) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("Error in SetProperties()"))) ;
        return hr ;
    }
    
    if (Actual.cbBuffer < pProperties->cbBuffer  ||
        Actual.cBuffers  < pProperties->cBuffers)
    {
        // can't use this allocator
        DbgLog((LOG_ERROR, 0, TEXT("Can't use allocator (only %d buffer of size %d given)"),
            Actual.cBuffers, Actual.cbBuffer)) ;
        return E_INVALIDARG ;
    }
    DbgLog((LOG_TRACE, 3, TEXT("    %d buffers of %ld bytes each"), 
        pProperties->cBuffers, pProperties->cbBuffer)) ;
    
    ASSERT(Actual.cbAlign == 1) ;
    ASSERT(Actual.cbPrefix == 0) ;
    
    return S_OK ;
}

// We're stopping the stream -- release output DC to reduce memory footprint etc.
STDMETHODIMP CLine21DecFilter::Stop(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::Stop()"))) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (State_Running == m_State  ||
        State_Paused  == m_State)
    {
        DbgLog((LOG_TRACE, 1, TEXT("We are stopping -- release output DC etc."))) ;
        m_L21Dec.DeleteOutputDC() ;       // release internal DIBSection now
        m_L21Dec.SetOutputBuffer(NULL) ;  // no output buffer anymore
        m_pbOutBuffer = NULL ;            // must be same as mL21Dec's m_pbOutBuffer
        
        // Release the prev downstream pin's interface now
        if (m_pPinDown)
        {
            m_pPinDown->Release() ;
            m_pPinDown = NULL ;
        }
    }
    
    HRESULT hr = CTransformFilter::Stop() ;
    
    FreeTimer() ; // To be sure, we don't need a timer in case one is hanging around
    return hr ;
}

// We're starting/stopping to stream -- based on that acquire or release output DC
// to reduce memory footprint etc.
STDMETHODIMP CLine21DecFilter::Pause(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::Pause()"))) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (State_Stopped == m_State)
    {
        //  Try to make sure we have at least 2 buffers
        IMemAllocator *pAlloc;
        if (SUCCEEDED(m_pInput->GetAllocator(&pAlloc))) {
            ALLOCATOR_PROPERTIES props;
            ALLOCATOR_PROPERTIES propsActual;
            pAlloc->GetProperties(&props);
            if (props.cBuffers < 4) {
                props.cBuffers = 4;
                props.cbBuffer = 200;
                props.cbAlign = max(props.cbAlign, 1);
                props.cbPrefix = 0;
                HRESULT hr = pAlloc->SetProperties(&props, &propsActual);
                DbgLog((LOG_TRACE, 2, TEXT("Setproperties returned %8.8X"), hr));
            }
            pAlloc->Release();
        }
        
        DbgLog((LOG_TRACE, 1, TEXT("We are running -- get output DC etc."))) ;
        if (! m_L21Dec.CreateOutputDC() )
        {
            DbgLog((LOG_ERROR, 0, TEXT("WARNING: CLine21DecFilter::Pause() failed"))) ;
            return E_FAIL ;  // should at least fail to avoid faulting later
        }
        
        //
        // Get actual key color and store it for future use.
        //
        GetActualColorKey() ;
        
        m_L21Dec.FillOutputBuffer() ;  // just to clear any existing junk
        
        // We are starting a new play session; we do an exception to allow
        // the first output sample to be sent down even though the byte pair
        // wasn't valid for decoding.
        m_bMustOutput  = TRUE ;   // we are pausing again for this new play session
        m_bDiscontLast = FALSE ;  // no discontinuity from prev session remembered
        m_eGOP_CCType  = GOP_CCTYPE_Unknown ;  // reset GOP packet CC type
        
        SetRect(&m_rectLastOutput, 0, 0, 0, 0) ;  // start with no rect
        
        // If we somehow didn't release the prev downstream pin's interface, do that now
        if (m_pPinDown)
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: downstream pin interface wasn't released properly"))) ;
            m_pPinDown->Release() ;
            m_pPinDown = NULL ;
        }

        // Get the downstream pin's interface so that we can set rects on it later on
        m_pOutput->ConnectedTo(&m_pPinDown) ;
        if (NULL == m_pPinDown)
            DbgLog((LOG_TRACE, 3, TEXT("Running w/o connecting our output pin!!!"))) ;
        else
            DbgLog((LOG_TRACE, 5, TEXT("L21D Output pin connected to %s"), (LPCTSTR)CDisp(m_pPinDown))) ;

#if 0  // No QM for now
        // Reset the sample skipping count for QM handling
        ResetSkipSamples() ;
#endif // #if 0
    }
    else if (State_Running == m_State)
    {
        DbgLog((LOG_TRACE, 1, TEXT("We are pausing from running"))) ;
        //
        // We are not sending output samples down anymore. So we don't need a
        // timer for now.
        //
        FreeTimer() ;
    }
    
    return CTransformFilter::Pause() ;
}

//
// we don't send any data during PAUSE, so to avoid hanging renderers, we
// need to return VFW_S_CANT_CUE when paused
//
HRESULT CLine21DecFilter::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetState()"))) ;
    CAutoLock   Lock(&m_csFilter) ;

    UNREFERENCED_PARAMETER(dwMSecs);
    CheckPointer(State,E_POINTER);
    ValidateReadWritePtr(State,sizeof(FILTER_STATE));
    
    *State = m_State;
    if (m_State == State_Paused)
        return VFW_S_CANT_CUE;
    else
        return S_OK;
}


void CLine21DecFilter::GetActualColorKey(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetActualColorKey()"))) ;
    // Can't take the filter lock as it can cause deadlock.

    //
    // Does the pin connected to our output support IMixerPinConfig?
    // If so, get the color key info and set the relative position;
    // otherwise, it may be the Video Renderer and such -- use default
    // color key based on current bitdepth.
    //
    DWORD   dwPhysColor = -1 ;
    IPin   *pPin ;
    HRESULT hr ;
    hr = m_pOutput->ConnectedTo(&pPin) ;
    if (SUCCEEDED(hr) && pPin)
    {
        IMixerPinConfig  *pMPC ;
        hr = pPin->QueryInterface(IID_IMixerPinConfig, (LPVOID *)&pMPC) ;
        if (SUCCEEDED(hr) && pMPC)
        {
            // Temporary addition to track down any color key value change
            DWORD  dwOldPhysColor ;
            m_L21Dec.GetBackgroundColor(&dwOldPhysColor) ;
            DbgLog((LOG_TRACE, 3, TEXT("Downstream pin supports IMixerPinConfig"))) ;
            hr = pMPC->GetColorKey(NULL, &dwPhysColor) ;
            DbgLog((LOG_TRACE, 1, TEXT("GetActualColorKey() gave 0x%lx (old is 0x%lx)"),
                    dwPhysColor, dwOldPhysColor)) ;
            // Kapil says that we can ignore this error as it's a bad error case and
            // the OverlayMixer will take care of it by stopping this stream anyway.
            if (FAILED(hr))
                DbgLog((LOG_TRACE, 1, TEXT("IMixerPinConfig::GetColorKey() failed (Error 0x%lx)."), hr)) ;
            pMPC->Release() ;  // done; let it go.
        }
        else
        {
            DbgLog((LOG_TRACE, 3, TEXT("Downstream pin doesn't support IMixerPinConfig"))) ;
        }
        
        pPin->Release() ;  // done with the pin
    }
    
    m_L21Dec.SetBackgroundColor(dwPhysColor) ;
}


AM_LINE21_CCSUBTYPEID CLine21DecFilter::MapGUIDToID(const GUID *pFormatIn) 
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::MapGUIDToID(0x%lx)"), pFormatIn)) ;

    if (MEDIASUBTYPE_Line21_BytePair        == *pFormatIn)
        return AM_L21_CCSUBTYPEID_BytePair ;
    else if (MEDIASUBTYPE_Line21_GOPPacket  == *pFormatIn)
        return AM_L21_CCSUBTYPEID_GOPPacket ;
    // else if (MEDIASUBTYPE_Line21_VBIRawData == *pFormatIn)
    //     return AM_L21_CCSUBTYPEID_VBIRawData ;
    else
        return AM_L21_CCSUBTYPEID_Invalid ;
}



//
// CMessageWindow class implementation
//

LPCTSTR  gpszClassName = TEXT("L21DecMsgWnd") ;

CMessageWindow::CMessageWindow()
{
    DbgLog((LOG_TRACE, 5, TEXT("CMessageWindow::CMessageWindow() -- Instantiating message window"))) ;

    m_hWnd   = NULL ;
    m_iCount = 0 ;
    
    //
    // Register message window class, only if it's not already registered
    //
    WNDCLASS   wc ;
    if (! GetClassInfo(GetModuleHandle(NULL), gpszClassName, &wc))
    {
        ZeroMemory(&wc, sizeof(wc)) ;
        wc.lpfnWndProc   = MsgWndProc ;
        wc.hInstance     = GetModuleHandle(NULL) ;
        wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1) ;
        wc.lpszClassName = gpszClassName ;
        if (0 == RegisterClass(&wc)) // Oops, just leave; we'll catch later...
        {
            DbgLog((LOG_ERROR, 0, 
                TEXT("ERROR: RegisterClass() for app class failed (Error %ld)"), 
                GetLastError())) ;
            return ;
        }
    }
    
    m_hWnd = CreateWindowEx(WS_EX_TOOLWINDOW, gpszClassName, TEXT(""), 
        WS_ICONIC, 0, 0, 1, 1, NULL, NULL, 
        GetModuleHandle(NULL), NULL);
    if (NULL == m_hWnd)  // Oops, just leave; we'll catch later...
    {
        DbgLog((LOG_ERROR, 0,
            TEXT("ERROR: CreateWindowEx() failed (Error %ld)"), 
            GetLastError())) ;
        return ;
    }
    
    ShowWindow(m_hWnd, SW_HIDE) ;
}

CMessageWindow::~CMessageWindow()
{
    DbgLog((LOG_TRACE, 5, TEXT("CMessageWindow::~CMessageWindow() -- Destructing message window"))) ;

    DWORD_PTR dwRes ;
    if (0 == SendMessageTimeout(m_hWnd, WM_CLOSE, 0, 0, SMTO_NORMAL, 1000, &dwRes))  // 1 sec wait
    {
        ASSERT(0 == dwRes) ;  // just to be informedd
        DWORD dwErr = GetLastError() ;
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: SendMessageTimeOut() failed (Result=%lu, Error=%lu). Try again..."), 
            dwRes, dwErr)) ;
    }
    else
        DbgLog((LOG_ERROR, 5, TEXT("SendMessageTimeOut() closed window"))) ;
    
#if 0
    if (! UnregisterClass(gpszClassName, GetModuleHandle(NULL)))  // if failed for some reason
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: UnregisterClass(L21DecMsgWnd) failed (Error %ld)"), GetLastError())) ;
        ASSERT(FALSE) ;  // just so that we know
    }
#endif // #if 0
}

LRESULT CALLBACK CMessageWindow::MsgWndProc(HWND hWnd, UINT uMsg, 
                                            WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_TIMER:
        DbgLog((LOG_TRACE, 3, TEXT("MsgWndProc(, uMsg = WM_TIMER, wParam = 0x%0x, )"),
            wParam)) ;
        ((CLine21DecFilter *) wParam)->TimerProc(hWnd, uMsg, wParam, 0 /* dwTime */) ;
        return 0 ;
    }
    DbgLog((LOG_TRACE, 5, TEXT("MsgWndProc(, uMsg = 0x%x, wParam = 0x%0x, )"),
        uMsg, wParam)) ;
    return DefWindowProc(hWnd, uMsg, wParam, lParam) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\lin21dec\l21dfilt.h ===
//
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
//
// ActiveMovie Line 21 Decoder filter
//

extern const AMOVIESETUP_FILTER sudLine21Dec ;

#ifndef _INC_L21DFILT_H
#define _INC_L21DFILT_H

#pragma pack(push, 1)

//
//  DVD Line21 data come as a user data packet from the GOP header.
//  A struct for per frame/field based data and a valid flag definition.
//
//  From DVD specifications...
#define AM_L21_GOPUD_HDR_STARTCODE      0x000001B2
#define AM_L21_GOPUD_HDR_INDICATOR      0x4343
#define AM_L21_GOPUD_HDR_RESERVED       0x01F8
#define AM_L21_GOPUD_HDR_TOPFIELD_FLAG  0x1
#define AM_L21_GOPUD_ELEM_MARKERBITS    0x7F
#define AM_L21_GOPUD_ELEM_VALIDFLAG     0x1
// There can be max 63 frames/fields' worth data per packet as there are 
// 6 bits to represent this number in the packet.
#define AM_L21_GOPUD_ELEMENT_MAX        63

typedef struct _AM_L21_GOPUD_ELEMENT {
    BYTE        bMarker_Switch ;
    BYTE        chFirst ;
    BYTE        chSecond ;
} AM_L21_GOPUD_ELEMENT, *PAM_L21_GOPUD_ELEMENT ;

typedef struct _AM_L21_GOPUD_HEADER {
    BYTE        abL21StartCode[4] ;
    BYTE        abL21Indicator[2] ;
    BYTE        abL21Reserved[2] ;
    BYTE        bTopField_Rsrvd_NumElems ;
} AM_L21_GOPUD_HEADER, *PAM_L21_GOPUD_HEADER ;

typedef struct _AM_L21_GOPUD_PACKET {
    AM_L21_GOPUD_HEADER   Header ;
    AM_L21_GOPUD_ELEMENT  aElements[AM_L21_GOPUD_ELEMENT_MAX] ;
} AM_L21_GOPUD_PACKET, *PAM_L21_GOPUD_PACKET ;

#define GETGOPUD_NUMELEMENTS(pGOPUDPacket) ((pGOPUDPacket)->Header.bTopField_Rsrvd_NumElems & 0x3F)
#define GETGOPUD_PACKETSIZE(pGOPUDPacket)  (LONG)(sizeof(AM_L21_GOPUD_HEADER) + GETGOPUD_NUMELEMENTS(pGOPUDPacket) * sizeof(AM_L21_GOPUD_ELEMENT))
#define GETGOPUDPACKET_ELEMENT(pGOPUDPacket, i) ((pGOPUDPacket)->aElements[i])
#define GETGOPUD_ELEM_MARKERBITS(Elem)     ((((Elem).bMarker_Switch & 0xFE) >> 1) & 0x7F)
#define GETGOPUD_ELEM_SWITCHBITS(Elem)     ((Elem).bMarker_Switch & 0x01)

#define GETGOPUD_L21STARTCODE(Header)             \
    ( (DWORD)((Header).abL21StartCode[0]) << 24 | \
    (DWORD)((Header).abL21StartCode[1]) << 16 | \
    (DWORD)((Header).abL21StartCode[2]) <<  8 | \
(DWORD)((Header).abL21StartCode[3]) )
#define GETGOPUD_L21INDICATOR(Header)             \
    ( (DWORD)((Header).abL21Indicator[0]) << 8 |  \
(DWORD)((Header).abL21Indicator[1]) )
#define GETGOPUD_L21RESERVED(Header)              \
    ( (DWORD)((Header).abL21Reserved[0]) << 8  |  \
(DWORD)((Header).abL21Reserved[1]) )

#define GOPUD_HEADERLENGTH   (4+2+2+1)
#define GETGOPUD_ELEMENT(pGOPUDPkt, i)  (pGOPUDPkt + GOPUD_HEADERLENGTH + sizeof(AM_L21_GOPUD_ELEMENT) * i)
#define ISGOPUD_TOPFIELDFIRST(pGOPUDPacket)  ((pGOPUDPacket)->Header.bTopField_Rsrvd_NumElems & 0x80)


//
//  ATSC Line21 data come as a user data packet from the GOP header.
//  A struct for per frame/field based data and a valid flag definition.
//
//  From ATSC Standards for Coding 25/50Hz Video (A/63) specifications...
#define AM_L21_ATSCUD_HDR_STARTCODE      0x000001B2
#define AM_L21_ATSCUD_HDR_IDENTIFIER     0x47413934
#define AM_L21_ATSCUD_HDR_TYPECODE_EIA   0x03
#define AM_L21_ATSCUD_HDR_EM_DATA_FLAG   0x80
#define AM_L21_ATSCUD_HDR_CC_DATA_FLAG   0x40
#define AM_L21_ATSCUD_HDR_ADDL_DATA_FLAG 0x20
#define AM_L21_ATSCUD_HDR_CC_COUNT_MASK  0x1F
#define AM_L21_ATSCUD_HDR_NEXTBITS_ON    0x01
#define AM_L21_ATSCUD_ELEM_MARKERBITS    0xF8
#define AM_L21_ATSCUD_ELEM_VALID_FLAG    0x04
#define AM_L21_ATSCUD_ELEM_TYPE_FLAG     0x03
#define AM_L21_ATSCUD_MARKERBITS         0xFF
#define AM_L21_ATSCUD_HDR_NEXTBITS_FLAG  0x00000100
// There can be max 31 frames/fields' worth data per packet as there are 
// 5 bits to represent this number in the packet.
#define AM_L21_ATSCUD_ELEMENT_MAX        31

typedef struct _AM_L21_ATSCUD_ELEMENT {
    BYTE        bCCMarker_Valid_Type ;
    BYTE        chFirst ;
    BYTE        chSecond ;
} AM_L21_ATSCUD_ELEMENT, *PAM_L21_ATSCUD_ELEMENT ;

typedef struct _AM_L21_ATSCUD_HEADER {
    BYTE        abL21StartCode[4] ;
    BYTE        abL21Identifier[4] ;
    BYTE        bL21UDTypeCode ;
    BYTE        bL21DataFlags_Count ;
    BYTE        bL21EMData ;
} AM_L21_ATSCUD_HEADER, *PAM_L21_ATSCUD_HEADER ;

typedef struct _AM_L21_ATSCUD_PACKET {
    AM_L21_ATSCUD_HEADER   Header ;
    AM_L21_ATSCUD_ELEMENT  aElements[AM_L21_ATSCUD_ELEMENT_MAX] ;
    BYTE                   bMarkerBits ;
} AM_L21_ATSCUD_PACKET, *PAM_L21_ATSCUD_PACKET ;

#define GETATSCUD_NUMELEMENTS(pATSCUDPacket) ((pATSCUDPacket)->Header.bL21DataFlags_Count & AM_L21_ATSCUD_HDR_CC_COUNT_MASK)
#define GETATSCUD_PACKETSIZE(pATSCUDPacket)  (LONG)(sizeof(AM_L21_ATSCUD_HEADER) + \
                                              GETATSCUD_NUMELEMENTS(pATSCUDPacket) * sizeof(AM_L21_ATSCUD_ELEMENT) + \
                                              sizeof(BYTE))
#define GETATSCUDPACKET_ELEMENT(pATSCUDPacket, i) ((pATSCUDPacket)->aElements[i])
#define GETATSCUD_ELEM_MARKERBITS(Elem)     (((Elem).bCCMarker_Valid_Type & AM_L21_ATSCUD_ELEM_MARKERBITS) >> 3)

#define GETATSCUD_STARTCODE(Header)             \
    ( (DWORD)((Header).abL21StartCode[0]) << 24 | \
      (DWORD)((Header).abL21StartCode[1]) << 16 | \
      (DWORD)((Header).abL21StartCode[2]) <<  8 | \
      (DWORD)((Header).abL21StartCode[3]) )
#define GETATSCUD_IDENTIFIER(Header)             \
    ( (DWORD)((Header).abL21Identifier[0]) << 24 | \
      (DWORD)((Header).abL21Identifier[1]) << 16 | \
      (DWORD)((Header).abL21Identifier[2]) <<  8 | \
      (DWORD)((Header).abL21Identifier[3]) )
#define GETATSCUD_TYPECODE(Header)    (DWORD)((Header).bL21UDTypeCode)
#define ISATSCUD_TYPE_EIA(pATSCUDPacket)  (AM_L21_ATSCUD_HDR_TYPECODE_EIA == \
                                     ((pATSCUDPacket)->Header.bL21UDTypeCode & 0xFF))
#define ISATSCUD_EM_DATA(pATSCUDPacket)   (AM_L21_ATSCUD_HDR_EM_DATA_FLAG == \
                                     ((pATSCUDPacket)->Header.bL21DataFlags_Count & AM_L21_ATSCUD_HDR_EM_DATA_FLAG))
#define ISATSCUD_CC_DATA(pATSCUDPacket)   (AM_L21_ATSCUD_HDR_CC_DATA_FLAG == \
                                     ((pATSCUDPacket)->Header.bL21DataFlags_Count & AM_L21_ATSCUD_HDR_CC_DATA_FLAG))
#define ISATSCUD_ADDL_DATA(pATSCUDPacket) (AM_L21_ATSCUD_HDR_ADDL_DATA_FLAG == \
                                     ((pATSCUDPacket)->Header.bL21DataFlags_Count & AM_L21_ATSCUD_HDR_ADDL_DATA_FLAG))
#define GETATSCUD_EM_DATA(pATSCUDPacket)  ((pATSCUDPacket)->Header.bL21EMData)
#define ISATSCUD_ELEM_MARKERBITS_VALID(Elem)     (AM_L21_ATSCUD_ELEM_MARKERBITS == \
                                        ((Elem).bCCMarker_Valid_Type & AM_L21_ATSCUD_ELEM_MARKERBITS))
#define ISATSCUD_ELEM_CCVALID(Elem)  (AM_L21_ATSCUD_ELEM_VALID_FLAG == \
                                        ((Elem).bCCMarker_Valid_Type & AM_L21_ATSCUD_ELEM_VALID_FLAG))
#define GETATSCUD_ELEM_CCTYPE(Elem)    (DWORD)((Elem).bCCMarker_Valid_Type & AM_L21_ATSCUD_ELEM_TYPE_FLAG))
#define GETATSCUD_MARKERBITS(pATSCUDPacket) (DWORD)((pATSCUDPacket)->bMarkerBits)
#define ISATSCUD_MARKER_BITSVALID(pATSCUDPacket) (AM_L21_ATSCUD_MARKERBITS == \
                                       ((pATSCUDPacket)->bMarkerBits & AM_L21_ATSCUD_MARKERBITS))

// Header = StartCode + Id + TypeCode + (EM_CC_Addl_Data + CCCount) + EM_Data
#define ATSCUD_HEADERLENGTH   (4+4+1+1+1)
#define GETATSCUD_ELEMENT(pATSCUDPkt, i)  ((BYTE)(pATSCUDPkt) + ATSCUD_HEADERLENGTH + \
                                            sizeof(AM_L21_ATSCUD_ELEMENT) * i)


// CC type in GOP packet
typedef enum {
    GOP_CCTYPE_Unknown = 0,  // Invalid
    GOP_CCTYPE_None,         // all 0 -- filler packet
    GOP_CCTYPE_DVD,          // DVD CC packets
    GOP_CCTYPE_ATSC,         // ATSC CC packets
} GOPPACKET_CCTYPE ;


// Some more flag, struct and macro definitions...
#define AM_L21_INFO_FIELDBASED          0x0001
#define AM_L21_INFO_TOPFIELDFIRST       0x0003
#define AM_L21_INFO_BOTTOMFIELDFIRST    0x0005

typedef struct _AM_LINE21INFO {
    DWORD       dwFieldFlags ;
    UINT        uWidth ;
    UINT        uHeight ;
    UINT        uBitDepth ;
    DWORD       dwAvgMSecPerSample ;
} AM_LINE21INFO, *PAM_LINE21INFO ;


//
//  Message Window class (for handling WM_TIMER messages) definition
//
class CMessageWindow 
{
public:
    CMessageWindow() ;
    ~CMessageWindow() ;
    
    HWND GetHandle() {
        return m_hWnd ;
    } ;
    int  AddCount() {
        m_iCount++ ;
        return m_iCount ;
    } ;
    int  ReleaseCount() {
        if (GetHandle() == NULL)  // something wrong -- get out of here
            return 0 ;

        m_iCount-- ; 
        ASSERT(m_iCount >= 0) ;
        if (m_iCount < 0)  // paranoia!!!
            m_iCount = 0 ;
        return m_iCount ;
    } ;
    
private:
    HWND       m_hWnd ;
    int        m_iCount ;
    
    static LRESULT CALLBACK MsgWndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) ;
} ;


#define ISRECTEQUAL(r1, r2) (r1.top == r2.top && r1.left == r2.left && r1.right == r2.right && r1.bottom == r2.bottom)


//
//  Line 21 Decoder class definition
//
class CLine21DecFilter : public CTransformFilter,
                         // public ISpecifyPropertyPages, -- WILL DO LATER
                         public IAMLine21Decoder
{
    friend class CMessageWindow ;
    
private:
    static CMessageWindow  *m_pMsgWnd ; // hidden window to process WM_TIMER messages
    
public:
    
    //
    //  Constructor and destructor
    //
    CLine21DecFilter(TCHAR *, LPUNKNOWN, HRESULT *) ;
    ~CLine21DecFilter() ;
    
    //
    //   Standard COM stuff
    //
    // this goes in the factory template table to create new instances
    static CUnknown * CreateInstance(LPUNKNOWN, HRESULT *) ;
    static void InitClass(BOOL, const CLSID *) ;
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv) ;
    DECLARE_IUNKNOWN ;
    
    //
    //   CTranformFilter overrides
    //
    // I must override it
    HRESULT Transform(IMediaSample * pIn, IMediaSample * pOut) ;
    
    // Real stuff is in here...
    HRESULT Receive(IMediaSample * pIn) ;
    
    // check if you can support mtIn
    HRESULT CheckInputType(const CMediaType* mtIn) ;
    
    // check if you can support the transform from this input to
    // this output
    HRESULT CheckTransform(const CMediaType* mtIn,
                           const CMediaType* mtOut) ;
    
    // called from CBaseOutputPin to prepare the allocator's count
    // of buffers and sizes
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
							 ALLOCATOR_PROPERTIES *pProperties) ;
    
    // overriden to know when the media type is set
    HRESULT SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt) ;
    
    // overriden to suggest OUTPUT pin media types
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType) ;
    
    HRESULT EndOfStream(void) ;
    HRESULT BeginFlush(void) ;
    HRESULT EndFlush(void) ;
    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State) ;
    
    // overridden to know when we're starting/stopping the decoding
    STDMETHODIMP Stop(void) ;
    STDMETHODIMP Pause(void) ;
    
    // overridden to know when connections are completed, so that we can get 
    // the media type (actualy format) info for caching
    HRESULT CompleteConnect(PIN_DIRECTION dir, IPin *pReceivePin) ;
    
    // Override to know when we disconnect from in/output side to not use
    // any specified output format any more.
    HRESULT BreakConnect(PIN_DIRECTION dir) ;

#if 0 // no QM for now
    // We also override this one as we handle the quality management messages
    HRESULT AlterQuality(Quality q) ;
#endif // #if 0

    //
    // ISpecifyPropertyPages method
    //
    // STDMETHODIMP GetPages(CAUUID *pPages) ;
    
    //
    // IAMLine21Decoder interface methods
    //
    STDMETHODIMP GetDecoderLevel(AM_LINE21_CCLEVEL *lpLevel) ;
    STDMETHODIMP GetCurrentService(AM_LINE21_CCSERVICE *lpService) ;
    STDMETHODIMP SetCurrentService(AM_LINE21_CCSERVICE Service) ;
    STDMETHODIMP GetServiceState(AM_LINE21_CCSTATE *lpState) ;
    STDMETHODIMP SetServiceState(AM_LINE21_CCSTATE State) ;
    STDMETHODIMP GetOutputFormat(LPBITMAPINFOHEADER lpbmih) ;
    STDMETHODIMP SetOutputFormat(LPBITMAPINFO lpbmi) ;
    STDMETHODIMP GetBackgroundColor(DWORD *pdwPhysColor) ;
    STDMETHODIMP SetBackgroundColor(DWORD dwPhysColor) ;
    STDMETHODIMP GetRedrawAlways(LPBOOL lpbOption) ;
    STDMETHODIMP SetRedrawAlways(BOOL bOption) ;
    STDMETHODIMP GetDrawBackgroundMode(AM_LINE21_DRAWBGMODE *lpMode) ;
    STDMETHODIMP SetDrawBackgroundMode(AM_LINE21_DRAWBGMODE Mode) ;
    
private:   // data
    
    // Pointer to output buffer (cacheing for efficiency)
    LPBYTE              m_pbOutBuffer ;
    
    // Line21 Data Decoder class that takes 2 bytes and converts to a bitmap
    CLine21DataDecoder  m_L21Dec ;

    // What input format type is being used (better to use an integer flag)
    AM_LINE21_CCSUBTYPEID  m_eSubTypeIDIn ;
    
    GOPPACKET_CCTYPE       m_eGOP_CCType ;  // if GOPPackets used, what type data (DVD/ATSC/...)

    REFERENCE_TIME  m_rtTimePerSample ;  // (in 100 nSec) interval per byte pair from a packet (for GOP packet type)
    REFERENCE_TIME  m_rtStart ;          // start time for an output sample
    REFERENCE_TIME  m_rtStop ;           // stop time for an out output sample
    REFERENCE_TIME  m_rtLastSample ;     // start time of last delivered sample
    LONGLONG        m_llMediaStart ;     // media time start (rarely used, but...)
    REFERENCE_TIME  m_llMediaStop ;      // media time stop (rarely used, but...)
    
    // flag to detect if we must send an output sample
    BOOL        m_bMustOutput ;

    // flag to remember if the last input sample was a discontiuity sample
    BOOL        m_bDiscontLast ;
    
    // If the upstream filter doesn't specify any format type, use one from
    // our internal defaults
    VIDEOINFO  *m_pviDefFmt ;
    DWORD       m_dwDefFmtSize ;
    
    // Keep a copy of last output sample's bounding rect
    RECT        m_rectLastOutput ;
    IPin       *m_pPinDown ;    // downstream pin connected to our output
    
    CMediaType  m_mtOutput ; // current output mediatype (cached)
    //
    // For timer arrangement to complete any scrolling in roll-up mode
    // or to clear old CC (only in byte pair mode as DVD doesn't need it),
    // if input data flow stops in the middle.
    //
    UINT_PTR     m_uTimerID ;    // timer id
    UINT         m_uTimerCount ; // count of how many times TimerProc() was entered;
                                 // used for timing out CC in byte pair mode.
    BOOL         m_bTimerClearReqd ;  // timer reqd for clearing old CC

    //
    // Data for Blending Param operation on the OverlayMixer's in pin
    //
    DWORD        m_dwBlendParam ;    // blend param from Get..() call
    BOOL         m_bBlendingState ;  // CC blending state last set

#if 0 // no QM for now
    // number of samples to skip between every output CC sample for QM handling
    int          m_iSkipSamples ;
#endif // #if 0

#ifdef PERF
    int          m_idDelvWait ;
#endif // PERF
    
private:   // functions
    void    GetActualColorKey(void) ;
    AM_LINE21_CCSUBTYPEID MapGUIDToID(const GUID *pFormatIn) ;
    BOOL    VerifyGOPUDPacketData(PAM_L21_GOPUD_PACKET pGOPUDPacket) ;
    BOOL    VerifyATSCUDPacketData(PAM_L21_ATSCUD_PACKET pATSCUDPacket) ;
    BOOL    IsFillerPacket(BYTE *pGOPPacket) ;
    DWORD   GetOwnPalette(int iNumEntries, PALETTEENTRY *ppe) ;
    HRESULT GetDefaultFormatInfo(void) ;
    BOOL    IsValidFormat(BYTE *pbFormat) ;
    HRESULT SendOutputSample(IMediaSample *pIn, 
                    REFERENCE_TIME *prtStart, REFERENCE_TIME *prtStop) ;
    void    SetBlendingState(BOOL bState) ;
    void    SetupTimerIfReqd(BOOL bTimerClearReqd) ;
    void    FreeTimer(void) ;
    static void CALLBACK TimerProc(HWND hWnd, UINT uMsg, UINT_PTR uID, DWORD dwTime) ;

    GOPPACKET_CCTYPE DetectGOPPacketDataType(BYTE *pGOPPacket) ;
    HRESULT ProcessGOPPacket_DVD(IMediaSample *pIn) ;
    HRESULT ProcessGOPPacket_ATSC(IMediaSample *pIn) ;

#if 0 // no QM for now
    inline int  GetSkipSamples(void)   { return m_iSkipSamples ; }
    inline void ResetSkipSamples(void) { m_iSkipSamples = 0 ; } ;
#endif // #if 0
} ;

#pragma pack(pop)

#endif // _INC_L21DFILT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\lin21dec\l21decod.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
//
//  L21Decod.h: Line 21 Decoder engine base class code
//

#ifndef _INC_L21DECOD_H
#define _INC_L21DECOD_H


//
//  Forward declarations
//
class CLine21DataDecoder ;


//
//  Input data type ID (rather than GUID) for internal functioning
//
typedef enum _AM_LINE21_CCSUBTYPEID {
    AM_L21_CCSUBTYPEID_Invalid = 0,
    AM_L21_CCSUBTYPEID_BytePair,
    AM_L21_CCSUBTYPEID_GOPPacket,
    AM_L21_CCSUBTYPEID_VBIRawData
} AM_LINE21_CCSUBTYPEID, *PAM_LINE21_CCSUBTYPEID ;

//
//  A set of values indicating what type of control code was received
//
#define L21_CONTROLCODE_INVALID     0
#define L21_CONTROLCODE_PAC         1
#define L21_CONTROLCODE_MIDROW      2
#define L21_CONTROLCODE_MISCCONTROL 3


//
//  CLine21DataDecoder: class for decoding from byte pair and output to bitmap
//
class CLine21DataDecoder {
public:  // public methods for CLine21Filter to call
    CLine21DataDecoder::CLine21DataDecoder(
                            AM_LINE21_CCSTYLE eStyle = AM_L21_CCSTYLE_None,
                            AM_LINE21_CCSTATE eState = AM_L21_CCSTATE_Off,
                            AM_LINE21_CCSERVICE eService = AM_L21_CCSERVICE_None) ;
    ~CLine21DataDecoder(void) ;
    
    void InitState(void) ;
    BOOL InitCaptionBuffer(void) ;  // all buffers
    BOOL InitCaptionBuffer(AM_LINE21_CCSTYLE eCCStyle) ; // only needed buffer(s)
    BOOL DecodeBytePair(BYTE chFirst, BYTE chSecond) ;
    BOOL UpdateCaptionOutput(void) ;
    inline BOOL IsOutputReady(void)  { return m_GDIWork.IsBitmapDirty() ; } ;
    void CopyOutputDIB(void) ;
    void CompleteScrolling(void) ;
    inline AM_LINE21_CCSTYLE GetCaptionStyle()   { return m_eCCStyle ; } ;
    AM_LINE21_CCSTYLE SetCaptionStyle(AM_LINE21_CCSTYLE eStyle) ;
    inline BOOL IsScrolling(void)   { return m_bScrolling ; } ;
    void FlushInternalStates(void) ;
    inline BOOL IsOutDIBClear(void) {
        return m_GDIWork.IsOutDIBClear() ;
    } ;
    inline BOOL IsSizeOK(LPBITMAPINFOHEADER lpbmih) {
        return m_GDIWork.IsSizeOK(lpbmih) ;
    } ;

    // methods to allow the filter to do get/set using the 
    // IAMLine21Decoder interface
    inline AM_LINE21_CCLEVEL GetDecoderLevel(void)    { return m_eLevel ; } ;
    inline AM_LINE21_CCSERVICE GetCurrentService(void)  { return m_eUserService ; } ;
    BOOL SetCurrentService(AM_LINE21_CCSERVICE Service) ; 
    inline AM_LINE21_CCSTATE GetServiceState(void)    { return m_eState ; } ;
    BOOL SetServiceState(AM_LINE21_CCSTATE eState) ;
    HRESULT GetDefaultFormatInfo(LPBITMAPINFO lpbmi, DWORD *pdwSize) {
        CAutoLock  Lock(&m_csL21Dec) ;
        return m_GDIWork.GetDefaultFormatInfo(lpbmi, pdwSize) ;
    } ;
    HRESULT GetOutputFormat(LPBITMAPINFOHEADER lpbmih) {
        CAutoLock  Lock(&m_csL21Dec) ;
        return m_GDIWork.GetOutputFormat(lpbmih) ;
    } ;
    HRESULT GetOutputOutFormat(LPBITMAPINFOHEADER lpbmih) {
        CAutoLock  Lock(&m_csL21Dec) ;
        return m_GDIWork.GetOutputOutFormat(lpbmih) ;
    } ;
    HRESULT SetOutputOutFormat(LPBITMAPINFO lpbmi) {
        CAutoLock  Lock(&m_csL21Dec) ;
        return m_GDIWork.SetOutputOutFormat(lpbmi) ;
    } ;
    HRESULT SetOutputInFormat(LPBITMAPINFO lpbmi) {
        CAutoLock  Lock(&m_csL21Dec) ;
        return m_GDIWork.SetOutputInFormat(lpbmi) ;
    } ;
    inline void GetBackgroundColor(DWORD *pdwPhysColor) { 
        m_GDIWork.GetBackgroundColor(pdwPhysColor) ;
    } ;
    inline BOOL SetBackgroundColor(DWORD dwPhysColor) {
        return m_GDIWork.SetBackgroundColor(dwPhysColor) ;
    } ;
    inline BOOL GetRedrawAlways() { return m_bRedrawAlways ; } ;
    inline void SetRedrawAlways(BOOL Option) { m_bRedrawAlways = !!Option ; } ;
    inline AM_LINE21_DRAWBGMODE GetDrawBackgroundMode(void) { 
        return (m_GDIWork.GetBackgroundOpaque() ?
                AM_L21_DRAWBGMODE_Opaque : AM_L21_DRAWBGMODE_Transparent) ;
    } ;
    inline void SetDrawBackgroundMode(AM_LINE21_DRAWBGMODE Mode) { 
        m_GDIWork.SetBackgroundOpaque(AM_L21_DRAWBGMODE_Opaque == Mode) ;
    } ;
    
    // methods to pass values between the CLine21DecFilter class and CGDIWork class
    BOOL CreateOutputDC(void)  {
        CAutoLock  Lock(&m_csL21Dec) ;
        return m_GDIWork.CreateOutputDC() ;
    } ;
    void DeleteOutputDC(void)  { 
        CAutoLock  Lock(&m_csL21Dec) ;
        m_GDIWork.DeleteOutputDC() ;
    } ;
    
    // some general methods to communicate with the container class
    inline void SetOutputBuffer(LPBYTE lpbOut) {
        m_GDIWork.SetOutputBuffer(lpbOut) ;
    } ;
    inline void FillOutputBuffer(void) {
        m_GDIWork.FillOutputBuffer() ;
    } ;
    inline void InitColorNLastChar(void) {
        m_GDIWork.InitColorNLastChar() ;
    } ;
    void CalcOutputRect(RECT *prectOut) ;
    inline DWORD GetPaletteForFormat(LPBITMAPINFOHEADER lpbmih) {
        return m_GDIWork.GetPaletteForFormat(lpbmih) ;
    } ;
    
private:   // private helper methods
    //
    //  The following methods are for implementing the actual decoding
    //  algorithm.
    //
    BOOL IsMidRowCode(BYTE chFirst, BYTE chSecond) ;
    BOOL IsPAC(BYTE chFirst, BYTE chSecond) ;
    BOOL IsMiscControlCode(BYTE chFirst, BYTE chSecond) ;
    UINT CheckControlCode(BYTE chFirst, BYTE chSecond) ;
    BOOL IsSpecialChar(BYTE chFirst, BYTE chSecond) ;
    BOOL ValidParity(BYTE ch) ;
    BOOL IsStandardChar(BYTE ch)  { return (ch >= 0x20 && ch <= 0x7F) ; } ;
    BOOL ProcessControlCode(UINT uCodeType, BYTE chFirst, BYTE chSecond) ;
    BOOL DecodePAC(BYTE chFirst, BYTE chSecond) ;
    BOOL DecodeMidRowCode(BYTE chFirst, BYTE chSecond) ;
    BOOL DecodeMiscControlCode(BYTE chFirst, BYTE chSecond) ;
    BOOL LineFromRow(UINT uCurrRow) ;
    BOOL ProcessPrintableChar(BYTE ch) ;
    BOOL ProcessSpecialChar(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleRCL(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleBS(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleDER(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleRU(BYTE chFirst, BYTE chSecond, int iLines) ;
    BOOL HandleFON(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleRDC(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleTR(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleRTD(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleEDM(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleCR(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleENM(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleEOC(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleTO(BYTE chFirst, BYTE chSecond, int iCols) ;
    
    void SetNewLinePosition(int iLines, UINT uCurrRow) ;
    BOOL PutCharInBuffer(UINT16 wChar, BOOL bMidRowCode = FALSE) ; // put char in buffer (& MRC too)
    BOOL IsEmptyLine(int iLine) ;   // Is the line empty (no non-Xparent chars)?
    BOOL RemoveCharsInBuffer(int iNumChars) ;  // removes n chars to the right of current col
    BOOL PrintTextToBitmap(void) ;  // creates bitmap image of the caption text
    void UpdateBoundingRect(RECT *prectOut, RECT *prectLine) ;
    
    //
    //  The following methods are defined to bring uniformity in coding of
    //  the algorithm irrespective of any caption style being used.
    //
    CCaptionBuffer * GetDispBuffer(void) ;    // display buffer: mainly for Pop-On style
    void ClearBuffer(void) ;
    void RemoveLineFromBuffer(UINT8 uLine, BOOL bUpNextLine) ;
    void GetCaptionChar(UINT8 uLine, UINT8 uCol, CCaptionChar& cc) ;
    CCaptionChar * GetCaptionCharPtr(UINT8 uLine, UINT8 uCol) ;
    void SetCaptionChar(const UINT8 uLine, const UINT8 uCol,
                        const CCaptionChar& cc) ;
    int  GetMaxLines(void) ;
    void SetMaxLines(UINT uLines) ;
    int  GetNumLines(void) ;
    void SetNumLines(UINT uLines) ;
    int  GetNumCols(int iLines) ;
    int  GetRow(UINT uLine) ;
    int  GetCurrLine(void) ;
    int  GetCurrCol(void) ;
    void SetCurrLine(UINT8 uLine) ;
    void SetCurrCol(UINT8 uCol) ;
    int  GetStartRow(UINT8 uLine) ;
    int  GetRowIndex(UINT8 uRow) ;
    void SetStartRow(UINT8 uLine, UINT8 uRow) ;
    void SetRowIndex(UINT8 uLine, UINT8 uRow) ;
    int  IncCurrCol(UINT uNumChars) ;
    int  DecCurrCol(UINT uNumChars) ;
    int  IncNumChars(UINT uLine, UINT uNumChars) ;
    int  DecNumChars(UINT uLine, UINT uNumChars) ;
    int  IncNumLines(UINT uLines) ;
    int  DecNumLines(UINT uLines) ;
    void MoveCaptionChars(int uLine, int iNum) ;
    
    BOOL IsCapBufferDirty(void) ;
    BOOL IsRedrawLine(UINT8 uLine) ;
    BOOL IsRedrawAll(void) ;
    void SetCapBufferDirty(BOOL bState) ;
    void SetRedrawLine(UINT8 uLine, BOOL bState) ;
    void SetRedrawAll(BOOL bState) ;
    
    void SetScrollState(BOOL bState) ;
    int  IncScrollStartLine(int iCharHeight) ;
    void SkipScrolling(void) ;   // CR came while scrolling; skip current one
    void MoveCaptionLinesUp(void) ;  // remove top line, move other lines up
    void RelocateRollUp(UINT uBaseRow) ; // move roll-up caption to given base row

    //
    //  Common buffers used for all CC modes
    //
    CCaptionBuffer * GetCaptionBuffer(void) ;
    CCaptionBuffer * GetDisplayBuffer(void) ;
    inline int  GetBufferIndex(void)  { return m_iBuffIndex ; } ;
    inline void SetBufferIndex(int iIndex) ;
    inline void SwapBuffers(void)  { m_iBuffIndex = 1 - m_iBuffIndex ; } ;
    
private:  // private data
    CCritSec            m_csL21Dec ;   // to serialize operations on line21 decoder object

    CCaptionBuffer *    m_pCurrBuff ;
    
    // Actual caption buffer with text and attribs/positions/banks etc
    CCaptionBuffer      m_aCCData[2] ;
    int                 m_iBuffIndex ; // index for current CC data buffer
    
    CGDIWork            m_GDIWork ;    // GDI details class as a member

    UINT                m_uFieldNum ;  // Field number: 1 or 2 (top/bottom)
    
    // What style caption is being displayed now and was used last
    AM_LINE21_CCSTYLE   m_eCCStyle ;
    AM_LINE21_CCSTYLE   m_eLastCCStyle ;
    
    // Is Line 21 decoding On/Off
    AM_LINE21_CCSTATE   m_eState ;
    
    // Which service is currently being viewed by the user
    AM_LINE21_CCSERVICE m_eUserService ;  // one of C1/C2/T1/T2/XDS
    
    // Decoder is standard or enhanced
    AM_LINE21_CCLEVEL   m_eLevel ;
    
    //
    //  Some internal states during decoding
    //
    AM_LINE21_CCSERVICE m_eDataService ; // service indicated by received bytes
    UINT                m_uCurrFGEffect ;  // FG effect of current position
    UINT                m_uCurrFGColor ;   // FG color of current position
    
    BOOL                m_bExpectRepeat ;  // should we expect a repeat of last pair?
    BYTE                m_chLastByte1 ;    // the 1st second byte processed
    BYTE                m_chLastByte2 ;    // the 2nd second byte processed
    
    BOOL                m_bScrolling ;     // are we in the middle of scrolling up?
    int                 m_iScrollStartLine ; // current scan line to be scrolled off
    
    BOOL                m_bRedrawAlways ;  // client wants a total redraw per sample
    
#ifdef PERF
    int          m_idTxt2Bmp ;
    int          m_idBmp2Out ;
    int          m_idScroll ;
#endif // PERF
} ;


//
//  Some misc. constant definitions
//
#define INVALID_CHANNEL     -1

//
//  Some macros to hide some gory details
//
#define ISSUBTYPEVALID(ID) (AM_L21_CCSUBTYPEID_BytePair   == ID || \
                            AM_L21_CCSUBTYPEID_GOPPacket  == ID || \
                            AM_L21_CCSUBTYPEID_VBIRawData == ID)

#endif _INC_L21DECOD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\lin21dec\l21dgdi.cpp ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.

//
// ActiveMovie Line 21 Decoder Filter: GDI-related base class code
//

#include <streams.h>
#include <windowsx.h>

// #ifdef FILTER_DLL
#include <initguid.h>
// #endif

#include <IL21Dec.h>
#include "L21DBase.h"
#include "L21DGDI.h"
#include "L21Decod.h"


//
//  CGDIWork: class for GDI details to print caption text to output bitmap
//
CGDIWork::CGDIWork(void)
{
    DbgLog((LOG_TRACE, 1, TEXT("CGDIWork::CGDIWork()"))) ;
    
#ifdef PERF
    m_idClearIntBuff = MSR_REGISTER(TEXT("L21DPerf - Int Buff Clear")) ;
    m_idClearOutBuff = MSR_REGISTER(TEXT("L21DPerf - Out Buff Clear")) ;
#endif // PERF

#ifdef TEST
    m_hDCTest = CreateDC("Display",NULL, NULL, NULL) ;       // a DC on the desktop just for testing
    ASSERT(m_hDCTest) ;
#endif // TEST
    
    // Init some of the members
    m_hDCInt = CreateCompatibleDC(NULL) ;
    ASSERT(m_hDCInt) ;
    m_bDCInited    = FALSE ;  // DC is not init-ed yet
    m_hBmpInt      = NULL ;
    m_lpbIntBuffer = NULL ;
    m_hBmpIntOrig  = NULL ;
    m_lpbOutBuffer = NULL ;
    m_bOutputInverted = FALSE ; // by default +ve output height
    m_hFontOrig    = NULL ;
    m_hFontDef     = NULL ;
    m_hFontSpl     = NULL ;
    
    // Create an initial input BITMAPINFO struct to start with
    InitBMIData() ;
    m_lpBMIOut = NULL ;
    m_uBMIOutSize = 0 ;
    
    // Init the width and height based on prelim size so that we can compare 
    // any size changes later
    if (m_lpBMIIn)  // InitBMIData() succeeded as it should
    {
        m_lWidth  = m_lpBMIIn->bmiHeader.biWidth ;
        m_lHeight = m_lpBMIIn->bmiHeader.biHeight ;
    }
    else  // InitBMIData() failed -- bad case!!!
    {
        m_lWidth  = 320 ;
        m_lHeight = 240 ;
    }
    
    // set the default color key for output background color
    SetDefaultKeyColor(&(m_lpBMIIn->bmiHeader)) ;
    
    SetColorFiller() ; // fill color filler array with above color key
    m_bOutDIBClear = FALSE ;  // output DIB secn is cleared by ClearInternalBuffer()
    m_bBitmapDirty = FALSE ;  // bitmap isn't dirty to start with
    
    // check if Lucida Console is available (the callback sets the m_bUseTTFont flag)
    CheckTTFont() ;

    //
    // We are not supposed to use the 10% of the border on the top/bottom and left/right.
    // But leaving 10% on each side for a 320x240 image when we are using a non-TT font,
    // like "Terminal", leaves very little room for showing captions. So I leave only 5% 
    // on each side with non-TT font.
    // By doing this I am violating the spec, but it's a necessary evil.
    // When TT font (Lucida Console) is available, we leave 10% border on every side.
    //
    if ( IsTTFont() )
        m_iBorderPercent = 20 ;
    else
        m_iBorderPercent = 10 ;
    
    InitFont() ;   // init the log font struct, create and select default font
    
    m_bFontSizeOK = SetCharNBmpSize() ;   // get the char width and height for default font
    
    // We are using a black background color
    SetBkColor(m_hDCInt, RGB(  0, 0,   0)) ;
    SetBkMode(m_hDCInt, TRANSPARENT) ;
    
    // Init the COLORREF array of 7 FG colors
    m_acrFGColors[0] = RGB(255, 255, 255) ;   // white
    m_acrFGColors[1] = RGB(  0, 255,   0) ;   // green
    m_acrFGColors[2] = RGB(  0,   0, 255) ;   // blue
    m_acrFGColors[3] = RGB(  0, 255, 255) ;   // cyan
    m_acrFGColors[4] = RGB(255,   0,   0) ;   // red
    m_acrFGColors[5] = RGB(255, 255,   0) ;   // yellow
    m_acrFGColors[6] = RGB(128,   0, 128) ;   // (dull) magenta
    // m_acrFGColors[6] = RGB(255,   0, 255) ;   // magenta
    
    InitColorNLastChar() ;  // init with a text color and last CC char printed
    
    // For now assume a non-opaque background
    m_bOpaque = TRUE ;
}

CGDIWork::~CGDIWork(void)
{
    DbgLog((LOG_TRACE, 1, TEXT("CGDIWork::~CGDIWork()"))) ;
    
    // Delete the DIBSection associated with this DC
    DeleteOutputDC() ;
    
    // Unselect and delete the selected font
    if (m_bUseSplFont)   // if special font is in use now
    {
        SelectObject(m_hDCInt, m_hFontOrig) ;
        DeleteObject(m_hFontSpl) ;
        m_hFontSpl = NULL ;
        m_bUseSplFont = FALSE ;
    }
    else    // default font in use now
    {
        SelectObject(m_hDCInt, m_hFontOrig) ;
    }
    DeleteObject(m_hFontDef) ;  // delete the default font in any case
    m_hFontDef = NULL ;
    
    // Now delete the DC
    DeleteDC(m_hDCInt) ;
    m_hDCInt = NULL ;
    
    // release BMI data pointer
    if (m_lpBMIOut)
        delete m_lpBMIOut ;
    m_uBMIOutSize = 0 ;
    if (m_lpBMIIn)
        delete m_lpBMIIn ;
    m_uBMIInSize = 0 ;
    
#ifdef TEST
    DeleteDC(m_hDCTest) ;  // a DC on the desktop just for testing
    DbgLog((LOG_ERROR, 1, TEXT("Test DC is being released"))) ;
#endif // TEST
}


int CALLBACK CGDIWork::EnumFontProc(ENUMLOGFONTEX *lpELFE, NEWTEXTMETRIC *lpNTM, 
                                    int iFontType, LPARAM lParam)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::EnumFontProc(0x%lx, 0x%lx, %d, %ld)"), 
            lpELFE, lpNTM, iFontType, lParam)) ;

    // Just verify that we got a valid TT font
    if ( !(lpELFE->elfLogFont.lfCharSet & 0xFFFFFF00) &&
        !(lpELFE->elfLogFont.lfPitchAndFamily & 0xFFFFFF00) &&
        !(iFontType & 0xFFFF0000) )
    {
        ASSERT(lpELFE->elfLogFont.lfPitchAndFamily & (FIXED_PITCH | FF_MODERN)) ;
        ((CGDIWork *) (LPVOID) lParam)->m_lfChar = lpELFE->elfLogFont ;
        ((CGDIWork *) (LPVOID) lParam)->m_bUseTTFont = TRUE ;
        return 1 ;
    }
    
    ASSERT(FALSE) ;  // Weird!!! We should know about it.
    return 0 ;
}


void CGDIWork::CheckTTFont(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::CheckTTFont()"))) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    m_bUseTTFont = FALSE ;  // assume not available
    ZeroMemory(&m_lfChar, sizeof(LOGFONT)) ;
    lstrcpy(m_lfChar.lfFaceName, TEXT("Lucida Console")) ;
    m_lfChar.lfCharSet = ANSI_CHARSET ;
    m_lfChar.lfPitchAndFamily = 0 ;
    EnumFontFamiliesEx(m_hDCInt, &m_lfChar, (FONTENUMPROC) EnumFontProc, (LPARAM)(LPVOID)this, 0) ;
}


void CGDIWork::InitColorNLastChar(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::InitColorNLastChar()"))) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    // Last caption char init
    m_ccLast.SetChar(0) ;
    m_ccLast.SetEffect(0) ;
    m_ccLast.SetColor(AM_L21_FGCOLOR_WHITE) ;
    
    // Use white as default text color
    m_uColorIndex = AM_L21_FGCOLOR_WHITE ;
    if (CLR_INVALID == SetTextColor(m_hDCInt, m_acrFGColors[m_uColorIndex]))
        ASSERT(FALSE) ;
}


void CGDIWork::SetDefaultKeyColor(LPBITMAPINFOHEADER lpbmih)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::SetDefaultKeyColor(0x%lx)"), lpbmih)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    switch (lpbmih->biBitCount)
    {
    case 8:   
        m_dwPhysColor = 253 ;   // hard coded for magenta
        break ;
        
    case 16:
        if (BI_BITFIELDS == lpbmih->biCompression)  // 565
            m_dwPhysColor = (0x1F << 11) | (0 << 9 ) | (0x1F) ; // magenta by default
        else                                        // 555
            m_dwPhysColor = (0x1F << 10) | (0 << 8 ) | (0x1F) ; // magenta by default
        break ;
        
    case 24:
        m_dwPhysColor = RGB(0xFF, 0, 0xFF) ; // magenta by default
        break ;
        
    case 32:
        m_dwPhysColor = RGB(0xFF, 0, 0xFF) ; // magenta by default
        break ;
        
    default:
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: UFOs have finally landed here!!"))) ;
        break ;
    }
}


#define SETPALETTECOLOR(pe, r, g, b)  pe.peRed = r ; pe.peGreen = g ; pe.peBlue = b ; pe.peFlags = 0 ;

DWORD CGDIWork::GetOwnPalette(int iNumEntries, PALETTEENTRY *ppe)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetOwnPalette(%d, 0x%lx)"), 
            iNumEntries, ppe)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;

    ASSERT(iPALETTE_COLORS == iNumEntries) ;
    ASSERT(! IsBadWritePtr(ppe, sizeof(PALETTEENTRY) * iNumEntries)) ;
    
    ZeroMemory(ppe, sizeof(PALETTEENTRY) * iNumEntries) ;  // clear all first
    SETPALETTECOLOR(ppe[0]  ,   0,   0,   0) ;  // black
    SETPALETTECOLOR(ppe[1]  , 128,   0,   0) ;  // brown
    SETPALETTECOLOR(ppe[2]  ,   0, 128,   0) ;  // green
    SETPALETTECOLOR(ppe[3]  , 128, 128,   0) ;  // some mix
    SETPALETTECOLOR(ppe[4]  ,   0,   0, 128) ;  // blue
    SETPALETTECOLOR(ppe[5]  , 128,   0, 128) ;  // dull magenta
    SETPALETTECOLOR(ppe[6]  ,   0, 128, 128) ;  // dull cyan
    SETPALETTECOLOR(ppe[7]  , 192, 192, 192) ;  // gray
    SETPALETTECOLOR(ppe[8]  , 192, 220, 192) ;  // greenish gray
    SETPALETTECOLOR(ppe[9]  , 166, 202, 240) ;  // very lt blue
    SETPALETTECOLOR(ppe[246], 255, 251, 240) ;  // dull white
    SETPALETTECOLOR(ppe[247], 160, 160, 164) ;  // lt gray
    SETPALETTECOLOR(ppe[248], 128, 128, 128) ;  // dark gray
    SETPALETTECOLOR(ppe[249], 255,   0,   0) ;  // red
    SETPALETTECOLOR(ppe[250],   0, 255,   0) ;  // lt green
    SETPALETTECOLOR(ppe[251], 255, 255,   0) ;  // yellow
    SETPALETTECOLOR(ppe[252],   0,   0, 255) ;  // lt blue
    SETPALETTECOLOR(ppe[253], 255,   0, 255) ;  // magenta/pink
    SETPALETTECOLOR(ppe[254],   0, 255, 255) ;  // cyan
    SETPALETTECOLOR(ppe[255], 255, 255, 255) ;  // white
    
    return iNumEntries ;
}


DWORD CGDIWork::GetPaletteForFormat(LPBITMAPINFOHEADER lpbmih)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter::GetOwnPalette(0x%lx)"), lpbmih)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;

    // Now set the palette data too; we pick the system palette colors
    HDC hDC = GetDC(NULL) ;
    if (NULL == hDC)
    {
        ASSERT(!TEXT("GetDC(NULL) failed")) ;
        return 0 ;  // no color in palette
    }

    lpbmih->biClrUsed = GetSystemPaletteEntries(hDC, 0, iPALETTE_COLORS, 
                                        (PALETTEENTRY *)(lpbmih + 1)) ;
    lpbmih->biClrImportant = 0 ;
    ReleaseDC(NULL, hDC) ;
            
    //
    // At least on NT, GetSystemPaletteEntries() call returns 0 if the display
    // is in non-palettized mode.  In such a case, I need to hack up my own 
    // palette so that we can still support 8bpp output.
    //
    if (0 == lpbmih->biClrUsed)  // GetSystemPaletteEntries() failed
    {
        DbgLog((LOG_TRACE, 2, 
                TEXT("Couldn't get system palette (non-palette mode?) -- using own palette"))) ;
        lpbmih->biClrUsed = GetOwnPalette(iPALETTE_COLORS, (PALETTEENTRY *)(lpbmih + 1)) ;
    }

    return lpbmih->biClrUsed ;  // number of palette entries
}


bool CGDIWork::InitBMIData(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::InitBMIData()"))) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    HDC  hDCTemp = GetDC(NULL) ;
    if (NULL == hDCTemp)
    {
        ASSERT(!TEXT("GetDC(NULL) failed")) ;
        return false ;
    }
    WORD wPlanes   = (WORD)GetDeviceCaps(hDCTemp, PLANES) ;
    WORD wBitCount = (WORD)GetDeviceCaps(hDCTemp, BITSPIXEL) ;
    ReleaseDC(NULL, hDCTemp) ;

    m_uBMIInSize = sizeof(BITMAPINFOHEADER) ;  // at least

    // Increase BITMAPINFO struct size based of bpp value
    if (8 == wBitCount)        // palettized mode
        m_uBMIInSize += 256 * sizeof(RGBQUAD) ;  // for palette entries
    else // if (32 == wBitCount)  // we'll use BIT_BITFIELDS
        m_uBMIInSize += 3 * sizeof(RGBQUAD) ;    // for bitmasks

    m_lpBMIIn = (LPBITMAPINFO) new BYTE[m_uBMIInSize] ;
    if (NULL == m_lpBMIIn)
    {
        ASSERT(!TEXT("Out of memory for BMIIn buffer")) ;
        return false ;
    }
    m_lpBMIIn->bmiHeader.biSize = sizeof(BITMAPINFOHEADER) ;
    m_lpBMIIn->bmiHeader.biWidth = CAPTION_OUTPUT_WIDTH ;
    m_lpBMIIn->bmiHeader.biHeight = CAPTION_OUTPUT_HEIGHT ;
    m_lpBMIIn->bmiHeader.biPlanes   = wPlanes ;
    m_lpBMIIn->bmiHeader.biBitCount = wBitCount ;
    // We should detect the 16bpp - 565 mode too; but how??
    if (32 == m_lpBMIIn->bmiHeader.biBitCount)
        m_lpBMIIn->bmiHeader.biCompression = BI_BITFIELDS ;
    else
        m_lpBMIIn->bmiHeader.biCompression = BI_RGB ;
    m_lpBMIIn->bmiHeader.biSizeImage = DIBSIZE(m_lpBMIIn->bmiHeader) ;
    m_lpBMIIn->bmiHeader.biXPelsPerMeter = 0 ;
    m_lpBMIIn->bmiHeader.biYPelsPerMeter = 0 ;
    m_lpBMIIn->bmiHeader.biClrUsed = 0 ;
    m_lpBMIIn->bmiHeader.biClrImportant = 0 ;
    
    //
    // If we are in bitfield mode, set the bmiColors values too.
    // If we are in palettized mode, pickthe system palette.
    //
    switch (m_lpBMIIn->bmiHeader.biBitCount)
    {
    case 8:
        GetPaletteForFormat((LPBITMAPINFOHEADER) m_lpBMIIn) ;
        break ;

    case 16:  // just clear it off
    case 24:  //  .. ditto ..
    case 32:  // set the masks
        {
            DWORD  *pdw = (DWORD *) m_lpBMIIn->bmiColors ;
            if (m_lpBMIIn->bmiHeader.biCompression == BI_BITFIELDS)
            {
                pdw[iRED]   = bits888[iRED] ;
                pdw[iGREEN] = bits888[iGREEN] ;
                pdw[iBLUE]  = bits888[iBLUE] ;
            }
            else              // BI_RGB
            {
                pdw[iRED]   = 
                pdw[iGREEN] = 
                pdw[iBLUE]  = 0 ;
            }
        }
        break ;

    default:  // don't care
        ASSERT(!TEXT("Bad biBitCount!!")) ;
        break ;
    }

    return true ;
}


BOOL CGDIWork::InitFont(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::InitFont()"))) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    LPBITMAPINFOHEADER  lpbmih = (m_lpBMIOut ? LPBMIHEADER(m_lpBMIOut) : LPBMIHEADER(m_lpBMIIn)) ;
    ASSERT(lpbmih) ;
    int   iWidth, iHeight ;
    if (! CharSizeFromOutputSize(lpbmih->biWidth, lpbmih->biHeight, &iWidth, &iHeight) )
    {
        DbgLog((LOG_ERROR, 0, 
                TEXT("ERROR: CGDIWork::CharSizeFromOutputSize() failed for %ld x %ld output"), 
                lpbmih->biWidth, lpbmih->biHeight)) ;
        return FALSE ;
    }

    // Init a LOGFONT struct in m_lfChar
    if (m_bUseTTFont)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Got Lucida Console TT Font (%d x %d)."), iWidth, iHeight)) ;
        m_lfChar.lfHeight = -iHeight ;  // -Y means I want "Y only"
        m_lfChar.lfWidth  = -iWidth ;   // -X means I want "X only"

        // m_lfChar.lfFaceName is "Lucida Console"
    }
    else  // no Lucida Console; use 8x12 Terminal font
    {
        DbgLog((LOG_TRACE, 1, 
                TEXT("Did NOT get Lucida Console TT Font. Will use Terminal %d x %d"), 
                iWidth, iHeight)) ;
        m_lfChar.lfHeight = iHeight ;
        m_lfChar.lfWidth  = iWidth ;
        m_lfChar.lfCharSet = OEM_CHARSET ;  // or ANSI???
        m_lfChar.lfPitchAndFamily = FIXED_PITCH | FF_MODERN ;
        lstrcpy(m_lfChar.lfFaceName, TEXT("Terminal")) ;
    }
    m_lfChar.lfEscapement = 0 ;
    m_lfChar.lfOrientation = 0 ;
    m_lfChar.lfWeight = FW_NORMAL ;
    m_lfChar.lfItalic = FALSE ;
    m_lfChar.lfUnderline = FALSE ;
    m_lfChar.lfStrikeOut = FALSE ;
    // m_lfChar.lfCharSet set in CheckTTFont() or above
    m_lfChar.lfOutPrecision = OUT_STRING_PRECIS ;
    m_lfChar.lfClipPrecision = CLIP_STROKE_PRECIS ;
    m_lfChar.lfQuality = DRAFT_QUALITY ;
    // m_lfChar.lfPitchAndFamily set in CheckTTFont() or above
    
    // Create and init the font handles using the above LOGFONT data
    if (m_hFontOrig && m_hFontDef)  // if we are re-initing font stuff
    {
        SelectObject(m_hDCInt, m_hFontOrig) ;  // unselect the default font
        DeleteObject(m_hFontDef) ;             // delete the default font
        // m_hFontDef = NULL ;
        if (m_hFontSpl)  // if we have the special font for italics/UL
        {
            DeleteObject(m_hFontSpl) ;         // delete it
            m_hFontSpl = NULL ;
            m_bUseSplFont = FALSE ;            // no special font now
        }
    }
    
    // Anyway create the default font now and select it in internal DC
    m_hFontDef    = CreateFontIndirect(&m_lfChar) ;
    m_hFontSpl    = NULL ;
    m_bUseSplFont = FALSE ;
    m_hFontOrig   = (HFONT) SelectObject(m_hDCInt, m_hFontDef) ;

    return TRUE ;  // success
}


void CGDIWork::SetNumBytesValues(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::SetNumBytesValues()"))) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    // If we have a output format specified by the downstream filter then use that ONLY
    if (m_lpBMIOut)
    {
        m_uBytesPerPixel = m_lpBMIOut->bmiHeader.biBitCount >> 3 ;
        m_uBytesPerSrcScanLine = m_uIntBmpWidth * m_uBytesPerPixel ;
        m_uBytesPerDestScanLine = m_lpBMIOut->bmiHeader.biWidth * m_uBytesPerPixel ;
        return ;
    }
    
    // If no output format has been defined by the downstream filter, use upstream's
    if (m_lpBMIIn)
    {
        m_uBytesPerPixel = m_lpBMIIn->bmiHeader.biBitCount >> 3 ;
        m_uBytesPerSrcScanLine = m_uIntBmpWidth * m_uBytesPerPixel ;
        m_uBytesPerDestScanLine = m_lpBMIIn->bmiHeader.biWidth * m_uBytesPerPixel ;
    }
    else  // somehow output BMI not specified yet
    {
        DbgLog((LOG_ERROR, 1, TEXT("How did we not have a m_lpBMIIn defined until now?"))) ;
        m_uBytesPerPixel = 0 ;
        m_uBytesPerSrcScanLine = 0 ;
        m_uBytesPerDestScanLine = 0 ;
    }
}


BOOL CGDIWork::SetCharNBmpSize(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::SetCharNBmpSize()"))) ;
    CAutoLock  Lock(&m_csL21DGDI) ;

    if (NULL == m_hDCInt)  // HDC not yet created -- very unlikely!!
        return FALSE ;
    
    // Get the char width and height now
    TEXTMETRIC  tm ;
    GetTextMetrics(m_hDCInt, &tm) ;
    m_uCharWidth = tm.tmAveCharWidth ;
    m_uCharHeight = tm.tmHeight ;  // + tm.tmInternalLeading + tm.tmExternalLeading ;
    DbgLog((LOG_TRACE, 1, TEXT("    *** Chars are %d x %d pixels"), m_uCharWidth, m_uCharHeight)) ;
    
    // We need to scroll the scan lines by as many lines as necessary to complete
    // scrolling within 12 steps max, approx. 0.4 seconds which is the EIA-608
    // standard requirement.
    m_iScrollStep = (int)((m_uCharHeight + DEFAULT_CHAR_HEIGHT - 1) / DEFAULT_CHAR_HEIGHT) ;
    
    // Internal bitmap width and height based on char sizes
    m_uIntBmpWidth  = m_uCharWidth * (MAX_CAPTION_COLUMNS + 2) ; // +2 for leading and trailing space
    m_uIntBmpHeight = m_uCharHeight * MAX_CAPTION_LINES ;        // max 4 lines of caption shown
    
    // Leave a band along the border acc. to the spec.
    LPBITMAPINFOHEADER  lpbmih = (m_lpBMIOut ? LPBMIHEADER(m_lpBMIOut) : LPBMIHEADER(m_lpBMIIn)) ;
    BOOL bOK = (m_uIntBmpWidth - MAX_CAPTION_COLUMNS / 2 - 1 <=             // minus to handle rounding
                   (UINT)(lpbmih->biWidth * (100 - m_iBorderPercent) / 100))  &&
               (m_uCharHeight * MAX_CAPTION_ROWS - MAX_CAPTION_ROWS / 2 <=  // minus to handle rounding
                   (UINT)(ABS(lpbmih->biHeight) * (100 - m_iBorderPercent) / 100)) ;
    ASSERT(bOK) ;
    if (! bOK )  // too big font for the output window
    {
        return FALSE ;
    }

    m_uIntBmpWidth = DWORDALIGN(m_uIntBmpWidth) ;  // make sure to DWORD align it

    // We want to store the following values just for speedy usage later
    //
    // horizontally we want to be in the middle
    m_uHorzOffset = (lpbmih->biWidth - m_uIntBmpWidth) / 2 ;
    // vertically we want to leave 10% of the height or leave
    // just enough space to accomodate all the caption lines
    m_uVertOffset = min( ABS(lpbmih->biHeight) * m_iBorderPercent / 200,  // border % is for 2 sides
                         (ABS(lpbmih->biHeight) - (long)(m_uCharHeight * MAX_CAPTION_ROWS)) / 2 ) ;
    
    // Now set the number bytes per pixel/line etc
    SetNumBytesValues() ;
    
    return TRUE ;
}


BOOL CGDIWork::SetBackgroundColor(DWORD dwPhysColor)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::SetBackgroundColor(0x%lx)"), dwPhysColor)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;

    BOOL  bChanged = m_dwPhysColor != dwPhysColor ;
    
    if ((DWORD) -1 == dwPhysColor)  // not from OverlayMixer
    {
        // use default for the current output format
        LPBITMAPINFOHEADER  lpbmih = (m_lpBMIOut ? LPBMIHEADER(m_lpBMIOut) : LPBMIHEADER(m_lpBMIIn)) ;
        SetDefaultKeyColor(lpbmih) ;
    }
    else  // as specified by Mixer/VR
    {
        m_dwPhysColor = dwPhysColor ;
    }
    
    // Earlier we used to check if the physical key color has changed and if so
    // only then we updated the color filler array.  Now we just go ahead and 
    // rebuild the color filler (fix for Memphis bug #72274).
    SetColorFiller() ;  // update the color filler
    
    // Rather than returning whether physical key color changed, it's better to
    // fill the background unconditionally
    return TRUE ;
}


void CGDIWork::SetColorFiller(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::SetColorFiller()"))) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    LPBITMAPINFOHEADER  lpbmih = (m_lpBMIOut ? LPBMIHEADER(m_lpBMIOut) : LPBMIHEADER(m_lpBMIIn)) ;
    int                 i ;
    
    switch (lpbmih->biBitCount)
    {
    case 8:
        for (i = 0 ; i < 12 ; i++)
            m_abColorFiller[i] = (BYTE)(m_dwPhysColor & 0xFF) ;
        break ;
        
    case 16:
        for (i = 0 ; i < 12 ; i += 2)
            *((WORD *)&m_abColorFiller[i]) = (WORD)(m_dwPhysColor & 0xFFFF) ;
        break ;
        
    case 24:
        for (i = 0 ; i < 4 ; i++)
        {
            m_abColorFiller[i * 3]     = (BYTE) (m_dwPhysColor & 0xFF) ;
            m_abColorFiller[i * 3 + 1] = (BYTE)((m_dwPhysColor & 0xFF00) >> 8) ;
            m_abColorFiller[i * 3 + 2] = (BYTE)((m_dwPhysColor & 0xFF0000) >> 16) ;
        }
        break ;
        
    case 32:
        for (i = 0 ; i < 12 ; i += 4)
            *((DWORD *)&m_abColorFiller[i]) = m_dwPhysColor ;
        break ;
        
    default:
        DbgLog((LOG_ERROR, 0, TEXT("It's just plain impossible!!!"))) ;
        break ;
    }
}


void CGDIWork::FillOutputBuffer(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::FillOutputBuffer()"))) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    // If an output format is specified by downstream filter, use it;  
    // otherwise use upstream's
    LPBITMAPINFOHEADER lpbmih = (m_lpBMIOut ? LPBMIHEADER(m_lpBMIOut) : LPBMIHEADER(m_lpBMIIn)) ;
    
    // If an output buffer is available then only fill it up; else we'll fault
    if (NULL == m_lpbOutBuffer)  // it happens the first time, it's OK.
    {
        DbgLog((LOG_ERROR, 5, TEXT("Why are we trying to fill a NULL buffer??"))) ;
        return ;
    }
    
    MSR_START(m_idClearOutBuff) ;  // start clearing out buffer
    ULONG   ulTotal = m_uBytesPerPixel * lpbmih->biWidth * ABS(lpbmih->biHeight) ;
    if (IsBadWritePtr(m_lpbOutBuffer, ulTotal))  // somehow we can't write to the buffer
    {
        DbgLog((LOG_ERROR, 1, TEXT("Bad output buffer. Skip filling it up."))) ;
        return ;
    }
    
    ULONG   ulFillerMax = ulTotal - (ulTotal % 12) ;
    ULONG   ul ;
    for (ul = 0 ; ul < ulFillerMax ; ul += 12)
        CopyMemory(m_lpbOutBuffer + ul, m_abColorFiller, 12) ;
    for (ul = 0 ; ul < ulTotal % 12 ; ul++)
        m_lpbOutBuffer[ulFillerMax + ul] = m_abColorFiller[ul] ;
    MSR_STOP(m_idClearOutBuff) ;   // done clearing out buffer
    
    // Mark the output buffer as new so that the whole content of internal 
    // buffer is copied over
    m_bNewOutBuffer = TRUE ;
}


//
// This method is required only to generate the default format block in case
// the upstream filter doesn't specify FORMAT_VideoInfo type.
//
HRESULT CGDIWork::GetDefaultFormatInfo(LPBITMAPINFO lpbmi, DWORD *pdwSize)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::GetDefaultFormatInfo(0x%lx, 0x%lx)"),
            lpbmi, pdwSize)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    if (NULL == pdwSize || IsBadWritePtr(pdwSize, sizeof(DWORD)))
    {
        return E_INVALIDARG ;
    }
    
    LPBITMAPINFO lpbmiCurr = (m_lpBMIOut ? m_lpBMIOut : m_lpBMIIn) ;
    UINT dwCurrSize = (m_lpBMIOut ? m_uBMIOutSize : m_uBMIInSize) ;
    ASSERT(dwCurrSize) ;  // just a check
    
    if (NULL == lpbmi)      // wants just the format data size
    {
        *pdwSize = dwCurrSize ;
        return NOERROR ;
    }
    
    if (IsBadWritePtr(lpbmi, *pdwSize))  // not enough space in out-param
        return E_INVALIDARG ;
    
    *pdwSize = min(*pdwSize, dwCurrSize) ;  // minm of actual and given
    CopyMemory(lpbmi, lpbmiCurr, *pdwSize) ;
    
    return NOERROR ;   // success
}


HRESULT CGDIWork::GetOutputFormat(LPBITMAPINFOHEADER lpbmih)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::GetOutputFormat(0x%lx)"), lpbmih)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    if (IsBadWritePtr(lpbmih, sizeof(BITMAPINFOHEADER)))  // not enough space in out-param
        return E_INVALIDARG ;
    
    ZeroMemory(lpbmih, sizeof(BITMAPINFOHEADER)) ;  // just to keep it clear
    
    LPBITMAPINFOHEADER lpbmihCurr = (m_lpBMIOut ? LPBMIHEADER(m_lpBMIOut) : LPBMIHEADER(m_lpBMIIn)) ;
    if (NULL == lpbmihCurr)  // no output format specified by downstream
        return S_FALSE ;
    
    CopyMemory(lpbmih, lpbmihCurr, sizeof(BITMAPINFOHEADER)) ;
    
    return S_OK ;   // success
}


HRESULT CGDIWork::GetOutputOutFormat(LPBITMAPINFOHEADER lpbmih)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::GetOutputOutFormat(0x%lx)"), lpbmih)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    if (IsBadWritePtr(lpbmih, sizeof(BITMAPINFOHEADER)))
    {
        DbgLog((LOG_ERROR, 0, TEXT("GetOutputOutFormat(): Bad in param"))) ;
        return E_INVALIDARG ;
    }
    if (m_lpBMIOut)
    {
        CopyMemory(lpbmih, m_lpBMIOut, sizeof(BITMAPINFOHEADER)) ;
        return S_OK ;
    }
    else
    {
        DbgLog((LOG_TRACE, 3, TEXT("GetOutputOutFormat(): No output format specified by downstream filter"))) ;
        return S_FALSE ;
    }
}


BOOL CGDIWork::IsSizeOK(LPBITMAPINFOHEADER lpbmih)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::IsSizeOK(0x%lx)"), lpbmih)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;

    return ((IsTTFont() && ISDWORDALIGNED(lpbmih->biWidth))  ||  // TT font and DWORD-aligned width  or
            (!IsTTFont() &&                                      // non-TT font and ...
             ((320 == ABS(lpbmih->biWidth) && 240 == ABS(lpbmih->biHeight)) ||   // 320x240 output or
              (640 == ABS(lpbmih->biWidth) && 480 == ABS(lpbmih->biHeight))))) ; // 640x480 output
}


HRESULT CGDIWork::SetOutputOutFormat(LPBITMAPINFO lpbmi)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::SetOutputOutFormat(0x%lx)"), lpbmi)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    // 
    // NULL param means output format not available from downstream filter
    //
    if (NULL == lpbmi)
    {
        if (m_lpBMIOut)
            delete m_lpBMIOut ;
        m_lpBMIOut = NULL ;
        m_uBMIOutSize = 0 ;
        
        // In this case, go back to the default output format specified by 
        // upstream filter
        if (m_lpBMIIn)
        {
            SetOutputSize(m_lpBMIIn->bmiHeader.biWidth, m_lpBMIIn->bmiHeader.biHeight) ;
            SetNumBytesValues() ;
        }
        else
        {
            DbgLog((LOG_ERROR, 1, TEXT("How did we not have a default output format?"))) ;
        }
        return NOERROR ;
    }
    
    // Just paranoid...
    if (IsBadReadPtr(lpbmi, sizeof(BITMAPINFOHEADER)))
    {
        DbgLog((LOG_ERROR, 0, TEXT("Invalid output format (out) data pointer"))) ;
        return E_INVALIDARG ;
    }

    // Make sure we can handle this output size
    if (! IsSizeOK(&lpbmi->bmiHeader) )
        return E_INVALIDARG ;

    // Danny included the beginning of the VIDEOINFOHEADER struct and I don't want it!!!
    UINT uSize = GetBitmapFormatSize((LPBITMAPINFOHEADER) lpbmi) - SIZE_PREHEADER ;
    if (NULL == m_lpBMIOut)  // If we didn't have one before then allocate space for one
    {
        m_lpBMIOut = (LPBITMAPINFO) new BYTE [uSize] ;
        if (NULL == m_lpBMIOut)
        {
            DbgLog((LOG_ERROR, 0, TEXT("Out of memory for output format info from downstream"))) ;
            return E_OUTOFMEMORY ;
        }
        m_uBMIOutSize = uSize ;  // new size
    }
    else  // we have an existing out format, but ...
    {
        // ... check if new data is bigger than the current space we have
        if (m_uBMIOutSize < uSize)
        {
            delete m_lpBMIOut ;
            m_lpBMIOut = (LPBITMAPINFO) new BYTE[uSize] ;
            if (NULL == m_lpBMIOut)
            {
                DbgLog((LOG_ERROR, 1, TEXT("Out of memory for out format BMI from downstream"))) ;
                m_uBMIOutSize = 0 ;
                return FALSE ;
            }
            m_uBMIOutSize = uSize ;
        }
    }
    
    // Make sure the output size specified by the format is such that
    // each scanline is DWORD aligned
    lpbmi->bmiHeader.biWidth = DWORDALIGN(lpbmi->bmiHeader.biWidth) ;
    lpbmi->bmiHeader.biSizeImage = DIBSIZE(lpbmi->bmiHeader) ;
    
    // Now copy the specified format data
    CopyMemory(m_lpBMIOut, lpbmi, uSize) ;
    
    // Check if the output size is changing and update all the related vars
    SetOutputSize(m_lpBMIOut->bmiHeader.biWidth, m_lpBMIOut->bmiHeader.biHeight) ;
    SetNumBytesValues() ;
    
    return NOERROR ;
}


HRESULT CGDIWork::SetOutputInFormat(LPBITMAPINFO lpbmi)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::SetOutputInFormat(0x%lx)"), lpbmi)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    // 
    // NULL param means no output format from upstream filter
    //
    if (NULL == lpbmi)
    {
#if 0
        if (m_lpBMIOut)
        {
            //
            // BTW this can happen when the graph is torn down at the end of
            // playback.  We can ignore this error in that case.
            //
            DbgLog((LOG_ERROR, 3, TEXT("Can't delete Output format from upstream w/o downstream specifying it"))) ;
            return E_INVALIDARG ;
        }
#endif // #if 0
        if (m_lpBMIIn)
            delete m_lpBMIIn ;
        // m_lpBMIIn = NULL ;
        // m_uBMIInSize = 0 ;
        
        //
        // Initialize the default output format from upstream filter
        //
        InitBMIData() ;
        
        // return NOERROR ;
    }
    else  // non-NULL format specified
    {
        UINT uSize = GetBitmapFormatSize((LPBITMAPINFOHEADER) lpbmi) ;
        if (IsBadReadPtr(lpbmi, uSize))  // just paranoid...
        {
            DbgLog((LOG_ERROR, 0, TEXT("Not enough output format (in) data pointer"))) ;
            ASSERT(FALSE) ;
            return E_INVALIDARG ;
        }

        // Make sure we can handle this output size
        if (! IsSizeOK(&lpbmi->bmiHeader) )
            return E_INVALIDARG ;

        if (NULL == m_lpBMIIn)  // If we didn't have one before then allocate space for one
        {
            m_lpBMIIn = (LPBITMAPINFO) new BYTE [uSize] ;
            if (NULL == m_lpBMIIn)
            {
                DbgLog((LOG_ERROR, 0, TEXT("Out of memory for output format info from upstream"))) ;
                return E_OUTOFMEMORY ;
            }
        }
        else  // we have an existing out format, but ...
        {
            // ... check if new data is bigger than the current space we have
            if (m_uBMIInSize < uSize)
            {
                delete m_lpBMIIn ;
                m_lpBMIIn = (LPBITMAPINFO) new BYTE[uSize] ;
                if (NULL == m_lpBMIIn)
                {
                    DbgLog((LOG_ERROR, 1, TEXT("Out of memory for out format BMI from upstream"))) ;
                    m_uBMIInSize = 0 ;
                    return FALSE ;
                }
                m_uBMIInSize = uSize ;
            }
        }
        
        // Make sure the output size specified by the format is such that
        // each scanline is DWORD aligned
        lpbmi->bmiHeader.biWidth = DWORDALIGN(lpbmi->bmiHeader.biWidth) ;
        lpbmi->bmiHeader.biSizeImage = DIBSIZE(lpbmi->bmiHeader) ;
        
        // Now copy the specified format data
        CopyMemory(m_lpBMIIn, lpbmi, uSize) ;
    }  // end of else of if (lpbmi)
    
    // If we don't have a output format specified by downstream then we'll
    // use this output format and resize the output accordingly
    if (NULL == m_lpBMIOut)
    {
        // Check if output size is changing and update all the related vars
        SetOutputSize(m_lpBMIIn->bmiHeader.biWidth, m_lpBMIIn->bmiHeader.biHeight) ;
        SetNumBytesValues() ;
        
        // Create color filler based on input-side format spec.
        SetColorFiller() ;
    }
    
    return NOERROR ;
}


void CGDIWork::ClearInternalBuffer(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::ClearInternalBuffer()"))) ;
    CAutoLock  Lock(&m_csL21DGDI) ;

    //
    // There is a window of opportunity while doing Stop(), that the internal DIB section
    // has been deleted, but CTransformFilter::Stop() hasn't yet been called. So the
    // filter may keep on trying to do its job, like clearing the internal buffer, and
    // fault!!!
    //
    if (!m_bDCInited) {     // DIB secn not yet created/already deleted
        DbgLog((LOG_TRACE, 5, TEXT("Internal DIBsection has been deleted; skipped erasing it."))) ;
        return ;            // just quietly leave....
    }
    MSR_START(m_idClearIntBuff) ;  // start clearing internal buffer
    
    // We add m_uCharHeight because of the extra 1 line of space that we 
    // acquire to scroll
    ULONG   ulTotal = m_uIntBmpWidth * m_uBytesPerPixel * (m_uIntBmpHeight + m_uCharHeight) ;
    ULONG   ulFillerMax = ulTotal - (ulTotal % 12) ;
    ULONG   ul ;
    for (ul = 0 ; ul < ulFillerMax ; ul += 12)
        CopyMemory(m_lpbIntBuffer + ul, m_abColorFiller, 12) ;
    for (ul = 0 ; ul < ulTotal % 12 ; ul++)
        m_lpbIntBuffer[ulFillerMax + ul] = m_abColorFiller[ul] ;
    
    MSR_STOP(m_idClearIntBuff) ;   // done clearing internal buffer
    m_bBitmapDirty = TRUE ;  // bitmap has changed (needs to be redrawn to reflect that)
    m_bOutDIBClear = TRUE ;  // bitmap is spotless now!!!
}


void CGDIWork::ChangeFont(BOOL bItalics, BOOL bUnderline)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::ChangeFont(%u, %u)"), bItalics, bUnderline)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    if (NULL == m_hDCInt)
    {
        DbgLog((LOG_ERROR, 2, TEXT("WARNING: ChangeFont() called w/o valid output DC"))) ;
        return ;
    }
    
    // If current font is non-default, un-select & release it
    if (m_bUseSplFont)
    {
        SelectObject(m_hDCInt, m_hFontDef) ;
        DeleteObject(m_hFontSpl) ;
        m_hFontSpl = NULL ;
        m_bUseSplFont = FALSE ;
    }
    
    m_lfChar.lfItalic    = (BYTE)bItalics ;
    m_lfChar.lfUnderline = (BYTE)bUnderline ;
    
    // If special font is reqd, create font & select it
    if (bItalics || bUnderline)
    {
        m_hFontSpl = CreateFontIndirect(&m_lfChar) ;
        SelectFont(m_hDCInt, m_hFontSpl) ;
        m_bUseSplFont = TRUE ;
    }
    // Otherwise m_hFontDef is already selected in m_hDCCurr.
    // So don't do anything more.
}


BOOL CGDIWork::CharSizeFromOutputSize(LONG lOutWidth, LONG lOutHeight, 
                                      int *piCharWidth, int *piCharHeight)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::CharSizeFromOutputSize(%ld, %ld, 0x%lx, 0x%lx)"), 
            lOutWidth, lOutHeight, piCharWidth, piCharHeight)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;

    // We only care about the absolute value here
    lOutWidth  = ABS(lOutWidth) ;
    lOutHeight = ABS(lOutHeight) ;

    if ( IsTTFont() )  // TT font
    {
        if (! ISDWORDALIGNED(lOutWidth) )  // must have DWORD-aligned width
            return FALSE ;

        *piCharWidth   = (int)(lOutWidth * (100 - m_iBorderPercent) / 100) ;  // 80-90% of width
        *piCharWidth  += MAX_CAPTION_COLUMNS / 2 + 1 ;  // max_col / 2 for rounding
        *piCharWidth  /= (MAX_CAPTION_COLUMNS + 2) ;    // space per column
        *piCharHeight  = (int)(lOutHeight * (100 - m_iBorderPercent) / 100) ; // 80-90% of width
        *piCharHeight += (MAX_CAPTION_ROWS / 2) ;       // max_row / 2 for rounding
        *piCharHeight /= MAX_CAPTION_ROWS ;             // space per row
        return TRUE ;  // acceptable
    }
    else  // non-TT font (Terminal) -- only 320x240 or 640x480
    {
        if (640 == lOutWidth  &&  480 == lOutHeight)
        {
            *piCharWidth  = 16 ;
            *piCharHeight = 24 ;
            return TRUE ;  // acceptable
        }
        else if (320 == lOutWidth  &&  240 == lOutHeight)
        {
            *piCharWidth  = 8 ;
            *piCharHeight = 12 ;
            return TRUE ;  // acceptable
        }
        else
            return FALSE ;  // can't handle size for non-TT font
    }
}


void CGDIWork::ChangeFontSize(UINT uCharWidth, UINT uCharHeight)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::ChangeFontSize(%u, %u)"), uCharWidth, uCharHeight)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    if (NULL == m_hDCInt)
    {
        DbgLog((LOG_ERROR, 2, TEXT("WARNING: ChangeFontSize() called w/o valid output DC"))) ;
        return ;
    }
    
    if ((UINT) ABS(m_lfChar.lfWidth)  == uCharWidth  &&   // same width
        (UINT) ABS(m_lfChar.lfHeight) == uCharHeight)     // same height
        return ;                              // don't change anything
    
    // If current font is non-default, un-select & release it
    if (m_bUseSplFont)
    {
        SelectObject(m_hDCInt, m_hFontOrig) ;
        DeleteObject(m_hFontSpl) ;
        m_hFontSpl = NULL ;
        m_bUseSplFont = FALSE ;
    }
    else
    {
        // delete the default font
        SelectObject(m_hDCInt, m_hFontOrig) ;
        DeleteObject(m_hFontDef) ;
        m_hFontDef = NULL ;
    }
    
    // Change font size in the LOGFONT structure for future fonts
    // Always use -ve height so that we are bound to get that height chars
    if (m_bUseTTFont)
    {
        m_lfChar.lfWidth = uCharWidth ;  // can we ignore this??
        if ((m_lfChar.lfWidth = uCharWidth) > 0)    // if +ve Width,
            m_lfChar.lfWidth = -m_lfChar.lfWidth ;  // change sign to make it -ve
        m_lfChar.lfHeight = uCharHeight ;
        if ((m_lfChar.lfHeight = uCharHeight) > 0)    // if +ve height,
            m_lfChar.lfHeight = -m_lfChar.lfHeight ;  // change sign to make it -ve
        lstrcpy(m_lfChar.lfFaceName, TEXT("Lucida Console")) ;
    }
    else  // no Lucida Console; use 8x12 Terminal font
    {
        m_lfChar.lfHeight = uCharHeight ;
        m_lfChar.lfWidth  = uCharWidth ;
        m_lfChar.lfCharSet = OEM_CHARSET ;
        m_lfChar.lfPitchAndFamily = FIXED_PITCH | FF_MODERN ;
        lstrcpy(m_lfChar.lfFaceName, TEXT("Terminal")) ;
    }
    
    // Create font & select only default font in the DC
    m_hFontDef = CreateFontIndirect(&m_lfChar) ;
    SelectFont(m_hDCInt, m_hFontDef) ;
    
    // Now update the char size, output bitmap size, bytes/pixel etc. too
    m_bFontSizeOK = SetCharNBmpSize() ;
}


BOOL CGDIWork::SetOutputSize(LONG lWidth, LONG lHeight)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::SetOutputSize(%ld, %ld)"), lWidth, lHeight)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    // If a output format is specified by downstream filter, use it; else use upstream's
    LPBITMAPINFOHEADER lpbmih = (m_lpBMIOut ? LPBMIHEADER(m_lpBMIOut) : LPBMIHEADER(m_lpBMIIn)) ;
    
    // Now we want to use the ABS()-ed values for calculating the char sizes
    lWidth = ABS(lWidth) ;
    lHeight = ABS(lHeight) ;
    
    if (lpbmih)
    {
        // Check if current output bitmap size is the same or not.
        // This also includes height changing from +ve to -ve and vice-versa
        if (lWidth  == m_lWidth  &&  
            lHeight == m_lHeight)
            return FALSE ;    // same size; nothing changed
        
        // Store the width and height now so that we can compare any size 
        // change and/or -ve/+ve height thing later.
        m_lWidth  = lWidth ;
        m_lHeight = lHeight ;
    }
    
    // Create new DIB section with new sizes (leaving borders)
    int   iCharWidth ;
    int   iCharHeight ;
    if (! CharSizeFromOutputSize(lWidth, lHeight, &iCharWidth, &iCharHeight) )
    {
        DbgLog((LOG_ERROR, 0, TEXT("ERROR: CharSizeFromOutputSize() failed for %ld x %ld output"),
                lWidth, lHeight)) ;
        return FALSE ;  // failure
    }
    ChangeFontSize(iCharWidth, iCharHeight) ;
    
    return TRUE ;
}


void CGDIWork::ChangeColor(int iColor)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::ChangeColor(%d)"), iColor)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    SetTextColor(m_hDCInt, m_acrFGColors[iColor]) ;
    m_uColorIndex = iColor ;
}


BOOL CGDIWork::CreateOutputDC(void)
{
    DbgLog((LOG_TRACE, 3, TEXT("CGDIWork::CreateOutputDC()"))) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    // Shouldn't we do a DeleteOutputDC() here??
#pragma message("We should delete the old DIBSection before creating the new")
    // DeleteOutputDC() ; -- to use DeleteOutputDC() move the Lock defn down; else deadlock!!!
    
    // If a output format is specified by downstream filter, use it; else use upstream's
    LPBITMAPINFO lpbmih = (m_lpBMIOut ? m_lpBMIOut : m_lpBMIIn) ;
    ASSERT(lpbmih->bmiHeader.biSize) ;  // just checking!!!
    
    // Save the width and height values before changing it to the internal DIB size
    // to be created.
    LONG    lWidth = lpbmih->bmiHeader.biWidth ;
    LONG    lHeight = lpbmih->bmiHeader.biHeight ;
    
    //
    //  Hack:  This is a kind of hack that I am changing the out BMI for creating
    //         the DIBSection and changing it back.  But I think it's better than
    //         creating a new lpBMI and copying over the whole lpBMIOut data etc.
    //
    lpbmih->bmiHeader.biWidth  = m_uIntBmpWidth ;
    // Add a char height for extra line to scroll
    // -ve height for top-down DIB
    lpbmih->bmiHeader.biHeight = (DWORD)(-((int)(m_uIntBmpHeight + m_uCharHeight))) ;
    lpbmih->bmiHeader.biSizeImage = DIBSIZE(lpbmih->bmiHeader) ;
    
    m_hBmpInt = CreateDIBSection(m_hDCInt, lpbmih, DIB_RGB_COLORS, 
        (LPVOID *)&m_lpbIntBuffer, NULL, 0) ;
    if (NULL == m_hBmpInt)
    {
        DbgLog((LOG_ERROR, 0, TEXT("Failed to create DIB section for output bitmap (Error %ld)"), GetLastError())) ;
        
        // Restore the width and height values, otherwise later we won't know what hit us!!!
        lpbmih->bmiHeader.biWidth  = lWidth ;
        lpbmih->bmiHeader.biHeight = lHeight ;
        lpbmih->bmiHeader.biSizeImage = DIBSIZE(lpbmih->bmiHeader) ;
        
        return FALSE ;
    }
    
    ClearInternalBuffer() ;  // get rid of any random stuff remaining there
    m_hBmpIntOrig = (HBITMAP) SelectObject(m_hDCInt, m_hBmpInt) ;  // select DIBSection in our internal DC
    
    // Set back the saved width and height values, and size image too
    lpbmih->bmiHeader.biWidth  = lWidth ;
    lpbmih->bmiHeader.biHeight = lHeight ;
    lpbmih->bmiHeader.biSizeImage = DIBSIZE(lpbmih->bmiHeader) ;
    
    m_bDCInited = TRUE ;      // now it's all set
    m_bNewIntBuffer = TRUE ;  // new DIB section created
    
    // If given height is -ve then we set "output inverted" flag
    m_bOutputInverted = (lpbmih->bmiHeader.biHeight < 0) ;
    
    return TRUE ;
}


BOOL CGDIWork::DeleteOutputDC(void)
{
    DbgLog((LOG_TRACE, 3, TEXT("CGDIWork::DeleteOutputDC()"))) ;
    CAutoLock  Lock(&m_csL21DGDI) ;

    if (! m_bDCInited)
        return TRUE ;
    
    // Release the DIBSection etc.
    if (m_hBmpInt)
    {
        SelectObject(m_hDCInt, m_hBmpIntOrig) ;   // first take out of our DC
        DeleteObject(m_hBmpInt) ;                 // then delete teh DIBSection
        m_hBmpInt = NULL ;                        // we don't have the bitmap anymore
        m_hBmpIntOrig = NULL ;                    // orig bitmap is now selected
    }
    
    m_lpbIntBuffer = NULL ;
    m_bDCInited = FALSE ;
    
    return TRUE ;   // success!!
}


void CGDIWork::DrawLeadingSpace(int iLine, int iCol)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::DrawLeadingSpace(%d, %d)"), iLine, iCol)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;
    
    if (! m_bOpaque )  // doesn't matter for transparent background
        return ;
    
    // opaque the leading space's position and also the next char's
    RECT    Rect ;
    Rect.left = iCol * m_uCharWidth ;
    Rect.top = iLine * m_uCharHeight ;
    Rect.right = Rect.left + 2 * m_uCharWidth ;
    Rect.bottom = Rect.top + m_uCharHeight ;
    UINT16   chSpace = MAKECCCHAR(0, ' ') ;
    
    ChangeFont(FALSE, FALSE) ; // no UL or italics
    if (! ExtTextOutW(m_hDCInt, iCol * m_uCharWidth, iLine * m_uCharHeight,
                ETO_OPAQUE, &Rect, &chSpace, 1, NULL /* lpDX */) )
        DbgLog((LOG_ERROR, 1, TEXT("ERROR: ExtTextOutW() failed drawing leading space!!!"))) ;

    m_bOutDIBClear = FALSE ;    // we have put the leading space at least

    // Now get back to prev font (underline and italics)
    ChangeFont(m_ccLast.IsItalicized(), m_ccLast.IsUnderLined()) ;
}

void CGDIWork::WriteChar(int iLine, int iCol, CCaptionChar& cc)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::WriteChar(%d, %d, %u)"), iLine, iCol, cc.GetChar())) ;
    CAutoLock  Lock(&m_csL21DGDI) ;

    UINT16  wActual ;
    UINT16  wBGSpace = MAKECCCHAR(0, ' ') ;
    RECT    Rect ;
    UINT    uColor = cc.GetColor() ;
    UINT    uEffect = cc.GetEffect() ;
    
    // Make sure the internal DIB section is still valid
    if (! m_bDCInited )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Internal output DIB section is not valid anymore"))) ;
        return ;
    }
    
    // Make sure we have good size font first
    if (! m_bFontSizeOK )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Font size is not right for current output window"))) ;
        return ;
    }
    
    if (cc.IsMidRowCode())  // if it's a mid row code
        wActual = MAKECCCHAR(0, ' ') ;   // use space
    else                    // otherwise
        wActual = cc.GetChar() ; // use the char itself
    if (0 == wActual)   // this one is supposed to be skipped -- I am not sure
    {
        DbgLog((LOG_TRACE, 1, TEXT("Should we skip NULL char at (%d, %d)??"), iLine, iCol)) ;
        // return ;
    }
    
    if (uColor != m_ccLast.GetColor())
        ChangeColor(uColor) ;
    if (uEffect != m_ccLast.GetEffect())
        ChangeFont(cc.IsItalicized(), cc.IsUnderLined()) ;
    if (m_bOpaque)  // opaque the next char's position
    {
        Rect.left = (iCol+1) * m_uCharWidth ;
        Rect.top = iLine * m_uCharHeight ;
        Rect.right = Rect.left + m_uCharWidth ;
        Rect.bottom = Rect.top + m_uCharHeight ;
    }
    if (! ExtTextOutW(m_hDCInt, iCol * m_uCharWidth, iLine * m_uCharHeight,
                    m_bOpaque ? ETO_OPAQUE : 0, 
                    m_bOpaque ? &Rect : NULL,
                    &wActual, 1, NULL /* lpDX */) )
        DbgLog((LOG_ERROR, 1, TEXT("ERROR: ExtTextOutW() failed drawing caption char!!!"))) ;

    if (0 != wActual)  // if this char is non-null
        m_bOutDIBClear = FALSE ;    // we have put one char at least

#ifdef TEST
    BitBlt(m_hDCTest, 0, 0, 600, 120, m_hDCInt, 0, 0, SRCCOPY) ; // 300 x 65
#endif // TEST
    
    m_ccLast = cc ;
    
    m_bBitmapDirty = TRUE ;
}


void CGDIWork::CopyLine(int iSrcLine, int iSrcOffset,
                        int iDestLine, int iDestOffset, UINT uNumScanLines)
                        // uNumScanLines param has a default value of 0xff.
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::CopyLine(%d, %d, %d, %d, %u)"),
            iSrcLine, iSrcOffset, iDestLine, iDestOffset, uNumScanLines)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;

    LPBYTE  lpSrc ;
    LPBYTE  lpDest ;
    int     iDestInc ;
    
    // Make sure the internal DIB section is still valid
    if (! m_bDCInited )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Internal output DIB section is not valid anymore"))) ;
        return ;
    }
    
    // Make sure we have good size font
    if (! m_bFontSizeOK )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Font size is not right for current output window"))) ;
        return ;
    }
    
    ASSERT(m_lpbOutBuffer) ;  // so that we catch it in debug builds
    if (NULL == m_lpbOutBuffer)
    {
        DbgLog((LOG_ERROR, 0, TEXT("How could we be drawing lines when output buffer is NOT given?"))) ;
        return ;
    }
    
    int  iLineStart ;
    lpSrc = m_lpbIntBuffer +
            (iSrcLine * m_uCharHeight * m_uBytesPerSrcScanLine +
            (iSrcLine == 0 ? // skip scroll lines only for 1st line
            iSrcOffset * m_uBytesPerSrcScanLine : 0)) ;
    if (IsOutputInverted())   // OverlayMixer case
    {
        iLineStart = ((iDestLine - 1) * m_uCharHeight + m_uVertOffset) ;
        lpDest = m_lpbOutBuffer +                        // buffer start
                 (iLineStart + iDestOffset) * m_uBytesPerDestScanLine +  // # scanlines
                 m_uHorzOffset * m_uBytesPerPixel ;      // leading pixels on the scanline 
        iDestInc = m_uBytesPerDestScanLine ;
    }
    else                     // Video Renderer case
    {
        iLineStart = (MAX_CAPTION_ROWS - iDestLine + 1) * m_uCharHeight - iDestOffset + m_uVertOffset ;
        lpDest = m_lpbOutBuffer +                        // buffer start
                 iLineStart * m_uBytesPerDestScanLine +  // # scanlines * pixels/scanline
                 m_uHorzOffset * m_uBytesPerPixel ;      // leading pixels on the scanline
        iDestInc = -((int) m_uBytesPerDestScanLine) ;
    }
    
    // We don't want to copy more than a text line's height of
    // scan lines.  But we can copy less if we are asked to.
    UINT uMax = min(uNumScanLines, m_uCharHeight) ;
    for (UINT u = iSrcOffset ; u < uMax ; u++)
    {
        // Before we copy the bits, lets just make sure the buffer isn't bad
        if (IsBadWritePtr(lpDest, m_uBytesPerSrcScanLine))
        {
            DbgLog((LOG_ERROR, 1, TEXT("Bad output buffer. Skip copying the text line."))) ;
            ASSERT(!"Bad output buffer") ;
            break ;
        }
    
        CopyMemory(lpDest, lpSrc, m_uBytesPerSrcScanLine) ;
        lpSrc  += m_uBytesPerSrcScanLine ;
        lpDest += iDestInc ;
    }
}


void CGDIWork::GetOutputLines(int iDestLine, RECT *prectLine)
{
    DbgLog((LOG_TRACE, 5, TEXT("CGDIWork::GetOutputLines(%d, 0x%lx)"), iDestLine, prectLine)) ;
    CAutoLock  Lock(&m_csL21DGDI) ;

    if (IsBadWritePtr(prectLine, sizeof(*prectLine)))
    {
        DbgLog((LOG_ERROR, 0, TEXT("ERROR: prectOut is a bad pointer!!!"))) ;
        return ;
    }

    SetRect(prectLine, 0 /*m_uHorzOffset */, 0,   // to stop BPC's CC wobbling
        m_uHorzOffset + m_uCharWidth * (MAX_CAPTION_COLUMNS+2), 0) ;
    int  iLineStart ;
    if (IsOutputInverted())   // OverlayMixer case
    {
        iLineStart = ((iDestLine - 1) * m_uCharHeight + m_uVertOffset) ;
        prectLine->top    = iLineStart ;
        prectLine->bottom = iLineStart + m_uCharHeight ;
    }
    else                     // Video Renderer case
    {
        // I am not sure about the rect top/bottom thing here.
        prectLine->top    = (iDestLine - 1) * m_uCharHeight + m_uVertOffset ;
        prectLine->bottom = prectLine->top + m_uCharHeight ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\lin21dec\test\tsrcl21.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#include <streams.h>
#include <olectl.h>
#include <initguid.h>
#include <olectl.h>
#include "TSrcL21.h"


// Setup data

const AMOVIESETUP_MEDIATYPE sudOpPinTypes =
{
	&MEDIATYPE_AUXLine21Data,       // Major type
	&MEDIASUBTYPE_NULL              // Minor type
} ;

const AMOVIESETUP_PIN sudOpPin =
{
	L"Output",              // Pin string name
	FALSE,                  // Is it rendered
	TRUE,                   // Is it an output
	FALSE,                  // Can we have none
	FALSE,                  // Can we have many
	&CLSID_NULL,            // Connects to filter
	NULL,                   // Connects to pin
	1,                      // Number of types
	&sudOpPinTypes          // Pin details
} ;

const AMOVIESETUP_FILTER sudTSrcL21 =
{
	&CLSID_Line21TestSource,// Filter CLSID
	L"Line21 Source",       // String name
	MERIT_NORMAL    ,       // Filter merit
	1,                      // Number pins
	&sudOpPin               // Pin details
};


// COM global table of objects in this dll

CFactoryTemplate g_Templates[] = {
  { L"Line21 Source"
  , &CLSID_Line21TestSource
  , CLine21Source::CreateInstance
  , NULL
  , &sudTSrcL21 }
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);


//
// DllRegisterServer
//
// Exported entry points for registration and unregistration
//
STDAPI DllRegisterServer()
{
	return AMovieDllRegisterServer2(TRUE) ;
} // DllRegisterServer


//
// DllUnregisterServer
//
STDAPI DllUnregisterServer()
{
	return AMovieDllRegisterServer2(FALSE) ;
} // DllUnregisterServer


//
// CreateInstance
//
// Only way to create Line 21 Source filter
//
CUnknown * WINAPI CLine21Source::CreateInstance(LPUNKNOWN lpunk, HRESULT *phr)
{
	CUnknown *punk = new CLine21Source(lpunk, phr);
	if (punk == NULL) {
		*phr = E_OUTOFMEMORY;
	}
	return punk;
} // CreateInstance


//
// Constructor
//
// Initialise a CLine21Source object so that we have a pin.
//
CLine21Source::CLine21Source(LPUNKNOWN lpunk, HRESULT *phr) :
		CSource(NAME("Line21 Source"),
				lpunk,
				CLSID_Line21TestSource)
{
	CAutoLock cAutoLock(&m_cStateLock) ;

	m_paStreams    = (CSourceStream **) new CLine21DataStream*[1] ;
	if (m_paStreams == NULL) {
		*phr = E_OUTOFMEMORY ;
		return ;
	}

	m_paStreams[0] = new CLine21DataStream(phr, this, L"Line21 Source") ;
	if (m_paStreams[0] == NULL) {
		*phr = E_OUTOFMEMORY ;
		return ;
	}
} // (Constructor)


//
// Constructor
//
CLine21DataStream::CLine21DataStream(HRESULT *phr,
									 CLine21Source *pParent,
									 LPCWSTR pPinName) :
		CSourceStream(NAME("Line21 Source"), phr, pParent, pPinName),
		m_hFile(INVALID_HANDLE_VALUE), // no file now
		m_bInitValid(FALSE),    // not inited yet
		m_bGotEOF(FALSE),       // not EOF yet
		m_lpbNext(NULL),        // no caption data buffer yet
		m_iSubType(0),          // inited to an invalid value
		m_iBytesLeft(0),        // should be set in ReadHeaderData()
		m_iWidth(320),          // we assume 320 for now
		m_iHeight(240),         // ..  ...   240 ... ...
		m_iBitCount(0),         // at least for now
		m_bFirstSample(TRUE),   // before starting to run
		m_rtSampleTime(0L),     // at starting, sample  time is 0
		m_rtRepeatTime(33L),    // that means ~30 frames / sec.
		m_lpbCaptionData(NULL), // ptr to caption data to be passed downstream
		m_iDataSize(0),         // size of each data packet for current subtype
		m_bDiscont(FALSE)       // by default no discontinuity sample sent down
{
	CAutoLock cAutoLock(&m_csSharedState);

	ZeroMemory(m_achSourceFile, sizeof(m_achSourceFile)) ;

	// Get the input file name and open it here
	if (! (m_bInitValid = OpenInputFile()) )
	{
		MessageBox(NULL, 
				   "Input file not specified or bad header data.\n"
				   "Can't really do anything.", 
				   "Warning", MB_OK | MB_ICONWARNING) ;
				   m_bInitValid = FALSE ;
		return ;
	}

	// Find out what is the current display bitdepth; use that in format
	HDC     hDC = GetDC(NULL) ;
	m_iBitCount = GetDeviceCaps(hDC, BITSPIXEL) ;
	ReleaseDC(NULL, hDC) ;

	// Allocate caption data buffer to hold the data to be passed downstream
	m_lpbCaptionData = new BYTE[m_iDataSize] ;
	if (NULL == m_lpbCaptionData)
	{
		DbgLog((LOG_ERROR, 1, TEXT("Not enough memory in L21 Source for caption data"))) ;
		m_bInitValid = FALSE ;
	}

	// Everything worked; Init successfull !!!
	m_bInitValid = TRUE ;
} // (Constructor)


//
// Destructor
//
CLine21DataStream::~CLine21DataStream()
{
	CAutoLock cAutoLock(&m_csSharedState);

	// Close the file if one was opened
	if (m_hFile)
		CloseHandle(m_hFile) ;

	if (m_lpbCaptionData)
		delete [] m_lpbCaptionData ;
} // (Destructor)


//
// FillBuffer
//
// Reads a pair of bytes' worth data and creates an output sample
//
HRESULT CLine21DataStream::FillBuffer(IMediaSample *pMS)
{
	BYTE *pData ;
	LONG  lDataLen ;

	if (! m_bInitValid )  // filterinit failed, somehow
		return E_FAIL ;   // can't do anything anyway.

	pMS->GetPointer(&pData) ;
	lDataLen = pMS->GetSize() ;

	CAutoLock cAutoLockShared(&m_csSharedState) ;

	// Get the next set of data from input text file and create
	// an output sample with them
	if (! GetNextData(pData, &lDataLen) )
		return S_FALSE ;

	FILTER_STATE State ;
	m_pFilter->GetState(0, &State) ;

	if (State_Paused == State  ||  State_Stopped == State)
		m_rtSampleTime = 0 ;
	else if (m_bFirstSample  &&  State_Running == State)
	{
		m_pFilter->StreamTime(m_rtSampleTime) ;
		m_bFirstSample = FALSE ;
	}
	else
		;  // nothing I guess!!!

	pMS->SetSyncPoint(TRUE) ;

	// The current time is the sample's start
	CRefTime rtStart = m_rtSampleTime ;

	// Calculate the sample end time based on subtype
	switch (m_iSubType)
	{
		case AM_SRCL21_SUBTYPE_BYTEPAIR:
			m_rtSampleTime += m_rtRepeatTime ;
			break ;

		case AM_SRCL21_SUBTYPE_GOPPACKET:
		{
			// GOPPacket sample's time is #fields X each field's time
			for (UINT8 u = 0 ; 
				 u < (((PAM_L21_GOPUD_PACKET)pData)->Header.bTopField_Rsrvd_NumElems & 0x3F) ; 
				 u++) 
				m_rtSampleTime += m_rtRepeatTime ; 
			break ;
		}

		case AM_SRCL21_SUBTYPE_VBIRAWDATA:  // we should not be here at all!!!
			m_rtSampleTime += m_rtRepeatTime ;
			break ;

		default:
			DbgLog((LOG_ERROR, 1, TEXT("No valid subtype has been defined. Check \"SubType\" value in the input .l21 file."))) ;
			return E_FAIL ;   // can't do anything anyway.
	}

	pMS->SetTime((REFERENCE_TIME *) &rtStart,(REFERENCE_TIME *) &m_rtSampleTime) ;

	pMS->SetMediaType(&m_mt) ;
	pMS->SetActualDataLength(lDataLen) ;  // set the actual data length now

	if (m_bDiscont)
	{
	    DbgLog((LOG_TRACE, 0, TEXT("Sending down a discontinuity sample"))) ;
	    pMS->SetDiscontinuity(TRUE) ;
	    m_bDiscont = FALSE ;
	}

	return NOERROR ;
} // FillBuffer


//
// Notify  ---  IGNORED for the time being
//
// Alter the repeat rate according to quality management messages sent from
// the downstream filter (often the renderer).  Wind it up or down according
// to the flooding level - also skip forward if we are notified of Late-ness
//
STDMETHODIMP CLine21DataStream::Notify(IBaseFilter * pSender, Quality q)
{

#if 0
	// Adjust the repeat rate.
	if (q.Proportion<=0) {
		m_rtRepeatTime = 1000;        // We don't go slower than 1 per second
	} 
	else {
		m_rtRepeatTime = m_rtRepeatTime*1000/q.Proportion;
		if (m_rtRepeatTime>1000) {
			m_rtRepeatTime = 1000;    // We don't go slower than 1 per second
		} 
		else if (m_rtRepeatTime<10) {
			m_rtRepeatTime = 10;      // We don't go faster than 100/sec
		}
	}

	// skip forwards
	if (q.Late > 0) {
		m_rtSampleTime += q.Late;
	}
#endif // # if 0

	return NOERROR;
} // Notify


//
// GetMediaType
//
// Supports any RGB(only?) subtype of Video (RGB8, RGB555, RGB565,RGB24, RGB32),
// but _prefers_ only 1 format -- image size of 320x240. However it can accept
// any reasonable image size.
//
HRESULT CLine21DataStream::GetMediaType(int iPosition, CMediaType *pmt)
{
	CAutoLock cAutoLock(m_pFilter->pStateLock()) ;

	if (! m_bInitValid )  // filterinit failed, somehow
		return E_FAIL ;   // can't do anything anyway.

	if (iPosition < 0)
		return E_INVALIDARG ;

	// Have we run off the end of types?
	if (iPosition > 4)
		return VFW_S_NO_MORE_ITEMS ;

#if 1  // for testing only
	pmt->ResetFormatBuffer() ;
#else
	VIDEOINFO *pvi ;
	pvi = (VIDEOINFO *) pmt->Format() ;
	if (NULL == pvi)  // no format block allocated yet
	{
		pvi = (VIDEOINFO *) pmt->AllocFormatBuffer(sizeof(VIDEOINFO)) ;
		if (NULL == pvi)
			return(E_OUTOFMEMORY) ;

		ZeroMemory(pvi, sizeof(VIDEOINFO));
		pvi->rcSource.left   = pvi->rcTarget.left    = 0 ;
		pvi->rcSource.top    = pvi->rcTarget.top     = 0 ;
		pvi->rcSource.right  = pvi->rcTarget.right   = 320 ;
		pvi->rcSource.bottom = pvi->rcTarget.bottom  = 240 ;
		pvi->dwBitRate = 16 ;
		pvi->dwBitErrorRate = 0 ;
		pvi->AvgTimePerFrame = m_rtRepeatTime ;
		pvi->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
		pvi->bmiHeader.biWidth         = m_iWidth;
		pvi->bmiHeader.biHeight        = m_iHeight;
		pvi->bmiHeader.biPlanes        = 1;
		pvi->bmiHeader.biClrImportant  = 0;
		pvi->bmiHeader.biXPelsPerMeter = pvi->bmiHeader.biYPelsPerMeter = 0 ;
		pvi->bmiHeader.biClrImportant  = 0 ;
	}

	// Major type is .._AUXLine21Data.
	// Subtype is any of .._BytePair, .._GOPPacket, .._VBIRawData.
	// Format is any of 8, 16 (555), 16 (565), 24, 32bpp for 320x240 size.
	int     i ;
	switch (iPosition) 
	{
		case 0: // Return our 24bit format
			pvi->bmiHeader.biCompression = BI_RGB ;
			pvi->bmiHeader.biBitCount    = 24 ;
			break;

		case 1: // Return our highest quality 32bit format
			// Place the RGB masks as the first 3 doublewords in the palette area
			for (i = 0; i < 3; i++)
				pvi->TrueColorInfo.dwBitMasks[i] = bits888[i] ;

			pvi->bmiHeader.biCompression = BI_BITFIELDS ;
			pvi->bmiHeader.biBitCount    = 32 ;
			break;

		case 2: // Return our 16bit format (BI_RGB)
			pvi->bmiHeader.biCompression = BI_RGB ;
			pvi->bmiHeader.biBitCount    = 16 ;
			break;

		case 3: // Return our 16bit format (BI_BITFIELDS: 565)
			pvi->bmiHeader.biCompression = BI_BITFIELDS ;
			pvi->bmiHeader.biBitCount    = 16 ;

			// Place the RGB masks as the first 3 doublewords in the palette area
			for (i = 0; i < 3; i++)
				pvi->dwBitMasks[i] = bits565[i] ;

			break;

		case 4: // Return our 8bit format
			pvi->bmiHeader.biCompression = BI_RGB ;
			pvi->bmiHeader.biBitCount    = 8 ;
			break;

		default:
			return VFW_S_NO_MORE_ITEMS ;
	}
	// Now we can calculate the image size
	pvi->bmiHeader.biSizeImage = GetBitmapSize(&pvi->bmiHeader);

	SetRectEmpty(&(pvi->rcSource));     // doesn't matter
	SetRectEmpty(&(pvi->rcTarget));     // doesn't matter
#endif // #if 0

	// (Adjust the parameters common to all formats...)
	pmt->SetType(&MEDIATYPE_AUXLine21Data) ;
	// pmt->SetFormatType(&FORMAT_VideoInfo) ;
	pmt->SetFormatType(&GUID_NULL) ;
	pmt->SetTemporalCompression(FALSE);

	// Work out the GUID for the subtype from the header info.
	switch (m_iSubType)
	{
		case AM_SRCL21_SUBTYPE_BYTEPAIR:
			pmt->SetSubtype(&MEDIASUBTYPE_Line21_BytePair) ;
			pmt->SetSampleSize(2) ;
			break ;

		case AM_SRCL21_SUBTYPE_GOPPACKET:
			pmt->SetSubtype(&MEDIASUBTYPE_Line21_GOPPacket) ;
			pmt->SetSampleSize(sizeof(AM_L21_GOPUD_PACKET)) ;
			break ;

		case AM_SRCL21_SUBTYPE_VBIRAWDATA:  // we should not be here at all!!!
			pmt->SetSubtype(&MEDIASUBTYPE_Line21_VBIRawData) ;
			pmt->SetSampleSize(0) ;
			break ;

		default:
			return E_FAIL ;
	}

	return NOERROR;
} // GetMediaType


//
// CheckMediaType
//
// We will accept only 320x240 size formats, in any image size will work.
// Returns E_INVALIDARG if the mediatype is not acceptable
//
HRESULT CLine21DataStream::CheckMediaType(const CMediaType *pMediaType)
{
	CAutoLock cAutoLock(m_pFilter->pStateLock());

	if (! m_bInitValid )  // filterinit failed, somehow
		return E_FAIL ;   // can't do anything anyway.

	if ((*(pMediaType->Type()) != MEDIATYPE_AUXLine21Data) || // we only output Line21 data...
		 !(pMediaType->IsFixedSize()) ) {    // in fixed size samples
		return E_INVALIDARG;
	}

	// Check for the subtypes we support
	const GUID *SubType = pMediaType->Subtype();
	switch (m_iSubType)
	{
		case AM_SRCL21_SUBTYPE_BYTEPAIR:
			if (*SubType != MEDIASUBTYPE_Line21_BytePair)
				return E_INVALIDARG;
			break ;

		case AM_SRCL21_SUBTYPE_GOPPACKET:
			if (*SubType != MEDIASUBTYPE_Line21_GOPPacket)
				return E_INVALIDARG;
			break ;

		case AM_SRCL21_SUBTYPE_VBIRAWDATA:  // for now, we should not be here at all!!!
			if (*SubType != MEDIASUBTYPE_Line21_VBIRawData)
				return E_INVALIDARG;
			break ;

		default:
			return E_FAIL ;
	}

#if 0  // for testing...
	// Get the format area of the media type
	VIDEOINFO *pvi = (VIDEOINFO *) pMediaType->Format();

	if (pvi == NULL)
		return E_INVALIDARG;
#endif // #if 0

	return S_OK;  // This format is acceptable.
} // CheckMediaType


//
// DecideBufferSize
//
// This will always be called after the format has been sucessfully
// negotiated. So we have a look at m_mt to see what size image we agreed.
// Then we can ask for buffers of the correct size to contain them.
//
HRESULT CLine21DataStream::DecideBufferSize(IMemAllocator *pAlloc,ALLOCATOR_PROPERTIES *pProperties)
{
	CAutoLock cAutoLock(m_pFilter->pStateLock());

	if (! m_bInitValid )  // filter init failed, somehow
		return E_FAIL ;   // can't do anything anyway.

	ASSERT(pAlloc) ;
	ASSERT(pProperties) ;
	HRESULT hr = NOERROR ;

	// VIDEOINFO *pvi = (VIDEOINFO *) m_mt.Format() ; -- why did I have it???
	pProperties->cBuffers = 1 ;
	// pProperties->cbBuffer = m_pOutput->CurrentMediaType().GetSampleSize() ;

	pProperties->cbBuffer = m_iDataSize ;
	ASSERT(pProperties->cbBuffer) ;

	// Ask the allocator to reserve us some sample memory, NOTE the function
	// can succeed (that is return NOERROR) but still not have allocated the
	// memory that we requested, so we must check we got whatever we wanted

	ALLOCATOR_PROPERTIES Actual ;
	hr = pAlloc->SetProperties(pProperties,&Actual);
	if (FAILED(hr)) {
		return hr ;
	}

	// Is this allocator unsuitable
	if (Actual.cbBuffer < pProperties->cbBuffer) {
		return E_FAIL;
	}

	ASSERT( Actual.cBuffers == 1 );
	return NOERROR ;
} // DecideBufferSize


//
// SetMediaType
//
// Called when a media type is agreed between filters
//
HRESULT CLine21DataStream::SetMediaType(const CMediaType *pMediaType)
{
	CAutoLock cAutoLock(m_pFilter->pStateLock()) ;

	DbgLog((LOG_TRACE, 3, TEXT(" ::SetMediaType(output)"))) ;

	if (! m_bInitValid )  // filterinit failed, somehow
		return E_FAIL ;   // can't do anything anyway.

	// Pass the call up to my base class
	HRESULT hr = CSourceStream::SetMediaType(pMediaType);
	if (SUCCEEDED(hr)) 
	{
		VIDEOINFO * pvi = (VIDEOINFO *) m_mt.Format() ;
		if (NULL == pvi)
		{
			DbgLog((LOG_TRACE, 3, TEXT("No format type specified by source"))) ;
			return NOERROR ;
		}
		switch (pvi->bmiHeader.biBitCount) 
		{
			case 32:
			case 24:
			case 16:
			case 8:
				DbgLog((LOG_TRACE, 3, 
						TEXT("biBitCount=%ld, biCompression=0x%lx"),
						pvi->bmiHeader.biBitCount, pvi->bmiHeader.biCompression)) ;
				break;

			default:
				// We should never agree any other pixel sizes
				ASSERT("Tried to agree inappropriate format") ;
				break ;
		}

		// something to do here -- but what??
		return NOERROR ;
	} 
	else 
	{
		return hr ;
	}
} // SetMediaType


//
//  OpenInputFile
//
//  Gets the required input file name, opens it reads the header info, sets
//  subtype and format info etc.
//
BOOL CLine21DataStream::OpenInputFile(void)
{
	OPENFILENAME    ofn ;

	ZeroMemory (&ofn, sizeof ofn) ;
	ofn.lStructSize = sizeof(OPENFILENAME) ;
	ofn.hwndOwner = NULL ;
	ofn.lpstrFilter = TEXT("Line21 Data Files\0*.L21\0All Files\0*.*\0\0") ;
	ofn.nFilterIndex = 1 ;
	ofn.lpstrFile = m_achSourceFile ;
	ofn.nMaxFile = MAX_PATH ;
	ofn.lpstrTitle = TEXT("Select Input File") ;
	ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST ;

	// Get the user's selection
	if (! GetOpenFileName(&ofn) )
	{
		return FALSE ;
	}
	
	// Open the file for reading only
	m_hFile = CreateFile(m_achSourceFile, GENERIC_READ, 0, NULL, 
						 OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL) ;
	if (INVALID_HANDLE_VALUE == m_hFile)
	{
		MessageBox(NULL, TEXT("Couldn't open input file"), 
				   TEXT("Error"), MB_OK | MB_ICONWARNING) ;
		return FALSE ;
	}

	// Read header info and set media subtype, format details
	return ReadHeaderData() ;
}


//
//  ReadHeaderData
//
//  Opens the input file, reads the header info and sets media type details
//
BOOL CLine21DataStream::ReadHeaderData(void)
{
	DWORD       dw ;
	DWORD       dwCount = 0 ;
	BOOL        bDone = FALSE ;
	LPBYTE      pbBuff ;

	SetFilePointer(m_hFile, 0, NULL, FILE_BEGIN) ;  // from the start

	do
	{
		if (! ReadFile(m_hFile, m_achIntBuffer, MAXREADSIZE, &dw, NULL) )
		{
			MessageBox(NULL, TEXT("Couldn't read data from input file"), 
					   TEXT("Error"), MB_OK | MB_ICONWARNING) ;
			return FALSE ;
		}
		if (dw < MAXREADSIZE)
			m_bGotEOF = TRUE ;  // no point doing reads anymore
	
		// Make sure the buffer has trailing nulls as end indicator
		m_achIntBuffer[dw]   =       // Null terminate the input buffer.
		m_achIntBuffer[dw+1] =       // We use 3 chars just to ensure that
		m_achIntBuffer[dw+2] = 0 ;   // by mistake we don't skip over one.

		// Now go through the buffer to extract all the header lines
		pbBuff = (LPBYTE)m_achIntBuffer ;
		while (pbBuff < (LPBYTE)m_achIntBuffer+dw)
		{
			if ('#' == *pbBuff)  // a header line
			{
				pbBuff = ExtractHeaderLine(pbBuff+1) ;  // get it & move to next
				if (NULL == pbBuff)
				{
					DbgLog((LOG_ERROR, 1, "Input file has no non-header info.")) ;
					return FALSE ;
				}
			}
			else   // new line, but not a header => start of caption data
			{
				bDone = TRUE ;   // done extracting header info
				break ;   // get out of the for() loop
			}
		}
		dwCount = (pbBuff - (LPBYTE)m_achIntBuffer) ;  // why did I use += ??

	} while (! (m_bGotEOF || bDone) ) ;

	// No make sure to leave the file pointer at the start of the caption
	// data; otherwise we'll loose the starting byte pairs.
	// SetFilePointer(m_hFile, dwCount, NULL, FILE_BEGIN) ;

	// Out of whatever was read first, the actual caption data start here;
	// so adjust teh counts and the pointers
	m_iBytesLeft = dw - dwCount ;
	m_lpbNext = (LPBYTE)m_achIntBuffer + dwCount ;

	return TRUE ;
}


//
//  ToUpper: Helper function converting alphabetic char to upper case
//
BYTE ToUpper(BYTE ch)
{
	if (ch >= 'a' && ch <= 'z')
		return ch - ('a' - 'A') ;
	if (ch >= 'A' && ch <= 'Z')
		return ch ;
	return 0 ;   // a null char as error ??
}

//
//  CompText: Helper function comparing 2 text strings for a given 
//            number of chars with or w/o case sensitivity
//
int CompText(LPSTR pbText1, LPSTR pbText2, int iLen, BOOL bIgnoreCase)
{
	int iDiff ;

	if (IsBadReadPtr(pbText1, iLen))
	{
		DbgLog((LOG_ERROR, 1, TEXT("First string doesn't have %d valid bytes"), iLen)) ;
		DebugBreak() ;
		return 0 ;
	}

	for (int i = 0 ; i < iLen ; i++)
	{
		if (bIgnoreCase)
			iDiff = ToUpper(pbText1[i]) - ToUpper(pbText2[i]) ;
		else
			iDiff = pbText1[i] - pbText2[i] ;

		if (0 != iDiff)  // didn't match
			return iDiff ;
	}  // end of for (i)

	return 0 ;
}


//
//  SkipUptoCRLF:  Local helper function to skip the rest of a line
//                 upto CR-LF
//
LPBYTE SkipUptoCRLF(LPBYTE pbBuff)
{
	// Skip upto and including the CR-LF so that we are at the beginning  
	// of the next line
	CHAR    ch ;
	while (ch = *pbBuff++)  // have we hit end-of-buffer (NULL char)?
	{
		if (CHAR_CR == ch  &&  CHAR_LF == *pbBuff)   // got a CR-LF pair
			return (pbBuff + 1) ;
	}

	// Didn't get a CR-LF pair, but hit end of buffer -- Error case
	return NULL ;
}


//
//  SkipIfCRLF:  Local helper function to skip the next char (pair) only if
//               it's a CR-LF; otherwise ignore it.
//
LPBYTE SkipIfCRLF(LPBYTE pbBuff)
{
	// If the next char(pair) is CR-LF, skip it so that we are at the beginning  
	// of the next line; otherwise ignore it
	if (CHAR_CR == *pbBuff  &&  CHAR_LF == *(pbBuff+1))   // got a CR-LF pair
		return (pbBuff + 2) ;
	else
		return pbBuff ;
}

//
//  ExtractHeaderLine
//
//  Extracts the header line info and returns the pointer to next line
//
LPBYTE CLine21DataStream::ExtractHeaderLine(LPBYTE pbBuff)
{
	if (0 == CompText((LPSTR)pbBuff, "SubType=", lstrlen("SubType="), TRUE)) // SubType info
	{
	pbBuff += lstrlen("SubType=") ;
	if (0 == CompText((LPSTR)pbBuff, "BytePair", lstrlen("BytePair"), TRUE))
	{
		m_iSubType = AM_SRCL21_SUBTYPE_BYTEPAIR ;
		pbBuff += lstrlen("BytePair") ;
		m_iDataSize = 2 ;
	}
	else if (0 == CompText((LPSTR)pbBuff, "GOPPacket", lstrlen("GOPPacket"), TRUE))
	{
		m_iSubType = AM_SRCL21_SUBTYPE_GOPPACKET ;
		pbBuff += lstrlen("GOPPacket") ;
		m_iDataSize = sizeof(AM_L21_GOPUD_PACKET) ;
	}
	else if (0 == CompText((LPSTR)pbBuff, "VBIRawData", lstrlen("VBIRawData"), TRUE))
	{
		m_iSubType = AM_SRCL21_SUBTYPE_VBIRAWDATA ;
		pbBuff += lstrlen("VBIRawData") ;
		m_iDataSize = 40 ;  // just some random value!!!
	}
	else
		m_iSubType = 0 ;  // unknown
	}
	else if (0 == lstrcmpi((LPSTR)pbBuff, TEXT("VideoInfo")))  // VideoInfo info
	{
		;
	}
	else 
	{
		;
	}

	LPBYTE   pPrev = pbBuff ;
	pbBuff = SkipUptoCRLF(pbBuff) ;
	m_iBytesLeft -= (pbBuff - pPrev) ; // remember to reduce # chars left!!
	return pbBuff ;
}


//
//  GetNextData
//
//  Gets the data from the input file for the next output sample
//
BOOL CLine21DataStream::GetNextData(LPBYTE pData, LONG *plDataLen)
{
	// ASSERT(*plDataLen == m_iDataSize) ;  // necessary????

	// This is a check to detect when we run out of data to parse
	if (m_iBytesLeft <= 0)
	{
		DbgLog((LOG_ERROR, 1, TEXT("We have no or negative bytes left to parse in ::GetNextData()"))) ;
		return FALSE ;
	}

	switch (m_iSubType)
	{
		case AM_SRCL21_SUBTYPE_BYTEPAIR:
			FillBufferIfReqd(BYTEPAIR_MIN) ;
			return GetNextBytePairData(pData, plDataLen) ;

		case AM_SRCL21_SUBTYPE_GOPPACKET:
			FillBufferIfReqd(GOPPACKET_MIN) ;
			return GetNextGOPPacketData(pData, plDataLen) ;

		case AM_SRCL21_SUBTYPE_VBIRAWDATA:
			return FALSE ;  // for now, later TRUE ;
			// FillBufferIfReqd(VBIRAWDATA_MIN) ;
			// GetNextVBIRawData(pData, plDataLen) ;
			// return TRUE ;

		default:
			return FALSE ;
	}
}

//
//  IsHexDigit: Helper function checking if given char is a hex digit
//
BOOL IsHexDigit(CHAR ch)
{
	return ((ch >= '0' && ch <= '9') || 
		(ch >= 'A' && ch <= 'F') ||
		(ch >= 'a' && ch <= 'f')) ;
}

//
//  GetHexDigit: Helper function getting numerical value of a hex char
//
int GetHexDigit(CHAR ch)
{
	if (ch >= '0' && ch <= '9')
	return ch - '0' ;
	else if (ch >= 'A' && ch <= 'F')
	return ch - 'A' + 10 ;
	else if (ch >= 'a' && ch <= 'f')
	return ch - 'a' + 10 ;
	else 
	return 0 ;   // error !!!
}


//
//  ApplyParityBit: Uses correct or wrong odd parity bit for the specified
//                  character.
//
BYTE ApplyParityBit(BYTE ch, BOOL bWrongParity)
{
	ch = ch & 0x7F ;
	BYTE chTemp = ch ;
	chTemp ^= chTemp >> 4 ;
	chTemp ^= chTemp >> 2 ;
	BOOL bOddParity = (0 != (0x01 & (chTemp ^ (chTemp >> 1)))) ;
	if ((bWrongParity && bOddParity) || (!bWrongParity && !bOddParity))
		ch = ch | 0x80 ;

	return ch ;
}


//
//  PickBytePair: Picks the next byte pair from a GOP packet or real byte 
//                pair as specified in the inout file.
//
BOOL CLine21DataStream::PickBytePair(LPBYTE pbData)
{
	int         n = 0 ;
	int         aiVal[2] ;
	BYTE        achChar[2] = { 0, 0 } ;
	BYTE        ch ;
	int         iDepth = 0 ;
	BOOL        bSplMode = FALSE ;
	BOOL        bGotCtrlCode = FALSE ;
	BOOL        abWrongParity[2] = { FALSE, FALSE } ;
	BOOL        bInsideNumber = FALSE ;

	//  First check if we have used up all the chars in the buffer
	if (m_iBytesLeft <= 0)
	{
		DbgLog((LOG_TRACE, 1, TEXT("End of caption text input file."))) ;
		// CBasePin *pOutPin = m_pFilter->GetPin(0) ;
		// ASSERT(pPin) ;
		/* pPin->Deliver */ // EndOfStream() ;  // stop the data stream
		return FALSE ;
	}

	//  Are we at the end of a line? If so skip the CR-LF
	if (CHAR_CR == *m_lpbNext && CHAR_LF == *(m_lpbNext+1))
	{
		DbgLog((LOG_TRACE, 3, TEXT("Got a CR-LF pair; skipping it"))) ;
		m_lpbNext += 2 ;
		m_iBytesLeft -= 2 ;
	}

	// This is a check to detect when we run out of data to parse
	if (m_iBytesLeft <= 0)
	{
		// ASSERT(m_iBytesLeft > 0) ;
		DbgLog((LOG_ERROR, 1, TEXT("We have no or negative bytes left to parse after CR-LF"))) ;
		return FALSE ;
	}

	// Now go on until we get 2 bytes' worth data
	while (n < 2  &&  m_iBytesLeft > 0)
	{
		ch = *m_lpbNext++ ;
		m_iBytesLeft-- ;

		// If we have got just the last char so that the bytes left count is
		// down to 0, but the char just read has not been sent (we care only
		// if this char is not a special char).  -- Total Hack!!!
		if (0 == n  &&                       // first of the pair
			0 == m_iBytesLeft  &&            // no more char left
			!(ch == CHAR_CR || ch == CHAR_LF ||  // NOT (CR/LF 
			  ch == '[' || ch == ']' ||          //     [ or ]
			  ch == CHAR_DISCONTINUITY ||        //     discontinuity indicator
			  ch == CHAR_WRONGPARITY) )          //     Wrong parity indicator
		{
			achChar[0] = ch ;
			achChar[2] = 0 ;   // filler byte
			n = 2 ;
			break ;    // done!!!
		}

		// Another check to detect when we run out of data to parse
		if (m_iBytesLeft <= 0)
		{
			// ASSERT(m_iBytesLeft > 0) ;
			DbgLog((LOG_ERROR, 1, TEXT("We have no or negative bytes left to parse"))) ;
			// return FALSE ;
			// rather than returning, check if we have 1 char pending; if so
			// send it with 2nd char as 0.
			break ;
		}

		// Check if we are getting either CR or '[' as the 2nd byte or
		// we have run out of chars altogether
		if (1 == n  &&  (CHAR_CR == ch  ||  '[' == ch))
		{
			// Send a NULL char as second byte and step back 1 char in the buffer
			achChar[n] = 0 ;  // just put in a NULL to fill up
			n = 2 ;
			if (CHAR_CR == ch)  // for CR
			{
				if (CHAR_LF != (ch = *m_lpbNext))  // the next char should be LF; else bad data
				{
					DbgLog((LOG_ERROR, 1, TEXT("Bad chars (0x%x) in input file after CR"), ch)) ;
					return FALSE ;  // Stop playback -- was break ;
				}
				else   // LF next
				{
					// Skip the LF char too
					m_lpbNext++ ;
					m_iBytesLeft-- ;
					DbgLog((LOG_TRACE, 3, TEXT("Got a CR-LF at odd position and skipped it"))) ;
				}
			}
			else if ('[' == ch)  // it's a '['; back up a step
			{
				 // Back off for now; we'll handle the '[' in the next round
				 m_lpbNext-- ;
				 m_iBytesLeft++ ;
			}
			else
				DbgLog((LOG_TRACE, 0, TEXT("SURPRISE: How did we come here??"))) ;

		}
		// We are getting the special chars as byte pairs only
		else if ('[' == ch)
		{
			iDepth++ ;
			bSplMode = TRUE ;

			// init the two values and its index
			aiVal[0] = aiVal[1] = 0 ;
			n = 0 ;
		}
		else if (']' == ch)
		{
			iDepth-- ;
			if (iDepth < 0)
				return FALSE  ;  // show some error message
			bSplMode = FALSE ;
						bInsideNumber = FALSE ;  // no more inside a number

			n++ ;   // one more numeric value ends with ']'
			if (n == 2)  // we got 2 PACs within [ ]; Good!!
				bGotCtrlCode = TRUE ;
			else   // Error: how did this happen??
				return FALSE ;  // show some error message
			break ;
		}
		else if (bSplMode)  // in special mode; look for digits or a blank
		{
	    /*
		    if (CHAR_WRONGPARITY == ch)  // if this char is '^'
		    {
			    if (bInsideNumber)
			    {
				DbgLog((LOG_ERROR, 0, TEXT("BAD INPUT: Can't have a ^ inside a number"))) ;
				continue ;   // ignore this char
			    }
			    abWrongParity[n] = TRUE ;
			    continue ;
			}
	    */

		    if (CHAR_DISCONTINUITY == ch)  // if this char is '~'
		    {
			    if (bInsideNumber)
			    {
				DbgLog((LOG_ERROR, 0, TEXT("BAD INPUT: Can't have a ~ inside a number"))) ;
				continue ;   // ignore this char
			    }
			    m_bDiscont = TRUE ;
			    continue ;
			}

			if (IsHexDigit(ch))  // valid hex digit
			{
							bInsideNumber = TRUE ;
				aiVal[n] = aiVal[n] * 16 + GetHexDigit(ch) ;
				continue ;  // go for the next char
			}
			else if (' ' == ch)  // a blank space as separator?? 
			{
				bInsideNumber = FALSE ;
				n++ ;  // fill the next value given inside [ ]
				if (n >= 2)  // too many; return (show some error message)
					return FALSE  ;
				continue ;  // go for the next char
			}
			else  // bad char within [ ] -- show error message
				;
		}
		else   // normal mode -- can be any char
		{
	    /*
					if (CHAR_WRONGPARITY == ch)  // if this char is '^'
					{
						abWrongParity[n] = TRUE ;
						continue ;
					}

	    */
			achChar[n] = ch ;
			n++ ;
		}

		// If we haven't got 2-bytes yet, but ran out of data then give NULL 
		// as the 2nd byte and ease out of this loop
		if (1 == n  &&  0 == m_iBytesLeft)
		{
			achChar[n] = 0 ;
			n = 2 ;
		}
	}

	// We seemed to have got 2 valid byte equivalents (Control Codes or chars)
	if (bGotCtrlCode)
	{
		pbData[0] = /* (int) */ ApplyParityBit(aiVal[0], abWrongParity[0]) ;
		pbData[1] = /* (int) */ ApplyParityBit(aiVal[1], abWrongParity[1]) ;
	}
	else
	{
		pbData[0] = ApplyParityBit(achChar[0], abWrongParity[0]) ;
		pbData[1] = ApplyParityBit(achChar[1], abWrongParity[1]) ;
	}

	// Just making sure that we are not leaving a CR-LF as the next char (pair)
	// Being at the beginning of a line is beneficial.
	LPBYTE   pPrev = m_lpbNext ;
	m_lpbNext = SkipIfCRLF(m_lpbNext) ;
	m_iBytesLeft -= (m_lpbNext - pPrev) ; // remember to reduce # chars left!!

	return TRUE ;
}


//
//  GetNextBytePairData
//
//  Gets the data from the input file for the next output byte pair sample
//
BOOL CLine21DataStream::GetNextBytePairData(LPBYTE pbData, LONG *plDataSize)
{
	ASSERT(pbData) ;

	*plDataSize = 2 ;
	return PickBytePair(pbData) ;
}


//
//  GetValue:  Helper function to create the numerical value from chars
//
LPBYTE GetValue(LPBYTE pbBuff, UINT *puValue)
{
	CHAR    ch ;
	UINT    uVal = 0 ;

	// Skip leading blank(s)
	while ((ch = *pbBuff)  &&  ' ' == ch)
		pbBuff++ ;

	// Now read the actual value
	while (ch = *pbBuff++)
	{
		if (ch >= '0'  &&  ch <= '9')
			uVal = uVal * 10 + ch - '0' ;
		else
			break ;
	}
	pbBuff-- ;   // we went too far; back up a bit
	*puValue = uVal ;
	return pbBuff ;
}


//
//  GetNextGOPacketData
//
//  Gets the data from the input file for the next output GOP packet sample
//
BOOL CLine21DataStream::GetNextGOPPacketData(LPBYTE pData, LONG *plDataSize)
{
	ASSERT(pData) ;
	PAM_L21_GOPUD_PACKET  pGOPUD = (PAM_L21_GOPUD_PACKET) pData ;
	
	// Just making sure that we are not leaving a CR-LF as the next char (pair)
	// Being at the beginning of a line is beneficial.
	LPBYTE   pPrev = m_lpbNext ;
	m_lpbNext = SkipIfCRLF(m_lpbNext) ;
	m_iBytesLeft -= (m_lpbNext - pPrev) ; // remember to reduce # chars left!!

	// Find the "NEWPACKET <length>" element in the buffer at a new line
	UINT    uNumElements ;
	if (0 == CompText((LPSTR)m_lpbNext, "NewPacket ", lstrlen("NewPacket "), TRUE)) // NewPacket <kength> token?
	{
		m_lpbNext += lstrlen("NewPacket ") ;
		m_lpbNext = GetValue(m_lpbNext, &uNumElements) ;
		if (uNumElements > AM_L21_GOPUD_ELEMENT_MAX)
		{
			DbgLog((LOG_ERROR, 1, 
				TEXT("\"NewPacket\" length (%u) is more than max allowed (truncated)"), 
				uNumElements)) ;
			uNumElements = AM_L21_GOPUD_ELEMENT_MAX ;
		}
		pPrev = m_lpbNext ;
		m_lpbNext = SkipUptoCRLF(m_lpbNext) ;
		m_iBytesLeft -= (m_lpbNext - pPrev) ;  // remember to reduce the # chars skipped
	}
	else
	{
		DbgLog((LOG_ERROR, 1, 
			TEXT("No \"NewPacket <length>\" token was found before GOPPacket data"))) ;
		return FALSE ;
	}

	// Fill in the header with valid values
	CopyMemory(pGOPUD->Header.abL21StartCode, AM_L21_GOPUD_STARTCODE, 4) ;
	CopyMemory(pGOPUD->Header.abL21Indicator, AM_L21_GOPUD_L21INDICATOR, 2) ;
	CopyMemory(pGOPUD->Header.abL21Reserved, AM_L21_GOPUD_L21RESERVED, 2) ;

	// Get all the byte pair elements and set the marker bits etc
	ZeroMemory(pGOPUD->aElements, sizeof(AM_L21_GOPUD_ELEMENT) * 
			   AM_L21_GOPUD_ELEMENT_MAX) ;  // clear elements data

	TCHAR       achPair[2] ;
	for (UINT u = 0 ; u < uNumElements ; u++)
	{
		if (! PickBytePair((LPBYTE)achPair) )
		{
			DbgLog((LOG_ERROR, 1, TEXT("Error getting byte pair for element %d"), u+1)) ;
			return FALSE ;
		}
		pGOPUD->aElements[u].chFirst  = achPair[0] ;
		pGOPUD->aElements[u].chSecond = achPair[1] ;
		pGOPUD->aElements[u].bMarker_Switch = (AM_L21_GOPUD_ELEMENT_MARKERBITS << 1) | 
											  AM_L21_GOPUD_ELEMENT_VALIDFLAG ;

		// Just make sure that we are not eating into the next GOP packet
		// Check for the "NewPacket " token at the line start.
		if (0 == CompText((LPSTR)m_lpbNext, "NewPacket ", lstrlen("NewPacket "), TRUE))
		{
			DbgLog((LOG_ERROR, 1, TEXT("New packet starting after %d byte pairs"), u+1)) ;
			uNumElements = u+1 ;  // use the correct number of byte pairs
			break ;
		}
	}

	// Now only we know the actual size of the sample data
	*plDataSize = sizeof(AM_L21_GOPUD_HEADER) + 
	uNumElements * sizeof(AM_L21_GOPUD_ELEMENT) ;

	// Now we exactly know how many elements are in the packet.  So we can create
	// set the OR of TopField flag, reserved and # elements.
	pGOPUD->Header.bTopField_Rsrvd_NumElems = 
	AM_L21_GOPUD_TOPFIELD_FLAG | AM_L21_GOPUD_RESERVED | uNumElements ;

	return TRUE ;
}


//
//  GetNextVBIRawData
//
//  Gets the data from the input file for the next output VBI Raw data sample
//
BOOL CLine21DataStream::GetNextVBIRawData(LPBYTE pData, LONG *plDataSize)
{
	return TRUE ;
}


//
//  FillBufferIfReqd
//
//  Checks if the byte left has fallen below the min specified; if so, reads
//  in cross at least the min.
//
//  Returns TRUE only if new data has been read off the input file.
//
BOOL CLine21DataStream::FillBufferIfReqd(int iMin)
{
	LPBYTE      pbDest ;
	DWORD       dw ;         

	if (m_iBytesLeft > iMin)
		return FALSE ;

	// Check if EOF has already been hit; if so, don't read anymore
	if (m_bGotEOF)
		return FALSE ;

	// Move last few bytes to the beginning and adjust pointer to the start
	CopyMemory(m_achIntBuffer, m_lpbNext, m_iBytesLeft) ;
	m_lpbNext = (LPBYTE)m_achIntBuffer ;
	pbDest = (LPBYTE)m_achIntBuffer + m_iBytesLeft ;

	// Read in more to the position after the existing bytes
	if (! ReadFile(m_hFile, pbDest, MAXREADSIZE /* - m_iBytesLeft */, &dw, NULL) ||
		dw < (DWORD)(MAXREADSIZE)) //  - m_iBytesLeft))
	{
		m_bGotEOF = TRUE ;   // we have hit EOF; don't read anymore
		m_iBytesLeft += dw ;
	}
	else
		m_iBytesLeft += MAXREADSIZE ;

	// Make sure the buffer has trailing nulls as end indicator
	m_achIntBuffer[m_iBytesLeft]   =       // Null terminate the input buffer.
	m_achIntBuffer[m_iBytesLeft+1] =       // We use 3 chars just to ensure that
	m_achIntBuffer[m_iBytesLeft+2] = 0 ;   // by mistake we don't skip over one.

	return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\lin21dec\l21dgdi.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
//
//  L21DGDI.h: Line 21 Decoder GDI-related base class code
//

#ifndef _INC_L21DGDI_H
#define _INC_L21DGDI_H


//
// Forward declarations
//
class CGDIWork ;


//
// We start with 8x12 pixel chars by default
//
#ifndef __DEFAULTCHARSIZE_DEFINED
#define __DEFAULTCHARSIZE_DEFINED
#define DEFAULT_CHAR_WIDTH    8
#define DEFAULT_CHAR_HEIGHT   12
#endif // __DEFAULTCHARSIZE_DEFINED

// #define TEST

//
//  CGDIWork: class for GDI details to print caption text to output bitmap
//
class CGDIWork {
public:
    CGDIWork(void) ;
    ~CGDIWork(void) ;
    BOOL InitFont(void) ;
    void InitColorNLastChar(void) ;
    DWORD GetPaletteForFormat(LPBITMAPINFOHEADER lpbmih) ;
    inline void SetOutputBuffer(LPBYTE lpbOut) {
        m_bNewOutBuffer = m_lpbOutBuffer != lpbOut ; // Changed?
        m_lpbOutBuffer = lpbOut ;
    } ;
    void SetColorFiller(void) ;
    void FillOutputBuffer(void) ;
    HRESULT GetDefaultFormatInfo(LPBITMAPINFO lpbmi, DWORD *pdwSize) ;
    HRESULT GetOutputFormat(LPBITMAPINFOHEADER lpbmih) ;
    HRESULT GetOutputOutFormat(LPBITMAPINFOHEADER lpbmih) ;
    HRESULT SetOutputOutFormat(LPBITMAPINFO lpbmi) ;
    HRESULT SetOutputInFormat(LPBITMAPINFO lpbmi) ;
    inline void GetBackgroundColor(DWORD *pdwPhysColor) { *pdwPhysColor = m_dwPhysColor ; } ;
    BOOL SetBackgroundColor(DWORD dwPhysColor) ;
    inline BOOL GetBackgroundOpaque(void)         { return m_bOpaque ; } ;
    inline void SetBackgroundOpaque(BOOL bOpaque) { m_bOpaque = bOpaque ; } ;
    
    inline UINT GetCharHeight(void)  { return m_uCharHeight ; } ;
    inline int  GetScrollStep(void)  { return m_iScrollStep ; } ;
    BOOL CreateOutputDC(void) ;
    BOOL DeleteOutputDC(void) ;
    void DrawLeadingSpace(int iLine, int iCol) ;
    void WriteChar(int iLine, int iCol, CCaptionChar& cc) ;
    inline BOOL IsNewIntBuffer(void)   { return m_bNewIntBuffer ; } ;
    inline BOOL IsNewOutBuffer(void)   { return m_bNewOutBuffer ; } ;
    inline BOOL IsBitmapDirty(void)    { return m_bBitmapDirty ; } ;
    void ClearInternalBuffer(void) ;
    inline void ClearNewIntBufferFlag(void) { m_bNewIntBuffer = FALSE ; } ;
    inline void ClearNewOutBufferFlag(void) { m_bNewOutBuffer = FALSE ; } ;
    inline void ClearBitmapDirtyFlag(void) { m_bBitmapDirty = FALSE ; } ;
    void CopyLine(int iSrcLine, int iSrcOffset, 
                  int iDestLine, int iDestOffset, 
                  UINT uNumScanLines = 0xFF) ;
    inline BOOL IsTTFont(void)  { return m_bUseTTFont ; } ;
    inline BOOL IsOutDIBClear(void)  { return m_bOutDIBClear ; } ;
    BOOL IsSizeOK(LPBITMAPINFOHEADER lpbmih) ;
    inline BOOL IsOutputInverted(void) { return m_bOutputInverted ; } ;
    void GetOutputLines(int iDestLine, RECT *prectLine) ;
    
private:   // private data
    CCritSec        m_csL21DGDI ;     // to serialize actions on internal DIB secn
    
#ifdef TEST
    HDC             m_hDCTest ;       // a DC on the desktop just for testing
#endif // TEST
    HDC             m_hDCInt ;        // an HDC for output (attached to a DIBSection)
    BOOL            m_bDCInited ;     // DC is ready for real output (DIB section created)
    
    LPBYTE          m_lpbOutBuffer ;  // output sample buffer pointer
    LPBYTE          m_lpbIntBuffer ;  // memory buffer of output DIBSection
    HBITMAP         m_hBmpInt ;       // bitmap for output DIBSection
    HBITMAP         m_hBmpIntOrig ;   // original bitmap for output DIBSection
    LPBITMAPINFO    m_lpBMIOut ;      // BITMAPINFO for output from downstream filter
    LPBITMAPINFO    m_lpBMIIn ;       // BITMAPINFO for output from upstream filter
    UINT            m_uBMIOutSize ;   // bytes for BMI data from downstream
    UINT            m_uBMIInSize ;    // bytes for BMI data from upstream
    LONG            m_lWidth ;        // currently set output width
    LONG            m_lHeight ;       // currently set output height
    int             m_iBorderPercent ;// current border percent (10 or 20)
    DWORD           m_dwPhysColor ;   // bkgrnd physical color for output bitmap
    BYTE            m_abColorFiller[12] ; // filler to be applied for fast color keying
    BOOL            m_bOpaque ;       // should caption background be opaque?
    
    BOOL            m_bBitmapDirty ;  // new output content has been written on DIBSection
    BOOL            m_bNewIntBuffer ; // new DIB section created
    BOOL            m_bNewOutBuffer ; // new output sample buffer
    BOOL            m_bOutputInverted ; // output right side up for -ve height
    BOOL            m_bUseTTFont ;    // TT font (Lucida Console) available; use that
    HFONT           m_hFontDef ;      // default font (white, normal) to use
    HFONT           m_hFontSpl ;      // font with any specialty (italics, underline etc.)
    HFONT           m_hFontOrig ;     // original font that came with the DC
    LOGFONT         m_lfChar ;        // LOGFONT struct for quick font create
    BOOL            m_bUseSplFont ;   // Is special font being used now?
    BOOL            m_bFontSizeOK ;   // are font sizes OK? Otherwise we don't draw
    
    UINT            m_uCharWidth ;    // width of each caption char in pixels
    UINT            m_uCharHeight ;   // height of each caption char in pixels
    int             m_iScrollStep ;   // # scanlines to scroll by in each step
    UINT            m_uIntBmpWidth ;  // width of internal output bitmap in pixels
    UINT            m_uIntBmpHeight ; // height of internal output bitmap in pixels
    UINT            m_uHorzOffset ;   // pixels to be left from the left
    UINT            m_uVertOffset ;   // pixels to be left from the top
    UINT            m_uBytesPerPixel ;// bytes for each pixel of output (based on bpp)
    UINT            m_uBytesPerSrcScanLine ; // bytes for each source scan line's data
    UINT            m_uBytesPerDestScanLine ;// bytes for each destn scan line's data
    
    CCaptionChar    m_ccLast ;        // last caption char and attribs printed
    COLORREF        m_acrFGColors[7] ;// 7 colors from white to magenta
    UINT            m_uColorIndex ;   // index of currently used color
    
    BOOL            m_bOutDIBClear ;  // Is output DIB secn clean?

#ifdef PERF
    int             m_idClearIntBuff ;
    int             m_idClearOutBuff ;
#endif // PERF

private:   // private helper methods
    bool InitBMIData(void) ;
    static int CALLBACK EnumFontProc(ENUMLOGFONTEX *lpELFE, NEWTEXTMETRIC *lpNTM,
        int iFontType, LPARAM lParam) ;
    void CheckTTFont(void) ;
    void ChangeFont(BOOL bItalics, BOOL bUnderline) ;
    void ChangeFontSize(UINT uCharWidth, UINT uCharHeight) ;
    void ChangeColor(int iColor) ;
    BOOL SetOutputSize(LONG lWidth, LONG lHeight) ;
    BOOL SetCharNBmpSize(void) ;
    void SetNumBytesValues(void) ;
    void SetDefaultKeyColor(LPBITMAPINFOHEADER lpbmih) ;
    DWORD GetOwnPalette(int iNumEntries, PALETTEENTRY *ppe) ;
    BOOL CharSizeFromOutputSize(LONG lOutWidth, LONG lOutHeight, int *piCharWidth, int *piCharHeight) ;
} ;

#endif _INC_L21DGDI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\lin21dec\test\tsrcl21.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1996  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// {4DA9E3D0-5530-11d0-B79D-00AA003767A7}
DEFINE_GUID(CLSID_Line21TestSource, 
0x4da9e3d0, 0x5530, 0x11d0, 0xb7, 0x9d, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7);
// {4DA9E3D1-5530-11d0-B79D-00AA003767A7}
DEFINE_GUID(CLSID_Line21TestSourceProperty, 
0x4da9e3d1, 0x5530, 0x11d0, 0xb7, 0x9d, 0x0, 0xaa, 0x0, 0x37, 0x67, 0xa7);

//
//  GUID definition ends here.
//
#define UINT8  unsigned char
#define UINT16 unsigned short int

#define AM_SRCL21_SUBTYPE_BYTEPAIR     1
#define AM_SRCL21_SUBTYPE_GOPPACKET    2
#define AM_SRCL21_SUBTYPE_VBIRAWDATA   3

#define BYTEPAIR_MIN     8
#define GOPPACKET_MIN    254
#define VBIRAWDATA_MIN   40

#define CHAR_CR          0x0D
#define CHAR_LF          0x0A

#define CHAR_WRONGPARITY '^'
#define CHAR_DISCONTINUITY '~'

#define MAXREADSIZE      512


//
//  The following typedefs are copy of the same in ..\lin21dec.cpp file.
//  Make surethey are in sync; otherwise we'll produce some output data here
//  which the Lin21Dec filter won't understand.
//
static const BYTE AM_L21_GOPUD_STARTCODE[4] = { 0x00, 0x00, 0x01, 0xB2 } ;
static const BYTE AM_L21_GOPUD_L21INDICATOR[2] = { 0x43, 0x43 } ;
static const BYTE AM_L21_GOPUD_L21RESERVED[2] = { 0x01, 0xF8 } ;
#define AM_L21_GOPUD_TOPFIELD_FLAG      0x80
#define AM_L21_GOPUD_RESERVED           0x40
#define AM_L21_GOPUD_ELEMENT_MARKERBITS 0x7F
#define AM_L21_GOPUD_ELEMENT_VALIDFLAG  0x1
#define AM_L21_GOPUD_ELEMENT_MAX        63

typedef struct _AM_L21_GOPUD_ELEMENT {
    BYTE        bMarker_Switch ;
    BYTE        chFirst ;
    BYTE        chSecond ;
} AM_L21_GOPUD_ELEMENT, *PAM_L21_GOPUD_ELEMENT ;

typedef struct _AM_L21_GOPUD_HEADER {
    BYTE        abL21StartCode[4] ;
    BYTE        abL21Indicator[2] ;
    BYTE        abL21Reserved[2] ;
    BYTE        bTopField_Rsrvd_NumElems ;
} AM_L21_GOPUD_HEADER, *PAM_L21_GOPUD_HEADER ;

typedef struct _AM_L21_GOPUD_PACKET {
    AM_L21_GOPUD_HEADER   Header ;
    AM_L21_GOPUD_ELEMENT  aElements[AM_L21_GOPUD_ELEMENT_MAX] ;
} AM_L21_GOPUD_PACKET, *PAM_L21_GOPUD_PACKET ;

// The class managing the output pin
class CLine21DataStream ;

// Main object for a line 21 data source filter
class CLine21Source : public CSource
{

public:

    // Only way to create a Line 21 data source filter
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN lpunk, HRESULT *phr);

private:

    // It is only allowed to to create these objects with CreateInstance
    CLine21Source(LPUNKNOWN lpunk, HRESULT *phr);

} ; // CLine21Source


// CBallStream manages the data flow from the output pin.
class CLine21DataStream : public CSourceStream
{

public:

    CLine21DataStream(HRESULT *phr, CLine21Source *pParent, LPCWSTR pPinName) ;
    ~CLine21DataStream() ;

    // reads 2 bytes info from input text file to create the output sample
    HRESULT FillBuffer(IMediaSample *pms) ;

    // Ask for buffers of the size appropriate to the agreed media type
    HRESULT DecideBufferSize(IMemAllocator *pIMemAlloc,
                             ALLOCATOR_PROPERTIES *pProperties) ;

    // Set the agreed media type, and set up approp. VIDEOINFO struct as format
    HRESULT SetMediaType(const CMediaType *pMediaType) ;

    // God knows why we need these
    HRESULT CheckMediaType(const CMediaType *pMediaType) ;
    HRESULT GetMediaType(int iPosition, CMediaType *pmt) ;

    // Quality control notifications sent to us
    STDMETHODIMP Notify(IBaseFilter * pSender, Quality q) ;

private:  // data

    TCHAR       m_achSourceFile[MAX_PATH] ;  // input file name
    HANDLE      m_hFile ;         // input file handle for reading
    BOOL        m_bInitValid ;    // filter was init-ed correctly
    BOOL        m_bGotEOF    ;    // ReadFile() hit EOF of input file
    TCHAR       m_achIntBuffer[MAXREADSIZE+GOPPACKET_MIN+3] ; // internal buffer for Line21 bytes
                                  // +GOPPACKET_MIN to re-load when part of GOPPacket is unparsed
                                  // +3 for safety null chars as buffer end
    LPBYTE      m_lpbNext ;       // pointer to byte to be read from buffer
    int         m_iSubType ;      // an Id for selected sub type for output
    int         m_iBytesLeft ;    // bytes are left in internal buffer
    int         m_iHeight;        // The current image height
    int         m_iWidth;         // And current image width
    int         m_iBitCount ;     // required bitdepth of caption bitmap
    BOOL        m_bFirstSample ;  // Is it the first sample going out?
    CRefTime    m_rtRepeatTime;   // Time between frames (in 100nSec units)
    CCritSec    m_csSharedState;  // Lock on m_rtSampleTime and m_Ball
    CRefTime    m_rtSampleTime;   // The time stamp for each sample
    LPBYTE      m_lpbCaptionData ;// ptr to caption data to be passed downstream
    int         m_iDataSize ;     // size of caption data each each packet
    BOOL        m_bDiscont ;      // should we send a discont. sample down?

private:  // helper methods

    BOOL        IsValidSubtype(int iSubType) {
                return (iSubType >= AM_SRCL21_SUBTYPE_BYTEPAIR &&
                        iSubType <= AM_SRCL21_SUBTYPE_VBIRAWDATA) ;
    } ;

    // Gets the input text file name and gets it opened and read
    BOOL        OpenInputFile(void) ;

    // Open the specified input text file and reads the header info
    BOOL        ReadHeaderData(void) ;
    LPBYTE      ExtractHeaderLine(LPBYTE lpbBuff) ;

    // Check if the bytes left in the internal buffer is lower that Min
    BOOL        FillBufferIfReqd(int iMin) ;

    // Read data from input file to create next sample
    BOOL        GetNextData(LPBYTE pbData, LONG *plDataLen) ;
    BOOL        GetNextBytePairData(LPBYTE pbData, LONG *plDataSize) ;
    BOOL        GetNextGOPPacketData(LPBYTE pbData, LONG *plDataSize) ;
    BOOL        GetNextVBIRawData(LPBYTE pbData, LONG *plDataSize) ;
    BOOL        PickBytePair(LPBYTE pbData) ;

    BOOL        SkipLine(void) ;

} ; // CLine21DataStream
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\lin21dec2\l21dbase.cpp ===
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.

//
// DirectShow Line 21 Decoder 2 Filter: Base class code
//

#include <streams.h>
#include <windowsx.h>

// #ifdef FILTER_DLL
#include <initguid.h>
// #endif

#include <IL21Dec.h>
#include "L21DBase.h"
#include "L21DDraw.h"
#include "L21Decod.h"


//
//  CCaptionChar: Caption char base class implementation (non-inline methods)
//

void CCaptionChar::SetChar(UINT16 wChar)
{
    if (wChar != m_wChar)
    {
        SetDirty(TRUE) ;
        m_wChar = wChar ;
    }
}

void CCaptionChar::SetColor(UINT8 uColor)
{
    if (uColor != GetColor())  // color changed
    {
        SetDirty(TRUE) ;
        m_uAttrib &= ~AM_L21_FGCOLOR_MASK ;           // clear old color
        m_uAttrib |= (uColor & AM_L21_FGCOLOR_MASK) ; // set new color
    }
}

void CCaptionChar::SetEffect(UINT8 uEffect)
{
    if (uEffect != GetEffect())
    {
        SetDirty(TRUE) ; 
        m_uAttrib &= ~AM_L21_FGEFFECT_MASK ;            // clear old effect bits
        m_uAttrib |= (uEffect & AM_L21_FGEFFECT_MASK) ; // set new effect value
    }
}

void CCaptionChar::SetItalicized(BOOL bState) 
{
    if (bState) 
        m_uAttrib |= AM_L21_FGEFFECT_ITALICS ;
    else 
        m_uAttrib &= ~AM_L21_FGEFFECT_ITALICS ;
    SetDirty(TRUE) ; 
}

void CCaptionChar::SetUnderLined(BOOL bState)
{
    if (bState) 
        m_uAttrib |= AM_L21_FGEFFECT_UNDERLINE ;
    else 
        m_uAttrib &= ~AM_L21_FGEFFECT_UNDERLINE ;
    SetDirty(TRUE) ; 
}

void CCaptionChar::SetFlashing(BOOL bState)
{
    if (bState) 
        m_uAttrib |= AM_L21_FGEFFECT_FLASHING ;
    else 
        m_uAttrib &= ~AM_L21_FGEFFECT_FLASHING ;
    SetDirty(TRUE) ; 
}

void CCaptionChar::SetDirty(BOOL bState)
{
    if (bState) 
        m_uAttrib |= AM_L21_ATTRIB_DIRTY ;
    else 
        m_uAttrib &= ~AM_L21_ATTRIB_DIRTY ;
}

void CCaptionChar::SetMidRowCode(BOOL bState)
{
    if (bState) 
        m_uAttrib |= AM_L21_ATTRIB_MRC ;
    else 
        m_uAttrib &= ~AM_L21_ATTRIB_MRC ;
}



//
//  CCaptionLine: Base class implementation of a line of CC chars
//
CCaptionLine::CCaptionLine(void)
{
    m_uNumChars = 0 ;
    m_uStartRow = 0 ;  // un-inited
    ClearLine() ;
}

CCaptionLine::CCaptionLine(const UINT uStartRow, const UINT uNumChars /* 0 */)
{
    m_uNumChars = (UINT8)uNumChars ;
    m_uStartRow = (UINT8)uStartRow ;
    ClearLine() ;
}

CCaptionLine& CCaptionLine::operator = (const CCaptionLine& cl)
{
    m_uNumChars = cl.m_uNumChars ;
    m_uStartRow = cl.m_uStartRow ;
    for (int i = 0 ; i < MAX_CAPTION_COLUMNS ; i++)
        cl.GetCaptionChar(i, m_aCapChar[i]) ;
    return *this ;
}

int CCaptionLine::IncNumChars(UINT uNumChars)
{
    m_uNumChars += (uNumChars & 0x3F) ;
    if (m_uNumChars > MAX_CAPTION_COLUMNS)
        m_uNumChars = MAX_CAPTION_COLUMNS ;
    return m_uNumChars ;
}

int CCaptionLine::DecNumChars(UINT uNumChars)
{
    if (uNumChars < m_uNumChars)
        m_uNumChars -= (UINT8)uNumChars ;   // & 0x3F ;
    else       // error ??? or just make it 0 ???
        m_uNumChars = 0 ;
    return m_uNumChars ;
}

void CCaptionLine::SetCaptionChar(UINT uCol, const CCaptionChar &cc)
{
    if (uCol >= (UINT)MAX_CAPTION_COLUMNS)   // error!!
        return ;

    // A Hacky (?) Fix:
    // If this char is for the last (32nd) column then we set the "Dirty"
    // flag on for the char before it so that it gets redrawn causing any
    // prev char in last column to be erased while rendering.
    if ((UINT)MAX_CAPTION_COLUMNS - 1 == uCol)
        m_aCapChar[uCol-1].SetDirty(TRUE) ;  // to cause re-rendering
    m_aCapChar[uCol] = cc  ;
}

CCaptionChar* CCaptionLine::GetCaptionCharPtr(UINT uCol)
{
    if (uCol >= (UINT)MAX_CAPTION_COLUMNS)   // error!!
        return NULL ;
    return &(m_aCapChar[uCol]) ;
}

void CCaptionLine::SetStartRow(UINT uRow)
{
    if (uRow > MAX_CAPTION_ROWS)  // error!! We use 1-based index for Row numbers
    {
        ASSERT(uRow > MAX_CAPTION_ROWS) ;
        return ;
    }
    m_uStartRow = uRow & 0xF ;
    ASSERT(m_uStartRow > 0 && uRow > 0) ;
}

void CCaptionLine::MoveCaptionChars(int iNum)
{
    ASSERT(iNum < MAX_CAPTION_COLUMNS) ;
    int  i ;
    for (i = min(m_uNumChars, MAX_CAPTION_COLUMNS-iNum) - 1 ; i >= 0 ; i--)
        m_aCapChar[i+iNum] = m_aCapChar[i] ;
    CCaptionChar  cc ;
    for (i = 0 ; i < iNum ; i++)
        m_aCapChar[i] = cc ;
    m_uNumChars = min(m_uNumChars+iNum, MAX_CAPTION_COLUMNS) ;
}

void CCaptionLine::ClearLine(void)
{
    CCaptionChar cc ;
    for (UINT u = 0 ; u < MAX_CAPTION_COLUMNS ; u++)
        m_aCapChar[u] = cc ;
    m_uNumChars = 0 ;
    m_uStartRow = 0 ;   // newly added
}



//
//  CRowIndexMap: Mapping of row usage (row to line) class implementation
//
int CRowIndexMap::GetRowIndex(UINT8 uRow)
{
    DbgLog((LOG_TRACE, 5, TEXT("CRowIndexMap::GetRowIndex(%u)"), uRow)) ;

    uRow-- ;   // it's just easier to deal with 0-based index
    
    if (uRow >= MAX_CAPTION_ROWS)
    {
        DbgLog((LOG_ERROR, 2, TEXT("Invalid row number (%u) for row index"), uRow)) ;
        ASSERT(FALSE) ;
        return -1 ;
    }
    
    // Decide if we check the bits in 1st or 2nd DWORD (mask is 1111b)
#if 0
    if (uRow >= 8)
    {
        uRow = (uRow - 8) << 2 ;
        return ( m_adwMap[1] & (0xF << uRow) ) >> uRow ;
    }
    else
    {
        uRow = uRow << 2 ;
        return ( m_adwMap[0] & (0xF << uRow) ) >> uRow ;
    }
#else   // trust me -- it works!!!
    return (m_adwMap[uRow / 8] & (0xF << (4 * (uRow % 8)))) >> (4 * (uRow % 8)) ;
#endif // #if 0
}

void CRowIndexMap::SetRowIndex(UINT uLine, UINT8 uRow)
{
    DbgLog((LOG_TRACE, 5, TEXT("CRowIndexMap::SetRowIndex(%u, %u)"), uLine, uRow)) ;

    uRow-- ;  // it's just easier to deal with 0-based index
    
    if (uRow >= MAX_CAPTION_ROWS  ||
        uLine > MAX_CAPTION_LINES)
    {
        DbgLog((LOG_ERROR, 2, TEXT("Invalid row number (%u)/line (%u) for saving"), uRow, uLine)) ;
        ASSERT(FALSE) ;
        return ;
    }
    
    // Decide if we check the bits in 1st or 2nd DWORD (mask is 1111b)
#if 0
    if (uRow >= 8)
    {
        uRow = (uRow - 8) << 2 ;
        m_adwMap[1] &= ~(0xF << uRow) ;   // just to clear any existing bits there
        m_adwMap[1] |= (uLine << uRow) ;
    }
    else
    {
        uRow = uRow << 2 ;
        m_adwMap[0] &= ~(0xF << uRow) ;   // just to clear any existing bits there
        m_adwMap[0] |= (uLine << uRow) ;
    }
#else   // trust me -- it works!!!
    m_adwMap[uRow / 8] &= ~(0xF   << (4 * (uRow % 8))) ;  // clear any existing bits there
    m_adwMap[uRow / 8] |=  (uLine << (4 * (uRow % 8))) ;  // put new line number in there
#endif // #if 0
}


//
//  CCaptionBuffer: The base caption buffer class implementation
//

CCaptionBuffer::CCaptionBuffer(UINT8 uStyle    /* = AM_L21_CCSTYLE_None */,
                               UINT8 uMaxLines /* = MAX_CAPTION_LINES */)
{
    ClearBuffer() ;
    m_uMaxLines = uMaxLines ;
    m_uCaptionStyle = uStyle ;
}

CCaptionBuffer::CCaptionBuffer(/* const */ CCaptionBuffer &cb)
{
    for (int i = 0 ; i < cb.GetNumLines() ; i++)
        m_aCapLine[i] = cb.GetCaptionLine(i) ;
    m_RowIndex  = cb.m_RowIndex ;
    m_uNumLines = cb.m_uNumLines ;
    m_uMaxLines = cb.m_uMaxLines ;
    m_uCurrCol  = cb.m_uCurrCol ;
    m_uCurrLine = cb.m_uCurrLine ;
    m_uCaptionStyle = cb.m_uCaptionStyle ;
    m_uDirtyState = L21_CAPBUFFER_REDRAWALL ;  // cb.m_uDirtyState ;
}

void CCaptionBuffer::SetCurrCol(int uCurrCol)
{
    m_uCurrCol = uCurrCol & 0x3F ;
    if (m_uCurrCol > MAX_CAPTION_COLUMNS - 1)
        m_uCurrCol = MAX_CAPTION_COLUMNS - 1 ;
}

void CCaptionBuffer::SetCaptionLine(UINT uLine, const CCaptionLine& cl)
{
    if (uLine >= MAX_CAPTION_LINES)
        return ;
    m_aCapLine[uLine] = cl ;
    SetRedrawLine((UINT8)uLine, TRUE) ;
}

void CCaptionBuffer::ClearCaptionLine(UINT uLine)
{
    m_aCapLine[uLine].ClearLine() ;
    SetRedrawLine((UINT8)uLine, TRUE) ;
}

int CCaptionBuffer::IncCurrCol(UINT uNumChars)
{
    m_uCurrCol += (UINT8)uNumChars ;
    if (m_uCurrCol > MAX_CAPTION_COLUMNS - 1)
        m_uCurrCol = MAX_CAPTION_COLUMNS - 1 ;
    
    return m_uCurrCol ;
}

int CCaptionBuffer::DecCurrCol(UINT uNumChars)
{
    if (m_uCurrCol < uNumChars)
        m_uCurrCol  = 0 ;
    else
        m_uCurrCol -= (UINT8)uNumChars ;
    
    return m_uCurrCol ;
}

void CCaptionBuffer::ClearBuffer(void)
{
    for (int i = 0 ; i < MAX_CAPTION_LINES ; i++)
    {
        m_aCapLine[i].ClearLine() ;
        SetStartRow(i, 0) ;
    }
    m_RowIndex.ClearRowIndex() ; ;
    m_uNumLines = 0 ;
    m_uMaxLines = MAX_CAPTION_LINES ;
    m_uCurrCol  = 0 ;
    m_uCurrLine = 0 ;
    m_uDirtyState = L21_CAPBUFFER_REDRAWALL |   // draw everything
                    L21_CAPBUFFER_DIRTY ;       // buffer is dirty
}

void CCaptionBuffer::InitCaptionBuffer(void) 
{
    ClearBuffer() ;
}

int CCaptionBuffer::IncNumLines(int uLines)
{
    m_uNumLines += uLines & 0x7 ;
    // Roll-Up is supposed to allow 1 line more than the max for scrolling
    if (AM_L21_CCSTYLE_RollUp == m_uCaptionStyle)
    {
        if (m_uNumLines > m_uMaxLines+1)
            m_uNumLines = m_uMaxLines+1 ;
    }
    else  // non Roll-Up mode -- Pop-On or Paint-On
    {
        if (m_uNumLines > m_uMaxLines)  // What? Too many lines!!!
        {
            DbgLog((LOG_ERROR, 1, 
                TEXT("WARNING: How did %u lines get created with max of %u lines?"), 
                m_uNumLines, m_uMaxLines)) ;
            m_uNumLines = m_uMaxLines ;  // just to plug the hole!!!
        }
    }
    return m_uNumLines ;
}

int CCaptionBuffer::DecNumLines(int uLines)
{
    if (uLines > m_uNumLines)  // error!!
        return 0 ;
    m_uNumLines -= uLines & 0x7 ;
    return m_uNumLines ;
}

void CCaptionBuffer::RemoveLineFromBuffer(UINT8 uLine, BOOL bUpNextLine)
{
    DbgLog((LOG_TRACE, 5, TEXT("CRowIndexMap::RemoveLineFromBuffer(%u, %u)"), 
            uLine, bUpNextLine)) ;

    int iNumLines = GetNumLines() ;
    int iMaxLines = GetMaxLines() ;
    int iRow ;
    
    if (bUpNextLine)    // if next line should be move up (for Roll-up style)
    {
        // We go upto iNumLines-1 because iNumLines is the not-yet-included line
        for (int i = uLine ; i < iNumLines-1 ; i++)
        {
            iRow = GetStartRow(i) ;     // get the row posn of line i
            SetCaptionLine(i, GetCaptionLine(i+1)) ;  // copy line i+1 data to line i
            SetStartRow(i, iRow) ;  // put prev line i's row # as new line i's row #
        }
    
        // Clear the last line data and row index bits, ONLY IF it's already in
        iRow = GetStartRow(iNumLines-1) ;
        ClearCaptionLine(iNumLines-1) ;
        if (iNumLines <= iMaxLines)  // if the last line is already in
        {
            if (iRow > 0)  // if row # is valid, release it
                m_RowIndex.SetRowIndex(0, (UINT8)iRow) ;
            else           // otherwise something wrong
                ASSERT(FALSE) ; // so that we know
        }
        // Otherwise there is a not-yet-in line hanging, which doesn't have a 
        // row number given yet.  So no need to release that row.
    }
    else    // next line doesn't get moved up (for NON Roll-up style)
    {
        // Release the line-to-be-deleted's row by clearing the index bit
        if ((iRow = GetStartRow(uLine)) > 0)  // (check validity)
            m_RowIndex.SetRowIndex(0, (UINT8)iRow) ;
        else            // that would be weird
            ASSERT(FALSE) ; // so that we know

        // Here we stop at iNumLines-1, because we move all the existing lines to
        // make space for a new line that will start next.
        for (int i = uLine ; i < iNumLines-1 ; i++)
        {
            SetCaptionLine(i, GetCaptionLine(i+1)) ;  // copy line i+1 data to line i
            // Update index bitmap to new row i's start row (+1 because index 
            // bitmap nibble values are 1-based).
            m_RowIndex.SetRowIndex(i+1, (UINT8)GetStartRow(i)) ;
        }
    
        // Clear the last line's data
        ClearCaptionLine(iNumLines-1) ;
    }
    
    // A line is out of the buffer -- so buffer is dirty
    SetBufferDirty(TRUE) ;
    
    // Clear whole DIB section so that no leftover shows up
    SetRedrawAll(TRUE) ;
    
    DecNumLines(1) ;  // now we have 1 line less
    
    // We have removed a line from the buffer; so the current line also
    // needs to be updated to point to the proper line in the caption buffer.
    if (m_uCurrLine == uLine)
        if (uLine == m_uNumLines-1)
            m_uCurrLine-- ;
        else
            ;  // do nothing -- old next line will become new curr line
        else if (m_uCurrLine > uLine)   // if a line above was removed
            m_uCurrLine-- ;             // then move line index up
        else    // a line was deleted below current line
            ;   // do nothing -- doesn't matter at all
        if (m_uCurrLine < 0)  // in case we went too far up
            m_uCurrLine = 0 ; // come down to the ground!!!
}

void CCaptionBuffer::SetStartRow(UINT uLine, UINT uRow)
{
    int iRow = GetStartRow(uLine) ;         // get the currently set row number
    if (iRow == (int)uRow)  // if nothing changed...
        return ;            // ...no point re-doing it
    if (iRow > 0)                           // if it was already set then...
        m_RowIndex.SetRowIndex(0, (UINT8)iRow) ;   // ...clear the row index map bits
    m_aCapLine[uLine].SetStartRow(uRow) ;   // set new row value for the line
    // set row index bits only if specified row > 0; else it's just for clearing
    if (uRow > 0) {
        // use +1 for line # as row index map uses 1-based index for line #s
        m_RowIndex.SetRowIndex(uLine+1, (UINT8)uRow) ; // set index map bits for new row
    }
    else
        ASSERT(FALSE) ;
}

BOOL CCaptionBuffer::IsRedrawLine(UINT8 uLine)
{
    if (uLine >= m_uNumLines)
    {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid line number (%d) to get line redraw info"), uLine)) ;
        return FALSE ;
    }
    return (m_uDirtyState & (0x01 << (L21_CAPBUFFDIRTY_FLAGS + uLine))) ; 
}

void CCaptionBuffer::SetBufferDirty(BOOL bState)
{
    if (bState)
        m_uDirtyState |= (UINT8)L21_CAPBUFFER_DIRTY ;
    else
        m_uDirtyState &= (UINT8)~L21_CAPBUFFER_DIRTY ;
}

void CCaptionBuffer::SetRedrawAll(BOOL bState)
{
    if (bState)
        m_uDirtyState |= (UINT8)L21_CAPBUFFER_REDRAWALL ;
    else
        m_uDirtyState &= (UINT8)~L21_CAPBUFFER_REDRAWALL ;
}

void CCaptionBuffer::SetRedrawLine(UINT8 uLine, BOOL bState)
{
    if (uLine >= m_uNumLines)
    {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid line number (%d) to set line redraw info"), uLine)) ;
        return ;
    }
    if (bState)
        m_uDirtyState |= (UINT8)(0x01 << (L21_CAPBUFFDIRTY_FLAGS + uLine)) ;
    else
        m_uDirtyState &= (UINT8)~(0x01 << (L21_CAPBUFFDIRTY_FLAGS + uLine)) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\lin21dec2\l21ddraw.cpp ===
// Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.

//
// DirectShow Line 21 Decoder 2 Filter: drawing-related base class code
//

#include <streams.h>
#include <windowsx.h>

#include <initguid.h>

#ifdef FILTER_DLL
DEFINE_GUID(IID_IDirectDraw7,
            0x15e65ec0,0x3b9c,0x11d2,0xb9,0x2f,0x00,0x60,0x97,0x97,0xea,0x5b);
#endif

#include <IL21Dec.h>
#include "L21DBase.h"
#include "L21DDraw.h"
#include "L21Decod.h"


//
//  CLine21DecDraw: class for drawing details to output caption text to bitmap
//
CLine21DecDraw::CLine21DecDraw(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::CLine21DecDraw()"))) ;

    // Init some of the members
    m_pDDrawObjUnk          = NULL ;
    m_lpDDSOutput           = NULL ;
    m_lpDDSNormalFontCache  = NULL ;
    m_lpDDSItalicFontCache  = NULL ;
    m_lpDDSSpecialFontCache = NULL ;
    m_lpDDSScratch          = NULL ;
    m_lpBMIOut              = NULL ;
    m_uBMIOutSize           = 0 ;
    m_lpBMIIn               = NULL ;
    m_uBMIInSize            = 0 ;
    m_lpBltList             = NULL ;
    m_iPixelOffset          = 0 ;

    // Create an initial input BITMAPINFO struct to start with
    InitBMIData() ;

    // Init the width and height based on prelim size so that we can compare
    // any size changes later
    if (m_lpBMIIn)  // InitBMIData() succeeded as it should
    {
        m_lWidth  = m_lpBMIIn->bmiHeader.biWidth ;
        m_lHeight = m_lpBMIIn->bmiHeader.biHeight ;
    }
    else  // InitBMIData() failed!!!
    {
        m_lWidth  = 640 ;
        m_lHeight = 480 ;
    }

    // check if Lucida Console is available (the callback sets the m_bUseTTFont flag)
    CheckTTFont() ;  // m_bUseTTFont is set inside this function

    //
    // We are not supposed to use the 10% of the border on the top/bottom and left/right.
    // But leaving 10% on each side for a 320x240 image when we are using a non-TT font,
    // like "Terminal", leaves very little room for showing captions. So I leave only 5%
    // on each side with non-TT font.
    // By doing this I am violating the spec, but it's a necessary evil.
    // When TT font (Lucida Console) is available, we leave 10% border on every side.
    //
    if ( IsTTFont() )
        m_iBorderPercent = 20 ;
    else
        m_iBorderPercent = 10 ;

    // Set the border amounts based on output size and font type (TT or not)
    m_iHorzOffset = m_lWidth  * m_iBorderPercent / 200 ;  // default
    m_iVertOffset = m_lHeight * m_iBorderPercent / 200 ;  // default

    // Use char size appropriate for the output bitmap size
    if (! CharSizeFromOutputSize(m_lWidth, m_lHeight, &m_iCharWidth, &m_iCharHeight) )
    {
        DbgLog((LOG_TRACE, 1,
            TEXT("CharSizeFromOutputSize(%ld,%ld,,) failed. Using default char size."),
            m_lWidth, m_lHeight)) ;
        ASSERT(!TEXT("Char size selection failed")) ;
        // Use dafult char size
        m_iCharWidth   = DEFAULT_CHAR_WIDTH ;
        m_iCharHeight  = DEFAULT_CHAR_HEIGHT ;
    }

    ASSERT(m_iCharWidth  * (MAX_CAPTION_COLUMNS + 2) <= m_lWidth) ;
    ASSERT(m_iCharHeight * MAX_CAPTION_ROWS <= m_lHeight) ;

    m_iScrollStep  = CalcScrollStepFromCharHeight() ;

    // Flags to know if output should be turn on/off and/or sent down
    m_bOutputClear   = TRUE ;  // output buffer is clear on start
    m_bNewOutBuffer  = TRUE ;  // output buffer is new to start with

    //
    // Init the COLORREF array of 7 foreground colors as just RGB values
    //
    m_acrFGColors[0] = RGB(0xFF, 0xFF, 0xFF) ;   // white
    m_acrFGColors[1] = RGB( 0x0, 0xFF,  0x0) ;   // green
    m_acrFGColors[2] = RGB( 0x0,  0x0, 0xFF) ;   // blue
    m_acrFGColors[3] = RGB( 0x0, 0xFF, 0xFF) ;   // cyan
    m_acrFGColors[4] = RGB(0xFF,  0x0,  0x0) ;   // red
    m_acrFGColors[5] = RGB(0xFF, 0xFF,  0x0) ;   // yellow
    m_acrFGColors[6] = RGB(0xFF,  0x0, 0xFF) ;   // magenta

    m_idxFGColors[0] = 0x0F;    // white
    m_idxFGColors[1] = 0x0A;    // green
    m_idxFGColors[2] = 0x0C;    // blue
    m_idxFGColors[3] = 0x0E;    // cyan
    m_idxFGColors[4] = 0x09;    // red
    m_idxFGColors[5] = 0x0B;    // yellow
    m_idxFGColors[6] = 0x0D;    // magenta

    // Init text color (FG, BG, opacity), last CC char printed etc.
    InitColorNLastChar() ;

    // Init the list of caption chars
    InitCharSet() ;

    // Font cache needs to be built before any output
    SetFontUpdate(true) ;
}


CLine21DecDraw::~CLine21DecDraw(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::~CLine21DecDraw()"))) ;

    // Delete the cached fonts
    if (m_lpDDSNormalFontCache)
    {
        m_lpDDSNormalFontCache->Release() ;
        m_lpDDSNormalFontCache = NULL ;
    }
    if (m_lpDDSItalicFontCache )
    {
        m_lpDDSItalicFontCache->Release() ;
        m_lpDDSItalicFontCache  = NULL ;
    }
    if (m_lpDDSSpecialFontCache)
    {
        m_lpDDSSpecialFontCache->Release() ;
        m_lpDDSSpecialFontCache = NULL ;
    }
    if (m_lpDDSScratch)
    {
        m_lpDDSScratch->Release() ;
        m_lpDDSScratch = NULL ;
    }

    // release BMI data pointer
    if (m_lpBMIOut)
        delete m_lpBMIOut ;
    m_uBMIOutSize = 0 ;
    if (m_lpBMIIn)
        delete m_lpBMIIn ;
    m_uBMIInSize = 0 ;
}


int CALLBACK CLine21DecDraw::EnumFontProc(ENUMLOGFONTEX *lpELFE, NEWTEXTMETRIC *lpNTM,
                                    int iFontType, LPARAM lParam)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::EnumFontProc(0x%lx, 0x%lx, %d, %ld)"),
            lpELFE, lpNTM, iFontType, lParam)) ;

    // Just verify that we got a valid TT font
    if ( !(lpELFE->elfLogFont.lfCharSet & 0xFFFFFF00) &&
        !(lpELFE->elfLogFont.lfPitchAndFamily & 0xFFFFFF00) &&
        !(iFontType & 0xFFFF0000) )
    {
        ASSERT(lpELFE->elfLogFont.lfPitchAndFamily & (FIXED_PITCH | FF_MODERN)) ;
        ((CLine21DecDraw *) (LPVOID) lParam)->m_lfChar = lpELFE->elfLogFont ;
        ((CLine21DecDraw *) (LPVOID) lParam)->m_bUseTTFont = TRUE ;
        return 1 ;
    }

    ASSERT(FALSE) ;  // Weird!!! We should know about it.
    return 0 ;
}


void CLine21DecDraw::CheckTTFont(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::CheckTTFont()"))) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    m_bUseTTFont = FALSE ;  // assume not available
    ZeroMemory(&m_lfChar, sizeof(LOGFONT)) ;
    lstrcpy(m_lfChar.lfFaceName, TEXT("Lucida Console")) ;
    m_lfChar.lfCharSet = ANSI_CHARSET ;
    m_lfChar.lfPitchAndFamily = 0 ;
    HDC hDC = CreateDC(TEXT("Display"),NULL, NULL, NULL) ;  // a temp DC on the desktop
    if (NULL == hDC)
    {
        DbgLog((LOG_TRACE, 1, TEXT("ERROR: Couldn't create DC for font enum"))) ;
        ASSERT(hDC) ;
        return ;
    }
    EnumFontFamiliesEx(hDC, &m_lfChar, (FONTENUMPROC) EnumFontProc, (LPARAM)(LPVOID)this, 0) ;
    DeleteDC(hDC) ;  // done with temp DC
}


void CLine21DecDraw::InitColorNLastChar(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::InitColorNLastChar()"))) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    // Last caption char init
    m_ccLast.SetChar(0) ;
    m_ccLast.SetEffect(0) ;
    m_ccLast.SetColor(AM_L21_FGCOLOR_WHITE) ;

    // By default we use white text on a black opaque background
    m_uColorIndex = AM_L21_FGCOLOR_WHITE ;

    // For now assume an opaque background
    m_bOpaque = TRUE ;
    m_dwBackground = 0x80000000 ;  // 0xFF000000

    // We go back to white chars with normal style
    ChangeFont(AM_L21_FGCOLOR_WHITE, FALSE, FALSE) ;
}


void CLine21DecDraw::InitCharSet(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::InitCharSet()"))) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    // First init with the worst case chars -- last 8 spaces blanked out
    //                                  1         2         3         4         5         6         7         8         9        10        11        12
    //                       01 23456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890
    TCHAR *lpszChars = TEXT(" !\"#$%&'()A+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[E]IOUabcdefghijklmnopqrstuvwxyzC NN         A EAEIOU        ") ;
    for (int i = 0 ; i < 120 ; i++)
    {
        m_lpwCharSet[i] = MAKECCCHAR(0, lpszChars[i]) ;
    }
    m_lpwCharSet[120] = MAKECCCHAR(0, 0) ;

    // Change a few special chars embedded in the standard char range
    m_lpwCharSet[ 10] = 0x00e1 ;  // 'a' with an acute accent
    m_lpwCharSet[ 60] = 0x00e9 ;  // 'e' with an acute accent
    m_lpwCharSet[ 62] = 0x00ed ;  // 'i' with an acute accent
    m_lpwCharSet[ 63] = 0x00f3 ;  // 'o' with an acute accent
    m_lpwCharSet[ 64] = 0x00fa ;  // 'u' with an acute accent
    m_lpwCharSet[ 91] = 0x00e7 ;  // 'c' with cedilla
    m_lpwCharSet[ 92] = 0x00f7 ;  // division sign
    m_lpwCharSet[ 93] = 0x00d1 ;  // 'N' with tilde
    m_lpwCharSet[ 94] = 0x00f1 ;  // 'n' with tilde
    m_lpwCharSet[ 95] = 0x2588 ;  // solid block

    // Then fill in the range of real special chars
    m_lpwCharSet[ 96] = 0x00ae ;  // 30h
    m_lpwCharSet[ 97] = 0x00b0 ;  // 31h
    m_lpwCharSet[ 98] = 0x00bd ;  // 32h
    m_lpwCharSet[ 99] = 0x00bf ;  // 33h
    m_lpwCharSet[100] = 0x2122 ;  // 34h
    m_lpwCharSet[101] = 0x00a2 ;  // 35h
    m_lpwCharSet[102] = 0x00a3 ;  // 36h
    m_lpwCharSet[103] = 0x266b ;  // 37h
    m_lpwCharSet[104] = 0x00e0 ;  // 38h
    m_lpwCharSet[105] = 0x0000 ;  // 39h
    m_lpwCharSet[106] = 0x00e8 ;  // 3ah
    m_lpwCharSet[107] = 0x00e2 ;  // 3bh
    m_lpwCharSet[108] = 0x00ea ;  // 3ch
    m_lpwCharSet[109] = 0x00ee ;  // 3dh
    m_lpwCharSet[110] = 0x00f4 ;  // 3eh
    m_lpwCharSet[111] = 0x00fb ;  // 3fh
}


bool CLine21DecDraw::InitBMIData(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::InitBMIData()"))) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    HDC  hDCTemp = GetDC(NULL) ;
    if (NULL == hDCTemp)
    {
        ASSERT(!TEXT("GetDC(NULL) failed")) ;
        return false ;
    }
    WORD wPlanes   = (WORD)GetDeviceCaps(hDCTemp, PLANES) ;
    WORD wBitCount = (WORD)GetDeviceCaps(hDCTemp, BITSPIXEL) ;
    ReleaseDC(NULL, hDCTemp) ;

    wPlanes   = 1 ;
    wBitCount = wBitCount ;

    m_uBMIInSize = sizeof(BITMAPINFOHEADER) ;  // at least

    // Increase BITMAPINFO struct size based of bpp value
    if (8 == wBitCount)        // palettized mode
        m_uBMIInSize += 256 * sizeof(RGBQUAD) ;  // for palette entries
    else
        m_uBMIInSize += 3 * sizeof(RGBQUAD) ;    // space for bitmasks, if needed

    m_lpBMIIn = (LPBITMAPINFO) new BYTE[m_uBMIInSize] ;
    if (NULL == m_lpBMIIn)
    {
        ASSERT(!TEXT("Out of memory for BMIIn buffer")) ;
        return false ;
    }
    m_lpBMIIn->bmiHeader.biSize     = sizeof(BITMAPINFOHEADER) ;
    m_lpBMIIn->bmiHeader.biWidth    = CAPTION_OUTPUT_WIDTH ;
    m_lpBMIIn->bmiHeader.biHeight   = CAPTION_OUTPUT_HEIGHT ;
    m_lpBMIIn->bmiHeader.biPlanes   = wPlanes ;
    m_lpBMIIn->bmiHeader.biBitCount = wBitCount ;
    if (16 == m_lpBMIIn->bmiHeader.biBitCount)  // assume 565
        m_lpBMIIn->bmiHeader.biCompression = BI_BITFIELDS ;
    else
        m_lpBMIIn->bmiHeader.biCompression = BI_RGB ;
    m_lpBMIIn->bmiHeader.biSizeImage = DIBSIZE(m_lpBMIIn->bmiHeader) ;
    m_lpBMIIn->bmiHeader.biXPelsPerMeter = 0 ;
    m_lpBMIIn->bmiHeader.biYPelsPerMeter = 0 ;
    m_lpBMIIn->bmiHeader.biClrUsed = 0 ;
    m_lpBMIIn->bmiHeader.biClrImportant = 0 ;

    //
    // If we are in bitfield mode, set the bmiColors values too.
    // If we are in palettized mode, pickthe system palette.
    //
    DWORD  *pdw = (DWORD *) m_lpBMIIn->bmiColors ;
    switch (m_lpBMIIn->bmiHeader.biBitCount)
    {
    case 8:
        // GetPaletteForFormat((LPBITMAPINFOHEADER) m_lpBMIIn) ;
        ASSERT(8 != m_lpBMIIn->bmiHeader.biBitCount) ;
        return false ;
        // break ;

    case 16:    // by deafult 565
        if (m_lpBMIIn->bmiHeader.biCompression == BI_BITFIELDS) // 565
        {
            pdw[iRED]   = bits565[iRED] ;
            pdw[iGREEN] = bits565[iGREEN] ;
            pdw[iBLUE]  = bits565[iBLUE] ;
        }
        else    // BI_RGB: 555
        {
            pdw[iRED]   = bits555[iRED] ;
            pdw[iGREEN] = bits555[iGREEN] ;
            pdw[iBLUE]  = bits555[iBLUE] ;
        }
        break ;

    case 24:  //  clear all...
        pdw[iRED]   =
        pdw[iGREEN] =
        pdw[iBLUE]  = 0 ;
        break ;

    case 32:  // set the masks
        if (m_lpBMIIn->bmiHeader.biCompression == BI_BITFIELDS)
        {
            pdw[iRED]   = bits888[iRED] ;
            pdw[iGREEN] = bits888[iGREEN] ;
            pdw[iBLUE]  = bits888[iBLUE] ;
        }
        else              // BI_RGB
        {
            pdw[iRED]   =
            pdw[iGREEN] =
            pdw[iBLUE]  = 0 ;
        }
        break ;

    default:  // don't care
        ASSERT(!TEXT("Bad biBitCount!!")) ;
        break ;
    }

    return true ;
}


BOOL CLine21DecDraw::SetBackgroundColor(DWORD dwBGColor)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::SetBackgroundColor(0x%lx)"), dwBGColor)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    BOOL  bResult = TRUE ;
    if (m_dwBackground != dwBGColor)
    {
        m_dwBackground = dwBGColor ;
        SetFontUpdate(true) ;  // need to rebuild font caches for new BG color
    }

    return true ;   // bResult ;
}


// Create normal, italic and special (color, U or I+U) font caches
bool CLine21DecDraw::InitFont(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::InitFont()"))) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    // Create a normal font to find out the char size etc.
    HFONT hFont = CreateCCFont(0, m_iCharHeight, FALSE, FALSE) ;
    if (NULL == hFont)  // font creation failed
    {
        return false ;
    }

    //
    // The following magic is necessary to get GDI to rasterize
    // the font with anti-aliasing switched on when we later use
    // the font in a DDraw Surface.  The doc's say that this is only
    // necessary in Win9X - but Win2K seems to require it too.
    //
    SIZE size ;
    LPCTSTR  lpszStr = TEXT("ABCDEFGHIJKLMNOPQRSTUVWXYZ") ;
    HDC hdcWin = GetDC(NULL) ;
    HFONT hFontOld = (HFONT)SelectObject(hdcWin, hFont) ;  // select new font
    GetTextExtentPoint32(hdcWin, lpszStr, lstrlen(lpszStr), &size) ;
    size.cx /= lstrlen(lpszStr) ;  // get per char width

    // Restore font to original and delete font now
    hFont = (HFONT)SelectObject(hdcWin, hFontOld) ;
    DeleteObject(hFont) ;

    //
    // Make sure that the font doesn't get too big.
    //
    if (size.cx * FONTCACHELINELENGTH > 1024) {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: Text size (%d) is too big. Can't create font."), size.cx)) ;
        ReleaseDC(NULL, hdcWin) ;  // release new DC created here
        return false ;
    }

    // Set the char size
    m_iCharWidth  = size.cx ;  // iMaxWidth ;
    m_iCharHeight = size.cy ;

    // Also re-calc scroll step value now
    m_iScrollStep = CalcScrollStepFromCharHeight() ;

    // Calculate the horizontal offset and vertical offset of the CC area within
    // the output DDraw surface
    int iCCRectWidth  = m_iCharWidth * (MAX_CAPTION_COLUMNS + 2) ; // +2 for leading and trailing space
    iCCRectWidth  = DWORDALIGN(iCCRectWidth) ;  // make sure to DWORD align it
    m_iHorzOffset = min((long)(m_lHeight * m_iBorderPercent / 200),  // border % is for 2 sides
                        (m_lWidth - iCCRectWidth) / 2) ;
    // iCCRectHeight = m_iCharHeight * MAX_CAPTION_LINES ;        // max 4 lines of caption shown
    // Vertically we want to leave 10% of the height or leave just enough space
    // to accomodate all the caption lines
    m_iVertOffset = min((long)(m_lHeight * m_iBorderPercent / 200),  // border % is for 2 sides
                        (m_lHeight - (long)(m_iCharHeight * MAX_CAPTION_ROWS)) / 2) ;

    // Create white color normal and italic font caches now
    bool  bResult = true ;
    DWORD dwTextColor = m_uColorIndex ;
    DWORD  dwBGColor  = 0xFF000000 ; // m_dwBackground ;
    DWORD dwOpacity   = m_bOpaque ? OPAQUE : 0 ;
    if (m_lpDDSScratch)
    {
        m_lpDDSScratch->Release() ;
        m_lpDDSScratch = NULL ;
    }
    if (m_lpDDSNormalFontCache)
    {
        m_lpDDSNormalFontCache->Release() ;
        m_lpDDSNormalFontCache = NULL ;
    }
    if (m_lpDDSItalicFontCache)
    {
        m_lpDDSItalicFontCache->Release() ;
        m_lpDDSItalicFontCache = NULL ;
    }

    bResult &= CreateScratchFontCache(&m_lpDDSScratch) ;
    bResult &= CreateFontCache(&m_lpDDSNormalFontCache, dwTextColor, dwBGColor, dwOpacity, FALSE, FALSE) ;
    bResult &= CreateFontCache(&m_lpDDSItalicFontCache, dwTextColor, dwBGColor, dwOpacity, TRUE, FALSE) ;
    // We don't create any special font cache, because we don't what will be
    // required.  So we just reset it here.
    if (m_lpDDSSpecialFontCache)
    {
        m_lpDDSSpecialFontCache->Release() ;
        m_lpDDSSpecialFontCache = NULL ;
    }

    //
    // We set the current font cache to the normal font cache by default
    //
    m_lpBltList = m_lpDDSNormalFontCache ;

    //
    // Now release the resources acquired locally
    //
    ReleaseDC(NULL, hdcWin) ;  // release the locally created DC
    // DeleteObject(hFont) ;      // delete font

    // If we successfully (re-)inited the font cache, reset the flag
    if (bResult)
    {
        SetFontUpdate(false) ;
    }

    return bResult ;  // return status
}


HFONT CLine21DecDraw::CreateCCFont(int iFontWidth, int iFontHeight, BOOL bItalic, BOOL bUnderline)
{
    DbgLog((LOG_TRACE, 5,
            TEXT("CLine21DecDraw::CreateCCFont(%d, %d, %s, %s)"),
            iFontWidth, iFontHeight, bItalic ? TEXT("T") : TEXT("F"), bUnderline ? TEXT("T") : TEXT("F"))) ;

    //
    // Initialize LOGFONT structure to create an "anti-aliased" Lucida Console font
    //
    LOGFONT lfChar ;
    ZeroMemory(&lfChar, sizeof(lfChar)) ;

    // Init a LOGFONT struct in m_lfChar
    if (IsTTFont())
    {
        DbgLog((LOG_TRACE, 5, TEXT("Got Lucida Console TT Font"))) ;
        lstrcpy(lfChar.lfFaceName, TEXT("Lucida Console")) ;
        if (0 == iFontWidth)
        {
            lfChar.lfHeight     = -iFontHeight ;
        }
        else
        {
            lfChar.lfHeight     = iFontHeight ;
            lfChar.lfWidth      = iFontWidth ;
        }

        // m_lfChar.lfCharSet set in CheckTTFont()
        // m_lfChar.lfPitchAndFamily set in CheckTTFont()
        lfChar.lfCharSet        = m_lfChar.lfCharSet ;
        lfChar.lfPitchAndFamily = m_lfChar.lfPitchAndFamily ;
    }
    else  // no Lucida Console; use 8x12 Terminal font
    {
        DbgLog((LOG_TRACE, 1, 
                TEXT("Did NOT get Lucida Console TT Font. Will use Terminal"))) ;
        lfChar.lfHeight = iFontHeight ;
        lfChar.lfWidth  = iFontWidth ;
        lfChar.lfCharSet = ANSI_CHARSET ;
        lfChar.lfPitchAndFamily = FIXED_PITCH | FF_MODERN ;
        lstrcpy(lfChar.lfFaceName, TEXT("Terminal")) ;
    }

    lfChar.lfWeight         = FW_NORMAL ;
    lfChar.lfItalic         = bItalic ? TRUE : FALSE ;
    lfChar.lfUnderline      = bUnderline ? TRUE : FALSE ;
    lfChar.lfOutPrecision   = OUT_STRING_PRECIS ;
    lfChar.lfClipPrecision  = CLIP_STROKE_PRECIS ;
    lfChar.lfQuality        = ANTIALIASED_QUALITY ;

    HFONT hFont = CreateFontIndirect(&lfChar) ;
    if ( !hFont )
    {
        DbgLog((LOG_ERROR, 1,
            TEXT("WARNING: CreateFontIndirect('Lucida Console') failed (Error %ld)"),
            GetLastError())) ;
        return NULL ;
    }

    return hFont ;
}


bool CLine21DecDraw::CreateScratchFontCache(LPDIRECTDRAWSURFACE7* lplpDDSFontCache)
{
    DbgLog((LOG_TRACE, 5,
            TEXT("CLine21DecDraw::CreateScratchFontCache(0x%lx)"), lplpDDSFontCache)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    //
    // Create the DDraw ARGB32/ARGB4444 surface in "system" memory to be used as
    // a scratch font cache, where the chars will be drawn; then the alpha value
    // will be set and the resulting bits will be written into the final
    // destination font cache.  This will speed up font cache creation a lot, as
    // it avoid the read-modify-write cycle on VRAM font caches.
    //
    HRESULT hr = DDrawARGBSurfaceInit(lplpDDSFontCache, TRUE /* use SysMem */, FALSE /* Texture */,
                        FONTCACHELINELENGTH * (m_iCharWidth + INTERCHAR_SPACE),
                        FONTCACHENUMLINES  * m_iCharHeight) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 1, TEXT("DDrawARGBSurfaceInit() failed for scratch (Error 0x%lx)"), hr)) ;
        return false ;
    }

    // Clear the scratch surface before drawing the chars on it
    DDBLTFX ddFX ;
    ZeroMemory(&ddFX, sizeof(ddFX)) ;
    ddFX.dwSize = sizeof(ddFX) ;
    ddFX.dwFillColor =  0x00000000 ;
    hr = (*lplpDDSFontCache)->Blt(NULL, NULL, NULL, DDBLT_COLORFILL, &ddFX) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 1, TEXT("Blt() to clear scratch font cache failed (Error 0x%lx)"), hr)) ;
        return false ;
    }

    return true ;
}


bool CLine21DecDraw::CreateFontCache(LPDIRECTDRAWSURFACE7* lplpDDSFontCache,
                                     DWORD dwTextColor, DWORD dwBGColor,
                                     DWORD dwOpacity, BOOL bItalic,
                                     BOOL bUnderline)
{
    DbgLog((LOG_TRACE, 5,
            TEXT("CLine21DecDraw::CreateFontCache(0x%lx, 0x%lx, 0x%lx, 0x%lx, %s, %s)"),
            lplpDDSFontCache, dwTextColor, dwBGColor, dwOpacity,
            bItalic ? TEXT("T") : TEXT("F"), bUnderline ? TEXT("T") : TEXT("F"))) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    HRESULT   hr ;

    //
    // First make sure the scratch font cache exists; otherwise try to create it.
    //
    if (NULL == m_lpDDSScratch)
    {
        bool bResult = CreateScratchFontCache(&m_lpDDSScratch) ;
        if (! bResult )
        {
            return false ;
        }
    }

    //
    // Delete the old font cache
    //
    if (*lplpDDSFontCache)
    {
        (*lplpDDSFontCache)->Release() ;
        *lplpDDSFontCache = NULL ;
    }

    //
    // Create the DDraw ARGB32/ARGB4444 surface in "video" memory to be used as
    // font cache
    //
    hr = DDrawARGBSurfaceInit(lplpDDSFontCache, FALSE /* use VRAM */, TRUE /* Texture */,
                        FONTCACHELINELENGTH * (m_iCharWidth + INTERCHAR_SPACE),
                        FONTCACHENUMLINES  * m_iCharHeight) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 1, TEXT("DDrawARGBSurfaceInit() failed (Error 0x%lx)"), hr)) ;
        return false ;
    }

    // Get the DC for the scratch font cache (DDraw surface)
    HDC hdcDest ;
    m_lpDDSScratch->GetDC(&hdcDest) ;

    // Create a normal font to find out the char size etc.
    HFONT  hFont ;
    if (bItalic)
    {
        hFont = CreateCCFont(m_iCharWidth - INTERCHAR_SPACE_EXTRA, m_iCharHeight,
                             bItalic, bUnderline) ;
        SetTextCharacterExtra(hdcDest, INTERCHAR_SPACE + INTERCHAR_SPACE_EXTRA) ;  // add 6 inter-char spaces
    }
    else
    {
        hFont = CreateCCFont(0, m_iCharHeight, bItalic, bUnderline) ;
        SetTextCharacterExtra(hdcDest, INTERCHAR_SPACE) ;  // add 4 inter-char spaces
    }
    if (NULL == hFont)  // font creation failed
    {
        return false ;
    }

    //
    // Select the font into the DDraw surface and draw the characters
    //
    hFont = (HFONT)SelectObject(hdcDest, hFont) ;
    SetTextColor(hdcDest, m_acrFGColors[dwTextColor]) ;
    SetBkColor(hdcDest, dwBGColor) ;
    SetBkMode(hdcDest, dwOpacity) ;

    int iRow ;
    for (iRow = 0 ; iRow < FONTCACHENUMLINES ; iRow++)
    {
        ExtTextOutW(hdcDest, 0, iRow * m_iCharHeight, ETO_OPAQUE, NULL,
                    m_lpwCharSet + iRow * FONTCACHELINELENGTH, FONTCACHELINELENGTH,
                    NULL) ;
    }

    // Restore original font in DC and let go of them
    hFont = (HFONT)SelectObject(hdcDest, hFont) ;
    m_lpDDSScratch->ReleaseDC(hdcDest) ;
    DeleteObject(hFont) ;

    // Read each pixel data, set the alpha value, and then write to the VRAM font cache
    SetFontCacheAlpha(m_lpDDSScratch, *lplpDDSFontCache, m_idxFGColors[dwTextColor]) ;

    return true ;  // success
}


// We return a 32bit alpha value, which gets trimmed to 16bit by the caller, if needed
DWORD
CLine21DecDraw::GetAlphaFromBGColor(int iBitDepth)
{
    DWORD  dwAlpha = 0 ;

    switch (iBitDepth)
    {
    case 8:
        dwAlpha = 0x80;
        break ;

    case 16:
        dwAlpha = (m_dwBackground & 0xF0000000) >> 16 ;
        break ;

    case 32:
        dwAlpha = (m_dwBackground & 0xFF000000) ;
        break ;

    default:
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: GetAlphaFromBGColor(%d) called"), iBitDepth)) ;
        break ;
    }

    return dwAlpha ;
}


// We return a 32bit color value, which gets trimmed to 16bit by the caller, if needed
DWORD
CLine21DecDraw::GetColorBitsFromBGColor(int iBitDepth)
{
    DWORD  dwColorBits = 0 ;

    switch (iBitDepth)
    {
    case 16:
        dwColorBits = ((m_dwBackground & 0x00F00000) >> 12) |
                      ((m_dwBackground & 0x0000F000) >>  8) |
                      ((m_dwBackground & 0x000000F0) >>  4) ;
        break ;

    case 32:
        dwColorBits = (m_dwBackground & 0x00FFFFFF) ;
        break ;

    default:
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: GetColorBitsFromBGColor(%d) called"), iBitDepth)) ;
        break ;
    }

    return dwColorBits ;
}


void
CLine21DecDraw::SetFontCacheAlpha(LPDIRECTDRAWSURFACE7 lpDDSFontCacheSrc,
                                  LPDIRECTDRAWSURFACE7 lpDDSFontCacheDest,
                                  BYTE bFGClr
                                  )
{
    DbgLog((LOG_TRACE, 5,
            TEXT("CLine21DecDraw::SetFontCacheAlpha(0x%lx, 0x%lx)"), lpDDSFontCacheSrc, lpDDSFontCacheDest)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    //
    // We set the alpha values by hand here.  This is done on every pixel of the
    // font cache, but it happens only when the cache is created.
    // It gets us better font smoothing too.
    //
    HRESULT hr ;
    DDSURFACEDESC2 sdSrc, sdDest ;
    ZeroMemory(&sdSrc, sizeof(sdSrc)) ;
    sdSrc.dwSize = sizeof(sdSrc) ;
    hr = lpDDSFontCacheSrc->Lock(NULL, &sdSrc, DDLOCK_WAIT, NULL) ;
    if (DD_OK != hr)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Source font cache surface Lock() failed (Error 0x%lx)"), hr)) ;
        ASSERT(DD_OK == hr) ;
        return ;
    }
    ZeroMemory(&sdDest, sizeof(sdDest)) ;
    sdDest.dwSize = sizeof(sdDest) ;
    hr = lpDDSFontCacheDest->Lock(NULL, &sdDest, DDLOCK_WAIT, NULL) ;
    if (DD_OK != hr)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Dest font cache surface Lock() failed (Error 0x%lx)"), hr)) ;
        ASSERT(DD_OK == hr) ;
        lpDDSFontCacheSrc->Unlock(NULL) ;
        return ;
    }

    // Now we set the alpha based on the bitdepth at which we are outputting

    switch (sdDest.ddpfPixelFormat.dwRGBBitCount)
    {
    case 8:
        {
            DbgLog((LOG_TRACE, 5, TEXT("CC is being output at AI44"))) ;
            LPDWORD lpwSrc  = (LPDWORD) sdSrc.lpSurface ;
            LPBYTE lpwDest  = (LPBYTE) sdDest.lpSurface ;
            LPBYTE lpb ;
            BYTE   wPel ;
            BYTE   bAlpha     = (BYTE) GetAlphaFromBGColor(8) ;

            for (int iRow = 0 ; iRow < FONTCACHENUMLINES * m_iCharHeight ; iRow++)
            {
                LPDWORD lpwS = lpwSrc ;
                LPBYTE lpwD = lpwDest ;

                for (int iCol = 0 ;
                     iCol < FONTCACHELINELENGTH * (m_iCharWidth + INTERCHAR_SPACE) ;
                     iCol++)
                {
                    BYTE bPel = (BYTE)(*lpwS & 0xF0);
                    if (bPel)
                    {
                        bPel |= bFGClr;
                    }
                    else
                    {
                        bPel  = bAlpha ;  // | dwColorBits ;  // turn on alpha partially
                    }

                    *lpwD++ = bPel ;
                    lpwS++ ;
                }
                lpwSrc  += (sdSrc.lPitch / sizeof(DWORD)) ;
                lpwDest += sdDest.lPitch;
            }

            break;
        }

    case 16:
        {
            DbgLog((LOG_TRACE, 5, TEXT("CC is being output at ARGB4444"))) ;
            LPWORD lpwSrc  = (LPWORD) sdSrc.lpSurface ;
            LPWORD lpwDest = (LPWORD) sdDest.lpSurface ;
            WORD   wRed, wGreen, wBlue ;
            LPBYTE lpb ;
            WORD   wPel ;
            WORD   wAlpha     = (WORD) GetAlphaFromBGColor(16) ;
            WORD   wColorBits = (WORD) GetColorBitsFromBGColor(16) ;

            for (int iRow = 0 ; iRow < FONTCACHENUMLINES * m_iCharHeight ; iRow++)
            {
                LPWORD lpwS = lpwSrc ;
                LPWORD lpwD = lpwDest ;

                for (int iCol = 0 ;
                     iCol < FONTCACHELINELENGTH * (m_iCharWidth + INTERCHAR_SPACE) ;
                     iCol++)
                {
                    wRed = 0, wGreen = 0, wBlue = 0 ; // , wAlpha = 0 ;
                    lpb = (LPBYTE)lpwS ;
                    wPel = MAKEWORD(lpb[0], lpb[1]) ;
                    if (wPel)
                    {
                        wRed   = (wPel & 0xF000) >> 4 ;
                        wGreen = (wPel & 0x0780) >> 3 ;
                        wBlue  = (wPel & 0x001E) >> 1 ;
                        // wAlpha = 0xF000 ;  // turn on alpha fully
                        wPel   = 0xF000 | wRed | wGreen | wBlue ;
                    }
                    else
                    {
                        wPel   = wAlpha ;  // | wColorBits ;
                    }

                    *lpwD++ = wPel ;
                    lpwS++ ;
                }
                lpwSrc  += (sdSrc.lPitch / sizeof(WORD)) ;
                lpwDest += (sdDest.lPitch / sizeof(WORD)) ;
            }
            break ;
        }

    case 32:
        {
            DbgLog((LOG_TRACE, 5, TEXT("CC is being output at ARGB32"))) ;
            LPDWORD lpdwSrc = (LPDWORD) sdSrc.lpSurface ;
            LPDWORD lpdwDst = (LPDWORD) sdDest.lpSurface ;
            DWORD   dwAlpha = GetAlphaFromBGColor(32) ;
            DWORD   dwColorBits = GetColorBitsFromBGColor(32) ;
            for (int iRow = 0 ; iRow < FONTCACHENUMLINES * m_iCharHeight ; iRow++)
            {
                LPDWORD lpdw  = lpdwDst ;
                LPDWORD lpdwS = lpdwSrc ;

                for (int iCol = 0 ;
                     iCol < FONTCACHELINELENGTH * (m_iCharWidth + INTERCHAR_SPACE) ;
                     iCol++)
                {
                    DWORD dwPel = *lpdwS ;
                    if (dwPel)
                    {
                        dwPel |= 0xFF000000 ;  // turn on alpha fully
                    }
                    else
                    {
                        dwPel  = dwAlpha ;  // | dwColorBits ;  // turn on alpha partially
                    }

                    *lpdw++ = dwPel ;
                    lpdwS++;
                }
                lpdwSrc += (sdSrc.lPitch / sizeof(DWORD)) ;
                lpdwDst += (sdDest.lPitch / sizeof(DWORD)) ;
            }
            break ;
        }

    default:
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: Bad display bitdepth (%d) mode"), sdDest.ddpfPixelFormat.dwRGBBitCount)) ;

        break ;
    }  // end of switch ()

    // Done with everything
    lpDDSFontCacheSrc->Unlock(NULL) ;
    lpDDSFontCacheDest->Unlock(NULL) ;
}


HRESULT
CLine21DecDraw::DDrawARGBSurfaceInit(LPDIRECTDRAWSURFACE7* lplpDDSFontCache,
                                     BOOL bUseSysMem, BOOL bTexture,
                                     DWORD cx, DWORD cy)
{
    DbgLog((LOG_TRACE, 5,
            TEXT("CLine21DecDraw::DDrawARGBSurfaceInit(0x%lx, %s, %lu, %lu)"),
            lplpDDSFontCache, (TRUE == bUseSysMem) ? TEXT("T") : TEXT("F"),
            (TRUE == bTexture) ? TEXT("T") : TEXT("F"), cx, cy)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    // Just to be sure that the cached DDraw object is valid...
    if (NULL == m_pDDrawObjUnk)

    {
        DbgLog((LOG_TRACE, 1,
            TEXT("DDrawARGBSurfaceInit(): m_pDDrawObjUnk is not yet set. Skipping the rest."))) ;
        ASSERT(m_pDDrawObjUnk) ;
        return E_UNEXPECTED ;
    }

    DDSURFACEDESC2 ddsd ;
    HRESULT hRet ;

    *lplpDDSFontCache = NULL ;

    ZeroMemory(&ddsd, sizeof(ddsd)) ;
    ddsd.dwSize = sizeof(ddsd) ;

    LPBITMAPINFOHEADER lpbmih = (m_lpBMIOut ? LPBMIHEADER(m_lpBMIOut) : LPBMIHEADER(m_lpBMIIn)) ;

    // Set the DDPIXELFORMAT part
    ddsd.ddpfPixelFormat.dwSize = sizeof(DDPIXELFORMAT) ;
    ddsd.ddpfPixelFormat.dwFlags = DDPF_RGB ;

    if (bTexture  ||  !bUseSysMem)  // for VRAM surface
    {
        if (8 != lpbmih->biBitCount) {
            ddsd.ddpfPixelFormat.dwFlags |= DDPF_ALPHAPIXELS ;
        }
    }

    ddsd.ddpfPixelFormat.dwRGBBitCount = lpbmih->biBitCount ;
    if (8 == lpbmih->biBitCount) {

        if (bUseSysMem) {
            // scratch surface RGB32
            ddsd.ddpfPixelFormat.dwRGBBitCount = 32;
            ddsd.ddpfPixelFormat.dwRBitMask = 0x00FF0000 ;
            ddsd.ddpfPixelFormat.dwGBitMask = 0x0000FF00 ;
            ddsd.ddpfPixelFormat.dwBBitMask = 0x000000FF ;
            ddsd.ddpfPixelFormat.dwRGBAlphaBitMask = 0x00000000 ;  // to be sure
        }
        else {
            // VRAM surface -- AI44
            ddsd.ddpfPixelFormat.dwFourCC = '44IA';
        }
    }
    else if (16 == lpbmih->biBitCount)
    {
        if (bUseSysMem) // scratch surface -- RGB565
        {
            ddsd.ddpfPixelFormat.dwRBitMask = 0xF800 ;
            ddsd.ddpfPixelFormat.dwGBitMask = 0x07E0 ;
            ddsd.ddpfPixelFormat.dwBBitMask = 0x001F ;
            ddsd.ddpfPixelFormat.dwRGBAlphaBitMask = 0x0000 ;
        }
        else            // VRAM surface -- ARGB4444
        {
            ddsd.ddpfPixelFormat.dwRBitMask = 0x0F00 ;
            ddsd.ddpfPixelFormat.dwGBitMask = 0x00F0 ;
            ddsd.ddpfPixelFormat.dwBBitMask = 0x000F ;
            if (bTexture)
                ddsd.ddpfPixelFormat.dwRGBAlphaBitMask = 0xF000 ;
            else
                ddsd.ddpfPixelFormat.dwRGBAlphaBitMask = 0x0000 ;  // to be sure
        }
    }
    else
    {
        ddsd.ddpfPixelFormat.dwRBitMask = 0x00FF0000 ;
        ddsd.ddpfPixelFormat.dwGBitMask = 0x0000FF00 ;
        ddsd.ddpfPixelFormat.dwBBitMask = 0x000000FF ;
        if (bTexture)
            ddsd.ddpfPixelFormat.dwRGBAlphaBitMask = 0xFF000000 ;
        else
            ddsd.ddpfPixelFormat.dwRGBAlphaBitMask = 0x00000000 ;  // to be sure
    }

    // Create the Caps bits
    DWORD  dwCaps = 0 ;
    if (bUseSysMem)
    {
        dwCaps |= DDSCAPS_SYSTEMMEMORY ;
    }
    else
    {
        dwCaps |= DDSCAPS_VIDEOMEMORY ;
    }
    if (bTexture)
    {
        dwCaps |= DDSCAPS_TEXTURE ;
    }
    else
    {
        dwCaps |= DDSCAPS_OFFSCREENPLAIN ;
    }
    ddsd.ddsCaps.dwCaps = dwCaps ;

    // Now flags and other fields...
    ddsd.dwFlags = DDSD_WIDTH | DDSD_HEIGHT | DDSD_CAPS | DDSD_PIXELFORMAT ;
    ddsd.dwBackBufferCount = 0 ;

    if (bTexture)
    {
        for (ddsd.dwWidth  = 1 ; cx > ddsd.dwWidth  ; ddsd.dwWidth  <<= 1)
            ;
        for (ddsd.dwHeight = 1 ; cy > ddsd.dwHeight ; ddsd.dwHeight <<= 1)
            ;
    }
    else
    {
        ddsd.dwWidth  = cx ;
        ddsd.dwHeight = cy ;
    }

    // Create the surface with these settings
    LPDIRECTDRAW7  lpDDObj ;
    hRet = m_pDDrawObjUnk->QueryInterface(IID_IDirectDraw7, (LPVOID *) &lpDDObj) ;
    if (SUCCEEDED(hRet))
    {
        hRet = lpDDObj->CreateSurface(&ddsd, lplpDDSFontCache, NULL) ;
        lpDDObj->Release() ;  // done with the interface
    }

    return hRet ;
}


bool CLine21DecDraw::CharSizeFromOutputSize(LONG lOutWidth, LONG lOutHeight,
                                            int *piCharWidth, int *piCharHeight)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::CharSizeFromOutputSize(%ld, %ld, 0x%lx, 0x%lx)"),
            lOutWidth, lOutHeight, piCharWidth, piCharHeight)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    // We only care about the absolute value here
    lOutWidth  = ABS(lOutWidth) ;
    lOutHeight = ABS(lOutHeight) ;

    if ( IsTTFont() )  // TT font
    {
        if (! ISDWORDALIGNED(lOutWidth) )  // must have DWORD-aligned width
            return false ;

        *piCharWidth   = (int)(lOutWidth * (100 - m_iBorderPercent) / 100) ;  // 80-90% of width
        *piCharWidth  += MAX_CAPTION_COLUMNS / 2 + 1 ;  // max_col / 2 for rounding
        *piCharWidth  /= (MAX_CAPTION_COLUMNS + 2) ;    // space per column
        *piCharHeight  = (int)(lOutHeight * (100 - m_iBorderPercent) / 100) ; // 80-90% of width
        *piCharHeight += (MAX_CAPTION_ROWS / 2) ;       // max_row / 2 for rounding
        *piCharHeight /= MAX_CAPTION_ROWS ;             // space per row
        return true ;  // acceptable
    }
    else  // non-TT font (Terminal) -- only 320x240 or 640x480
    {
        if (640 == lOutWidth  &&  480 == lOutHeight)
        {
            *piCharWidth  = 16 ;
            *piCharHeight = 24 ;
            return true ;  // acceptable
        }
        else if (320 == lOutWidth  &&  240 == lOutHeight)
        {
            *piCharWidth  = 8 ;
            *piCharHeight = 12 ;
            return true ;  // acceptable
        }
        else
            return false ;  // can't handle size for non-TT font
    }
}


bool CLine21DecDraw::SetOutputSize(LONG lWidth, LONG lHeight)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::SetOutputSize(%ld, %ld)"), lWidth, lHeight)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    // If a output format is specified by downstream filter, use it; else use upstream's
    LPBITMAPINFOHEADER lpbmih = (m_lpBMIOut ? LPBMIHEADER(m_lpBMIOut) : LPBMIHEADER(m_lpBMIIn)) ;

    // Now we want to use the ABS()-ed values for calculating the char sizes
    lWidth  = ABS(lWidth) ;
    lHeight = ABS(lHeight) ;

    if (lpbmih)
    {
        // Check if current output bitmap size is the same or not.
        // This also includes height changing from +ve to -ve and vice-versa
        if (lWidth  == m_lWidth  &&
            lHeight == m_lHeight)
            return false ;    // same size; nothing changed

        // Store the width and height now so that we can compare any size
        // change and/or -ve/+ve height thing later.
        // m_lWidth  = lWidth ;
        // m_lHeight = lHeight ;
    }

    // Create new DIB section with new sizes (leaving borders)
    int   iCharWidth ;
    int   iCharHeight ;
    if (! CharSizeFromOutputSize(lWidth, lHeight, &iCharWidth, &iCharHeight) )
    {
        DbgLog((LOG_ERROR, 0, TEXT("ERROR: CharSizeFromOutputSize() failed for %ld x %ld output"),
                lWidth, lHeight)) ;
        ASSERT(!TEXT("CharSizeFromOutputSize() failed")) ;
        return false ;  // failure
    }

    // Store the image and char width and height now so that we can compare any
    // size change and/or -ve/+ve height thing later.
    m_lWidth      = lWidth ;
    m_lHeight     = lHeight ;
    m_iCharWidth  = iCharWidth ;
    m_iCharHeight = iCharHeight ;
    m_iScrollStep  = CalcScrollStepFromCharHeight() ;

    // Re-calculate the horizonal and vertical offsets too
    m_iHorzOffset = m_lWidth  * m_iBorderPercent / 200 ;
    m_iVertOffset = m_lHeight * m_iBorderPercent / 200 ;

    // The font caches need to be rebuilt for new sizes (and DDraw object/surface)
    SetFontUpdate(true) ;

    return true ;
}


HRESULT CLine21DecDraw::SetOutputOutFormat(LPBITMAPINFO lpbmi)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::SetOutputOutFormat(0x%lx)"), lpbmi)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    //
    // NULL param means output format not available from downstream filter
    //
    if (NULL == lpbmi)
    {
        if (m_lpBMIOut)
            delete m_lpBMIOut ;
        m_lpBMIOut = NULL ;
        m_uBMIOutSize = 0 ;

        // In this case, go back to the default output format specified by
        // upstream filter
        if (m_lpBMIIn)
        {
            SetOutputSize(m_lpBMIIn->bmiHeader.biWidth, m_lpBMIIn->bmiHeader.biHeight) ;
        }
        else
        {
            DbgLog((LOG_ERROR, 1, TEXT("How did we not have a default output format?"))) ;
        }
        return NOERROR ;
    }

    // Just paranoid...
    if (IsBadReadPtr(lpbmi, sizeof(BITMAPINFOHEADER)))
    {
        DbgLog((LOG_ERROR, 0, TEXT("Invalid output format (out) data pointer"))) ;
        return E_INVALIDARG ;
    }

    // Make sure we can handle this output size
    if (! IsSizeOK(&lpbmi->bmiHeader) )
        return E_INVALIDARG ;

    // The beginning of the VIDEOINFOHEADER struct and we don't want it
    UINT uSize = 0;
    switch (((LPBITMAPINFOHEADER)lpbmi)->biCompression) {
    case BI_RGB:
    case BI_BITFIELDS:
        uSize = GetBitmapFormatSize((LPBITMAPINFOHEADER) lpbmi) - SIZE_PREHEADER ;
        break;

    default: // AI44 case
        uSize = ((LPBITMAPINFOHEADER)lpbmi)->biSize;
        break;
    }

    if (NULL == m_lpBMIOut)  // If we didn't have one before then allocate space for one
    {
        m_lpBMIOut = (LPBITMAPINFO) new BYTE [uSize] ;
        if (NULL == m_lpBMIOut)
        {
            DbgLog((LOG_ERROR, 0, TEXT("Out of memory for output format info from downstream"))) ;
            return E_OUTOFMEMORY ;
        }
        m_uBMIOutSize = uSize ;  // new size
    }
    else  // we have an existing out format, but ...
    {
        // ... check if new data is bigger than the current space we have
        if (m_uBMIOutSize < uSize)
        {
            delete m_lpBMIOut ;
            m_lpBMIOut = (LPBITMAPINFO) new BYTE[uSize] ;
            if (NULL == m_lpBMIOut)
            {
                DbgLog((LOG_ERROR, 1, TEXT("Out of memory for out format BMI from downstream"))) ;
                m_uBMIOutSize = 0 ;
                return E_OUTOFMEMORY ;
            }
            m_uBMIOutSize = uSize ;
        }
    }

    // Make sure the output size specified by the format is such that
    // each scanline is DWORD aligned
    lpbmi->bmiHeader.biWidth = DWORDALIGN(lpbmi->bmiHeader.biWidth) ;
    lpbmi->bmiHeader.biSizeImage = DIBSIZE(lpbmi->bmiHeader) ;

    // Now copy the specified format data
    CopyMemory(m_lpBMIOut, lpbmi, uSize) ;

    // Check if the output size is changing and update all the related vars
    SetOutputSize(m_lpBMIOut->bmiHeader.biWidth, m_lpBMIOut->bmiHeader.biHeight) ;

    return NOERROR ;
}


HRESULT CLine21DecDraw::SetOutputInFormat(LPBITMAPINFO lpbmi)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::SetOutputInFormat(0x%lx)"), lpbmi)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    //
    // NULL param means no output format from upstream filter
    //
    if (NULL == lpbmi)
    {
#if 0
        if (m_lpBMIOut)
        {
            //
            // BTW this can happen when the graph is torn down at the end of
            // playback.  We can ignore this error in that case.
            //
            DbgLog((LOG_ERROR, 3, TEXT("Can't delete Output format from upstream w/o downstream specifying it"))) ;
            return E_INVALIDARG ;
        }
#endif // #if 0
        if (m_lpBMIIn)
            delete m_lpBMIIn ;
        m_lpBMIIn = NULL ;
        m_uBMIInSize = 0 ;

        //
        // Initialize the default output format from upstream filter
        //
        InitBMIData() ;

        // return NOERROR ;
    }
    else  // non-NULL format specified
    {
        // The beginning of the VIDEOINFOHEADER struct and we don't want it
        UINT uSize = GetBitmapFormatSize((LPBITMAPINFOHEADER) lpbmi) - SIZE_PREHEADER ;
        if (IsBadReadPtr(lpbmi, uSize))  // just paranoid...
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: Not enough output format (in) data pointer"))) ;
            ASSERT(FALSE) ;
            return E_INVALIDARG ;
        }

        // Make sure we can handle this output size
        if (! IsSizeOK(&lpbmi->bmiHeader) )
            return E_INVALIDARG ;

        if (NULL == m_lpBMIIn)  // If we didn't have one before then allocate space for one
        {
            m_lpBMIIn = (LPBITMAPINFO) new BYTE [uSize] ;
            if (NULL == m_lpBMIIn)
            {
                DbgLog((LOG_ERROR, 0, TEXT("Out of memory for output format info from upstream"))) ;
                return E_OUTOFMEMORY ;
            }
        }
        else  // we have an existing out format, but ...
        {
            // ... check if new data is bigger than the current space we have
            if (m_uBMIInSize < uSize)
            {
                delete m_lpBMIIn ;
                m_lpBMIIn = (LPBITMAPINFO) new BYTE[uSize] ;
                if (NULL == m_lpBMIIn)
                {
                    DbgLog((LOG_ERROR, 1, TEXT("Out of memory for out format BMI from upstream"))) ;
                    m_uBMIInSize = 0 ;
                    return E_OUTOFMEMORY ;
                }
                m_uBMIInSize = uSize ;
            }
        }

        // Make sure the output size specified by the format is such that
        // each scanline is DWORD aligned
        lpbmi->bmiHeader.biWidth = DWORDALIGN(lpbmi->bmiHeader.biWidth) ;
        lpbmi->bmiHeader.biSizeImage = DIBSIZE(lpbmi->bmiHeader) ;

        // Now copy the specified format data
        CopyMemory(m_lpBMIIn, lpbmi, uSize) ;
    }  // end of else of if (lpbmi)

    // If we don't have a output format specified by downstream then we'll
    // use this output format and resize the output accordingly
    if (NULL == m_lpBMIOut)
    {
        // Check if output size is changing and update all the related vars
        SetOutputSize(m_lpBMIIn->bmiHeader.biWidth, m_lpBMIIn->bmiHeader.biHeight) ;
    }

    return NOERROR ;
}


void CLine21DecDraw::FillOutputBuffer(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::FillOutputBuffer()"))) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    // First check if the output DDraw surface is valid (it's NOT valid during
    // start-up, when the style, service etc. get set).  We should skip the rest
    // of the code as it's not necessary at that stage anyway.
    if (NULL == m_lpDDSOutput)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Output DDraw surface is not valid. Skip it silently..."))) ;
        return ;
    }

    DDBLTFX ddFX ;
    ZeroMemory(&ddFX, sizeof(ddFX)) ;
    ddFX.dwSize = sizeof(ddFX) ;
    ddFX.dwFillColor =  0x00000000 ;

    HRESULT  hr = m_lpDDSOutput->Blt(NULL, NULL, NULL, DDBLT_COLORFILL, &ddFX) ;
    if (SUCCEEDED(hr))
    {
        m_bOutputClear = TRUE ;    // output buffer is totally clear
    }
    else
    {
        DbgLog((LOG_TRACE, 3, TEXT("WARNING: CC output clearing failed (Blt() Error 0x%lx)"), hr)) ;
    }
}


//
// This method is required only to generate the default format block in case
// the upstream filter doesn't specify FORMAT_VideoInfo type.
//
HRESULT CLine21DecDraw::GetDefaultFormatInfo(LPBITMAPINFO lpbmi, DWORD *pdwSize)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::GetDefaultFormatInfo(0x%lx, 0x%lx)"),
            lpbmi, pdwSize)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    if (NULL == pdwSize || IsBadWritePtr(pdwSize, sizeof(DWORD)))
    {
        return E_INVALIDARG ;
    }

    LPBITMAPINFO lpbmiCurr = (m_lpBMIOut ? m_lpBMIOut : m_lpBMIIn) ;
    UINT dwCurrSize = (m_lpBMIOut ? m_uBMIOutSize : m_uBMIInSize) ;
    ASSERT(dwCurrSize) ;  // just a check

    if (NULL == lpbmi)      // wants just the format data size
    {
        *pdwSize = dwCurrSize ;
        return NOERROR ;
    }

    if (IsBadWritePtr(lpbmi, *pdwSize))  // not enough space in out-param
        return E_INVALIDARG ;

    *pdwSize = min(*pdwSize, dwCurrSize) ;  // minm of actual and given
    CopyMemory(lpbmi, lpbmiCurr, *pdwSize) ;

    return NOERROR ;   // success
}


HRESULT CLine21DecDraw::GetOutputFormat(LPBITMAPINFOHEADER lpbmih)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::GetOutputFormat(0x%lx)"), lpbmih)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    if (IsBadWritePtr(lpbmih, sizeof(BITMAPINFOHEADER)))  // not enough space in out-param
        return E_INVALIDARG ;

    ZeroMemory(lpbmih, sizeof(BITMAPINFOHEADER)) ;  // just to keep it clear

    LPBITMAPINFOHEADER lpbmihCurr = (m_lpBMIOut ? LPBMIHEADER(m_lpBMIOut) : LPBMIHEADER(m_lpBMIIn)) ;
    if (NULL == lpbmihCurr)  // no output format specified by downstream
        return S_FALSE ;

    CopyMemory(lpbmih, lpbmihCurr, sizeof(BITMAPINFOHEADER)) ;

    return S_OK ;   // success
}


HRESULT CLine21DecDraw::GetOutputOutFormat(LPBITMAPINFOHEADER lpbmih)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::GetOutputOutFormat(0x%lx)"), lpbmih)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    if (IsBadWritePtr(lpbmih, sizeof(BITMAPINFOHEADER)))
    {
        DbgLog((LOG_ERROR, 0, TEXT("GetOutputOutFormat(): Bad in param"))) ;
        return E_INVALIDARG ;
    }
    if (m_lpBMIOut)
    {
        CopyMemory(lpbmih, m_lpBMIOut, sizeof(BITMAPINFOHEADER)) ;
        return S_OK ;
    }
    else
    {
        DbgLog((LOG_TRACE, 3, TEXT("GetOutputOutFormat(): No output format specified by downstream filter"))) ;
        return S_FALSE ;
    }
}


BOOL CLine21DecDraw::IsSizeOK(LPBITMAPINFOHEADER lpbmih)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::IsSizeOK(0x%lx)"), lpbmih)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    return ((IsTTFont() && ISDWORDALIGNED(lpbmih->biWidth))  ||  // TT font and DWORD-aligned width  or
            (!IsTTFont() &&                                      // non-TT font and ...
             ((320 == ABS(lpbmih->biWidth) && 240 == ABS(lpbmih->biHeight)) ||   // 320x240 output or
              (640 == ABS(lpbmih->biWidth) && 480 == ABS(lpbmih->biHeight))))) ; // 640x480 output
}


bool CLine21DecDraw::SetDDrawSurface(LPDIRECTDRAWSURFACE7 lpDDSurf)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::SetDDrawSurface(0x%lx)"), lpDDSurf)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    // The passed in DDraw surface pointer may be NULL when the pin connection
    // is broken.  In that case, we skip almost everything else.
    if (NULL == lpDDSurf)
    {
        // Save the new DDraw surface pointer
        m_bNewOutBuffer = m_lpDDSOutput != lpDDSurf ;  // has it changed?
        m_lpDDSOutput = NULL ;  // no DDraw surface to cache
        SetDDrawObject(NULL) ;  // ... and no DDraw object either

        return true ;  // it's OK
    }

    bool  bResult = true ;

    // First check if the DDraw objects are the same
    IUnknown  *pDDObj ;
    HRESULT hr = lpDDSurf->GetDDInterface((LPVOID*)&pDDObj) ;
    if (SUCCEEDED(hr)  &&  pDDObj)
    {
        // If the DDraw object changed (probably window shifted to different
        // monitor or display res changed etc), we need to re-do a whole
        // bunch of stuff now.
        if (GetDDrawObject()  &&
            IsEqualObject(pDDObj, GetDDrawObject()))
        {
            DbgLog((LOG_TRACE, 5, TEXT("Same DDraw object is being used."))) ;
        }
        else  // new DDraw object
        {
            DbgLog((LOG_TRACE, 3, TEXT("DDraw object has changed. Pass it down..."))) ;
            SetDDrawObject(pDDObj) ;

            // Need to re-init the font caches for the new DDraw object and surface
            SetFontUpdate(true) ;
        }

        // Now let go of all the interfaces
        pDDObj->Release() ;
    }

    // Save the new DDraw surface pointer
    m_bNewOutBuffer = m_lpDDSOutput != lpDDSurf ;  // has it changed?
    m_lpDDSOutput = lpDDSurf ;

    // In case the font cache needs to be updated, do it now.
    if (! IsFontReady() )
    {
        bResult = InitFont() ;
        ASSERT(bResult  &&  TEXT("SetDDrawSurface(): InitFont() failed.")) ;
    }

    return bResult ;
}


void CLine21DecDraw::ChangeFont(DWORD dwTextColor, BOOL bItalic, BOOL bUnderline)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::ChangeFont(%lu, %s, %s)"),
        dwTextColor, bItalic ? TEXT("T") : TEXT("F"), bUnderline ? TEXT("T") : TEXT("F"))) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    //
    // If the current font style & color and the new font style & color happen
    // to be the same, just ignore this one and return.
    //
    if (m_bFontItalic == bItalic  &&  m_bFontUnderline == bUnderline  &&
        m_dwTextColor == dwTextColor)
        return ;  // don't have to do anything at all

    //
    // For Italic chars we Blt the char rect from 2 pixels to the right,
    // but for normal chars we don't do that.
    //
    if (bItalic)
        m_iPixelOffset = 1 ;
    else
        m_iPixelOffset = 0 ;

    // Update the current font color and style info -- will revert on problem
    m_dwTextColor    = dwTextColor ;
    m_bFontItalic    = bItalic ;
    m_bFontUnderline = bUnderline ;

    //
    // If the text color is white and the font style is not underlined, we'll
    // just point to the normal or Italic font cache as appropriate.
    //
    if (!bUnderline  &&  AM_L21_FGCOLOR_WHITE == dwTextColor)
    {
        if (bItalic) // need Italic style
        {
            m_lpBltList = m_lpDDSItalicFontCache ;
        }
        else        // need normal style
        {
            m_lpBltList = m_lpDDSNormalFontCache ;
        }
        return ;
    }

    //
    // Looks like we need a non-white text color and/or underlined style.  For
    // that we have to create the special font cache and point to that.
    //
    if (m_lpDDSSpecialFontCache)
    {
        m_lpDDSSpecialFontCache->Release() ;
        m_lpDDSSpecialFontCache = NULL ;
    }
    DWORD  dwBGColor  = 0xFF000000 ; // m_dwBackground ;
    DWORD  dwOpacity = m_bOpaque ? OPAQUE : 0 ;
    bool   bResult = true ;
    if (NULL == m_lpDDSScratch)  // if no scratch surface, create it now
    {
        ASSERT(!TEXT("No scratch font cache!!")) ;
        bResult &= CreateScratchFontCache(&m_lpDDSScratch) ;
        ASSERT(bResult) ;
    }

    bResult &= CreateFontCache(&m_lpDDSSpecialFontCache, dwTextColor, dwBGColor,
                               dwOpacity, bItalic, bUnderline) ;
    if (bResult)
    {
        m_lpBltList = m_lpDDSSpecialFontCache ;
    }
    else  // if we can't create any special font, we fallback to normal white
    {
        DbgLog((LOG_TRACE, 1,
                TEXT("Failed creating special font (ColorId=%d, , , %s, %s). Using normal font."),
                dwTextColor, bItalic ? TEXT("I") : TEXT("non-I"),
                bUnderline ? TEXT("U") : TEXT("non-U"))) ;
        m_lpBltList = m_lpDDSNormalFontCache ;

        // Due to some problem, we are still using the white normal font
        m_dwTextColor    = AM_L21_FGCOLOR_WHITE ;
        m_bFontItalic    = FALSE ;
        m_bFontUnderline = FALSE ;
    }
}


void CLine21DecDraw::GetSrcNDestRects(int iLine, int iCol, UINT16 wChar,
                                      int iSrcCrop, int iDestOffset,
                                      RECT *prectSrc, RECT *prectDest)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::GetSrcNDestRects(%d,%d,,,,,)"),
            iLine, iCol)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    // if (m_bOpaque)  // opaque the next char's position
    {
        prectDest->left   = (iCol+1) * m_iCharWidth + m_iHorzOffset ;
        prectDest->right  = prectDest->left + m_iCharWidth ;
        // Row numbers are from 1 to 15.  The rect top should start from top of
        // a row's rect.  That's why we subtract 1 from the row number below.
        prectDest->top    = (iLine-1) * m_iCharHeight + m_iVertOffset + iDestOffset ; // fix dest top
        prectDest->bottom = prectDest->top + m_iCharHeight - ABS(iSrcCrop) ;      // fix dest size
    }

    MapCharToRect(wChar, prectSrc) ;

    // Adjust Src rect: +ve iSrcCrop => skip the top part; -ve iSrcCrop => skip the bottom
    if (iSrcCrop < 0)        // crop out bottom part of Src rect
    {
        prectSrc->bottom += iSrcCrop ;  // adding a -ve reduces the bottom
    }
    else  if (iSrcCrop > 0)  // crop out top part of Src rect
    {
        prectSrc->top += iSrcCrop ;     // adding a +ve skips the top
    }
    // Otherwise no rect adjustment is needed
}


void CLine21DecDraw::DrawLeadingTrailingSpace(int iLine, int iCol, int iSrcCrop, int iDestOffset)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::DrawLeadingTrailingSpace(%d, %d, %d, %d)"),
            iLine, iCol, iSrcCrop, iDestOffset)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    if (NULL == m_lpDDSOutput)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Output DDraw surface is not valid. Skip it silently..."))) ;
        return ;
    }

    if (! m_bOpaque )  // doesn't matter for transparent background
        return ;

    UINT16  wActual ;
    UINT16  wBGSpace = MAKECCCHAR(0, ' ') ;

    wActual = MAKECCCHAR(0, ' ') ;   // use space

    // Leading space is drawn using a blank space with normal style
    ChangeFont(AM_L21_FGCOLOR_WHITE, FALSE, FALSE) ;

    // Get appropriate source and destination rectangles
    RECT    RectSrc ;
    RECT    RectDest ;
    GetSrcNDestRects(iLine, iCol, wActual, iSrcCrop, iDestOffset, &RectSrc, &RectDest) ;

    // Now Blt the src rect to the dest rect for the required char
    HRESULT hr = m_lpDDSOutput->Blt(&RectDest, m_lpBltList, &RectSrc, DDBLT_WAIT, NULL) ;
    if (SUCCEEDED(hr))
    {
        m_bOutputClear   = FALSE ; // output buffer is cleared by ClearOutputBuffer()
    }
    else
    {
        DbgLog((LOG_TRACE, 3, TEXT("WARNING: CC lead/trail space output failed (Blt() Error 0x%lx)"), hr)) ;
    }

    // Now restore prev font (color, italics, underline)
    ChangeFont(m_ccLast.GetColor(), m_ccLast.IsItalicized(), m_ccLast.IsUnderLined()) ;
}


void CLine21DecDraw::WriteChar(int iLine, int iCol, CCaptionChar& cc, int iSrcCrop, int iDestOffset)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::WriteChar(%d, %d, char=0x%x, %d, %d)"),
            iLine, iCol, cc.GetChar(), iSrcCrop, iDestOffset)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    if (NULL == m_lpDDSOutput)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Output DDraw surface is not valid. Skip it silently..."))) ;
        return ;
    }

    UINT16  wActual ;
    UINT16  wBGSpace = MAKECCCHAR(0, ' ') ;
    UINT    uColor = cc.GetColor() ;
    UINT    uEffect = cc.GetEffect() ;

    // Do we need some status checks tp make sure that we should output CC chars?

    if (cc.IsMidRowCode())  // if it's a mid row code
        wActual = MAKECCCHAR(0, ' ') ;   // use space
    else                    // otherwise
        wActual = cc.GetChar() ; // use the char itself
    if (0 == wActual)   // this one is supposed to be skipped -- I am not sure
    {
        DbgLog((LOG_TRACE, 3, TEXT("Should we skip NULL char at (%d, %d)??"), iLine, iCol)) ;
        // return ;
    }

    // In case the color or style has changed, we have to change the pointer to
    // the font cache, and may have to even build a new one (for non-white colors)
    if (uColor != m_ccLast.GetColor()  ||  uEffect != m_ccLast.GetEffect())
        ChangeFont(uColor, cc.IsItalicized(), cc.IsUnderLined()) ;

    // Get appropriate source and destination rectangles
    RECT    RectSrc ;
    RECT    RectDest ;
    GetSrcNDestRects(iLine, iCol, wActual, iSrcCrop, iDestOffset, &RectSrc, &RectDest) ;

    // Now Blt the src rect to the dest rect for the required char
    HRESULT hr = m_lpDDSOutput->Blt(&RectDest, m_lpBltList, &RectSrc, DDBLT_WAIT, NULL) ;
    if (SUCCEEDED(hr))
    {
        if (0 != wActual)  // if this char is non-null
        {
            m_bOutputClear   = FALSE ; // output buffer is cleared by ClearOutputBuffer()
        }
    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: CC char output failed (Blt() Error 0x%lx)"), hr)) ;
    }

    m_ccLast = cc ;
}


void CLine21DecDraw::WriteBlankCharRepeat(int iLine, int iCol, int iRepeat,
                                          int iSrcCrop, int iDestOffset)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::WriteBlankCharRepeat(%d,%d,%d,%d,%d)"),
            iLine, iCol, iRepeat, iSrcCrop, iDestOffset)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    if (NULL == m_lpDDSOutput)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Output DDraw surface is not valid. Skip it silently..."))) ;
        return ;
    }

    if (! m_bOpaque )  // doesn't matter for transparent background
        return ;

    UINT16  wActual = MAKECCCHAR(0, ' ') ;   // use space;
    // UINT16  wBGSpace = MAKECCCHAR(0, ' ') ;

    // Leading space is drawn using a blank space with normal style
    // ChangeFont(AM_L21_FGCOLOR_WHITE, FALSE, FALSE) ;

    // Get appropriate source and destination rectangles
    RECT    RectSrc ;
    RECT    RectDest ;
    GetSrcNDestRects(iLine, iCol, wActual, iSrcCrop, iDestOffset, &RectSrc, &RectDest) ;
    RectDest.right = RectDest.left + m_iCharWidth * iRepeat ; // stretch Dest rect

    // Now Blt the src rect to the dest rect for the required char
    HRESULT  hr ;
    hr = m_lpDDSOutput->Blt(&RectDest, m_lpBltList, &RectSrc, DDBLT_WAIT, NULL) ;
    if (SUCCEEDED(hr))
    {
        m_bOutputClear = FALSE ; // output buffer is cleared by ClearOutputBuffer()
    }
    else
    {
        DbgLog((LOG_TRACE, 3, TEXT("WARNING: CC line filler output failed (Blt() Error 0x%lx)"), hr)) ;
        // ASSERT(SUCCEEDED(hr)) ;
    }

    // Now restore prev font (color, italics, underline)
    // ChangeFont(m_ccLast.GetColor(), m_ccLast.IsItalicized(), m_ccLast.IsUnderLined()) ;
}


// Special Chars like TM, R, musical note etc. etc.
// 0x00ae,    0x00b0,    0x00bd,    0x00bf,    0x2122,    0x00a2,    0x00a3,    0x266b,
//    30h,       31h,       32h,       33h,       34h,       35h,       36h,       37h,
// 0x00e0,    0x0000,    0x00e8,    0x00e2,    0x00ea,    0x00ee,    0x00f4,    0x00fb
//    38h,       39h,       3Ah,       3Bh,       3Ch,       3Dh,       3Eh,       3Fh

void CLine21DecDraw::MapCharToRect(UINT16 wChar, RECT *pRect)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::MapCharToRect(%d, %lx)"), (int)wChar, pRect)) ;

    int  iLine ;
    int  iCol ;
    int  iIndex = 0 ;

    if (wChar >= MAKECCCHAR(0, 0x20)  &&  wChar <= MAKECCCHAR(0, 0x29))
    {
        iIndex = (BYTE)wChar - 0x20 ;
    }
    else if (wChar >= MAKECCCHAR(0, 0x2B)  &&  wChar <= MAKECCCHAR(0, 0x5B))
    {
        iIndex = (BYTE)wChar - 0x20 ;
    }
    else if (wChar == MAKECCCHAR(0, 0x5D))  // ']' char (standing alone!!)
    {
        iIndex = (BYTE)wChar - 0x20 ;
    }
    else if (wChar >= MAKECCCHAR(0, 0x61)  &&  wChar <= MAKECCCHAR(0, 0x7A))
    {
        iIndex = (BYTE)wChar - 0x20 ;
    }
    else  // special chars that have random values
    {
        switch (wChar)
        {
        case 0x00e1:  // m_lpwCharSet[ 10]: 'a' with acute accent
            iIndex = 10 ;
            break ;

        case 0x00e9:  // m_lpwCharSet[ 60]: 'e' with acute accent
            iIndex = 60 ;
            break ;

        case 0x00ed:  // m_lpwCharSet[ 62]: 'i' with an acute accent
            iIndex = 62 ;
            break ;

        case 0x00f3:  // m_lpwCharSet[ 63]: 'o' with an acute accent
            iIndex = 63 ;
            break ;

        case 0x00fa:  // m_lpwCharSet[ 64]: 'u' with an acute accent
            iIndex = 64 ;
            break ;

        case 0x00e7:  // m_lpwCharSet[ 91]: 'c' with cedilla
            iIndex = 91 ;
            break ;

        case 0x00f7:  // m_lpwCharSet[ 92]: division sign
            iIndex = 92 ;
            break ;

        case 0x00d1:  // m_lpwCharSet[ 93]: 'N' with tilde
            iIndex = 93 ;
            break ;

        case 0x00f1:  // m_lpwCharSet[ 94]: 'n' with tilde
            iIndex = 94 ;
            break ;

        case 0x2588:  // m_lpwCharSet[ 95]: solid block
            iIndex = 95 ;
            break ;

        case 0x00ae:  // m_lpwCharSet[ 96]: 30h -- registered mark symbol
            iIndex = 96 ;
            break ;

        case 0x00b0:  // m_lpwCharSet[ 97]: 31h -- degree sign
            iIndex = 97 ;
            break ;

        case 0x00bd:  // m_lpwCharSet[ 98]: 32h -- '1/2'
            iIndex = 98 ;
            break ;

        case 0x00bf:  // m_lpwCharSet[ 99]: 33h -- inverse query
            iIndex = 99 ;
            break ;

        case 0x2122:  // m_lpwCharSet[100]: 34h -- trademark symbol
            iIndex = 100 ;
            break ;

        case 0x00a2:  // m_lpwCharSet[101]: 35h -- cents sign
            iIndex = 101 ;
            break ;

        case 0x00a3:  // m_lpwCharSet[102]: 36h -- Pounds Sterling sign
            iIndex = 102 ;
            break ;

        case 0x266b:  // m_lpwCharSet[103]: 37h -- music note
            iIndex = 103 ;
            break ;

        case 0x00e0:  // m_lpwCharSet[104]: 38h -- 'a' with grave accent
            iIndex = 104 ;
            break ;

        case 0x0000:  // m_lpwCharSet[105]: 39h -- transparent space
            iIndex = 105 ;
            break ;

        case 0x00e8:  // m_lpwCharSet[106]: 3ah -- 'e' with grave accent
            iIndex = 106 ;
            break ;

        case 0x00e2:  // m_lpwCharSet[107]: 3bh -- 'a' with circumflex
            iIndex = 107 ;
            break ;

        case 0x00ea:  // m_lpwCharSet[108]: 3ch -- 'e' with circumflex
            iIndex = 108 ;
            break ;

        case 0x00ee:  // m_lpwCharSet[109]: 3dh -- 'i' with circumflex
            iIndex = 109 ;
            break ;

        case 0x00f4:  // m_lpwCharSet[110]: 3eh -- 'o' with circumflex
            iIndex = 110 ;
            break ;

        case 0x00fb:  // m_lpwCharSet[111]: 3fh -- 'u' with circumflex
            iIndex = 111 ;
            break ;

        default:
            iIndex = 0 ;
            DbgLog((LOG_TRACE, 1, TEXT("WARNING: Unknown char (%d) received and ignored"), (int)wChar)) ;
            break ;
        }  // end of switch (wChar)
    }  // end of else of if (wChar...)

    // Now convert iIndex to (iLine, iCol) pair
    iLine = iIndex / FONTCACHELINELENGTH ;  // line of cache based on array index
    iCol  = iIndex % FONTCACHELINELENGTH ;  // actual col of a particular line of cache

    // Create source rect based on line and col values
    // HACK: There is a little bit of hack to work around the over/underhang
    // problem we were having for the Italic chars -- we skip one column of
    // pixels from the left (based on our observation) to avoid the overhang
    // occurance.
    pRect->left   = iCol * (m_iCharWidth + INTERCHAR_SPACE) + m_iPixelOffset ;
    pRect->top    = iLine * m_iCharHeight ;
    pRect->right  = pRect->left + m_iCharWidth ;
    pRect->bottom = pRect->top + m_iCharHeight ;
}


void CLine21DecDraw::GetOutputLines(int iDestLine, RECT *prectLine)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecDraw::GetOutputLines(%d, 0x%lx)"), iDestLine, prectLine)) ;
    CAutoLock  Lock(&m_csL21DDraw) ;

    if (IsBadWritePtr(prectLine, sizeof(*prectLine)))
    {
        DbgLog((LOG_ERROR, 0, TEXT("ERROR: prectOut is a bad pointer!!!"))) ;
        return ;
    }

    SetRect(prectLine, 0 /* m_iHorzOffset */, 0,   // to stop BPC's CC wobbling
        m_iHorzOffset + m_iCharWidth * (MAX_CAPTION_COLUMNS+2), 0) ;

    // Output is inverted in Windows bitmap sense
    int  iLineStart ;
    iLineStart = (iDestLine - 1) * m_iCharHeight + m_iVertOffset ;
    prectLine->top    = iLineStart ;
    prectLine->bottom = iLineStart + m_iCharHeight ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\lin21dec2\l21ddraw.h ===
// Copyright (c) 2000  Microsoft Corporation.  All Rights Reserved.
//
//  L21DDraw.h: Line 21 Decoder drawing-related base class code
//

#ifndef _INC_L21DDRAW_H
#define _INC_L21DDRAW_H


//
// We start with 16x24 pixel chars by default
//
#ifndef __DEFAULTCHARSIZE_DEFINED
#define __DEFAULTCHARSIZE_DEFINED
#define DEFAULT_CHAR_WIDTH    16
#define DEFAULT_CHAR_HEIGHT   24
#endif // __DEFAULTCHARSIZE_DEFINED

//
// Font cache holds 3 lines of 40 chars per line (total 120 chars, using 112)
//
#ifndef __FONTCACHE_DEFINED
#define __FONTCACHE_DEFINED
#define FONTCACHELINELENGTH  40
#define FONTCACHENUMLINES     3
#endif // __FONTCACHE_DEFINED


//
// We use a 4 pixel inter-char space to avoid getting into the over/underhang
// problems with Italic chars
//
#ifndef __INTERCHAR_SPACE
#define __INTERCHAR_SPACE
#define INTERCHAR_SPACE   4
#endif // __INTERCHAR_SPACE

//
// A 2 pixel extra inter-char space is used to avoid getting into the over/underhang
// problems with Italic chars
//
#ifndef __INTERCHAR_SPACE_EXTRA
#define __INTERCHAR_SPACE_EXTRA
#define INTERCHAR_SPACE_EXTRA   2
#endif // __INTERCHAR_SPACE_EXTRA


//
//  CLine21DecDraw: class for drawing details to output caption text to bitmap
//
class CLine21DecDraw {
public:
    CLine21DecDraw(void) ;
    ~CLine21DecDraw(void) ;
    bool InitFont(void) ;
    void InitColorNLastChar(void) ;
    void InitCharSet(void) ;
    void MapCharToRect(UINT16 wChar, RECT *pRect) ;
    // LPDIRECTDRAWSURFACE7 GetDDrawSurface(void)  { return m_lpDDSOutput ; } ;
    bool SetDDrawSurface(LPDIRECTDRAWSURFACE7 lpDDS) ;
    IUnknown* GetDDrawObject(void)  { return m_pDDrawObjUnk ; } ;
    inline void SetDDrawObject(IUnknown *pDDrawObjUnk)    { m_pDDrawObjUnk = pDDrawObjUnk ; } ;
    void FillOutputBuffer(void) ;
    HRESULT GetDefaultFormatInfo(LPBITMAPINFO lpbmi, DWORD *pdwSize) ;
    HRESULT GetOutputFormat(LPBITMAPINFOHEADER lpbmih) ;
    HRESULT GetOutputOutFormat(LPBITMAPINFOHEADER lpbmih) ;
    HRESULT SetOutputOutFormat(LPBITMAPINFO lpbmi) ;
    HRESULT SetOutputInFormat(LPBITMAPINFO lpbmi) ;
    inline void GetBackgroundColor(DWORD *pdwBGColor) { *pdwBGColor = m_dwBackground ; } ;
    BOOL SetBackgroundColor(DWORD dwBGColor) ;
    inline BOOL GetBackgroundOpaque(void)         { return m_bOpaque ; } ;
    inline void SetBackgroundOpaque(BOOL bOpaque) { m_bOpaque = bOpaque ; } ;

    inline UINT GetCharHeight(void)  { return m_iCharHeight ; } ;
    inline int  GetScrollStep(void)  { return m_iScrollStep ; } ;
    void DrawLeadingTrailingSpace(int iLine, int iCol, int iSrcCrop, int iDestOffset) ;
    void WriteChar(int iLine, int iCol, CCaptionChar& cc, int iSrcCrop, int iDestOffset) ;
    void WriteBlankCharRepeat(int iLine, int iCol, int iRepeat, int iSrcCrop,
                              int iDestOffset) ;
    inline BOOL IsNewOutBuffer(void)   { return m_bNewOutBuffer ; } ;
    inline void SetNewOutBuffer(BOOL bState)  { m_bNewOutBuffer = bState ; }
    inline BOOL IsOutDIBClear(void)  { return m_bOutputClear ; } ;
    BOOL IsSizeOK(LPBITMAPINFOHEADER lpbmih) ;
    void GetOutputLines(int iDestLine, RECT *prectLine) ;
    inline BOOL IsTTFont(void)  { return m_bUseTTFont ; } ;

private:   // private methods
    bool CreateScratchFontCache(LPDIRECTDRAWSURFACE7* lplpDDSFontCache) ;
    bool CreateFontCache(LPDIRECTDRAWSURFACE7 *lplpDDSFontCache,
                         DWORD dwTextColor, DWORD dwBGColor, DWORD dwOpacity,
                         BOOL bItalic, BOOL bUnderline) ;
    HFONT CreateCCFont(int iFontWidth, int iFontHeight, BOOL bItalic, BOOL bUnderline) ;
    HRESULT DDrawARGBSurfaceInit(LPDIRECTDRAWSURFACE7* lplpDDSFontCache,
                                 BOOL bUseSysMem, BOOL bTexture, DWORD cx, DWORD cy) ;

private:   // private data
    CCritSec        m_csL21DDraw ;    // to serialize actions on this class

    UINT16          m_lpwCharSet[121] ; // 120(+1) spaces for 112 chars of CC-ing

    LPBITMAPINFO    m_lpBMIOut ;      // BITMAPINFO for output from downstream filter
    LPBITMAPINFO    m_lpBMIIn ;       // BITMAPINFO for output from upstream filter
    UINT            m_uBMIOutSize ;   // bytes for BMI data from downstream
    UINT            m_uBMIInSize ;    // bytes for BMI data from upstream
    LONG            m_lWidth ;        // currently set output width
    LONG            m_lHeight ;       // currently set output height
    int             m_iBorderPercent ;// current border percent (10 or 20)
    int             m_iHorzOffset ;   // horizontal offset of CC area
    int             m_iVertOffset ;   // vertical offset of CC area
    BOOL            m_bOpaque ;       // should caption background be opaque?

    BOOL            m_bOutputClear ;  // is output buffer clear?
    BOOL            m_bNewOutBuffer ; // has output buffer changed?

    LOGFONT         m_lfChar ;        // LOGFONT struct for quick font create
    BOOL            m_bUseTTFont ;    // are TT fonts available?

    int             m_iCharWidth ;    // width of each caption char in pixels
    int             m_iCharHeight ;   // height of each caption char in pixels
    int             m_iScrollStep ;   // # scanlines to scroll by in each step
    int             m_iPixelOffset ;  // pixel offset within a char rect (Italics vs. not)

    CCaptionChar    m_ccLast ;        // last caption char and attribs printed
    COLORREF        m_acrFGColors[7] ;// 7 colors from white to magenta
    BYTE            m_idxFGColors[7] ;// same 7 colors but in palette index form
    UINT            m_uColorIndex ;   // index of currently used color
    DWORD           m_dwBackground ;  // background color with alpha bits
    DWORD           m_dwTextColor ;   // last used CC text color
    BOOL            m_bFontItalic ;   // is Italic font being used?
    BOOL            m_bFontUnderline ; // is Italic font being used?

    //
    //  Details to work with the new VMR
    //
    IUnknown       *m_pDDrawObjUnk ;   // pointer to DDraw object for DDraw surface
    LPDIRECTDRAWSURFACE7 m_lpDDSOutput ;  // current out buffer/surface pointer
    LPDIRECTDRAWSURFACE7 m_lpDDSNormalFontCache ;  // normal font cache -- indicates caching status too
    LPDIRECTDRAWSURFACE7 m_lpDDSItalicFontCache ;  // Italic font cache
    LPDIRECTDRAWSURFACE7 m_lpDDSSpecialFontCache ; // other special (U, I+U, colored) font cache
    LPDIRECTDRAWSURFACE7 m_lpDDSScratch ; // a scratch font cache in system memory
    LPDIRECTDRAWSURFACE7 m_lpBltList ; // current list to Blt() from
    bool            m_bUpdateFontCache ; // font cache re-build flag

#ifdef PERF
    int             m_idClearOutBuff ;
#endif // PERF

private:   // private helper methods
    bool InitBMIData(void) ;
    static int CALLBACK EnumFontProc(ENUMLOGFONTEX *lpELFE, NEWTEXTMETRIC *lpNTM,
                                     int iFontType, LPARAM lParam) ;
    void CheckTTFont(void) ;
    void ChangeFont(DWORD dwTextColor, BOOL bItalic, BOOL bUnderline) ;
    void SetFontCacheAlpha(LPDIRECTDRAWSURFACE7 lpDDSFontCacheSrc, LPDIRECTDRAWSURFACE7 lpDDSFontCacheDest, BYTE bClr) ;
    int CalcScrollStepFromCharHeight(void) {
        // We need to scroll the CC by as many lines at a time as necessary to
        // complete scrolling within 12 steps max, approx. 0.4 seconds which is
        // the EIA-608 standard requirement.
#define MAX_SCROLL_STEP  12
        return (int)((m_iCharHeight + MAX_SCROLL_STEP - 1) / MAX_SCROLL_STEP) ;
    }
    void GetSrcNDestRects(int iLine, int iCol, UINT16 wChar, int iSrcCrop,
                          int iDestOffset, RECT *prectSrc, RECT *prectDest) ;
    bool CharSizeFromOutputSize(LONG lOutWidth, LONG lOutHeight,
                                int *piCharWidth, int *piCharHeight) ;
    bool SetOutputSize(LONG lWidth, LONG lHeight) ;
    void SetFontUpdate(bool bState)  { m_bUpdateFontCache = bState ; }
    bool IsFontReady(void) { return !m_bUpdateFontCache ; }
    DWORD GetAlphaFromBGColor(int iBitDepth) ;
    DWORD GetColorBitsFromBGColor(int iBitDepth) ;
} ;

#endif _INC_L21DDRAW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\lin21dec2\l21dfilt.cpp ===
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.

//
// DirectShow Line 21 Decoder Filter 2: Filter Interface
//

#include <streams.h>
#include <windowsx.h>

#ifdef FILTER_DLL
#include <initguid.h>
#endif /* FILTER_DLL */

#include <IL21Dec.h>
#include "L21DBase.h"
#include "L21DDraw.h"
#include "L21Decod.h"
#include "L21DFilt.h"


//
//  Setup Data
//
/* const */ AMOVIESETUP_MEDIATYPE sudLine21Dec2InType  =
{
    &MEDIATYPE_AUXLine21Data,       // MajorType
    &MEDIASUBTYPE_NULL              // MinorType
} ;

/* const */ AMOVIESETUP_MEDIATYPE sudLine21Dec2OutType =
{
    &MEDIATYPE_Video,               // MajorType
    &MEDIASUBTYPE_NULL              // MinorType
} ;

/* const */ AMOVIESETUP_PIN psudLine21Dec2Pins[] =
{
    { L"Input",                // strName
        FALSE,                   // bRendered
        FALSE,                   // bOutput
        FALSE,                   // bZero
        FALSE,                   // bMany
        &CLSID_NULL,             // clsConnectsToFilter
        L"Output",               // strConnectsToPin
        1,                       // nTypes
        &sudLine21Dec2InType     // lpTypes
    },
    { L"Output",               // strName
        FALSE,                   // bRendered
        TRUE,                    // bOutput
        FALSE,                   // bZero
        FALSE,                   // bMany
        &CLSID_NULL,             // clsConnectsToFilter
        L"Input",                // strConnectsToPin
        1,                       // nTypes
        &sudLine21Dec2OutType    // lpTypes
    }
} ;

const AMOVIESETUP_FILTER sudLine21Dec2 =
{
    &CLSID_Line21Decoder2,        // clsID
    L"Line 21 Decoder 2",         // strName
    MERIT_NORMAL + 2,             // dwMerit
    2,                            // nPins
    psudLine21Dec2Pins,           // lpPin
} ;

//  Nothing to say about the output pin

#ifdef FILTER_DLL

// list of class ids and creator functions for class factory
CFactoryTemplate g_Templates[] =
{
    {   L"Line 21 Decoder 2",
        &CLSID_Line21Decoder2,
        CLine21DecFilter2::CreateInstance,
        NULL,
        &sudLine21Dec2
    }
} ;

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

//
//  Exported entry points for registration and unregistration (in this case
//  they only call through to default implmentations).
//
HRESULT DllRegisterServer()
{
    return AMovieDllRegisterServer2(TRUE) ;
}

HRESULT DllUnregisterServer()
{
    return AMovieDllRegisterServer2(FALSE) ;
}

#endif // FILTER_DLL



#ifndef UNALIGNED
#define UNALIGNED   // __unaligned
#endif // UNALIGNED


//
//  CLine21DecFilter2 class implementation
//

#pragma warning(disable:4355)

//
//  Constructor
//
CLine21DecFilter2::CLine21DecFilter2(TCHAR *pName, LPUNKNOWN pUnk, HRESULT *phr)
: CTransformFilter(pName, pUnk, CLSID_Line21Decoder2),

m_L21Dec(),
m_eSubTypeIDIn(AM_L21_CCSUBTYPEID_Invalid),
m_eGOP_CCType(GOP_CCTYPE_Unknown),
m_rtTimePerInSample(166833),   // 333667),
m_rtTimePerOutSample(333667),
m_rtStart((LONGLONG) 0),
m_rtStop((LONGLONG) 0),
m_bNoTimeStamp(TRUE),
m_rtLastOutStop((LONGLONG) 0),
m_llMediaStart((LONGLONG) 0),
m_llMediaStop((LONGLONG) 0),
m_pviDefFmt(NULL),
m_dwDefFmtSize(0),
m_bMustOutput(TRUE),
m_bDiscontLast(FALSE),
m_bEndOfStream(FALSE),   // not true until EoS() is called
m_pPinDown(NULL),
m_bBlendingState(TRUE),  // we set it to FALSE in Pause()
m_OutputThread(this),
m_InSampleQueue()
{
    CAutoLock   Lock(&m_csFilter) ;

    DbgLog((LOG_TRACE, 3,
        TEXT("CLine21DecFilter2::CLine21DecFilter2() -- Instantiating Line 21 Decoder 2 filter"))) ;

    ASSERT(pName) ;
    ASSERT(phr) ;

#ifdef PERF
#pragma message("Building for PERF measurements")
    m_idDelvWait  = MSR_REGISTER(TEXT("L21D2Perf - Wait on Deliver")) ;
#endif // PERF
}


//
//  Destructor
//
CLine21DecFilter2::~CLine21DecFilter2()
{
    CAutoLock   Lock(&m_csFilter) ;

    DbgLog((LOG_TRACE, 3,
        TEXT("CLine21DecFilter2::~CLine21DecFilter2() -- Destructing Line 21 Decoder 2 filter"))) ;

    // In case the downstream pin interface wasn't released...
    if (m_pPinDown)
    {
        m_pPinDown->Release() ;
        m_pPinDown = NULL ;
    }

    // Release all the buffers allocated
    if (m_pviDefFmt)
    {
        delete m_pviDefFmt ;
        m_pviDefFmt = NULL ;
    }

    // Make sure we are not holding onto any DDraw surfaces (should be
    // released during disconnect)
    DbgLog((LOG_TRACE, 5, TEXT("* Destroying the Line 21 Decoder 2 filter *"))) ;
}


//
//  NonDelegatingQueryInterface
//
STDMETHODIMP CLine21DecFilter2::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    if (ppv)
        *ppv = NULL ;

    DbgLog((LOG_TRACE, 6, TEXT("Lin21DecFilter2: Somebody's querying my interface"))) ;
    if (IID_IAMLine21Decoder == riid)
    {
        return GetInterface((IAMLine21Decoder *) this, ppv) ;
    }
    return CTransformFilter::NonDelegatingQueryInterface(riid, ppv) ;
}


//
//  CreateInstance: Goes in the factory template table to create new instances
//
CUnknown * CLine21DecFilter2::CreateInstance(LPUNKNOWN pUnk, HRESULT * phr)
{
    return new CLine21DecFilter2(TEXT("Line 21 Decoder 2 filter"), pUnk, phr) ;
}


STDMETHODIMP CLine21DecFilter2::GetDecoderLevel(AM_LINE21_CCLEVEL *lpLevel)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::GetDecoderLevel(0x%lx)"), lpLevel)) ;
    // CAutoLock   Lock(&m_csFilter) ;

    if (IsBadWritePtr(lpLevel, sizeof(AM_LINE21_CCLEVEL)))
        return E_INVALIDARG ;

    *lpLevel = m_L21Dec.GetDecoderLevel() ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter2::GetCurrentService(AM_LINE21_CCSERVICE *lpService)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::GetCurrentService(0x%lx)"), lpService)) ;
    // CAutoLock   Lock(&m_csFilter) ;

    if (IsBadWritePtr(lpService, sizeof(AM_LINE21_CCSERVICE)))
        return E_INVALIDARG ;

    *lpService = m_L21Dec.GetCurrentService() ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter2::SetCurrentService(AM_LINE21_CCSERVICE Service)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::SetCurrentService(%lu)"), Service)) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (Service < AM_L21_CCSERVICE_None || Service > AM_L21_CCSERVICE_XDS)
        return E_INVALIDARG ;

    if (Service >= AM_L21_CCSERVICE_Text1)  // we don't have support for Text1/2 or XDS now.
        return E_NOTIMPL ;

    if (m_L21Dec.SetCurrentService(Service))  // if we must refresh output
    {
        m_bMustOutput = TRUE ;                // then flag it here.
    }

    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter2::GetServiceState(AM_LINE21_CCSTATE *lpState)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::GetServiceState(0x%lx)"), lpState)) ;
    // CAutoLock   Lock(&m_csFilter) ;

    if (IsBadWritePtr(lpState, sizeof(AM_LINE21_CCSTATE)))
        return E_INVALIDARG ;

    *lpState = m_L21Dec.GetServiceState() ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter2::SetServiceState(AM_LINE21_CCSTATE State)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::SetServiceState(%lu)"), State)) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (State < AM_L21_CCSTATE_Off || State > AM_L21_CCSTATE_On)
        return E_INVALIDARG ;

    if (m_L21Dec.SetServiceState(State))   // if we must refresh output
    {
        m_bMustOutput = TRUE ;             // then flag it here.
    }

    return NOERROR ;
}



STDMETHODIMP CLine21DecFilter2::GetOutputFormat(LPBITMAPINFOHEADER lpbmih)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::GetOutputFormat(0x%lx)"), lpbmih)) ;
    // CAutoLock   Lock(&m_csFilter) ;
    return m_L21Dec.GetOutputFormat(lpbmih) ;
}



STDMETHODIMP CLine21DecFilter2::SetOutputFormat(LPBITMAPINFO lpbmi)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::SetOutputFormat(0x%lx)"), lpbmi)) ;
    // CAutoLock   Lock(&m_csFilter) ;

    return E_NOTIMPL ;  // for now, until we do it properly
}

STDMETHODIMP CLine21DecFilter2::GetBackgroundColor(DWORD *pdwPhysColor)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::GetBackgroundColor(0x%lx)"), pdwPhysColor)) ;
    // CAutoLock   Lock(&m_csFilter) ;

    if (IsBadWritePtr(pdwPhysColor, sizeof(DWORD)))
        return E_INVALIDARG ;

    m_L21Dec.GetBackgroundColor(pdwPhysColor) ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter2::SetBackgroundColor(DWORD dwPhysColor)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::SetBackgroundColor(0x%lx)"), dwPhysColor)) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (m_L21Dec.SetBackgroundColor(dwPhysColor))  // color key has really changed
    {
        // refill the output buffer only if we are not in stopped state
        if (State_Stopped != m_State)
            m_L21Dec.FillOutputBuffer() ;
    }

    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter2::GetRedrawAlways(LPBOOL lpbOption)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::GetRedrawAlways(0x%lx)"), lpbOption)) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (IsBadWritePtr(lpbOption, sizeof(BOOL)))
        return E_INVALIDARG ;
    *lpbOption = m_L21Dec.GetRedrawAlways() ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter2::SetRedrawAlways(BOOL bOption)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::SetRedrawAlways(%lu)"), bOption)) ;
    CAutoLock   Lock(&m_csFilter) ;

    m_L21Dec.SetRedrawAlways(bOption) ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter2::GetDrawBackgroundMode(AM_LINE21_DRAWBGMODE *lpMode)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::GetDrawBackgroundMode(0x%lx)"), lpMode)) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (IsBadWritePtr(lpMode, sizeof(AM_LINE21_DRAWBGMODE)))
        return E_INVALIDARG ;

    *lpMode = m_L21Dec.GetDrawBackgroundMode() ;
    return NOERROR ;
}

STDMETHODIMP CLine21DecFilter2::SetDrawBackgroundMode(AM_LINE21_DRAWBGMODE Mode)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::SetDrawBackgroundMode(%lu)"), Mode)) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (Mode < AM_L21_DRAWBGMODE_Opaque  || Mode > AM_L21_DRAWBGMODE_Transparent)
        return E_INVALIDARG ;
    m_L21Dec.SetDrawBackgroundMode(Mode) ;
    return NOERROR ;
}


//
//  VerifyGOPUDPacketData: Private helper method to verify GOP user data
//                         packet integrity.
//
BOOL CLine21DecFilter2::VerifyGOPUDPacketData(PAM_L21_GOPUD_PACKET pGOPUDPacket)
{
    return (AM_L21_GOPUD_HDR_STARTCODE == GETGOPUD_L21STARTCODE(pGOPUDPacket->Header) &&  // valid start code
        AM_L21_GOPUD_HDR_INDICATOR == GETGOPUD_L21INDICATOR(pGOPUDPacket->Header) &&  // Line21 indicator
        AM_L21_GOPUD_HDR_RESERVED  == GETGOPUD_L21RESERVED(pGOPUDPacket->Header)  &&  // reserved bits
        GETGOPUD_NUMELEMENTS(pGOPUDPacket) > 0) ;                                     // +ve # elements
}


//
//  VerifyATSCUDPacketData: Private helper method to verify ATSC user data
//                          packet integrity.
//
BOOL CLine21DecFilter2::VerifyATSCUDPacketData(PAM_L21_ATSCUD_PACKET pATSCUDPacket)
{
    if (AM_L21_ATSCUD_HDR_STARTCODE  != GETATSCUD_STARTCODE(pATSCUDPacket->Header) ||  // invalid start code
        AM_L21_ATSCUD_HDR_IDENTIFIER != GETATSCUD_IDENTIFIER(pATSCUDPacket->Header))   // not ATSC Identifier
        return FALSE ;

    if (! ISATSCUD_TYPE_EIA(pATSCUDPacket) )   // not EIA-type CC
        return FALSE ;

    // Either EM or valid CC data is acceptable
    return (ISATSCUD_EM_DATA(pATSCUDPacket) ||             // EM data type  OR
            (ISATSCUD_CC_DATA(pATSCUDPacket)  &&           // CC data type  AND
             GETATSCUD_NUMELEMENTS(pATSCUDPacket) > 0)) ;  // +ve # CC elements
}


//
//  IsFillerPacket: Private helper method to check if the packet (at least header)
//                  contains only 0 bytes, which means it's a filler.
//
BOOL CLine21DecFilter2::IsFillerPacket(BYTE *pGOPPacket)
{
    DWORD  dwStartCode = ((DWORD)(pGOPPacket[0]) << 24 | \
                          (DWORD)(pGOPPacket[1]) << 16 | \
                          (DWORD)(pGOPPacket[2]) <<  8 | \
                          (DWORD)(pGOPPacket[3])) ;

    // If first 4 bytes of packet is NOT the start code (0x1B2) then it's a filler
    return (AM_L21_GOPUD_HDR_STARTCODE != dwStartCode) ;
}


//
//  DetectGOPPacketDataType: Private helper method to detect if GOP user data
//                           packet is from a DVD disc, ATSC stream or others.
//
GOPPACKET_CCTYPE CLine21DecFilter2::DetectGOPPacketDataType(BYTE *pGOPPacket)
{
    if (VerifyGOPUDPacketData((PAM_L21_GOPUD_PACKET) pGOPPacket))
        return GOP_CCTYPE_DVD ;
    else if (VerifyATSCUDPacketData((PAM_L21_ATSCUD_PACKET) pGOPPacket))
        return GOP_CCTYPE_ATSC ;
    else if (IsFillerPacket(pGOPPacket))
        return GOP_CCTYPE_None ;   // not a valid packet -- just ignore it
    else
        return GOP_CCTYPE_Unknown ; // it's some unknown format of CC packet
}


HRESULT CLine21DecFilter2::GetOutputBuffer(IMediaSample **ppOut)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::GetOutputBuffer()"))) ;

    HRESULT  hr ;

    // Get delivery buffer from downstream filter (VMR)
    DWORD dwFlags = 0 ;  // AM_GBF_NOTASYNCPOINT ;
    if (m_bSampleSkipped)
        dwFlags |= AM_GBF_PREVFRAMESKIPPED ;

    dwFlags |= AM_GBF_NODDSURFACELOCK;

    DbgLog((LOG_TRACE, 5, TEXT(">>>> Going to call GetDeliveryBuffer()..."))) ;
    hr = m_pOutput->GetDeliveryBuffer(ppOut, NULL, NULL, dwFlags) ;
    DbgLog((LOG_TRACE, 5, TEXT("<<<< Back from call to GetDeliveryBuffer()"))) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: GetDeliveryBuffer() failed (Error 0x%lx)"), hr)) ;
        return hr ;
    }

    // Check if the output sample uses DDraw surface from the same DDraw object
    IVMRSurface*  pVMRSurf ;
    hr = (*ppOut)->QueryInterface(IID_IVMRSurface, (LPVOID*)&pVMRSurf) ;
    if (SUCCEEDED(hr))
    {
        LPDIRECTDRAWSURFACE7  pDDSurf ;
        hr = pVMRSurf->GetSurface(&pDDSurf) ;
        if (SUCCEEDED(hr))
        {
            m_L21Dec.SetDDrawSurface(pDDSurf) ;
            pDDSurf->Release() ;
        }
        else  // ERROR: couldn't get the DirectDraw surface
        {
            DbgLog((LOG_TRACE, 1,
                TEXT("WARNING: IVMRSurface::GetSurface() failed (Error 0x%lx)"), hr)) ;
        }
        pVMRSurf->Release() ;
    }

    return hr ;
}


// We use a 2 milliseconds (20000 in DShow time) time delta
#define L21D2_SAMPLE_TIME_DELTA   20000

//
// Checks if any output sample needs to be sent, and if so, prepares and sends one down
//
HRESULT CLine21DecFilter2::SendOutputSampleIfNeeded()
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::SendOutputSampleIfNeeded()"))) ;

    HRESULT  hr ;
    REFERENCE_TIME  rtStreamAdjusted ;

    {
    CAutoLock  lock(&m_csFilter) ;

    if (NULL == m_pPinDown)  // output pin is NOT connected -- skip everything
        return S_OK ;

    // Get the current stream time, and based on that process queued samples
    CRefTime  rtStreamTime ;
    hr = StreamTime(rtStreamTime) ;
    if (SUCCEEDED(hr))
    {
        rtStreamAdjusted = (REFERENCE_TIME) rtStreamTime - L21D2_SAMPLE_TIME_DELTA ;

        // There is a possibility of a race condition between different filters when
        // the graph switches to the Running state.  This filter may have gone into
        // Running state (with a tStart value of ~10mSec), and starts sending output
        // samples.  But the clock provider, especially if it's an upstream filter 
        // (Demux, SBE etc.) may not have gone into the Running state yet, and will
        // provide a clock time below the tStart value, resulting in a stream time,
        // which is negative at the beginning.  When the clock provider filter
        // switches to Running state, it gets the tStart value and bumps up its clock
        // to that value at least, resulting in a stream time of zero or higher (but
        // that may hold flat for a little while -- until the actual clock value 
        // reaches the tStart level).  After that, the clock will work fine and the 
        // stream time values will be reliable.  For the above scenario, we need to
        // specially handle the case of negative stream time by bumping it upto 
        // zero, and also processing any input sample we get during this period.
        if (rtStreamAdjusted < 0)
            rtStreamAdjusted = 0 ;
    }
    else  // no clock for the graph!!!
    {
        rtStreamAdjusted = 0 ;  // just init it to something
        DbgLog((LOG_TRACE, 1, 
            TEXT("StreamTime() failed (Error 0x%lx), which means no clock. We'll proceed anyway."), hr)) ;
    }

    // Compare the start time stamp of the next sample in the queue against the 
    // current stream time.  If the sample's time stamp is before the stream time
    // (minus a small delta -- 2 msecs?) then remove the sample from the queue
    // and process it.  Otherwise we just send the same output sample w/o any
    // timestamp so that the VMR can mix it as it sees fit.
    int   iCount = 0 ;
    IMediaSample  *pSample ;
    REFERENCE_TIME  rtStart, rtEnd ;
    while (pSample = m_InSampleQueue.PeekItem())  // peek at the first sample, if any
    {
        hr = pSample->GetTime(&rtStart, &rtEnd) ;
        if (S_OK == hr)  // media sample has time stamp set
        {
            if (rtStreamAdjusted > 0  &&     // valid stream time  AND
                rtStart > rtStreamAdjusted)  // not time yet -- no more processing
            {
                DbgLog((LOG_TRACE, 5, TEXT("Media sample timestamp for future"))) ;
                break ;
            }
            // Otherwise go ahead with processing the sample(s)...
        }
        else  // if there is no time stamp set, we can go ahead and process it
            DbgLog((LOG_TRACE, 5, 
                TEXT("Media sample #%d doesn't have any timestamp set. Process it..."))) ;

        // Now actually remove the media sample from the list for processing
        pSample = m_InSampleQueue.RemoveItem() ;
        if (pSample)
        {
            hr = ProcessSample(pSample) ;
            pSample->Release() ;    // sample processed; must release now
            iCount++ ;
        }
    }
    DbgLog((LOG_TRACE, 5, TEXT("### Processed %d samples in this round"), iCount)) ;

    // First check if we need to send any output samples
    m_L21Dec.UpdateCaptionOutput() ;
    if (!m_bMustOutput  &&           // we are not in "Must Show" mode
        m_L21Dec.IsOutDIBClear() )   // no CC to show
    {
        DbgLog((LOG_TRACE, 5, TEXT("Clear CC -- no sample being sent."))) ;
        SetBlendingState(FALSE) ;
        m_rtLastOutStop += m_rtTimePerOutSample ;  // advance time anyway
        return S_OK ;
    }

    //
    // We need to send a sample down
    //
    SetBlendingState(TRUE) ;  // turn on blending first

    }  // Filter lock scope ends here

    if (m_bNoTimeStamp)
    {
        hr = SendOutputSample(NULL, NULL, NULL) ;
        if (SUCCEEDED(hr))  // if out sample was delivered right
        {
            DbgLog((LOG_TRACE, 5, TEXT("+++ Delivered sample w/o timestamp up to time %s +++"),
                    (LPCTSTR)CDisp(rtStreamAdjusted, CDISP_DEC))) ;
        }
    }
    else
    {
        REFERENCE_TIME  rtStart ;
        REFERENCE_TIME  rtStop  ;
        if (m_rtStart > m_rtLastOutStop)
        {
            DbgLog((LOG_TRACE, 5, 
                TEXT("++++ Starting timestamp low from %s [new sample's: %s]"),
                (LPCTSTR)CDisp(m_rtLastOutStop, CDISP_DEC), (LPCTSTR)CDisp(m_rtStart, CDISP_DEC))) ;
            rtStart = m_rtLastOutStop ;
        }
        else
        {
            DbgLog((LOG_TRACE, 5,
                TEXT("**** Starting timestamp from current sample's (%s) [last: %s]"),
                (LPCTSTR)CDisp(m_rtStart, CDISP_DEC), (LPCTSTR)CDisp(m_rtLastOutStop, CDISP_DEC))) ;
            rtStart = m_rtStart  ;
        }
        rtStop = m_rtStart + m_rtTimePerOutSample ; // rtStart + ...??

        hr = SendOutputSample(NULL, &rtStart, &rtStop) ;
        if (SUCCEEDED(hr))  // if out sample was delivered right
        {
            DbgLog((LOG_TRACE, 5, TEXT("*** Delivered output sample in output thread (for time %s -> %s) ***"),
                (LPCTSTR)CDisp(rtStart, CDISP_DEC), (LPCTSTR)CDisp(rtStop, CDISP_DEC))) ;
        }
    }
    SetBlendingState(! m_L21Dec.IsOutDIBClear() ) ;

    return hr ;
}


BOOL CLine21DecFilter2::IsValidFormat(BYTE *pbFormat)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::IsValidFormat(0x%lx)"), pbFormat)) ;
    // CAutoLock   Lock(&m_csFilter) ; -- can't do that as it may cause deadlock

    if (NULL == pbFormat)
        return FALSE ;

    BITMAPINFOHEADER *lpBMIH = HEADER(pbFormat) ;
    if (! ( 8 == lpBMIH->biBitCount || 16 == lpBMIH->biBitCount ||
           24 == lpBMIH->biBitCount || 32 == lpBMIH->biBitCount) )  // bad bitdepth
        return FALSE ;
    if ( !(BI_RGB == lpBMIH->biCompression ||
           BI_BITFIELDS == lpBMIH->biCompression ||
           '44IA' == lpBMIH->biCompression) ) // bad compression
        return FALSE ;
    if (DIBSIZE(*lpBMIH) != lpBMIH->biSizeImage) // invalid dimensions/size
        return FALSE ;

    return TRUE ;  // hopefully it's a valid video info header
}


void CLine21DecFilter2::SetBlendingState(BOOL bState)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::SetBlendingState(%s)"),
            bState ? TEXT("TRUE") : TEXT("FALSE"))) ;
    // CAutoLock   Lock(&m_csFilter) ;

    // if (m_bBlendingState == bState)  // nothing to change
    //     return ;

    if (NULL == m_pPinDown)
    {
        DbgLog((LOG_ERROR, 3, TEXT("WARNING: Downstream pin not available -- not connected??"))) ;
        return ;
    }

    IVMRVideoStreamControl  *pVMRVSC ;
    HRESULT hr = m_pPinDown->QueryInterface(IID_IVMRVideoStreamControl, (LPVOID *) &pVMRVSC) ;
    if (FAILED(hr) || NULL == pVMRVSC)
    {
        DbgLog((LOG_TRACE, 1, TEXT("WARNING: IVMRVideoStreamControl not available on pin %s"),
                (LPCTSTR) CDisp(m_pPinDown))) ;
        ASSERT(pVMRVSC) ;
        return ;
    }

    hr = pVMRVSC->SetStreamActiveState(bState) ;
    if (SUCCEEDED(hr))
    {
        m_bBlendingState = bState ;  // save last blending operation flag
    }
    else  // VMR probably has stopped
    {
        DbgLog((LOG_TRACE, 3, TEXT("IVMRVideoStreamControl::SetStreamActiveState() failed (Error 0x%lx)"), hr)) ;
    }

    pVMRVSC->Release() ;
}


HRESULT CLine21DecFilter2::SendOutputSample(IMediaSample *pIn,
                                            REFERENCE_TIME *prtStart,
                                            REFERENCE_TIME *prtStop)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::SendOutputSample(0x%lx, %s, %s)"),
        pIn, prtStart ? (LPCTSTR)CDisp(*prtStart, CDISP_DEC) : TEXT("NULL"),
        prtStop ? (LPCTSTR)CDisp(*prtStop, CDISP_DEC) : TEXT("NULL"))) ;

    // if (NULL == m_pPinDown)  // output pin is NOT connected -- skip everything
    //     return S_OK ;

    // First get the output sample
    HRESULT        hr ;
    IMediaSample  *pOut ;
    hr = GetOutputBuffer(&pOut) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: GetOutputBuffer() failed (Error 0x%lx)"), hr)) ;
        return hr ;
    }

    // Now we take the lock
    CAutoLock  Lock(&m_csFilter) ;

    // If EoS has been called while we were getting the delivery buffer (above),
    // we must not deliver the next sample -- just release the acquired buffer.
    if (m_bEndOfStream)
    {
        DbgLog((LOG_TRACE, 3, TEXT("EndOfStream already called. Not delivering next sample"))) ;
        pOut->Release() ;
        return S_OK ;
    }

    Transform(pIn, pOut) ;  // check if output buffer address changed

    if (m_L21Dec.IsOutDIBClear())
        hr = pOut->SetTime(NULL, NULL) ;         // render clear samples right away
    else
        hr = pOut->SetTime(NULL, NULL) ;         // render clear samples right away
    ASSERT(SUCCEEDED(hr)) ;

    // If a new DDraw surface has been given in GetOutputBuffer() just above, we
    // need to re-render the whole CC content on the new surface (should be rare).
    // Output CC data from internal buffer to the DDraw surface
    if (m_L21Dec.IsNewOutBuffer())
        m_L21Dec.UpdateCaptionOutput() ;

    hr = pOut->SetMediaTime(NULL, NULL) ;
    ASSERT(NOERROR == hr) ;

    // The time stamp and other settings now
    if (NULL == pIn)  // preparing out sample w/o valid in sample
    {
        // We assume that it must be a discontinuity as it's a forced output sample
        pOut->SetSyncPoint(m_bDiscontLast) ;
        pOut->SetDiscontinuity(m_bDiscontLast) ;
    }
    else  // input sample is valid
    {
        pOut->SetSyncPoint(pIn->IsSyncPoint() == S_OK) ;
        pOut->SetDiscontinuity(m_bSampleSkipped || S_OK == pIn->IsDiscontinuity()) ;
    }
    m_bSampleSkipped = FALSE ;

    // Now deliver the output sample
    MSR_START(m_idDelvWait) ;  // delivering output sample
    hr = m_pOutput->Deliver(pOut) ;
    MSR_STOP(m_idDelvWait) ;   // done delivering output sample
    if (FAILED(hr))  // Deliver failed for some reason. Eat the error and just go ahead.
    {
        DbgLog((LOG_ERROR, 1, TEXT("WARNING: Deliver() of output sample failed (Error 0x%lx)"), hr)) ;
    }
    else
    {
        DbgLog((LOG_TRACE, 5, TEXT("Delivered %sClear output sample for time (%s, %s)"),
            m_L21Dec.IsOutDIBClear() ? TEXT("") : TEXT("NON-"),
            prtStart ? (LPCTSTR)CDisp(*prtStart, CDISP_DEC) : TEXT("NULL"),
            prtStop  ? (LPCTSTR)CDisp(*prtStop, CDISP_DEC)  : TEXT("NULL"))) ;
        m_bMustOutput = FALSE ;  // we just delivered an output sample
    }
    pOut->Release() ;  // release the output sample

    if (prtStop)  // if we had a valid time stamp
        m_rtLastOutStop = *prtStop ;  // remember the stop of this sample
    else          // invalid / no timestamp
        m_rtLastOutStop += m_rtTimePerOutSample ;  // just advance it

    return S_OK ;
}


// #define PACKET_DUMP
#ifdef PACKET_DUMP  // only for debug builds
//
// A helper function to dump the GOP Packets with Line21 data for internal debugging ONLY
//
void DumpPacket(PAM_L21_GOPUD_PACKET pGOPUDPacket)
{
    AM_L21_GOPUD_ELEMENT Elem ;
    TCHAR                achBuffer[100] ;
    BOOL                 bDumped = TRUE ;
    int                  iElems = GETGOPUD_NUMELEMENTS(pGOPUDPacket) ;

    DbgLog((LOG_TRACE, 0, TEXT("# Elements: %d (%2.2x)"),
        iElems, pGOPUDPacket->Header.bTopField_Rsrvd_NumElems)) ;
    ZeroMemory(achBuffer, sizeof(achBuffer)) ;  // just to clear it
    for (int i = 0 ; i < iElems ; i++)
    {
        Elem = GETGOPUDPACKET_ELEMENT(pGOPUDPacket, i) ;
        wsprintf(achBuffer + 12 * (i % 6), TEXT("(%2.2x %2.2x %2.2x)"),
            (int)Elem.bMarker_Switch, (int)Elem.chFirst, (int)Elem.chSecond) ;
        if (GETGOPUD_ELEM_MARKERBITS(Elem) == AM_L21_GOPUD_ELEM_MARKERBITS  &&
            GETGOPUD_ELEM_SWITCHBITS(Elem) == AM_L21_GOPUD_ELEM_VALIDFLAG)
            achBuffer[12 * (i % 6) + 10] = ' ' ;
        else
            achBuffer[12 * (i % 6) + 10] = '*' ; // indicates bad marker bit
        achBuffer[12 * (i % 6) + 11] = ' ' ;     // separator space
        bDumped = FALSE ;  // something not dumped yet

        if (0 == (i+1) % 6) // 6 elems per line
        {
            DbgLog((LOG_TRACE, 0, achBuffer)) ;
            bDumped = TRUE ;
        }
    }  // end of for (i)

    // if there is something that's not been dumped yet, pad it with NULLs to the end
    // and then dump.
    if (!bDumped)
    {
        ZeroMemory(achBuffer + 12 * (i % 6), 100 - 12 * (i % 6)) ;
        DbgLog((LOG_TRACE, 0, achBuffer)) ;
    }
}


//
// A helper function to dump the ATSC Packets with Line21 data for internal debugging ONLY
//
void DumpATSCPacket(PAM_L21_ATSCUD_PACKET pATSCUDPacket)
{
    AM_L21_ATSCUD_ELEMENT Elem ;
    TCHAR                 achBuffer[100] ;
    BOOL                  bDumped = TRUE ;
    int                   iElems = GETATSCUD_NUMELEMENTS(pATSCUDPacket) ;

    DbgLog((LOG_TRACE, 0, TEXT("Data Flags: %sEM, %sCC, %sAdditional"),
        ISATSCUD_EM_DATA(pATSCUDPacket)   ? TEXT("") : TEXT("Not "),
        ISATSCUD_CC_DATA(pATSCUDPacket)   ? TEXT("") : TEXT("Not "),
        ISATSCUD_ADDL_DATA(pATSCUDPacket) ? TEXT("") : TEXT("Not "))) ;
    DbgLog((LOG_TRACE, 0, TEXT("# Elements: %d"), iElems)) ;
    DbgLog((LOG_TRACE, 0, TEXT("EM Data: 0x%x"), GETATSCUD_EM_DATA(pATSCUDPacket))) ;

    if (ISATSCUD_CC_DATA(pATSCUDPacket))  // if CC data present then dump that
    {
        ZeroMemory(achBuffer, sizeof(achBuffer)) ;  // just to clear it
        for (int i = 0 ; i < iElems ; i++)
        {
            Elem = GETATSCUDPACKET_ELEMENT(pATSCUDPacket, i) ;
            wsprintf(achBuffer + 12 * (i % 6), TEXT("(%2.2x %2.2x %2.2x)"),
                (int)Elem.bCCMarker_Valid_Type, (int)Elem.chFirst, (int)Elem.chSecond) ;
            if (ISATSCUD_ELEM_MARKERBITS_VALID(Elem)  &&  ISATSCUD_ELEM_CCVALID(Elem))
                achBuffer[12 * (i % 6) + 10] = ' ' ;
            else
                achBuffer[12 * (i % 6) + 10] = '*' ; // indicates bad marker bit
            achBuffer[12 * (i % 6) + 11] = ' ' ;     // separator space
            bDumped = FALSE ;  // something not dumped yet

            if (0 == (i+1) % 6) // 6 elems per line
            {
                DbgLog((LOG_TRACE, 0, achBuffer)) ;
                bDumped = TRUE ;
            }
        }  // end of for (i)

        // if there is something that's not been dumped yet, pad it with NULLs to the end
        // and then dump.
        if (!bDumped)
        {
            ZeroMemory(achBuffer + 12 * (i % 6), 100 - 12 * (i % 6)) ;
            DbgLog((LOG_TRACE, 0, achBuffer)) ;
        }
    }

    DbgLog((LOG_TRACE, 0, TEXT("Marker bits: 0x%x"), GETATSCUD_MARKERBITS(pATSCUDPacket))) ;
}

#endif // PACKET_DUMP


HRESULT CLine21DecFilter2::ProcessGOPPacket_DVD(IMediaSample *pIn)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::ProcessGOPPacket_DVD(0x%lx)"), pIn)) ;

    // Get the input data packet and verify that the contents are OK
    HRESULT  hr ;
    PAM_L21_GOPUD_PACKET  pGOPUDPacket ;
    hr = pIn->GetPointer((LPBYTE *)&pGOPUDPacket) ;
    if (! VerifyGOPUDPacketData(pGOPUDPacket) )
    {
        DbgLog((LOG_ERROR, 1, TEXT("Packet verification failed"))) ;
        return S_FALSE ;
    }
    if (pIn->GetActualDataLength() != GETGOPUD_PACKETSIZE(pGOPUDPacket))
    {
        DbgLog((LOG_ERROR, 1,
            TEXT("pIn->GetActualDataLength() [%d] and data size [%d] in packet mismatched"),
            pIn->GetActualDataLength(), GETGOPUD_PACKETSIZE(pGOPUDPacket))) ;
        return S_FALSE ;
    }

#ifdef PACKET_DUMP
    DumpPacket(pGOPUDPacket) ;
#endif // PACKET_DUMP

    // The checks are done.
    AM_L21_GOPUD_ELEMENT    Elem ;
    REFERENCE_TIME          rtInterval ;
    int     iElems = GETGOPUD_NUMELEMENTS(pGOPUDPacket) ;
    if (0 == iElems)
    {
        ASSERT(iElems > 0) ;
        return S_OK ;
    }

    if (NOERROR == pIn->GetTime(&m_rtStart, &m_rtStop))
    {
        //
        // We need at least 16.7msec/frame in the GOP for each bytepair
        //
        REFERENCE_TIME   rtTemp ;
        rtTemp = m_rtStart + m_rtTimePerInSample * iElems ;
        DbgLog((LOG_TRACE, 3, TEXT("Received an input sample (Start=%s, Stop=%s (%s)) discon(%d)"),
            (LPCTSTR)CDisp(m_rtStart, CDISP_DEC), (LPCTSTR)CDisp(rtTemp, CDISP_DEC), (LPCTSTR)CDisp(m_rtStop, CDISP_DEC),
            S_OK == pIn->IsDiscontinuity())) ;
        if (m_rtStop < rtTemp)
            m_rtStop = rtTemp ;

        rtInterval = (m_rtStop - m_rtStart) / iElems ;
        m_bNoTimeStamp = FALSE ;
    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("Received an input sample with no timestamp"))) ;
        rtInterval = 0 ;
        m_bNoTimeStamp = TRUE ;
    }

    LONGLONG   llMediaInterval ;
    if (SUCCEEDED(pIn->GetMediaTime(&m_llMediaStart, &m_llMediaStop)))
    {
        //
        // We need at least 16.7msec/frame in the GOP for each bytepair
        //
        LONGLONG   llTemp ;
        llTemp = m_llMediaStart + m_rtTimePerInSample * iElems ;
        if (m_llMediaStop < llTemp)
            m_llMediaStop = llTemp ;
        llMediaInterval = (m_llMediaStop - m_llMediaStart) / iElems ;
    }
    else
    {
        llMediaInterval = 0 ;
    }

    BOOL   bTopFirst = ISGOPUD_TOPFIELDFIRST(pGOPUDPacket) ;
    DbgLog((LOG_TRACE, 5,
            TEXT("Got a Line21 packet with %d elements, %s field first"),
            iElems, bTopFirst ? TEXT("Top") : TEXT("Bottom"))) ;
    for (int i = bTopFirst ? 0 : 1 ;  // if top field is not first,
         i < iElems ; i++)            // pick next field to start with
    {
        m_rtStop = m_rtStart + rtInterval ;
        m_llMediaStop = m_llMediaStart + llMediaInterval ;
        Elem = GETGOPUDPACKET_ELEMENT(pGOPUDPacket, i) ;
        if (GETGOPUD_ELEM_MARKERBITS(Elem) == AM_L21_GOPUD_ELEM_MARKERBITS  &&
            GETGOPUD_ELEM_SWITCHBITS(Elem) == AM_L21_GOPUD_ELEM_VALIDFLAG)
        {
            //
            // In the WB titles the bottom field's data has wrong marker
            // bit set so that we don't try to decode them. But the titles
            // from Columbia/Tristar (and God knows who else) doesn't do
            // that causing us to look at every field's data which causes
            // CC to flash away with the arrival of the next EOC (14 2F),
            // because it's not recognized as the repeat of the last EOC
            // due to the (0, 0) pair with valid marker bit. So we knowingly
            // skip the alternate field's data to avoid this problem.
            //
            if ( (bTopFirst  && (i & 0x01))  ||     // top first & odd index
                 (!bTopFirst && 0 == (i & 0x01)) )  // bottom first & even index
            {
                DbgLog((LOG_TRACE, 5,
                    TEXT("(0x%x, 0x%x) decode skipped for element %d -- the 'other' field"),
                    Elem.chFirst, Elem.chSecond, i)) ;
                // Advance the time stamps anyway
                m_rtStart = m_rtStop ;
                m_llMediaStart = m_llMediaStop ;
                continue ;
            }

            // Now decode this element; if fails (i.e, bad data), just
            // ignore it and go to the next element.
            if (m_L21Dec.DecodeBytePair(Elem.chFirst, Elem.chSecond))
            {
                DbgLog((LOG_TRACE, 5, TEXT("(0x%x, 0x%x) decode succeeded"),
                    Elem.chFirst, Elem.chSecond)) ;
            }
            else
            {
                DbgLog((LOG_TRACE, 5, TEXT("(0x%x, 0x%x) decode failed"),
                    Elem.chFirst, Elem.chSecond)) ;
            }
        }  // end of check for good markerbit and valid flag
        else
            DbgLog((LOG_TRACE, 5,
                TEXT("Ignored an element (0x%x, 0x%x, 0x%x) with invalid flag"),
                Elem.bMarker_Switch, Elem.chFirst, Elem.chSecond)) ;

        // We need to increment the time stamp though;
        // stop time for this sample is start time for next sample
        m_rtStart = m_rtStop ;
        m_llMediaStart = m_llMediaStop ;
    }  // end of for(i)

    return S_OK ;
}


HRESULT CLine21DecFilter2::ProcessGOPPacket_ATSC(IMediaSample *pIn)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::ProcessGOPPacket_ATSC(0x%lx)"), pIn)) ;

    // Get the input data packet and verify that the contents are OK
    HRESULT  hr ;
    PAM_L21_ATSCUD_PACKET  pATSCUDPacket ;
    hr = pIn->GetPointer((LPBYTE *) &pATSCUDPacket) ;
    ASSERT(hr == NOERROR) ;
    if (! VerifyATSCUDPacketData(pATSCUDPacket) )
    {
        DbgLog((LOG_ERROR, 1, TEXT("ATSC Packet verification failed"))) ;
        return S_FALSE ;
    }
    if (pIn->GetActualDataLength() < GETATSCUD_PACKETSIZE(pATSCUDPacket))
    {
        DbgLog((LOG_ERROR, 1,
            TEXT("pIn->GetActualDataLength() [%d] is less than minm ATSC_UD data size [%d]"),
            pIn->GetActualDataLength(), GETATSCUD_PACKETSIZE(pATSCUDPacket))) ;
        return S_FALSE ;
    }

#ifdef PACKET_DUMP
    DumpATSCPacket(pATSCUDPacket) ;
#endif // PACKET_DUMP

    // The checks are done.
    AM_L21_ATSCUD_ELEMENT    Elem ;
    REFERENCE_TIME           rtInterval ;
    int     iElems = GETATSCUD_NUMELEMENTS(pATSCUDPacket) ;
    if (0 == iElems)
    {
        ASSERT(iElems > 0) ;
        return S_OK ;
    }

    if (NOERROR == pIn->GetTime(&m_rtStart, &m_rtStop))
    {
        //
        // We need at least 16.7msec/frame in the GOP for each bytepair
        //
        REFERENCE_TIME   rtTemp ;
        rtTemp = m_rtStart + m_rtTimePerInSample * iElems ;
        DbgLog((LOG_TRACE, 3, TEXT("Received an input sample (Start=%s, Stop=%s (%s))"),
                (LPCTSTR)CDisp(m_rtStart, CDISP_DEC), (LPCTSTR)CDisp(rtTemp, CDISP_DEC),
                (LPCTSTR)CDisp(m_rtStop, CDISP_DEC))) ;
        if (m_rtStop < rtTemp)
            m_rtStop = rtTemp ;

        rtInterval = (m_rtStop - m_rtStart) / iElems ;
        m_bNoTimeStamp = FALSE ;
    }
    else
    {
        DbgLog((LOG_TRACE, 1, TEXT("Received an input sample with no timestamp"))) ;
        rtInterval = 0 ;
        m_bNoTimeStamp = TRUE ;
    }

    LONGLONG   llMediaInterval ;
    if (SUCCEEDED(pIn->GetMediaTime(&m_llMediaStart, &m_llMediaStop)))
    {
        //
        // We need at least 16.7msec/frame in the GOP for each bytepair
        //
        LONGLONG   llTemp ;
        llTemp = m_llMediaStart + m_rtTimePerInSample * iElems ;
        if (m_llMediaStop < llTemp)
            m_llMediaStop = llTemp ;
        llMediaInterval = (m_llMediaStop - m_llMediaStart) / iElems ;
    }
    else
    {
        llMediaInterval = 0 ;
    }

    for (int i = 0 ; i < iElems ; i++)
    {
        m_rtStop = m_rtStart + rtInterval ;
        m_llMediaStop = m_llMediaStart + llMediaInterval ;
        Elem = GETATSCUDPACKET_ELEMENT(pATSCUDPacket, i) ;
        if (ISATSCUD_ELEM_MARKERBITS_VALID(Elem)  &&  ISATSCUD_ELEM_CCVALID(Elem))
        {
            // Now decode this element; if fails (i.e, bad data), just
            // ignore it and go to the next element.
            if (m_L21Dec.DecodeBytePair(Elem.chFirst, Elem.chSecond))
            {
                DbgLog((LOG_TRACE, 5, TEXT("(0x%x, 0x%x) decode succeeded"),
                    Elem.chFirst, Elem.chSecond)) ;
            }
            else
            {
                DbgLog((LOG_TRACE, 5, TEXT("(0x%x, 0x%x) decode failed"),
                    Elem.chFirst, Elem.chSecond)) ;
            }
        }  // end of check for good markerbit and valid flag
        else
            DbgLog((LOG_TRACE, 5,
                TEXT("Ignored an element (0x%x, 0x%x, 0x%x) with invalid marker/type flag"),
                Elem.bCCMarker_Valid_Type, Elem.chFirst, Elem.chSecond)) ;

        // We need to increment the time stamp though;
        // stop time for this sample is start time for next sample
        m_rtStart = m_rtStop ;
        m_llMediaStart = m_llMediaStop ;
    }  // end of for(i)

    return S_OK ;
}


//
//  Receive: It's the real place where the output samples are created by
//           decoding the byte pairs out of the input stream.
//
HRESULT CLine21DecFilter2::Receive(IMediaSample * pIn)
{
    CAutoLock   lock(&m_csReceive);
    HRESULT     hr ;

    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::Receive(0x%p)"), pIn)) ;

    //
    // First check if we must do anything at all
    //
    if (!m_bMustOutput  &&                                         // not a must output
        (AM_L21_CCSTATE_Off    == m_L21Dec.GetServiceState()  ||   // CC turned off
         AM_L21_CCSERVICE_None == m_L21Dec.GetCurrentService()))   // no CC selected
    {
        DbgLog((LOG_TRACE, 3,
            TEXT("Captioning is off AND we don't HAVE TO output. Skipping everything."))) ;
        return NOERROR ;  // we are done with this sample
    }

    // Get the input format info; we'll use the same for output
    ASSERT(m_pOutput != NULL) ;

    //
    // First check if it's a discontinuity sample.  If so, just flush everything
    // and send an output sample down.
    //
    hr = pIn->IsDiscontinuity() ;
    if (S_OK == hr)  // got a discontinuity; flush everything, refresh output
    {
        // If we got a discontinuity in the last sample, we flushed and all.
        // We can skip this one safely.
        if ( ! m_bDiscontLast )  // new discontinuity sample => do flush etc.
        {
            // Flush the internal buffers (caption and output DIB section)
            DbgLog((LOG_TRACE, 1, TEXT("-->> Got a discontinuity sample. Flushing all data..."))) ;  // 1
            m_L21Dec.FlushInternalStates() ; // clear CC internal data buffers
            m_L21Dec.FillOutputBuffer() ;    // clear existing CC on output sample
            m_InSampleQueue.ClearQueue() ;   // remove all queued up samples
            m_bMustOutput  = TRUE ;          // we must output a sample NOW
            m_bDiscontLast = TRUE ;          // remember we handled a discontinuity
        }
        else  // another discontinuity => ignore it
        {
            DbgLog((LOG_TRACE, 1, TEXT("--> Got a discontinuity sample after another. Ignore it."))) ;
        }
    }  // end of if (discontinuity sample)
    else
    {
#ifdef DEBUG
        if (AM_L21_CCSUBTYPEID_BytePair == m_eSubTypeIDIn)  // only for ATV bytepair CC
        {
            BYTE  *pbInBytePair ;
            hr = pIn->GetPointer(&pbInBytePair) ;      // Get the input byte pair
            REFERENCE_TIME  rtStart, rtStop ;
            hr = pIn->GetTime(&rtStart, &rtStop) ;
            DbgLog((LOG_TRACE, 5, TEXT("Got normal sample (0x%x, 0x%x) for time: %s -> %s"),
                pbInBytePair[0], pbInBytePair[1],
                S_OK == hr ? (LPCTSTR)CDisp(rtStart, CDISP_DEC) : TEXT("**Bad**"), 
                S_OK == hr ? (LPCTSTR)CDisp(rtStop,  CDISP_DEC) : TEXT("**Bad**"))) ;
        }
#endif // DEBUG

        m_bDiscontLast = FALSE ;       // remember we got a normal sample

        // Add it to the sample queue -- will have to wait, if queue is full
        if (! m_InSampleQueue.AddItem(pIn) )
        {
            DbgLog((LOG_TRACE, 1, TEXT("WARNING: Adding an input sample failed!!!"))) ;
            m_bDiscontLast = TRUE ;  // we dropped a sample; so discontinuity is ON
            // Because we are setting the above flag, we'll happen to ignore the next
            // discontinuity sample, if it came right away.  So we must do the same
            // things now.  Also it makes sense as this is a bad state, where flushing
            // the output is not a bad idea.
            m_L21Dec.FlushInternalStates() ; // clear CC internal data buffers
            m_L21Dec.FillOutputBuffer() ;    // clear existing CC on output sample
        }
    }

    //
    // If we must output a sample, we'll do it now.  This may be either because
    // * we haven't sent down any sample in this play session
    // * it's the discontinuity sample
    // * CC state/service choice has been changed by the user via IAMLine21Decoder
    // * some "unknown" reason (??)
    //
    if (m_bMustOutput)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Signal for sending an output sample, because we must..."))) ;
        m_OutputThread.SignalForOutput() ;
    }

    return S_OK ;  // we are done
}


HRESULT CLine21DecFilter2::ProcessSample(IMediaSample *pIn)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::ProcessSample(%p)"), pIn)) ;

    ASSERT(pIn) ;

    HRESULT          hr ;
    // REFERENCE_TIME  *prtStart = NULL, *prtStop = NULL ;

    //
    // Process the sample based on filter's input format type
    //
    switch (m_eSubTypeIDIn)
    {
    case AM_L21_CCSUBTYPEID_BytePair:
        {
            //
            // Determine if the sample is for Field1 or Field2.  We need to process
            // the field1 data and reject the field2 data.
            //
            IMediaSample2  *pSample2 ;
            AM_SAMPLE2_PROPERTIES   Sample2Prop ;
            hr = pIn->QueryInterface(IID_IMediaSample2, (LPVOID *) &pSample2) ;
            if (SUCCEEDED(hr))
            {
                hr = pSample2->GetProperties(sizeof(Sample2Prop), (BYTE *) &Sample2Prop) ;
                pSample2->Release() ;
                DbgLog((LOG_TRACE, 5, TEXT("Line21: Input sample for field%lu"),
                        Sample2Prop.dwTypeSpecificFlags)) ;
                if (Sample2Prop.dwTypeSpecificFlags)  // field2 data
                {
                    break ;  // don't process it
                }
            }

            // Now we are ready to process the bytepair sample
            BYTE  *pbInBytePair ;
            LONG   lInDataSize ;
            hr = pIn->GetPointer(&pbInBytePair) ;      // Get the input byte pair
            lInDataSize = pIn->GetActualDataLength() ; // se how much data we got
            if (FAILED(hr)  ||  2 != lInDataSize)  // bad data -- complain and just skip it
            {
                DbgLog((LOG_ERROR, 1, TEXT("%d bytes of data sent as Line21 data (hr = 0x%lx)"),
                    lInDataSize, hr)) ;
                ASSERT(NOERROR == hr) ;
                ASSERT(2 == lInDataSize) ;
                break ;
            }

            REFERENCE_TIME  rtStart, rtStop ;
            if (NOERROR == (hr = pIn->GetTime(&rtStart, &rtStop)))
            {
                m_rtStart = rtStart ;
                m_rtStop  = rtStop ;
                // In case the end timestamp on the incoming media sample is too
                // far off or too close, we fix it here to something practical.
                if (m_rtStop != m_rtStart + m_rtTimePerOutSample)
                    m_rtStop = m_rtStart + m_rtTimePerOutSample ;
                m_bNoTimeStamp = FALSE ;
            }
            else
            {
                DbgLog((LOG_TRACE, 3, TEXT("GetTime() call failed (Error 0x%lx)"), hr)) ;
                m_bNoTimeStamp = TRUE ;
            }

            // Now decode into the received output sample buffer
            if (m_L21Dec.DecodeBytePair(pbInBytePair[0], pbInBytePair[1]))
            {
                DbgLog((LOG_TRACE, 5, TEXT("(0x%x, 0x%x) decode succeeded"),
                        pbInBytePair[0], pbInBytePair[1])) ;
            }

            break ;
        }  // end of case ..._BytePair

        case AM_L21_CCSUBTYPEID_GOPPacket:
        {
            BYTE *pbGOPPacket ;
            hr = pIn->GetPointer((LPBYTE *)&pbGOPPacket) ;
            ASSERT(hr == NOERROR) ;
            GOPPACKET_CCTYPE  eGOP_CCType = DetectGOPPacketDataType(pbGOPPacket) ;
            if (GOP_CCTYPE_None != eGOP_CCType  && // NOT filler CC packet  AND...
                m_eGOP_CCType   != eGOP_CCType)    // change of CC type
            {
                DbgLog((LOG_TRACE, 3, TEXT("GOPPacket CC type changed from %d to %d"),
                        m_eGOP_CCType, eGOP_CCType)) ;

                // Flush internal caption buffers and output sample buffer
                m_L21Dec.FlushInternalStates() ; // clear CC internal data buffers
                m_L21Dec.FillOutputBuffer() ;    // clear existing CC on output sample
                m_bMustOutput  = TRUE ;          // we must output a sample NOW
                // SHOULD WE SIGNAL TO SEND AN OUTPUT SAMPLE or IS IT OK ANYWAY?

                m_eGOP_CCType = eGOP_CCType ;    // switch to new CC type
            }

            switch (m_eGOP_CCType)
            {
            case GOP_CCTYPE_DVD:
                hr = ProcessGOPPacket_DVD(pIn) ;
                break ;

            case GOP_CCTYPE_ATSC:
                hr = ProcessGOPPacket_ATSC(pIn) ;
                break ;

            default:
                DbgLog((LOG_TRACE, 3, TEXT("Unknown GOP packet data type (%d)"), m_eGOP_CCType)) ;
                break ;
            }  // end of switch (.._CCType)

            break ;
        }  // end of case ..._GOPPacket

        default:  // it's a bad data format type (how could we get into it?)
            DbgLog((LOG_ERROR, 0, TEXT("ERROR: We are in a totally unexpected format type"))) ;
            ASSERT(! TEXT("Bad connection subtype used")) ;
            return E_FAIL ;  // or E_UNEXPECTED ; ???
    }

    return NOERROR ;
}


//
//  Transform: It's mainly a place holder because we HAVE to override it.
//             The actual work is done in Receive() itself. Here we detect
//             if the buffer addres provided by downstream filter's allocator
//             has changed or not; if yes, we have to re-write entire text.
//
HRESULT CLine21DecFilter2::Transform(IMediaSample * pIn, IMediaSample * pOut)
{
    DbgLog((LOG_TRACE, 3, TEXT("CLine21DecFilter2::Transform(0x%p, 0x%p)"),
            pIn, pOut)) ;

    UNREFERENCED_PARAMETER(pIn) ;

    HRESULT   hr ;
    LPBITMAPINFO       lpbiNew ;
    BITMAPINFOHEADER   biCurr ;

    // Check if there has been any dynamic format change; if so, make adjustments
    // accordingly.
    AM_MEDIA_TYPE  *pmt ;
    hr = pOut->GetMediaType(&pmt) ;
    ASSERT(SUCCEEDED(hr)) ;
    if (S_OK == hr)  // i.e, format has changed
    {
        hr = pOut->SetMediaType(NULL) ; // just to tell OverlayMixer, I am not changing again
        ASSERT(SUCCEEDED(hr)) ;
        // m_mtOutput = *pmt ;
        lpbiNew = (LPBITMAPINFO) HEADER(((VIDEOINFO *)(pmt->pbFormat))) ;
        m_L21Dec.GetOutputFormat(&biCurr) ;
        if (0 != memcmp(lpbiNew, &biCurr, sizeof(BITMAPINFOHEADER)))
        {
            // output format has been changed -- update our internel values now
            DbgLog((LOG_TRACE, 2, TEXT("Output format has been dynamically changed"))) ;
            m_L21Dec.SetOutputOutFormat(lpbiNew) ;
            GetDefaultFormatInfo() ;  // to pick any change in format data
        }

        m_pOutput->CurrentMediaType() = *pmt ;
        DeleteMediaType(pmt) ;
    }

    return S_OK ;
}


//
//  BeginFlush: We have to implement this as we have overridden Receive()
//
HRESULT CLine21DecFilter2::BeginFlush(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::BeginFlush()"))) ;

    CAutoLock   Lock(&m_csFilter) ;

    HRESULT     hr = NOERROR ;
    if (NULL != m_pOutput)
    {
        hr = m_pOutput->DeliverBeginFlush() ;
        if (FAILED(hr))
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: DeliverBeginFlush() on out pin failed (Error 0x%lx)"), hr)) ;

        m_InSampleQueue.ClearQueue() ;   // clear queued up samples on flush
        m_L21Dec.FlushInternalStates() ; // clear CC internal data buffers
        m_L21Dec.FillOutputBuffer() ;    // clear existing CC on output sample
        SetBlendingState(FALSE) ;        // turn off blending through VMR
    }

    return hr ;
}


//
//  EndFlush: We have to implement this as we have overridden Receive()
//
HRESULT CLine21DecFilter2::EndFlush(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::EndFlush()"))) ;

    CAutoLock   Lock(&m_csFilter) ;

    HRESULT     hr = NOERROR ;
    if (NULL != m_pOutput)
    {
        hr = m_pOutput->DeliverEndFlush() ;
        if (FAILED(hr))
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: DeliverEndFlush() on out pin failed (Error 0x%lx)"), hr)) ;
    }

    return hr ;
}


//
//  EndOfStream: We have to implement this as we have overridden Receive()
//
HRESULT CLine21DecFilter2::EndOfStream(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::EndOfStream()"))) ;

    // First let's do some housekeeping on our side
    // SetBlendingState(FALSE) ; // turn off CC stream
    m_OutputThread.Close() ;  // stop the output thread
    m_InSampleQueue.Close() ; // flush in-samples and close queue

    CAutoLock   Lock(&m_csFilter) ;
    HRESULT     hr = NOERROR ;

    if (NULL != m_pOutput)
    {
        SetBlendingState(FALSE) ; // turn off CC stream

        // Now deliver the EoS downstream
        hr = m_pOutput->DeliverEndOfStream() ;
        if (FAILED(hr))
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: DeliverEndOfStream() on out pin failed (Error 0x%lx)"), hr)) ;
        else
            m_bEndOfStream = TRUE ;  // must not send down any more samples
    }

    return hr ;
}


HRESULT CLine21DecFilter2::GetDefaultFormatInfo(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::GetDefaultFormatInfo()"))) ;
    //
    // We can't take the lock in this method, because it is called in Transform()
    // which is called from Receive() causing us to take m_csReceive and then
    // m_csFilter which is opposite of what Stop, Pause etc. methods do thereby
    // causing a potential for deadlock.
    //

    // build a VIDEOINFO struct with default internal BITMAPINFO
    DWORD   dwSize ;
    m_L21Dec.GetDefaultFormatInfo(NULL, &dwSize) ;

    if (m_dwDefFmtSize != dwSize + SIZE_PREHEADER)
    {
        if (m_pviDefFmt)
        {
            delete m_pviDefFmt ;
            m_pviDefFmt = NULL ;
            m_dwDefFmtSize = 0 ;
        }
        m_pviDefFmt = (VIDEOINFO *) new BYTE[dwSize + SIZE_PREHEADER] ;
        if (NULL == m_pviDefFmt)
        {
            DbgLog((LOG_ERROR, 0, TEXT("WARNING: Out of memory for format block VIDEOINFO struct"))) ;
            return E_OUTOFMEMORY ;
        }
        m_dwDefFmtSize = dwSize + SIZE_PREHEADER;  // total size of default format data
    }

    // We want to get BITMAPINFO part of VIDEOINFO struct from our GDI class
    m_L21Dec.GetDefaultFormatInfo((LPBITMAPINFO) &(m_pviDefFmt->bmiHeader), &dwSize) ; // get default data

    // Set the other fields
    LARGE_INTEGER  li ;
    li.QuadPart = (LONGLONG) 333667 ;  // => 29.97 fps
    RECT   rc ;
    rc.left = rc.top = 0 ;
    rc.right = HEADER(m_pviDefFmt)->biWidth ;
    rc.bottom = abs(HEADER(m_pviDefFmt)->biHeight) ;  // just make sure rect fields are +ve
    m_pviDefFmt->rcSource = rc ;
    m_pviDefFmt->rcTarget = rc ;
    m_pviDefFmt->dwBitRate = MulDiv(HEADER(m_pviDefFmt)->biSizeImage,
        80000000, li.LowPart) ;
    m_pviDefFmt->dwBitErrorRate = 0 ;
    m_pviDefFmt->AvgTimePerFrame = (LONGLONG) 333667L ; // => 29.97 fps

    return NOERROR ;
}


//
//  CheckInputType: Check if you can support the input data type
//
HRESULT CLine21DecFilter2::CheckInputType(const CMediaType* pmtIn)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::CheckInputType(0x%lx)"), pmtIn)) ;
    // CAutoLock   Lock(&m_csFilter) ; -- shouldn't as that causes deadlock

    if (NULL == pmtIn)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Rejecting: media type info is NULL"))) ;
        return E_INVALIDARG ;
    }

    //  We only support MEDIATYPE_AUXLine21Data and
    //  MEDIASUBTYPE_Line21_BytePair or MEDIASUBTYPE_Line21_GOPPacket
    //  or MEDIASUBTYPE_Line21_VBIRawData (never)
    GUID    SubTypeIn = *pmtIn->Subtype() ;
    m_eSubTypeIDIn = MapGUIDToID(&SubTypeIn) ;
    if (! (MEDIATYPE_AUXLine21Data == *pmtIn->Type()  &&
        ISSUBTYPEVALID(m_eSubTypeIDIn)) )
    {
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: Rejecting invalid Line 21 Data subtype"))) ;
        return E_INVALIDARG ;
    }

    // Check that this is a valid format type
    if (FORMAT_VideoInfo == *pmtIn->FormatType())
    {
        ASSERT(m_pOutput != NULL) ;

        //
        // Make sure the given input format is valid. If not, reject it and use our
        // own default format data.
        //
        if (! IsValidFormat(pmtIn->Format()) )
        {
            DbgLog((LOG_TRACE, 1, TEXT("Invalid format data given -- using our own format data."))) ;
            if (NULL == m_pviDefFmt)
            {
                HRESULT  hr = GetDefaultFormatInfo() ;
                if (FAILED(hr))
                {
                    DbgLog((LOG_ERROR, 0, TEXT("WARNING: Couldn't get default format data"))) ;
                    return hr ;
                }
            }
            // We should fix the input mediatype too (with the default VideoInfo data).
            m_pInput->CurrentMediaType().SetFormat((LPBYTE) m_pviDefFmt, m_dwDefFmtSize) ;
            m_pOutput->CurrentMediaType().SetFormatType(pmtIn->FormatType()) ;
            m_pOutput->CurrentMediaType().SetFormat((LPBYTE) m_pviDefFmt, m_dwDefFmtSize) ;
        }
        else  // seems to be valid format spec.
        {
            //
            // Get the specified input format info; we'll use the same for output
            //
            if (pmtIn->FormatLength() > 0) // only if there is some format data
            {
                m_pOutput->CurrentMediaType().SetFormatType(pmtIn->FormatType()) ;
                m_pOutput->CurrentMediaType().SetFormat(pmtIn->Format(), pmtIn->FormatLength()) ;
            }
            else
            {
                DbgLog((LOG_ERROR, 0, TEXT("WARNING: FORMAT_VideoInfo and no format block specified."))) ;
                return E_INVALIDARG ;
            }
        }
    }
    else if (GUID_NULL   == *pmtIn->FormatType() ||  // wild card
             FORMAT_None == *pmtIn->FormatType())    // no format
    {
        //
        // input pin didn't get a format type info; use our own
        //
        DbgLog((LOG_TRACE, 3, TEXT("No format type specified -- using our own format type."))) ;
        if (NULL == m_pviDefFmt)
        {
            HRESULT  hr = GetDefaultFormatInfo() ;
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 0, TEXT("WARNING: Couldn't get default format data"))) ;
                return hr ;
            }
        }
        m_pOutput->CurrentMediaType().SetFormat((LPBYTE) m_pviDefFmt, m_dwDefFmtSize) ;
    }
    else  // something weird that we don't like
    {
        DbgLog((LOG_TRACE, 3, TEXT("Rejecting invalid format type"))) ;
        // tell what input type too??
        return E_INVALIDARG ;
    }

    // some more level 3 debug log here???

    // We should branch based on what format type we got, because ..GOPPacket
    // type needs to be unwrapped and parsed whereas the ..BytePair format
    // is to be directly parsed.

    // do we have a case for -- return VFW_E_TYPE_NOT_ACCEPTED ???

    return NOERROR ;
}


//
//  CheckTransform: check if this input to this output transform is supported
//
HRESULT CLine21DecFilter2::CheckTransform(const CMediaType* pmtIn,
                                         const CMediaType* pmtOut)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::CheckTransform(0x%lx, 0x%lx)"),
            pmtIn, pmtOut)) ;
    // CAutoLock   Lock(&m_csFilter) ; -- shouldn't as that causes deadlock

    if (NULL == pmtIn || NULL == pmtOut)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Rejecting: media type info is NULL"))) ;
        return E_INVALIDARG ;
    }

    //  We only support MEDIATYPE_AUXLine21Data and
    //  MEDIASUBTYPE_Line21_BytePair or MEDIASUBTYPE_Line21_GOPPacket
    //  or MEDIASUBTYPE_Line21_VBIRawData (never)
    //  Check that input is a valid subtype type
    //  and format is VideoInfo or None
    GUID SubTypeIn = *pmtIn->Subtype() ;
    m_eSubTypeIDIn = MapGUIDToID(&SubTypeIn) ;
    if (! (MEDIATYPE_AUXLine21Data == *pmtIn->Type()  &&   // line21 data type and...
           ISSUBTYPEVALID(m_eSubTypeIDIn)  &&              // valid subtype (bytepair/GOPPacket) and...
           (FORMAT_VideoInfo == *pmtIn->FormatType() ||    // format VideoInfo  or
            FORMAT_None      == *pmtIn->FormatType() ||    // format None (KS wild card)  or
            GUID_NULL        == *pmtIn->FormatType())) )   // GUID Null (DShow wild card)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Rejecting: input type not Line21 / subtype / formattype invalid"))) ;
        return E_INVALIDARG ;
    }

    // and we only accept video as output
    if (MEDIATYPE_Video != *pmtOut->Type())
    {
        DbgLog((LOG_TRACE, 3, TEXT("Rejecting: output type is not VIDEO"))) ;
        return E_INVALIDARG ;
    }

    // check output is VIDEOINFO type
    if (FORMAT_VideoInfo != *pmtOut->FormatType())
    {
        DbgLog((LOG_TRACE, 3, TEXT("Rejecting: output format type is not VIDEOINFO"))) ;
        return E_INVALIDARG ;
    }

    //
    //  Verify that the output size specified by the input and output mediatype
    //  are acceptable.
    //
    if ( !IsValidFormat(pmtOut->Format())  ||             // invalid output format data  OR
         // !m_L21Dec.IsSizeOK(HEADER(pmtOut->Format()))  || // output size is NOT acceptable  OR
         (FORMAT_VideoInfo == *pmtIn->FormatType() &&     // valid input format type and...
          !IsValidFormat(pmtIn->Format()) // &&               // valid input format data and...
          // !m_L21Dec.IsSizeOK(HEADER(pmtIn->Format()))) )  // output size is NOT acceptable
         ) )  // just closing parentheses
    {
        DbgLog((LOG_TRACE, 1, TEXT("Rejecting: Input/output-specified output size is unacceptable"))) ;
        return E_INVALIDARG ;
    }

#if 0

#define rcS1 ((VIDEOINFO *)(pmtOut->Format()))->rcSource
#define rcT1 ((VIDEOINFO *)(pmtOut->Format()))->rcTarget

    DbgLog((LOG_TRACE, 3,
        TEXT("Input Width x Height x Bitdepth: %ld x %ld x %ld"),
        HEADER(pmtIn->Format())->biWidth,
        HEADER(pmtIn->Format())->biHeight,
        HEADER(pmtIn->Format())->biBitCount)) ;
    DbgLog((LOG_TRACE, 3,
        TEXT("Output Width x Height x Bitdepth: %ld x %ld x %ld"),
        HEADER(pmtOut->Format())->biWidth,
        HEADER(pmtOut->Format())->biHeight,
        HEADER(pmtOut->Format())->biBitCount)) ;
    DbgLog((LOG_TRACE, 3,
        TEXT("rcSrc: (%ld, %ld, %ld, %ld)"),
        rcS1.left, rcS1.top, rcS1.right, rcS1.bottom)) ;
    DbgLog((LOG_TRACE, 3,
        TEXT("rcDst: (%ld, %ld, %ld, %ld)"),
        rcT1.left, rcT1.top, rcT1.right, rcT1.bottom)) ;

    DWORD     dwErr ;

    // If we've been given rectangles, use What???
    if (!IsRectEmpty(&rcS1) || !IsRectEmpty(&rcT1))
    {
        DbgLog((LOG_TRACE, 4, TEXT("Either source or dest rect is empty"))) ;
        dwErr = 0 ;  // what to do here??
    }
    else
    {
        DbgLog((LOG_TRACE, 4, TEXT("Source or dest rects are not empty")));
        dwErr = 0 ;  // what to do here??
    }

    if (dwErr != 0)  // or what to check against??
    {
        DbgLog((LOG_ERROR, 1, TEXT("decoder rejected this transform"))) ;
        return E_FAIL ;
    }

#endif // #if 0

    return NOERROR ;
}


//
//  CompleteConnect: Overridden to know when a connection is made to this filter
//
HRESULT CLine21DecFilter2::CompleteConnect(PIN_DIRECTION dir, IPin *pReceivePin)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::CompleteConnect(%s, 0x%lx)"),
        dir == PINDIR_INPUT ? TEXT("Input") : TEXT("Output"), pReceivePin)) ;
    CAutoLock   Lock(&m_csFilter) ;

    LPBITMAPINFO lpbmi ;
    HRESULT      hr ;

    if (PINDIR_OUTPUT == dir)
    {
        DbgLog((LOG_TRACE, 5, TEXT("L21D output pin connecting to %s"), (LPCTSTR)CDisp(pReceivePin))) ;

        //
        // This version of the line21 decoder is only supposed to work with the VMR
        //
        IVMRVideoStreamControl  *pVMRSC ;
        hr = pReceivePin->QueryInterface(IID_IVMRVideoStreamControl, (LPVOID *) &pVMRSC) ;
        if (SUCCEEDED(hr))
        {
            DbgLog((LOG_TRACE, 5, TEXT("Downstream input pin supports IVMR* interface"))) ;
            pVMRSC->Release() ;
        }
        else
        {
            DbgLog((LOG_TRACE, 5, TEXT("Downstream input pin does NOT support IVMR* interface"))) ;
            return E_FAIL ;
        }

        //
        // Now get the the output pin's mediatype and use that for our
        // output size etc.
        //
        const CMediaType  *pmt = &(m_pOutput->CurrentMediaType()) ;
        ASSERT(MEDIATYPE_Video == *pmt->Type()  &&
            FORMAT_VideoInfo == *pmt->FormatType()) ;
        // m_mtOutput = *pmt ;  // this is our output mediatype for now
        if (pmt->FormatLength() > 0)  // only if there is some format data
        {
            lpbmi = (LPBITMAPINFO) HEADER(((VIDEOINFO *)(pmt->Format()))) ;
            ASSERT(lpbmi) ;

            // Set the output format info coming from downstream
            m_L21Dec.SetOutputOutFormat(lpbmi) ;
            GetDefaultFormatInfo() ;  // to pick any change in format data
        }

        return NOERROR ;
    }

    ASSERT(PINDIR_INPUT == dir) ;
    {
        DbgLog((LOG_TRACE, 5, TEXT("L21D input pin connecting to %s"), (LPCTSTR)CDisp(pReceivePin))) ;

        // const CMediaType  *pmt = &(m_pInput->CurrentMediaType()) ;
        AM_MEDIA_TYPE mt ;
        hr = pReceivePin->ConnectionMediaType(&mt) ;
        if (SUCCEEDED(hr))  // ONLY if upstream filter provides mediatype used in the connection
        {
            // If format type (and format data) has been specified then save it as
            // input-side output format
            if (FORMAT_VideoInfo == mt.formattype  &&
                mt.cbFormat > 0)
            {
                lpbmi = (LPBITMAPINFO) HEADER(((VIDEOINFO *)(mt.pbFormat))) ;
                ASSERT(lpbmi) ;

                // Store whatever output format info is specified by upstream filter
                m_L21Dec.SetOutputInFormat(lpbmi) ;
                GetDefaultFormatInfo() ;  // to pick any change in format data
            }

            FreeMediaType(mt) ;
        }  // end of if ()
    }

    //
    //  We MUST clear the caption data buffers and any exisiting internal state
    //  now.  This is most important in the cases where the filter has been
    //  used to decode some Line 21 data, disconnected from the source and then
    //  reconnected again to play another stream of data.
    //
    m_L21Dec.FlushInternalStates() ;   // reset internal state

    return NOERROR ;
}


//
//  BreakConnect: Overridden to know when a connection is broken to our pin
//
HRESULT CLine21DecFilter2::BreakConnect(PIN_DIRECTION dir)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::BreakConnect(%s)"),
            dir == PINDIR_INPUT ? TEXT("Input") : TEXT("Output"))) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (PINDIR_OUTPUT == dir)
    {
        // If not connected yet, just return (but indicate with S_FALSE)
        if (! m_pOutput->IsConnected() )
            return S_FALSE ;

        m_L21Dec.SetOutputOutFormat(NULL) ;  // no output format from downstream
        GetDefaultFormatInfo() ;  // to pick any change in format data
        m_L21Dec.SetDDrawSurface(NULL) ;  // DDraw output surface not available now

        //
        // NOTE 1: We are definitely not running/paused. So no need to delete/
        // create output DIB section here.
        //

        //
        // NOTE 2: We don't do CBaseOutputPin::BreakConnect(), because the
        // base class code for CTransformOutputPin::BreakConnect() already
        // does that.
        //
        return NOERROR ;
    }

    ASSERT(PINDIR_INPUT == dir) ;

    // If not connected yet, just return (but indicate with S_FALSE)
    if (! m_pInput->IsConnected() )
        return S_FALSE ;

    // m_L21Dec.SetOutputInFormat(NULL) ;  // no output format from upstream
    GetDefaultFormatInfo() ;  // to pick any change in format data

    //
    // NOTE 1: We are definitely not running/paused. So no need to delete/
    // create output DIB section here.
    //

    //
    // NOTE 2: We don't do CBaseOutputPin::BreakConnect(), because the
    // base class code for CTransformOutputPin::BreakConnect() already
    // does that.
    //
    return NOERROR ;
}

//
//  SetMediaType: overriden to know when the media type is actually set
//
HRESULT CLine21DecFilter2::SetMediaType(PIN_DIRECTION direction, const CMediaType *pmt)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::SetMediaType(%s, 0x%lx)"),
            direction == PINDIR_INPUT ? TEXT("Input") : TEXT("Output"), pmt)) ;
    // CAutoLock   Lock(&m_csFilter) ;

    LPTSTR alpszFormatIDs[] = { TEXT("Invalid"), TEXT("BytePair"),
								TEXT("GOPPacket"), TEXT("VBIRawData") } ;

    if (PINDIR_OUTPUT == direction)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Output type: %d x %d x %d"),
            HEADER(m_pOutput->CurrentMediaType().Format())->biWidth,
            HEADER(m_pOutput->CurrentMediaType().Format())->biHeight,
            HEADER(m_pOutput->CurrentMediaType().Format())->biBitCount)) ;
        return NOERROR ;
    }

    ASSERT(PINDIR_INPUT == direction) ;
    DbgLog((LOG_TRACE, 3, TEXT("Input type: <%s>"),
        alpszFormatIDs[MapGUIDToID(m_pInput->CurrentMediaType().Subtype())])) ;

    if (m_pOutput && m_pOutput->IsConnected())
    {
        DbgLog((LOG_TRACE, 2, TEXT("*** Changing IN when OUT already connected"))) ;
        DbgLog((LOG_TRACE, 2, TEXT("Reconnecting the output pin..."))) ;
        return m_pGraph->Reconnect(m_pOutput) ;
    }

    return NOERROR ;
}


#if 0  // Quality Management is deferred for now as OvMixer always says (Flood, 1000)

//
//  AlterQuality: overriden to handle quality messages and not pass them upstream
//
HRESULT CLine21DecFilter2::AlterQuality(Quality q)
{
    DbgLog((LOG_TRACE, 5, TEXT("QM: CLine21DecFilter2::AlterQuality(%s, %ld)"),
            Flood == q.Type ? TEXT("Flood") : TEXT("Famine"), q.Proportion)) ; // log trace=5

    if (1000 == q.Proportion)
    {
        DbgLog((LOG_TRACE, 5, TEXT("QM: Quality is just right.  Don't change anything."))) ;
        return S_OK ;
    }

    if (Flood == q.Type)    // Flood: too much output
    {
        if (q.Proportion > 500 && q.Proportion <= 900)
        {
            m_iSkipSamples += 1 ;
        }
        else if (q.Proportion > 300 && q.Proportion <= 500)
        {
            m_iSkipSamples += 2 ;
        }
        else if (q.Proportion <= 300)
        {
            m_iSkipSamples += 3 ;
        }
        m_iSkipSamples = min(m_iSkipSamples, 10) ;  // at least 1 in 10 is shown
    }
    else                    // Famine: send more output
    {
        if (q.Proportion > 1200)  // could take 20% more
        {
            m_iSkipSamples-- ;
            if (m_iSkipSamples < 0)
                m_iSkipSamples = 0 ;
        }
    }

    DbgLog((LOG_TRACE, 5, TEXT("QM: Adjusted rate is %d samples are skipped."), m_iSkipSamples)) ;
    return S_OK ;
}
#endif // #if 0 -- end of commented out AlterQuality() implementation


// Return our preferred output media types (in order)
// remember that we do not need to support all of these formats -
// if one is considered potentially suitable, our CheckTransform method
// will be called to check if it is acceptable right now.
// Remember that the enumerator calling this will stop enumeration as soon as
// it receives a S_FALSE return.
//
//  GetMediaType: Get our preferred media type (in order)
//
HRESULT CLine21DecFilter2::GetMediaType(int iPosition, CMediaType *pmt)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::GetMediaType(%d, 0x%lx)"),
            iPosition, pmt)) ;
    CAutoLock   Lock(&m_csFilter) ;

    LARGE_INTEGER       li ;
    CMediaType          cmt ;
    LPBITMAPINFOHEADER  lpbi ;

    if (NULL == pmt)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Media type is NULL, Sorry!!"))) ;
        return E_INVALIDARG ;
    }

    // Output choices depend on the input connected
    if (! m_pInput->CurrentMediaType().IsValid() )
    {
        DbgLog((LOG_TRACE, 3, TEXT("No input type set yet, Sorry!!"))) ;
        return E_FAIL ;
    }

    if (iPosition < 0)
    {
        return E_INVALIDARG ;
    }

    // Find the format info specified in the input VideoInfo struct
    cmt = m_pInput->CurrentMediaType() ;
    BITMAPINFOHEADER bih ;
    BOOL  bOutKnown = (S_OK == m_L21Dec.GetOutputOutFormat(&bih)) ;
    if (! bOutKnown )
    {
        HRESULT hr = m_L21Dec.GetOutputFormat(&bih) ;
        if (FAILED(hr))      // really weird!!!
            return E_FAIL ;  // we don't want to continue in such a case
    }

    BOOL bInKnown = NULL != cmt.Format() && IsValidFormat(cmt.Format()) ; // just to be sure
    VIDEOINFOHEADER vih ;
    if (bInKnown)
        CopyMemory(&vih, (VIDEOINFOHEADER *)(cmt.Format()), sizeof(VIDEOINFOHEADER)) ;

    // Offer the decoder's default output format (Video) first
    switch (iPosition)
    {
    case 0: // AI44
        {
            DbgLog((LOG_TRACE, 3, TEXT("Media Type 0: 8 bit AI44)"))) ;

            // First allocate enough space to hold the pertinent info
            cmt.ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER) + (3*sizeof(DWORD)));

            // Use some info from input format and use our choices too
            lpbi = HEADER(cmt.Format()) ;
            if (!bOutKnown && bInKnown) // output format not known and input format spec-ed
                CopyMemory(lpbi, &(vih.bmiHeader), sizeof(BITMAPINFOHEADER)) ;
            else  // if output format known or input format not spec-ed
                CopyMemory(lpbi, &bih, sizeof(BITMAPINFOHEADER)) ;
            lpbi->biBitCount = 8 ;
            lpbi->biCompression = '44IA' ; // AI44 byte swapped
            lpbi->biSizeImage = DIBSIZE(*lpbi) ;
            lpbi->biClrUsed = 0 ;  // for true color modes

            DWORD* pdw = (DWORD *)((LPBYTE)lpbi + lpbi->biSize);
            pdw[iRED]   = 0;
            pdw[iGREEN] = 0;
            pdw[iBLUE]  = 0;

            // Now set the output mediatype of type Video using the input
            // format info
            cmt.SetType(&MEDIATYPE_Video) ;
            cmt.SetSubtype(&MEDIASUBTYPE_AI44) ;
            break;
        }

    case 1:  // ARGB4444
        {
            DbgLog((LOG_TRACE, 3, TEXT("Media Type 0: 16 bit ARGB(4444)"))) ;

            // First allocate enough space to hold the pertinent info
            cmt.ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER) + (3*sizeof(DWORD)));

            // Use some info from input format and use our choices too
            lpbi = HEADER(cmt.Format()) ;
            if (!bOutKnown && bInKnown) // output format not known and input format spec-ed
                CopyMemory(lpbi, &(vih.bmiHeader), sizeof(BITMAPINFOHEADER)) ;
            else  // if output format known or input format not spec-ed
                CopyMemory(lpbi, &bih, sizeof(BITMAPINFOHEADER)) ;
            lpbi->biBitCount = 16 ;
            lpbi->biCompression = BI_BITFIELDS ; // use bitfields for RGB565
            lpbi->biSizeImage = DIBSIZE(*lpbi) ;
            lpbi->biClrUsed = 0 ;  // for true color modes

            DWORD* pdw = (DWORD *)((LPBYTE)lpbi + lpbi->biSize);
            pdw[iRED]   = 0x0F00;
            pdw[iGREEN] = 0x00F0;
            pdw[iBLUE]  = 0x000F;

            // Now set the output mediatype of type Video using the input
            // format info
            cmt.SetType(&MEDIATYPE_Video) ;
            cmt.SetSubtype(&MEDIASUBTYPE_ARGB4444) ;

            break ;
        }

    case 2:  // ARGB32
        {
            DbgLog((LOG_TRACE, 3, TEXT("Media Type 1: ARGB32 for VMR"))) ;

            // First allocate enough space to hold the pertinent info
            cmt.ReallocFormatBuffer(SIZE_PREHEADER + sizeof(BITMAPINFOHEADER));

            // Use some info from input format and use our choices too
            lpbi = HEADER(cmt.Format()) ;
            if (!bOutKnown && bInKnown) // output format not known and input format spec-ed
                CopyMemory(lpbi, &(vih.bmiHeader), sizeof(BITMAPINFOHEADER)) ;
            else  // if output format known or input format not spec-ed
                CopyMemory(lpbi, &bih, sizeof(BITMAPINFOHEADER)) ;
            lpbi->biBitCount = 32 ;
            lpbi->biCompression = BI_RGB ;
            lpbi->biSizeImage = DIBSIZE(*lpbi) ;
            lpbi->biClrUsed = 0 ;  // for true color modes

            // Now set the output mediatype of type Video using the input
            // format info
            cmt.SetType(&MEDIATYPE_Video) ;
            cmt.SetSubtype(&MEDIASUBTYPE_ARGB32) ;
            break ;
        }

    default:
        return VFW_S_NO_MORE_ITEMS ;

    }  // end of switch (iPosition)

    // Now set the output formattype and sample size
    cmt.SetSampleSize(lpbi->biSizeImage) ;
    cmt.SetFormatType(&FORMAT_VideoInfo) ;

    // The fields of VIDEOINFOHEADER needs to be filled now
    if (! bInKnown ) // if the upstream filter didn't specify anything
    {
        RECT  Rect ;
        Rect.left = 0 ;
        Rect.top = 0 ;
        Rect.right = lpbi->biWidth ;
        Rect.bottom = abs(lpbi->biHeight) ;  // biHeight could be -ve, but rect fields are +ve

        // We set some default values for time/frame, src and target rects etc. etc.
        li.QuadPart = (LONGLONG) 333667 ;  // => 29.97 fps
        ((VIDEOINFOHEADER *)(cmt.pbFormat))->AvgTimePerFrame = (LONGLONG) 333667 ;  // => 29.97 fps
        ((VIDEOINFOHEADER *)(cmt.pbFormat))->rcSource = Rect ;
        ((VIDEOINFOHEADER *)(cmt.pbFormat))->rcTarget = Rect ;
    }
    else
        li.QuadPart = vih.AvgTimePerFrame ;

    ((VIDEOINFOHEADER *)(cmt.pbFormat))->dwBitRate =
        MulDiv(lpbi->biSizeImage, 80000000, li.LowPart) ;
    ((VIDEOINFOHEADER *)(cmt.pbFormat))->dwBitErrorRate = 0L ;

    // Set temporal compression and copy the prepared data now
    cmt.SetTemporalCompression(FALSE) ;
    *pmt = cmt ;

    return NOERROR ;
}


//
//  DecideBufferSize: Called from CBaseOutputPin to prepare the allocator's
//                    count of buffers and sizes.  It makes sense only when
//                    the input is connected.
//
HRESULT CLine21DecFilter2::DecideBufferSize(IMemAllocator * pAllocator,
                                           ALLOCATOR_PROPERTIES *pProperties)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::DecideBufferSize(0x%lx, 0x%lx)"),
            pAllocator, pProperties)) ;
    CAutoLock   Lock(&m_csFilter) ;

    // Is the input pin connected
    if (! m_pInput->IsConnected())
    {
        return E_UNEXPECTED ;
    }

    ASSERT(m_pOutput->CurrentMediaType().IsValid()) ;
    ASSERT(pAllocator) ;
    ASSERT(pProperties) ;

    // set the size of buffers based on the expected output bitmap size, and
    // the count of buffers to 1.
    pProperties->cBuffers = 1 ;
    pProperties->cbBuffer = m_pOutput->CurrentMediaType().GetSampleSize() ;

    ASSERT(pProperties->cbBuffer) ;

    ALLOCATOR_PROPERTIES Actual ;
    HRESULT hr = pAllocator->SetProperties(pProperties, &Actual) ;
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 0, TEXT("Error (0x%lx) in SetProperties()"), hr)) ;
        return hr ;
    }

    if (Actual.cbBuffer < pProperties->cbBuffer  ||
        Actual.cBuffers  < pProperties->cBuffers)
    {
        // can't use this allocator
        DbgLog((LOG_ERROR, 0, TEXT("Can't use allocator (only %d buffer of size %d given)"),
            Actual.cBuffers, Actual.cbBuffer)) ;
        return E_INVALIDARG ;
    }
    DbgLog((LOG_TRACE, 3, TEXT("    %d buffers of %ld bytes each"),
        pProperties->cBuffers, pProperties->cbBuffer)) ;

    ASSERT(Actual.cbAlign == 1) ;
    ASSERT(Actual.cbPrefix == 0) ;

    return S_OK ;
}

// We're stopping the stream -- stop output thread, release cached data and pointers
STDMETHODIMP CLine21DecFilter2::Stop(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::Stop()"))) ;

    // First stop the output thread and clear the input sample queue
    m_OutputThread.Close() ;
    m_InSampleQueue.Close() ;

    CAutoLock   Lock1(&m_csFilter) ;   // first take the filter lock
    CAutoLock   Lock2(&m_csReceive) ;  // take receive lock to block Receive()
    if (State_Running == m_State  ||
        State_Paused  == m_State)
    {
        DbgLog((LOG_TRACE, 1, TEXT("We are stopping"))) ;

        // After stop, we should clear out all states -- CC data and DDRaw surface both
        m_L21Dec.SetDDrawSurface(NULL) ;  // DDraw output surface may not be available
        m_L21Dec.FlushInternalStates() ;  // ... and clear CC internal state

        SetBlendingState(FALSE) ;  // we are done with blending for now

        // Release the downstream pin's interface now
        if (m_pPinDown)
        {
            m_pPinDown->Release() ;
            m_pPinDown = NULL ;
        }
    }

    HRESULT hr = CTransformFilter::Stop() ;

    return hr ;
}

// We're starting/stopping to stream -- based on that acquire or release output DC
// to reduce memory footprint etc.
STDMETHODIMP CLine21DecFilter2::Pause(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::Pause()"))) ;
    CAutoLock   Lock(&m_csFilter) ;

    if (State_Stopped == m_State)
    {
        //  Try to make sure we have at least 2 buffers
        IMemAllocator *pAlloc;
        if (SUCCEEDED(m_pInput->GetAllocator(&pAlloc))) {
            ALLOCATOR_PROPERTIES props;
            ALLOCATOR_PROPERTIES propsActual;
            pAlloc->GetProperties(&props);
            if (props.cBuffers < 4) {
                props.cBuffers = 4;
                props.cbBuffer = 200;
                props.cbAlign = max(props.cbAlign, 1);
                props.cbPrefix = 0;
                HRESULT hr = pAlloc->SetProperties(&props, &propsActual);
                DbgLog((LOG_TRACE, 2, TEXT("Setproperties returned %8.8X"), hr));
            }
            pAlloc->Release();
        }

        // We are starting a new play session; we do an exception to allow
        // the first output sample to be sent down even if the first sample
        // isn't valid for decoding.
        m_bMustOutput = TRUE ;   // we are pausing again for this new play session
        m_bDiscontLast = FALSE ; // no discontinuity from prev session remembered
        m_rtLastOutStop = (LONGLONG) 0 ;  // reset the last sample sent time
        m_eGOP_CCType = GOP_CCTYPE_Unknown ;  // reset GOP packet CC type

        // If we somehow didn't release the prev downstream pin's interface, do that now
        if (m_pPinDown)
        {
            DbgLog((LOG_ERROR, 1, TEXT("WARNING: downstream pin interface wasn't released properly"))) ;
            m_pPinDown->Release() ;
            m_pPinDown = NULL ;
        }

        // Get the downstream pin's interface so that we can set rects on it later on
        m_pOutput->ConnectedTo(&m_pPinDown) ;
        if (NULL == m_pPinDown)
        {
            DbgLog((LOG_TRACE, 3, TEXT("Running w/o connecting our output pin!!!"))) ;
            // ASSERT(m_pPinDown) ;
        }
        else
        {
            DbgLog((LOG_TRACE, 5, TEXT("L21D Output pin connected to %s"), (LPCTSTR)CDisp(m_pPinDown))) ;
            SetBlendingState(FALSE) ;  // keep it off until we get data
        }

        if (! m_InSampleQueue.Create() )
        {
            DbgLog((LOG_TRACE, 1, TEXT("ERROR: Failed creating input sample queue (events)"))) ;
            return E_FAIL ;
        }

        m_bEndOfStream = FALSE ;  // we are starting to run

#if 0  // No QM for now
        // Reset the sample skipping count for QM handling
        ResetSkipSamples() ;
#endif // #if 0
    }
    else if (State_Running == m_State)
    {
        DbgLog((LOG_TRACE, 1, TEXT("We are pausing from running"))) ;  // 1
    }

    return CTransformFilter::Pause() ;
}


STDMETHODIMP CLine21DecFilter2::Run(REFERENCE_TIME tStart)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::Run()"))) ;
    CAutoLock   Lock(&m_csFilter) ;

    // if (m_pPinDown)  // the output pin is connected; otherwise don't output!!!
    {
        // Start the output thread now
        if (!m_OutputThread.Create())
        {
            DbgLog((LOG_TRACE, 1, TEXT("ERROR: Failed creating output thread"))) ;
            return E_FAIL ;
        }
    }

    // return CBaseFilter::Run(tStart) ;
    return CTransformFilter::Run(tStart) ;
}


//
// we don't send any data during PAUSE, so to avoid hanging renderers, we
// need to return VFW_S_CANT_CUE when paused
//
HRESULT CLine21DecFilter2::GetState(DWORD dwMSecs, FILTER_STATE *State)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::GetState()"))) ;
    CAutoLock   Lock(&m_csFilter) ;

    UNREFERENCED_PARAMETER(dwMSecs) ;
    CheckPointer(State, E_POINTER) ;
    ValidateReadWritePtr(State, sizeof(FILTER_STATE)) ;

    *State = m_State ;
    if (m_State == State_Paused)
        return VFW_S_CANT_CUE ;
    else
        return S_OK ;
}


AM_LINE21_CCSUBTYPEID CLine21DecFilter2::MapGUIDToID(const GUID *pFormatIn)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DecFilter2::MapGUIDToID(0x%lx)"), pFormatIn)) ;

    if (MEDIASUBTYPE_Line21_BytePair        == *pFormatIn)
        return AM_L21_CCSUBTYPEID_BytePair ;
    else if (MEDIASUBTYPE_Line21_GOPPacket  == *pFormatIn)
        return AM_L21_CCSUBTYPEID_GOPPacket ;
    // else if (MEDIASUBTYPE_Line21_VBIRawData == *pFormatIn)
    //     return AM_L21_CCSUBTYPEID_VBIRawData ;
    else
        return AM_L21_CCSUBTYPEID_Invalid ;
}


//
// CLine21OutputThread: Line21 output thread class implementation
//
CLine21OutputThread::CLine21OutputThread(CLine21DecFilter2 *pL21DFilter) :
m_pL21DFilter(pL21DFilter),
m_hThread(NULL),
m_hEventEnd(NULL),
m_hEventMustOutput(NULL)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21OutputThread::CLine21OutputThread()"))) ;
}


CLine21OutputThread::~CLine21OutputThread()
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21OutputThread::~CLine21OutputThread()"))) ;

    Close() ;
    m_pL21DFilter = NULL ;
}


BOOL CLine21OutputThread::Create()
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21OutputThread::Create()"))) ;

    CAutoLock lock(&m_AccessLock) ;

    HRESULT hr = NOERROR;

    if (NULL == m_hThread)
    {
        m_hEventEnd = CreateEvent(NULL, TRUE, FALSE, NULL) ;
        m_hEventMustOutput = CreateEvent(NULL, TRUE, FALSE, NULL) ;
        if (m_hEventEnd != NULL  &&  m_hEventMustOutput != NULL)
        {
            DWORD  dwThreadId ;
            m_hThread = ::CreateThread
                ( NULL
                , 0
                , reinterpret_cast<LPTHREAD_START_ROUTINE>(InitialThreadProc)
                , reinterpret_cast<LPVOID>(this)
                , 0
                , &dwThreadId
                ) ;
            if (NULL == m_hThread)
            {
                hr = HRESULT_FROM_WIN32(GetLastError()) ;
                DbgLog((LOG_ERROR, 0, TEXT("Couldn't create a thread"))) ;

                CloseHandle(m_hEventEnd), m_hEventEnd = NULL ;
                return FALSE ;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError()) ;
            DbgLog((LOG_ERROR, 0, TEXT("Couldn't create an event"))) ;
            if (m_hEventMustOutput)
            {
                CloseHandle(m_hEventMustOutput) ;
                m_hEventMustOutput = NULL ;
            }
            if (m_hEventEnd)
            {
                CloseHandle(m_hEventEnd) ;
                m_hEventEnd = NULL ;
            }
            return FALSE ;
        }
    }

    return TRUE ;
}


void CLine21OutputThread::Close()
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21OutputThread::Close()"))) ;

    CAutoLock lock(&m_AccessLock) ;

    //
    // Check if a thread was created
    //
    if (m_hThread)
    {
        ASSERT(m_hEventEnd != NULL) ;

        //  Tell the thread to exit
        if (SetEvent(m_hEventEnd))
        {
            //
            // Synchronize with thread termination.
            //
            DbgLog((LOG_TRACE, 5, TEXT("Wait for thread to terminate..."))) ;

            HANDLE hThread = (HANDLE)InterlockedExchangePointer(&m_hThread, 0) ;
            if (hThread)
            {
                WaitForSingleObject(hThread, INFINITE) ;
                CloseHandle(hThread) ;
            }
            CloseHandle(m_hEventEnd), m_hEventEnd = NULL ;
            CloseHandle(m_hEventMustOutput), m_hEventMustOutput = NULL ;
        }
        else
            DbgLog((LOG_ERROR, 0, TEXT("ERROR: Couldn't signal end event (0x%lx)"), GetLastError())) ;
    }
}


void CLine21OutputThread::SignalForOutput()
{
    CAutoLock lock(&m_AccessLock) ;

    if (m_hThread)
    {
        ASSERT(m_hEventMustOutput != NULL) ;

        SetEvent(m_hEventMustOutput) ;
    }
}


DWORD WINAPI CLine21OutputThread::InitialThreadProc(CLine21OutputThread * pThread)
{
    return pThread->OutputThreadProc() ;
}


DWORD CLine21OutputThread::OutputThreadProc()
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21OutputThread::OutputThreadProc()"))) ;

    HANDLE aEventHandles[2] = {m_hEventEnd, m_hEventMustOutput} ;

    while (TRUE)
    {
        // We are going to wait for a short period of time (the delay is to
        // ensure that we don't get blocked too early and thereby delay the 
        // processing of samples or make them in bunches).  Even though we are 
        // going to try start preparing the next frame quite early, we'll be 
        // throttled by the VMR in the GetDeliveryBuffer() call, which will make
        // the interval between successive outputs from us ~33 mSecs apart,
        // which is ideal.
        DWORD dw = WaitForMultipleObjects(NUMELMS(aEventHandles), aEventHandles,
                                FALSE, 10) ;  // wait for "some" time (33 before)
        switch (dw)
        {
        case WAIT_OBJECT_0:
            DbgLog((LOG_TRACE, 1, TEXT("End event has been signaled"))) ;
            ResetEvent(m_hEventEnd) ;
            return 1 ;

        case WAIT_OBJECT_0 + 1:
            DbgLog((LOG_TRACE, 1, TEXT("Must output event has been signaled"))) ;
            ResetEvent(m_hEventMustOutput) ;
            break ;

        case WAIT_TIMEOUT:
            DbgLog((LOG_TRACE, 5, TEXT("Wait is over. Should we deliver a sample?"))) ;
            break ;

        default:
            DbgLog((LOG_ERROR, 1, TEXT("Something wrong has happened during wait (dw = 0x%lx)"), dw)) ;
            return 1 ;
        }

        // We "may have to" send an output sample now
        HRESULT hr = m_pL21DFilter->SendOutputSampleIfNeeded() ;

    }  // end of while () loop

    return 1 ; // shouldn't get here
}



//
// CLine21InSampleQueue: Line21 Input Sample Queue class implementation
//
CLine21InSampleQueue::CLine21InSampleQueue() :
m_hEventEnd(NULL),
m_hEventSample(NULL),
m_iCount(0),
m_List(NAME("Line21 In-sample List"), Max_Input_Sample)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21InSampleQueue::CLine21InSampleQueue()"))) ;
}


CLine21InSampleQueue::~CLine21InSampleQueue()
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21InSampleQueue::~CLine21InSampleQueue()"))) ;
    Close() ;
}


BOOL CLine21InSampleQueue::Create()
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21InSampleQueue::Create()"))) ;

    CAutoLock lock(&m_AccessLock) ;

    ASSERT(NULL == m_hEventEnd  &&  NULL == m_hEventSample) ;
    m_hEventEnd    = CreateEvent(NULL, TRUE, FALSE, NULL) ; // not signalled
    if (NULL == m_hEventEnd)
    {
        ASSERT(m_hEventEnd) ;
        return FALSE ;
    }
    m_hEventSample = CreateEvent(NULL, TRUE, TRUE, NULL) ;  // SIGNALLED => OK to add
    if (NULL == m_hEventSample)
    {
        ASSERT(m_hEventSample) ;
        CloseHandle(m_hEventEnd) ;  // else we leak a handle
        return FALSE ;
    }
    m_iCount = 0 ;
    return TRUE ;
}


void CLine21InSampleQueue::Close()
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21InSampleQueue::Close()"))) ;

    // First signal the end event, so that any waiting thread is unblocked
    if (m_hEventEnd)
        SetEvent(m_hEventEnd) ;

    // Now take the lock and proceed to clear out...
    CAutoLock lock(&m_AccessLock) ;

    // First release all queued up media samples
    IMediaSample  *pSample ;
    for (int i = 0 ; i < m_iCount ; i++)
    {
        pSample = m_List.RemoveHead() ;
        if (pSample)
            pSample->Release() ;
    }
    m_iCount = 0 ;

    // Close event handles now
    if (m_hEventEnd)
    {
        CloseHandle(m_hEventEnd) ;
        m_hEventEnd = NULL ;
    }
    if (m_hEventSample)
    {
        CloseHandle(m_hEventSample) ;
        m_hEventSample = NULL ;
    }
}


BOOL CLine21InSampleQueue::AddItem(IMediaSample *pSample)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21InSampleQueue::AddItem()"))) ;  // LOG_TRACE = 0

    m_AccessLock.Lock() ;  // we'll do selective locking

    // If there are too many samples in queue => wait for some processing
    if (m_iCount >= Max_Input_Sample)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Queue full.  Waiting for free slot..."))) ;
        HANDLE aEventHandles[2] = {m_hEventEnd, m_hEventSample} ;
        m_AccessLock.Unlock() ;  // don't keep the lock as that would block others
        DWORD dw = WaitForMultipleObjects(NUMELMS(aEventHandles), aEventHandles,
                                FALSE, INFINITE) ;
        m_AccessLock.Lock() ;    // re-acquire lock before proceeding

        switch (dw)
        {
        case WAIT_OBJECT_0:
            DbgLog((LOG_TRACE, 1, TEXT("End event has been signaled"))) ;
            // ResetEvent(m_hEventEnd) ;  -- we should never reset the end event
            m_AccessLock.Unlock() ;  // unlock before leaving
            return FALSE ;

        case WAIT_OBJECT_0 + 1:
            DbgLog((LOG_TRACE, 5, TEXT("Sample queue event has been signaled"))) ;
            ASSERT(m_iCount < Max_Input_Sample) ;
            // ResetEvent(m_hEventSample) ; -- shouldn't reset here
            break ;

        case WAIT_TIMEOUT:
            // We should never come here, but...
            m_AccessLock.Unlock() ;  // unlock before leaving
            return FALSE ;

        default:
            DbgLog((LOG_ERROR, 0, TEXT("Something wrong has happened during wait (dw = 0x%lx)"), dw)) ;
            ResetEvent(m_hEventSample) ;  // next RemoveItem() will set it again
            m_AccessLock.Unlock() ;  // unlock before leaving
            return FALSE ;
        }
    }  // end of if (m_iCount >= ...)

    // Now add new media sample to queue
    DbgLog((LOG_TRACE, 1, TEXT("Adding new sample to queue after %d"), m_iCount)) ;  // LOG_TRACE = 5
    if (m_List.AddTail(pSample))
    {
        pSample->AddRef() ;  // we must hold onto the sample until we process it
        m_iCount++ ;
        if (m_iCount >= Max_Input_Sample)
        {
            DbgLog((LOG_TRACE, 3, TEXT("Input sample queue is full"))) ;
            ResetEvent(m_hEventSample) ;  // next RemoveItem() will set it again
        }

        m_AccessLock.Unlock() ;  // release before leaving function
        return TRUE ;
    }
    m_AccessLock.Unlock() ;  // release before leaving function
    ASSERT(!"Couldn't add media sample to queue") ;
    return FALSE ;
}


IMediaSample* CLine21InSampleQueue::PeekItem()
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21InSampleQueue::PeekItem()"))) ;

    CAutoLock lock(&m_AccessLock) ;

    IMediaSample *pSample = m_List.GetHead() ;
    if (pSample)
    {
        DbgLog((LOG_TRACE, 5, TEXT("There are %d samples left in the queue"), m_iCount)) ;
    }
    return pSample ;
}


IMediaSample* CLine21InSampleQueue::RemoveItem()
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21InSampleQueue::RemoveItem()"))) ;

    CAutoLock lock(&m_AccessLock) ;

    IMediaSample *pSample = m_List.RemoveHead() ;
    if (pSample)
    {
        m_iCount-- ;
        ASSERT(m_iCount < Max_Input_Sample) ;
        DbgLog((LOG_TRACE, 5, TEXT("Got a sample from queue -- %d left"), m_iCount)) ;
        SetEvent(m_hEventSample) ;  // Can add samples again
    }
    return pSample ;
}


void CLine21InSampleQueue::ClearQueue()
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21InSampleQueue::ClearQueue()"))) ;

    CAutoLock lock(&m_AccessLock) ;

    // First release all queued up media samples
    IMediaSample  *pSample ;
    for (int i = 0 ; i < m_iCount ; i++)
    {
        pSample = m_List.RemoveHead() ;
        if (pSample)
            pSample->Release() ;
    }
    m_iCount = 0 ;

    SetEvent(m_hEventSample) ;  // ready to take samples again
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\lin21dec2\l21dbase.h ===
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.

//
// L21DBase.h: Line 21 Decoder 2 Base class code
//

#ifndef _INC_L21DBASE_H
#define _INC_L21DBASE_H

// Just a few macro definitions
#define ABS(x) (((x) > 0) ? (x) : -(x))
#define LPBMIHEADER(bmi) &((bmi)->bmiHeader)
#define DWORDALIGN(n)  (((n) + 3) & ~0x03)
#define ISDWORDALIGNED(n)  (0 == ((n) & 0x03))
#define DWORDALIGNWIDTH(bmih) (((((bmih).biWidth * (bmih).biBitCount) + 31) & ~31) >> 3)
#define MAKECCCHAR(b1, b2)  ((b1) << 8 | (b2))

//
//  Caption character attribs set by PACs and/or mid-row codes
//
#define UINT8   unsigned char
#define UINT16  unsigned short int

#define AM_L21_FGCOLOR_WHITE             0x00
#define AM_L21_FGCOLOR_GREEN             0x01
#define AM_L21_FGCOLOR_BLUE              0x02
#define AM_L21_FGCOLOR_CYAN              0x03
#define AM_L21_FGCOLOR_RED               0x04
#define AM_L21_FGCOLOR_YELLOW            0x05
#define AM_L21_FGCOLOR_MAGENTA           0x06
#define AM_L21_FGCOLOR_MASK              0x07

#define AM_L21_FGEFFECT_ITALICS          0x08
#define AM_L21_FGEFFECT_UNDERLINE        0x10
#define AM_L21_FGEFFECT_FLASHING         0x20
#define AM_L21_FGEFFECT_MASK             0x38

#define AM_L21_ATTRIB_DIRTY              0x40
#define AM_L21_ATTRIB_MRC                0x80

//
// Caption width and height
//
#define CAPTION_OUTPUT_WIDTH  640  /* 320 */
#define CAPTION_OUTPUT_HEIGHT 480  /* 240 */


//
// Forward declarations
//
class CCaptionChar ;
class CCaptionLine ;
class CRowIndexMap ;
class CCaptionBuffer ;
class CPopOnCaption ;


//
//  The max's of rows and columns
//
const int MAX_CAPTION_COLUMNS = 32 ;  // max # of column / line
const int MAX_CAPTION_ROWS    = 15 ;  // number of rows available on screen
const int MAX_CAPTION_LINES   = 4 ;   // max # of caption text at a time
// for text mode, add MAX_TEXT_LINES = 15 ;


//
//  CCaptionChar: The caption char details
//
class CCaptionChar {
private:
    UINT16 m_wChar ;     // actual char
    UINT8  m_uAttrib ;   // CC char attrib bits -- FG color, effect, dirty, MRC etc.
    //
    // The layout of bits (LSB -> MSB) of CC char attribs --
    //    0 - 2: color (0 -> 6 for White -> Magenta)
    //    3 - 5: effects (3: Italics, 4: Underline, 5: Flash)
    //        6: dirty (is the CC char dirty, i.e, needs to written?)
    //        7: is it a mid-row code (carries attrib, shown as opaque space)?
    //
    
public:
    inline CCaptionChar(void) {
        m_wChar   = 0 ;
        m_uAttrib = 0 ;
    } ;
    
    inline UINT16 GetChar(void) const  { return m_wChar ; } ;
    inline CCaptionChar& operator = (const CCaptionChar& cc) {
        m_wChar   = cc.m_wChar ;
        m_uAttrib = cc.m_uAttrib ;
        return *this ;
    } ;
    inline BOOL  operator == (const CCaptionChar& cc) const {
        return (m_wChar   == cc.m_wChar  &&
                m_uAttrib == cc.m_uAttrib) ;
    } ;
    inline BOOL  operator != (const CCaptionChar& cc) const {
        if (*this == cc)  return FALSE ;
        else              return TRUE ;
    } ;
    inline BOOL  IsEqualAttrib(CCaptionChar cc) const {
        return (GetColor()  == cc.GetColor()  &&
                GetEffect() == cc.GetEffect()) ;
    } ;
    inline UINT8 GetColor(void) const      { return  m_uAttrib & AM_L21_FGCOLOR_MASK ; } ;
    inline UINT8 GetEffect(void) const     { return (m_uAttrib & AM_L21_FGEFFECT_MASK) >> 3 ; } ;
    inline BOOL  IsItalicized(void) const  { return (0 != (m_uAttrib & AM_L21_FGEFFECT_ITALICS)) ; } ;
    inline BOOL  IsUnderLined(void) const  { return (0 != (m_uAttrib & AM_L21_FGEFFECT_UNDERLINE)) ; } ;
    inline BOOL  IsFlashing(void) const    { return (0 != (m_uAttrib & AM_L21_FGEFFECT_FLASHING)) ; } ;
    inline BOOL  IsDirty(void) const       { return (0 != (m_uAttrib & AM_L21_ATTRIB_DIRTY)) ; } ;
    inline BOOL  IsMidRowCode(void) const  { return (0 != (m_uAttrib & AM_L21_ATTRIB_MRC)) ; } ;
    void  SetChar(UINT16 wChar) ;
    void  SetColor(UINT8 uColor) ;
    void  SetEffect(UINT8 uEffect) ;
    void  SetItalicized(BOOL bState) ;
    void  SetUnderLined(BOOL bState) ;
    void  SetFlashing(BOOL bState) ;
    void  SetDirty(BOOL bState) ;
    void  SetMidRowCode(BOOL bState) ;

} ;


//
//  CCaptionLine: The caption line details
//
class CCaptionLine {
protected:  // not private
    CCaptionChar m_aCapChar[MAX_CAPTION_COLUMNS] ;  // char details of line
    UINT8        m_uNumChars ;      // number of chars in the line
    UINT8        m_uStartRow ;      // start row of the line
    
public:
    CCaptionLine(void) ;
    CCaptionLine(const UINT uStartRow, const UINT uNumChars = 0) ;
    
    CCaptionLine& operator = (const CCaptionLine& cl) ;
    
    inline int   GetNumChars(void) const  { return m_uNumChars ; } ;
    inline void  SetNumChars(UINT uNumChars)  { m_uNumChars = uNumChars & 0x3F ; } ;
    int IncNumChars(UINT uNumChars) ;
    int DecNumChars(UINT uNumChars) ;
    inline void  GetCaptionChar(UINT uCol, CCaptionChar &cc) const {
        if (uCol >= (UINT)MAX_CAPTION_COLUMNS)   // error!!
            return ;
        cc = m_aCapChar[uCol] ;
    } ;
    void SetCaptionChar(UINT uCol, const CCaptionChar &cc) ;
    CCaptionChar* GetCaptionCharPtr(UINT uCol) ;
    inline int  GetStartRow(void)  { return m_uStartRow ; } ;
    void SetStartRow(UINT uRow) ;
    inline CCaptionChar* GetLineText(void) { return (CCaptionChar *) m_aCapChar ; }
    void MoveCaptionChars(int iNum) ;
    void ClearLine(void) ;

} ;

//
//  CRowIndexMap: Mapping of row usage (row to text line)
//
class CRowIndexMap {
private:
    DWORD         m_adwMap[2] ;  // bit map of row usage
    
public:
    inline CRowIndexMap(void)  { ClearRowIndex() ; }
    
    DWORD GetMap(int i) { 
        if (! (0 == i || 1 == i) )
            return 0 ;
        return m_adwMap[i] ; 
    } ;
    int  GetRowIndex(UINT8 uRow) ;
    void SetRowIndex(UINT uLine, UINT8 uRow) ;
    inline void ClearRowIndex(void)  { m_adwMap[0] = m_adwMap[1] = 0 ; } ;
} ;


//
//  A set of flags and consts for caption buffer dirty state info
//
#define L21_CAPBUFFER_REDRAWALL     0x01
#define L21_CAPBUFFER_DIRTY         0x02
#define L21_CAPBUFFDIRTY_FLAGS      2


//
//  CCaptionBuffer: The caption buffer class details
//
class CCaptionBuffer {
protected:  // private
    CCaptionLine  m_aCapLine[MAX_CAPTION_LINES + 1] ;  // shall we always have an extra line? It's easier this way!!
    CRowIndexMap  m_RowIndex ;     // row index map bits
    UINT8         m_uNumLines ;    // # lines
    UINT8         m_uMaxLines ;    // max # lines (4 or less)
    UINT8         m_uCurrCol ;     // current column on the screen
    UINT8         m_uCurrLine ;    // max 4: maps row # to array index
    UINT8         m_uCaptionStyle ;// 0 = None, 1 = Pop-On, 2 = Paint-On, 3 = Roll-Up
    UINT8         m_uDirtyState ;  // caption buffer dirty state flags
    
public:
    CCaptionBuffer(UINT8 uStyle    = AM_L21_CCSTYLE_None, 
                   UINT8 uMaxLines = MAX_CAPTION_LINES) ;
    CCaptionBuffer(/* const */ CCaptionBuffer &cb) ;
    
    inline int  GetNumLines(void)  { return m_uNumLines ; } ;
    inline int  GetMaxLines(void)  { return m_uMaxLines ; } ;
    inline int  GetCurrRow(void)   { return m_aCapLine[m_uCurrLine].GetStartRow() ; } ;
    inline int  GetCurrCol(void)   { return m_uCurrCol ; } ;  // Why do we need it??
    inline int  GetCurrLine(void)  { return m_uCurrLine ; } ;
    inline int  GetRowIndex(UINT uRow)   { return m_RowIndex.GetRowIndex((UINT8)uRow) ; } ;
    inline int  GetStyle(void)     { return m_uCaptionStyle ; } ;
    
    inline void SetNumLines(int uNumLines)  { m_uNumLines = uNumLines & 0x7 ; } ;
    inline void SetMaxLines(int uMaxLines)  { 
        ASSERT(m_uMaxLines >= 0 && m_uMaxLines <= MAX_CAPTION_LINES) ;
        m_uMaxLines = uMaxLines & 0x7 ; 
    } ;
    inline void SetCurrRow(int uCurrRow)    {
        ASSERT(m_uCurrLine >= 0 && m_uCurrLine < m_uMaxLines) ;
        m_aCapLine[m_uCurrLine].SetStartRow(uCurrRow) ; 
    } ;
    void SetCurrCol(int uCurrCol) ;
    inline void SetCurrLine(int uLine)      { m_uCurrLine = uLine & 0x7 ; } ;
    inline void SetRowIndex(UINT uLine, UINT uRow)   { m_RowIndex.SetRowIndex(uLine, (UINT8)uRow) ; } ;
    inline void SetStyle(UINT8 uStyle)      { m_uCaptionStyle = uStyle ; } ;
    
    inline CCaptionLine& GetCaptionLine(UINT uLine)  {
        // uLine is assumed to have been verified in the caller
        return m_aCapLine[uLine] ;
    } ;
    void SetCaptionLine(UINT uLine, const CCaptionLine& cl) ;
    void ClearCaptionLine(UINT uLine) ;
    int  IncCurrCol(UINT uNumChars) ;
    int  DecCurrCol(UINT uNumChars) ;
    void ClearBuffer(void) ;
    void InitCaptionBuffer(void) ;
    int  IncNumLines(int uLines) ;
    int  DecNumLines(int uLines) ;
    CRowIndexMap& GetRowIndexMap(void)  { return m_RowIndex ; } ;
    void RemoveLineFromBuffer(UINT8 uLine, BOOL bUpNextLine) ;
    
    inline int  GetStartRow(UINT uLine) {
        return m_aCapLine[uLine].GetStartRow() ;
    } ;
    void SetStartRow(UINT uLine, UINT uRow) ;
    inline void GetCaptionChar(UINT uLine, UINT uCol, CCaptionChar& cc) {
        m_aCapLine[uLine].GetCaptionChar(uCol, cc) ;
    } ;
    inline void SetCaptionChar(UINT uLine, UINT uCol, const CCaptionChar& cc) {
        m_aCapLine[uLine].SetCaptionChar(uCol, cc) ;
    } ;
    inline CCaptionChar* GetCaptionCharPtr(UINT uLine, UINT uCol) {
        return m_aCapLine[uLine].GetCaptionCharPtr(uCol) ;
    } ;
    inline int IncNumChars(int uLine, UINT uNumChars) {
        return m_aCapLine[uLine].IncNumChars(uNumChars) ;
    } ;
    inline int DecNumChars(int uLine, UINT uNumChars) {
        return m_aCapLine[uLine].DecNumChars(uNumChars) ;
    } ;
    inline void MoveCaptionChars(int uLine, int iNum) {
        m_aCapLine[uLine].MoveCaptionChars(iNum) ;
    } ;
    
    inline BOOL IsBufferDirty(void)  { return m_uDirtyState & L21_CAPBUFFER_DIRTY ; } ;
    inline BOOL IsRedrawAll(void)    { return m_uDirtyState & L21_CAPBUFFER_REDRAWALL ; } ;

    BOOL IsRedrawLine(UINT8 uLine) ;
    void SetBufferDirty(BOOL bState) ;
    void SetRedrawAll(BOOL bState) ;
    void SetRedrawLine(UINT8 uLine, BOOL bState) ;
} ;

#endif // #ifndef _INC_L21DBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\lin21dec2\l21dfilt.h ===
//
// Copyright (c) 1996 - 2000  Microsoft Corporation.  All Rights Reserved.
//
// DirectShow Line 21 Decoder 2 filter
//

// forward declaration
class CLine21DecFilter2 ;
class CLine21OutputThread ;

extern const AMOVIESETUP_FILTER sudLine21Dec2 ;

#ifndef _INC_L21DFILT_H
#define _INC_L21DFILT_H

#pragma pack(push, 1)

//
//  DVD Line21 data come as a user data packet from the GOP header.
//  A struct for per frame/field based data and a valid flag definition.
//
//  From DVD specifications...
#define AM_L21_GOPUD_HDR_STARTCODE      0x000001B2
#define AM_L21_GOPUD_HDR_INDICATOR      0x4343
#define AM_L21_GOPUD_HDR_RESERVED       0x01F8
#define AM_L21_GOPUD_HDR_TOPFIELD_FLAG  0x1
#define AM_L21_GOPUD_ELEM_MARKERBITS    0x7F
#define AM_L21_GOPUD_ELEM_VALIDFLAG     0x1
// There can be max 63 frames/fields' worth data per packet as there are 
// 6 bits to represent this number in the packet.
#define AM_L21_GOPUD_ELEMENT_MAX        63

typedef struct _AM_L21_GOPUD_ELEMENT {
    BYTE        bMarker_Switch ;
    BYTE        chFirst ;
    BYTE        chSecond ;
} AM_L21_GOPUD_ELEMENT, *PAM_L21_GOPUD_ELEMENT ;

typedef struct _AM_L21_GOPUD_HEADER {
    BYTE        abL21StartCode[4] ;
    BYTE        abL21Indicator[2] ;
    BYTE        abL21Reserved[2] ;
    BYTE        bTopField_Rsrvd_NumElems ;
} AM_L21_GOPUD_HEADER, *PAM_L21_GOPUD_HEADER ;

typedef struct _AM_L21_GOPUD_PACKET {
    AM_L21_GOPUD_HEADER   Header ;
    AM_L21_GOPUD_ELEMENT  aElements[AM_L21_GOPUD_ELEMENT_MAX] ;
} AM_L21_GOPUD_PACKET, *PAM_L21_GOPUD_PACKET ;

#define GETGOPUD_NUMELEMENTS(pGOPUDPacket) ((pGOPUDPacket)->Header.bTopField_Rsrvd_NumElems & 0x3F)
#define GETGOPUD_PACKETSIZE(pGOPUDPacket)  (LONG)(sizeof(AM_L21_GOPUD_HEADER) + GETGOPUD_NUMELEMENTS(pGOPUDPacket) * sizeof(AM_L21_GOPUD_ELEMENT))
#define GETGOPUDPACKET_ELEMENT(pGOPUDPacket, i) ((pGOPUDPacket)->aElements[i])
#define GETGOPUD_ELEM_MARKERBITS(Elem)     ((((Elem).bMarker_Switch & 0xFE) >> 1) & 0x7F)
#define GETGOPUD_ELEM_SWITCHBITS(Elem)     ((Elem).bMarker_Switch & 0x01)

#define GETGOPUD_L21STARTCODE(Header)             \
    ( (DWORD)((Header).abL21StartCode[0]) << 24 | \
      (DWORD)((Header).abL21StartCode[1]) << 16 | \
      (DWORD)((Header).abL21StartCode[2]) <<  8 | \
      (DWORD)((Header).abL21StartCode[3]) )
#define GETGOPUD_L21INDICATOR(Header)             \
    ( (DWORD)((Header).abL21Indicator[0]) << 8 |  \
      (DWORD)((Header).abL21Indicator[1]) )
#define GETGOPUD_L21RESERVED(Header)              \
    ( (DWORD)((Header).abL21Reserved[0]) << 8  |  \
      (DWORD)((Header).abL21Reserved[1]) )

#define GOPUD_HEADERLENGTH   (4+2+2+1)
#define GETGOPUD_ELEMENT(pGOPUDPkt, i)  (pGOPUDPkt + GOPUD_HEADERLENGTH + sizeof(AM_L21_GOPUD_ELEMENT) * i)
#define ISGOPUD_TOPFIELDFIRST(pGOPUDPacket)  ((pGOPUDPacket)->Header.bTopField_Rsrvd_NumElems & 0x80)


//
//  ATSC Line21 data come as a user data packet from the GOP header.
//  A struct for per frame/field based data and a valid flag definition.
//
//  From ATSC Standards for Coding 25/50Hz Video (A/63) specifications...
#define AM_L21_ATSCUD_HDR_STARTCODE      0x000001B2
#define AM_L21_ATSCUD_HDR_IDENTIFIER     0x47413934
#define AM_L21_ATSCUD_HDR_TYPECODE_EIA   0x03
#define AM_L21_ATSCUD_HDR_EM_DATA_FLAG   0x80
#define AM_L21_ATSCUD_HDR_CC_DATA_FLAG   0x40
#define AM_L21_ATSCUD_HDR_ADDL_DATA_FLAG 0x20
#define AM_L21_ATSCUD_HDR_CC_COUNT_MASK  0x1F
#define AM_L21_ATSCUD_HDR_NEXTBITS_ON    0x01
#define AM_L21_ATSCUD_ELEM_MARKERBITS    0xF8
#define AM_L21_ATSCUD_ELEM_VALID_FLAG    0x04
#define AM_L21_ATSCUD_ELEM_TYPE_FLAG     0x03
#define AM_L21_ATSCUD_MARKERBITS         0xFF
#define AM_L21_ATSCUD_HDR_NEXTBITS_FLAG  0x00000100
// There can be max 31 frames/fields' worth data per packet as there are 
// 5 bits to represent this number in the packet.
#define AM_L21_ATSCUD_ELEMENT_MAX        31

typedef struct _AM_L21_ATSCUD_ELEMENT {
    BYTE        bCCMarker_Valid_Type ;
    BYTE        chFirst ;
    BYTE        chSecond ;
} AM_L21_ATSCUD_ELEMENT, *PAM_L21_ATSCUD_ELEMENT ;

typedef struct _AM_L21_ATSCUD_HEADER {
    BYTE        abL21StartCode[4] ;
    BYTE        abL21Identifier[4] ;
    BYTE        bL21UDTypeCode ;
    BYTE        bL21DataFlags_Count ;
    BYTE        bL21EMData ;
} AM_L21_ATSCUD_HEADER, *PAM_L21_ATSCUD_HEADER ;

typedef struct _AM_L21_ATSCUD_PACKET {
    AM_L21_ATSCUD_HEADER   Header ;
    AM_L21_ATSCUD_ELEMENT  aElements[AM_L21_ATSCUD_ELEMENT_MAX] ;
    BYTE                   bMarkerBits ;
} AM_L21_ATSCUD_PACKET, *PAM_L21_ATSCUD_PACKET ;

#define GETATSCUD_NUMELEMENTS(pATSCUDPacket) ((pATSCUDPacket)->Header.bL21DataFlags_Count & AM_L21_ATSCUD_HDR_CC_COUNT_MASK)
#define GETATSCUD_PACKETSIZE(pATSCUDPacket)  (LONG)(sizeof(AM_L21_ATSCUD_HEADER) + \
                                              GETATSCUD_NUMELEMENTS(pATSCUDPacket) * sizeof(AM_L21_ATSCUD_ELEMENT) + \
                                              sizeof(BYTE))
#define GETATSCUDPACKET_ELEMENT(pATSCUDPacket, i) ((pATSCUDPacket)->aElements[i])
#define GETATSCUD_ELEM_MARKERBITS(Elem)     (((Elem).bCCMarker_Valid_Type & AM_L21_ATSCUD_ELEM_MARKERBITS) >> 3)

#define GETATSCUD_STARTCODE(Header)             \
    ( (DWORD)((Header).abL21StartCode[0]) << 24 | \
      (DWORD)((Header).abL21StartCode[1]) << 16 | \
      (DWORD)((Header).abL21StartCode[2]) <<  8 | \
      (DWORD)((Header).abL21StartCode[3]) )
#define GETATSCUD_IDENTIFIER(Header)             \
    ( (DWORD)((Header).abL21Identifier[0]) << 24 | \
      (DWORD)((Header).abL21Identifier[1]) << 16 | \
      (DWORD)((Header).abL21Identifier[2]) <<  8 | \
      (DWORD)((Header).abL21Identifier[3]) )
#define GETATSCUD_TYPECODE(Header)    (DWORD)((Header).bL21UDTypeCode)
#define ISATSCUD_TYPE_EIA(pATSCUDPacket)  (AM_L21_ATSCUD_HDR_TYPECODE_EIA == \
                                     ((pATSCUDPacket)->Header.bL21UDTypeCode & 0xFF))
#define ISATSCUD_EM_DATA(pATSCUDPacket)   (AM_L21_ATSCUD_HDR_EM_DATA_FLAG == \
                                     ((pATSCUDPacket)->Header.bL21DataFlags_Count & AM_L21_ATSCUD_HDR_EM_DATA_FLAG))
#define ISATSCUD_CC_DATA(pATSCUDPacket)   (AM_L21_ATSCUD_HDR_CC_DATA_FLAG == \
                                     ((pATSCUDPacket)->Header.bL21DataFlags_Count & AM_L21_ATSCUD_HDR_CC_DATA_FLAG))
#define ISATSCUD_ADDL_DATA(pATSCUDPacket) (AM_L21_ATSCUD_HDR_ADDL_DATA_FLAG == \
                                     ((pATSCUDPacket)->Header.bL21DataFlags_Count & AM_L21_ATSCUD_HDR_ADDL_DATA_FLAG))
#define GETATSCUD_EM_DATA(pATSCUDPacket)  ((pATSCUDPacket)->Header.bL21EMData)
#define ISATSCUD_ELEM_MARKERBITS_VALID(Elem)     (AM_L21_ATSCUD_ELEM_MARKERBITS == \
                                        ((Elem).bCCMarker_Valid_Type & AM_L21_ATSCUD_ELEM_MARKERBITS))
#define ISATSCUD_ELEM_CCVALID(Elem)  (AM_L21_ATSCUD_ELEM_VALID_FLAG == \
                                        ((Elem).bCCMarker_Valid_Type & AM_L21_ATSCUD_ELEM_VALID_FLAG))
#define GETATSCUD_ELEM_CCTYPE(Elem)    (DWORD)((Elem).bCCMarker_Valid_Type & AM_L21_ATSCUD_ELEM_TYPE_FLAG))
#define GETATSCUD_MARKERBITS(pATSCUDPacket) (DWORD)((pATSCUDPacket)->bMarkerBits)
#define ISATSCUD_MARKER_BITSVALID(pATSCUDPacket) (AM_L21_ATSCUD_MARKERBITS == \
                                       ((pATSCUDPacket)->bMarkerBits & AM_L21_ATSCUD_MARKERBITS))

// Header = StartCode + Id + TypeCode + (EM_CC_Addl_Data + CCCount) + EM_Data
#define ATSCUD_HEADERLENGTH   (4+4+1+1+1)
#define GETATSCUD_ELEMENT(pATSCUDPkt, i)  ((BYTE)(pATSCUDPkt) + ATSCUD_HEADERLENGTH + \
                                            sizeof(AM_L21_ATSCUD_ELEMENT) * i)


// CC type in GOP packet
typedef enum {
    GOP_CCTYPE_Unknown = 0,  // Invalid
    GOP_CCTYPE_None,         // all 0 -- filler packet
    GOP_CCTYPE_DVD,          // DVD CC packets
    GOP_CCTYPE_ATSC,         // ATSC CC packets
} GOPPACKET_CCTYPE ;


// Some more flag, struct and macro definitions...
#define AM_L21_INFO_FIELDBASED          0x0001
#define AM_L21_INFO_TOPFIELDFIRST       0x0003
#define AM_L21_INFO_BOTTOMFIELDFIRST    0x0005

typedef struct _AM_LINE21INFO {
    DWORD       dwFieldFlags ;
    UINT        uWidth ;
    UINT        uHeight ;
    UINT        uBitDepth ;
    DWORD       dwAvgMSecPerSample ;
} AM_LINE21INFO, *PAM_LINE21INFO ;


#define ISRECTEQUAL(r1, r2) ((r1).top == (r2).top     && \
                             (r1).left == (r2).left   && \
                             (r1).right == (r2).right && \
                             (r1).bottom == (r2).bottom)


//
// CLine21OutputThread: Line21 output thread class definition
//
class CLine21OutputThread {
public:
    CLine21OutputThread(CLine21DecFilter2 *pL21DFilter) ;
    ~CLine21OutputThread() ;
    BOOL Create() ;
    void Close() ;
    void SignalForOutput() ;
    static DWORD WINAPI InitialThreadProc(CLine21OutputThread * pThread) ;

private:
    // Data:
    CCritSec m_AccessLock ;
    HANDLE   m_hThread ;
    HANDLE   m_hEventEnd ;
    HANDLE   m_hEventMustOutput ;
    CLine21DecFilter2 *m_pL21DFilter ;

    // Methods:
    // Actual thread proc -- called by InitialThreadProc()
    DWORD OutputThreadProc() ;
} ;


//
// CLine21InSampleQueue: Line21 Input Sample Queue class definition
//
const int Max_Input_Sample = 10 ;

class CLine21InSampleQueue {
public:
    CLine21InSampleQueue() ;
    ~CLine21InSampleQueue() ;
    BOOL Create() ;
    void Close() ;
    BOOL AddItem(IMediaSample *pSample) ;
    IMediaSample* RemoveItem() ;
    IMediaSample* PeekItem() ;
    void ClearQueue() ;

private:
    // Data:
    CCritSec m_AccessLock ;
    HANDLE   m_hEventEnd ;
    HANDLE   m_hEventSample ;
    int      m_iCount ;
    CGenericList<IMediaSample>  m_List ;
} ;


//
//  Line 21 Decoder class definition
//
class CLine21DecFilter2 : public CTransformFilter,
                          // public ISpecifyPropertyPages, -- WILL DO LATER
                          public IAMLine21Decoder
{
public:
    
    //
    //  Constructor and destructor
    //
    CLine21DecFilter2(TCHAR *, LPUNKNOWN, HRESULT *) ;
    ~CLine21DecFilter2() ;
    
    //
    //   Standard COM stuff
    //
    // this goes in the factory template table to create new instances
    static CUnknown * CreateInstance(LPUNKNOWN, HRESULT *) ;
    // static void InitClass(BOOL, const CLSID *) ;
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid,void **ppv) ;
    DECLARE_IUNKNOWN ;
    
    // Checks if an output sample needs to be send, and if so, sends one down
    HRESULT SendOutputSampleIfNeeded() ;

    //
    //   CTranformFilter overrides
    //
    // I must override it
    HRESULT Transform(IMediaSample * pIn, IMediaSample * pOut) ;
    
    // Real stuff is in here...
    HRESULT Receive(IMediaSample * pIn) ;
    
    // check if you can support mtIn
    HRESULT CheckInputType(const CMediaType* mtIn) ;
    
    // check if you can support the transform from this input to
    // this output
    HRESULT CheckTransform(const CMediaType* mtIn,
                           const CMediaType* mtOut) ;
    
    // called from CBaseOutputPin to prepare the allocator's count
    // of buffers and sizes
    HRESULT DecideBufferSize(IMemAllocator * pAllocator,
							 ALLOCATOR_PROPERTIES *pProperties) ;
    
    // overriden to know when the media type is set
    HRESULT SetMediaType(PIN_DIRECTION direction,const CMediaType *pmt) ;
    
    // overriden to suggest OUTPUT pin media types
    HRESULT GetMediaType(int iPosition, CMediaType *pMediaType) ;
    
    HRESULT EndOfStream(void) ;
    HRESULT BeginFlush(void) ;
    HRESULT EndFlush(void) ;
    STDMETHODIMP GetState(DWORD dwMSecs, FILTER_STATE *State) ;
    
    // overridden to know when we're starting/stopping the decoding
    STDMETHODIMP Stop(void) ;
    STDMETHODIMP Pause(void) ;
    STDMETHODIMP Run(REFERENCE_TIME tStart) ;
    
    // overridden to know when connections are completed, so that we can get 
    // the media type (actualy format) info for caching
    HRESULT CompleteConnect(PIN_DIRECTION dir, IPin *pReceivePin) ;
    
    // Override to know when we disconnect from in/output side to not use
    // any specified output format any more.
    HRESULT BreakConnect(PIN_DIRECTION dir) ;

#if 0 // no QM for now
    // We also override this one as we handle the quality management messages
    HRESULT AlterQuality(Quality q) ;
#endif // #if 0

    //
    // ISpecifyPropertyPages method
    //
    // STDMETHODIMP GetPages(CAUUID *pPages) ;
    
    //
    // IAMLine21Decoder interface methods
    //
    STDMETHODIMP GetDecoderLevel(AM_LINE21_CCLEVEL *lpLevel) ;
    STDMETHODIMP GetCurrentService(AM_LINE21_CCSERVICE *lpService) ;
    STDMETHODIMP SetCurrentService(AM_LINE21_CCSERVICE Service) ;
    STDMETHODIMP GetServiceState(AM_LINE21_CCSTATE *lpState) ;
    STDMETHODIMP SetServiceState(AM_LINE21_CCSTATE State) ;
    STDMETHODIMP GetOutputFormat(LPBITMAPINFOHEADER lpbmih) ;
    STDMETHODIMP SetOutputFormat(LPBITMAPINFO lpbmi) ;
    STDMETHODIMP GetBackgroundColor(DWORD *pdwPhysColor) ;
    STDMETHODIMP SetBackgroundColor(DWORD dwPhysColor) ;
    STDMETHODIMP GetRedrawAlways(LPBOOL lpbOption) ;
    STDMETHODIMP SetRedrawAlways(BOOL bOption) ;
    STDMETHODIMP GetDrawBackgroundMode(AM_LINE21_DRAWBGMODE *lpMode) ;
    STDMETHODIMP SetDrawBackgroundMode(AM_LINE21_DRAWBGMODE Mode) ;
    
private:   // data
    
    // Line21 Data Decoder class that takes 2 bytes and converts to a bitmap
    CLine21DataDecoder  m_L21Dec ;

    // The thread on which we'll output samples as needed
    CLine21OutputThread m_OutputThread ;

    // The input sample queue object
    CLine21InSampleQueue m_InSampleQueue ;

    // What input format type is being used (better to use an integer flag)
    AM_LINE21_CCSUBTYPEID  m_eSubTypeIDIn ;

    GOPPACKET_CCTYPE       m_eGOP_CCType ;  // if GOPPackets used, what type data (DVD/ATSC/...)
    
    REFERENCE_TIME  m_rtTimePerInSample ;   // (in 100 nSec) interval per byte pair from an in-packet (for GOP packet type)
    REFERENCE_TIME  m_rtTimePerOutSample ;  // (in 100 nSec) interval per output sample (~33 mSec)
    REFERENCE_TIME  m_rtStart ;          // start time for an output sample
    REFERENCE_TIME  m_rtStop ;           // stop time for an out output sample
    REFERENCE_TIME  m_rtLastOutStop ;    // stop time of last output sample
    LONGLONG        m_llMediaStart ;     // media time start (rarely used, but...)
    REFERENCE_TIME  m_llMediaStop ;      // media time stop (rarely used, but...)

    // CC input samples w/o valid timestamps are output for "NOW"
    BOOL            m_bNoTimeStamp ;  // no timestamp for this sample

    // flag to detect if we must send an output sample
    BOOL            m_bMustOutput ;

    // flag to remember if the last input sample was a discontiuity sample
    BOOL            m_bDiscontLast ;

    BOOL            m_bEndOfStream ;  // has EoS been sent/called?

    // If the upstream filter doesn't specify any format type, use one from
    // our internal defaults
    VIDEOINFO      *m_pviDefFmt ;
    DWORD           m_dwDefFmtSize ;
    
    IPin           *m_pPinDown ;    // downstream pin connected to our output
    
    BOOL            m_bBlendingState ;   // latest CC blending state

#if 0 // no QM for now
    // number of samples to skip between every output CC sample for QM handling
    int          m_iSkipSamples ;
#endif // #if 0

#ifdef PERF
    int          m_idDelvWait ;
#endif // PERF
    
private:   // functions
    AM_LINE21_CCSUBTYPEID MapGUIDToID(const GUID *pFormatIn) ;
    BOOL    VerifyGOPUDPacketData(PAM_L21_GOPUD_PACKET pGOPUDPacket) ;
    BOOL    VerifyATSCUDPacketData(PAM_L21_ATSCUD_PACKET pATSCUDPacket) ;
    BOOL    IsFillerPacket(BYTE *pGOPPacket) ;
    HRESULT GetDefaultFormatInfo(void) ;
    BOOL    IsValidFormat(BYTE *pbFormat) ;
    HRESULT SendOutputSample(IMediaSample *pIn, 
                    REFERENCE_TIME *prtStart, REFERENCE_TIME *prtStop) ;
    void    SetBlendingState(BOOL bState) ;
    // bool    CanChangeMediaType(RECT *prectSrc, RECT *prectDest) ;
    HRESULT GetOutputBuffer(IMediaSample **ppOut) ;
    GOPPACKET_CCTYPE DetectGOPPacketDataType(BYTE *pGOPPacket) ;
    HRESULT ProcessGOPPacket_DVD(IMediaSample *pIn) ;
    HRESULT ProcessGOPPacket_ATSC(IMediaSample *pIn) ;
    HRESULT ProcessSample(IMediaSample *pIn) ;

#if 0 // no QM for now
    inline int  GetSkipSamples(void)   { return m_iSkipSamples ; }
    inline void ResetSkipSamples(void) { m_iSkipSamples = 0 ; } ;
#endif // #if 0
} ;

#pragma pack(pop)

#endif // _INC_L21DFILT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\lin21dec2\l21decod.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
//
//  L21Decod.h: Line 21 Decoder engine base class code
//

#ifndef _INC_L21DECOD_H
#define _INC_L21DECOD_H


//
//  Forward declarations
//
class CLine21DataDecoder ;


//
//  Input data type ID (rather than GUID) for internal functioning
//
typedef enum _AM_LINE21_CCSUBTYPEID {
    AM_L21_CCSUBTYPEID_Invalid = 0,
    AM_L21_CCSUBTYPEID_BytePair,
    AM_L21_CCSUBTYPEID_GOPPacket,
    AM_L21_CCSUBTYPEID_VBIRawData
} AM_LINE21_CCSUBTYPEID, *PAM_LINE21_CCSUBTYPEID ;

//
//  A set of values indicating what type of control code was received
//
#define L21_CONTROLCODE_INVALID     0
#define L21_CONTROLCODE_PAC         1
#define L21_CONTROLCODE_MIDROW      2
#define L21_CONTROLCODE_MISCCONTROL 3


//
//  CLine21DataDecoder: class for decoding from byte pair and output to bitmap
//
class CLine21DataDecoder {
public:  // public methods for CLine21Filter to call
    CLine21DataDecoder::CLine21DataDecoder(
                            AM_LINE21_CCSTYLE eStyle = AM_L21_CCSTYLE_None,
                            AM_LINE21_CCSTATE eState = AM_L21_CCSTATE_Off,
                            AM_LINE21_CCSERVICE eService = AM_L21_CCSERVICE_None) ;
    ~CLine21DataDecoder(void) ;

    void InitState(void) ;
    BOOL InitCaptionBuffer(void) ;  // all buffers
    BOOL InitCaptionBuffer(AM_LINE21_CCSTYLE eCCStyle) ; // only needed buffer(s)
    BOOL DecodeBytePair(BYTE chFirst, BYTE chSecond) ;
    BOOL UpdateCaptionOutput(void) ;
    bool OutputCCLine(int iLine, int iDestRow, int iSrcCrop, int iDestOffset) ;
    bool OutputCCBuffer(void) ;
    bool OutputBlankCCLine(int iLine, int iDestRow, int iSrcCrop, int iDestOffset) ;
    void CompleteScrolling(void) ;
    inline AM_LINE21_CCSTYLE GetCaptionStyle()   { return m_eCCStyle ; } ;
    AM_LINE21_CCSTYLE SetCaptionStyle(AM_LINE21_CCSTYLE eStyle) ;
    inline BOOL IsScrolling(void)   { return m_bScrolling ; } ;
    void FlushInternalStates(void) ;
    inline BOOL IsOutDIBClear(void) {
       return m_L21DDraw.IsOutDIBClear() ;
    } ;
    inline BOOL IsNewOutBuffer(void) {
       return m_L21DDraw.IsNewOutBuffer() ;
    }
    
    // inline BOOL IsSizeOK(LPBITMAPINFOHEADER lpbmih) {
    //     return m_L21DDraw.IsSizeOK(lpbmih) ;
    // } ;

    // methods to allow the filter to do get/set using the 
    // IAMLine21Decoder interface
    inline AM_LINE21_CCLEVEL GetDecoderLevel(void)    { return m_eLevel ; } ;
    inline AM_LINE21_CCSERVICE GetCurrentService(void)  { return m_eUserService ; } ;
    BOOL SetCurrentService(AM_LINE21_CCSERVICE Service) ; 
    inline AM_LINE21_CCSTATE GetServiceState(void)    { return m_eState ; } ;
    BOOL SetServiceState(AM_LINE21_CCSTATE eState) ;
    HRESULT GetDefaultFormatInfo(LPBITMAPINFO lpbmi, DWORD *pdwSize) {
        CAutoLock  Lock(&m_csL21Dec) ;
        return m_L21DDraw.GetDefaultFormatInfo(lpbmi, pdwSize) ;
    } ;
    HRESULT GetOutputFormat(LPBITMAPINFOHEADER lpbmih) {
        CAutoLock  Lock(&m_csL21Dec) ;
        return m_L21DDraw.GetOutputFormat(lpbmih) ;
    } ;
    HRESULT GetOutputOutFormat(LPBITMAPINFOHEADER lpbmih) {
        CAutoLock  Lock(&m_csL21Dec) ;
        return m_L21DDraw.GetOutputOutFormat(lpbmih) ;
    } ;
    HRESULT SetOutputOutFormat(LPBITMAPINFO lpbmi) {
        CAutoLock  Lock(&m_csL21Dec) ;
        return m_L21DDraw.SetOutputOutFormat(lpbmi) ;
    } ;
    HRESULT SetOutputInFormat(LPBITMAPINFO lpbmi) {
        CAutoLock  Lock(&m_csL21Dec) ;
        return m_L21DDraw.SetOutputInFormat(lpbmi) ;
    } ;
    inline void GetBackgroundColor(DWORD *pdwBGColor) { 
        m_L21DDraw.GetBackgroundColor(pdwBGColor) ;
    } ;
    inline BOOL SetBackgroundColor(DWORD dwBGColor) {
        return m_L21DDraw.SetBackgroundColor(dwBGColor) ;
    } ;

    inline BOOL GetRedrawAlways() { return m_bRedrawAlways ; } ;
    inline void SetRedrawAlways(BOOL Option) { m_bRedrawAlways = !!Option ; } ;

    inline AM_LINE21_DRAWBGMODE GetDrawBackgroundMode(void) { 
        return (m_L21DDraw.GetBackgroundOpaque() ?
                AM_L21_DRAWBGMODE_Opaque : AM_L21_DRAWBGMODE_Transparent) ;
    } ;
    inline void SetDrawBackgroundMode(AM_LINE21_DRAWBGMODE Mode) { 
        m_L21DDraw.SetBackgroundOpaque(AM_L21_DRAWBGMODE_Opaque == Mode) ;
    } ;
    
    // methods to pass values between the CLine21DecFilter class and CGDIWork class
    // some general methods to communicate with the container class
    IUnknown* GetDDrawObject(void){
        return m_L21DDraw.GetDDrawObject() ;
    } ;
    bool SetDDrawSurface(LPDIRECTDRAWSURFACE7 lpDDS) {
        return m_L21DDraw.SetDDrawSurface(lpDDS) ;
    } ;
    inline void FillOutputBuffer(void) {
        m_L21DDraw.FillOutputBuffer() ;
    } ;
    inline void InitColorNLastChar(void) {
        m_L21DDraw.InitColorNLastChar() ;
    } ;
    
private:   // private helper methods
    //
    //  The following methods are for implementing the actual decoding
    //  algorithm.
    //
    BOOL IsMidRowCode(BYTE chFirst, BYTE chSecond) ;
    BOOL IsPAC(BYTE chFirst, BYTE chSecond) ;
    BOOL IsMiscControlCode(BYTE chFirst, BYTE chSecond) ;
    UINT CheckControlCode(BYTE chFirst, BYTE chSecond) ;
    BOOL IsSpecialChar(BYTE chFirst, BYTE chSecond) ;
    BOOL ValidParity(BYTE ch) ;
    BOOL IsStandardChar(BYTE ch)  { return (ch >= 0x20 && ch <= 0x7F) ; } ;
    BOOL ProcessControlCode(UINT uCodeType, BYTE chFirst, BYTE chSecond) ;
    BOOL DecodePAC(BYTE chFirst, BYTE chSecond) ;
    BOOL DecodeMidRowCode(BYTE chFirst, BYTE chSecond) ;
    BOOL DecodeMiscControlCode(BYTE chFirst, BYTE chSecond) ;
    BOOL LineFromRow(UINT uCurrRow) ;
    BOOL ProcessPrintableChar(BYTE ch) ;
    BOOL ProcessSpecialChar(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleRCL(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleBS(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleDER(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleRU(BYTE chFirst, BYTE chSecond, int iLines) ;
    BOOL HandleFON(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleRDC(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleTR(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleRTD(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleEDM(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleCR(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleENM(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleEOC(BYTE chFirst, BYTE chSecond) ;
    BOOL HandleTO(BYTE chFirst, BYTE chSecond, int iCols) ;
    
    void SetNewLinePosition(int iLines, UINT uCurrRow) ;
    BOOL PutCharInBuffer(UINT16 wChar, BOOL bMidRowCode = FALSE) ; // put char in buffer (& MRC too)
    BOOL IsEmptyLine(int iLine) ;   // Is the line empty (no non-Xparent chars)?
    BOOL RemoveCharsInBuffer(int iNumChars) ;  // removes n chars to the right of current col
    
    //
    //  The following methods are defined to bring uniformity in coding of
    //  the algorithm irrespective of any caption style being used.
    //
    CCaptionBuffer * GetDispBuffer(void) ;    // display buffer: mainly for Pop-On style
    void ClearBuffer(void) ;
    void RemoveLineFromBuffer(UINT8 uLine, BOOL bUpNextLine) ;
    void GetCaptionChar(UINT8 uLine, UINT8 uCol, CCaptionChar& cc) ;
    CCaptionChar * GetCaptionCharPtr(UINT8 uLine, UINT8 uCol) ;
    void SetCaptionChar(const UINT8 uLine, const UINT8 uCol,
                        const CCaptionChar& cc) ;
    int  GetMaxLines(void) ;
    void SetMaxLines(UINT uLines) ;
    int  GetNumLines(void) ;
    void SetNumLines(UINT uLines) ;
    int  GetNumCols(int iLines) ;
    int  GetRow(UINT uLine) ;
    int  GetCurrLine(void) ;
    int  GetCurrCol(void) ;
    void SetCurrLine(UINT8 uLine) ;
    void SetCurrCol(UINT8 uCol) ;
    int  GetStartRow(UINT8 uLine) ;
    int  GetRowIndex(UINT8 uRow) ;
    void SetStartRow(UINT8 uLine, UINT8 uRow) ;
    void SetRowIndex(UINT8 uLine, UINT8 uRow) ;
    int  IncCurrCol(UINT uNumChars) ;
    int  DecCurrCol(UINT uNumChars) ;
    int  IncNumChars(UINT uLine, UINT uNumChars) ;
    int  DecNumChars(UINT uLine, UINT uNumChars) ;
    int  IncNumLines(UINT uLines) ;
    int  DecNumLines(UINT uLines) ;
    void MoveCaptionChars(int uLine, int iNum) ;
    
    BOOL IsCapBufferDirty(void) ;
    BOOL IsRedrawLine(UINT8 uLine) ;
    BOOL IsRedrawAll(void) ;
    void SetCapBufferDirty(BOOL bState) ;
    void SetRedrawLine(UINT8 uLine, BOOL bState) ;
    void SetRedrawAll(BOOL bState) ;
    
    void SetScrollState(BOOL bState) ;
    int  IncScrollStartLine(int iCharHeight) ;
    void SkipScrolling(void) ;   // CR came while scrolling; skip current one
    void MoveCaptionLinesUp(void) ;  // remove top line, move other lines up
    void RelocateRollUp(UINT uBaseRow) ; // move roll-up caption to given base row

    //
    //  Common buffers used for all CC modes
    //
    CCaptionBuffer * GetCaptionBuffer(void) ;
    CCaptionBuffer * GetDisplayBuffer(void) ;
    inline int  GetBufferIndex(void)  { return m_iBuffIndex ; } ;
    inline void SetBufferIndex(int iIndex) ;
    inline void SwapBuffers(void)  { m_iBuffIndex = 1 - m_iBuffIndex ; } ;
    
private:  // private data
    CCritSec            m_csL21Dec ;   // to serialize operations on line21 decoder object

    CCaptionBuffer *    m_pCurrBuff ;
    
    // Actual caption buffer with text and attribs/positions/banks etc
    CCaptionBuffer      m_aCCData[2] ;
    int                 m_iBuffIndex ; // index for current CC data buffer
    
    CLine21DecDraw      m_L21DDraw ;   // Drawing details class as a member

    UINT                m_uFieldNum ;  // Field number: 1 or 2 (top/bottom)
    
    // What style caption is being displayed now and was used last
    AM_LINE21_CCSTYLE   m_eCCStyle ;
    AM_LINE21_CCSTYLE   m_eLastCCStyle ;
    
    // Is Line 21 decoding On/Off
    AM_LINE21_CCSTATE   m_eState ;
    
    // Which service is currently being viewed by the user
    AM_LINE21_CCSERVICE m_eUserService ;  // one of C1/C2/T1/T2/XDS
    
    // Decoder is standard or enhanced
    AM_LINE21_CCLEVEL   m_eLevel ;
    
    //
    //  Some internal states during decoding
    //
    AM_LINE21_CCSERVICE m_eDataService ; // service indicated by received bytes
    UINT                m_uCurrFGEffect ;  // FG effect of current position
    UINT                m_uCurrFGColor ;   // FG color of current position
    
    BOOL                m_bExpectRepeat ;  // should we expect a repeat of last pair?
    BYTE                m_chLastByte1 ;    // the 1st second byte processed
    BYTE                m_chLastByte2 ;    // the 2nd second byte processed
    
    BOOL                m_bScrolling ;     // are we in the middle of scrolling up?
    int                 m_iScrollStartLine ; // current scan line to be scrolled off
    
    BOOL                m_bRedrawAlways ;  // client wants a total redraw per sample

#ifdef PERF
    int          m_idTxt2Bmp ;
    int          m_idBmp2Out ;
    int          m_idScroll ;
#endif // PERF
} ;


//
//  Some misc. constant definitions
//
#define INVALID_CHANNEL     -1

//
//  Some macros to hide some gory details
//
#define ISSUBTYPEVALID(ID) (AM_L21_CCSUBTYPEID_BytePair   == ID || \
                            AM_L21_CCSUBTYPEID_GOPPacket  == ID || \
                            AM_L21_CCSUBTYPEID_VBIRawData == ID)

#endif _INC_L21DECOD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\lin21dec2\l21decod.cpp ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.

//
// ActiveMovie Line 21 Decoder Filter: Decoder Logic part
//

#include <streams.h>
#include <windowsx.h>

// #ifdef FILTER_DLL
#include <initguid.h>
// #endif

#include <IL21Dec.h>
#include "L21DBase.h"
#include "L21DDraw.h"
#include "L21Decod.h"


//
//  CLine21DataDecoder class constructor: mainly init of members
//
CLine21DataDecoder::CLine21DataDecoder(AM_LINE21_CCSTYLE eStyle     /* = AM_L21_CCSTYLE_None */,
                                       AM_LINE21_CCSTATE eState     /* = AM_L21_CCSTATE_Off  */,
                                       AM_LINE21_CCSERVICE eService /* = AM_L21_CCSERVICE_None */)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::CLine21DataDecoder()"))) ;
    
#ifdef PERF
    m_idTxt2Bmp = MSR_REGISTER(TEXT("L21DPerf - Text to CC bmp")) ;
    m_idBmp2Out = MSR_REGISTER(TEXT("L21DPerf - Bmp to Output")) ;
    m_idScroll  = MSR_REGISTER(TEXT("L21DPerf - Line Scroll")) ;
#endif // PERF

    InitState() ;
    
    // We separately set some of the passed in values
    SetCaptionStyle(eStyle) ;
}


CLine21DataDecoder::~CLine21DataDecoder(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::~CLine21DataDecoder()"))) ;
    
    // make sure the internal bitmap etc has been released and
    // allocated memory or other resources are not left un-released.
}

//
// Decoder state initializer; will be used also in filter's CompleteConnect()
//
void CLine21DataDecoder::InitState(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::InitState()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    m_pCurrBuff = NULL ;
    
    m_uFieldNum = 1 ;   // field 1 by default
    
    m_bRedrawAlways = FALSE ;  // someone has to be too picky/weird to do it!!
    m_eLevel = AM_L21_CCLEVEL_TC2 ;   // we are TC2 compliant
    m_eUserService = AM_L21_CCSERVICE_Caption1 ;   // CC is the default service
    m_eState = AM_L21_CCSTATE_On ;  // State is "On" by default

    FlushInternalStates() ;
}


void CLine21DataDecoder::FlushInternalStates(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::FlushInternalStates()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    InitCaptionBuffer() ;     // clear caption buffer
    SetRedrawAll(TRUE) ;      // redraw (no) caption on next Receive()
    SetScrollState(FALSE) ;   // turn off scrolling, just to be sure
    SetCaptionStyle(AM_L21_CCSTYLE_None) ;  // also sets m_pCurrBuff = NULL
    m_eLastCCStyle = AM_L21_CCSTYLE_None ;
    m_eDataService = AM_L21_CCSERVICE_None ;
    m_uCurrFGColor = AM_L21_FGCOLOR_WHITE ;
    m_uCurrFGEffect = 0 ;
    m_bExpectRepeat = FALSE ;
    m_chLastByte1 = 0 ;
    m_chLastByte2 = 0 ;

    m_L21DDraw.InitColorNLastChar() ;   // reset color etc.
}


BOOL CLine21DataDecoder::SetServiceState(AM_LINE21_CCSTATE eState)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::SetServiceState(%lu)"), eState)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (eState == m_eState)  // no change of state
        return FALSE ;       // no refresh to be forced
    
    m_eState = eState ;  // save the state for future decoding
    
    //
    // When service is turned off, we must clear the caption buffer(s) and
    // the internal DIB section so that old captions are not shown anymore.
    //
    if (AM_L21_CCSTATE_Off == m_eState)
    {
        FlushInternalStates() ;
		FillOutputBuffer() ; // just to clear any existing junk
        return TRUE ;        // output needs to be refreshed
    }
    return FALSE ;          // output need not be refreshed by force
}


BOOL CLine21DataDecoder::SetCurrentService(AM_LINE21_CCSERVICE eService)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::SetCurrentService(%lu)"), eService)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (eService == m_eUserService)  // no change of service
        return FALSE ;               // no refresh to be forced
    
    m_eUserService = eService ;   // save the service the user wants
    
    //
    // When service "none" is selected (kind of "turn it off"), we must clear the 
    // caption buffer(s) and the internal DIB section so that old captions are 
    // not shown anymore.
    //
    if (AM_L21_CCSERVICE_None == m_eUserService)
    {
        FlushInternalStates() ;
		FillOutputBuffer() ; // just to clear any existing junk
        return TRUE ;        // output needs to be refreshed
    }
    return FALSE ;          // output need not be refreshed by force
}


//
//  Actual caption byte pair decoding algorithm
//
BOOL CLine21DataDecoder::DecodeBytePair(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::DecodeBytePair(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (AM_L21_CCSTATE_Off == m_eState)
    {
        DbgLog((LOG_TRACE, 5, TEXT("Line21 data decoding turned off"))) ;
        return FALSE ;  // we actually didn't decode / generate anything
    }
    
    UINT uCodeType = CheckControlCode(chFirst, chSecond) ;
    if (L21_CONTROLCODE_INVALID != uCodeType)
    {
        // It's a control code (PAC / Mid row code / misc control code)
        return ProcessControlCode(uCodeType, chFirst, chSecond) ;
    }
    else if (IsSpecialChar(chFirst, chSecond))
    {
        // It's a special char represented by the second char
        return ProcessSpecialChar(chFirst, chSecond) ;
    }
    else
    {
        // If the 1st byte is in [0, F] then ignore 1st byte and print 2nd byte
        // as just a printable char
        BOOL  bResult = FALSE ;
        if (! ((chFirst &0x7F) >= 0x0 && (chFirst & 0x7F) <= 0xF) )
        {
            if (! ProcessPrintableChar(chFirst) )
                return FALSE ;
            bResult = TRUE ;
        }
        // If one of the two bytes decode right, we take it as a success
        bResult |= ProcessPrintableChar(chSecond) ;
        m_bExpectRepeat = FALSE ;  // turn it off now
        return bResult ;
    }
}


BOOL CLine21DataDecoder::UpdateCaptionOutput(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::UpdateCaptionOutput()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (m_L21DDraw.IsNewOutBuffer() ||            // if output buffer changed  OR
        (m_eCCStyle != AM_L21_CCSTYLE_PopOn  &&   // non-PopOn style (PopOn draws on EOC) AND
         IsCapBufferDirty()) ||                   // draw when dirty
        IsScrolling())                            // we are scrolling
    {
        OutputCCBuffer() ;     // output CC data from internal buffer to DDraw surface
        return TRUE ;          // caption updated
    }
    return FALSE ;  // no caption update
}


BOOL CLine21DataDecoder::IsPAC(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::IsPAC(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // mask off parity bit before code matching
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // now match code with control code list
    if ((0x10 <= chFirst  && 0x17 >= chFirst)  &&
        (0x40 <= chSecond && 0x7F >= chSecond))
        return TRUE ;
    if ((0x18 <= chFirst  && 0x1F >= chFirst)  &&
        (0x40 <= chSecond && 0x7F >= chSecond))
        return TRUE ;
    
    return FALSE ;
}


BOOL CLine21DataDecoder::IsMiscControlCode(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::IsMiscControlCode(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // mask off parity bit before code matching
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // first match with TO1 -> TO3 codes
    if ((0x21 <= chSecond && 0x23 >= chSecond)  &&
        (0x17 == chFirst  ||  0x1F == chFirst))
        return TRUE ;
    
    // Now match with the other misc control code
    if ((0x14 == chFirst  ||  0x15 == chFirst)  &&  
        (0x20 <= chSecond && 0x2F >= chSecond))
        return TRUE ;
    if ((0x1C == chFirst  ||  0x1D == chFirst)  &&  
        (0x20 <= chSecond && 0x2F >= chSecond))
        return TRUE ;

    return FALSE ;
}


BOOL CLine21DataDecoder::IsMidRowCode(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::IsMidRowCode(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // mask off parity bit before code matching
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // Now match with the mid row code list
    if ((0x11 == chFirst)  &&  (0x20 <= chSecond && 0x2F >= chSecond))
        return TRUE ;
    if ((0x19 == chFirst)  &&  (0x20 <= chSecond && 0x2F >= chSecond))
        return TRUE ;
    
    return FALSE ;
}


UINT CLine21DataDecoder::CheckControlCode(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::CheckControlCode(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    if (IsPAC(chFirst, chSecond))
        return L21_CONTROLCODE_PAC ;
    
    if (IsMidRowCode(chFirst, chSecond))
        return L21_CONTROLCODE_MIDROW ;
    
    if (IsMiscControlCode(chFirst, chSecond))
        return L21_CONTROLCODE_MISCCONTROL ;
    
    DbgLog((LOG_TRACE, 3, TEXT("Not a control code"))) ;
    return L21_CONTROLCODE_INVALID ;
}


BOOL CLine21DataDecoder::IsSpecialChar(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::IsSpecialChar(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // Strip the parity bit before determining the service channel
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // now match code with special char list
    if (0x11 == chFirst && (0x30 <= chSecond && 0x3f >= chSecond))
        return TRUE ;
    if (0x19 == chFirst && (0x30 <= chSecond && 0x3f >= chSecond))
        return TRUE ;
    
    return FALSE ;
}


BOOL CLine21DataDecoder::ValidParity(BYTE ch)
{
#if 1
    ch ^= ch >> 4 ;
    ch ^= ch >> 2 ;
    return (0 != (0x01 & (ch ^ (ch >> 1)))) ;
#else
    return TRUE ;
#endif
}


void CLine21DataDecoder::RelocateRollUp(UINT uBaseRow)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::RelocateRollUp(%u)"), uBaseRow)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    if (AM_L21_CCSTYLE_RollUp != m_eCCStyle)
        return ;
    
    int  iMaxLines = GetMaxLines() ;
    int  iNumLines = GetNumLines() ;
    int  iMax ;
    if (m_bScrolling)  // during scrolling go for last but 1 line
    {
        DbgLog((LOG_TRACE, 3, TEXT("Moving base row to %d during scrolling"), uBaseRow)) ;
        if (iNumLines > iMaxLines)
        {
            DbgLog((LOG_TRACE, 3, TEXT("%d lines while max is %d"), iNumLines, iMaxLines)) ;
            iNumLines-- ;  // we don't set the row for the "not-yet-in" line
        }
        iMax = min(iNumLines, iMaxLines) ;
    }
    else               // otherwise go for the last line
    {
        DbgLog((LOG_TRACE, 3, TEXT("Moving base row to %d (not scrolling)"), uBaseRow)) ;
        iMax = min(iNumLines, iMaxLines) ;
    }
    for (int i = 0 ; i < iMax ; i++)
    {
        SetStartRow((UINT8)i, (UINT8)(uBaseRow - (iMax - 1 - i))) ;
        DbgLog((LOG_TRACE, 5, TEXT("RelocateRollUp(): Line %d @ row %d"), i, (int)(uBaseRow - (iMax - 1 - i)) )) ;
    }
}


BOOL CLine21DataDecoder::LineFromRow(UINT uCurrRow)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::LineFromRow(%u)"), uCurrRow)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    int     iLines ;
    
    // If we are in Roll-up mode then we shouldn't try to go through 
    // all the hassle of creating a new line etc. -- it's just a PAC 
    // to specify starting position and/or color; so just do that.
    if (AM_L21_CCSTYLE_RollUp != m_eCCStyle)
    {
        // If the indentation PAC places cursor on an existing row
        
        int   iIndex ;
        iIndex = GetRowIndex((UINT8)uCurrRow) ;
        if (-1 == iIndex)    // some error encountered
            return FALSE ;   // fail decoding
        
        if (0 == iIndex)  // landed in a new row
        {
            iLines = GetNumLines() ;
            SetNewLinePosition(iLines, uCurrRow) ;
            SetRedrawLine((UINT8)iLines, TRUE) ;  // initially set line to be redrawn
        }
        else  // landed in an existing row
        {
            SetCurrLine(iIndex-1) ;  // -1 because row index map is 1-based (it has to be),
            // but the caption line index etc are all 0-based.
        }
        
        // We have to put the cursor at the 1st column
        SetCurrCol(0) ;   // no matter which line it is, go to 1st col (i.e, 0)
    }
    else  // in Roll-up mode
    {
        // If necessary, move entire caption so that the specified row 
        // becomes the new base row.
        iLines = GetNumLines() ;
        if ((int) uCurrRow < iLines)
        {
            ASSERT((int) uCurrRow < iLines) ;
            uCurrRow = (UINT) iLines ;
        }
        if (1 == iLines)  // if this is for the first line
        {
            SetStartRow(0, (UINT8)uCurrRow) ;  // also set the base row to start with
            DbgLog((LOG_TRACE, 5, TEXT("LineFromRow(): Line 0 @ row %u"), uCurrRow)) ;
        }
        else              // otherwise just move captions to the specified row
        {
            RelocateRollUp(uCurrRow) ;
            if (GetStartRow(iLines-1) == (int)uCurrRow)  // last line is at current row
                SetScrollState(FALSE) ;             // we should not scroll
            SetCapBufferDirty(TRUE) ; // caption buffer is dirty in a sense
            SetRedrawAll(TRUE) ;      // must be redrawn to show new position
        }
        
        DbgLog((LOG_TRACE, 3, TEXT("Base row for %d lines moved to %d"), iLines, uCurrRow)) ;
    }
    
    return TRUE ;
}


BOOL CLine21DataDecoder::DecodePAC(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::DecodePAC(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    int         iGroup ;
    UINT        uDiff ;
    UINT        uCurrRow ;
    UINT        uCurrCol ;
    UINT        uCol ;
    
    if (AM_L21_CCSTYLE_None == m_eCCStyle)
    {
        DbgLog((LOG_TRACE, 3, TEXT("DecodePAC(): No CC style defined yet. Skipping..."))) ;
        return TRUE ;  // ??
    }

    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("DecodePAC(): Data for some other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }

    // Turn off parity checking here
    chFirst  &= 0x7F ;
    chSecond &= 0x7F ;
    
    // now locate which of the two groups does 2nd byte belong, if at all!!
    if (chSecond >= 0x40 && chSecond <= 0x5F)
    {
        iGroup = 0 ;
        uDiff = chSecond - 0x40 ;
    }
    else if (chSecond >= 0x60 && chSecond <= 0x7F)
    {
        iGroup = 1 ;
        uDiff = chSecond - 0x60 ;
    }
    else   // invalid 2nd byte for PAC
    {
        DbgLog((LOG_ERROR, 2, TEXT("Invalid 2nd byte for PAC"))) ;
        return FALSE ;
    }
    
    // Valid 2nd byte; now decide based on the 1st byte
    static UINT8 auPACtoRowMap[0x10] = {
        11,  1,  3, 12, 14,  5,  7,  9, 11,  1,  3, 12, 14,  5,  7,  9  // row
     // 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 1A, 1B, 1C, 1D, 1E, 1F  // PAC byte 1
    } ;
    
    if (chFirst >= 0x10  &&  chFirst <= 0x1F)
    {
        // the row number is 1 more if the 2nd byte is in the 60-7F group
        uCurrRow = auPACtoRowMap[chFirst - 0x10] + iGroup  ;
        
        // Now see what happens with the new row specified, if any, in the PAC
        LineFromRow(uCurrRow) ;
    }
    else
    {
        DbgLog((LOG_TRACE, 2, TEXT("Invalid mid-row code in 1st byte"))) ;
        return FALSE ;
    }
    
    // some final decisions...
    m_uCurrFGEffect = 0 ;  // clear all effects as a result of PAC processing
    if (uDiff <= 0x0D)  // color (and underline) spec
        m_uCurrFGColor = uDiff >> 1 ;  // AM_L21_FGCOLOR_xxx are from 0 to 6
    else if (uDiff <= 0x0F)  // 0E, 0F == italics (and underline) spec
    {
        m_uCurrFGEffect |= AM_L21_FGEFFECT_ITALICS ;
        m_uCurrFGColor = AM_L21_FGCOLOR_WHITE ;  // 0
    }
    else  // 10 -> 1F == indent (and underline) spec (no other way)
    {
        // 50 (70) => 0, 52 (72) => 4 etc.
        // last bit of 2nd char determines underline or not
        uCurrCol = ((uDiff - 0x10) & 0xFE) << 1 ;
        if (uCurrCol >= MAX_CAPTION_COLUMNS)
            uCurrCol = MAX_CAPTION_COLUMNS - 1 ;
        
            /*
            int  iCurrLine = GetCurrLine() ;
            if (0 == GetNumCols(iCurrLine)) // if it's a tab indent on clean line
            {
            SetStartCol(iCurrLine, uCurrCol) ; // set start column as spec-ed
            SetCurrCol(0) ;             // and current col to 0
            }
            else if ((uCol = GetStartCol(iCurrLine)) > uCurrCol)  // existing line
            {
            // insert null spaces before currently existing chars as filler
            // (that adjusts the number of chars value too)
            MoveCaptionChars(iCurrLine, uCol - uCurrCol) ;
            SetStartCol(iCurrLine, uCurrCol) ;
            SetCurrCol(0) ;
            }
            else
            SetCurrCol(uCurrCol) ;
        */
        SetCurrCol((UINT8)uCurrCol) ;
        
        m_uCurrFGColor = AM_L21_FGCOLOR_WHITE ;
    }
    
    // at last check underline bit
    if (uDiff & 0x01)
        m_uCurrFGEffect |= AM_L21_FGEFFECT_UNDERLINE ;
    else
        m_uCurrFGEffect &= ~AM_L21_FGEFFECT_UNDERLINE ;
    
    return TRUE ;   // done at last!!!
}


BOOL CLine21DataDecoder::DecodeMidRowCode(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::DecodeMidRowCode(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    BYTE        uValue ;
    
    if (AM_L21_CCSTYLE_None == m_eCCStyle)
    {
        DbgLog((LOG_TRACE, 3, TEXT("DecodeMidRowCode(): No CC style defined yet.  Returning..."))) ;
        return TRUE ;  // ??
    }
    
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("DecodeMidRowCode(): Data for some other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }

    if (chSecond < 0x20  ||  chSecond > 0x2F)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Invalid mid-row code in 2nd byte"))) ;
        return FALSE ;
    }
    uValue = chSecond - 0x20 ;
    if (uValue & 0x01)
        m_uCurrFGEffect |= AM_L21_FGEFFECT_UNDERLINE ;
    else
        m_uCurrFGEffect &= ~AM_L21_FGEFFECT_UNDERLINE ;
    if (chSecond < 0x2E)   // only color specs
    {
        m_uCurrFGColor = uValue >> 1 ;  // AM_L21_FGCOLOR_xxx are from 0 to 6
        m_uCurrFGEffect &= ~AM_L21_FGEFFECT_ITALICS ;  // color turns off italics
    }
    else   // 2nd byte is 0x2E or 0x2F, i.e, italics specified
        m_uCurrFGEffect |= AM_L21_FGEFFECT_ITALICS ;
    
    // finally, mid-row code introduces a blank space
    PutCharInBuffer(0x20, TRUE) ;  // mark it as MRC too
    return TRUE ;
}


BOOL CLine21DataDecoder::DecodeMiscControlCode(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::DecodeMiscControlCode(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    BOOL        bResult ;
    
    switch (chFirst)
    {
        // case 0x15:
        // case 0x1D:
        //     m_uField = 2 ;   // the data is coming in Field 2
        
    case 0x14:      // misc control code -- channel 1
    case 0x1C:      // ditto -- channel 2
        switch (chSecond)
        {
        case 0x20:   // RCL: Resume Caption Loading
            bResult = HandleRCL(chFirst, chSecond) ;
            break ;
            
        case 0x21:   // BS:  Backspace
            bResult = HandleBS(chFirst, chSecond) ;
            break ;
            
        case 0x22:   // AOF: reserved
        case 0x23:   // AOF: reserved
            DbgLog((LOG_ERROR, 2, TEXT("AOF/AON as Misc ctrl code"))) ;
            return TRUE ;  // just ignore it
            
        case 0x24:   // DER: Delete to End of Row
            bResult = HandleDER(chFirst, chSecond) ;
            break ;
            
        case 0x25:   // RU2: Roll-Up Captions - 2 rows
        case 0x26:   // RU3: Roll-Up Captions - 3 rows
        case 0x27:   // RU4: Roll-Up Captions - 4 rows
            bResult = HandleRU(chFirst, chSecond, 2 + chSecond - 0x25) ;
            break ;
            
        case 0x28:   // FON: Flash On
            bResult = HandleFON(chFirst, chSecond) ;
            break ;
            
        case 0x29:   // RDC: Resume Direct Captioning
            bResult = HandleRDC(chFirst, chSecond) ;
            break ;
            
        case 0x2A:   // TR:  Text Restart
            bResult = HandleTR(chFirst, chSecond) ;
            break ;
            
        case 0x2B:   // RTD: Resume Text Display
            bResult = HandleRTD(chFirst, chSecond) ;
            break ;
            
        case 0x2C:   // EDM: Erase Displayed Memory
            bResult = HandleEDM(chFirst, chSecond) ;
            break ;
            
        case 0x2D:   // CR:  Carriage Return
            bResult = HandleCR(chFirst, chSecond) ;
            break ;
            
        case 0x2E:   // ENM: Erase Non-displayed Memory
            bResult = HandleENM(chFirst, chSecond) ;
            break ;
            
        case 0x2F:   // EOC: End of Caption (flip memories)
            bResult = HandleEOC(chFirst, chSecond) ;
            break ;
            
        default:
            DbgLog((LOG_ERROR, 2, TEXT("Invalid 2nd byte (0x%x) for Misc ctrl code (0x%x)"), 
                chSecond, chFirst)) ;
            return FALSE ;
        }  // end of switch (chSecond)
        break ;
        
        case 0x17:      // misc control code -- channel 1
        case 0x1F:      // ditto -- channel 2
            switch (chSecond)
            {
            case 0x21:   // TO1: Tab Offset 1 column
            case 0x22:   // TO2: Tab Offset 2 columns
            case 0x23:   // TO3: Tab Offset 3 columns
                bResult = HandleTO(chFirst, chSecond, 1 + chSecond - 0x21) ;
                break ;
                
            default:
                DbgLog((LOG_ERROR, 2, TEXT("Invalid 2nd byte (0x%x) for Misc ctrl code (0x%x)"), 
                    chSecond, chFirst)) ;
                return FALSE ;
            }  // end of switch (chSecond)
            break ;
            
        default:
            DbgLog((LOG_ERROR, 2, TEXT("Invalid 1st byte for Misc ctrl code"))) ;
            return FALSE ;
    }  // end of switch (chFirst)
    
    if (AM_L21_CCSTYLE_None == m_eCCStyle)
        DbgLog((LOG_TRACE, 2, TEXT("No CC style defined yet."))) ;
    else
        DbgLog((LOG_TRACE, 3, TEXT("CC style defined now (%d)."), m_eCCStyle)) ;
    
    return bResult ;  // return result of handling above
}


BOOL CLine21DataDecoder::ProcessSpecialChar(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::ProcessSpecialChar(0x%x, 0x%x)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // Table of special char Unicode values for Truetype font (Lucida Console)
    static UINT16 awSplCharTT[] = {
     0x00ae,    0x00b0,    0x00bd,    0x00bf,    0x2122,    0x00a2,    0x00a3,    0x266b,
     // 30h,       31h,       32h,       33h,       34h,       35h,       36h,       37h,
     0x00e0,    0x0000,    0x00e8,    0x00e2,    0x00ea,    0x00ee,    0x00f4,    0x00fb } ;
     // 38h,       39h,       3Ah,       3Bh,       3Ch,       3Dh,       3Eh,       3Fh 

    // Table of special char for non-Truetype font (Terminal) [alternate chars]
    static UINT16 awSplCharNonTT[] = {
     0x0020,    0x0020,    0x0020,    0x0020,    0x0020,    0x0020,    0x0020,    0x0020,
     // 30h,       31h,       32h,       33h,       34h,       35h,       36h,       37h,
     0x0041,    0x0000,    0x0045,    0x0041,    0x0045,    0x0049,    0x004f,    0x0055 } ;
     // 38h,       39h,       3Ah,       3Bh,       3Ch,       3Dh,       3Eh,       3Fh 

    if (AM_L21_CCSTYLE_None == m_eCCStyle)
    {
        DbgLog((LOG_TRACE, 3, TEXT("ProcessSpecialChar(): No CC style defined yet.  Returning..."))) ;
        return TRUE ;  // ??
    }
                
    if (m_eDataService != m_eUserService)
    {           
        DbgLog((LOG_TRACE, 3, TEXT("Special char for diff channel (%d)"), (int)m_eDataService)) ;
        return TRUE ;  // ??
    }
                
    // Check if it's a repeat of the last special. If so ignore it; else print it.
    if (m_bExpectRepeat)
    {
        if (m_chLastByte1 == (chFirst & 0x7F) && m_chLastByte2 == (chSecond & 0x7F))
        {
            // Got 2nd transmission of the spl char; reset flag and ignore bytepair
            m_bExpectRepeat = FALSE ;
            return TRUE ;
        }
                    
        // Otherwise we got a different spl char pair; process it and expect a
        // repeat of this new pair next time.
    }
    else  // this is the 1st transmission of this spl char pair
    {
        m_bExpectRepeat = TRUE ;
        // now go ahead and process it
    }
                
    //  This pair of bytes may be valid. So we need to remember them to check
    //  against the next such pair for a repeat (of spl chars).
    //  BTW, we store the bytes only after the parity bit is stripped.
    m_chLastByte1 = chFirst & 0x7F ;
    m_chLastByte2 = chSecond & 0x7F ;
                
    ASSERT((chSecond & 0x7F) >= 0x30  &&  (chSecond & 0x7F) <= 0x3F) ;
    if (! ValidParity(chSecond) )
    {
        DbgLog((LOG_TRACE, 3, TEXT("Bad parity for character <%d>"), chSecond)) ;
        ProcessPrintableChar(0x7F) ;  // put special char solid block (7F)
    }
    else
    {
        if (m_L21DDraw.IsTTFont())
            PutCharInBuffer(awSplCharTT[(chSecond & 0x7F) - 0x30]) ;
        else
            PutCharInBuffer(awSplCharNonTT[(chSecond & 0x7F) - 0x30]) ;
    }

    return TRUE ;
}


BOOL CLine21DataDecoder::ProcessControlCode(UINT uCodeType,
                                            BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, 
            TEXT("CLine21DataDecoder::ProcessControlCode(%u, 0x%x, 0x%x)"), 
            uCodeType, chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    // Make sure that the pair has valid parity bits
    if (! ValidParity(chSecond) )
    {
        DbgLog((LOG_TRACE, 1, TEXT("Invalid 2nd byte (%d) of Control Code pair -- ignoring pair"), chSecond)) ;
        return FALSE ;
    }
    
    BOOL  bSuccess = TRUE ;
    if (! ValidParity(chFirst) )
    {
        DbgLog((LOG_TRACE, 1, TEXT("Invalid 2nd byte (%d) of Control Code pair"), chFirst)) ;
        if (m_bExpectRepeat)  // if 2nd transmission of control code
        {
            if ((chSecond & 0x7F) == m_chLastByte2)  // we got the same 2nd byte
            {
                // most likely it's the retransmission garbled up -- ignore them
            }
            else   // different 2nd byte; just print it.
                bSuccess = ProcessPrintableChar((chSecond & 0x7F)) ;
            
            // Turn it off -- either 2nd byte matched => retransmit of control code
            //                or printed 2nd byte as a printable char
            m_bExpectRepeat = FALSE ;
        }
        else  // if 1st transmission of control code
        {
            bSuccess = ProcessPrintableChar(0x7F) && 
                ProcessPrintableChar((chSecond & 0x7F)) ;
        }
        return bSuccess ;
    }
    
    // Check if it's a repeat of the last control code. If so ignore it; else
    // set it so.
    if (m_bExpectRepeat)
    {
        if (m_chLastByte1 == (chFirst & 0x7F) && m_chLastByte2 == (chSecond & 0x7F))
        {
            // Got 2nd transmission of the control code; reset flag and ignore bytepair
            m_bExpectRepeat = FALSE ;
            return TRUE ;
        }
        
        // Otherwise we got a different control code pair; process it and expect a
        // repeat of this new pair next time.
    }
    else  // this is the 1st transmission of this control code pair
    {
        m_bExpectRepeat = TRUE ;
        // now go ahead and process it
    }
    
    //  Looks like this pair of bytes is going to be valid and at least has
    //  valid (odd) parity bits set.  So we need to remember them to check
    //  against the next such pair for a repeat (of control codes).
    //  BTW, we store the bytes only after the parity bit is stripped.
    
    chFirst = chFirst & 0x7F ;
    chSecond = chSecond & 0x7F ;
    
    m_chLastByte1 = chFirst ;
    m_chLastByte2 = chSecond ;
    
    switch (uCodeType)
    {
    case L21_CONTROLCODE_PAC:
        return DecodePAC(chFirst, chSecond) ;
        
    case L21_CONTROLCODE_MIDROW:
        return DecodeMidRowCode(chFirst, chSecond) ;
        
    case L21_CONTROLCODE_MISCCONTROL:
        return DecodeMiscControlCode(chFirst, chSecond) ;
        
    default:
        DbgLog((LOG_TRACE, 1, TEXT("Invalid code type (%u)"), uCodeType)) ;
        return FALSE ;  // not a control code
    }
}


BOOL CLine21DataDecoder::ProcessPrintableChar(BYTE ch)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::ProcessPrintableChar(%x)"), ch)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Printable char (?) for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }
    
    if (AM_L21_CCSTYLE_None == m_eCCStyle)
    {
        DbgLog((LOG_TRACE, 3, TEXT("ProcessPrintableChar(): No CC style defined yet. Skipping..."))) ;
        return FALSE ;
    }
    
    if (! IsStandardChar(ch & 0x7F) )
    {
        DbgLog((LOG_TRACE, 3, TEXT("Not a printable char."))) ;
        return FALSE ;
    }
    
    if (! ValidParity(ch) )  // if a printable char doesn't have valid parity
    {
        DbgLog((LOG_TRACE, 1, TEXT("Bad parity for (probably) printable char <%d>"), ch)) ;
        ch = 0x7F ;            // then replace it with 7Fh.
    }
    
    //
    // There is more twist to it than you think!!! Some special chars
    // are inside the standard char range.
    //
    BOOL  bResult = FALSE ;
    switch (ch & 0x7F)  // we only look at the parity-less bits
    {
        case 0x2A:  // lower-case a with acute accent
            if (m_L21DDraw.IsTTFont())
                bResult = PutCharInBuffer(0x00e1) ;
            else   // no TT font -- use 'A' as alternate char
                bResult = PutCharInBuffer(0x0041) ;
            break ;

        case 0x5C:  // lower-case e with acute accent
            if (m_L21DDraw.IsTTFont())
                bResult = PutCharInBuffer(0x00e9) ;
            else   // no TT font -- use 'E' as alternate char
                bResult = PutCharInBuffer(0x0045) ;
            break ;

        case 0x5E:  // lower-case i with acute accent
            if (m_L21DDraw.IsTTFont())
                bResult = PutCharInBuffer(0x00ed) ;
            else   // no TT font -- use 'I' as alternate char
                bResult = PutCharInBuffer(0x0049) ;
            break ;

        case 0x5F:  // lower-case o with acute accent
            if (m_L21DDraw.IsTTFont())
                bResult = PutCharInBuffer(0x00f3) ;
            else   // no TT font -- use 'O' as alternate char
                bResult = PutCharInBuffer(0x004f) ;
            break ;

        case 0x60:  // lower-case u with acute accent
            if (m_L21DDraw.IsTTFont())
                bResult = PutCharInBuffer(0x00fa) ;
            else   // no TT font -- use 'U' as alternate char
                bResult = PutCharInBuffer(0x0055) ;
            break ;

        case 0x7B:  // lower-case c with cedilla
            if (m_L21DDraw.IsTTFont())
                bResult = PutCharInBuffer(0x00e7) ;
            else   // no TT font -- use 'C' as alternate char
                bResult = PutCharInBuffer(0x0043) ;
            break ;

        case 0x7C:  // division sign
            if (m_L21DDraw.IsTTFont())
                bResult = PutCharInBuffer(0x00f7) ;
            else   // no TT font -- use ' ' as alternate char
                bResult = PutCharInBuffer(0x0020) ;
            break ;

        case 0x7D:  // upper-case N with tilde
            if (m_L21DDraw.IsTTFont())
                bResult = PutCharInBuffer(0x00d1) ;
            else   // no TT font -- use 'N' as alternate char
                bResult = PutCharInBuffer(0x004e) ;
            break ;

        case 0x7E:  // lower-case n with tilde
            if (m_L21DDraw.IsTTFont())
                bResult = PutCharInBuffer(0x00f1) ;
            else   // no TT font -- use 'N' as alternate char
                bResult = PutCharInBuffer(0x004e) ;
            break ;

        case 0x7F:  // solid block
            if (m_L21DDraw.IsTTFont())
                bResult = PutCharInBuffer(0x2588) ;
            else   // no TT font -- use ' ' as alternate char
                bResult = PutCharInBuffer(0x0020) ;
            break ;

        default:
            bResult = PutCharInBuffer(MAKECCCHAR(0, ch & 0x7F)) ;
            break ;
    }
    return bResult ;
}


BOOL CLine21DataDecoder::PutCharInBuffer(UINT16 wChar, BOOL bMidRowCode /* = FALSE */)
{
    DbgLog((LOG_TRACE, 5, 
        TEXT("CLine21DataDecoder::PutCharInBuffer(0x%x, %u)"), wChar, bMidRowCode)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // Make sure we have got a PAC or MidRow code specifying our row posn
    // thereby creating a line in which the in param char is going to be put.
    if (0 == GetNumLines())
        return FALSE ;
    
    int          i ;
    CCaptionChar cc ;
    
    cc.SetChar(wChar) ;
    cc.SetColor((UINT8)m_uCurrFGColor) ;
    //
    // If this char is a mid-row code (which is shown as blank in CC) then don't
    // set the underline (mainly) or italicized/flashing attrib for it, because 
    // a space should not (or need not) be shown with such attribs.  We skip the 
    // effect bits altogether for such chars.
    //
    if (bMidRowCode)
        cc.SetEffect(0) ;
    else
        cc.SetEffect((UINT8)m_uCurrFGEffect) ;
    cc.SetMidRowCode(bMidRowCode) ;
    
    i = GetCurrLine() ;
    int  iCurrCol = GetCurrCol() ;
    SetCaptionChar((UINT8)i, (UINT8)iCurrCol, cc) ;
    //
    // If we are overwriting existing chars, the # chars doesn't increase...
    //
    int  iNumCols = GetNumCols(i) ;
    if (iCurrCol >= iNumCols)  // increment # chars by the differenece
        IncNumChars(i, iCurrCol-iNumCols+1) ;
    IncCurrCol(1) ;  // ...but current column goes up anyway.
    
    SetCapBufferDirty(TRUE) ;  // some new caption char added -- ???
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleRCL(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleRCL(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (0x14 == chFirst)
        m_eDataService = AM_L21_CCSERVICE_Caption1 ;
    else
        m_eDataService = AM_L21_CCSERVICE_Caption2 ;
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("We switched to PopOn of non-selected service. Skipping..."))) ;
        return TRUE ;  // ??
    }

    if (AM_L21_CCSTYLE_PopOn  == m_eCCStyle)    // if already in pop-on mode...
        return TRUE ;                           // ... just ignore
    
    // decodes subsequent chars for pop-on into the non-displayed buffer, 
    // but doesn't affect currently displayed caption
    m_eLastCCStyle = SetCaptionStyle(AM_L21_CCSTYLE_PopOn) ; // gets CapBuffer address based on index
    
    SetRedrawAll(TRUE) ;  // we should redraw the whole caption now -- ???
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleBS(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleBS(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    // We should act ONLY IF the current data channel is Caption(C)/Text(T) which the user
    // has picked and the current byte pair is for the same substream (1 or 2 of C/T).
    if (m_eDataService == m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Backspace for same data and user channel"))) ;
        AM_LINE21_CCSERVICE eService ;
        if (0x14 == chFirst)
            eService = AM_L21_CCSERVICE_Caption1 ;
        else
            eService = AM_L21_CCSERVICE_Caption2 ;
        if (eService != m_eUserService)
        {
            DbgLog((LOG_TRACE, 3, TEXT("Backspace for other channel. Skipping..."))) ;
            return TRUE ;  // ??
        }
    }
    else  // we are getting data for a channel different from what user has opted
    {
        DbgLog((LOG_TRACE, 3, TEXT("Backspace for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }

    UINT  uCurrCol = GetCurrCol() ;
    if (0 == uCurrCol)   // no place to back up anymore
        return TRUE ;
    
    int  iLine = GetCurrLine() ;
    int  n ;
    if (MAX_CAPTION_COLUMNS - 1 == uCurrCol) // at last col
    {
        n = 2 ;  // erase 2 chars (?)
    }
    else   // in the middle of a row
    {
        n = 1 ;
    }
    SetCurrCol(uCurrCol - n) ;
    RemoveCharsInBuffer(n) ;
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleDER(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleDER(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    // We should act ONLY IF the current data channel is Caption(C)/Text(T) which the user
    // has picked and the current byte pair is for the same substream (1 or 2 of C/T).
    if (m_eDataService == m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Delete to End of Row for same data and user channel"))) ;
        AM_LINE21_CCSERVICE eService ;
        if (0x14 == chFirst)
            eService = AM_L21_CCSERVICE_Caption1 ;
        else
            eService = AM_L21_CCSERVICE_Caption2 ;
        if (eService != m_eUserService)
        {
            DbgLog((LOG_TRACE, 3, TEXT("Delete to End of Row for other channel. Skipping..."))) ;
            return TRUE ;  // ??
        }
    }
    else  // we are getting data for a channel different from what user has opted
    {
        DbgLog((LOG_TRACE, 3, TEXT("Delete to End of Row for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }

    RemoveCharsInBuffer(MAX_CAPTION_COLUMNS) ;  // delete as many as you can
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleRU(BYTE chFirst, BYTE chSecond, int iLines)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleRU(%u, %u, %d)"),
            chFirst, chSecond, iLines)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    if (0x14 == chFirst)
        m_eDataService = AM_L21_CCSERVICE_Caption1 ;
    else
        m_eDataService = AM_L21_CCSERVICE_Caption2 ;
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("We switched to RU%d of non-selected service. Skipping..."), iLines)) ;
        return TRUE ;  // ??
    }

    int iNumLines = 0 ;
    int iBaseRow  = 0 ;
    
    // Check if the current style is Roll-up
    if (AM_L21_CCSTYLE_RollUp != m_eCCStyle)
    {
        // Now set up for roll-up captioning
        m_eLastCCStyle = SetCaptionStyle(AM_L21_CCSTYLE_RollUp) ;
        iNumLines = IncNumLines(1) ;    // create the 1st line
        DbgLog((LOG_TRACE, 5, TEXT("HandleRU(,,%d): Increasing lines by 1 to %d"), iLines, iNumLines)) ;
        iBaseRow = MAX_CAPTION_ROWS ;   // by default base row at row 15
        SetCurrCol(0) ;                 // start at beginning of line
    }
    else  // already in Roll-up mode; don't clear buffer, re-use current base row etc.
    {
        // if the current roll-up window height is more than the one
        // newly specified then remove the extra lines from the top
        iNumLines = GetNumLines() ;
        for (int i = 0 ; i < iNumLines - iLines ; i++)
            MoveCaptionLinesUp() ;
        
        //
        // If we remove even one line from the top, we must not be scrolling
        // anymore, for now.
        //
        if (iNumLines > iLines)
		{
			DbgLog((LOG_TRACE, 5, TEXT("HandleRU(,,): %d lines reduced to %d"), iNumLines, iLines)) ;
            SetScrollState(FALSE) ;
			iNumLines = iLines ;
		}
        
        if (iNumLines > 0)  // if we have lines from prev roll-up session
        {
            // save the prev base row value as it's the default base row next
			DbgLog((LOG_TRACE, 5, TEXT("HandleRU(,,%d): %d lines"), iLines, iNumLines)) ;
            iNumLines = min(iNumLines, iLines) ;
            iBaseRow = GetStartRow(iNumLines-1) ;
            if (0 == iBaseRow)  // a weird case -- we must patch to continue
            {
			    DbgLog((LOG_TRACE, 3, TEXT("HandleRU(,,%d): iBaseRow = 0.  Patch now!!!"), iLines)) ;

                // Detect the first line with non-zero row number
                int  i ;
                for (i = iNumLines ; i > 0 && 0 == iBaseRow ; i--)
                {
                    iBaseRow = GetStartRow(i-1) ;
                }
                if (0 == iBaseRow)  // still, probably it's only one (new) line
                {
                    DbgLog((LOG_TRACE, 5, TEXT("Base row for %d lines forced set to 15"), iNumLines)) ;
                    iBaseRow = MAX_CAPTION_ROWS ;   // by default base row at row 15
                }

                // In case we don't have room for everyone, move the current lines up
                // and adjust the base row value. This will fix any bad row numbers.
                if (iBaseRow + (iLines - iNumLines) > MAX_CAPTION_ROWS)
                {
                    iBaseRow = MAX_CAPTION_ROWS - (iLines - iNumLines) ;
                    RelocateRollUp(iBaseRow) ;
                }
            }  // end of if (0 == iBaseRow)
			DbgLog((LOG_TRACE, 5, TEXT("HandleRU(,,%d): base row = %d"), iLines, iBaseRow)) ;
        }
        else  // we were in Roll-up mode, but a EDM came just before the RUx
        {
            // Almost starting from scratch
            iNumLines = IncNumLines(1) ;    // create the 1st line
            DbgLog((LOG_TRACE, 5, TEXT("HandleRU(,,%d): Increasing lines from 0 to %d"), iLines, iNumLines)) ;
            iBaseRow = MAX_CAPTION_ROWS ;   // by default base row at row 15
        }

        // Don't change the current column location.
    }
    
    // Set the new values to start with
    SetMaxLines(iLines) ;
    SetCurrLine(iNumLines-1) ;  // or iLines-1??
    SetStartRow((UINT8)(iNumLines-1), (UINT8)iBaseRow) ;
    DbgLog((LOG_TRACE, 5, TEXT("HandleRU(): Line %d @ row %d"), iNumLines-1, iBaseRow)) ;
    SetRedrawLine(iNumLines-1, TRUE) ;  // by default new line is to be redrawn
    
    SetRedrawAll(TRUE) ;      // redraw the whole caption
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleFON(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleFON(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // We should act ONLY IF the current data channel is Caption(C)/Text(T) which the user
    // has picked and the current byte pair is for the same substream (1 or 2 of C/T).
    if (m_eDataService == m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("FlashOn for same data and user channel"))) ;
        AM_LINE21_CCSERVICE eService ;
        if (0x14 == chFirst)
            eService = AM_L21_CCSERVICE_Caption1 ;
        else
            eService = AM_L21_CCSERVICE_Caption2 ;
        if (eService != m_eUserService)
        {
            DbgLog((LOG_TRACE, 3, TEXT("FlashOn for other channel. Skipping..."))) ;
            return TRUE ;  // ??
        }
    }
    else  // we are getting data for a channel different from what user has opted
    {
        DbgLog((LOG_TRACE, 3, TEXT("FlashOn for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }

    m_uCurrFGEffect |= AM_L21_FGEFFECT_FLASHING ;
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleRDC(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleRDC(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    if (0x14 == chFirst)
        m_eDataService = AM_L21_CCSERVICE_Caption1 ;
    else
        m_eDataService = AM_L21_CCSERVICE_Caption2 ;
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("We switched to PaintOn of non-selected service. Skipping..."))) ;
        return TRUE ;  // ??
    }

    if (AM_L21_CCSTYLE_PaintOn == m_eCCStyle)   // if already in paint-on mode...
        return TRUE ;                           // ... just ignore
    
    m_eLastCCStyle = SetCaptionStyle(AM_L21_CCSTYLE_PaintOn) ;

    SetRedrawAll(TRUE) ;  // we should redraw the whole caption now -- ???
    
    return TRUE ;
}


//
// I am not sure what the Text Restart command is supposed to do. But it "sounds
// like" something to do with the text1/2 channels which we don't support now.
//
BOOL CLine21DataDecoder::HandleTR(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleTR(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (0x14 == chFirst)
        m_eDataService = AM_L21_CCSERVICE_Text1 ;
    else
        m_eDataService = AM_L21_CCSERVICE_Text2 ;
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("We switched to Text mode. Don't do anything."))) ;
        return TRUE ;  // ??
    }

    return TRUE ;
}


BOOL CLine21DataDecoder::HandleRTD(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleRTD(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (0x14 == chFirst)
        m_eDataService = AM_L21_CCSERVICE_Text1 ;
    else
        m_eDataService = AM_L21_CCSERVICE_Text2 ;
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("We switched to Text mode. Don't do anything."))) ;
        return TRUE ;  // ??
    }
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleEDM(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleEDM(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    AM_LINE21_CCSERVICE eService ;
    if (0x14 == chFirst)
        eService = AM_L21_CCSERVICE_Caption1 ;
    else
        eService = AM_L21_CCSERVICE_Caption2 ;

    //
    // I am not sure what I am doing is right, but this seems to be the only way to
    // achieve how CC is supposed to look.
    // I thought if the decoder is in Text mode and it gets an EDM, it's supposed to
    // ignore it, just like the BS, DER, CR etc commands.  But that leaves junk on
    // screen. So I am interpretting the spec as saying "erase whatever is in display
    // memory whatever mode -- text/CC, you are in".
    //
    if (eService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Erase DispMem for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }
    
    CCaptionBuffer *pDispBuff ;

    // next redraw will show blank caption for non-PopOn style ONLY
    switch (m_eCCStyle)
    {
    case AM_L21_CCSTYLE_RollUp:
        SetScrollState(FALSE) ;  // not scrolling now at least
        // fall through to do more...
        
    case AM_L21_CCSTYLE_PaintOn:
        // when display memory is cleared, the attribs should be cleared too
        m_uCurrFGEffect = 0 ;
        m_uCurrFGColor = AM_L21_FGCOLOR_WHITE ;
        // fall through to do more...
        
    case AM_L21_CCSTYLE_PopOn:
        pDispBuff = GetDisplayBuffer() ;
        ASSERT(pDispBuff) ;
        if (pDispBuff)
            pDispBuff->ClearBuffer() ;
        pDispBuff->SetRedrawAll(TRUE) ;
        break ;
    }
    
    //
    // To clear the screen content we should clear internal DIB section which
    // will in turn cause a (clear) sample to be output erasing currently
    // displayed CC.
    //
    m_L21DDraw.FillOutputBuffer() ;

    return TRUE ;
}


void CLine21DataDecoder::SetNewLinePosition(int iLines, UINT uCurrRow)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::SetNewLinePosition(%d, %u)"), 
            iLines, uCurrRow)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    int     iMaxLines = GetMaxLines() ;
    
    // Check if scroll up is needed or not
    if (iLines >= iMaxLines)
    {
        DbgLog((LOG_TRACE, 1, TEXT("Too many lines. Locate and remove one blank line."))) ;
        
        if (AM_L21_CCSTYLE_RollUp == m_eCCStyle)  // if in roll-up mode
        {
            // We shouldn't be here at all. Anyway, complain and remove the top line.
            DbgLog((LOG_ERROR, 0, 
                TEXT("ERROR: How do we have too many lines in roll-up mode (%d vs. max %d)?"),
                iLines, iMaxLines)) ;
            ASSERT(FALSE) ;  // so that we don't miss it
            RemoveLineFromBuffer(0, TRUE) ; // move line #2 onwards up
            iLines-- ;
        }
        else  // non Roll-up mode
        {
            // See if there is a blank line. If so, remove it to make space
            for (int i = 0 ; i < iLines ; i++)
            {
                if (GetNumCols(i) == 0)
                {
                    DbgLog((LOG_TRACE, 3, TEXT("Found line #%d (1-based) blank -- removed."), i+1)) ;
                    RemoveLineFromBuffer((UINT8)i, FALSE) ; // just remove line; don't move up following lines
                    iLines-- ;
                    break ;    // got one line -- enough.
                }
            }
            
            // HACK HACK: This should never happen, but....
            // If the number of lines is still too many, just overwrite the 
            // last line (Is that good?? Oh well...)
            if ((iLines = GetNumLines()) >= iMaxLines)  // too many lines
            {
                DbgLog((LOG_ERROR, 1, TEXT("ERROR: Too many lines. Removing last line by force."))) ;
                RemoveLineFromBuffer(iLines-1, FALSE) ; // just remove the line
                iLines-- ;  // one less line
                SetCurrCol(0) ;  // we start at the beginning on the line
            }
        }
    }
    
    // Now we have to add a new line and set it up
    int iNum = IncNumLines(1) ;
    DbgLog((LOG_TRACE, 5, TEXT("SetNewLinePosition(): Increasing lines by 1 to %d"), iNum)) ;
    SetCurrLine((UINT8)iLines) ;
    SetStartRow((UINT8)iLines, (UINT8)uCurrRow) ;
    DbgLog((LOG_TRACE, 5, TEXT("SetNewLinePosition(): Line %d @ row %u"), iLines, uCurrRow)) ;
}


BOOL CLine21DataDecoder::HandleCR(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleCR(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // We should act ONLY IF the current data channel is Caption(C)/Text(T) which the user
    // has picked and the current byte pair is for the same substream (1 or 2 of C/T).
    if (m_eDataService == m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Carriage Return for same data and user channel"))) ;
        AM_LINE21_CCSERVICE eService ;
        if (0x14 == chFirst)
            eService = AM_L21_CCSERVICE_Caption1 ;
        else
            eService = AM_L21_CCSERVICE_Caption2 ;
        if (eService != m_eUserService)
        {
            DbgLog((LOG_TRACE, 3, TEXT("Carriage Return for other channel. Skipping..."))) ;
            return TRUE ;  // ??
        }
    }
    else  // we are getting data for a channel different from what user has opted
    {
        DbgLog((LOG_TRACE, 3, TEXT("Carriage Return for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }

    // Is it only allowed in roll-up style?  I think so based on the docs.
    
    switch (m_eCCStyle)
    {
    case AM_L21_CCSTYLE_PopOn:
    case AM_L21_CCSTYLE_PaintOn:
        DbgLog((LOG_ERROR, 1, TEXT("INVALID: CR in Pop-on/Paint-on mode!!!"))) ;
        break ;  // or return FALSE ; ???
        
    case AM_L21_CCSTYLE_RollUp:  // This is the real one
        {
            int iRow ;
            int iLines = GetNumLines() ;
            if (0 == iLines)  // no CC line yet -- this is 1st line's data
            {
                iRow = MAX_CAPTION_ROWS ;  // base line's default row position
				SetStartRow((UINT8)iLines, (UINT8)iRow) ;
                DbgLog((LOG_TRACE, 5, TEXT("HandleCR(): Line %d @ row %d"), iLines, iRow)) ;
            }
            else if (1 == iLines)  // there is only 1 line so far
            {
                if (0 == GetNumCols(0))  // blank 1st line
                {
                    RemoveLineFromBuffer(0, TRUE) ; // remove blank 1st line
                    iLines = 0 ;                    // no line left

                    DbgLog((LOG_TRACE, 5, TEXT("Only blank line removed. Base line set to 15."))) ;
                    // HACK HACK
                    iRow = MAX_CAPTION_ROWS ;  // base line's default row position
				    SetStartRow((UINT8)iLines, (UINT8)iRow) ;
                }
            }
            else  // there are multiple lines already
            {
                // iRow = GetStartRow(iLines-1) + 1 ;  // +1 to go under last line
                if (m_bScrolling)
                {
                    SkipScrolling() ;
                    iLines = GetNumLines() ;  // we might have scrolled top line off
                }
            }
            if (iLines > 0)  // only if we already have a non-blank line
                SetScrollState(TRUE) ;  // ready to scroll
            iLines = IncNumLines(1) ;
            DbgLog((LOG_TRACE, 5, TEXT("HandleCR(): Increasing lines by 1 to %d"), iLines)) ;

            //
            // Number of lines is 1 more than iLines now. So iLines actually
            // points to the last line as a 0-based index.
            //
            SetCurrLine((UINT8)iLines-1) ;
            SetRedrawLine((UINT8)iLines-1, TRUE) ;  // new line always to be redrawn
            SetCurrCol(0) ;
            
            // Make sure to give up all the display attributes and chars 
            // for new row
            // RemoveCharsInBuffer(MAX_CAPTION_COLUMNS) ;  // should we or let it be cleared by a DER?
            m_uCurrFGColor = AM_L21_FGCOLOR_WHITE ;
            m_uCurrFGEffect = 0 ;  // no effect until a PAC/MRC comes
            
            break ;
        }
        
    default:  // Weird!! How did we come here?
        DbgLog((LOG_ERROR, 0, TEXT("WARNING: CR came for unknown mode"))) ;
        break ;
    }
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleENM(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleENM(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    AM_LINE21_CCSERVICE eService ;
    if (0x14 == chFirst)
        eService = AM_L21_CCSERVICE_Caption1 ;
    else
        eService = AM_L21_CCSERVICE_Caption2 ;

    //
    // I am not sure what I am doing is right, but this seems to be the only way to
    // achieve how CC is supposed to look.
    // I thought if the decoder is in Text mode and it gets an ENM, it's supposed to
    // ignore it, just like the BS, DER, CR etc commands.  But that leaves junk on
    // screen. So I am interpretting the spec as saying "erase whatever is in non-display
    // memory whatever mode -- text/CC, you are in".
    //
    if (eService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Erase non-DispMem for other channel. Skipping..."))) ;
        return TRUE ;  // ??
    }
    
    // Meant only for Pop-on style back back -- clear non-displayed buffer; 
    // display not affected until EOC
    m_aCCData[1 - GetBufferIndex()].ClearBuffer() ;
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleEOC(BYTE chFirst, BYTE chSecond)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleEOC(%u, %u)"), chFirst, chSecond)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    if (0x14 == chFirst)
        m_eDataService = AM_L21_CCSERVICE_Caption1 ;
    else
        m_eDataService = AM_L21_CCSERVICE_Caption2 ;
    if (m_eDataService != m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("We switched to PopOn mode of non-selected channel. skipping..."))) ;
        return TRUE ;  // ??
    }

    if (AM_L21_CCSTYLE_PopOn == m_eCCStyle)  // already in pop-on; flip buffers
    {
        OutputCCBuffer() ;   // output CC data from internal buffer to DDraw surface
        SwapBuffers() ;      // switch 0, 1
        //
        // Also need to update m_pCurrBuff so that we point to
        // the correct one after the above swap.
        // (m_pCurrBuff is set in SetCaptionStyle()).
        //
    }
    else   // change to pop-on style
    {
        m_eLastCCStyle = SetCaptionStyle(AM_L21_CCSTYLE_PopOn) ;
    }

    // Update current buffer pointer based on style and buffer index
    m_pCurrBuff = GetCaptionBuffer() ;
    ASSERT(m_pCurrBuff) ;
    if (m_pCurrBuff)
        m_pCurrBuff->SetRedrawAll(TRUE) ;  // we should redraw the whole caption now
    
    return TRUE ;
}


BOOL CLine21DataDecoder::HandleTO(BYTE chFirst, BYTE chSecond, int iCols)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::HandleTO(%u, %u, %d)"),
            chFirst, chSecond, iCols)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    // We should act ONLY IF the current data channel is Caption(C)/Text(T) which the user
    // has picked and the current byte pair is for the same substream (1 or 2 of C/T).
    if (m_eDataService == m_eUserService)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Tab Offset %d for same data and user channel"), iCols)) ;
        AM_LINE21_CCSERVICE eService ;
        if (0x17 == chFirst)
            eService = AM_L21_CCSERVICE_Caption1 ;
        else
            eService = AM_L21_CCSERVICE_Caption2 ;
        if (eService != m_eUserService)
        {
            DbgLog((LOG_TRACE, 3, TEXT("Tab Offset %d for other channel. Skipping..."), iCols)) ;
            return TRUE ;  // ??
        }
    }
    else  // we are getting data for a channel different from what user has opted
    {
        DbgLog((LOG_TRACE, 3, TEXT("Tab Offset %d for other channel. Skipping..."), iCols)) ;
        return TRUE ;  // ??
    }
    
    UINT8  uCurrCol  = (UINT8)GetCurrCol() ;
    uCurrCol += (UINT8)iCols ;
    if (uCurrCol >= MAX_CAPTION_COLUMNS)
        uCurrCol = MAX_CAPTION_COLUMNS - 1 ;
    SetCurrCol(uCurrCol) ;
    
    return TRUE ;
}


//
// It checks as well as *updates* the number of chars in a line of caption
//
BOOL CLine21DataDecoder::IsEmptyLine(int iLine)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::IsEmptyLine(%ld)"), iLine)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    CCaptionChar*   pcc ;
    int  iNumChars = GetNumCols(iLine) ;
    BOOL bResult = TRUE ;
    int  i ;
    for (i = iNumChars - 1 ; i >= 0 ; i--) // going backwards (-1 due to 0-based index)
    {
        pcc = GetCaptionCharPtr((UINT8)iLine, (UINT8)i) ;
        ASSERT(pcc) ;
        if (pcc  &&  pcc->GetChar() != 0)  // got one
        {
            bResult = FALSE ;
            break ;  // enough
        }
    }

    if ( !bResult ) // only if there is some chars left on this line
        DecNumChars(iLine, iNumChars - (i + 1)) ;  // reduce # chars by the diff

    return bResult ;
}


BOOL CLine21DataDecoder::RemoveCharsInBuffer(int iNumChars)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::RemoveCharsInBuffer(%d)"), iNumChars)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    int          i, j, k, n ;
    CCaptionChar cc ;
    
    // Just to be sure, check a few things first
    if (GetNumLines() == 0 ||   // no line to delete from
        (n = GetNumCols(GetCurrLine())) == 0)      // no char on current line to delete
        return TRUE ;           // we are done!!
    
    // Prepare the replacement caption char
    cc.SetChar(0) ;  // 0 is transparent space
    cc.SetColor(AM_L21_FGCOLOR_WHITE) ;
    cc.SetEffect(0) ;
    cc.SetDirty(TRUE) ;
    
    // Find the location to clear
    i = GetCurrLine() ;
    j = GetCurrCol() ;
    
    // Check that we are not trying to delete too many chars.
    // Remember: current col + # chars to delete <= MAX.
    if (iNumChars + j > MAX_CAPTION_COLUMNS)  // try it and see!!!
        iNumChars = MAX_CAPTION_COLUMNS - j ;
    
    // Clear the necessary chars
    for (k = 0 ; k < iNumChars ; k++)
    {
        if (j + k < n)          // if a char before the last char is removed, ...
            DecNumChars(i, 1) ; // ... reduce # chars by 1
        SetCaptionChar((UINT8)i, (UINT8)(j+k), cc) ;
    }
    
    if (0 == GetNumCols(i) ||  // # chars left on this line is 0  OR
        IsEmptyLine(i))        // no non-transparent chars on this line
        RemoveLineFromBuffer((UINT8)i, FALSE) ; // delete the line from buffer
    else                     // something left -- so redraw line
        SetRedrawAll(TRUE) ; // I really hate to do it, but I couldn't find a better way
    
    SetCapBufferDirty(TRUE) ;  // some caption char(s) removed
    
    return TRUE ;
}

void CLine21DataDecoder::SkipScrolling(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::SkipScrolling()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    int iLines = GetNumLines() ;
    SetScrollState(FALSE) ;    // we are no more scrolling
    
    if (iLines > GetMaxLines())  // too many line; remove top line
    {
        // remove the first text line and move subsequent lines up by one
        DbgLog((LOG_TRACE, 3, TEXT("Top line is being scrolled out"))) ;
        MoveCaptionLinesUp() ;
    }
    else   // otherwise move the line(s) up by a row and bring in new line
    {
        iLines-- ;   // last but one line is at base row
        UINT uBaseRow = GetStartRow(iLines-1) ;
        DbgLog((LOG_TRACE, 3, TEXT("Scrolling all lines up by 1 row"))) ;
        // The following call moves all the line up by including the not-yet-in 
        // line at the base row
        RelocateRollUp(uBaseRow) ;  // move all lines one row higher
    }
}


int CLine21DataDecoder::IncScrollStartLine(int iCharHeight)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::IncScrollStartLine(%d)"), 
            iCharHeight)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    if (0 == m_iScrollStartLine)  // starting to scroll
        MSR_START(m_idScroll) ;

    m_iScrollStartLine += m_L21DDraw.GetScrollStep() ;
    if (m_iScrollStartLine >= iCharHeight)
    {
        // Scrolling one line is done -- do the standard end of scroll stuff
        SkipScrolling() ;
        MSR_STOP(m_idScroll) ;  // scrolling ended
    }
    
    return m_iScrollStartLine ;
}


void CLine21DataDecoder::SetScrollState(BOOL bState)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::SetScrollState(%s)"), 
            bState ? TEXT("TRUE") : TEXT("FALSE"))) ;

    if (bState)                      // if turning ON scrolling
    {
        if (!m_bScrolling)           // change scroll line only if NOT scrolling now
            m_iScrollStartLine = 0 ; // start from first line
    }
    else                             // turning if OFF
        m_iScrollStartLine = 0 ;     // back to the start line

    m_bScrolling = bState ;          // set the spec-ed scrolling state
}


void CLine21DataDecoder::MoveCaptionLinesUp(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::MoveCaptionLinesUp()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    RemoveLineFromBuffer(0, TRUE) ; // remove the top line from buffer
    SetCapBufferDirty(TRUE) ;       // a line of text removed -- buffer dirty
}


void CLine21DataDecoder::CompleteScrolling(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::CompleteScrolling()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // For now we are doing a really cheapo solution, but it may work.
    if (m_bScrolling)
        SkipScrolling() ;
}


bool CLine21DataDecoder::OutputCCLine(int iLine, int iDestRow, 
                                      int iSrcCrop, int iDestOffset)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::OutputCCLine(%d,%d,%d,%d)"), 
            iLine, iDestRow, iSrcCrop, iDestOffset)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    int           c ;
    int           j ;
    CCaptionChar *pcc ;
    BOOL          bRedrawAll ;
    BOOL          bRedrawLine ;
    BOOL          bXparentSpace ;
    UINT16        wChar ;

#ifdef DUMP_BUFFER
    TCHAR    achTestBuffer[MAX_CAPTION_COLUMNS+5] ;
    int     iTest = 0 ;
#endif // DUMP_BUFFER

    c = GetNumCols(iLine) ;
    if (0 == c)        // if there is no char on a line, skip drawing it
        return true ;  // line drawing didn't fail

    bRedrawAll = IsRedrawAll() || m_L21DDraw.IsNewOutBuffer() ;

    // Redraw line if 
    // 1) redraw all flag is set   Or
    // 2) redraw line flag is set
    bRedrawLine = bRedrawAll || IsScrolling() || IsRedrawLine((UINT8)iLine) ;

    // First skip all the leading transparent spaces and then draw
    // the leading space.
    for (j = 0 ; j < c ; j++)
    {
        pcc = GetCaptionCharPtr((UINT8)iLine, (UINT8)j) ;
        if (pcc  &&  0 != pcc->GetChar())
        {
            // Add a leading blank space for each caption line, if either
            // a) the whole line is being redrawn   OR
            // b) the non-transparent space char is dirty so that
            //    the char will be drawn on top of the next space.
            if (bRedrawLine || pcc->IsDirty())
                m_L21DDraw.DrawLeadingTrailingSpace(iDestRow, j, iSrcCrop, iDestOffset) ;
            break ;
        }
#ifdef DUMP_BUFFER
        // ` (back quote) => transparent space for debug output
        achTestBuffer[iTest] = TEXT('`') ;
        iTest++ ;
#endif // DUMP_BUFFER
    }
    
    bXparentSpace = FALSE ;  // new line => no transparent char issue
    
    // Now print the dirty chars for the current line of caption
    for ( ; j < c ; j++)
    {
        pcc = GetCaptionCharPtr((UINT8)iLine, (UINT8)j) ;
        if (NULL == pcc)
        {
            ASSERT(!TEXT("Got bad pointer to CC char")) ;
            continue ;  // proceed to the next char
        }
        wChar = pcc->GetChar() ;
#ifdef DUMP_BUFFER
        // ` (back quote) => transparent space for debug output
        achTestBuffer[iTest] = wChar == 0 ? TEXT('`') : (TCHAR)(wChar & 0x7F) ;  // dump higher byte
        iTest++ ;
#endif // DUMP_BUFFER
        
        // We draw a char only if we have to, i.e,
        // 1) all the caption chars on the line has to be drawn fresh
        //    Or
        // 2) if a char has changed
        // This saves a lot of time doing ExtTextOut()s.
        if (bRedrawLine || pcc->IsDirty())
        {
            if (0 == wChar)  // got transparent space; set flag, don't draw
                bXparentSpace = TRUE ;
            else  // not transparent space
            {
                if (bXparentSpace)  // leading blank after transparent space
                {
                    // To draw 1 col behind, don't add 1 to j
                    m_L21DDraw.DrawLeadingTrailingSpace(iDestRow, j, iSrcCrop, iDestOffset) ;
                    bXparentSpace = FALSE ;  // it's done
                }
                m_L21DDraw.WriteChar(iDestRow, j+1, *pcc, iSrcCrop, iDestOffset) ;  // add 1 to j for CC chars
            }
            pcc->SetDirty(FALSE) ;   // char no more dirty
        }
    }  // end of for (j) loop

    // Draw a trailing blank space at line end
    m_L21DDraw.DrawLeadingTrailingSpace(iDestRow, c+1, iSrcCrop, iDestOffset) ;

    // Whether the line needed to be redrawn or not, let's clear it now
    SetRedrawLine((UINT8)iLine, FALSE) ;
    
#ifdef DUMP_BUFFER
    achTestBuffer[iTest] = 0 ;
    DbgLog((LOG_TRACE, 0, TEXT("    <%s>"), achTestBuffer)) ;
    // iTest = 0 ;  // for next line
#endif // DUMP_BUFFER
        
    return true ;  // success
}


bool CLine21DataDecoder::OutputBlankCCLine(int iLine, int iDestRow, 
                                           int iSrcCrop, int iDestOffset)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::OutputBlankCCLine(%d,%d,%d,%d)"), 
            iLine, iDestRow, iSrcCrop, iDestOffset)) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    int c = GetNumCols(iLine) ;  // find out (prev) line's length
    if (0 == c)
        return true ;

    // First skip all the leading transparent spaces and then draw
    // the leading space.
    CCaptionChar *pcc ;
    for (int j = 0 ; j < c ; j++)
    {
        pcc = GetCaptionCharPtr((UINT8)iLine, (UINT8)j) ;
        if (pcc  &&  0 != pcc->GetChar())
        {
            // Add a leading blank space for each caption line
            m_L21DDraw.DrawLeadingTrailingSpace(iDestRow, j, iSrcCrop, iDestOffset) ;
            break ;
        }
    }

    m_L21DDraw.WriteBlankCharRepeat(iDestRow, j+1, c-j, iSrcCrop, iDestOffset) ;

    m_L21DDraw.DrawLeadingTrailingSpace(iDestRow, c+1, iSrcCrop, iDestOffset) ;

    return true ;  // success
}


bool CLine21DataDecoder::OutputCCBuffer(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::OutputCCBuffer()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    // Output the CC data, based on the associated attributes, from the internal
    // buffer to the output buffer.
    int    i ;
    int    iNumLines ;
    int    iMaxLines ;
    int    iMax ;
    BOOL   bRedrawAll ;
    BOOL   bDrawNormal = FALSE ;   // draw whole CC normally (no scrolling)?

#ifdef DUMP_BUFFER
    DbgLog((LOG_TRACE, 0, TEXT("Caption Buffer Content:"))) ;
#endif // DUMP_BUFFER

    MSR_START(m_idTxt2Bmp) ;

    // We need to print all the CC chars to internal output buffer if
    // - a CC command came that needs a total output refresh  or
    // - we are scrolling  or
    // - we have a totally new internal output buffer
    bRedrawAll = IsRedrawAll() || IsScrolling() || m_L21DDraw.IsNewOutBuffer() ;
    if (bRedrawAll)
        m_L21DDraw.FillOutputBuffer() ;
    
    // Draw the chars for all cols of all rows that is dirty
    iNumLines = GetNumLines() ;
    iMaxLines = GetMaxLines() ;
    iMax = min(iNumLines, iMaxLines) ;
    DbgLog((LOG_TRACE, 5, TEXT("Will draw %d lines of total %d lines CC"), iMax, iNumLines)) ;

    if (IsScrolling())  // we are scrolling in roll-up mode
    {
        // Now fill out the bottom most row in the background color.
        // Use the last-but-one line's length to fill up.
        OutputBlankCCLine(iNumLines-2, GetStartRow((UINT8)(iNumLines-2)), 0, 0) ;

        // Output (probably) bottom part of the top line
        // Output Src = <bottom of the top line> to Dest w/o offset
        if (iNumLines > iMaxLines)  // we are scrolling out the top line
        {
            OutputCCLine(0, GetStartRow((UINT8)0), 
                         m_iScrollStartLine,   // +ve value means crop top part of Src
                         0) ;                  // no offset on the Dest side
        }
        else   // we are just scrolling a full line up
        {
            OutputCCLine(0, GetStartRow((UINT8)0), 
                         0,                     // no cropping of top part of Src
                         -m_iScrollStartLine) ; // offset on the Dest side to move up
        }

        // The lines in the middle (iNumLines - 1 points to the last line)
        for (i = 1 ; i < iNumLines - 1 ; i++)  // or iMax - 1 ???
        {
            if (0 == GetStartRow((UINT8)i))
            {
                DbgLog((LOG_TRACE, 5, TEXT("Skipping line %d at row %d"), i, GetStartRow((UINT8)i))) ;
                ASSERT(GetStartRow((UINT8)i)) ;
                continue ;
            }

            // Output Src = <whole line> to Dest = <scroll offset>
            OutputCCLine(i, GetStartRow((UINT8)i), 
                         0,    // no Src cropping -- take the whole char(s)
                         -m_iScrollStartLine) ;  // offset for Dest (up from normal)
        }  // end of for (i)

#if 0
        // Now fill out the bottom most part in the background color.
        // Use the previous line's length to fill up.
        OutputBlankCCLine(iNumLines-2, GetStartRow((UINT8)(iNumLines-2)),
                     -m_iScrollStartLine,   // -ve value means crop bottom part of Src
                     m_L21DDraw.GetCharHeight() - m_iScrollStartLine) ;  // offset for Dest (down from base row top)
#endif // #if 0

        // Output the top part of the bottom-most line
        // Output Src = <top of the bottom line> to Dest w/o offset
        OutputCCLine(iNumLines - 1, GetStartRow((UINT8)(iNumLines-2)),
                     -((int)m_L21DDraw.GetCharHeight() - m_iScrollStartLine), // -ve value means crop bottom part of Src
                     m_L21DDraw.GetCharHeight() - m_iScrollStartLine) ;  // offset for Dest (down from base row top)

        // Move to one scan line down for next output sample.
        // NOTE: It's MUCH harder than just ++-ing
        if (IncScrollStartLine(m_L21DDraw.GetCharHeight()) == 0)  // just completed scrolling
        {
            // Needed to fix Whistler bug 379387 -- force top scan lines out
            iNumLines = GetNumLines() ;        // get the latest number of lines
            iMax = min(iNumLines, iMaxLines) ; // update it now

            bDrawNormal = TRUE ;               // we'll redraw the current lines
            m_L21DDraw.FillOutputBuffer() ;    // it's scrolling, and a total redraw
            SetRedrawAll(TRUE) ;               // it's a good idea to redraw all now
        }
    }
    else   // no scrolling -- whatever mode we are in
    {
        bDrawNormal = TRUE ;
    }

    if (bDrawNormal)  // we need to draw all parts of all the lines
    {
        for (i = 0 ; i < iMax ; i++)
        {
            OutputCCLine(i, GetStartRow((UINT8)i), 0, 0) ;  // no cropping, no dest change
        }  // end of for (i)
    }
    
    MSR_STOP(m_idTxt2Bmp) ;

    // If the above steps were done because the caption buffer was 
    // dirty, then now we can mark the caption buffer as 
    // "no-more-dirty" as it has been output in the bitmap form and 
    // has been "redrawn all".
    SetCapBufferDirty(FALSE) ;
    SetRedrawAll(FALSE) ;
    m_L21DDraw.SetNewOutBuffer(FALSE) ;
    
    return true ;  // most probably we drew something
}


//
// Clear both buffers
//
BOOL CLine21DataDecoder::InitCaptionBuffer(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::InitCaptionBuffer(void)"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    m_aCCData[0].InitCaptionBuffer() ;  // clear buffer 0
    m_aCCData[1].InitCaptionBuffer() ;  // clear buffer 1
    SetBufferIndex(0) ;                 // reset CC buffer index
    
    return TRUE ;
}


//
// Clear buffer(s) based on the given style
//
BOOL CLine21DataDecoder::InitCaptionBuffer(AM_LINE21_CCSTYLE eCCStyle)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::InitCaptionBuffer(%d)"), (int)eCCStyle)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    switch (eCCStyle)
    {
    case AM_L21_CCSTYLE_PopOn:
        m_aCCData[0].InitCaptionBuffer() ;
        m_aCCData[1].InitCaptionBuffer() ;
        SetBufferIndex(0) ;   // reset CC buffer index
        break ;
        
    case AM_L21_CCSTYLE_RollUp:
    case AM_L21_CCSTYLE_PaintOn:
        m_aCCData[GetBufferIndex()].InitCaptionBuffer() ;
        break ;
        
    default:
        DbgLog((LOG_ERROR, 1, TEXT("InitCaptionBuffer(): Wrong Style (%d)!!"), eCCStyle)) ;
        return FALSE ;
    }

    return TRUE ;
}

//
// Caption style determines the buffer pointers to hold the caption chars.
// We make m_pCurrBuff point to the approp. buffer based on the new style.
// NOTE: The only other place where m_pCurrBuff may be changed is in 
// CLine21DataDecoder::HandleEOC() which flips the buffers back & front. So
// we also need to change m_pCurrBuff there too.
//
AM_LINE21_CCSTYLE CLine21DataDecoder::SetCaptionStyle(AM_LINE21_CCSTYLE eStyle)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::SetCaptionStyle(%d)"), eStyle)) ;
    CAutoLock   Lock(&m_csL21Dec) ;
    
    switch (eStyle)
    {
    case AM_L21_CCSTYLE_PopOn:
        m_pCurrBuff = &m_aCCData[1 - GetBufferIndex()] ;
        // Set CC style on both the buffers
        m_aCCData[0].SetStyle(eStyle) ;
        m_aCCData[1].SetStyle(eStyle) ;
        break ;
        
    case AM_L21_CCSTYLE_RollUp:
        InitCaptionBuffer() ;
        m_pCurrBuff = &m_aCCData[GetBufferIndex()] ;
        m_pCurrBuff->SetStyle(eStyle) ;  // set CC style on display buffer only
        break ;

    case AM_L21_CCSTYLE_PaintOn:
        if (AM_L21_CCSTYLE_PopOn == m_eCCStyle)   // if switching from PopOn to PaintOn...
            InitCaptionBuffer(eStyle) ;           // ...clear display buffer
        m_pCurrBuff = &m_aCCData[GetBufferIndex()] ;
        m_pCurrBuff->SetStyle(eStyle) ;  // set CC style on display buffer only
        break ;
        
    case AM_L21_CCSTYLE_None:  // This is done in init etc.
        m_pCurrBuff = NULL ;
        // Reset CC style on both the buffers
        m_aCCData[0].SetStyle(AM_L21_CCSTYLE_None) ;
        m_aCCData[1].SetStyle(AM_L21_CCSTYLE_None) ;
        break ;
        
    default:
        DbgLog((LOG_ERROR, 1, TEXT("SetCaptionStyle(): Invalid Style!!"))) ;
        m_pCurrBuff = NULL ;
        // Reset CC style on both the buffers
        m_aCCData[0].SetStyle(AM_L21_CCSTYLE_None) ;
        m_aCCData[1].SetStyle(AM_L21_CCSTYLE_None) ;
        return AM_L21_CCSTYLE_None ;
    }
    AM_LINE21_CCSTYLE  eOldStyle = m_eCCStyle ;
    m_eCCStyle = eStyle ;
    
    //
    // When CC style changes, some internal states also need to cleared
    //
    m_uCurrFGEffect = 0 ;
    m_uCurrFGColor = AM_L21_FGCOLOR_WHITE ;
    SetScrollState(FALSE) ;  // not scrolling now
    
    return eOldStyle ;
}

CCaptionBuffer * CLine21DataDecoder::GetDisplayBuffer(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CLine21DataDecoder::GetDisplayBuffer()"))) ;
    CAutoLock   Lock(&m_csL21Dec) ;

    switch (m_eCCStyle)
    {
    case AM_L21_CCSTYLE_PopOn:
    case AM_L21_CCSTYLE_RollUp:
    case AM_L21_CCSTYLE_PaintOn:
        return &m_aCCData[GetBufferIndex()] ;
        
    default:
        DbgLog((LOG_ERROR, 1, TEXT("GetDisplayBuffer(): Wrong Style!!"))) ;
        return NULL ;
    }
}

CCaptionBuffer * CLine21DataDecoder::GetCaptionBuffer(void)
{
    return &m_aCCData[1 - GetBufferIndex()] ;
}


void CLine21DataDecoder::SetBufferIndex(int iIndex)
{
    if (! (0 == iIndex  ||  1 == iIndex) )  // error!!
        return ;
    m_iBuffIndex = iIndex & 0x01 ;
}


void CLine21DataDecoder::ClearBuffer(void)
{
    if (m_pCurrBuff)
        m_pCurrBuff->ClearBuffer() ;
}

void CLine21DataDecoder::RemoveLineFromBuffer(UINT8 uLine, BOOL bUpNextLine)
{
    if (m_pCurrBuff)
        m_pCurrBuff->RemoveLineFromBuffer(uLine, bUpNextLine) ;
}

void CLine21DataDecoder::GetCaptionChar(UINT8 uLine, UINT8 uCol, CCaptionChar& cc)
{
    if (m_pCurrBuff)
        m_pCurrBuff->GetCaptionChar(uLine, uCol, cc) ;
}

void CLine21DataDecoder::SetCaptionChar(const UINT8 uLine, const UINT8 uCol,
                                        const CCaptionChar& cc)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetCaptionChar(uLine, uCol, cc) ;
}

CCaptionChar* CLine21DataDecoder::GetCaptionCharPtr(UINT8 uLine, UINT8 uCol)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetCaptionCharPtr(uLine, uCol) ;
    
    //
    //  Otherwise it's a very bad thing!!!!
    //
    DbgLog((LOG_ERROR, 0, TEXT("WARNING: m_pCurrBuff is NULL inside GetCaptionCharPtr()"))) ;
#ifdef DEBUG
    DebugBreak() ;  // don't want to miss debugging it!!!
#endif // DEBUG
    return NULL ;  // may be we should trap this and not fault
}

int  CLine21DataDecoder::GetMaxLines(void)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetMaxLines() ;
    return 0 ;  // that's best!!!
}

void CLine21DataDecoder::SetMaxLines(UINT uLines)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetMaxLines(uLines) ;
}

int  CLine21DataDecoder::GetNumLines(void)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetNumLines() ;
    return 0 ;
}

void CLine21DataDecoder::SetNumLines(UINT uLines)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetNumLines(uLines) ;
}

int  CLine21DataDecoder::GetNumCols(int iLine)
{
    if (NULL == m_pCurrBuff)
    {
        ASSERT(FALSE) ;
        return 0 ;   // should we??
    }
    
    if (iLine >= GetNumLines())
    {
        DbgLog((LOG_ERROR, 1, TEXT("Invalid line number (%d) ( > Total (%d)"), iLine, GetNumLines())) ;
        ASSERT(FALSE) ;
        return 0 ;
    }
    
    return m_pCurrBuff->GetCaptionLine(iLine).GetNumChars() ;
}


int  CLine21DataDecoder::GetCurrLine(void)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetCurrLine() ;
    ASSERT(FALSE) ;
    return 0 ; // should we??
}

int  CLine21DataDecoder::GetCurrCol(void)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetCurrCol() ;
    ASSERT(FALSE) ;
    return 0 ; // should we??
}

void CLine21DataDecoder::SetCurrLine(UINT8 uLine)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetCurrLine(uLine) ;
}

void CLine21DataDecoder::SetCurrCol(UINT8 uCol)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetCurrCol(uCol) ;
}

int  CLine21DataDecoder::GetStartRow(UINT8 uLine)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetStartRow(uLine & 0x7) ;
    
	ASSERT(m_pCurrBuff) ;

    //
    // This is very very bad!!!
    //
    DbgLog((LOG_ERROR, 0, TEXT("WARNING: m_pCurrBuff is NULL in GetStartRow()"))) ;
#ifdef DEBUG
    DebugBreak() ;  // don't want to miss debugging it!!!
#endif // DEBUG
    return 0 ;
}

void CLine21DataDecoder::SetStartRow(UINT8 uLine, UINT8 uRow)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetStartRow(uLine & 0x7, uRow) ;
}

int  CLine21DataDecoder::GetRowIndex(UINT8 uRow)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->GetRowIndex(uRow) ;
    else
    {
        ASSERT(FALSE) ;
        return 0 ;  // should we??
    }
}

void CLine21DataDecoder::SetRowIndex(UINT8 uLine, UINT8 uRow)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetRowIndex(uLine, uRow) ;
}

int CLine21DataDecoder::IncCurrCol(UINT uNumChars)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->IncCurrCol(uNumChars) ;
    ASSERT(FALSE) ;
    return 0 ; // is that OK?
}

int CLine21DataDecoder::DecCurrCol(UINT uNumChars)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->DecCurrCol(uNumChars) ;
    ASSERT(FALSE) ;
    return 0 ;  // is that OK?
}

int CLine21DataDecoder::IncNumChars(UINT uLine, UINT uNumChars)
{
    if (NULL == m_pCurrBuff)
    {
        ASSERT(FALSE) ;
        return 0 ;  // should we??
    }
    
    if (uLine >= (UINT)GetNumLines())
    {
        ASSERT(FALSE) ;
        return 0 ;
    }
    
    return m_pCurrBuff->GetCaptionLine(uLine).IncNumChars(uNumChars) ;
}

int CLine21DataDecoder::DecNumChars(UINT uLine, UINT uNumChars)
{
    if (NULL == m_pCurrBuff)
    {
        ASSERT(FALSE) ;
        return 0 ;  // should we??
    }
    
    if (uLine >= (UINT)GetNumLines())
    {
        ASSERT(FALSE) ;
        return 0 ;
    }
    return m_pCurrBuff->GetCaptionLine(uLine).DecNumChars(uNumChars) ;
}

int CLine21DataDecoder::IncNumLines(UINT uLines)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->IncNumLines(uLines) ;
    return 0 ;
}

int CLine21DataDecoder::DecNumLines(UINT uLines)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->DecNumLines(uLines) ;
    return 0 ;
}

void CLine21DataDecoder::MoveCaptionChars(int iLine, int iNum)
{
    if (m_pCurrBuff)
        m_pCurrBuff->MoveCaptionChars(iLine, iNum) ;
}

BOOL CLine21DataDecoder::IsCapBufferDirty(void)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->IsBufferDirty() ;
    return FALSE ;
}

BOOL CLine21DataDecoder::IsRedrawLine(UINT8 uLine)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->IsRedrawLine(uLine) ;
    return FALSE ;
}

BOOL CLine21DataDecoder::IsRedrawAll(void)
{
    if (m_pCurrBuff)
        return m_pCurrBuff->IsRedrawAll() ;
    return FALSE ;
}

void CLine21DataDecoder::SetCapBufferDirty(BOOL bState)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetBufferDirty(bState) ;
}

void CLine21DataDecoder::SetRedrawLine(UINT8 uLine, BOOL bState)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetRedrawLine(uLine, bState) ;
}

void CLine21DataDecoder::SetRedrawAll(BOOL bState)
{
    if (m_pCurrBuff)
        m_pCurrBuff->SetRedrawAll(bState) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\mixer\inc\devtype.h ===
// devtype.h : definitions for vidsvr.odl
// Copyright (c) 1995 - 1998  Microsoft Corporation.  All Rights Reserved.
//
#ifdef __cplusplus
# define odlhelp(x)
# define odlhelp2(x, y)
#else
# define odlhelp(x) [ helpstring(x)]
# define odlhelp2(x, y) [ x, y ]
#endif
// these device type elements are built into the ODL and are used to construct
// the DeviceType property

#ifdef __MKTYPLIB__

#include <dssenum.h>

        // these are the string resource id numbers in the vidsvr
        // for the progid strings
        typedef enum BpcVidsvrProgIds {
            BPC_IDS_VIDSVR_PROGID = 2100,
            BPC_IDS_COABPCDETAILS_PROGID = 2101,
        } BpcVidsvrProgIds;


        typedef enum {
            // 0 - 0x4000 are reserved for FILTER_STATE values from dshow sdk axcore.idl definitions
            BPC_STATE_APM_QUERY_SUSPEND  = 0x4000,  // vidsvr has received a query suspend
            BPC_STATE_APM_SUSPEND_FAILED = 0x4001,  // vidsvr has received a query suspend
            BPC_STATE_APM_RESUME         = 0x4002,  // received apm resume no user present
            BPC_STATE_APM_RESUME_USER    = 0x4003,  // received apm resume user present
            BPC_STATE_SHUTDOWN           = 0x4004,  // vidsvr has received a system shutdown notification
            BPC_STATE_REINIT_REQUEST     = 0x4005,  // vidsvr has received a reinitialization request from a client
                                                    // all clients should release any outstanding video 
                                                    // objects (devices, enumerators, etc.) except for the actual 
                                                    // video control itself and call vidocx reinit method 
                                                    // to allow reinit to occur.
            BPC_STATE_REINIT_STARTED     = 0x4006,  // all clients have agreed to reinit
            BPC_STATE_REINIT_COMPLETE    = 0x4007,  // reinitialization has completed, all clients may resume
                                                    // normal activity.  note: new devices may now exist
            BPC_STATE_UNKNOWN             = 0xffffffff,
        } BPCSTATETYPE;

        typedef enum statustype {
//          STATUS_POWER        = 0x01,
            STATUS_PLAY         = 0x02,
//          STATUS_THISPLAY     = 0x04,
            STATUS_PAUSED       = 0x08,
//          STATUS_AUDIO        = 0x10,
//          STATUS_VIDEO        = 0x20,
//          STATUS_RECORDING    = 0x40,
            STATUS_ACTIVE       = 0x80, // set when we're input or output
        } STATUSTYPE;

#if 0
// reserved for future use
        typedef enum ircommands {
            IR_PLAY = 1,
            IR_STOP = 2,
            IR_PAUSE = 3,
            IR_UNPAUSE = 4,
            IR_RECORD = 5,
            IR_REWIND = 6,
            IR_FASTFORWARD = 7,
            IR_SETCHANNEL = 8,
            IR_TOGGLEPOWER = 9,
            IR_POWERON = 10,
            IR_POWEROFF = 11
        } IRCOMMANDS;

    // these values must match those in quartzsrc\ui\controls\litevid\dispids.h
    typedef odlhelp2 (
        uuid(05589fa4-c356-11ce-bf01-00aa0055595a),
        helpstring("Event Notification Flags")
    ) enum
    {
        odlhelp("No Event Notification") eventNone              = 0x00,
        odlhelp("State Changes (default)") eventStateChange     = 0x01,
        odlhelp("Position Changes") eventPositionChange         = 0x02,
        odlhelp("Timer events") eventTimer                      = 0x04,
        odlhelp("Keyboard Events") eventKeyboard                = 0x08,
        odlhelp("Mouse Clicks") eventMouseClick                 = 0x10,
        odlhelp("Mouse Moves") eventMouseMove                   = 0x20
    } EventNotificationFlags;
#endif

    typedef odlhelp2 (
        uuid(05589faa-c356-11ce-bf01-00aa0055595a),
        helpstring("Movie Window Settings")
   ) enum
    {
        odlhelp("Default Size") movieDefaultSize,
        odlhelp("Half Size") movieHalfSize,
        odlhelp("Double Size") movieDoubleSize,
        odlhelp("Maximum Size") movieMaximizeSize,
        odlhelp("Full Screen") movieFullScreen,
        odlhelp("User Defined (enforce Aspect Ratio)") moviePermitResizeWithAspect,
        odlhelp("User Defined (ignore Aspect Ratio)") moviePermitResizeNoRestrict
    } MovieWindowSetting;


    typedef odlhelp2(
        uuid(05589fab-c356-11ce-bf01-00aa0055595a),
        helpstring("State of Movie Clip")
    ) enum
    {
        // These values MUST be the same as the State_ constants in quartz\sdk\include\strmif.h
        odlhelp("Movie is stopped") stateStopped,
        odlhelp("Movie is paused") statePaused,
        odlhelp("Movie is running") stateRunning
    } State;


    typedef odlhelp2(
        uuid(05589fac-c356-11ce-bf01-00aa0055595a),
        helpstring("Display Mode")
    ) enum
    {
        odlhelp("Time") modeTime,
        odlhelp("Frames") modeFrames
    } DisplayMode;
#endif
// mktyplib won't allow an enum to define disp ids
// vid ids
#define dispidPower      1008
#define dispidStartTime  1002
#define dispidStopTime   1003
#define dispidVideoOn    1004
#define dispidClosedCaption     1005
#define dispidDebug             1006
#define dispidEventNotification 1007
#define dispidDeviceCount       1001
#define dispidDisplayMode       1025
#define dispidInput     1020
#define dispidOutput    1021
#define dispidColorKey  1012
#define dispidFileName  1013
#define dispidPriority  1014
#define dispidUserName  1015
#define dispidLogin     1016
#define dispidVolume    1017
#define dispidBalance   1018
#define dispidImageSourceHeight  1019
#define dispidImageSourceWidth   1010
#define dispidMovieWindowSetting 1011
#define dispidCurrentState       1022
#define dispidCurrentPosition    1023
#define dispidDuration           1024
#define dispidPrerollTime        1009
#define dispidRate               1026
#define dispidLocaleID           1027
#define dispidRun                1028
#define dispidPause              1029
#define dispidStop               1030
#define dispidClose              1031
#define dispidOpen               1032
#define dispidDevices            1033
#define dispidControlling        1034
#define dispidTune               1035
#define dispidTSDevCount         1036
#define dispidLogout             1037
#define dispidAutoScan           1038
#define dispidAudioPinNames      1039
#define dispidAuxConfig          1040
#define dispidMinMaxChannel      1041
#define dispidReInit             1042
#define dispidMute               1043
#define dispidAudioPin           1044

    // Vid events
#define eventidGotControl     1001
#define eventidLostControl    1002
#define eventidDeviceMessage  1003
#define eventidStateChange    1004
#define eventidPositionChange 1005
#define eventidErrorMessage   1006

    //DeviceBase methods&props
#define dispidName         1001
#define dispidIsInput      1002
#define dispidIsOutput     1003
#define dispidHasChannel   1004
#define dispidHasFilename  1005
#define dispidDeviceType   1006
#define dispidStatus       1007
#define dispidProdName     1008
#define dispidDevFileName  1009
#define dispidChannel      1010
#define dispidSendMessage  1011
#define dispidCommand      1012
#define dispidChannelAvailable  1013
#define dispidCommandAvailable  1014
#define dispidDevImageSourceWidth   1015
#define dispidDevImageSourceHeight  1016
#define dispidDevCurrentPosition    1017
#define dispidDevDuration           1018
#define dispidDevPrerollTime        1019
#define dispidDevRate               1020
#define dispidDevCountryCode        1021
#define dispidDevVideoFrequency     1022
#define dispidDevAudioFrequency     1023
#define dispidDevDefaultVideoType   1024
#define dispidDevDefaultAudioType   1025
#define dispidDevVideoSubchannel    1026
#define dispidDevAudioSubchannel    1027
#define dispidDevTuningSpace        1028
#define dispidStatusString      1030
#define dispidDevVolume         1031
#define dispidDevBalance        1032
#define dispidActivate          1033
#define dispidDeActivate        1034
#define dispidDevPower          1035
#define dispidDevRun            1036
#define dispidDevStop           1037
#define dispidDevPause          1038
#define dispidDevRefresh        1039
#define dispidHasCA             1040
#define dispidDevVideoOn        1041
#define dispidDevCurrentState   1042
#define dispidDevOverScan       1043
#define dispidDevClosedCaption  1044
#define dispidDevMinMaxChannel  1045
#define dispidDevHasMinMaxChannel  1046

//
#define dispidItem              1500
#define dispidCount             1501
#define dispidHWnd              1502
#define dispidLCID              1503
#define dispidNotify            1504
#define dispidDevControlling    1505
#define dispidDevColorKey       1506
#define dispidDevPriority       1507
#define dispidDevInput          1508
#define dispidDevOutput         1509
#define dispidDevTune           1510
#define dispidDevTSDevCount     1511
#define dispidDevOpen           1512
#define dispidDevLogin          1513
#define dispidDevLogout         1514
#define dispidDevAutoScan       1515
#define dispidDevAudioPinNames  1516
#define dispidDevAuxConfig      1517
#define dispidDevReInit         1518
#define dispidDevMute           1519
#define dispidDevAudioPin       1520

// NOTE:  !!!! these must match the odl for the caserver(caserver.odl)
// don't change these without considering the impact on existing code
// normally you should not delete, rename, or reuse any of these.  you should
// add new ones and stop using the old ones while leaving them in place marked
// as obsolete.

// These symbols are #defined because mktyplib doesn't understand
// enum.  if we convert completely to midl then we could  change all
// of these to enums which would be more type safe for authors
// of provider specific dll's


// IBPCDetails interface
#define OABPCDETID_Channel        (1401)
#define OABPCDETID_StartTime      (1402)
#define OABPCDETID_Duration       (1403)
#define OABPCDETID_ItemID         (1404)
#define OABPCDETID_StorageId      (1405)
#define OABPCDETID_Title          (1406)
#define OABPCDETID_Rating         (1407)
#define OABPCDETID_Year           (1408)
#define OABPCDETID_Description    (1409)
#define OABPCDETID_ViewCost       (1410)
#define OABPCDETID_TapeCost       (1411)
#define OABPCDETID_Action         (1412)
#define OABPCDETID_Status         (1413)
#define OABPCDETID_Reason         (1414)
#define OABPCDETID_ReasonDesc     (1415)
#define OABPCDETID_ProviderBuffer (1416)
#define OABPCDETID_Expiry         (1417)
#define OABPCDETID_Location       (1418)
#define OABPCDETID_UserId         (1419)

// CAServer Interface
#define CASERVERID_ResetProviderSystem (1301)
#define CASERVERID_BuyItem             (1302)
#define CASERVERID_CancelItem          (1303)
#define CASERVERID_ItemDetails         (1304)
#define CASERVERID_ProviderEPGMask     (1305)
#define CASERVERID_DisplayConfigDialog (1306)
#define CASERVERID_UserName            (1307)
#define CASERVERID_UserArea            (1308)
#define CASERVERID_ProviderRating      (1309)
#define CASERVERID_ProviderStatus      (1310)
#define CASERVERID_ShowBox             (1311)
#define CASERVERID_HistoryItems        (1312)
#define CASERVERID_EmailMessages       (1313)
#define CASERVERID_ErrorMessages       (1314)
#define CASERVERID_HandleCardChaining  (1315)

// CAEvent Interface
// message event
#define CAEVENTID_CardMissing         (1201)
#define CAEVENTID_CardReady           (1202)
#define CAEVENTID_CardInvalid         (1203)
#define CAEVENTID_WrongCard           (1204)
#define CAEVENTID_BlackedOut          (1205)
#define CAEVENTID_RatingExceeded      (1206)
#define CAEVENTID_CostExceeded        (1207)
#define CAEVENTID_NotReady            (1208)
#define CAEVENTID_PasswordCleared     (1209)
#define CAEVENTID_SignalLost          (1210)
#define CAEVENTID_IntegrityFault      (1211)
#define CAEVENTID_OSDRequest          (1212)
// notifications
#define CAEVENTID_NewEmail            (1213)
#define CAEVENTID_NewCard             (1214)
#define CAEVENTID_ColdStart           (1215)
#define CAEVENTID_Ready               (1216)
#define CAEVENTID_CannotPurchase      (1217)
#define CAEVENTID_NoSubscriber        (1218)
#define CAEVENTID_CAFault             (1219)
#define CAEVENTID_CAFail              (1220)
#define CAEVENTID_CASuccess           (1221)
#define CAEVENTID_Retry               (1222)
#define CAEVENTID_Fail                (1223)
#define CAEVENTID_TuningChanged       (1224)
#define CAEVENTID_MessagesUpdated     (1233)
#define CAEVENTID_HistoryUpdated      (1234)
// special
#define CAEVENTID_TapingControlChanged (1225)
#define CAEVENTID_EPGGuideChanged     (1226)
#define CAEVENTID_HandlePurchaseOffer (1227)
#define CAEVENTID_RevokeEvent         (1228)
#define CAEVENTID_BillingCallStart    (1229)
#define CAEVENTID_BillingCallEnd      (1230)
#define CAEVENTID_CopyCard            (1231)
#define CAEVENTID_EPGFilterChanged    (1232)
#define CAEVENTID_CallbackFailed      (1235)

#define MSGID_Attributes              (1800)
#define MSGID_Message                 (1801)

#define EMSGID_MsgId                  (2000)
#define EMSGID_UserId                 (2001)
#define EMSGID_Received               (2002)
#define EMSGID_Expires                (2003)
#define EMSGID_Title                  (2004)
#define EMSGID_Message                (2005)
#define EMSGID_Read                   (2006)

#define SUSPEND_DeviceRelease         (2100)

#define VCTL_VBITune                  (2200)
#define VCTL_VBIStatus                (2201)



//all the collection interfaces

#define COLLECTID_Item     (0)
#define COLLECTID_Count    (1)
#define COLLECTID_Remove   (2)
#define COLLECTID_MarkRead (3)

// this is a standard system defined dispatch id
// however, due to the turmoil involved in midl vs. mktyplib
// and vc 4.1's poor support for OLE i can't include
// oaidl.h where this is defined and get a clean compile
// therefore i'm redefining it here.  this should be removed
// someday(hopefully vc4.2, maybe vc 5.0)
#ifndef DISPID_NEWENUM
#define DISPID_NEWENUM   (-4)
#endif

// end of file - devtype.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\mixer\inc\dssenum.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
#ifndef DSSENUM_H
#define DSSENUM_H
// DSSENUM.H

// STOCKBPCEVENT enumeration has been removed.  The allowable values
//  of events fired to the CA Server are those defined as constants
//  in the "CAEvent Interface" section of CAODL.H.

// Upper edge purchase actions

    typedef enum PURCHASEACTION {
        PAGETDETAILS,
        PAPURCHASETOVIEW,
        PAPURCHASETOTAPE,
        PACANCELVIEW,
        PACANCELTAPE,
        PAPREVIEW,
        PAGETEXTENDEDINFO
    } PURCHASEACTION;

// note that the bit mapping used here allows, for DSS, the direct conversion
// of lower edge status into upper edge status.
    typedef enum PURCHASESTATUS {
        PSVIEWTAKEN = 0,
        PSVIEWCANCELLED,
        PSVIEWREPORTED,
        PSPREVIEWTAKEN,

        PSVIEWAUTHORIZED,
        PSVIEWPURCHASED,
        PSTAPEPURCHASED,
        PSTAPEAUTHORIZED,

        PSTAPETAKEN,
        PSTAPECANCELLED,
        PSTAPEREPORTED,
        PSVIEWAVAILABLE,

        PSTAPEAVAILABLE,
        PSREVIEWAVAILABLE
    } PURCHASESTATUS;

// Reason values returned in BPCDetails when purchase actions are
//  attempted.
    typedef enum PURCHASEREASON {
        PRSUCCESS = 0,
        PRNOCALLBACK,
        PRNOSUBSCRIBER,
        PRRATING,
        PRSPENDING,
        PRCREDIT,
        PRWRONGCARD,
        PRCARDFULL,
        PRBLOCKED,
        PRBLACKOUT,
        PRTOOLATE,
        PRREDUNDANT,
        PRPPVFAILURE,
        PRBADDATA,
        PRCONTENTION,
		PRNOCARD,
		PRNOPIP
    } PURCHASEREASON;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\mixer\inc\mpconfig3.h ===
//==========================================================================;
//
//  Copyright (c) 1997 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

#ifndef __IMPConfig3__
#define __IMPConfig3__

#include <mpconfig.h>

// {CC2E5332-CCF8-11d2-8853-0000F80883E3}
DEFINE_GUID(IID_IMixerPinConfig3, 
0xcc2e5332, 0xccf8, 0x11d2, 0x88, 0x53, 0x0, 0x0, 0xf8, 0x8, 0x83, 0xe3);

// {ED7DA472-C083-11d2-8856-0000F80883E3}
DEFINE_GUID(IID_IEnumPinConfig, 
0xed7da472, 0xc083, 0x11d2, 0x88, 0x56, 0x0, 0x0, 0xf8, 0x8, 0x83, 0xe3);

#ifdef __cplusplus
extern "C" {
#endif

DECLARE_INTERFACE_(IMixerPinConfig3, IMixerPinConfig2)
{
    
    STDMETHOD (GetRenderTransport)(THIS_ 
        OUT AM_RENDER_TRANSPORT *pamRenderTransport					      
        ) PURE;
};

DECLARE_INTERFACE_(IEnumPinConfig, IUnknown)
{
    
    STDMETHOD (Next)(THIS_ 
        OUT IMixerPinConfig3 **pPinConfig					      
        ) PURE;
};


#ifdef __cplusplus
}
#endif


#endif // #define __IMPConfig__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\mixer\inc\ovmixpos2.h ===
// Copyright (c) 1999  Microsoft Corporation.  All Rights Reserved.
#ifndef __OVMIXPOS2__
#define __OVMIXPOS2__

#include <ovmixpos.h>

// {4EC741E2-BFAE-11d2-8856-0000F80883E3}
DEFINE_GUID(IID_IAMOverlayMixerPosition2, 
0x4ec741e2, 0xbfae, 0x11d2, 0x88, 0x56, 0x0, 0x0, 0xf8, 0x8, 0x83, 0xe3);

#ifdef __cplusplus
extern "C" {
#endif

DECLARE_INTERFACE_(IAMOverlayMixerPosition2, IAMOverlayMixerPosition)
{
    
    STDMETHOD (GetOverlayRects)(THIS_ 
        OUT RECT *src, OUT RECT* dest					      
        ) PURE;

    STDMETHOD (GetVideoPortRects)(THIS_ 
        OUT RECT *src, OUT RECT* dest					      
        ) PURE;

    STDMETHOD (GetBasicVideoRects)(THIS_ 
        OUT RECT *src, OUT RECT* dest					      
        ) PURE;

};


#ifdef __cplusplus
}
#endif


#endif // #define
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\mixer\inc\vpinfo.h ===
// Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
#ifndef __VP_INFO__
#define __VP_INFO__

// enum to specify, where we are going to do the cropping
typedef enum _AMVP_CROP_STATE
{	
    AMVP_NO_CROP,
    AMVP_CROP_AT_VIDEOPORT,
    AMVP_CROP_AT_OVERLAY
} AMVP_CROP_STATE;

// enum to specify, whether the videoport is in a stopped or running state
typedef enum _AMVP_STATE
{	
    AMVP_VIDEO_STOPPED,
    AMVP_VIDEO_RUNNING
} AMVP_STATE;

typedef enum _AM_TRANSFORM
{
    AM_SHRINK,
    AM_STRETCH
} AM_TRANSFORM;

typedef enum _AM_RENDER_TRANSPORT
{
    AM_OFFSCREEN,
    AM_OVERLAY,
    AM_GDI,
    AM_VIDEOPORT,
    AM_IOVERLAY,
    AM_VIDEOACCELERATOR
} AM_RENDER_TRANSPORT;

typedef struct _DRECT
{
    double left;
    double top;
    double right;
    double bottom;
} DRECT, *LPDRECT;

#ifndef DDVPCAPS_VBIANDVIDEOINDEPENDENT
#define DDVPCAPS_VBIANDVIDEOINDEPENDENT		0x00002000l	// Indicates that the VBI and video  can  be controlled by an independent processes.
#endif


// {E37786D2-B5B0-11d2-8854-0000F80883E3}
DEFINE_GUID(IID_IVPInfo,
0xe37786d2, 0xb5b0, 0x11d2, 0x88, 0x54, 0x0, 0x0, 0xf8, 0x8, 0x83, 0xe3);

DECLARE_INTERFACE_(IVPInfo, IUnknown)
{
    STDMETHOD (GetRectangles)(THIS_
               RECT *prcSource, RECT *prcDest
               ) PURE;
    STDMETHOD (GetCropState)(THIS_
	       AMVP_CROP_STATE* pCropState
	       ) PURE;
    STDMETHOD (GetPixelsPerSecond)(THIS_
	       DWORD* pPixelPerSec
	       ) PURE;
    STDMETHOD (GetVPDataInfo)(THIS_
               AMVPDATAINFO* pVPDataInfo
               ) PURE;
    STDMETHOD (GetVPInfo)(THIS_
               DDVIDEOPORTINFO* pVPInfo
               ) PURE;
    STDMETHOD (GetVPBandwidth)(THIS_
               DDVIDEOPORTBANDWIDTH* pVPBandwidth
               ) PURE;
    STDMETHOD (GetVPCaps)(THIS_
               DDVIDEOPORTCAPS* pVPCaps
               ) PURE;
    STDMETHOD (GetVPInputFormat)(THIS_
               LPDDPIXELFORMAT* pVPFormat
               ) PURE;
    STDMETHOD (GetVPOutputFormat)(THIS_
               LPDDPIXELFORMAT* pVPFormat
               ) PURE;
};


#if defined(CCHDEVICENAME)
#define AMCCHDEVICENAME CCHDEVICENAME
#else
#define AMCCHDEVICENAME 32
#endif
#define AMCCHDEVICEDESCRIPTION  256

#define AMDDRAWMONITORINFO_PRIMARY_MONITOR          0x0001
typedef struct {
    GUID*       lpGUID; // is NULL if the default DDraw device
    GUID        GUID;   // otherwise points to this GUID
} AMDDRAWGUID;


typedef struct {
    AMDDRAWGUID guid;
    RECT        rcMonitor;
    HMONITOR    hMon;
    DWORD       dwFlags;
    char        szDevice[AMCCHDEVICENAME];
    char        szDescription[AMCCHDEVICEDESCRIPTION];
    DDCAPS      ddHWCaps;
} AMDDRAWMONITORINFO;

// {c5265dba-3de3-4919-940b-5ac661c82ef4}
DEFINE_GUID(IID_IAMSpecifyDDrawConnectionDevice,
0xc5265dba, 0x3de3,0x4919, 0x94, 0x0b, 0x5a, 0xc6, 0x61, 0xc8, 0x2e, 0xf4);

DECLARE_INTERFACE_(IAMSpecifyDDrawConnectionDevice, IUnknown)
{
    // Use this method on a Multi-Monitor system to specify to the overlay
    // mixer filter which Direct Draw driver should be used when connecting
    // to an upstream decoder filter.
    //
    STDMETHOD (SetDDrawGUID)(THIS_
        /* [in] */ const AMDDRAWGUID *lpGUID
        ) PURE;

    // Use this method to determine the direct draw object that will be used when
    // connecting the overlay mixer filter to an upstream decoder filter.
    //
    STDMETHOD (GetDDrawGUID)(THIS_
        /* [out] */ AMDDRAWGUID *lpGUID
        ) PURE;

    // Use this method on a multi-monitor system to specify to the
    // overlay mixer filter the default Direct Draw device to use when
    // connecting to an upstream filter.  The default direct draw device
    // can be overriden for a particular connection by SetDDrawGUID method
    // described above.
    //
    STDMETHOD (SetDefaultDDrawGUID)(THIS_
        /* [in] */ const AMDDRAWGUID *lpGUID
        ) PURE;

    // Use this method on a multi-monitor system to determine which
    // is the default direct draw device the overlay mixer filter
    // will  use when connecting to an upstream filter.
    //
    STDMETHOD (GetDefaultDDrawGUID)(THIS_
        /* [out] */ AMDDRAWGUID *lpGUID
        ) PURE;


    // Use this method to get a list of Direct Draw device GUIDs and thier
    // associated monitor information that the overlay mixer can use when
    // connecting to an upstream decoder filter.
    //
    // The method allocates and returns an array of AMDDRAWMONITORINFO
    // structures, the caller of function is responsible for freeing this
    // memory when it is no longer needed via CoTaskMemFree.
    //
    STDMETHOD (GetDDrawGUIDs)(THIS_
        /* [out] */ LPDWORD lpdwNumDevices,
        /* [out] */ AMDDRAWMONITORINFO** lplpInfo
        ) PURE;
};


typedef struct {
    long    lHeight;       // in pels
    long    lWidth;        // in pels
    long    lBitsPerPel;   // Usually 16 but could be 12 for the YV12 format
    long    lAspectX;      // X aspect ratio
    long    lAspectY;      // Y aspect ratio
    long    lStride;       // stride in bytes
    DWORD   dwFourCC;      // YUV type code ie. 'YUY2', 'YV12' etc
    DWORD   dwFlags;       // Flag used to further describe the image
    DWORD   dwImageSize;   // Size of the bImage array in bytes, which follows this
                           // data structure

//  BYTE    bImage[dwImageSize];

} YUV_IMAGE;

#define DM_BOTTOMUP_IMAGE   0x00001
#define DM_TOPDOWN_IMAGE    0x00002
#define DM_FIELD_IMAGE      0x00004
#define DM_FRAME_IMAGE      0x00008


DECLARE_INTERFACE_(IDDrawNonExclModeVideo , IDDrawExclModeVideo )
{
    //
    // Call this function to capture the current image being displayed
    // by the overlay mixer.  It is not always possible to capture the
    // current frame, for example MoComp may be in use.  Applications
    // should always call IsImageCaptureSupported (see below) before
    // calling this function.
    //
    STDMETHOD (GetCurrentImage)(THIS_
        /* [out] */ YUV_IMAGE** lplpImage
        ) PURE;

    STDMETHOD (IsImageCaptureSupported)(THIS_
        ) PURE;

    //
    // On a multi-monitor system, applications call this function when they
    // detect that the playback rectangle has moved to a different monitor.
    // This call has no effect on a single monitor system.
    //
    STDMETHOD (ChangeMonitor)(THIS_
        /* [in]  */ HMONITOR hMonitor,
        /* [in]  */ LPDIRECTDRAW pDDrawObject,
        /* [in]  */ LPDIRECTDRAWSURFACE pDDrawSurface
        ) PURE;

    //
    // When an application receives a WM_DISPLAYCHANGE message it should
    // call this function to allow the OVMixer to recreate DDraw surfaces
    // suitable for the new display mode.  The application itself must re-create
    // the new DDraw object and primary surface passed in the call.
    //
    STDMETHOD (DisplayModeChanged)(THIS_
        /* [in]  */ HMONITOR hMonitor,
        /* [in]  */ LPDIRECTDRAW pDDrawObject,
        /* [in]  */ LPDIRECTDRAWSURFACE pDDrawSurface
        ) PURE;

    //
    // Applications should continually check that the primary surface passed
    // to the OVMixer does not become "lost", ie. the user entered a Dos box or
    // pressed Alt-Ctrl-Del.  When "surface loss" is detected the application should
    // call this function so that the OVMixer can restore the surfaces used for
    // video playback.
    //
    STDMETHOD (RestoreSurfaces)(THIS_
        ) PURE;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\mixer\ocx\resource.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by VRCtl.rc
//
#define IDS_PROJNAME                    100
#define IDR_VIDEORENDERCTL              101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\mixer\ocx\rnderctl.cpp ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
// RnderCtl.cpp : Implementation of CVideoRenderCtl
#include "stdafx.h"
#include "vrctl.h"
#ifndef FILTER_DLL
#include <streams.h>
#endif
#include "RnderCtl.h"
#ifdef FILTER_DLL
#include "mixerocx_i.c"
#endif

#ifdef FILTER_DLL
const CLSID CLSID_OverlayMixer = {0xcd8743a1,0x3736,0x11d0,{0x9e,0x69,0x0,0xc0,0x4f,0xd7,0xc1,0x5b}};

#else


/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtlStub::CVideoRenderCtlStub
//
/////////////////////////////////////////////////////////////////////////////
CVideoRenderCtlStub::CVideoRenderCtlStub(TCHAR *pName, LPUNKNOWN pUnk,HRESULT *phr) :
        CUnknown(pName, pUnk, phr),
        m_punkVRCtl(NULL)
{
    HRESULT hr;
    IUnknown *pUnkOuter = GetOwner();

    ++m_cRef;
    // create the control object
    hr = CoCreateInstanceInternal(CLSID_VideoRenderCtl, pUnkOuter, CLSCTX_INPROC_SERVER,
	    IID_IUnknown, (void**)&m_punkVRCtl);
    --m_cRef;

    if (FAILED(hr))
        *phr = hr;
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtlStub::~CVideoRenderCtlStub
//
/////////////////////////////////////////////////////////////////////////////
CVideoRenderCtlStub::~CVideoRenderCtlStub()
{
    if (m_punkVRCtl)
    {
        m_punkVRCtl->Release();
        m_punkVRCtl = NULL;
    }
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtlStub::~NonDelegatingQueryInterface
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CVideoRenderCtlStub::NonDelegatingQueryInterface(REFIID riid, void ** ppv)
{
    HRESULT hr;
    CheckPointer(ppv,E_POINTER);
    ValidateReadWritePtr(ppv,sizeof(PVOID));

    /* We know only about IUnknown */

    if (riid == IID_IUnknown)
    {
        GetInterface((LPUNKNOWN) (PNDUNKNOWN) this, ppv);
        hr = NOERROR;
    }
    else if (m_punkVRCtl)
    {
        hr = m_punkVRCtl->QueryInterface(riid, ppv);
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }

    return hr;


#if 0
    else if (m_punkVRCtl)
    {
        switch(riid)
        {
        case IID_IVideoRenderCtl:
        case IID_IDispatch:
        case IID_IViewObjectEx:
        case IID_IViewObject2:
        case IID_IViewObject:
        case IID_IOleInPlaceObjectWindowless:
        case IID_IOleInPlaceObject:
        case IID_IOleWindow:
        case IID_IOleInPlaceActiveObject:
        case IID_IOleControl:
        case IID_IOleObject:
        case IID_IQuickActivate:
        case IID_IPersistStorage:
        case IID_IPersistStreamInit:
        case IID_ISpecifyPropertyPages:
        case IID_IDataObject:
        case IID_IProvideClassInfo:
        case IID_IProvideClassInfo2:
        case IID_IConnectionPointContainer:
        case IID_IMixerOCXNotify:
        case IID_IBaseFilter:
            hr = m_punkVRCtl->QueryInterface(riid, ppv);
        default:
            *ppv = NULL;
            hr = E_NOINTERFACE;
        }

    }
    return hr;
#endif
}

#endif

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::CVideoRenderCtl
//
/////////////////////////////////////////////////////////////////////////////
CVideoRenderCtl::CVideoRenderCtl() :
    m_pwndMsgWindow(_T("STATIC"), this, 1),
    m_punkVideoRenderer(NULL),
    m_pIMixerOCX(NULL)
{
    m_ptTopLeftSC.x = 0;
    m_ptTopLeftSC.y = 0;
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::~CVideoRenderCtl
//
/////////////////////////////////////////////////////////////////////////////
CVideoRenderCtl::~CVideoRenderCtl()
{
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::FinalConstruct
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CVideoRenderCtl::FinalConstruct( )
{
    HRESULT hr;
    hr =CoCreateInstance(CLSID_OverlayMixer,
           GetControllingUnknown(), CLSCTX_INPROC_SERVER, IID_IUnknown,
           (void **)&m_punkVideoRenderer);
    if (SUCCEEDED(hr))
    {
        hr = m_punkVideoRenderer->QueryInterface(IID_IMixerOCX,
            (void **)&m_pIMixerOCX);
        if (SUCCEEDED(hr))
        {
            // its an interface from the aggregated object so release now
            m_pIMixerOCX->Release();
            RECT rc;
            memset(&rc, 0, sizeof(RECT));
            m_pwndMsgWindow.Create(NULL, rc, _T("VRCtlWindow"), 0);
            IMixerOCXNotify *pIMixerOCXNotify = NULL;
            hr = ControlQueryInterface(IID_IMixerOCXNotify, (void **) &pIMixerOCXNotify);
            if (SUCCEEDED(hr))
            {
                pIMixerOCXNotify->Release();
                hr = m_pIMixerOCX->Advise(pIMixerOCXNotify); // advise will addref
                if (SUCCEEDED(hr))
                    pIMixerOCXNotify->Release();
            }

        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::FinalRelease
//
/////////////////////////////////////////////////////////////////////////////
void CVideoRenderCtl::FinalRelease()
{
    if (m_pIMixerOCX) {
        (GetControllingUnknown())->AddRef();
        m_pIMixerOCX->UnAdvise();
        m_pIMixerOCX = NULL;
    }

    if (m_punkVideoRenderer) {
        m_punkVideoRenderer->Release();
        m_punkVideoRenderer = NULL;
    }

    // make sure there aren't any of our private message lying around in the
    // queue o.w. we will leak
    MSG Message;
    while (PeekMessage(&Message,m_pwndMsgWindow.m_hWnd,WM_MIXERNOTIFY,WM_MIXERNOTIFY,PM_REMOVE))
    {
        if (Message.lParam)
            delete ((void *) Message.lParam);
    }

    if (m_pwndMsgWindow.m_hWnd)
    {
        ::SendMessage(m_pwndMsgWindow.m_hWnd, WM_CLOSE, 0, 0);
    }
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::OnDraw
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CVideoRenderCtl::OnDraw(ATL_DRAWINFO& di)
{
    HRESULT hr = S_OK;
    if (m_pIMixerOCX)
        hr=m_pIMixerOCX->OnDraw(di.hdcDraw, (LPRECT) di.prcBounds);
    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::SetColorScheme
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CVideoRenderCtl::SetColorScheme(LOGPALETTE* pLogpal)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::GetExtent
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CVideoRenderCtl::GetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
    HRESULT hr;
    if (dwDrawAspect != DVASPECT_CONTENT)
	    return E_FAIL;
    if (psizel == NULL)
	    return E_POINTER;

    hr = E_NOINTERFACE;
    if (m_pIMixerOCX)
    {
        DWORD dwVideoWidth = 0;
        DWORD dwVideoHeight = 0;
        hr = m_pIMixerOCX->GetVideoSize(&dwVideoWidth, &dwVideoHeight);
        if (SUCCEEDED(hr))
        {
            SIZEL sizl;
            sizl.cx = dwVideoWidth;
            sizl.cy = dwVideoHeight;
            AtlPixelToHiMetric(&sizl, psizel);
        }
    }
    if (FAILED(hr))
        hr = IOleObjectImpl<CVideoRenderCtl>::GetExtent(dwDrawAspect, psizel);
    return hr;
}
/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::GetColorSet
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CVideoRenderCtl::GetColorSet(DWORD dwDrawAspect, LONG lindex,
        void* pvAspect, DVTARGETDEVICE* ptd, HDC hicTargetDev, LOGPALETTE** ppColorSet)
{
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::SetObjectRects
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CVideoRenderCtl::SetObjectRects(LPCRECT prcPos,LPCRECT prcClip)
{
    HRESULT hr;
    hr = IOleInPlaceObjectWindowlessImpl<CVideoRenderCtl>::SetObjectRects(prcPos, prcClip);
    if (SUCCEEDED(hr))
    {
        if (m_pIMixerOCX)
        {
            RECT rc = *prcPos;
            RECT rcClip = *prcClip;

            if(m_hWndCD)   // make Rect relative to our window if we have one
            {
                OffsetRect(&rcClip, -rc.left, -rc.top);
                OffsetRect(&rc, -rc.left, -rc.top);
                m_ptTopLeftSC.x = 0;
                m_ptTopLeftSC.y = 0;
                ::ClientToScreen(m_hWndCD, &m_ptTopLeftSC);
            }
            else
            {
                m_ptTopLeftSC.x = rc.left;
                m_ptTopLeftSC.y = rc.top;
                HWND hwnd;
                hr = GetContainerWnd(&hwnd);
                if (SUCCEEDED(hr))
                    ::ClientToScreen(hwnd, &m_ptTopLeftSC);
            }

            hr = m_pIMixerOCX->SetDrawRegion(&m_ptTopLeftSC, &rc, &rcClip);
        }
    }
    return hr;

}

//IMixerOCXNotify
/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::OnInvalidateRect
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CVideoRenderCtl::OnInvalidateRect(LPCRECT lpcRect)
{
    if (ValidateThreadOrNotify(MIXER_NOTID_INVALIDATERECT, (void *)lpcRect) == S_FALSE)
        return S_OK;

    HRESULT hr = E_FAIL;
    if(m_bWndLess && m_spInPlaceSite && m_bInPlaceActive)  // Windowless
    {

// This optimization is not working right now, at the minimum Chrome should be
// returning an Error on GetDC if it doesn't support the call..
#ifdef OPTIMIZE
        HDC hdc=NULL;
        if (SUCCEEDED(hr = m_spInPlaceSite->GetDC( NULL, 0, &hdc )))
        {
            if (m_pIMixerOCX)
                hr=m_pIMixerOCX->OnDraw(hdc, &m_rcPos);
            m_spInPlaceSite->ReleaseDC( hdc );
        }
#else
        hr = m_spInPlaceSite->InvalidateRect(lpcRect, FALSE);
#endif
    }
    else if ( m_hWndCD )
    {
        hr = ::InvalidateRect(m_hWndCD, lpcRect, FALSE);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::OnStatusChange
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CVideoRenderCtl::OnStatusChange(ULONG ulStatusFlags)
{
    if (ValidateThreadOrNotify(MIXER_NOTID_STATUSCHANGE, (void *)&ulStatusFlags) == S_FALSE)
        return S_OK;
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::OnDataChange
//
/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CVideoRenderCtl::OnDataChange(ULONG ulDataFlags)
{
    if (ValidateThreadOrNotify(MIXER_NOTID_DATACHANGE, (void *)&ulDataFlags) == S_FALSE)
        return S_OK;
    return E_NOTIMPL;
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::GetContainerWnd
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CVideoRenderCtl::GetContainerWnd(HWND *phwnd)
{
    HRESULT hr;
    if (phwnd == NULL)
        return E_INVALIDARG;

    *phwnd = NULL;
    hr = E_FAIL;

    if(m_bWndLess && m_spInPlaceSite)
    {
        hr = m_spInPlaceSite->GetWindow(phwnd);
    }
    else if (m_hWndCD)
    {
        *phwnd = ::GetParent(m_hWndCD);
        if (*phwnd)
            hr = S_OK;
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::OnMixerNotify
//
/////////////////////////////////////////////////////////////////////////////
LRESULT CVideoRenderCtl::OnMixerNotify(UINT nMsg, WPARAM wParam,
        LPARAM lParam, BOOL& fHandled)
{
    switch (wParam)
    {
    case MIXER_NOTID_INVALIDATERECT:
        OnInvalidateRect((LPRECT) lParam);
        break;
    case MIXER_NOTID_DATACHANGE:
        OnDataChange(*((ULONG *)lParam));
        break;
    case MIXER_NOTID_STATUSCHANGE:
        OnStatusChange(*((ULONG *)lParam));
        break;
    }
    if (lParam)
        delete (void *)lParam;

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl::OnMixerNotify
//
/////////////////////////////////////////////////////////////////////////////
HRESULT CVideoRenderCtl::ValidateThreadOrNotify(DWORD dwMixerNotifyId, void *pvData)
{
    HRESULT hr = S_OK;
    if (GetWindowThreadProcessId(m_pwndMsgWindow.m_hWnd, NULL) != GetCurrentThreadId())
    {
        void *pv = NULL;
        switch(dwMixerNotifyId)
        {
        case MIXER_NOTID_INVALIDATERECT:
            if (pvData)
            {
                pv = new RECT;
                if( pv ) {
                    memcpy(pv, pvData, sizeof(RECT));
                }
            }
            break;
        case MIXER_NOTID_DATACHANGE:
        case MIXER_NOTID_STATUSCHANGE:
            if (pvData)
            {
                pv = new ULONG;
                if( pv ) {
                    memcpy(pv, pvData, sizeof(ULONG));
                }
            }
            break;
        }
        ::PostMessage(m_pwndMsgWindow.m_hWnd, WM_MIXERNOTIFY, dwMixerNotifyId, (LPARAM) pv);

        hr = S_FALSE;
    }
    return hr;
}


//
// turn off warning about function being DLL export
//

#pragma warning( disable : 4273 )
typedef HRESULT (__stdcall* LPFNOCPF)(
    HWND hwndOwner,
    UINT x, UINT y,
    LPCOLESTR lpszCaption,
    ULONG cObjects,
    LPUNKNOWN FAR* ppUnk,
    ULONG cPages,
    LPCLSID pPageClsID,
    LCID lcid,
    DWORD dwReserved,
    LPVOID pvReserved
    );

extern "C"
HRESULT __stdcall
xxxOleCreatePropertyFrame(
    HWND hwndOwner,
    UINT x, UINT y,
    LPCOLESTR lpszCaption,
    ULONG cObjects,
    LPUNKNOWN FAR* ppUnk,
    ULONG cPages,
    LPCLSID pPageClsID,
    LCID lcid,
    DWORD dwReserved,
    LPVOID pvReserved
    )
{
    HRESULT hr = E_NOTIMPL;
    HINSTANCE hInst = LoadLibrary(TEXT("OLEAUT32.DLL"));

    if (hInst)
    {
        LPFNOCPF lpfn = (LPFNOCPF)GetProcAddress(hInst, "OleCreatePropertyFrame");

        if (lpfn)
        {
            hr = (*lpfn)(hwndOwner, x, y, lpszCaption,
                         cObjects, ppUnk, cPages, pPageClsID, lcid,
                         dwReserved, pvReserved);
        }

        FreeLibrary(hInst);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\mixer\ocx\stdafx.cpp ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information


#include "stdafx.h"
#ifdef FILTER_DLL


#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\mixer\ocx\rnderctl.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
// RnderCtl.h : Declaration of the CVideoRenderCtl

#ifndef __RNDERCTL_H__
#define __RNDERCTL_H__

#include "resource.h"       // main symbols

// private mixer notifications, one message with ids
#define WM_MIXERNOTIFY WM_USER + 0x203
#define MIXER_NOTID_INVALIDATERECT 1
#define MIXER_NOTID_DATACHANGE 2
#define MIXER_NOTID_STATUSCHANGE 3

#ifndef FILTER_DLL
HRESULT CoCreateInstanceInternal(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
        DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);

class CVideoRenderCtlStub : public CUnknown
{
public:
    DECLARE_IUNKNOWN
    static CUnknown *CreateInstance(LPUNKNOWN, HRESULT *);

    CVideoRenderCtlStub(TCHAR *pName, LPUNKNOWN pUnk,HRESULT *phr);
    ~CVideoRenderCtlStub();
    STDMETHOD(NonDelegatingQueryInterface)(REFIID riid, void ** ppv);

private:
    IUnknown *m_punkVRCtl;
};

#endif

/////////////////////////////////////////////////////////////////////////////
// CVideoRenderCtl
class ATL_NO_VTABLE CVideoRenderCtl : 
        public CComObjectRootEx<CComSingleThreadModel>,
        public CComCoClass<CVideoRenderCtl, &CLSID_VideoRenderCtl>,
        public CComControl<CVideoRenderCtl>,
        public IDispatchImpl<IVideoRenderCtl, &IID_IVideoRenderCtl, &LIBID_VRCTLLib>,
        public IProvideClassInfo2Impl<&CLSID_VideoRenderCtl, NULL, &LIBID_VRCTLLib>,
        public IPersistStreamInitImpl<CVideoRenderCtl>,
        public IPersistStorageImpl<CVideoRenderCtl>,
        public IQuickActivateImpl<CVideoRenderCtl>,
        public IOleControlImpl<CVideoRenderCtl>,
        public IOleObjectImpl<CVideoRenderCtl>,
        public IOleInPlaceActiveObjectImpl<CVideoRenderCtl>,
        public IViewObjectExImpl<CVideoRenderCtl>,
        public IOleInPlaceObjectWindowlessImpl<CVideoRenderCtl>,
        public IDataObjectImpl<CVideoRenderCtl>,
        public IConnectionPointContainerImpl<CVideoRenderCtl>,
        public ISpecifyPropertyPagesImpl<CVideoRenderCtl>,
        public IMixerOCXNotify
{
public:
    CVideoRenderCtl();
    ~CVideoRenderCtl();

    DECLARE_PROTECT_FINAL_CONSTRUCT()
    DECLARE_GET_CONTROLLING_UNKNOWN()
    DECLARE_REGISTRY_RESOURCEID(IDR_VIDEORENDERCTL)

    BEGIN_COM_MAP(CVideoRenderCtl)
	COM_INTERFACE_ENTRY(IVideoRenderCtl)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
	COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
	COM_INTERFACE_ENTRY_IMPL(IOleControl)
	COM_INTERFACE_ENTRY_IMPL(IOleObject)
	COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
	COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
	COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
	COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
	COM_INTERFACE_ENTRY_IMPL(IDataObject)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
        // private interface that the Renderer will query info on
        COM_INTERFACE_ENTRY(IMixerOCXNotify)
        // aggregated Video Renderer's interfaces
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IBaseFilter, m_punkVideoRenderer)
        COM_INTERFACE_ENTRY_AGGREGATE(IID_IMediaSeeking, m_punkVideoRenderer)
    END_COM_MAP()

    CContainedWindow m_pwndMsgWindow;

    BEGIN_PROPERTY_MAP(CVideoRenderCtl)
	// Example entries
	// PROP_ENTRY("Property Description", dispid, clsid)
	PROP_PAGE(CLSID_StockColorPage)
    END_PROPERTY_MAP()


    BEGIN_CONNECTION_POINT_MAP(CVideoRenderCtl)
    END_CONNECTION_POINT_MAP()


    BEGIN_MSG_MAP(CVideoRenderCtl)
	MESSAGE_HANDLER(WM_PAINT, OnPaint)
	MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
	MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
    ALT_MSG_MAP(1)
        MESSAGE_HANDLER(WM_MIXERNOTIFY,   OnMixerNotify)
    END_MSG_MAP()

public:
// IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }

//IMixerOCXNotify

    // invalidates the rect
    STDMETHOD(OnInvalidateRect)(LPCRECT lpcRect);

    // informs that a status change has occured, new status bits provided in ulStatusFlags
    STDMETHOD(OnStatusChange)(ULONG ulStatusFlags);

    // informs that data parameters, whose id is present in ilDataFlags has changed
    STDMETHOD(OnDataChange)(ULONG ulDataFlags);

// IOleObject
    STDMETHOD(SetColorScheme)(LOGPALETTE* /* pLogpal */);
    STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL *psizel);
    STDMETHOD(GetColorSet)(DWORD /* dwDrawAspect */,LONG /* lindex */, 
            void* /* pvAspect */, DVTARGETDEVICE* /* ptd */, HDC /* hicTargetDev */,
            LOGPALETTE** /* ppColorSet */);

// IOleInPlaceObject
    STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip);

    // internal window message handlers
    LRESULT OnMixerNotify(UINT nMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

// ATL helper over-rides
    HRESULT OnDraw(ATL_DRAWINFO& di);
    HRESULT FinalConstruct();
    void FinalRelease();

private:
// helpers
    HRESULT GetContainerWnd(HWND *phwnd);
    HRESULT ValidateThreadOrNotify(DWORD dwMixerNotifyId, void *pvData);


// members
    IUnknown *m_punkVideoRenderer;
    IMixerOCX *m_pIMixerOCX;
    POINT m_ptTopLeftSC; // top - left cordinates of the control in screen cordinates


};

#endif //__RNDERCTL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\mixer\ocx\stdafx.h ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__888D5477_CABB_11D1_8505_00A0C91F9CA0__INCLUDED_)
#define AFX_STDAFX_H__888D5477_CABB_11D1_8505_00A0C91F9CA0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#define _ATL_APARTMENT_THREADED

// ATL warnings....
#pragma warning (disable:4100 4610 4510 4244 4505 4701)

// ATL Win64 warnings
#pragma warning (disable:4189)


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#include <strmif.h>

#include <control.h>
#include <mixerocx.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__888D5477_CABB_11D1_8505_00A0C91F9CA0__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\mixer\ovmixer\bpcwrap.cpp ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
// 
//  bpcwrap.cpp
//
//  Wrapper for the hacky BPC resource management APIs for freeing a video 
//  port that is currently being used by the BPC's vidsvr.
//

#include <streams.h>
//below files required for ovmixer.h
#include <ddraw.h>
#include <mmsystem.h>	    // Needed for definition of timeGetTime
#include <limits.h>	    // Standard data type limit definitions
#include <ks.h>
#include <ksproxy.h>
#include <bpcwrap.h>
#include <ddmmi.h>
#include <amstream.h>
#include <dvp.h>
#include <ddkernel.h>
#include <vptype.h>
#include <vpconfig.h>
#include <vpnotify.h>
#include <vpobj.h>
#include <syncobj.h>
#include <mpconfig.h>
#include <ovmixpos.h>
//above files required for ovmixer.h
#include "macvis.h"
#include "ovmixer.h"

#include <initguid.h>
#include "ocidl.h"
#include "msbpcvid.h"
#include "assert.h"
#ifndef ASSERT
#define ASSERT assert
#endif
#include "bpcsusp.h"

CBPCWrap::CBPCWrap(COMFilter *pFilt) 
{
    m_pBPCSus = NULL;
    m_pFilt = pFilt;
}

CBPCWrap::~CBPCWrap() 
{
    if (m_pBPCSus != NULL) // this should cause BPC's OvMixer to reallocate the VP
        delete m_pBPCSus;
}

AMOVMIXEROWNER  CBPCWrap::GetOwner() 
{
    AMOVMIXEROWNER  owner=AM_OvMixerOwner_Unknown;

    //this IKsPin implementation has no knowledge of its owner (the mixer filter),
    //so we have to query for the property from here.

    // first get IPin for the primary pin
    IPin *pPin = (IPin *)(m_pFilt->GetPin(0));
    ASSERT(pPin);

    // now get IKsPropertySet
    IKsPropertySet *pKsPropSet=NULL;
    pPin->QueryInterface(IID_IKsPropertySet, (void**)&pKsPropSet);
    ASSERT(pKsPropSet);

    // finally get the owner
    DWORD cbRet;
    HRESULT hr;
    hr = pKsPropSet->Get(AMPROPSETID_NotifyOwner, AMPROPERTY_OvMixerOwner, NULL, 0, &owner, sizeof(owner), &cbRet);
    ASSERT(SUCCEEDED(hr) && cbRet==sizeof(owner));

    pKsPropSet->Release();

    return owner;
}


HRESULT CBPCWrap::TurnBPCOff()
{
    if (GetOwner()==AM_OvMixerOwner_BPC) {
        // we shouldn't suspend BPC if this instance of OvMixer is 
        // in the BPC graph.
        return S_OK;  
    }

    m_pBPCSus = new CBPCSuspend(); // this should cause BPC's OvMixer to free the VP
    
    if (m_pBPCSus == NULL) {
        return E_UNEXPECTED;
    } else {
        return S_OK;
    }
}

HRESULT CBPCWrap::TurnBPCOn()
{
    if (m_pBPCSus != NULL) // this should cause BPC's OvMixer to reallocate the VP
        delete m_pBPCSus;
    m_pBPCSus = NULL;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\mixer\ovmixer\ddmmi.h ===
/*==========================================================================
 *
 *  Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddmm.cpp
 *  Content:    Routines for using DirectDraw on a multimonitor system
 *
 ***************************************************************************/

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


HMONITOR DeviceFromWindow(HWND hwnd, LPSTR szDevice, RECT*prc);

#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\mixer\ocx\vrctl.cpp ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
// VRCtl.cpp : Implementation of DLL Exports.


#include "stdafx.h"
#include "resource.h"
#ifdef FILTER_DLL
#include "initguid.h"
#endif

#include "VRCtl.h"

#include "VRCtl_i.c"

#ifndef FILTER_DLL
#include <streams.h>
#endif 

#include "RnderCtl.h"



#ifdef FILTER_DLL

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_VideoRenderCtl, CVideoRenderCtl)
END_OBJECT_MAP()

CComModule _Module;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
		_Module.Term();
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}

#else

HRESULT CoCreateInstanceInternal(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
        DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv)
{

    HRESULT hr;
    IClassFactory *pCF;

    *ppv=NULL;

    hr = _Module.GetClassObject(rclsid, IID_IClassFactory, (void **)&pCF);
    if (FAILED(hr))
        return hr;

    hr=pCF->CreateInstance(pUnkOuter, riid, ppv);
    pCF->Release();
    return hr;
}

CUnknown *CVideoRenderCtlStub::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
    return (CUnknown *) new CVideoRenderCtlStub(NAME("Windowless Renderer Control Stub"), pUnk, phr);
    
} 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\mixer\ovmixer\bpcwrap.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
// 
//  bpcwrap.h
//
//  Wrapper for the hacky BPC resource management APIs for freeing a video 
//  port that is currently being used by the BPC's vidsvr.
//


//
//  Property set defines for notifying owner.
//
// {7B390654-9F74-11d1-AA80-00C04FC31D60}
DEFINE_GUID(AMPROPSETID_NotifyOwner, 
            0x7b390654, 0x9f74, 0x11d1, 0xaa, 0x80, 0x0, 0xc0, 0x4f, 0xc3, 0x1d, 0x60);

typedef enum _AMPROPERTY_NOTIFYOWNER {
    AMPROPERTY_OvMixerOwner = 0x01  //use AMOVMIXEROWNER
} AMPROPERTY_NOTIFYOWNER;

typedef enum _AMOVMIXEROWNER {
    AM_OvMixerOwner_Unknown = 0x01,
    AM_OvMixerOwner_BPC = 0x02
} AMOVMIXEROWNER;




class COMFilter;
class CBPCSuspend;

class CBPCWrap {
public:
    CBPCWrap(COMFilter *pFilt);
    ~CBPCWrap();
    HRESULT         TurnBPCOff();
    HRESULT         TurnBPCOn();

private:
    AMOVMIXEROWNER  GetOwner();
    CBPCSuspend *   m_pBPCSus;
    COMFilter *     m_pFilt;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\mixer\ovmixer\bpcsusp.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
//// bpcsuspend.h - header file for interface that allows external apps
//       to request that the bpc video server release all of its devices and
//       shutdown its directshow graph.  

// USAGE:
// in order to request that the bpc subsystem release its devices
// create an instance of the CBPCSuspend class
// to check if this succeeded use the IsBPCSuspended member function.  if IsBPCSuspended returns false 
// then that means that there are active bpc video clients and you must treat this as you would a
// device busy or device open type of failure.
// when you are done with the devices destroy the CBPCSuspend class and this will notify vidsvr
// that it can resume using the devices and return to background data capturing
//
// NOTE: you must compile vidsvr.odl and include the resulting .h before including this file
// 
// CLSID_BPCSuspend comes from the header file generated from compiling vidsvr.odl
// IBPCSuspended comes from the header file generated from compiling vidsvr.odl

// theory of operation:
// by using GetActiveObject instead of CoCreateInstance we don't force vidsvr to be loaded just to find
// out that it wasn't running in the first place.
// by returning an object that must be released to free the devices so that vidsvr can continue background
// data capture we utilize COM to manage this resource.  this means that if the external app that requested
// the devices crashes or leaks then the suspension object will be automatically released and 
// vidsvr can resume using the devices without requiring a system reboot or some other unfriendly intervention.

#if !defined(_MSBPCVideo_H_) && !defined(__msbpcvid_h__)
#error you must include the .h generated from compiling vidsvr.odl before including this file
#endif

#ifndef BPCSUSP_H
#define BPCSUSP_H
#pragma once

#include <oleauto.h>

#ifdef _CPPUNWIND
#pragma message("bpcsusp.h using exceptions")
#define BPCTRY try {
#ifdef _DEBUG
#define BPCCATCH } catch(...) { OutputDebugString("CBPCSuspend exception\r\n");}
#else
#define BPCCATCH } catch(...) {}
#endif
#define BPCNOTHROW throw()    
#else
#define BPCTRY
#define BPCCATCH
#define BPCNOTHROW
#endif

class CBPCSuspend {
    IDispatch* m_pSuspended;
    bool m_fBPCExists;
public:
   inline CBPCSuspend() BPCNOTHROW : m_pSuspended(NULL), m_fBPCExists(false) {
   BPCTRY
#ifdef _DEBUG
        OutputDebugString("CBPCSuspend()::CBPCSuspend()\r\n");
        TCHAR msgtemp[256];
#endif
        IUnknown *pUnkSuspendor = NULL;
        DWORD dwReserved;
        HRESULT hr = GetActiveObject(CLSID_BPCSuspend, &dwReserved, &pUnkSuspendor);
        if (SUCCEEDED(hr)) {
            IBPCSuspend *pSuspendor = NULL;
            hr = pUnkSuspendor->QueryInterface(IID_IBPCSuspend, reinterpret_cast<void **>(&pSuspendor));
            pUnkSuspendor->Release();
            if (SUCCEEDED(hr)) {

#ifdef _DEBUG
                OutputDebugString("CBPCSuspend()::CBPCSuspend() BPC exists\r\n");
#endif
                m_fBPCExists = true;
                hr = pSuspendor->DeviceRelease(0L, &m_pSuspended);
                if (FAILED(hr)) {
#ifdef _DEBUG
                    wsprintf(msgtemp, "CBPCSuspend()::CBPCSuspend() Suspendor->DeviceRelease() rc = %lx\r\n", hr);
                    OutputDebugString(msgtemp);
#endif
                    ASSERT(!m_pSuspended);
                }
#ifdef _DEBUG
                else {
                    wsprintf(msgtemp, "CBPCSuspend()::CBPCSuspend() BPC video server suspended\r\n");
                    OutputDebugString(msgtemp);
                }
#endif
                pSuspendor->Release();
            }


        } else {
#ifdef _DEBUG
            wsprintf(msgtemp, "CBPCSuspend()::CBPCSuspend() GetActiveObject() rc = %lx\r\n", hr);
            OutputDebugString(msgtemp);
#endif
        }
   BPCCATCH
   }
   inline ~CBPCSuspend() BPCNOTHROW {
       BPCTRY 
           if (m_fBPCExists && m_pSuspended) {
               m_pSuspended->Release();
                m_pSuspended = NULL;
           }
       BPCCATCH
   }
   inline bool IsBPCSuspended() BPCNOTHROW {
       // if m_fBPCExists but we weren't able to retrieve a suspension object then
       // there are active video clients and you must treat this as a device busy/failed to open type error
       if (m_fBPCExists && !m_pSuspended) {
           return false;
       }
       return true;
   }
};

#endif
// end of file - bpcsusp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\mixer\ovmixer\ddmc.h ===
/*==========================================================================;
 *
 *  Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddmc.h
 *  Content:	DirectDrawMotionComp include file
 *
 ***************************************************************************/

#ifndef __DDMC_INCLUDED__
#define __DDMC_INCLUDED__
#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown	    void
#undef  CO_E_NOTINITIALIZED
#define CO_E_NOTINITIALIZED 0x800401F0L
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GUIDS used by DirectDrawVideoPort objects
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
DEFINE_GUID( IID_IDDMotionCompContainer,	0xACA12120,0x3356,0x11D1,0x8F,0xCF,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );
DEFINE_GUID( IID_IDirectDrawMotionComp,		0xC9B2D740,0x3356,0x11D1,0x8F,0xCF,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );
#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDDMotionCompContainer		FAR *LPDDMOTIONCOMPCONTAINER;
typedef struct IDirectDrawMotionComp		FAR *LPDIRECTDRAWMOTIONCOMP;

typedef struct IDDMotionCompContainerVtbl DDMOTIONCOMPCONTAINERCALLBACKS;
typedef struct IDirectDrawMotionCompVtbl  DIRECTDRAWMOTIONCOMPCALLBACKS;


typedef struct _tag_DDMCUncompDataInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwUncompWidth;              // [in]     width of uncompressed data
    DWORD                   dwUncompHeight;             // [in]     height of uncompressed data
    DDPIXELFORMAT           ddUncompPixelFormat;        // [in]     pixel-format of uncompressed data
} DDMCUncompDataInfo, *LPDDMCUncompDataInfo;

typedef struct _tag_DDMCInternalMemInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwScratchMemAlloc;          // [out]    amount of scratch memory will the hal allocate for its private use
} DDMCInternalMemInfo, *LPDDMCInternalMemInfo;


typedef struct _tag_DDMCCompBufferInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwNumCompBuffers;           // [out]    number of buffers reqd for compressed data
    DWORD                   dwWidthToCreate;            // [out]    Width of surface to create
    DWORD                   dwHeightToCreate;           // [out]    Height of surface to create
    DWORD                   dwBytesToAllocate;          // [out]    Total number of bytes used by each surface
    DDSCAPS2                ddCompCaps;                 // [out]    caps to create surfaces to store compressed data
    DDPIXELFORMAT           ddPixelFormat;              // [out]    fourcc to create surfaces to store compressed data
} DDMCCompBufferInfo, *LPDDMCCompBufferInfo;


// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_DDMCBeginFrameInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    LPDIRECTDRAWSURFACE4    pddDestSurface;             // [in]     destination buffer in which to decoding this frame
    DWORD                   dwSizeInputData;            // [in]     size of other misc data to begin frame
    LPVOID                  pInputData;                 // [in]     pointer to misc data
    DWORD                   dwSizeOutputData;           // [in/out] size of other misc data to begin frame
    LPVOID                  pOutputData;                // [out]    pointer to misc data
} DDMCBeginFrameInfo, *LPDDMCBeginFrameInfo;

// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_DDMCEndFrameInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwSizeMiscData;             // [in]     size of other misc data to begin frame
    LPVOID                  pMiscData;                  // [in]     pointer to misc data
} DDMCEndFrameInfo, *LPDDMCEndFrameInfo;

typedef struct _tag_DDMCBUFFERINFO
{
    DWORD                   dwSize;                     // [in]    size of the struct
    LPDIRECTDRAWSURFACE4    pddCompSurface;             // [in]    pointer to buffer containing compressed data
    DWORD                   dwDataOffset;               // [in]    offset of relevant data from the beginning of buffer
    DWORD                   dwDataSize;                 // [in]    size of relevant data
} DDMCBUFFERINFO, *LPDDMCBUFFERINFO;


/*
 * INTERACES FOLLOW:
 *	IDDMotionCompContainer
 *	IDirectDrawMotionComp
 */

/*
 * IDDMotionCompContainer
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDDMotionCompContainer
DECLARE_INTERFACE_( IDDMotionCompContainer, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDDMotionCompContainer methods ***/
    STDMETHOD(CreateMotionComp)(THIS_ LPGUID, LPDDMCUncompDataInfo, LPVOID, DWORD, LPDIRECTDRAWMOTIONCOMP FAR *, IUnknown FAR *) PURE;
    STDMETHOD(GetCompBufferInfo)(THIS_ LPGUID, LPDDMCUncompDataInfo, LPDWORD, LPDDMCCompBufferInfo ) PURE;
    STDMETHOD(GetInternalMemInfo)(THIS_ LPGUID, LPDDMCUncompDataInfo, LPDDMCInternalMemInfo ) PURE;
    STDMETHOD(GetMotionCompGUIDs)(THIS_ LPDWORD, LPGUID ) PURE;
    STDMETHOD(GetUncompFormatsSupported)(THIS_ LPGUID, LPDWORD, LPDDPIXELFORMAT ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IMotionCompContainer_QueryInterface(p, a, b)            (p)->lpVtbl->QueryInterface(p, a, b)
#define IMotionCompContainer_AddRef(p)                          (p)->lpVtbl->AddRef(p)
#define IMotionCompContainer_Release(p)                         (p)->lpVtbl->Release(p)
#define IMotionCompContainer_CreateMotionComp(p,a,b,c,d,e,f)    (p)->lpVtbl->CreateMotionComp(p, a, b, c, d, e, f)
#define IMotionCompContainer_GetCompBufferInfo(p, a, b, c, d)   (p)->lpVtbl->GetCompBufferInfo(p, a, b, c, d)
#define IMotionCompContainer_GetInternalMemInfo(p, a, b, c)     (p)->lpVtbl->GetInternalMemInfo(p, a, b, c)
#define IMotionCompContainer_GetMotionCompGUIDs(p, a, b)        (p)->lpVtbl->GetMotionCompGUIDs(p, a, b)
#define IMotionCompContainer_GetUncompFormatsSupported(p,a,b,c) (p)->GetUncompFormatsSupported(p, a, b, c)
#else
#define IMotionCompContainer_QueryInterface(p, a, b)            (p)->QueryInterface(a, b)
#define IMotionCompContainer_AddRef(p)                          (p)->AddRef()
#define IMotionCompContainer_Release(p)                         (p)->Release()
#define IMotionCompContainer_CreateMotionComp(p, a, b, c,d,e,f) (p)->CreateMotionComp(a, b, c, d, e, f)
#define IMotionCompContainer_GetCompBufferInfo(p, a, b, c, d)   (p)->lpVtbl->GetCompBufferInfo(a, b, c, d)
#define IMotionCompContainer_GetInternalMemInfo(p, a, b, c)     (p)->lpVtbl->GetInternalMemInfo(a, b, c)
#define IMotionCompContainer_GetMotionCompGUIDs(p, a, b)        (p)->GetMotionCompGUIDs(a, b)
#define IMotionCompContainer_GetUncompFormatsSupported(p,a,b,c) (p)->GetUncompFormatsSupported(a, b, c)
#endif

#endif


/*
 * IDirectDrawMotionComp
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawMotionComp
DECLARE_INTERFACE_( IDirectDrawMotionComp, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirecytDrawMotionComp methods ***/
    STDMETHOD(BeginFrame)(THIS_ LPDDMCBeginFrameInfo) PURE;
    STDMETHOD(EndFrame)(THIS_ LPDDMCEndFrameInfo) PURE;
    STDMETHOD(QueryRenderStatus)(THIS_ DWORD) PURE;
    STDMETHOD(Execute)(THIS_ 
                       DWORD,            // Function
                       LPVOID,           // Input data
                       DWORD,            // Input data length
                       LPVOID,           // Output data
                       DWORD,            // Output data length
                       DWORD,            // Number of buffers
                       LPDDMCBUFFERINFO, // Buffer info array
                       DWORD             // Status cookie
                       ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IMotionComp_QueryInterface(p,a,b)      (p)->lpVtbl->QueryInterface(p,a,b)
#define IMotionComp_AddRef(p)                  (p)->lpVtbl->AddRef(p)
#define IMotionComp_Release(p)                 (p)->lpVtbl->Release(p)
#define IMotionComp_BeginFrame(p,a)            (p)->lpVtbl->BeginFrame(p,a)
#define IMotionComp_EndFrame(p,a)              (p)->lpVtbl->EndFrame(p,a)
#define IMotionComp_QueryRenderStatus(p,a,b)   (p)->lpVtbl->QueryRenderStatus(p,a,b)
#define IMotionComp_RenderMacroBlocks(p,a,b)   (p)->lpVtbl->RenderMacroBlocks(p,a,b)
#else
#define IMotionComp_QueryInterface(p,a,b)      (p)->QueryInterface(a,b)
#define IMotionComp_AddRef(p)                  (p)->AddRef()
#define IMotionComp_Release(p)                 (p)->Release()
#define IMotionComp_BeginFrame(p,a)            (p)->BeginFrame(a)
#define IMotionComp_EndFrame(p,a)              (p)->EndFrame(a)
#define IMotionComp_QueryRenderStatus(p,a,b)   (p)->QueryRenderStatus(a,b)
#define IMotionComp_RenderMacroBlocks(p,a,b)   (p)->RenderMacroBlocks(a,b)
#endif

#endif


#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\mixer\ovmixer\ddmm.cpp ===
/*==========================================================================
 *
 *  Copyright (c) 1995 - 1999  Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddmm.cpp
 *  Content:    Routines for using DirectDraw on a multimonitor system
 *
 ***************************************************************************/

//#define WIN32_LEAN_AND_MEAN
//#define WINVER 0x0400
//#define _WIN32_WINDOWS 0x0400
#include <streams.h>
#include <ddraw.h>
#include <ddmm.h>
#include <mmsystem.h>   // Needed for definition of timeGetTime
#include <limits.h>     // Standard data type limit definitions
#include <ddmmi.h>
#include <atlconv.h>
#include <dciddi.h>
#include <dvdmedia.h>
#include <amstream.h>

#include <ks.h>
#include <ksproxy.h>
#include <bpcwrap.h>
#include <dvp.h>
#include <ddkernel.h>
#include <vptype.h>
#include <vpconfig.h>
#include <vpnotify.h>
#include <vpobj.h>
#include <syncobj.h>
#include <mpconfig.h>
#include <ovmixpos.h>

#include <macvis.h>   // for Macrovision support
#include <ovmixer.h>
#include <initguid.h>
#include <malloc.h>

#define COMPILE_MULTIMON_STUBS
#include "MultMon.h"  // our version of multimon.h include ChangeDisplaySettingsEx

extern HINSTANCE LoadTheDDrawLibrary();
extern "C" const TCHAR chRegistryKey[];
const TCHAR szDDrawGUID[] = TEXT("DDraw Connection Device GUID");

const char szDisplay[] = "DISPLAY";
const char szDesc[] = "Primary Display Driver";


/******************************Public*Routine******************************\
* DeviceFromWindow
*
* find the direct draw device that should be used for a given window
*
* the return code is a "unique id" for the device, it should be used
* to determine when your window moves from one device to another.
*
*
* History:
* Tue 08/17/1999 - StEstrop - Created
*
\**************************************************************************/
HMONITOR
DeviceFromWindow(
    HWND hwnd,
    LPSTR szDevice,
    RECT *prc
    )
{
    HMONITOR hMonitor;

    if (GetSystemMetrics(SM_CMONITORS) <= 1)
    {
        if (prc)
            SetRect(prc, 0, 0,
                    GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN));

        if (szDevice)
            lstrcpyA(szDevice, szDisplay);

        return MonitorFromWindow(HWND_DESKTOP, MONITOR_DEFAULTTOPRIMARY);
    }

    //
    // The docs say that MonitorFromWindow will always return a Monitor.
    //

    hMonitor = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);
    if (prc != NULL || szDevice != NULL)
    {
        MONITORINFOEX mi;
        mi.cbSize = sizeof(mi);
        GetMonitorInfo(hMonitor, &mi);
        if (prc)
            *prc = mi.rcMonitor;

        USES_CONVERSION;
        if (szDevice)
            lstrcpyA(szDevice, T2A(mi.szDevice));
    }

    return hMonitor;
}


/*****************************Private*Routine******************************\
* GetCurrentMonitor
*
* find the current monitor
*
* History:
* Fri 08/20/1999 - StEstrop - Created
*
\**************************************************************************/
HMONITOR
COMFilter::GetCurrentMonitor(
    BOOL fUpdate
    )
{
    CAutoLock l(&m_csFilter);
    DbgLog((LOG_TRACE, 3, TEXT("Establishing current monitor = %hs"),
            m_lpCurrentMonitor->szDevice));

    if (fUpdate && GetOutputPin()) {

        RECT        rcMon;
        char        achMonitor[CCHDEVICENAME];   // device name of current monitor

        ASSERT(sizeof(achMonitor) == sizeof(m_lpCurrentMonitor->szDevice));
        HMONITOR hMon = DeviceFromWindow(GetWindow(), achMonitor, &rcMon);

        AMDDRAWMONITORINFO* p = m_lpDDrawInfo;
        for (; p < &m_lpDDrawInfo[m_dwDDrawInfoArrayLen]; p++) {

            if (hMon == p->hMon) {
                m_lpCurrentMonitor = p;
                break;
            }
        }

        DbgLog((LOG_TRACE, 3, TEXT("New monitor = %hs"),
                m_lpCurrentMonitor->szDevice));
    }


    return m_lpCurrentMonitor->hMon;
}


/******************************Public*Routine******************************\
* IsWindowOnWrongMonitor
*
* Has the window moved at least partially onto a monitor other than the
* monitor we have a DDraw object for?  ID will be the hmonitor of the
* monitor it is on, or 0 if it spans
*
* History:
* Thu 06/17/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
COMFilter::IsWindowOnWrongMonitor(
    HMONITOR *pID
    )
{
    AMTRACE((TEXT("COMFilter::IsWindowOnWrongMonitor")));


    *pID = m_lpCurrentMonitor->hMon;

    //
    // There is only 1 monitor.
    //

    RECT rc;
    HWND hwnd = GetWindow();

    if ( ! hwnd )
        return FALSE;

    if (GetSystemMetrics(SM_CMONITORS) > 1 && !IsIconic(hwnd)) {

        //
        // If the window is on the same monitor as last time, this is the quickest
        // way to find out.  This is called every frame, remember
        //
        GetWindowRect(hwnd, &rc);
        LPRECT lprcMonitor = &m_lpCurrentMonitor->rcMonitor;

        if (rc.left < lprcMonitor->left || rc.right > lprcMonitor->right ||
            rc.top < lprcMonitor->top || rc.bottom > lprcMonitor->bottom) {

            //
            // Find out for real. This is called every frame, but only when we are
            // partially off our main monitor, so that's not so bad.
            //
            *pID = DeviceFromWindow(hwnd, NULL, NULL);
        }
    }

    return  (m_lpCurrentMonitor->hMon != *pID);
}


/*****************************Private*Routine******************************\
* GetAMDDrawMonitorInfo
*
*
*
* History:
* Tue 08/17/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
GetAMDDrawMonitorInfo(
    const GUID* lpGUID,
    LPCSTR lpDriverDesc,
    LPCSTR lpDriverName,
    LPDIRECTDRAWCREATE lpfnDDrawCreate,
    AMDDRAWMONITORINFO* lpmi,
    HMONITOR hm
    )
{
    MONITORINFOEX miInfoEx;
    HDC hdcDisplay;
    miInfoEx.cbSize = sizeof(miInfoEx);

    lstrcpynA(lpmi->szDevice, lpDriverName, AMCCHDEVICENAME);
    lstrcpynA(lpmi->szDescription, lpDriverDesc, AMCCHDEVICEDESCRIPTION);

    if (lpGUID == NULL) {
        lpmi->hMon = DeviceFromWindow((HWND)NULL, NULL, NULL);
        lpmi->dwFlags = MONITORINFOF_PRIMARY;
        lpmi->guid.lpGUID = NULL;

        SetRect(&lpmi->rcMonitor, 0, 0,
                GetSystemMetrics(SM_CXSCREEN),
                GetSystemMetrics(SM_CYSCREEN));

        lpmi->guid.GUID = GUID_NULL;
    }
    else if (GetMonitorInfo(hm, &miInfoEx)) {
        lpmi->dwFlags = miInfoEx.dwFlags;
        lpmi->rcMonitor = miInfoEx.rcMonitor;
        lpmi->hMon = hm;
        lpmi->guid.lpGUID = &lpmi->guid.GUID;
        lpmi->guid.GUID = *lpGUID;
    }
    else return FALSE;


    INITDDSTRUCT(lpmi->ddHWCaps);
    LPDIRECTDRAW lpDD;

    HRESULT hr = CreateDirectDrawObject(lpmi->guid, &lpDD, lpfnDDrawCreate);
    if (SUCCEEDED(hr)) {

        IDirectDraw4* lpDD4;
        hr = lpDD->QueryInterface(IID_IDirectDraw4, (LPVOID*)&lpDD4);

        if (SUCCEEDED(hr)) {
            lpDD4->GetCaps(&lpmi->ddHWCaps, NULL);
            lpDD4->Release();
        }
        else {
            lpDD->GetCaps(&lpmi->ddHWCaps, NULL);
        }

        lpDD->Release();
    }
    else return FALSE;

    return TRUE;
}

/*****************************Private*Routine******************************\
* DDEnumCallbackEx
*
*
*
* History:
* Fri 08/13/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL WINAPI
DDEnumCallbackEx(
    GUID *lpGUID,
    LPSTR lpDriverDesc,
    LPSTR lpDriverName,
    LPVOID lpContext,
    HMONITOR  hm
    )
{
    DDRAWINFO* lpDDInfo = (DDRAWINFO*)lpContext;

    switch (lpDDInfo->dwAction) {

    case ACTION_COUNT_GUID:
        lpDDInfo->dwUser++;
        return TRUE;

    case ACTION_FILL_GUID:
        if (GetAMDDrawMonitorInfo(lpGUID, lpDriverDesc,
                                  lpDriverName,
                                  lpDDInfo->lpfnDDrawCreate,
                                  &lpDDInfo->pmi[lpDDInfo->dwUser],
                                  hm)) {
            lpDDInfo->dwUser++;
        }
        return TRUE;
    }

    return FALSE;
}


/*****************************Private*Routine******************************\
* MatchGUID
*
*
*
* History:
* Wed 08/18/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
COMFilter::MatchGUID(
    const GUID* lpGUID,
    LPDWORD lpdwMatchID
    )
{
    for (DWORD i = 0; i < m_dwDDrawInfoArrayLen; i++) {

        const GUID* lpMonGUID = m_lpDDrawInfo[i].guid.lpGUID;

        if ((lpMonGUID == NULL && lpGUID == NULL) ||
            (lpMonGUID && lpGUID && IsEqualGUID(*lpGUID, *lpMonGUID))) {

            *lpdwMatchID = i;
            return S_OK;
        }
    }

    return S_FALSE;
}


/******************************Public*Routine******************************\
* SetDDrawGUID
*
* Set the DDraw device GUID used when connecting the primary PIN to the
* upstream decoder.
*
* History:
* Fri 08/13/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMFilter::SetDDrawGUID(
    const AMDDRAWGUID *lpGUID
    )
{
    // Check that we aren't already using a DDraw device
    if (m_pDirectDraw) {
        return VFW_E_ALREADY_CONNECTED;
    }

    if (!lpGUID) {
        return E_POINTER;
    }

    if (lpGUID->lpGUID) {
        if (!IsEqualGUID(lpGUID->GUID, *lpGUID->lpGUID)) {
            return E_INVALIDARG;
        }
    }

    CAutoLock l(&m_csFilter);
    DWORD dwMatchID;

    HRESULT hr = MatchGUID(lpGUID->lpGUID, &dwMatchID);
    if (hr == S_FALSE) {
        return E_INVALIDARG;
    }

    m_lpCurrentMonitor = &m_lpDDrawInfo[dwMatchID];

    if (lpGUID->lpGUID) {
        m_ConnectionGUID.lpGUID = &m_ConnectionGUID.GUID;
        m_ConnectionGUID.GUID = lpGUID->GUID;
    }
    else {
        m_ConnectionGUID.lpGUID = NULL;
        m_ConnectionGUID.GUID = GUID_NULL;
    }

    return S_OK;
}

/******************************Public*Routine******************************\
* GetDDrawGUID
*
*
*
* History:
* Tue 08/17/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMFilter::GetDDrawGUID(
    AMDDRAWGUID* lpGUID
    )
{
    if (!lpGUID) {
        return E_POINTER;
    }

    // copy GUID and return S_OK;
    *lpGUID = m_ConnectionGUID;

    return S_OK;
}

/*****************************Private*Routine******************************\
* SetRegistryString
*
*
*
* History:
* Wed 08/18/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
SetRegistryString(
    HKEY hk,
    const TCHAR* pKey,
    const TCHAR* szString
    )
{
    HKEY hKey;
    LONG lRet;

    lRet = RegCreateKey(hk, chRegistryKey, &hKey);
    if (lRet == ERROR_SUCCESS) {

        lRet = RegSetValueEx(hKey, pKey, 0L, REG_SZ,
                             (LPBYTE)szString,
                             sizeof(TCHAR) * lstrlen(szString));
        RegCloseKey(hKey);
    }

    if (lRet == ERROR_SUCCESS) {
        return S_OK;
    }

    return AmHresultFromWin32(lRet);
}


/*****************************Private*Routine******************************\
* GetRegistryString
*
*
*
* History:
* Wed 08/18/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
GetRegistryString(
    HKEY hk,
    const TCHAR* pKey,
    TCHAR* szString,
    PLONG lpLength
    )
{
    HKEY hKey;
    LONG lRet;

    lRet = RegOpenKeyEx(hk, chRegistryKey, 0, KEY_QUERY_VALUE, &hKey);
    if (lRet == ERROR_SUCCESS) {

        DWORD dwType;
        lRet = RegQueryValueEx(hKey, pKey, 0L, &dwType,
                               (LPBYTE)szString, (LPDWORD)lpLength);
        RegCloseKey(hKey);
    }

    if (lRet == ERROR_SUCCESS) {
        return S_OK;
    }

    return AmHresultFromWin32(lRet);
}


/******************************Public*Routine******************************\
* SetDefaultDDrawGUID
*
*
*
* History:
* Tue 08/17/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMFilter::SetDefaultDDrawGUID(
    const AMDDRAWGUID* lpGUID
    )
{
    if (!lpGUID) {
        return E_POINTER;
    }

    if (lpGUID->lpGUID) {
        if (!IsEqualGUID(lpGUID->GUID, *lpGUID->lpGUID)) {
            return E_INVALIDARG;
        }
    }

    // match the supplied GUID with those DDraw devices available
    DWORD dwMatchID;
    HRESULT hr = MatchGUID(lpGUID->lpGUID, &dwMatchID);

    // if match not found return E_INVALIDARG
    if (hr == S_FALSE) {
        return E_INVALIDARG;
    }

    // if the caller is trying to make the default device the NULL
    // DDraw device, just delete the registry key.
    if (lpGUID->lpGUID == NULL) {

        HKEY hKey;
        LONG lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                 chRegistryKey, 0,
                                 KEY_SET_VALUE, &hKey);

        if (lRet == ERROR_SUCCESS) {
            lRet = RegDeleteValue(hKey, szDDrawGUID);

            if (lRet == ERROR_FILE_NOT_FOUND)
                lRet = 0;

            RegCloseKey(hKey);
        }

        if (lRet == 0)
            return S_OK;

        return AmHresultFromWin32(lRet);
    }

    // convert GUID into string
    LPOLESTR lpsz;
    hr = StringFromCLSID(lpGUID->GUID, &lpsz);
    if (FAILED(hr)) {
        return hr;
    }

    // write the string into the registry
    USES_CONVERSION;
    hr = SetRegistryString(HKEY_LOCAL_MACHINE, szDDrawGUID, OLE2T(lpsz));

    CoTaskMemFree(lpsz);

    return hr;
}

/******************************Public*Routine******************************\
* GetDefaultDDrawGUID
*
*
*
* History:
* Tue 08/17/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMFilter::GetDefaultDDrawGUID(
    AMDDRAWGUID* lpGUID
    )
{
    if (!lpGUID) {
        return E_POINTER;
    }

    // read string from the registry
    TCHAR   szGUID[64];
    LONG    lLen = 64;
    HRESULT hr = GetRegistryString(HKEY_LOCAL_MACHINE, szDDrawGUID,
                                   szGUID, &lLen);

    // if string not in registry return the default (NULL) DDraw device
    if (FAILED(hr)) {
        lpGUID->lpGUID = NULL;
        return S_OK;
    }

    // convert string into GUID and return
    lpGUID->lpGUID = &lpGUID->GUID;

    USES_CONVERSION;
    hr = IIDFromString(T2OLE(szGUID), lpGUID->lpGUID);

    return hr;
}


/******************************Public*Routine******************************\
* GetDDrawGUIDs
*
* Allocates and returns an array of AMDDRAWMONITORINFO structures, one for
* for each direct draw device attached to a display monitor.
*
* The caller is responsible for freeing the allocated memory by calling
* CoTaskMemFree when it is finished with the array.
*
* The functions returns the size of the array via the lpdw variable.
*
* History:
* Fri 08/13/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMFilter::GetDDrawGUIDs(
    LPDWORD lpdw,
    AMDDRAWMONITORINFO** lplpInfo
    )
{
    if (!lpdw || !lplpInfo) {
        return E_POINTER;
    }

    DDRAWINFO DDrawInfo;
    DDrawInfo.dwAction = ACTION_COUNT_GUID;

    if (m_lpfnDDrawEnumEx) {
        DDrawInfo.dwUser = 0;
        (*m_lpfnDDrawEnumEx)(DDEnumCallbackEx, (LPVOID)&DDrawInfo,
                             DDENUM_ATTACHEDSECONDARYDEVICES);
    }
    else {
        DDrawInfo.dwUser = 1;
    }

    // allocate memory
    *lpdw = DDrawInfo.dwUser;
    *lplpInfo = DDrawInfo.pmi = (AMDDRAWMONITORINFO*)CoTaskMemAlloc(
            DDrawInfo.dwUser * sizeof(AMDDRAWMONITORINFO));
    if (*lplpInfo == NULL) {
        return E_OUTOFMEMORY;
    }

    // fill in memory with device info
    if (m_lpfnDDrawEnumEx) {

        DDrawInfo.dwAction = ACTION_FILL_GUID;
        DDrawInfo.dwUser = 0;
        DDrawInfo.lpfnDDrawCreate = m_lpfnDDrawCreate;

        (*m_lpfnDDrawEnumEx)(DDEnumCallbackEx, (LPVOID)&DDrawInfo,
                             DDENUM_ATTACHEDSECONDARYDEVICES);
    }
    else {
        GetAMDDrawMonitorInfo(NULL, szDesc, szDisplay,
                              m_lpfnDDrawCreate, DDrawInfo.pmi,
                              MonitorFromWindow(HWND_DESKTOP,
                                                MONITOR_DEFAULTTONEAREST));
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\mixer\ovmixer\ddva.h ===
/*==========================================================================;
 *
 *  Copyright (c) 1997 - 1998  Microsoft Corporation.  All Rights Reserved.
 *
 *  File:	ddmc.h
 *  Content:	DirectDrawMotionComp include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   22-sep-97	smac
 *@@END_MSINTERNAL
 *
 ***************************************************************************/

#ifndef __DDVA_INCLUDED__
#define __DDVA_INCLUDED__
#if defined( _WIN32 )  && !defined( _NO_COM )
#define COM_NO_WINDOWS_H
#include <objbase.h>
#else
#define IUnknown	    void
#undef  CO_E_NOTINITIALIZED
#define CO_E_NOTINITIALIZED 0x800401F0L
#endif

#ifdef __cplusplus
extern "C" {
#endif

/*
 * GUIDS used by DirectDrawVideoAccelerator objects
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
DEFINE_GUID( IID_IDDVideoAcceleratorContainer,	0xACA12120,0x3356,0x11D1,0x8F,0xCF,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );
DEFINE_GUID( IID_IDirectDrawVideoAccelerator,   0xC9B2D740,0x3356,0x11D1,0x8F,0xCF,0x00,0xC0,0x4F,0xC2,0x9B,0x4E );
#endif

/*============================================================================
 *
 * DirectDraw Structures
 *
 * Various structures used to invoke DirectDraw.
 *
 *==========================================================================*/

struct IDirectDraw;
struct IDirectDrawSurface;
struct IDirectDrawPalette;
struct IDirectDrawClipper;

typedef struct IDDVideoAcceleratorContainer		FAR *LPDDVIDEOACCELERATORCONTAINER;
typedef struct IDirectDrawVideoAccelerator		FAR *LPDIRECTDRAWVIDEOACCELERATOR;

typedef struct IDDVideoAcceleratorContainerVtbl DDVIDEOACCELERATORCONTAINERCALLBACKS;
typedef struct IDirectDrawVideoAcceleratorVtbl  DIRECTDRAWVIDEOACCELERATORCALLBACKS;


typedef struct _tag_DDVAUncompDataInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwUncompWidth;              // [in]     width of uncompressed data
    DWORD                   dwUncompHeight;             // [in]     height of uncompressed data
    DDPIXELFORMAT           ddUncompPixelFormat;        // [in]     pixel-format of uncompressed data
} DDVAUncompDataInfo, *LPDDVAUncompDataInfo;

typedef struct _tag_DDVAInternalMemInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwScratchMemAlloc;          // [out]    amount of scratch memory will the hal allocate for its private use
} DDVAInternalMemInfo, *LPDDVAInternalMemInfo;


typedef struct _tag_DDVACompBufferInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwNumCompBuffers;           // [out]    number of buffers reqd for compressed data
    DWORD                   dwWidthToCreate;            // [out]    Width of surface to create
    DWORD                   dwHeightToCreate;           // [out]    Height of surface to create
    DWORD                   dwBytesToAllocate;          // [out]    Total number of bytes used by each surface
    DDSCAPS2                ddCompCaps;                 // [out]    caps to create surfaces to store compressed data
    DDPIXELFORMAT           ddPixelFormat;              // [out]    fourcc to create surfaces to store compressed data
} DDVACompBufferInfo, *LPDDVACompBufferInfo;


// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_DDVABeginFrameInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    LPDIRECTDRAWSURFACE4    pddDestSurface;             // [in]     destination buffer in which to decoding this frame
    DWORD                   dwSizeInputData;            // [in]     size of other misc data to begin frame
    LPVOID                  pInputData;                 // [in]     pointer to misc data
    DWORD                   dwSizeOutputData;           // [in/out] size of other misc data to begin frame
    LPVOID                  pOutputData;                // [out]    pointer to misc data
} DDVABeginFrameInfo, *LPDDVABeginFrameInfo;

// Note that you are NOT allowed to store any pointer in pMiscData
typedef struct _tag_DDVAEndFrameInfo
{
    DWORD                   dwSize;                     // [in]     size of the struct
    DWORD                   dwSizeMiscData;             // [in]     size of other misc data to begin frame
    LPVOID                  pMiscData;                  // [in]     pointer to misc data
} DDVAEndFrameInfo, *LPDDVAEndFrameInfo;

typedef struct _tag_DDVABUFFERINFO
{
    DWORD                   dwSize;                     // [in]    size of the struct
    LPDIRECTDRAWSURFACE4    pddCompSurface;             // [in]    pointer to buffer containing compressed data
    DWORD                   dwDataOffset;               // [in]    offset of relevant data from the beginning of buffer
    DWORD                   dwDataSize;                 // [in]    size of relevant data
} DDVABUFFERINFO, *LPDDVABUFFERINFO;


/*
 * INTERACES FOLLOW:
 *	IDDVideoAcceleratorContainer
 *	IDirectDrawVideoAccelerator
 */

/*
 * IDDVideoAcceleratorContainer
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDDVideoAcceleratorContainer
DECLARE_INTERFACE_( IDDVideoAcceleratorContainer, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDDVideoAcceleratorContainer methods ***/
    STDMETHOD(CreateVideoAccelerator)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPVOID, DWORD, LPDIRECTDRAWVIDEOACCELERATOR FAR *, IUnknown FAR *) PURE;
    STDMETHOD(GetCompBufferInfo)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPDWORD, LPDDVACompBufferInfo ) PURE;
    STDMETHOD(GetInternalMemInfo)(THIS_ LPGUID, LPDDVAUncompDataInfo, LPDDVAInternalMemInfo ) PURE;
    STDMETHOD(GetVideoAcceleratorGUIDs)(THIS_ LPDWORD, LPGUID ) PURE;
    STDMETHOD(GetUncompFormatsSupported)(THIS_ LPGUID, LPDWORD, LPDDPIXELFORMAT ) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoAcceleratorContainer_QueryInterface(p, a, b)            (p)->lpVtbl->QueryInterface(p, a, b)
#define IVideoAcceleratorContainer_AddRef(p)                          (p)->lpVtbl->AddRef(p)
#define IVideoAcceleratorContainer_Release(p)                         (p)->lpVtbl->Release(p)
#define IVideoAcceleratorContainer_CreateVideoAccelerator(p,a,b,c,d,e,f)    (p)->lpVtbl->CreateVideoAccelerator(p, a, b, c, d, e, f)
#define IVideoAcceleratorContainer_GetCompBufferInfo(p, a, b, c, d)   (p)->lpVtbl->GetCompBufferInfo(p, a, b, c, d)
#define IVideoAcceleratorContainer_GetInternalMemInfo(p, a, b, c)     (p)->lpVtbl->GetInternalMemInfo(p, a, b, c)
#define IVideoAcceleratorContainer_GetVideoAcceleratorGUIDs(p, a, b)        (p)->lpVtbl->GetVideoAcceleratorGUIDs(p, a, b)
#define IVideoAcceleratorContainer_GetUncompFormatsSupported(p,a,b,c) (p)->GetUncompFormatsSupported(p, a, b, c)
#else
#define IVideoAcceleratorContainer_QueryInterface(p, a, b)            (p)->QueryInterface(a, b)
#define IVideoAcceleratorContainer_AddRef(p)                          (p)->AddRef()
#define IVideoAcceleratorContainer_Release(p)                         (p)->Release()
#define IVideoAcceleratorContainer_CreateVideoAccelerator(p, a, b, c,d,e,f) (p)->CreateVideoAccelerator(a, b, c, d, e, f)
#define IVideoAcceleratorContainer_GetCompBufferInfo(p, a, b, c, d)   (p)->lpVtbl->GetCompBufferInfo(a, b, c, d)
#define IVideoAcceleratorContainer_GetInternalMemInfo(p, a, b, c)     (p)->lpVtbl->GetInternalMemInfo(a, b, c)
#define IVideoAcceleratorContainer_GetVideoAcceleratorGUIDs(p, a, b)        (p)->GetVideoAcceleratorGUIDs(a, b)
#define IVideoAcceleratorContainer_GetUncompFormatsSupported(p,a,b,c) (p)->GetUncompFormatsSupported(a, b, c)
#endif

#endif


/*
 * IDirectDrawVideoAccelerator
 */
#if defined( _WIN32 ) && !defined( _NO_COM )
#undef INTERFACE
#define INTERFACE IDirectDrawVideoAccelerator
DECLARE_INTERFACE_( IDirectDrawVideoAccelerator, IUnknown )
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    /*** IDirecytDrawVideoAccelerator methods ***/
    STDMETHOD(BeginFrame)(THIS_ LPDDVABeginFrameInfo) PURE;
    STDMETHOD(EndFrame)(THIS_ LPDDVAEndFrameInfo) PURE;
    STDMETHOD(QueryRenderStatus)(THIS_ LPDIRECTDRAWSURFACE4, DWORD)PURE;
    STDMETHOD(Execute)(THIS_ 
                       DWORD,            // Function
                       LPVOID,           // Input data
                       DWORD,            // Input data length
                       LPVOID,           // Output data
                       DWORD,            // Output data length
                       DWORD,            // Number of buffers
                       LPDDVABUFFERINFO  // Buffer info array
                       ) PURE;
};

//  Flags for QueryRenderStatus
#define DDVA_QUERYRENDERSTATUSF_READ     0x00000001  // Query for read
                                                     // set this bit to 0 
                                                     // if query for update

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IVideoAccelerator_QueryInterface(p,a,b)      (p)->lpVtbl->QueryInterface(p,a,b)
#define IVideoAccelerator_AddRef(p)                  (p)->lpVtbl->AddRef(p)
#define IVideoAccelerator_Release(p)                 (p)->lpVtbl->Release(p)
#define IVideoAccelerator_BeginFrame(p,a)            (p)->lpVtbl->BeginFrame(p,a)
#define IVideoAccelerator_EndFrame(p,a)              (p)->lpVtbl->EndFrame(p,a)
#define IVideoAccelerator_QueryRenderStatus(p,a,b)   (p)->lpVtbl->QueryRenderStatus(p,a,b)
#define IVideoAccelerator_RenderMacroBlocks(p,a,b)   (p)->lpVtbl->RenderMacroBlocks(p,a,b)
#else
#define IVideoAccelerator_QueryInterface(p,a,b)      (p)->QueryInterface(a,b)
#define IVideoAccelerator_AddRef(p)                  (p)->AddRef()
#define IVideoAccelerator_Release(p)                 (p)->Release()
#define IVideoAccelerator_BeginFrame(p,a)            (p)->BeginFrame(a)
#define IVideoAccelerator_EndFrame(p,a)              (p)->EndFrame(a)
#define IVideoAccelerator_QueryRenderStatus(p,a,b)   (p)->QueryRenderStatus(a,b)
#define IVideoAccelerator_RenderMacroBlocks(p,a,b)   (p)->RenderMacroBlocks(a,b)
#endif

#endif


#ifdef __cplusplus
};
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\mixer\ovmixer\macvis.h ===
// Copyright (c) 1998  Microsoft Corporation.  All Rights Reserved.
//
// MacVis.h: Overlay Mixer's MacroVision support code header
//

#ifndef __MACVIS_H__
#define __MACVIS_H__


//
// The magic GUID for Macrovision etc enabling (from winuser.h). It has 
// not been given a name there and so is used here directly.
//
static const GUID guidVidParam = 
    {0x2c62061, 0x1097, 0x11d1, {0x92, 0xf, 0x0, 0xa0, 0x24, 0xdf, 0x15, 0x6e}} ;

//
// Combination of all the VP_TV_XXX flags (w/o _WIN_VGA) gives 0x7FFF
//
#define ValidTVStandard(dw)  (dw & 0x7FFF)

//
// MacroVision implementation wrapped in a class for Overlay Mixer
//
class CDispMacroVision {

    public:
        CDispMacroVision(COMFilter *pOvMFilter) ;
        ~CDispMacroVision(void) ;

        BOOL      SetMacroVision(DWORD dwCPBits) ;
        BOOL      StopMacroVision(void) ;
        HMONITOR  GetMonitor(void) ;

    private:
        DWORD         m_dwCPKey ;
        COMFilter    *m_pOvMFilter ;
} ;

#endif // __MACVIS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\mixer\ovmixer\decimate.cpp ===
/******************************Module*Header*******************************\
* Module Name: decimate.cpp
*
* Support code for the IDecimateVideoImage and IAMVideoDecimationProperties
*
*
* Created: Thu 07/08/1999
* Author:  Stephen Estrop [StEstrop]
*
* Copyright (c) 1999 Microsoft Corporation
\**************************************************************************/
#include <streams.h>
#include <ddraw.h>
#include <mmsystem.h>       // Needed for definition of timeGetTime
#include <limits.h>         // Standard data type limit definitions
#include <ks.h>
#include <ksproxy.h>
#include <bpcwrap.h>
#include <ddmmi.h>
#include <dvdmedia.h>
#include <amstream.h>
#include <dvp.h>
#include <ddkernel.h>
#include <vptype.h>
#include <vpconfig.h>
#include <vpnotify.h>
#include <vpobj.h>
#include <syncobj.h>
#include <mpconfig.h>
#include <ovmixpos.h>
#include <macvis.h>
#include <ovmixer.h>


#if 0
#undef DBGLOG
#define DBGLOG(_x_) OutputDebugStringA( _x_ )
#else
#undef DBGLOG
#define DBGLOG(_x_)
#endif

/*****************************Private*Routine******************************\
* GetVideoDecimation
*
* Try to get the IDecimateVideoImage interface from our peer filter.
*
* History:
* 05-05-99 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMInputPin::GetVideoDecimation(
    IDecimateVideoImage** lplpDVI
    )
{
    AMTRACE((TEXT("COMInputPin::GetVideoDecimation")));

    *lplpDVI = NULL;

    if (m_Connected == NULL || !IsConnected()) {
        return E_FAIL;
    }

    PIN_INFO PinInfo;
    HRESULT hr = m_Connected->QueryPinInfo(&PinInfo);
    if (FAILED(hr)) {
        return hr;
    }

    hr = PinInfo.pFilter->QueryInterface(IID_IDecimateVideoImage,
                                         (LPVOID*)lplpDVI);
    PinInfo.pFilter->Release();

    return hr;
}

/*****************************Private*Routine******************************\
* QueryDecimationOnPeer
*
* Check to see if the decoder connected to our input pin is happy
* to decimate to the requested size.  The decoder will return,
* S_OK if it can, S_FALSE if it can't decimate to the requested size
* and would like us to continue using the current decimation size and
* E_FAIL if it can't decimate at all or wants to stop decimating.
*
* History:
* 05-05-99 - StEstrop - Created
*
\**************************************************************************/
HRESULT
COMInputPin::QueryDecimationOnPeer(
    long lWidth,
    long lHeight
    )
{
    AMTRACE((TEXT("COMInputPin::QueryDecimationOnPeer")));

    IDecimateVideoImage* lpDVI;
    HRESULT hr = GetVideoDecimation(&lpDVI);

    if (SUCCEEDED(hr)) {

        hr = lpDVI->SetDecimationImageSize(lWidth, lHeight);
        lpDVI->Release();
    }
    return hr;
}

/*****************************Private*Routine******************************\
* ResetDecimationIfSet()
*
* Resets the decimation to the original size, but only if actually set
* in the first place.
*
* History:
* 05-05-99 - StEstrop - Created
*
\**************************************************************************/
HRESULT
COMInputPin::ResetDecimationIfSet()
{
    AMTRACE((TEXT("COMInputPin::ResetDecimationIfSet")));

    if (m_bDecimating) {

        IDecimateVideoImage* lpDVI;
        HRESULT hr = GetVideoDecimation(&lpDVI);

        if (SUCCEEDED(hr)) {
            hr = lpDVI->ResetDecimationImageSize();
            lpDVI->Release();
            m_bDecimating = FALSE;
            m_lWidth = 0L;
            m_lHeight = 0L;
        }
        else return hr;
    }

    return S_OK;
}

/*****************************Private*Routine******************************\
* IsDecimationNeeded
*
* Decimation is needed if the current minimum scale factor (either vertical
* or horizontal) is less than 1000.
*
* History:
* Thu 07/08/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
IsDecimationNeeded(
    DWORD ScaleFactor
    )
{
    AMTRACE((TEXT("::IsDecimationNeeded")));
    return ScaleFactor < 1000;
}


/*****************************Private*Routine******************************\
* GetCurrentScaleFactor
*
* Determines the x axis scale factor and the y axis scale factor.
* The minimum of these two values is the limiting scale factor.
*
* History:
* Thu 07/08/1999 - StEstrop - Created
*
\**************************************************************************/
DWORD
GetCurrentScaleFactor(
    LPWININFO pWinInfo,
    DWORD* lpxScaleFactor,
    DWORD* lpyScaleFactor
    )
{
    AMTRACE((TEXT("::GetCurrentScaleFactor")));

    DWORD dwSrcWidth = WIDTH(&pWinInfo->SrcRect);
    DWORD dwSrcHeight = HEIGHT(&pWinInfo->SrcRect);

    DWORD dwDstWidth = WIDTH(&pWinInfo->DestRect);
    DWORD dwDstHeight = HEIGHT(&pWinInfo->DestRect);

    DWORD xScaleFactor = MulDiv(dwDstWidth, 1000, dwSrcWidth);
    DWORD yScaleFactor = MulDiv(dwDstHeight, 1000, dwSrcHeight);

    if (lpxScaleFactor) *lpxScaleFactor = xScaleFactor;
    if (lpyScaleFactor) *lpyScaleFactor = yScaleFactor;

    return min(xScaleFactor, yScaleFactor);
}


/*****************************Private*Routine******************************\
* Running
*
* Returns TRUE if the filter graph is in the "running" state.
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
COMInputPin::Running()
{
    return (m_pFilter->m_State == State_Running && CheckStreaming() == S_OK);
}


/*****************************Private*Routine******************************\
* TryDecoderDecimation
*
*
*
* History:
* Thu 07/08/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
COMInputPin::TryDecoderDecimation(
    LPWININFO pWinInfo
    )
{
    AMTRACE((TEXT("COMInputPin::TryDecoderDecimation")));


    ASSERT(Running());


    //
    // We only decimate on the primary pin
    //

    if (m_dwPinId != 0) {

        DBGLOG(("Can only decimate the primary pin\n"));
        DbgLog((LOG_TRACE, 1, TEXT("Can only decimate the primary pin")));
        return E_FAIL;
    }

    //
    // Can only decimate when using default relative position
    //

    if (m_rRelPos.left != 0 || m_rRelPos.top != 0 ||
        m_rRelPos.right != MAX_REL_NUM || m_rRelPos.bottom != MAX_REL_NUM) {

        DBGLOG(("Can only decimate default relative position\n"));
        DbgLog((LOG_TRACE, 1, TEXT("Can only decimate default relative position")));

        ResetDecimationIfSet();
        return E_FAIL;
    }

    //
    // Must also be using the default source rectangle
    //

    if (WIDTH(&pWinInfo->SrcRect) != m_lSrcWidth ||
        HEIGHT(&pWinInfo->SrcRect) != m_lSrcHeight) {

        DBGLOG(("Can only decimate default source rectangle\n"));
        DbgLog((LOG_TRACE, 1, TEXT("Can only decimate default source rectangle")));

        ResetDecimationIfSet();
        return E_FAIL;
    }

    //
    // Now try asking the upstream decoder if it wants to decimate to
    // the specified image size
    //

    LONG lWidth = WIDTH(&pWinInfo->DestRect);
    LONG lHeight = HEIGHT(&pWinInfo->DestRect);
    HRESULT hr = QueryDecimationOnPeer(lWidth, lHeight);
    if (SUCCEEDED(hr)) {
        m_bDecimating = TRUE;
        m_lWidth = lWidth;
        m_lHeight = lHeight;
    }
    else {
        ResetDecimationIfSet();
        return E_FAIL;
    }

    //
    // Adjust the source rect passed to UpdateOverlay to
    // reflect the image size
    //

    pWinInfo->SrcRect.right = lWidth;
    pWinInfo->SrcRect.bottom = lHeight;

    return S_OK;
}

/*****************************Private*Routine******************************\
* GetOverlayStretchCaps
*
* Returns the stretching capabilities of the VGA overlay scaler
*
* History:
* Fri 07/09/1999 - StEstrop - Created
*
\**************************************************************************/
DWORD
COMInputPin::GetOverlayStretchCaps()
{
    AMTRACE((TEXT("COMInputPin::GetOverlayStretchCaps")));

    LPDDCAPS pDirectCaps = NULL;
    pDirectCaps = m_pFilter->GetHardwareCaps();
    if ( pDirectCaps )
        return pDirectCaps->dwMinOverlayStretch;
    return 1000;
}




/*****************************Private*Routine******************************\
* BeyondOverlayCaps
*
* Determines if the current scale factor is outside the valid scale
* factors for the VGA overlay scaler.
*
* History:
* Thu 07/08/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
COMInputPin::BeyondOverlayCaps(
    DWORD ScaleFactor
    )
{
    AMTRACE((TEXT("COMInputPin::BeyondOverlayCaps")));

    return ScaleFactor < GetOverlayStretchCaps();
}



/*****************************Private*Routine******************************\
* CropSourceRect
*
* Crops the video image by adjusting the source rectangle until the ratio
* between the source and target rectangles is within the specified minimum
* scale factor (dwMinZoomFactor)
*
* History:
* Thu 07/08/1999 - StEstrop - Created
*
\**************************************************************************/
STDMETHODIMP
COMInputPin::CropSourceRect(
    LPWININFO pWinInfo,
    DWORD dwMinZoomFactorX,
    DWORD dwMinZoomFactorY
    )
{
    AMTRACE((TEXT("COMInputPin::CropSourceRect")));

#if defined(DEBUG)
    if (GetProfileIntA("OVMixer", "NoCrop", 0))
        return S_FALSE;
#endif

    AM_ASPECT_RATIO_MODE amAdjustedARMode = AM_ARMODE_STRETCHED;
    HRESULT hr = GetAdjustedModeAndAspectRatio(&amAdjustedARMode, NULL, NULL);
    ASSERT(SUCCEEDED(hr));

    DWORD dCurZoomFactorX;
    DWORD dCurZoomFactorY;
    GetCurrentScaleFactor(pWinInfo, &dCurZoomFactorX, &dCurZoomFactorY);

    LONG srcWidth = WIDTH(&pWinInfo->SrcRect);
    LONG srcHeight = HEIGHT(&pWinInfo->SrcRect);

    if (amAdjustedARMode == AM_ARMODE_STRETCHED) {

        //
        // if we don't need to maintain the aspect ratio, we clip only as
        // little as possible, so we can maximize the viewing area
        //
        if (dCurZoomFactorX < dwMinZoomFactorX) {

            pWinInfo->SrcRect.right = pWinInfo->SrcRect.left +
                MulDiv(srcWidth, dCurZoomFactorX, 1000);
        }

        if (dCurZoomFactorY < dwMinZoomFactorY) {

            pWinInfo->SrcRect.bottom = pWinInfo->SrcRect.top +
                MulDiv(srcHeight, dCurZoomFactorY, 1000);
        }
    }
    else {

        //
        // in this mode we need to maintain the aspect-ratio. So the clipping
        // in x and y has be to done by reducing the width and height of the
        // source rect by the same factor
        //
        if (dCurZoomFactorX < dwMinZoomFactorX ||
            dCurZoomFactorY < dwMinZoomFactorY) {

            DWORD dwFactor;
            DWORD dwFactorX = MulDiv(dCurZoomFactorX, 1000, dwMinZoomFactorX);
            dwFactor = min(1000, dwFactorX);

            DWORD dwFactorY = MulDiv(dCurZoomFactorY, 1000, dwMinZoomFactorY);
            dwFactor = min(dwFactor, dwFactorY);

            pWinInfo->SrcRect.right = pWinInfo->SrcRect.left +
                MulDiv(srcWidth, dwFactor, 1000);

            pWinInfo->SrcRect.bottom = pWinInfo->SrcRect.top +
                MulDiv(srcHeight, dwFactor, 1000);
        }
    }

    return S_OK;
}


/*****************************Private*Routine******************************\
* ApplyDecimation
*
* Non Video Port case
*
* This is where we enforce the chosen decimation strategy.
*
* History:
* Fri 07/09/1999 - StEstrop - Created
*
\**************************************************************************/
void
COMInputPin::ApplyDecimation(
    LPWININFO pWinInfo
    )
{
    AMTRACE((TEXT("COMInputPin::ApplyDecimation")));

    DWORD dwMinStretch = GetOverlayStretchCaps();

    if (Running()) {

        DWORD dwScaleFactor = ::GetCurrentScaleFactor(pWinInfo);
        if (IsDecimationNeeded(dwScaleFactor)) {

            DECIMATION_USAGE dwUsage;
            GetDecimationUsage(&dwUsage);

            switch (dwUsage) {
            case DECIMATION_USE_OVERLAY_ONLY:
            case DECIMATION_LEGACY:
                ResetDecimationIfSet();
                if (BeyondOverlayCaps(dwScaleFactor)) {
                    CropSourceRect(pWinInfo, dwMinStretch, dwMinStretch);
                }
                break;

            case DECIMATION_USE_DECODER_ONLY:
                if (TryDecoderDecimation(pWinInfo) != S_OK) {
                    CropSourceRect(pWinInfo, dwMinStretch, dwMinStretch);
                }
                break;

            case DECIMATION_USE_VIDEOPORT_ONLY:
                ASSERT(FALSE);

                DBGLOG(("This mode makes no sense when not using Video Ports"));
                DBGLOG(("Falling thru to the new default case"));

            case DECIMATION_DEFAULT:
                if (TryDecoderDecimation(pWinInfo) != S_OK) {
                    if (BeyondOverlayCaps(dwScaleFactor)) {
                        CropSourceRect(pWinInfo, dwMinStretch, dwMinStretch);
                    }
                }
                break;
            }
        }
        else {
            ResetDecimationIfSet();
        }
    }

    //
    // If the filter graph is not running we should not ask the decoder
    // to do anymore decimation as the decoder will not be
    // sending anymore frames to us.  So, we should adjust pWinInfo to take
    // into account the decimation that has already been applied and then
    // perform any necessary cropping.
    //

    else {

        if (m_bDecimating) {
            pWinInfo->SrcRect.right = m_lWidth;
            pWinInfo->SrcRect.bottom = m_lHeight;
        }

        DWORD dwScaleFactor = ::GetCurrentScaleFactor(pWinInfo);
        if (BeyondOverlayCaps(dwScaleFactor)) {
            CropSourceRect(pWinInfo, dwMinStretch, dwMinStretch);
        }
    }
}



/******************************Public*Routine******************************\
* GetMinZoomFactors
*
* Gets the minimum X and Y zoom factors for the given overlay and video port
* connection.
*
* History:
* 3/10/1999 - StEstrop - Created
*
\**************************************************************************/
void
CAMVideoPort::GetMinZoomFactors(
    LPWININFO pWinInfo,
    BOOL bColorKeying,
    BOOL bYInterpolating,
    LPDWORD lpMinX,
    LPDWORD lpMinY
    )
{
    AMTRACE((TEXT("CAMVideoPort::GetMinZoomFactors")));
    DWORD dwMinBandWidthZoomFactorX = 0;
    LPDDCAPS pDirectCaps = m_pIVPControl->GetHardwareCaps();

    //
    // if type is DDVPBCAPS_DESTINATION, contraint is terms of min-zoom-factor
    //

    if (m_sBandwidth.dwCaps == DDVPBCAPS_DESTINATION) {

        DbgLog((LOG_TRACE, 1, TEXT("DDVPBCAPS_DESTINATION")));
        dwMinBandWidthZoomFactorX = m_sBandwidth.dwOverlay;

        if (bColorKeying && !bYInterpolating) {

            DbgLog((LOG_TRACE, 1, TEXT("bColorKeying && !bYInterpolating")));
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwColorkey;
        }
        else if (!bColorKeying && bYInterpolating) {

            DbgLog((LOG_TRACE, 1, TEXT("!bColorKeying && bYInterpolating")));
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwYInterpolate;
        }
        else if (bColorKeying && bYInterpolating) {

            DbgLog((LOG_TRACE, 1, TEXT("bColorKeying && bYInterpolating")));
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwYInterpAndColorkey;
        }

        DbgLog((LOG_TRACE, 1,
                TEXT("dwMinBandWidthZoomFactorX=%d"),
                dwMinBandWidthZoomFactorX));
        DbgLog((LOG_TRACE, 1,
                TEXT("m_sBandwidth.dwOverlay   =%d"),
                m_sBandwidth.dwOverlay));

        if (dwMinBandWidthZoomFactorX < m_sBandwidth.dwOverlay)
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwOverlay;
    }
    else {

        //
        // if type is DDVPBCAPS_SOURCE, contraint is that the width of
        // the src-rect of the overlay must not be bigger than
        // m_lImageWidth*(value specified in m_sBandwidth)
        //

        ASSERT(m_sBandwidth.dwCaps == DDVPBCAPS_SOURCE);
        DbgLog((LOG_TRACE, 1, TEXT("DDVPBCAPS_SOURCE")));

        dwMinBandWidthZoomFactorX = m_sBandwidth.dwOverlay;

        if (bColorKeying && !bYInterpolating) {

            DbgLog((LOG_TRACE, 1, TEXT("bColorKeying && !bYInterpolating")));
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwColorkey;
        }
        else if (!bColorKeying && bYInterpolating) {

            DbgLog((LOG_TRACE, 1, TEXT("!bColorKeying && bYInterpolating")));
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwYInterpolate;
        }
        else if (bColorKeying && bYInterpolating) {

            DbgLog((LOG_TRACE, 1, TEXT("bColorKeying && bYInterpolating")));
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwYInterpAndColorkey;
        }

        DbgLog((LOG_TRACE, 1,
                TEXT("dwMinBandWidthZoomFactorX=%d"),
                dwMinBandWidthZoomFactorX));

        DbgLog((LOG_TRACE, 1,
                TEXT("m_sBandwidth.dwOverlay   =%d"),
                m_sBandwidth.dwOverlay));

        if (dwMinBandWidthZoomFactorX > m_sBandwidth.dwOverlay) {
            dwMinBandWidthZoomFactorX = m_sBandwidth.dwOverlay;
        }

        ASSERT(dwMinBandWidthZoomFactorX <= 1000);
        ASSERT(dwMinBandWidthZoomFactorX > 0);

        //
        // since this bandwidth structure was computed by passing m_lImageWidth
        // as a paramter, the constraint is WIDTH(SrcRect of the overlay) <=
        // m_lImageWidth*dMinBandWidthZoomFactorX.
        // Another way of specifying this is terms of min-zoom-factor,
        // taking the current dest rect into account
        //

        DbgLog((LOG_TRACE, 1,
                TEXT("Mucking about with dwMinBandWidthZoomFactorX")));

        if (dwMinBandWidthZoomFactorX < 1000) {
            int iDstWidth = WIDTH(&pWinInfo->DestRect);
            dwMinBandWidthZoomFactorX = MulABC_DivDE(iDstWidth, 1000, 1000,
                                                     m_lImageWidth,
                                                     dwMinBandWidthZoomFactorX);
        }
        else {
            dwMinBandWidthZoomFactorX = 0;
        }
        DbgLog((LOG_TRACE, 1,
                TEXT("NEW dwMinBandWidthZoomFactorX=%d"),
                dwMinBandWidthZoomFactorX));
    }

    //
    // Calculate the minimum zoom factors first
    // minimum zoom factor in X depends upon the driver's capabilities to
    // stretch the overlay as well as the bandwidth restrictions.
    //

    *lpMinX = pDirectCaps->dwMinOverlayStretch;
    DbgLog((LOG_TRACE, 1, TEXT("dwMinOverlayStretch=%d"), *lpMinX));

    if (*lpMinX < dwMinBandWidthZoomFactorX) {
        *lpMinX = dwMinBandWidthZoomFactorX;
    }
    DbgLog((LOG_TRACE, 1, TEXT("dwMinZoomFactorX=%d"), *lpMinX));

    //
    // minimum zoom factor in Y depends only upon the driver's capabilities
    //
    *lpMinY = pDirectCaps->dwMinOverlayStretch;
}



/*****************************Private*Routine******************************\
* CheckVideoPortAlignment
*
* Checks that the specified pre-scale width is matches the alignment criteria
* set by the video port.
*
* History:
* 3/16/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CAMVideoPort::CheckVideoPortAlignment(
    DWORD dwWidth
    )
{
    AMTRACE((TEXT("CAMVideoPort::CheckVideoPortAlignment")));
    if ((m_vpCaps.dwFlags & DDVPD_ALIGN) &&
         m_vpCaps.dwAlignVideoPortPrescaleWidth > 1) {

        if (dwWidth & (m_vpCaps.dwAlignVideoPortPrescaleWidth - 1)) {

            return FALSE;
        }
    }

    return TRUE;
}

#if defined(DEBUG)
/*****************************Private*Routine******************************\
* CheckVideoPortScaler
*
* Checks that the video port scaler can actual scale the video image to the
* requested capture size.
*
* History:
* 3/16/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CAMVideoPort::CheckVideoPortScaler(
    DECIMATE_MODE DecimationMode,
    DWORD ImageSize,
    DWORD PreScaleSize,
    ULONG ulDeciStep
    )
{
    AMTRACE((TEXT("CAMVideoPort::CheckVideoPortScaler")));
    BOOL fScalerOK = TRUE;

    if (ImageSize != PreScaleSize) {
        switch (DecimationMode) {
        case DECIMATE_ARB:
            break;

        case DECIMATE_INC:
            if (((ulDeciStep * PreScaleSize) % ImageSize) != 0) {

                DbgLog((LOG_ERROR, 1,
                        TEXT("Can't capture at this size")));

                DbgLog((LOG_ERROR, 1,
                        TEXT("%d is not a fraction of %d over %d"),
                        PreScaleSize, ImageSize, ulDeciStep));

                fScalerOK = FALSE;
            }
            break;

        case DECIMATE_BIN:
            {
                DWORD bin = 1;
                while ((ImageSize / bin) > PreScaleSize) {
                    bin *= 2;
                }

                if ((ImageSize % bin) != 0) {

                    DbgLog((LOG_ERROR, 1,
                            TEXT("Can't capture at this size")));

                    DbgLog((LOG_ERROR, 1,
                            TEXT("%d is not a fraction of %d over 2^n"),
                            PreScaleSize, ImageSize));

                    fScalerOK = FALSE;
                }
            }
            break;

        case DECIMATE_NONE:
            DbgLog((LOG_ERROR, 1,
                    TEXT("Can't capture at this width because the ")
                    TEXT("VideoPort can't scale in this direction")));
            fScalerOK = FALSE;
            break;
        }
    }

    return fScalerOK;
}
#endif

/*****************************Private*Routine******************************\
* AdjustSourceSizeForCapture
*
* Only gets called if we are capturing.
*
* First, we must make sure that the video comming over the video port is
* the correct size.  We do this by checking that m_lImageWidth is equal to
* m_cxCapture and that m_lImageHeight is equal to m_cyCapture.
*
* If they differ, then we pre-scale the video to the correct size.  This is
* the only pre-scaling that is performed.  This is normaly only performed
* once when the graph is first run.  The source rectangle is adjusted
* to accomodate the possibly changed video source size.
*
* Second, we determine the current shrink factor and if it is beyond the
* capabilities of the VGA scaler we CROP the source rectangle (maintaining the
* correct aspect ratio) to such a size that the VGA scaler can cope with
* scaling.
*
* History:
* 3/10/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CAMVideoPort::AdjustSourceSizeForCapture(
    LPWININFO pWinInfo,
    DWORD dwMinZoomFactorX,
    DWORD dwMinZoomFactorY
    )
{
    BOOL fUpdateRequired = FALSE;

    AMTRACE((TEXT("CAMVideoPort::AdjustSourceSizeForCapture")));

    DbgLog((LOG_TRACE, 1, TEXT("Src(%d, %d, %d, %d)"),
            pWinInfo->SrcRect.left, pWinInfo->SrcRect.top,
            pWinInfo->SrcRect.right, pWinInfo->SrcRect.bottom));
    DbgLog((LOG_TRACE, 1, TEXT("Dest(%d, %d, %d, %d)"),
            pWinInfo->DestRect.left, pWinInfo->DestRect.top,
            pWinInfo->DestRect.right, pWinInfo->DestRect.bottom));

    DWORD cyCapture = m_cyCapture;
    if (m_fCaptureInterleaved) {
        cyCapture /= 2;
    }

    //
    // First make sure that we are capturing at the correct size.
    //

    if (m_lDecoderImageWidth == m_cxCapture &&
        m_lDecoderImageHeight == cyCapture) {

        DbgLog((LOG_TRACE, 1, TEXT("Capture size matches image size")));

        //
        // We don't need to pre-scale at the video port, so make sure that it
        // is turned off.
        //
        if (m_svpInfo.dwPrescaleWidth != 0 || m_svpInfo.dwPrescaleHeight != 0) {

            DbgLog((LOG_TRACE, 1, TEXT("Turning off PRE-SCALE")));

            m_svpInfo.dwVPFlags &= ~DDVP_PRESCALE;
            m_svpInfo.dwPrescaleWidth = 0;
            m_svpInfo.dwPrescaleHeight = 0;
            fUpdateRequired = TRUE;
        }

        //
        // Reset the decimation ratio's
        //
        m_dwDeciNumX = 1000; m_dwDeciDenX = 1000;
        m_dwDeciNumY = 1000; m_dwDeciDenY = 1000;
    }
    else {

        //
        // We do need to pre-scale at the video port, make sure that it is
        // turned on.
        //

        if (m_svpInfo.dwPrescaleWidth != m_cxCapture ||
            m_svpInfo.dwPrescaleHeight != cyCapture) {

            DbgLog((LOG_TRACE, 1, TEXT("Turning on PRE-SCALE at (%d, %d)"),
                    m_cxCapture, cyCapture ));

            //
            // Need to do some more checking here.  Basically, I'm relying on
            // the decoder connected to the video port to specify a size that
            // the video port can actually scale to.
            //

            ASSERT(CheckVideoPortAlignment(m_cxCapture) == TRUE);

            ASSERT(CheckVideoPortScaler(m_DecimationModeX, m_lDecoderImageWidth,
                                        m_cxCapture, m_ulDeciStepX) == TRUE);

            ASSERT(CheckVideoPortScaler(m_DecimationModeY, m_lDecoderImageHeight,
                                        cyCapture, m_ulDeciStepY) == TRUE);

            m_svpInfo.dwVPFlags |= DDVP_PRESCALE;
            m_svpInfo.dwPrescaleWidth = m_cxCapture;
            m_svpInfo.dwPrescaleHeight = cyCapture;
            fUpdateRequired = TRUE;
        }


        //
        // Update the decimation ratio's
        //
        m_dwDeciDenX = 1000;
        m_dwDeciNumX = (DWORD)MulDiv(m_cxCapture, m_dwDeciDenX, m_lDecoderImageWidth);
        m_dwDeciDenY = 1000;
        m_dwDeciNumY = (DWORD)MulDiv(cyCapture, m_dwDeciDenY, m_lDecoderImageHeight);


        //
        // make sure that the source rectangle reflects the new source video
        // image file
        //
        RECT &rcSrc  = pWinInfo->SrcRect;
        rcSrc.right  = rcSrc.left + m_cxCapture;
        rcSrc.bottom = rcSrc.top + m_cyCapture;
    }

    //
    // Second, make sure that any shrinking falls within the capabilities
    // of the scaler on the VGA chip, cropping if necessary
    //
    m_pIVPControl->CropSourceRect(pWinInfo, dwMinZoomFactorX, dwMinZoomFactorY);


    DbgLog((LOG_TRACE, 1, TEXT("Src(%d, %d, %d, %d)"),
            pWinInfo->SrcRect.left, pWinInfo->SrcRect.top,
            pWinInfo->SrcRect.right, pWinInfo->SrcRect.bottom));

    return fUpdateRequired;
}


/*****************************Private*Routine******************************\
* Running
*
* Returns TRUE if the filter graph is in the "running" state.
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CAMVideoPort::Running()
{
    AMTRACE((TEXT("CAMVideoPort::Running")));

    return !(m_VPState == AMVP_VIDEO_STOPPED && !m_bStart);
}


/*****************************Private*Routine******************************\
* VideoPortDecimationBackend
*
*
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CAMVideoPort::VideoPortDecimationBackend(
    LPWININFO pWinInfo,
    DWORD dwDecNumX,
    DWORD dwDecDenX,
    DWORD dwDecNumY,
    DWORD dwDecDenY
    )
{
    AMTRACE((TEXT("CAMVideoPort::VideoPortDecimationBackend")));

    //
    // This is the same backend processing as the legacy code,
    // should make this into a function and avoid the code duplication.
    //

    DDVIDEOPORTINFO svpInfo = m_svpInfo;
    if ((dwDecNumX != dwDecDenX) || (dwDecNumY != dwDecDenY)) {

        DbgLog((LOG_TRACE, 1,
                TEXT("prescaling, original image width is %d"),
                m_lImageWidth));

        //
        // Apply the video port pre-scale width factor
        //
        m_svpInfo.dwVPFlags |= DDVP_PRESCALE;
        m_svpInfo.dwPrescaleWidth = MulDiv(m_lImageWidth, dwDecNumX, dwDecDenX);

        //
        // Check the video port is aligned to the specified boundardy
        //
        if (CheckVideoPortAlignment(m_svpInfo.dwPrescaleWidth) == FALSE) {

            DbgLog((LOG_TRACE, 1,
                    TEXT("pre aligned prescale width = %d"),
                    m_svpInfo.dwPrescaleWidth));

            DWORD dwPrescaleWidth = (m_svpInfo.dwPrescaleWidth &
                    (~(m_vpCaps.dwAlignVideoPortPrescaleWidth - 1)));

            dwDecNumX = MulDiv(dwPrescaleWidth, dwDecDenX, m_lImageWidth);
            m_svpInfo.dwPrescaleWidth = dwPrescaleWidth;

            DbgLog((LOG_TRACE, 1,
                    TEXT("Cause of Alignment restrictions, now new")
                    TEXT(" m_svpInfo.dwPrescaleWidth = %d"),
                    m_svpInfo.dwPrescaleWidth));
        }

        m_svpInfo.dwPrescaleHeight =
            MulDiv(m_lImageHeight, dwDecNumY, dwDecDenY);

        DbgLog((LOG_TRACE, 1, TEXT("PrescaleWidth = %d, PrescaleHeight = %d"),
                m_svpInfo.dwPrescaleWidth, m_svpInfo.dwPrescaleHeight));

        // scale the SrcRect by the decimation values computed
        RECT &rcSrc  = pWinInfo->SrcRect;
        rcSrc.left   = MulDiv(rcSrc.left,   dwDecNumX, dwDecDenX);
        rcSrc.right  = MulDiv(rcSrc.right,  dwDecNumX, dwDecDenX);
        rcSrc.top    = MulDiv(rcSrc.top ,   dwDecNumY, dwDecDenY);
        rcSrc.bottom = MulDiv(rcSrc.bottom, dwDecNumY, dwDecDenY);
        DbgLog((LOG_TRACE, 1,
                TEXT("Src(%d, %d, %d, %d)"),
                rcSrc.left, rcSrc.top, rcSrc.right, rcSrc.bottom));
        m_bVPDecimating = TRUE;
    }
    else {
        m_svpInfo.dwVPFlags &= ~DDVP_PRESCALE;
        m_svpInfo.dwPrescaleWidth = 0;
        m_svpInfo.dwPrescaleHeight = 0;
    }

    m_dwDeciNumX = dwDecNumX;
    m_dwDeciDenX = dwDecDenX;
    m_dwDeciNumY = dwDecNumY;
    m_dwDeciDenY = dwDecDenY;

    DbgLog((LOG_TRACE, 1,
            TEXT("m_dwDeciNumX = %d m_dwDeciDenX = %d"),
            m_dwDeciNumX, m_dwDeciDenX));

    DbgLog((LOG_TRACE, 1,
            TEXT("m_dwDeciNumY = %d m_dwDeciDenY = %d"),
            m_dwDeciNumY, m_dwDeciDenY));

    return m_svpInfo.dwVPFlags != svpInfo.dwVPFlags ||
           m_svpInfo.dwPrescaleWidth != svpInfo.dwPrescaleWidth ||
           m_svpInfo.dwPrescaleHeight != svpInfo.dwPrescaleHeight;
}


/*****************************Private*Routine******************************\
* TryVideoPortDecimation
*
*
* History:
* 3/3/1999 - StEstrop - Re-Wrote the original to remove the use of doubles
*
\**************************************************************************/
HRESULT
CAMVideoPort::TryVideoPortDecimation(
    LPWININFO pWinInfo,
    DWORD dwMinZoomFactorX,
    DWORD dwMinZoomFactorY,
    BOOL* lpUpdateRequired
    )
{
    AMTRACE((TEXT("CAMVideoPort::TryVideoPortDecimation")));

    CAutoLock cObjectLock(m_pMainObjLock);
    CheckPointer(pWinInfo, E_INVALIDARG);


    //
    // By default we don't need to call UpdateVideo on the video port
    //

    *lpUpdateRequired = FALSE;


    //
    // Make sure we do nothing if none of the source is supposed to be visible.
    //

    DWORD dwSrcWidth  = WIDTH(&pWinInfo->SrcRect);
    DWORD dwSrcHeight = HEIGHT(&pWinInfo->SrcRect);

    if (dwSrcWidth == 0 || dwSrcHeight == 0) {
        return E_FAIL;
    }


    //
    // We only decimate at the video port if it supports arbitary scaling
    //

    if (m_DecimationModeX != DECIMATE_ARB ||
        m_DecimationModeY != DECIMATE_ARB) {

        return E_FAIL;
    }


    //
    // Work out the decimation width and height as a pair of ratios,
    // we do this to remain compatible with the legacy code.
    //

    DWORD dwDecNumX = 1000;
    DWORD dwDecNumY = 1000;

    DWORD dwCurZoomX = MulDiv(WIDTH(&pWinInfo->DestRect), 1000, dwSrcWidth);
    DWORD dwCurZoomY = MulDiv(HEIGHT(&pWinInfo->DestRect), 1000, dwSrcHeight);

    if (dwCurZoomX < dwMinZoomFactorX) {
        // note that we round down here
        dwDecNumX = (1000 * dwCurZoomX) / dwMinZoomFactorX;
    }

    if (dwCurZoomY < dwMinZoomFactorY) {
        // note that we round down here
        dwDecNumY = (1000 * dwCurZoomY) / dwMinZoomFactorY;
    }


    *lpUpdateRequired = VideoPortDecimationBackend(pWinInfo, dwDecNumX, 1000,
                                                   dwDecNumY, 1000);
    return S_OK;
}

/*****************************Private*Routine******************************\
* AdjustSourceSize
*
* This function should only adjust the source rectangle if the source rectangle
* is actually larger than the destination rectangle AND the required shrink
* is beyond the capabilities of the scaler on the VGA chip.
*
* There is a special case if we are capturing, this case is identified by
* m_fCapturing being set to TRUE.  In this case we simply pass the parameters
* on to AdjustSourceSizeForCapture defined above.
*
* To ensure that the video image displayed still looks correct we make use of
* the scaling abilities of the video port.  We remove or reduce the shrink by
* reducing the size of the video coming over the video port.  This may be
* done in either the X or Y axis as necessary.
*
* The function first calculates the minimum shrink factor in both x and y
* directions.  The minimum factor in the x direction depends upon the bandwidth
* restrictions of the video port as well as the capabilities of the VGA scaler.
* The minimum shrink factor is scaled by 1000.
*
* Next for each axis we determine the current shrink factor, this is the ratio
* of the destination rectangle to the source rectangle scaled by 1000.
* If the current shrink factor is less than the minimum shrink factor we have to
* use the video port scaler to shrink the source rectangle to such a size that
* the VGA scaler is able to cope with the required scaling operation.
*
* There are three methods of scaling at the video port, the choice of method
* used is determined by querying the video port.  The three methods are:
*
* 1. Arbitrary:
* This means that the video port scaler can shrink the video
* to any requested size.  In this case we simply do all the scaling in the
* video port, the VGA scaler is not really used as the source rectangle is now
* the same size as the destination rectangle.
*
* 2. Increment:
* This means that the video port scaler can shrink the video in increments of
* x / N, where N is a constant integer returned from the video port and x is an
* variable integer in the range from 1 to (N-1).  We adjust the source rectangle
* so that is less than or equal to the destination rectangle.  The VGA scaler is
* then used if any stretching is required.
*
* 3. Binary:
* Here the video port can only shrink the video by a binary factor, that is 1/x,
* where x is a power of 2.  Again we adjust the source rectangle
* so that is less than or equal to the destination rectangle.  The VGA scaler is
* then used if any stretching is required.
*
*
* See additional comments in OVMixer.htm
*
* History:
* 3/3/1999 - StEstrop - Re-Wrote the original to remove the use of doubles
*
\**************************************************************************/
BOOL
CAMVideoPort::AdjustSourceSize(
    LPWININFO pWinInfo,
    DWORD dwMinZoomFactorX,
    DWORD dwMinZoomFactorY
    )
{
    AMTRACE((TEXT("CAMVideoPort::AdjustSourceSize")));
    CAutoLock cObjectLock(m_pMainObjLock);
    CheckPointer(pWinInfo, E_INVALIDARG);


    //
    // Make sure we do nothing if none of the source is supposed to be visible.
    //

    DWORD dwSrcWidth  = WIDTH(&pWinInfo->SrcRect);
    DWORD dwSrcHeight = HEIGHT(&pWinInfo->SrcRect);
    if (dwSrcWidth == 0 || dwSrcHeight == 0) {
        return FALSE;
    }


    //
    // Another special case for capturing, see the comments above.
    //
    if (m_fCapturing) {
        return AdjustSourceSizeForCapture(pWinInfo,dwMinZoomFactorX,
                                          dwMinZoomFactorY);
    }


    //
    // Determine the adjustment for the x axis.
    //

    DWORD dwDecNumX = 1000;
    DWORD dwDecDenX = 1000;
    DWORD dwDstWidth  = WIDTH(&pWinInfo->DestRect);
    DWORD dwCurZoomFactorX = MulDiv(dwDstWidth,  1000, dwSrcWidth);

    switch (m_DecimationModeX) {
    case DECIMATE_ARB:
        DbgLog((LOG_TRACE, 1, TEXT("DECIMATE_ARB X")));
        if (dwCurZoomFactorX < dwMinZoomFactorX) {
            dwDecNumX = dwCurZoomFactorX;
        }
        break;

    case DECIMATE_BIN:
        DbgLog((LOG_TRACE, 1, TEXT("DECIMATE_BIN X")));
        while ((DWORD)MulDiv(dwDstWidth, dwDecDenX, dwSrcWidth)
                < dwMinZoomFactorX)
        {
            dwDecDenX *= 2;
        }
        break;

    case DECIMATE_INC:
        DbgLog((LOG_TRACE, 1, TEXT("DECIMATE_INC X")));
        if (dwCurZoomFactorX < dwMinZoomFactorX) {

            dwDecNumX = MulABC_DivDE(dwDstWidth, m_ulDeciStepX, 1000,
                                     dwMinZoomFactorX, dwSrcWidth);
            dwDecDenX = m_ulDeciStepX;

            DbgLog((LOG_TRACE, 1, TEXT("dwDecNumX = %d dwDecDenX = %d"),
                    dwDecNumX, dwDecDenX ));
        }
        break;
    }


    //
    // Determine the adjustment for the y axis.
    //
    DWORD dwDecNumY = 1000;
    DWORD dwDecDenY = 1000;
    DWORD dwDstHeight = HEIGHT(&pWinInfo->DestRect);
    DWORD dwCurZoomFactorY = MulDiv(dwDstHeight, 1000, dwSrcHeight);

    switch (m_DecimationModeY) {
    case DECIMATE_ARB:
        DbgLog((LOG_TRACE, 1, TEXT("DECIMATE_ARB Y")));
        if (dwCurZoomFactorY < dwMinZoomFactorY) {
            dwDecNumY = dwCurZoomFactorY;
        }
        break;

    case DECIMATE_BIN:
        DbgLog((LOG_TRACE, 1, TEXT("DECIMATE_BIN Y")));
        while ((DWORD)MulDiv(dwDecDenY, dwDstWidth, dwSrcWidth)
                < dwMinZoomFactorY)
        {
            dwDecDenY *= 2;
        }
        break;

    case DECIMATE_INC:
        DbgLog((LOG_TRACE, 1, TEXT("DECIMATE_INC Y")));
        if (dwCurZoomFactorY < dwMinZoomFactorY) {

            dwDecNumY = MulABC_DivDE(dwDstHeight, m_ulDeciStepY, 1000,
                                     dwMinZoomFactorY, dwSrcHeight);
            dwDecDenY = m_ulDeciStepY;

            DbgLog((LOG_TRACE, 1, TEXT("dwDecNumY = %d dwDecDenY = %d"),
                    dwDecNumY, dwDecDenY ));
        }
        break;
    }

    return VideoPortDecimationBackend(pWinInfo, dwDecNumX, dwDecDenX,
                                      dwDecNumY, dwDecDenY);
}



/*****************************Private*Routine******************************\
* BeyondOverlayCaps
*
*
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CAMVideoPort::BeyondOverlayCaps(
    DWORD ScaleFactor,
    DWORD xMin,
    DWORD yMin
    )
{
    return ScaleFactor < xMin || ScaleFactor < yMin;
}



/*****************************Private*Routine******************************\
* TryDecoderDecimation
*
*
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
HRESULT
CAMVideoPort::TryDecoderDecimation(
    LPWININFO pWinInfo
    )
{
    //
    // Extract the width and height that we are trying to decimate
    // the video image down too
    //

    DWORD dwWidth = WIDTH(&pWinInfo->DestRect);
    DWORD dwHeight = HEIGHT(&pWinInfo->DestRect);


    //
    // Try to use the new IDecimateVideoImage interface on our upstream
    // filter
    //

    IDecimateVideoImage* lpDVI;
    HRESULT hr = m_pIVPControl->GetVideoDecimation(&lpDVI);
    if (SUCCEEDED(hr)) {
        hr = lpDVI->SetDecimationImageSize(dwWidth, dwHeight);
        lpDVI->Release();
    }


    //
    // If that failed try to decimate using the old IVPConfig interface
    //

    if (FAILED(hr)) {

        AMVPSIZE amvpSize;
        amvpSize.dwWidth = dwWidth;
        amvpSize.dwHeight = dwHeight;

        DbgLog((LOG_TRACE, 1,
                TEXT("SetScalingFactors to (%d, %d)"),
                amvpSize.dwWidth, amvpSize.dwHeight));

        hr = m_pIVPConfig->SetScalingFactors(&amvpSize);
    }

    //
    // If we were successful update our state variables
    //
    if (SUCCEEDED(hr)) {

        m_bDecimating = TRUE;
        pWinInfo->SrcRect.right = m_lWidth = dwWidth;
        pWinInfo->SrcRect.bottom = m_lHeight = dwHeight;
    }
    else {
        ResetDecoderDecimationIfSet();
        hr = E_FAIL;
    }

    return hr;
}



/*****************************Private*Routine******************************\
* ResetVPDecimationIfSet
*
*
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CAMVideoPort::ResetVPDecimationIfSet()
{
    BOOL bUpdateRequired = m_bVPDecimating;
    if (m_bVPDecimating) {

        m_svpInfo.dwVPFlags &= ~DDVP_PRESCALE;
        m_svpInfo.dwPrescaleWidth = 0;
        m_svpInfo.dwPrescaleHeight = 0;

        m_bVPDecimating = FALSE;
        m_dwDeciNumX = m_dwDeciDenX = 1000;
        m_dwDeciNumY = m_dwDeciDenY = 1000;
    }

    return bUpdateRequired;
}



/*****************************Private*Routine******************************\
* ResetDecoderDecimationIfSet
*
*
*
* History:
* Wed 07/14/1999 - StEstrop - Created
*
\**************************************************************************/
void
CAMVideoPort::ResetDecoderDecimationIfSet()
{
    if (m_bDecimating) {

        IDecimateVideoImage* lpDVI;
        HRESULT hr = m_pIVPControl->GetVideoDecimation(&lpDVI);
        if (SUCCEEDED(hr)) {
            hr = lpDVI->ResetDecimationImageSize();
            lpDVI->Release();
        }


        if (FAILED(hr)) {
            AMVPSIZE amvpSize;
            amvpSize.dwWidth = m_lDecoderImageWidth;
            amvpSize.dwHeight = m_lDecoderImageHeight;

            DbgLog((LOG_TRACE,1,
                    TEXT("SetScalingFactors to (%d, %d)"),
                    amvpSize.dwWidth, amvpSize.dwHeight));

            hr = m_pIVPConfig->SetScalingFactors(&amvpSize);
        }

        if (SUCCEEDED(hr)) {
            m_bDecimating = FALSE;
            m_lWidth = 0;
            m_lHeight = 0;
        }
    }
}



/*****************************Private*Routine******************************\
* ApplyDecimation
*
* Video Port case
*
* This is where we enforce the chosen decimation strategy for the Video Port
* case.
*
* History:
* Tue 07/13/1999 - StEstrop - Created
*
\**************************************************************************/
BOOL
CAMVideoPort::ApplyDecimation(
    LPWININFO pWinInfo,
    BOOL bColorKeying,
    BOOL bYInterpolating
    )
{
    AMTRACE((TEXT("CAMVideoPort::ApplyDecimation")));
    BOOL bUpdateRequired = FALSE;

    DECIMATION_USAGE dwUsage;
    m_pIVPControl->GetDecimationUsage(&dwUsage);


    //
    // Determine the current min zoom factors givin the current overlay and
    // video port connection
    //

    DWORD dwMinZoomX, dwMinZoomY;
    GetMinZoomFactors(pWinInfo, bColorKeying, bYInterpolating,
                      &dwMinZoomX, &dwMinZoomY);

    if ((dwUsage == DECIMATION_LEGACY) ||
        (dwUsage == DECIMATION_DEFAULT && m_fCapturing)) {

        bUpdateRequired = AdjustSourceSize(pWinInfo,
                                           dwMinZoomX,
                                           dwMinZoomY);
    }


    else {

        if (Running()) {

            DWORD ScaleFactor = ::GetCurrentScaleFactor(pWinInfo);
            if (IsDecimationNeeded(ScaleFactor)) {

                switch (dwUsage) {

                case DECIMATION_USE_OVERLAY_ONLY:
                    bUpdateRequired = ResetVPDecimationIfSet();
                    m_pIVPControl->CropSourceRect(pWinInfo,
                                                  dwMinZoomX,
                                                  dwMinZoomY);
                    break;

                case DECIMATION_USE_DECODER_ONLY:
                    bUpdateRequired = ResetVPDecimationIfSet();
                    if (TryDecoderDecimation(pWinInfo) != S_OK) {
                        m_pIVPControl->CropSourceRect(pWinInfo,
                                                      dwMinZoomX,
                                                      dwMinZoomY);
                    }
                    break;

                case DECIMATION_USE_VIDEOPORT_ONLY:
                    ResetDecoderDecimationIfSet();
                    if (TryVideoPortDecimation(pWinInfo, 1000,
                                               1000,
                                               &bUpdateRequired) != S_OK) {

                        m_pIVPControl->CropSourceRect(pWinInfo,
                                                      dwMinZoomX,
                                                      dwMinZoomY);
                    }
                    break;

                case DECIMATION_DEFAULT:
                    if (TryDecoderDecimation(pWinInfo) != S_OK) {
                        if (BeyondOverlayCaps(ScaleFactor, dwMinZoomX,
                                              dwMinZoomY)) {

                            if (TryVideoPortDecimation(pWinInfo,
                                                       dwMinZoomX,
                                                       dwMinZoomY,
                                                       &bUpdateRequired) != S_OK) {

                                m_pIVPControl->CropSourceRect(pWinInfo,
                                                              dwMinZoomX,
                                                              dwMinZoomY);
                            }
                        }
                    }
                    break;
                }
            }
            else {

                ResetDecoderDecimationIfSet();
                bUpdateRequired = ResetVPDecimationIfSet();
            }
        }


        else {

            if (m_bVPDecimating) {

                //
                // Apply the current pre-scale to the source image.
                //

                RECT &rcSrc = pWinInfo->SrcRect;
                rcSrc.left = MulDiv(rcSrc.left, m_dwDeciNumX, m_dwDeciDenX);
                rcSrc.top = MulDiv(rcSrc.top, m_dwDeciNumY, m_dwDeciDenY);
                rcSrc.right = MulDiv(rcSrc.right, m_dwDeciNumX, m_dwDeciDenX);
                rcSrc.bottom = MulDiv(rcSrc.bottom, m_dwDeciNumY, m_dwDeciDenY);
            }

            if (m_bDecimating) {

                //
                // Apply the current decoder decimation to the source image.
                //

                pWinInfo->SrcRect.right = m_lWidth;
                pWinInfo->SrcRect.bottom = m_lHeight;
            }

            //
            // Then make sure that any shrinking falls within the capabilities
            // of the scaler on the VGA chip, cropping if necessary.
            //

            m_pIVPControl->CropSourceRect(pWinInfo, dwMinZoomX, dwMinZoomY);
        }
    }

    return bUpdateRequired;
}
/******************************Public*Routine******************************\
* MulABC_DivDE
*
* Performs the following calculation:  ((A*B*C) / (D*E)) rounding the result
* to the nearest integer.
*
* History:
* 3/3/1999 - StEstrop - Created
*
\**************************************************************************/
DWORD MulABC_DivDE(DWORD A, DWORD B, DWORD C, DWORD D, DWORD E)
{

    unsigned __int64 Num = (unsigned __int64)A * (unsigned __int64)B;
    unsigned __int64 Den = (unsigned __int64)D * (unsigned __int64)E;

    if (Den == 0) {
        Den = 1;
    }

    Num *= (unsigned __int64)C;
    Num += (Den / 2);

    unsigned __int64 Res = Num / Den;

    return (DWORD)Res;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\mixer\ovmixer\macvis.cpp ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
//
// MacVis.cpp:  Overlay Mixer's Macrovision support code
//

#include <streams.h>
#include <windowsx.h>

#include <ddraw.h>
#include <mmsystem.h>	    // Needed for definition of timeGetTime
#include <limits.h>	    // Standard data type limit definitions
#include <ks.h>
#include <ksproxy.h>
#include <bpcwrap.h>
#include <ddmmi.h>
#include <amstream.h>
#include <dvp.h>
#include <ddkernel.h>
#include <vptype.h>
#include <vpconfig.h>
#include <vpnotify.h>
#include <vpobj.h>
#include <syncobj.h>
#include <mpconfig.h>
#include <ovmixpos.h>
#include "MultMon.h"  // our version of multimon.h include ChangeDisplaySettingsEx
#include <macvis.h>
#include <ovmixer.h>

CDispMacroVision::CDispMacroVision(COMFilter *pOvMFilter)
{
    DbgLog((LOG_TRACE, 5, TEXT("CDispMacroVision::CDispMacroVision(0x%lx)"), pOvMFilter)) ;
    m_dwCPKey = 0 ;
    m_pOvMFilter = pOvMFilter ;
}


CDispMacroVision::~CDispMacroVision(void)
{
    DbgLog((LOG_TRACE, 5, TEXT("CDispMacroVision::~CDispMacroVision()"))) ;
    SetMacroVision(0) ;
    StopMacroVision() ;
    ASSERT(0 == m_dwCPKey) ;
}


//
// This is a wrapper function to get the correct HMONITOR from the OverlayMixer.
//
HMONITOR
CDispMacroVision::GetMonitor(void)
{
    HMONITOR  hMon ;
    ASSERT(m_pOvMFilter) ;
    hMon = m_pOvMFilter->GetCurrentMonitor() ;
    DbgLog((LOG_TRACE, 3, TEXT("Monitor handle is %ld"), hMon)) ;
    return hMon ;
}


BOOL
CDispMacroVision::StopMacroVision()
{
    DbgLog((LOG_TRACE, 5, TEXT("CDispMacroVision::StopMacroVision()"))) ;

    if (0 == m_dwCPKey)
    {
        DbgLog((LOG_TRACE, 3, TEXT("Copy prot key was not acquired. Nothing to release."))) ;
        return TRUE ;  // success, what else?
    }

    HMONITOR  hMon = GetMonitor() ;

    MONITORINFOEX  mi ;
    mi.cbSize = sizeof(mi) ;
    if (! GetMonitorInfo(hMon, &mi) )
    {
        DbgLog((LOG_ERROR, 0, TEXT("GetMonitorInfo() failed (Error: %ld)"),
                GetLastError())) ;
        return FALSE ;
    }
    DbgLog((LOG_TRACE, 3, TEXT("DeviceName: '%s'"), mi.szDevice)) ;

    LONG             lRet ;
    VIDEOPARAMETERS  VidParams ;
    DEVMODE          DevMode ;
    // DISPLAY_DEVICE   dd ;
    // ZeroMemory(&dd, sizeof(dd)) ;
    // dd.cb = sizeof(dd) ;

    ZeroMemory(&DevMode, sizeof(DevMode)) ;
    DevMode.dmSize = sizeof(DevMode) ;

    ZeroMemory(&VidParams, sizeof(VidParams)) ;
    VidParams.Guid      = guidVidParam ;
    VidParams.dwCommand = VP_COMMAND_GET ;

    lRet = ChangeDisplaySettingsEx(mi.szDevice, &DevMode, NULL,
                                   CDS_VIDEOPARAMETERS | CDS_NORESET | CDS_UPDATEREGISTRY,
                                   &VidParams) ;
    if (DISP_CHANGE_SUCCESSFUL != lRet)
    {
        DbgLog((LOG_ERROR, 0, TEXT("ChangeDisplaySettingsEx(_GET) failed (%ld)"), lRet)) ;
        return FALSE ;
    }

    if (! ( (VidParams.dwFlags & VP_FLAGS_COPYPROTECT) &&
            (VidParams.dwCPType & VP_CP_TYPE_APS_TRIGGER) &&
            (VidParams.dwTVStandard & VidParams.dwCPStandard) ) )
    {
        // How did we acquire CP key in teh first place?
        DbgLog((LOG_ERROR, 0,
            TEXT("Copy prot weird error case (dwFlags=0x%lx, dwCPType=0x%lx, dwTVStandard=0x%lx, dwCPStandard=0x%lx"),
                VidParams.dwFlags, VidParams.dwCPType, VidParams.dwTVStandard, VidParams.dwCPStandard)) ;
        return FALSE ;
    }

    VidParams.dwCommand    = VP_COMMAND_SET ;
    VidParams.dwFlags      = VP_FLAGS_COPYPROTECT ;
    VidParams.dwCPType     = VP_CP_TYPE_APS_TRIGGER ;
    VidParams.dwCPCommand  = VP_CP_CMD_DEACTIVATE ;
    VidParams.dwCPKey      = m_dwCPKey ;
    VidParams.bCP_APSTriggerBits = (BYTE) 0 ;  // some value
    lRet = ChangeDisplaySettingsEx(mi.szDevice, &DevMode, NULL,
                                   CDS_VIDEOPARAMETERS | CDS_NORESET | CDS_UPDATEREGISTRY,
                                   &VidParams) ;
    if (DISP_CHANGE_SUCCESSFUL != lRet)
    {
        DbgLog((LOG_ERROR, 0, TEXT("ChangeDisplaySettingsEx() failed (%ld)"), lRet)) ;
        return FALSE ;
    }

    DbgLog((LOG_TRACE, 1, TEXT("Macrovision deactivated on key %lu"), m_dwCPKey)) ;
    m_dwCPKey = 0 ;

    return TRUE ;
}


//
// This function applies Macrovision based on the input parameter dwCPBits.
// hWnd is the handle of the window in which content is played back.
//
// Returns TRUE on success and FALSE on any failure.
//
BOOL
CDispMacroVision::SetMacroVision(DWORD dwCPBits)
{
    DbgLog((LOG_TRACE, 5, TEXT("CDispMacroVision::SetMacroVision(0x%lx)"), dwCPBits)) ;

    //
    // If MV is currently not set at all and the new CP bits is 0 (which happens
    // when from the Nav we reset the MV bits on start / stop of playback), we
    // don't really need to do anything -- MV not started and doesn't need to be
    // started.  So just leave queitly...
    //
    if (0 == m_dwCPKey  &&  // no key acquired so far
        0 == dwCPBits)      // MV CPBits is 0
    {
        DbgLog((LOG_TRACE, 1, TEXT("Copy prot is not enabled now and new CP bits is 0 -- so skip it."))) ;
        return TRUE ;  // we don't need to do anything, so success.
    }

    HMONITOR  hMon = GetMonitor() ;

    MONITORINFOEX  mi ;
    mi.cbSize = sizeof(mi) ;
    if (! GetMonitorInfo(hMon, &mi) )
    {
        DbgLog((LOG_ERROR, 0, TEXT("GetMonitorInfo() failed (Error: %ld)"),
                GetLastError())) ;
        return FALSE ;
    }
    DbgLog((LOG_TRACE, 3, TEXT("DeviceName: '%s'"), mi.szDevice)) ;

    LONG             lRet ;
    VIDEOPARAMETERS  VidParams ;
    DEVMODE          DevMode ;
    // DISPLAY_DEVICE   dd ;
    // ZeroMemory(&dd, sizeof(dd)) ;
    // dd.cb = sizeof(dd) ;

    ZeroMemory(&DevMode, sizeof(DevMode)) ;
    DevMode.dmSize = sizeof(DevMode) ;

    ZeroMemory(&VidParams, sizeof(VidParams)) ;
    VidParams.Guid      = guidVidParam ;
    VidParams.dwCommand = VP_COMMAND_GET ;

    lRet = ChangeDisplaySettingsEx(mi.szDevice, &DevMode, NULL,
                                   CDS_VIDEOPARAMETERS | CDS_NORESET | CDS_UPDATEREGISTRY,
                                   &VidParams) ;
    if (DISP_CHANGE_SUCCESSFUL != lRet)
    {
        DbgLog((LOG_ERROR, 0, TEXT("ChangeDisplaySettingsEx(_GET) failed (%ld)"), lRet)) ;
        return FALSE ;
    }

    if (0 == VidParams.dwFlags ||
        VP_TV_STANDARD_WIN_VGA == VidParams.dwTVStandard)
    {
        DbgLog((LOG_TRACE, 1, TEXT("** Copy protection NOT required (dwFlags=0x%lx, dwTVStandard=0x%lx"),
                VidParams.dwFlags, VidParams.dwTVStandard));
        return TRUE ;
    }

    //
    // Check to see if
    // a) the device supports copy prot
    // b) CP type is APS trigger
    // c) current TV standard and CP standard have commonality.
    // If so, apply copy prot. Otherwise error.
    //
    if ( (VidParams.dwFlags & VP_FLAGS_COPYPROTECT) &&
         (VidParams.dwCPType & VP_CP_TYPE_APS_TRIGGER) &&
         (VidParams.dwTVStandard & VidParams.dwCPStandard) )
    {
        DbgLog((LOG_TRACE, 3,
            TEXT("** Copy prot needs to be applied (dwFlags=0x%lx, dwCPType=0x%lx, dwTVStandard=0x%lx, dwCPStandard=0x%lx"),
                VidParams.dwFlags, VidParams.dwCPType, VidParams.dwTVStandard, VidParams.dwCPStandard)) ;

        VidParams.dwCommand = VP_COMMAND_SET ;          // do we have to set it again??
        VidParams.dwFlags   = VP_FLAGS_COPYPROTECT ;
        VidParams.dwCPType  = VP_CP_TYPE_APS_TRIGGER ;
        VidParams.bCP_APSTriggerBits = (BYTE) (dwCPBits & 0xFF) ;

        // Check if we already have a copy prot key; if not, get one now
        if (0 == m_dwCPKey)  // no key acquired so far
        {
            // Acquire a new key (that also aplies it, so no separate Set reqd)
            VidParams.dwCPCommand = VP_CP_CMD_ACTIVATE ;
            VidParams.dwCPKey     = 0 ;
            lRet = ChangeDisplaySettingsEx(mi.szDevice, &DevMode, NULL,
                                           CDS_VIDEOPARAMETERS | CDS_NORESET | CDS_UPDATEREGISTRY,
                                           &VidParams) ;
            if (DISP_CHANGE_SUCCESSFUL != lRet)
            {
                DbgLog((LOG_ERROR, 0,
                    TEXT("** ChangeDisplaySettingsEx() failed (%ld) to activate copy prot"), lRet)) ;
                return FALSE ;
            }

            m_dwCPKey = VidParams.dwCPKey ;
            DbgLog((LOG_TRACE, 3, TEXT("** Copy prot activated. Key value is %lu"), m_dwCPKey)) ;
        }
        else  // key already acquired
        {
            // apply the copy prot bits specified in the content
            VidParams.dwCPCommand = VP_CP_CMD_CHANGE ;
            VidParams.dwCPKey     = m_dwCPKey ;
            DbgLog((LOG_TRACE, 5, TEXT("** Going to call ChangeDisplaySettingsEx(_SET)..."))) ;
            lRet = ChangeDisplaySettingsEx(mi.szDevice, &DevMode, NULL,
                                           CDS_VIDEOPARAMETERS | CDS_NORESET | CDS_UPDATEREGISTRY,
                                           &VidParams) ;
            if (DISP_CHANGE_SUCCESSFUL != lRet)
            {
                DbgLog((LOG_ERROR, 0,
                    TEXT("** ChangeDisplaySettingsEx() failed (%ld) to set copy prot bits (%lu)"),
                    lRet, dwCPBits)) ;
                return FALSE ;
            }
            else
                DbgLog((LOG_TRACE, 3, TEXT("** Copy prot bits (0x%lx) applied"), dwCPBits)) ;
        }
    }
    else
    {
        DbgLog((LOG_ERROR, 0,
            TEXT("** Copy prot error case (dwFlags=0x%lx, dwCPType=0x%lx, dwTVStandard=0x%lx, dwCPStandard=0x%lx"),
                VidParams.dwFlags, VidParams.dwCPType, VidParams.dwTVStandard, VidParams.dwCPStandard)) ;
        return FALSE ;
    }

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\filters\mixer\ovmixer\omoutpin.cpp ===
// Copyright (c) 1998 - 1999  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <ddraw.h>
#include <mmsystem.h>	    // Needed for definition of timeGetTime
#include <limits.h>	    // Standard data type limit definitions
#include <ks.h>
#include <ksproxy.h>
#include <bpcwrap.h>
#include <ddmmi.h>
#include <amstream.h>
#include <dvp.h>
#include <ddkernel.h>
#include <vptype.h>
#include <vpconfig.h>
#include <vpnotify.h>
#include <vpobj.h>
#include <syncobj.h>
#include <mpconfig.h>
#include <ovmixpos.h>
#include <dvdmedia.h>
#include <macvis.h>
#include <ovmixer.h>
#include <resource.h>
#include "MultMon.h"  // our version of multimon.h include ChangeDisplaySettingsEx

// constructor
COMOutputPin::COMOutputPin(TCHAR *pObjectName, COMFilter *pFilter, CCritSec *pLock,
			   HRESULT *phr, LPCWSTR pPinName, DWORD dwPinNo)
			   : CBaseOutputPin(pObjectName, pFilter, pLock, phr, pPinName)
{
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMOutputPin::Constructor")));

    m_pFilterLock = pLock;

    m_pPosition = NULL;
    m_dwPinId = dwPinNo;
    m_pFilter = pFilter;
    m_pIOverlay = NULL;
    m_bAdvise = FALSE;
    m_pDrawClipper = NULL;

    // stuff to handle the new winproc of the window
    m_bWindowDestroyed = TRUE;
    m_lOldWinUserData = 0;
    m_hOldWinProc = NULL;

    m_hwnd = NULL;
    m_hDC = NULL;
    m_dwConnectWidth = 0;
    m_dwConnectHeight = 0;

//CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMOutputPin::Constructor")));
    return;
}

// destructor
COMOutputPin::~COMOutputPin()
{
    DbgLog((LOG_TRACE, 5, TEXT("Entering COMOutputPin::Destructor")));

    CAutoLock cLock(m_pFilterLock);

    if (m_pPosition)
    {
        m_pPosition->Release();
    }

    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMOutputPin::Destructor")));

    return;
}

// overriden to expose IMediaPosition and IMediaSeeking control interfaces
STDMETHODIMP COMOutputPin::NonDelegatingQueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMOutputPin::NonDelegatingQueryInterface")));

    CAutoLock cLock(m_pFilterLock);

    if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking)
    {
        // we should have an input pin by now
        if (m_pPosition == NULL)
        {
            hr = CreatePosPassThru(GetOwner(), FALSE, (IPin *)m_pFilter->GetPin(0), &m_pPosition);
            if (FAILED(hr))
            {
                DbgLog((LOG_ERROR, 1, TEXT("CreatePosPassThru failed, hr = 0x%x"), hr));
                goto CleanUp;
            }
        }
        hr = m_pPosition->QueryInterface(riid, ppv);
        goto CleanUp;
    }

    DbgLog((LOG_TRACE, 5, TEXT("QI'ing CBaseOutputPin")));
    hr = CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    if (FAILED(hr))
    {
        DbgLog((LOG_ERROR, 2, TEXT("CBaseOutputPin::NonDelegatingQueryInterface(riid) failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMOutputPin::NonDelegatingQueryInterface")));
    return hr;
}

// check a given transform
HRESULT COMOutputPin::CheckMediaType(const CMediaType* pmt)
{
    HRESULT hr = NOERROR;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMOutputPin::CheckMediaType")));

    CAutoLock cLock(m_pFilterLock);

    // we only allow a subtype overlay connection
    if (pmt->majortype != MEDIATYPE_Video || pmt->subtype != MEDIASUBTYPE_Overlay)
    {
	hr = S_FALSE;
        goto CleanUp;
    }

    // tell the owning filter
    hr = m_pFilter->CheckMediaType(m_dwPinId, pmt);
    if (FAILED(hr))
    {
        DbgLog((LOG_TRACE, 5, TEXT("m_pFilter->CheckMediaType failed, hr = 0x%x"), hr));
        goto CleanUp;
    }

CleanUp:
    DbgLog((LOG_TRACE, 5, TEXT("Leaving COMOutputPin::CheckMediaType")));
    return hr;
}

// Propose with a MEDIASUBTYPE_Overlay
HRESULT COMOutputPin::GetMediaType(int iPosition,CMediaType *pmt)
{
    HRESULT hr = NOERROR;
    DWORD dwConnectWidth = 0;
    DWORD dwConnectHeight = 0;
    VIDEOINFOHEADER *pvi = NULL;
    BITMAPINFOHEADER *pHeader = NULL;

    DbgLog((LOG_TRACE, 5, TEXT("Entering COMOutputPin::GetMediaType")));

    CAutoLock cLock(m_pFilterLock);

    //  Can't be < 0 - it's the base classes calling us
    ASSERT(iPosition >= 0);

    if (iPosition > 0)
    {
        hr = VFW_S_NO_MORE_ITEMS;
        goto CleanUp;
    }

    // I am allocating a large enough buffer for palettized and non-palettized formats
    pvi = (VIDEOINFOHEADER *) pmt->AllocFormatBuffer(sizeof(VIDEOINFOHEADER) + sizeof(TRUECOLORINFO));
    if (NULL == pvi)
    {
	DbgLog((LOG_ERROR, 1, TEXT("pmt->AllocFormatBuffer failed")));
	hr = E_OUTOFMEMORY;
        goto CleanUp;
    }
    ZeroMemory(pvi, sizeof(VIDEOINFOHEADER) + sizeof(TRUECOLORINFO));


    pmt->SetFormatType(&FORMAT_VideoInfo);
    pmt->majortype = MEDIATYPE_Video;
    pmt->subtype   = MEDIASUBTYPE_Overlay;
    pmt->bFixedSizeSamples    = FALSE;
    pmt->bTemporalCompression = FALSE;
    pmt->lSampleSize          = 0;

    // We set the BITMAPINFOHEADER to be a really basic eight bit palettised
    // format so that the video renderer will always accept it. We have to
    // pro