TYPE_AIFF                            ,IDS_MEDIASUBTYPE_AIFF},
    { &MEDIASUBTYPE_AU                              ,IDS_MEDIASUBTYPE_AU},
    { &MEDIASUBTYPE_AnalogVideo_NTSC_M              ,IDS_MEDIASUBTYPE_AnalogVideo_NTSC_M},
    { &MEDIASUBTYPE_AnalogVideo_PAL_B               ,IDS_MEDIASUBTYPE_AnalogVideo_PAL_B},
    { &MEDIASUBTYPE_AnalogVideo_PAL_D               ,IDS_MEDIASUBTYPE_AnalogVideo_PAL_D},
    { &MEDIASUBTYPE_AnalogVideo_PAL_G               ,IDS_MEDIASUBTYPE_AnalogVideo_PAL_G},
    { &MEDIASUBTYPE_AnalogVideo_PAL_H               ,IDS_MEDIASUBTYPE_AnalogVideo_PAL_H},
    { &MEDIASUBTYPE_AnalogVideo_PAL_I               ,IDS_MEDIASUBTYPE_AnalogVideo_PAL_I},
    { &MEDIASUBTYPE_AnalogVideo_PAL_M               ,IDS_MEDIASUBTYPE_AnalogVideo_PAL_M},
    { &MEDIASUBTYPE_AnalogVideo_PAL_N               ,IDS_MEDIASUBTYPE_AnalogVideo_PAL_N},
    { &MEDIASUBTYPE_AnalogVideo_SECAM_B             ,IDS_MEDIASUBTYPE_AnalogVideo_SECAM_B},
    { &MEDIASUBTYPE_AnalogVideo_SECAM_D             ,IDS_MEDIASUBTYPE_AnalogVideo_SECAM_D},
    { &MEDIASUBTYPE_AnalogVideo_SECAM_G             ,IDS_MEDIASUBTYPE_AnalogVideo_SECAM_G},
    { &MEDIASUBTYPE_AnalogVideo_SECAM_H             ,IDS_MEDIASUBTYPE_AnalogVideo_SECAM_H},
    { &MEDIASUBTYPE_AnalogVideo_SECAM_K             ,IDS_MEDIASUBTYPE_AnalogVideo_SECAM_K},
    { &MEDIASUBTYPE_AnalogVideo_SECAM_K1            ,IDS_MEDIASUBTYPE_AnalogVideo_SECAM_K1},
    { &MEDIASUBTYPE_AnalogVideo_SECAM_L             ,IDS_MEDIASUBTYPE_AnalogVideo_SECAM_L},
    { &MEDIASUBTYPE_Avi                             ,IDS_MEDIASUBTYPE_Avi},
    { &MEDIASUBTYPE_CFCC                            ,IDS_MEDIASUBTYPE_CFCC},
    { &MEDIASUBTYPE_CLJR                            ,IDS_MEDIASUBTYPE_CLJR},
    { &MEDIASUBTYPE_CPLA                            ,IDS_MEDIASUBTYPE_CPLA},
    { &MEDIASUBTYPE_DOLBY_AC3                       ,IDS_MEDIASUBTYPE_DOLBY_AC3},
    { &MEDIASUBTYPE_DVCS                            ,IDS_MEDIASUBTYPE_DVCS},
    { &MEDIASUBTYPE_DVD_LPCM_AUDIO                  ,IDS_MEDIASUBTYPE_DVD_LPCM_AUDIO},
    { &MEDIASUBTYPE_DVD_NAVIGATION_DSI              ,IDS_MEDIASUBTYPE_DVD_NAVIGATION_DSI},
    { &MEDIASUBTYPE_DVD_NAVIGATION_PCI              ,IDS_MEDIASUBTYPE_DVD_NAVIGATION_PCI},
    { &MEDIASUBTYPE_DVD_NAVIGATION_PROVIDER         ,IDS_MEDIASUBTYPE_DVD_NAVIGATION_PROVIDER},
    { &MEDIASUBTYPE_DVD_SUBPICTURE                  ,IDS_MEDIASUBTYPE_DVD_SUBPICTURE},
    { &MEDIASUBTYPE_DVSD                            ,IDS_MEDIASUBTYPE_DVSD},
    { &MEDIASUBTYPE_DssAudio                        ,IDS_MEDIASUBTYPE_DssAudio},
    { &MEDIASUBTYPE_DssVideo                        ,IDS_MEDIASUBTYPE_DssVideo},
    { &MEDIASUBTYPE_IF09                            ,IDS_MEDIASUBTYPE_IF09},
    { &MEDIASUBTYPE_IJPG                            ,IDS_MEDIASUBTYPE_IJPG},
    { &MEDIASUBTYPE_Line21_BytePair                 ,IDS_MEDIASUBTYPE_Line21_BytePair},
    { &MEDIASUBTYPE_Line21_GOPPacket                ,IDS_MEDIASUBTYPE_Line21_GOPPacket},
    { &MEDIASUBTYPE_Line21_VBIRawData               ,IDS_MEDIASUBTYPE_Line21_VBIRawData},
    { &MEDIASUBTYPE_MDVF                            ,IDS_MEDIASUBTYPE_MDVF},
    { &MEDIASUBTYPE_MJPG                            ,IDS_MEDIASUBTYPE_MJPG},
    { &MEDIASUBTYPE_MPEG1Audio                      ,IDS_MEDIASUBTYPE_MPEG1Audio},
    { &MEDIASUBTYPE_MPEG1Packet                     ,IDS_MEDIASUBTYPE_MPEG1Packet},
    { &MEDIASUBTYPE_MPEG1Payload                  ,IDS_MEDIASUBTYPE_MPEG1Payload},
    { &MEDIASUBTYPE_MPEG1AudioPayload          ,IDS_MEDIASUBTYPE_MPEG1AudioPayload},
    { &MEDIASUBTYPE_MPEG1System                     ,IDS_MEDIASUBTYPE_MPEG1System},
    { &MEDIASUBTYPE_MPEG1Video                      ,IDS_MEDIASUBTYPE_MPEG1Video},
    { &MEDIASUBTYPE_MPEG1VideoCD                    ,IDS_MEDIASUBTYPE_MPEG1VideoCD},
    { &MEDIASUBTYPE_MPEG2_AUDIO                     ,IDS_MEDIASUBTYPE_MPEG2_AUDIO},
    { &MEDIASUBTYPE_MPEG2_PROGRAM                   ,IDS_MEDIASUBTYPE_MPEG2_PROGRAM},
    { &MEDIASUBTYPE_MPEG2_TRANSPORT                 ,IDS_MEDIASUBTYPE_MPEG2_TRANSPORT},
    { &MEDIASUBTYPE_MPEG2_VIDEO                     ,IDS_MEDIASUBTYPE_MPEG2_VIDEO},
    { &MEDIASUBTYPE_Overlay                         ,IDS_MEDIASUBTYPE_Overlay},
    { &MEDIASUBTYPE_PCM                             ,IDS_MEDIASUBTYPE_PCM},
    { &MEDIASUBTYPE_Plum                            ,IDS_MEDIASUBTYPE_Plum},
    { &MEDIASUBTYPE_QTJpeg                          ,IDS_MEDIASUBTYPE_QTJpeg},
    { &MEDIASUBTYPE_QTMovie                         ,IDS_MEDIASUBTYPE_QTMovie},
    { &MEDIASUBTYPE_QTRle                           ,IDS_MEDIASUBTYPE_QTRle},
    { &MEDIASUBTYPE_QTRpza                          ,IDS_MEDIASUBTYPE_QTRpza},
    { &MEDIASUBTYPE_QTSmc                           ,IDS_MEDIASUBTYPE_QTSmc},
    { &MEDIASUBTYPE_RGB1                            ,IDS_MEDIASUBTYPE_RGB1},
    { &MEDIASUBTYPE_RGB24                           ,IDS_MEDIASUBTYPE_RGB24},
    { &MEDIASUBTYPE_RGB32                           ,IDS_MEDIASUBTYPE_RGB32},
    { &MEDIASUBTYPE_ARGB32                          ,IDS_MEDIASUBTYPE_ARGB32},
    { &MEDIASUBTYPE_ARGB4444                        ,IDS_MEDIASUBTYPE_ARGB4444},
    { &MEDIASUBTYPE_ARGB1555                        ,IDS_MEDIASUBTYPE_ARGB1555},
    { &MEDIASUBTYPE_AYUV                            ,IDS_MEDIASUBTYPE_AYUV},
    { &MEDIASUBTYPE_RGB32_D3D_DX7_RT                ,IDS_MEDIASUBTYPE_RGB32_D3D_DX7_RT},
    { &MEDIASUBTYPE_RGB16_D3D_DX7_RT                ,IDS_MEDIASUBTYPE_RGB16_D3D_DX7_RT},
    { &MEDIASUBTYPE_ARGB32_D3D_DX7_RT               ,IDS_MEDIASUBTYPE_ARGB32_D3D_DX7_RT},
    { &MEDIASUBTYPE_ARGB1555_D3D_DX7_RT             ,IDS_MEDIASUBTYPE_ARGB1555_D3D_DX7_RT},
    { &MEDIASUBTYPE_ARGB4444_D3D_DX7_RT             ,IDS_MEDIASUBTYPE_ARGB4444_D3D_DX7_RT},
    { &MEDIASUBTYPE_RGB4                            ,IDS_MEDIASUBTYPE_RGB4},
    { &MEDIASUBTYPE_RGB555                          ,IDS_MEDIASUBTYPE_RGB555},
    { &MEDIASUBTYPE_RGB565                          ,IDS_MEDIASUBTYPE_RGB565},
    { &MEDIASUBTYPE_RGB8                            ,IDS_MEDIASUBTYPE_RGB8},
    { &MEDIASUBTYPE_TVMJ                            ,IDS_MEDIASUBTYPE_TVMJ},
    { &MEDIASUBTYPE_UYVY                            ,IDS_MEDIASUBTYPE_UYVY},
    { &MEDIASUBTYPE_WAKE                            ,IDS_MEDIASUBTYPE_WAKE},
    { &MEDIASUBTYPE_WAVE                            ,IDS_MEDIASUBTYPE_WAVE},
    { &MEDIASUBTYPE_Y211                            ,IDS_MEDIASUBTYPE_Y211},
    { &MEDIASUBTYPE_Y411                            ,IDS_MEDIASUBTYPE_Y411},
    { &MEDIASUBTYPE_Y41P                            ,IDS_MEDIASUBTYPE_Y41P},
    { &MEDIASUBTYPE_YUY2                            ,IDS_MEDIASUBTYPE_YUY2},
    { &MEDIASUBTYPE_YV12                            ,IDS_MEDIASUBTYPE_YV12},
    { &MEDIASUBTYPE_YVU9                            ,IDS_MEDIASUBTYPE_YVU9},
    { &MEDIASUBTYPE_YVYU                            ,IDS_MEDIASUBTYPE_YVYU},
    { &MEDIASUBTYPE_dvhd                            ,IDS_MEDIASUBTYPE_dvhd},
    { &MEDIASUBTYPE_dvsd                            ,IDS_MEDIASUBTYPE_dvsd},
    { &MEDIASUBTYPE_dvsl                            ,IDS_MEDIASUBTYPE_dvsl},
    { &MEDIASUBTYPE_IEEE_FLOAT                      ,IDS_MEDIASUBTYPE_IEEE_FLOAT},
    { &MEDIASUBTYPE_DOLBY_AC3_SPDIF                 ,IDS_MEDIASUBTYPE_DOLBY_AC3_SPDIF},
    { &MEDIASUBTYPE_RAW_SPORT                       ,IDS_MEDIASUBTYPE_RAW_SPORT},
    { &MEDIASUBTYPE_SPDIF_TAG_241h                  ,IDS_MEDIASUBTYPE_SPDIF_TAG_241h},
    { &MEDIASUBTYPE_DRM_Audio                       ,IDS_MEDIASUBTYPE_DRM_Audio},
    { &DXVA_ModeNone                                ,IDS_DXVA_ModeNone},
    { &DXVA_ModeH261_A                              ,IDS_DXVA_ModeH261_A},
    { &DXVA_ModeH261_B                              ,IDS_DXVA_ModeH261_B},

    { &DXVA_ModeH263_A                              ,IDS_DXVA_ModeH263_A},
    { &DXVA_ModeH263_B                              ,IDS_DXVA_ModeH263_B},
    { &DXVA_ModeH263_C                              ,IDS_DXVA_ModeH263_C},
    { &DXVA_ModeH263_D                              ,IDS_DXVA_ModeH263_D},
    { &DXVA_ModeH263_E                              ,IDS_DXVA_ModeH263_E},
    { &DXVA_ModeH263_F                              ,IDS_DXVA_ModeH263_F},

    { &DXVA_ModeMPEG1_A                             ,IDS_DXVA_ModeMPEG1_A},

    { &DXVA_ModeMPEG2_A                             ,IDS_DXVA_ModeMPEG2_A},
    { &DXVA_ModeMPEG2_B                             ,IDS_DXVA_ModeMPEG2_B},
    { &DXVA_ModeMPEG2_C                             ,IDS_DXVA_ModeMPEG2_C},
    { &DXVA_ModeMPEG2_D                             ,IDS_DXVA_ModeMPEG2_D}
};

ULONG g_iSubTable = sizeof(g_pSubTable) / sizeof(g_pSubTable[0]);

//
//
//
CTextMediaType::TableEntry g_pFormatTable [] = {
    { NULL, IDS_UNKNOWN},       // THIS ENTRY MUST BE FIRST !!!
    { &FORMAT_AnalogVideo                           ,IDS_FORMAT_AnalogVideo},
    { &FORMAT_DolbyAC3                              ,IDS_FORMAT_DolbyAC3},
    { &FORMAT_MPEG2Audio                            ,IDS_FORMAT_MPEG2Audio},
    { &FORMAT_DVD_LPCMAudio                         ,IDS_FORMAT_DVD_LPCMAudio},
    { &FORMAT_DvInfo                                ,IDS_FORMAT_DvInfo},
    { &FORMAT_MPEG2Video                            ,IDS_FORMAT_MPEG2Video},
    { &FORMAT_MPEG2_VIDEO                           ,IDS_FORMAT_MPEG2_VIDEO},
    { &FORMAT_MPEGStreams                           ,IDS_FORMAT_MPEGStreams},
    { &FORMAT_MPEGVideo                             ,IDS_FORMAT_MPEGVideo},
    { &FORMAT_VIDEOINFO2                            ,IDS_FORMAT_VIDEOINFO2},
    { &FORMAT_VideoInfo                             ,IDS_FORMAT_VideoInfo},
    { &FORMAT_VideoInfo2                            ,IDS_FORMAT_VideoInfo2},
    { &FORMAT_WaveFormatEx                          ,IDS_FORMAT_WaveFormatEx}
};

ULONG g_iFormatTable = sizeof(g_pFormatTable) / sizeof(g_pFormatTable[0]);


//
// AsText
//
// Return the media type as a text string. Will place szAfterMajor after
// the text string for the major type and szAfterOthers after all other
// string apart from the last one.
//
void CTextMediaType::AsText(LPTSTR szType, unsigned int iLen, LPTSTR szAfterMajor, LPTSTR szAfterOthers, LPTSTR szAtEnd) {

    ASSERT(szType);

    //
    // Convert Majortype to string
    //
    TCHAR szMajorType[100];
    UINT  iMajorType = 100;

    CLSID2String(szMajorType, iMajorType, &majortype, g_pMajorTable, g_iMajorTable);

    //
    // Convert Subtype to string
    //
    TCHAR szSubType[100];
    UINT  iSubType = 100;
    CLSID2String(szSubType, iSubType, &subtype, g_pSubTable, g_iSubTable);

    //
    // Convert Format to string
    TCHAR szFormat[300];
    UINT  iFormat = 300;
    Format2String(szFormat, iFormat, FormatType(), Format(), FormatLength());

    //
    // Obtain the strings preceeding the Major Type, Sub Type and Format.
    //
    TCHAR szPreMajor[50];
    TCHAR szPreSub[50];
    TCHAR szPreFormat[50];

    LoadString(g_hInst, IDS_PREMAJOR, szPreMajor, 50);
    LoadString(g_hInst, IDS_PRESUB, szPreSub, 50);
    LoadString(g_hInst, IDS_PREFORMAT, szPreFormat, 50);

    _sntprintf(szType, iLen, TEXT("%s%s%s%s%s%s%s%s%s"),
               szPreMajor,  szMajorType, szAfterMajor,
               szPreSub,    szSubType, szAfterOthers,
               szPreFormat, szFormat, szAtEnd);
}

//
// CLSID2String
//
// Given a CLSID and a table which binds CLSIDs to string resource IDs,
// we find the string for a given CLSID and place it in szBuffer.
// If none of the CLSIDs match, we use the first entry in the table.
//
void CTextMediaType::CLSID2String(LPTSTR szBuffer, UINT iLength, const GUID* pGuid, TableEntry pTable[], ULONG iTable)
{
    for (ULONG index = 1; index < iTable; index++) {
        if (IsEqualGUID(*pGuid, *pTable[index].guid)) {
            LoadString(g_hInst, pTable[index].stringID, szBuffer, iLength);

            return;
        }
    }

    // no match
    LoadString(g_hInst, pTable[0].stringID, szBuffer, iLength);
}

//
// Format2String
//
// Converts a format block to a string
//
void CTextMediaType::Format2String(LPTSTR szBuffer, UINT iLength, const GUID* pFormatType, BYTE* pFormat, ULONG lFormatLength)
{
    //
    // Get the name of the format
    //
    TCHAR szName[50];
    UINT iName = 50;
    CLSID2String(szName, iName, pFormatType, g_pFormatTable, g_iFormatTable);

    if (pFormat) {
        //
        // Video Format
        //
        if (IsEqualGUID(*pFormatType, FORMAT_VideoInfo) ||
            IsEqualGUID(*pFormatType, FORMAT_MPEGVideo)) {

            VIDEOINFO * pVideoFormat = (VIDEOINFO *) pFormat;
            DbgLog((LOG_TRACE, 0, TEXT("Width = %d"), pVideoFormat->bmiHeader.biWidth));

            _sntprintf(szBuffer, iLength,
                        TEXT("%4.4hs %dx%d, %d bits\n")
                        TEXT("rcSrc=(%d,%d,%d,%d)\n")
                        TEXT("rcDst=(%d,%d,%d,%d)")
                       , (pVideoFormat->bmiHeader.biCompression == 0) ? "RGB" :
                            ((pVideoFormat->bmiHeader.biCompression == BI_BITFIELDS) ? "BITF" :
                            (LPSTR) &pVideoFormat->bmiHeader.biCompression )
                       , pVideoFormat->bmiHeader.biWidth
                       , pVideoFormat->bmiHeader.biHeight
                       , pVideoFormat->bmiHeader.biBitCount
                       , pVideoFormat->rcSource.left
                       , pVideoFormat->rcSource.top
                       , pVideoFormat->rcSource.right
                       , pVideoFormat->rcSource.bottom
                       , pVideoFormat->rcTarget.left
                       , pVideoFormat->rcTarget.top
                       , pVideoFormat->rcTarget.right
                       , pVideoFormat->rcTarget.bottom
                      );

            return;
        }


        if (IsEqualGUID(*pFormatType, FORMAT_VideoInfo2)) {

            VIDEOINFOHEADER2 * pVideoFormat = (VIDEOINFOHEADER2 *) pFormat;

            TCHAR* szInterlaced = TEXT("Frames");

            const DWORD dwNIBob = (AMINTERLACE_IsInterlaced |
                                   AMINTERLACE_1FieldPerSample |
                                   AMINTERLACE_DisplayModeBobOnly);

            const DWORD dwWeave = (AMINTERLACE_IsInterlaced |
                                   AMINTERLACE_DisplayModeWeaveOnly);

            const DWORD dwIBobOnly = (AMINTERLACE_IsInterlaced |
                                      AMINTERLACE_DisplayModeBobOnly);

            const DWORD dwIBobWeave = (AMINTERLACE_IsInterlaced |
                                       AMINTERLACE_FieldPatBothRegular |
                                       AMINTERLACE_DisplayModeBobOrWeave);


            if ((pVideoFormat->dwInterlaceFlags & dwNIBob) == dwNIBob) {
                 szInterlaced = TEXT("Non-Interleaved Bob");
            }
            else if ((pVideoFormat->dwInterlaceFlags & dwIBobWeave) == dwIBobWeave) {
                 szInterlaced = TEXT("Interleaved Bob or Weave");
            }
            else if ((pVideoFormat->dwInterlaceFlags & dwWeave) == dwWeave) {
                 szInterlaced = TEXT("Weave Only");
            }
            else if ((pVideoFormat->dwInterlaceFlags & dwIBobOnly) == dwIBobOnly) {
                 szInterlaced = TEXT("Interleaved Bob Only");
            }

            _sntprintf(szBuffer, iLength,
                        TEXT("%4.4hs %dx%d, %d bits,\n")
                        TEXT("Aspect Ratio: %dx%d,\n")
                        TEXT("Interlace format: %s\n")
                        TEXT("rcSrc=(%d,%d,%d,%d)\n")
                        TEXT("rcDst=(%d,%d,%d,%d)")
                       , (pVideoFormat->bmiHeader.biCompression == 0) ? "RGB" :
                            ((pVideoFormat->bmiHeader.biCompression == BI_BITFIELDS) ? "BITF" :
                            (LPSTR) &pVideoFormat->bmiHeader.biCompression )
                       , pVideoFormat->bmiHeader.biWidth
                       , pVideoFormat->bmiHeader.biHeight
                       , pVideoFormat->bmiHeader.biBitCount
                       , pVideoFormat->dwPictAspectRatioX
                       , pVideoFormat->dwPictAspectRatioY
                       , szInterlaced
                       , pVideoFormat->rcSource.left
                       , pVideoFormat->rcSource.top
                       , pVideoFormat->rcSource.right
                       , pVideoFormat->rcSource.bottom
                       , pVideoFormat->rcTarget.left
                       , pVideoFormat->rcTarget.top
                       , pVideoFormat->rcTarget.right
                       , pVideoFormat->rcTarget.bottom
                      );

            return;
        }
        //
        // Audio Format
        //
        if (IsEqualGUID(*pFormatType, FORMAT_WaveFormatEx)) {
            WAVEFORMATEX *pWaveFormat = (WAVEFORMATEX *) pFormat;

            // !!! use ACM to get format type name?
            _sntprintf(szBuffer, iLength, TEXT("%s: %.3f KHz %d bit %s ")
                       , szName
                       , (double) pWaveFormat->nSamplesPerSec / 1000.0
                       , pWaveFormat->wBitsPerSample
                       , pWaveFormat->nChannels == 1 ? TEXT("mono") : TEXT("stereo")
                      );

            return;
        }

        if (IsEqualGUID (*pFormatType,FORMAT_DvInfo )) {
            DVINFO *pDvInfo = (DVINFO *) pFormat;
            BYTE bSystem,bBcsys, bDisp ,bQU , bSamFreq;
            TCHAR szSystem[15],szQU [15], szAR[32] , szSamFreq[10];

            //Obtaining relevant fields from the Dvinfo structure

            bSystem = (BYTE) (( pDvInfo->dwDVAAuxSrc & 0x00200000) >> 21);  //Indicate Pal / Ntsc
            bBcsys  = (BYTE) (( pDvInfo->dwDVVAuxCtl & 0x00030000) >> 16);  //BroadCast System
            bDisp   = (BYTE) (( pDvInfo->dwDVVAuxCtl & 0x00000700) >> 8);   //Display Select mode
            bQU     = (BYTE) (( pDvInfo->dwDVAAuxSrc & 0x07000000) >> 24);  //Quantization
            bSamFreq= (BYTE) (( pDvInfo->dwDVAAuxSrc & 0x38000000) >> 27);  //Sampling Frequency


            // Determine whether Pal or NTSC
            if (bSystem)
                _tcscpy (szSystem ,TEXT("PAL"));
            else
                _tcscpy (szSystem ,TEXT("NTSC"));

            // Obtain Audio Format
            switch (bQU) {
            case 0:
                _tcscpy (szQU  ,TEXT ("16 bits"));
                break;
            case 1:
                _tcscpy (szQU  ,TEXT ("12 bits"));
                break;
            case 2:
                _tcscpy (szQU  ,TEXT ("20 bits"));
                break;
            default:
                _tcscpy (szQU  ,TEXT ("Not Defined"));
            }


            // Determine aspect ratio
            switch (bBcsys) {
            case 0:
                switch (bDisp) {
                case 0:
                    _tcscpy (szAR   ,TEXT ("4:3 full format"));
                    break;
                case 1:
                    _tcscpy (szAR   ,TEXT ("16:9 letter box centre"));
                    break;
                case 2:
                    _tcscpy (szAR   ,TEXT ("16:9 full format (squeeze)"));
                    break;
                default:
                    _tcscpy (szAR   ,TEXT ("Not Defined"));
                }
                break;

            case 1:
                switch (bDisp) {
                case 0:
                    _tcscpy (szAR   ,TEXT ("4:3 full format"));
                    break;
                case 1:
                    _tcscpy (szAR   ,TEXT ("14:9 letter box centre"));
                    break;
                case 2:
                    _tcscpy (szAR   ,TEXT ("14:9 letter box top"));
                    break;
                case 6:
                    _tcscpy (szAR   ,TEXT ("14:9 full format centre"));
                    break;
                case 3:
                    _tcscpy (szAR   ,TEXT ("16:9 letter box centre"));
                    break;
                case 4:
                    _tcscpy (szAR   ,TEXT ("16:9 letter box top"));
                    break;
                case 5:
                    _tcscpy (szAR   ,TEXT ("16:9 letter box centre"));
                    break;
                case 7:
                    _tcscpy (szAR   ,TEXT ("16:9 full format (anamorphic)"));
                }
                break;
            default:
                _tcscpy (szAR   ,TEXT ("Not Defined"));

            }

            //Unable to use this because the limit to be shown in the property page is three lines
            // Will enable it after fixing that problem

            /*  //Determine Sampling Frequency
                switch (bSamFreq)
                {
                case 0:
                        _tcscpy (szSamFreq  ,TEXT ("48 kHz"));
                        break;
                case 1:
                        _tcscpy (szSamFreq  ,TEXT ("44.1 kHz"));
                        break;
                case 2:
                        _tcscpy (szSamFreq  ,TEXT ("32 kHz"));
                        break;
                default:
                        _tcscpy (szSamFreq  ,TEXT ("Undefined"));

                }

        */
            _sntprintf(szBuffer, iLength, TEXT ("DV Stream \nAudio Format: %s \n %s  Aspect Ratio: %s"),
                       szQU, szSystem, szAR);
            return;

        }
    }

    _sntprintf(szBuffer, iLength, TEXT("%s"), szName);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\vmrprop\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by vmrprop.rc
//
#define IDD_FILTERCONFIG                105
#define IDS_TITLE_FILTERCONFIG          106
#define IDC_NUMPINS                     1000
#define IDC_PINSPIN                     1001
#define IDC_PINSELECT                   1007
#define IDC_YPOS_SLIDER                 1008
#define IDC_XPOS_SLIDER                 1009
#define IDC_XPOS                        1010
#define IDC_YPOS                        1011
#define IDC_XSIZE                       1012
#define IDC_YSIZE                       1013
#define IDC_ALPHA                       1014
#define IDC_XPOS_STATIC                 1015
#define IDC_YPOS_STATIC                 1016
#define IDC_BUTTON1                     1017
#define IDC_XSIZE_SLIDER                1018
#define IDC_YSIZE_SLIDER                1019
#define IDC_ALPHA_SLIDER                1020
#define IDC_SNAPSHOT			1021 
#define IDC_STATIC			-1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1018
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\vmrprop\vmrprop.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 2001  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//----------------------------------------------------------------------------
// VMRProp.h
//
//  Created 3/18/2001
//  Author: Steve Rowe [StRowe]
//
//----------------------------------------------------------------------------


#ifndef __VMRPROP__
#define __VMRPROP__

// {A2CA6D57-BE10-45e0-9B81-7523681EC278}
DEFINE_GUID(CLSID_VMRFilterConfigProp, 
0xa2ca6d57, 0xbe10, 0x45e0, 0x9b, 0x81, 0x75, 0x23, 0x68, 0x1e, 0xc2, 0x78);

class CVMRFilterConfigProp : public CBasePropertyPage
{  
public:
    
    static CUnknown * WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT *phr);
    
private:
    void CaptureCurrentImage(void);
    bool SaveCapturedImage(TCHAR* szFile, BYTE* lpCurrImage);
	HRESULT UpdateMixingData(DWORD dwStreamID);
	void UpdatePinPos(DWORD dwStreamID);
	void UpdatePinAlpha(DWORD dwStreamID);
	void OnHScroll(HWND hwnd, HWND hwndCtl, UINT code, int pos);
	void InitConfigControls(DWORD pin);
	
    CVMRFilterConfigProp(LPUNKNOWN pUnk, HRESULT *phr);

    void OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify);
    BOOL OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam);

    INT_PTR OnReceiveMessage(HWND hwnd,UINT uMsg,WPARAM wParam,LPARAM lParam);
	HRESULT OnConnect(IUnknown *pUnknown);
    HRESULT OnDisconnect();
    HRESULT OnActivate();
    HRESULT OnApplyChanges();
    void SetDirty();

    // IVMRFilterConfig interface
    IVMRFilterConfig *		m_pIFilterConfig;
	IVMRMixerControl *		m_pIMixerControl;
	IMediaEventSink *		m_pEventSink;
    DWORD					m_dwNumPins;
	DWORD					m_CurPin;
	FLOAT					m_XPos;
	FLOAT					m_YPos;
	FLOAT					m_XSize;
	FLOAT					m_YSize;
	FLOAT					m_Alpha;

};  // class COMPinConfigProperties


#endif // __VMRPROP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\measure\measure.cpp ===
// Copyright (c) 1994 - 1996  Microsoft Corporation.  All Rights Reserved.

#pragma warning(disable: 4201 4514)

/*
    It is very easy to fill large amounts of storage with data
    (e.g. 5 filters in a graph,
          5 interesting start/stop times per sample each = 10 events
          30 samples per second
          16 bytes per sample (8 bytes time, 8 bytes to identify incident)
       = 24KB/sec)

    this means that even a quite large buffer (I have in mind 64KB) will
    overflow after a few seconds.  Writing it out to a file is completely out
    (don't want to take page faults in the middle of things - even writing to
    memory carries some risk).

    I want to have two kinds of data available at the end of the run:
    1. A record of what actually happened (i.e. what the sequence of events
       actually was for at least a few frames)
    2. Statistical information (e.g. for inter-frame video times I would like
       to see number, average, standard deviation, greatest, smallest.

    The volume of information that the actual sequence of events generates means
    that it may only hold a second or two of information.  The statistical
    information should take in the whole run.  This means that information will
    be logged two ways.

    For the detailed record I log
        <incident, type, time>
    in a circular buffer and regularly over-write the oldest information.
    For the statistical information I record the informatin in an array, where
    the incident identifier is the index.  the array elements hold
        <Number of readings, sum, sum of squares, largest, smallest, latest>
    The readings are differences (start..next or start..stop).  This means that
    the actual number of Noted events will be one more than the number of
    "readings", whereas for Start-Stop events they will be equal.  To fix this,
    the number of readings is articifially initialised to -1.  If Start sees
    this number it resets it to 0.

    Times will be in tens of microseconds (this allows up to about 1 3/4 hrs)

    The statistics array will have room for up to 128 types of incident (this is
    4K - i.e. one page.  I hope this will ensure that it never gets
    paged out and so causes negligible overhead.
*/
#include <Windows.h>        // BOOL etc
#include <limits.h>         // for INTT_MAX
#include <math.h>           // for sqrt
#include <stdio.h>          // for sprintf

#include "Measure.h"
#include "Perf.h"           // ultra fast QueryPerformanceCounter for pentium

// forwards


enum {START, STOP, NOTE, RESET, INTGR, PAUSE, RUN};  // values for Type field

typedef struct {
    LONGLONG Time;         // microsec since class construction
    int      Id;
    int      Type;
    int      n;            // the integer for Msr_Integer
} LogDatum;


typedef struct {
    LONGLONG Latest;       // microsec since class construction
    LONGLONG SumSq;        // sum of squares of entries for this incident
    int      Largest;      // tenmicrosec
    int      Smallest;     // tenmicrosec
    int      Sum;          // sum of entries for this incident
    int      Number;       // number of entries for this incident
                           // for Start/Stop it counts the stops
                           // for Note it counts the intervals (Number of Notes-1)
    int      iType;        // STOP, NOTE, INTGR
} Stat;


#define MAXLOG 4096
static BOOL bInitOk;          // Set to true once initialised
static LogDatum Log[MAXLOG];  // 64K circular buffer
static int NextLog;           // Next slot to overwrite in the log buffer.
static BOOL bFull;            // TRUE => buffer has wrapped at least once.
static BOOL bPaused;          // TRUE => do not record.  No log, no stats.

#define MAXSTAT 128
static Stat StatBuffer[MAXSTAT];
static int NextStat;             // next free slot in StatBuffer.

static LPTSTR Incidents[MAXSTAT];// Names of incidents
static LONGLONG QPFreq;
static LONGLONG QPStart;         // base time in perf counts
#ifdef DEBUG
static LONGLONG tLast;           // last time - looks for going backwards
#endif

static CRITICAL_SECTION CSMeasure;         // Controls access to list

// set it to 100000 for 10 microsecs
// if you fiddle with it then you have to rewrite Format.
#define UNIT 100000

// Times are printed as 9 digits - this means that we can go
// up to 9,999.999,99 secs or about 2 and 3/4 hours.


// ASSERT(condition, msg) e.g. ASSERT(x>1, "Too many xs");
#define ASSERT(_cond_, _msg_)                                         \
        if (!(_cond_)) Assert(_msg_, __FILE__, __LINE__)

// print out debug message box
void Assert( const CHAR *pText
           , const CHAR *pFile
           , INT        iLine
           )
{
    CHAR Buffer[200];

    sprintf(Buffer, "%s\nAt line %d file %s"
           , pText, iLine, pFile);

    INT MsgId = MessageBox( NULL, Buffer, TEXT("ASSERT Failed")
                          , MB_SYSTEMMODAL |MB_ICONHAND |MB_ABORTRETRYIGNORE);
    switch (MsgId)
    {
        case IDABORT:           /* Kill the application */

            FatalAppExit(FALSE, TEXT("Application terminated"));
            break;

        case IDRETRY:           /* Break into the debugger */
            DebugBreak();
            break;

        case IDIGNORE:          /* Ignore assertion continue executing */
            break;
        }
} // Assert



//=============================================================================
//
// Init
//
// Call this first.
//=============================================================================
void WINAPI Msr_Init()
{
    // I would like this to be idempotent - that is, harmless if it
    // gets called more than once.  However that's not 100% possible
    // At least we should be OK so long as it's not re-entered.

    if (!bInitOk) {
        bInitOk = TRUE;
        InitializeCriticalSection(&CSMeasure);
        NextLog = 0;
        bFull = FALSE;
        NextStat = 0;
        LARGE_INTEGER li;
        QUERY_PERFORMANCE_FREQUENCY(&li);
        QPFreq = li.QuadPart;
        QUERY_PERFORMANCE_COUNTER(&li);
        QPStart = li.QuadPart;
#ifdef DEBUG
        tLast = 0L;
#endif

        Msr_Register("Scratch pad");
    }
} // Msr_Init  "constructor"



//=============================================================================
//
// ResetAll
//
// Do a Reset on every Incident that has been registered.
//=============================================================================
void WINAPI ResetAll()
{
    EnterCriticalSection(&CSMeasure);
    int i;
    for (i = 0; i<NextStat; ++i) {
        Msr_Reset(i);
    }
    LeaveCriticalSection(&CSMeasure);
} // ResetAll



//=============================================================================
//
// Pause
//
// Pause it all
//=============================================================================
void Pause()
{
    if (!bInitOk) Msr_Init();
    EnterCriticalSection(&CSMeasure);

    bPaused = TRUE;

    // log a PAUSE event for this id.
    LARGE_INTEGER Time;
    QUERY_PERFORMANCE_COUNTER(&Time);

    // Get time in 10muSec from start - this gets the number small
    // it's OK for nearly 6 hrs then an int overflows
    LONGLONG Tim = (Time.QuadPart-QPStart) * UNIT / QPFreq;

    Log[NextLog].Time = Tim;
    Log[NextLog].Type = PAUSE;
    Log[NextLog].Id   = -1;
    ++NextLog;
    if (NextLog==MAXLOG) {
        NextLog = 0;
        bFull = TRUE;
    }

    LeaveCriticalSection(&CSMeasure);

} // Pause



//=============================================================================
//
// Run
//
// Set it all running again
//=============================================================================
void Run()
{

    if (!bInitOk) Msr_Init();
    EnterCriticalSection(&CSMeasure);

    bPaused = FALSE;

    // log a RUN event for this id.
    LARGE_INTEGER Time;
    QUERY_PERFORMANCE_COUNTER(&Time);

    // Get time in 10muSec from start - this gets the number small
    // it's OK for nearly 6 hrs then an int overflows
    LONGLONG Tim = (Time.QuadPart-QPStart) * UNIT / QPFreq;

    Log[NextLog].Time = Tim;
    Log[NextLog].Type = RUN;
    Log[NextLog].Id   = -1;
    ++NextLog;
    if (NextLog==MAXLOG) {
        NextLog = 0;
        bFull = TRUE;
    }

    LeaveCriticalSection(&CSMeasure);

} // Run



//=============================================================================
//
// Msr_Control
//
// Do ResetAll, set bPaused to FALSE or TRUE according to iAction
//=============================================================================
void WINAPI Msr_Control(int iAction)
{
   switch (iAction) {
      case MSR_RESET_ALL:
          ResetAll();
          break;
      case MSR_RUN:
          Run();
          break;
      case MSR_PAUSE:
          Pause();
          break;
   }
} // Msr_Control



//=============================================================================
//
// Terminate
//
// Call this last.  It frees storage for names of incidents.
//=============================================================================
void WINAPI Msr_Terminate()
{
    int i;
    if (bInitOk) {
        EnterCriticalSection(&CSMeasure);
        for (i = 0; i<NextStat; ++i) {
            free(Incidents[i]);
        }
        bInitOk = FALSE;
        LeaveCriticalSection(&CSMeasure);
        DeleteCriticalSection(&CSMeasure);
    }
} // Msr_Terminate  "~Measure"



//=============================================================================
//
// InitIncident
//
// Reset the statistical counters for this incident.
//=============================================================================
void InitIncident(int Id)
{
    StatBuffer[Id].Latest = -1;      // recogniseably odd (see STOP)
    StatBuffer[Id].Largest = 0;
    StatBuffer[Id].Smallest = INT_MAX;
    StatBuffer[Id].Sum = 0;
    StatBuffer[Id].SumSq = 0;
    StatBuffer[Id].Number = -1;
    StatBuffer[Id].iType = NOTE;     // reset on first Start for Start/Stop
                                     // reset on first Integer for INTGR

} // InitIncident


//=============================================================================
//
// Register
//
// Register a new kind of incident.  The id that is returned can then be used
// on calls to Start, Stop and Note to record the occurrences of these incidents
// so that statistical performance information can be dumped later.
//=============================================================================
int Msr_Register(LPTSTR Incident)
{

    if (!bInitOk) {
        Msr_Init();
    }
    // it's now safe to enter the critical section as it will be there!
    EnterCriticalSection(&CSMeasure);

    int i;
    for (i = 0; i<NextStat; ++i) {
        if (0==strcmp(Incidents[i],Incident) ) {
            // Attempting to re-register the same name.
            // Possible actions
            // 1. ASSERT - that just causes trouble.
            // 2. Register it as a new incident.  That produced quartz bug 1
            // 3. Hand the old number back and reset it.
            //    Msr_Reset(i); - possible, but not today.
            // 4. Hand the old number back and just keep going.

            LeaveCriticalSection(&CSMeasure);
            return i;
        }
    }
    if (NextStat==MAXSTAT-1) {
        Assert("Too many types of incident\n(ignore is safe)", __FILE__, __LINE__);
        LeaveCriticalSection(&CSMeasure);
        return -1;
    }

    Incidents[NextStat] = (LPTSTR)malloc(strlen(Incident)+1);
    strcpy(Incidents[NextStat], Incident);

    InitIncident(NextStat);

    LeaveCriticalSection(&CSMeasure);
    return NextStat++;

} // Msr_Register



//=============================================================================
//
// Reset
//
// Reset the statistical counters for this incident.
// Log that we did it.
//=============================================================================
void WINAPI Msr_Reset(int Id)
{
    if (!bInitOk) {
        Msr_Init();
    }
    // it's now safe to enter the critical section as it will be there!

    EnterCriticalSection(&CSMeasure);

    // log a RESET event for this id.
    LARGE_INTEGER Time;
    QUERY_PERFORMANCE_COUNTER(&Time);

    // Get time in 10muSec from start - this gets the number small
    // it's OK for nearly 6 hrs then an int overflows
    LONGLONG Tim = (Time.QuadPart-QPStart) * UNIT / QPFreq;

    Log[NextLog].Time = Tim;
    Log[NextLog].Type = RESET;
    Log[NextLog].Id   = Id;
    ++NextLog;
    if (NextLog==MAXLOG) {
        NextLog = 0;
        bFull = TRUE;
    }

    InitIncident(Id);

    LeaveCriticalSection(&CSMeasure);

} // Msr_Reset


//=============================================================================
//
// Msr_Start
//
// Record the start time of the event with registered id Id.
// Add it to the circular Log and record the time in StatBuffer.
// Do not update the statistical information, that happens when Stop is called.
//=============================================================================
void WINAPI Msr_Start(int Id)
{
    if (bPaused) return;

    // This is performance critical.  Keep all array subscripting
    // together and with any luck the compiler will only calculate the
    // offset once.  Avoid subroutine calls unless they are definitely inline.

    // An id of -1 is the standard rotten registration one.
    // We already did an assert for that - so let it go.
    if (Id<-1 || Id>=NextStat) {
        // ASSERT(!"Performance logging with bad Id");
        return;
    }
    EnterCriticalSection(&CSMeasure);
    LARGE_INTEGER Time;
    QUERY_PERFORMANCE_COUNTER(&Time);

    LONGLONG Tim = (Time.QuadPart-QPStart) * UNIT / QPFreq;
#ifdef DEBUG
    ASSERT(Tim>=tLast, "Time is going backwards!!");  tLast = Tim;
#endif
    Log[NextLog].Time = Tim;
    Log[NextLog].Type = START;
    Log[NextLog].Id   = Id;
    ++NextLog;
    if (NextLog==MAXLOG) {
        NextLog = 0;
        bFull = TRUE;
    }

    StatBuffer[Id].Latest = Tim;

    if (StatBuffer[Id].Number == -1) {
        StatBuffer[Id].Number = 0;
        StatBuffer[Id].iType = STOP;
    }
    LeaveCriticalSection(&CSMeasure);

} // Msr_Start


//=============================================================================
//
// Msr_Stop
//
// Record the stop time of the event with registered id Id.
// Add it to the circular Log and
// add (StopTime-StartTime) to the statistical record StatBuffer.
//=============================================================================
void WINAPI Msr_Stop(int Id)
{
    if (bPaused) return;

    // This is performance critical.  Keep all array subscripting
    // together and with any luck the compiler will only calculate the
    // offset once.  Avoid subroutine calls unless they are definitely inline.

    EnterCriticalSection(&CSMeasure);
    LARGE_INTEGER Time;
    QUERY_PERFORMANCE_COUNTER(&Time);

    // An id of -1 is the standard rotten registration one.
    // We already did an assert for that - so let it go.
    if (Id<-1 || Id>=NextStat) {
        // ASSERT(!"Performance logging with bad Id");
        return;
    }

    // Get time in 10muSec from start - this gets the number small
    // it's OK for nearly 6 hrs, then an int overflows
    LONGLONG Tim = (Time.QuadPart-QPStart) * UNIT / QPFreq;
#ifdef DEBUG
    ASSERT(Tim>=tLast, "Time is going backwards!!");  tLast = Tim;
#endif
    Log[NextLog].Time = Tim;
    Log[NextLog].Type = STOP;
    Log[NextLog].Id   = Id;
    ++NextLog;
    if (NextLog==MAXLOG) {
        NextLog = 0;
        bFull = TRUE;
    }

    if (StatBuffer[Id].Latest!=-1) {
        int t = (int)(Tim - StatBuffer[Id].Latest);     // convert to delta
        // this is now OK for almost 6hrs since the last Start of this quantity.

        if (t > StatBuffer[Id].Largest) StatBuffer[Id].Largest = t;
        if (t < StatBuffer[Id].Smallest) StatBuffer[Id].Smallest = t;
        StatBuffer[Id].Sum += t;
        LONGLONG lt = t;
        StatBuffer[Id].SumSq += lt*lt;
        ++StatBuffer[Id].Number;
    }
    LeaveCriticalSection(&CSMeasure);

} // Msr_Stop


//=============================================================================
//
// Msr_Note
//
// Record the event with registered id Id.  Add it to the circular Log and
// add (ThisTime-PreviousTime) to the statistical record StatBuffer
//=============================================================================
void WINAPI Msr_Note(int Id)
{
    if (bPaused) return;

    // This is performance critical.  Keep all array subscripting
    // together and with any luck the compiler will only calculate the
    // offset once.  Avoid subroutine calls unless they are definitely inline.

    // An id of -1 is the standard rotten registration one.
    // We already did an assert for that - so let it go.
    if (Id<-1 || Id>=NextStat) {
        // ASSERT(!"Performance logging with bad Id");
        return;
    }

    EnterCriticalSection(&CSMeasure);
    LARGE_INTEGER Time;
    QUERY_PERFORMANCE_COUNTER(&Time);

    // Get time in 10muSec from start - this gets the number small
    // it's OK for nearly 6 hrs then an int overflows
    LONGLONG Tim = (Time.QuadPart-QPStart) * UNIT / QPFreq;
#ifdef DEBUG
    ASSERT(Tim>=tLast, "Time is going backwards!!");  tLast = Tim;
#endif
    Log[NextLog].Time = Tim;
    Log[NextLog].Type = NOTE;
    Log[NextLog].Id   = Id;
    ++NextLog;
    if (NextLog==MAXLOG) {
        NextLog = 0;
        bFull = TRUE;
    }
    int t = (int)(Tim - StatBuffer[Id].Latest);     // convert to delta
    // this is now OK for nearly 6 hrs since the last Note of this quantity.

    StatBuffer[Id].Latest = Tim;
    ++StatBuffer[Id].Number;
    if (StatBuffer[Id].Number>0) {
        if (t > StatBuffer[Id].Largest) StatBuffer[Id].Largest = t;
        if (t < StatBuffer[Id].Smallest) StatBuffer[Id].Smallest = t;
        StatBuffer[Id].Sum += (int)t;
        LONGLONG lt = t;
        StatBuffer[Id].SumSq += lt*lt;
    }
    LeaveCriticalSection(&CSMeasure);

} // Msr_Note


//=============================================================================
//
// Msr_Integer
//
// Record the event with registered id Id.  Add it to the circular Log and
// add (ThisTime-PreviousTime) to the statistical record StatBuffer
//=============================================================================
void WINAPI Msr_Integer(int Id, int n)
{
    if (bPaused) return;

    // This is performance critical.  Keep all array subscripting
    // together and with any luck the compiler will only calculate the
    // offset once.  Avoid subroutine calls unless they are definitely inline.

    // An id of -1 is the standard rotten registration one.
    // We already did an assert for that - so let it go.
    if (Id<-1 || Id>=NextStat) {
        // ASSERT(!"Performance logging with bad Id");
        return;
    }

    EnterCriticalSection(&CSMeasure);
    LARGE_INTEGER Time;
    QUERY_PERFORMANCE_COUNTER(&Time);

    // Get time in 10muSec from start - this gets the number small
    // it's OK for nearly 6 hrs then an int overflows
    LONGLONG Tim = (Time.QuadPart-QPStart) * UNIT / QPFreq;
#ifdef DEBUG
    ASSERT(Tim>=tLast, "Time is going backwards!!");  tLast = Tim;
#endif
    Log[NextLog].Time = Tim;
    Log[NextLog].Type = INTGR;
    Log[NextLog].Id   = Id;
    Log[NextLog].n    = n;
    ++NextLog;
    if (NextLog==MAXLOG) {
        NextLog = 0;
        bFull = TRUE;
    }

    // StatBuffer[Id].Latest = garbage for Intgr

    if (StatBuffer[Id].Number == -1) {
        StatBuffer[Id].Number = 0;
        StatBuffer[Id].iType = INTGR;
    }
    ++StatBuffer[Id].Number;
    if (n > StatBuffer[Id].Largest) StatBuffer[Id].Largest = n;
    if (n < StatBuffer[Id].Smallest) StatBuffer[Id].Smallest = n;
    StatBuffer[Id].Sum += (int)n;
    LONGLONG ln = n;
    StatBuffer[Id].SumSq += ln*ln;

    LeaveCriticalSection(&CSMeasure);

} // Msr_Integer


//=============================================================================
//
// TypeName
//
// Convert the type code into readable format
//=============================================================================
const LPTSTR TypeName(int Type)
{
    switch(Type){
    case START: return "START";
    case STOP:  return "STOP ";
    case NOTE:  return "NOTE ";
    case RESET: return "RESET";
    case INTGR: return "INTGR";
    case PAUSE: return "PAUSE";
    case RUN:   return "RUN  ";
    default:    return "DUNNO";
    }

} // TypeName


//==============================================================================
//
// Format
//
// I haven't found any way to get sprintf to format integers as
//      1,234.567.89 - so this does it.  (that's 12 spaces)
// All times are in tens of microsecs - so they are formatted as
// n,nnn.mmm,mm - this uses 12 spaces.
// The result that it returns points to Buff - it doesn't allocate any storage
// i must be positive.  Negative numbers are not handled (the pain of the floating
// minus sign is the reason - i.e. "     -12,345" not "-     12,345"
//==============================================================================
LPTSTR Format( LPTSTR Buff, int i)
{
    if (i<0) {
        sprintf(Buff, "    -.      ");
        return Buff;
    }
    BOOL bStarted;  // TRUE means that some left part of the number has been
                    // formatted and so we must continue with zeros not spaces
    if (i>999999999) {
        sprintf(Buff, " ***large***");
        return Buff;
    }

    if (i>99999999) {
        sprintf(Buff, "%1d,", i/100000000);
        i = i%100000000;
        bStarted = TRUE;
    } else {
        sprintf(Buff, "  ");
        bStarted = FALSE;
    }

    if (bStarted) {
        sprintf(Buff, "%s%03d.", Buff, i/100000);
        i = i%100000;
    } else {
        sprintf(Buff, "%s%3d.", Buff,i/100000);
        i = i%100000;
    }

    sprintf(Buff, "%s%03d,%02d", Buff, i/100, i%100);

    return Buff;
} // Format


//=============================================================================
//
// WriteOut
//
// If hFile==NULL then write str to debug output, else write it to file hFile
//
//=============================================================================
void WriteOut(HANDLE hFile, LPSTR str)
{
    if (hFile==NULL) {
        OutputDebugString(str);
    } else {
        DWORD dw;
        WriteFile(hFile, str, lstrlen(str), &dw, NULL);
    }
} // WriteOut


typedef LONGLONG longlongarray[MAXSTAT];


//=============================================================================
//
// WriteLogEntry
//
// If hFile==NULL then write to debug output, else write to file hFile
// write the ith entry of Log in a readable format
//
//=============================================================================
void WriteLogEntry(HANDLE hFile, int i, longlongarray &Prev)
{
    // We have the problem of printing LONGLONGs and wsprintf (26/6/95)
    // doesn't like them - found out the hard way - Laurie.
    char Buffer[200];
    char s1[20];
    char s2[20];

    int Delta;  // time since previous interesting incident

    switch(Log[i].Type) {
       case START:
          Prev[Log[i].Id] = Log[i].Time;
          Delta = -2;
          sprintf( Buffer, "%s  %5s %s : %s\r\n"
                 , Format(s1,(int)(Log[i].Time))
                 , TypeName(Log[i].Type)
                 , Format(s2, Delta)
                 , Incidents[Log[i].Id]
                 );
          break;
       case STOP:
          if (Prev[Log[i].Id]==-1) {
              Delta = -2;
          } else {
              Delta = (int)(Log[i].Time - Prev[Log[i].Id]);
          }
          Prev[Log[i].Id] = -1;
          sprintf( Buffer, "%s  %5s %s : %s\r\n"
                 , Format(s1,(int)(Log[i].Time))
                 , TypeName(Log[i].Type)
                 , Format(s2, Delta)
                 , Incidents[Log[i].Id]
                 );
          break;
       case NOTE:
          if (Prev[Log[i].Id]==-1) {
              Delta = -2;
          } else {
              Delta = (int)(Log[i].Time - Prev[Log[i].Id]);
          }
          Prev[Log[i].Id] = Log[i].Time;
          sprintf( Buffer, "%s  %5s %s : %s\r\n"
                 , Format(s1,(int)(Log[i].Time))
                 , TypeName(Log[i].Type)
                 , Format(s2, Delta)
                 , Incidents[Log[i].Id]
                 );
          break;
       case INTGR:
          sprintf( Buffer, "%s  %5s %12d : %s\r\n"
                 , Format(s1,(int)(Log[i].Time))
                 , TypeName(Log[i].Type)
                 , Log[i].n
                 , Incidents[Log[i].Id]
                 );
          break;
       case RESET:       // the delta for a reset will be length of run
       case PAUSE:
       case RUN:
          if ((Log[i].Id==-1)||(Prev[Log[i].Id]==-1)) {
              Delta = (int)(Log[i].Time);  // = time from start
          } else {
              Delta = (int)(Log[i].Time - Prev[Log[i].Id]);
          }
          if (Log[i].Id!=-1) Prev[Log[i].Id] = Log[i].Time;
          sprintf( Buffer, "%s  %5s %s : %s\r\n"
                 , Format(s1,(int)(Log[i].Time))
                 , TypeName(Log[i].Type)
                 , Format(s2, Delta)
                 , Incidents[Log[i].Id]
                 );
          break;
    }

    WriteOut(hFile, Buffer);

} // WriteLogEntry


//=============================================================================
//
// WriteLog
//
// Write the whole of Log out in readable format.
// If hFile==NULL then write to debug output, else write to hFile.
//=============================================================================
void WriteLog(HANDLE hFile)
{
    //LONGLONG Prev[MAXSTAT];  // previous values found in log
    longlongarray Prev;

    char Buffer[100];
    sprintf(Buffer, "  Time (sec)   Type        Delta  Incident_Name\r\n");
    WriteOut(hFile, Buffer);

    int i;

    // initialise Prev to recognisable odd values
    for (i = 0; i<MAXSTAT; ++i) {
        Prev[i] = -1;
    }

    if (bFull) {
        for(i = NextLog; i<MAXLOG; ++i) {
            WriteLogEntry(hFile, i, Prev);
        }
    }

    for(i = 0; i<NextLog; ++i) {
        WriteLogEntry(hFile, i, Prev);
    }

} // WriteLog


//=============================================================================
//
// WriteStats
//
// Write the whole of StatBuffer out in readable format.
// If hFile==NULL then write to DbgLog, else write to hFile.
//=============================================================================
void WriteStats(HANDLE hFile)
{
    char Buffer[200];
    char s1[20];
    char s2[20];
    char s3[20];
    char s4[20];
    sprintf( Buffer
           , "Number      Average       StdDev     Smallest      Largest Incident_Name\r\n"
           );
    WriteOut(hFile, Buffer);

    int i;
    for (i = 0; i<NextStat; ++i) {
        if (i==0 && StatBuffer[i].Number==0) {
            continue;   // no temp scribbles to report
        }
        double SumSq = (double)StatBuffer[i].SumSq;
        double Sum = StatBuffer[i].Sum;

        if (StatBuffer[i].iType==INTGR) {
            double Average;
            if (StatBuffer[i].Number<=0) {
                Average = 0;
            } else {
                Average = (double)StatBuffer[i].Sum / (double)StatBuffer[i].Number;
            }
            double Std;
            if (StatBuffer[i].Number<=1) Std = 0.0;
            Std = sqrt( ( (double)SumSq
                        - ( (double)(Sum * Sum)
                          / (double)StatBuffer[i].Number
                          )
                        )
                        / ((double)StatBuffer[i].Number-1.0)
                      );
            sprintf( Buffer
                   , "%6d %12.3f %12.3f %12d %12d : %s\r\n"
                   , StatBuffer[i].Number + (StatBuffer[i].iType==NOTE ? 1 : 0)
                   , Average
                   , Std
                   , StatBuffer[i].Smallest
                   , StatBuffer[i].Largest
                   , Incidents[i]
                   );
        } else {
            double StDev;
            int Avg;
            int Smallest;
            int Largest;

            // Calculate Standard Deviation
            if (StatBuffer[i].Number<=1) StDev = -2;
            else {
                StDev = sqrt( ( SumSq
                              - ( (Sum * Sum)
                                / StatBuffer[i].Number
                                )
                              )
                              / (StatBuffer[i].Number-1)
                            );
            }

            // Calculate average
            if (StatBuffer[i].Number<=0) {
                Avg = -2;
            } else {
                Avg = StatBuffer[i].Sum / StatBuffer[i].Number;
            }

            // Calculate smallest and largest
            if (StatBuffer[i].Number<=0) {
                Smallest = -2;
                Largest = -2;
            } else {
                Smallest = StatBuffer[i].Smallest;
                Largest =  StatBuffer[i].Largest;
            }
            sprintf( Buffer
                   , "%6d %s %s %s %s : %s\r\n"
                   , StatBuffer[i].Number + (StatBuffer[i].iType==NOTE ? 1 : 0)
                   , Format(s1, Avg )
                   , Format(s2, (int)StDev )
                   , Format(s3, Smallest )
                   , Format(s4, Largest )
                   , Incidents[i]
                   );
        }


        WriteOut(hFile, Buffer);
    }
    WriteOut(hFile, "Times such as 0.050,00 are in seconds (that was 1/20 sec) \r\n");
} // WriteStats


#if 0 // test format
void TestFormat(int n)
{
    char Buffer[50];
    char s1[20];
    sprintf(Buffer, ">%s<",Format(s1,n));
    DbgLog((LOG_TRACE, 0, Buffer));
} // TestFormat
#endif



//=====================================================================
//
// Dump
//
// Dump out all the results from Log and StatBuffer in readable format.
// If hFile is NULL then it uses DbgLog
// otherwise it prints it to that file
//=====================================================================
void Msr_Dump(HANDLE hFile)
{
    EnterCriticalSection(&CSMeasure);
    if (!bInitOk) {
        Msr_Init();  // of course the log will be empty - never mind!
    }

    WriteLog(hFile);
    WriteStats(hFile);

#if 0   // test Format
    TestFormat(1);
    TestFormat(12);
    TestFormat(123);
    TestFormat(1234);
    TestFormat(12345);
    TestFormat(123456);
    TestFormat(1234567);
    TestFormat(12345678);
    TestFormat(123456789);
    TestFormat(1234567890);
#endif

    LeaveCriticalSection(&CSMeasure);
} // Msr_Dump


//=====================================================================
//
// DumpStats
//
// Dump out all the results from Log and StatBuffer in readable format.
// If hFile is NULL then it uses DbgLog
// otherwise it prints it to that file
//=====================================================================
void WINAPI Msr_DumpStats(HANDLE hFile)
{
    EnterCriticalSection(&CSMeasure);
    if (!bInitOk) {
        Msr_Init();  // of course the stats will be empty - never mind!
    }
    WriteStats(hFile);

    LeaveCriticalSection(&CSMeasure);
} // Msr_DumpStats

extern "C" BOOL WINAPI DllMain(HINSTANCE, ULONG, LPVOID);

BOOL WINAPI
DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pv)
{
    UNREFERENCED_PARAMETER(pv);
    switch (ulReason)
    {

    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls(hInstance);
        InitPerfCounter();
        Msr_Init();
        break;

    case DLL_PROCESS_DETACH:
        Msr_Terminate();
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\graphedt\proppage\vmrprop\vmrprop.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 2001  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//----------------------------------------------------------------------------
// VMRProp.cpp
//
//  Created 3/18/2001
//  Author: Steve Rowe [StRowe]
//
//----------------------------------------------------------------------------

#include <windowsx.h>
#include <streams.h>
#include <atlbase.h>
#include <commctrl.h>
#include <stdio.h>
#include <shlobj.h> // for SHGetSpecialFolderPath
#include "resource.h"

#ifdef FILTER_DLL
#include <initguid.h>
#endif

#include "vmrprop.h"


#ifdef FILTER_DLL

STDAPI DllRegisterServer()
{
    AMTRACE((TEXT("DllRegisterServer")));
    return AMovieDllRegisterServer2( TRUE );
}

STDAPI DllUnregisterServer()
{
    AMTRACE((TEXT("DllUnregisterServer")));
    return AMovieDllRegisterServer2( FALSE );
}

CFactoryTemplate g_Templates[] = {
	{
		L"",
		&CLSID_VMRFilterConfigProp,
		CVMRFilterConfigProp::CreateInstance
	}
};
int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);

#endif // #ifdef FILTER_DLL


//
// Constructor
//
CVMRFilterConfigProp::CVMRFilterConfigProp(LPUNKNOWN pUnk, HRESULT *phr) :
	CBasePropertyPage(NAME("Filter Config Page"),pUnk,IDD_FILTERCONFIG,IDS_TITLE_FILTERCONFIG),
	m_pIFilterConfig(NULL),
	m_pIMixerControl(NULL),
	m_dwNumPins(1),
	m_pEventSink(NULL), 
	m_CurPin(0), 
	m_XPos(0.0F),
	m_YPos(0.0F),
	m_XSize(1.0F),
	m_YSize(1.0F),
	m_Alpha(1.0F)
{
	ASSERT(phr);
}


//
// Create a quality properties object
//
CUnknown * CVMRFilterConfigProp::CreateInstance(LPUNKNOWN pUnk, HRESULT *phr)
{
	ASSERT(phr);

    CUnknown * pUnknown = new CVMRFilterConfigProp(pUnk, phr);
    if (pUnknown == NULL)
    {
        *phr = E_OUTOFMEMORY;
    }
    return pUnknown;
}


//
// OnConnect
//
// Override CBasePropertyPage method.
// Notification of which filter this property page will communicate with
// We query the object for the IVMRFilterConfig interface.
//
HRESULT CVMRFilterConfigProp::OnConnect(IUnknown *pUnknown)
{
	ASSERT(NULL != pUnknown);
    ASSERT(NULL == m_pIFilterConfig);
    ASSERT(NULL == m_pIMixerControl);

    HRESULT hr = pUnknown->QueryInterface(IID_IVMRFilterConfig, (void **) &m_pIFilterConfig);
    if (FAILED(hr) || NULL == m_pIFilterConfig)
    {
        return E_NOINTERFACE;
    }

	// Get the IMediaEventSink interface.  We use this later to tell graphedit that we updated the number of pins
	CComPtr<IBaseFilter> pFilter;
	hr = pUnknown->QueryInterface(IID_IBaseFilter, (void **) &pFilter);
    if (FAILED(hr) || !pFilter)
    {
        return E_NOINTERFACE;
    }

	FILTER_INFO Info;
	hr = pFilter->QueryFilterInfo(&Info);
	if (FAILED(hr))
	{
		return E_FAIL;
	}

    hr = Info.pGraph->QueryInterface(IID_IMediaEventSink, (void**) &m_pEventSink);
	Info.pGraph->Release(); // the IFilterGraph pointer is ref counted.  We need to release it or leak.
    if (FAILED(hr) || NULL == m_pEventSink) 
	{
        return E_NOINTERFACE;
    }

    return NOERROR;
} // OnConnect


//
// OnDisconnect
//
// Override CBasePropertyPage method.
// Release all interfaces we referenced in OnConnect
//
HRESULT CVMRFilterConfigProp::OnDisconnect(void)
{
	if (m_pIFilterConfig)
	{
		m_pIFilterConfig->Release();
		m_pIFilterConfig = NULL;
	}
	if (m_pIMixerControl)
	{
		m_pIMixerControl->Release();
		m_pIMixerControl = NULL;
	}
	if (m_pEventSink)
	{
		m_pEventSink->Release();
		m_pEventSink = NULL;
	}
	return NOERROR;
} // OnDisconnect


//
// OnReceiveMessage
//
// Override CBasePropertyPage method.
// Handles the messages for our property window
//
INT_PTR CVMRFilterConfigProp::OnReceiveMessage(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        HANDLE_MSG(hwnd, WM_COMMAND, OnCommand);
		HANDLE_MSG(hwnd, WM_HSCROLL, OnHScroll);
    } // switch
    return CBasePropertyPage::OnReceiveMessage(hwnd,uMsg,wParam,lParam);
} // OnReceiveMessage


//
// OnCommand
//
// Handles the command messages for our property window
//
void CVMRFilterConfigProp::OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify)
{
    switch(id)
    {
    case IDC_NUMPINS:
		if (EN_CHANGE == codeNotify)
		{
			SetDirty();
			break;
		}
		break;

		// the selected pin changed
		case IDC_PINSELECT:
		if (CBN_SELCHANGE == codeNotify)
		{
			m_CurPin = ComboBox_GetCurSel(GetDlgItem(m_Dlg, IDC_PINSELECT));
			InitConfigControls(m_CurPin);
			break;
		}
		break;

	// Reset X position to center
	case IDC_XPOS_STATIC:
		if (STN_CLICKED == codeNotify)
		{
			m_XPos = 0.0F;
			UpdatePinPos(m_CurPin);

			HWND hwndT;
			int pos;
			TCHAR sz[32];
			hwndT = GetDlgItem(m_Dlg, IDC_XPOS_SLIDER );
			pos = int(1000 * m_XPos) + 1000;
			SendMessage(hwndT, TBM_SETPOS, TRUE, (LPARAM)(pos));
			_stprintf(sz, TEXT("%.3f"), m_XPos);
			SetDlgItemText(m_Dlg, IDC_XPOS, sz);
		}
		break;

	// Reset Y position to center
	case IDC_YPOS_STATIC:
		if (STN_CLICKED == codeNotify)
		{
			m_YPos = 0.0F;
			UpdatePinPos(m_CurPin);

			HWND hwndT;
			int pos;
			TCHAR sz[32];
			pos = int(1000 * m_YPos) + 1000;
			hwndT = GetDlgItem(m_Dlg, IDC_YPOS_SLIDER );
			SendMessage(hwndT, TBM_SETPOS, TRUE, (LPARAM)(pos));
			_stprintf(sz, TEXT("%.3f"), m_YPos);
			SetDlgItemText(m_Dlg, IDC_YPOS, sz);
		}
		break;

    // Capture the current video image
    case IDC_SNAPSHOT:
        CaptureCurrentImage();
        break;

	}
} // OnCommand


//
// OnApplyChanges
//
// Override CBasePropertyPage method.
// Called when the user clicks ok or apply.
// We update the number of pins on the VMR.
//
HRESULT CVMRFilterConfigProp::OnApplyChanges()
{
    ASSERT(m_pIFilterConfig);

    BOOL Success;
    m_dwNumPins = GetDlgItemInt(m_Dlg, IDC_NUMPINS, &Success, FALSE);

    //
    // Set Number of Streams
    //
    HRESULT hr = m_pIFilterConfig->SetNumberOfStreams(m_dwNumPins);
    if (SUCCEEDED(hr) && !m_pIMixerControl)
    {
        hr = m_pIFilterConfig->QueryInterface(IID_IVMRMixerControl, (void **) &m_pIMixerControl);
        if (SUCCEEDED(hr))
        {
            // select the last pin connected because this will be highest in the z-order
            m_CurPin = m_dwNumPins - 1;
            InitConfigControls(m_CurPin); 
        }

    }

    // Notify the graph so it will draw the new pins
    if (m_pEventSink)
    {
	    hr = m_pEventSink->Notify(EC_GRAPH_CHANGED, 0, 0);
    }

    return NOERROR;
} // OnApplyChanges


//
// SetDirty
//
// Sets m_hrDirtyFlag and notifies the property page site of the change
//
void CVMRFilterConfigProp::SetDirty()
{
    m_bDirty = TRUE;
    if (m_pPageSite)
    {
        m_pPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
    }

} // SetDirty


//
// OnActivate
//
// Override CBasePropertyPage method.
// Called when the page is being displayed.  Used to initialize page contents.
//
HRESULT CVMRFilterConfigProp::OnActivate()
{
 	ASSERT(m_pIFilterConfig);

	HRESULT hr = m_pIFilterConfig->GetNumberOfStreams(&m_dwNumPins);
	if (NULL == m_pIMixerControl)
	{
		hr = m_pIFilterConfig->QueryInterface(IID_IVMRMixerControl, (void **) &m_pIMixerControl);
		// if IMixerControl is exposed, the VMR is in mixing mode
		if (S_OK == hr && m_pIMixerControl)   
		{
			// if this is the first time, select the last pin connected because this will be highest in the z-order
			m_CurPin = m_dwNumPins - 1;
			InitConfigControls(m_CurPin); 
		}
	}
	else
	{
		InitConfigControls(m_CurPin); 
	}

	BOOL bSet = SetDlgItemInt(m_Dlg, IDC_NUMPINS, m_dwNumPins, 0);
	ASSERT(bSet);

	// Set the range of the spin control
	HWND hSpin = GetDlgItem(m_Dlg, IDC_PINSPIN);
	if(hSpin)
	{
		SendMessage(hSpin, UDM_SETRANGE32, 1, 16);
	}
    return NOERROR;
} // OnActivate



//
// InitConfigControls
//
// Enable and update the content of the configuration controls .
//
void CVMRFilterConfigProp::InitConfigControls(DWORD pin)
{
	// If this call fails, the pins are not connected or there is no mixing control.
	if (FAILED(UpdateMixingData(pin)))
	{
		return;
	}

	//
	// Populate Combo List Box and Enable Pin Config Controls
	//
	CComPtr<IBaseFilter> pFilter;
    HRESULT hr = m_pIFilterConfig->QueryInterface(IID_IBaseFilter, (void **) &pFilter);
    if (FAILED(hr) || !pFilter)
    {
        return;
    }
	CComPtr<IEnumPins> pEnum;
	hr = pFilter->EnumPins(&pEnum);
    if (FAILED(hr) || !pEnum)
    {
        return;
    }
	HWND hCtl = GetDlgItem(m_Dlg, IDC_PINSELECT);
	ComboBox_ResetContent(GetDlgItem(m_Dlg, IDC_PINSELECT));
	pEnum->Reset();
	IPin * pPin;
	PIN_INFO Info;
	TCHAR szPinName[255]; // pin names are 32 characters or less.  This should be sufficient for a long time to come.
	while (S_OK == pEnum->Next(1, &pPin, NULL))
	{
		hr = pPin->QueryPinInfo(&Info);
        if (SUCCEEDED(hr))
        {
#ifdef UNICODE
		_tcscpy(szPinName, Info.achName);
#else
        WideCharToMultiByte(CP_ACP, NULL, Info.achName, -1, szPinName, 255, NULL, NULL);
#endif
		ComboBox_AddString(GetDlgItem(m_Dlg, IDC_PINSELECT), szPinName);
		pPin->Release();
		Info.pFilter->Release();
        }
	}

	ComboBox_SetCurSel(GetDlgItem(m_Dlg, IDC_PINSELECT), pin); // select the pin
	ComboBox_Enable(GetDlgItem(m_Dlg, IDC_PINSELECT), TRUE);
	ComboBox_Enable(GetDlgItem(m_Dlg, IDC_XPOS_SLIDER), TRUE);
	ComboBox_Enable(GetDlgItem(m_Dlg, IDC_YPOS_SLIDER), TRUE);
	ComboBox_Enable(GetDlgItem(m_Dlg, IDC_XSIZE_SLIDER), TRUE);
	ComboBox_Enable(GetDlgItem(m_Dlg, IDC_YSIZE_SLIDER), TRUE);
	ComboBox_Enable(GetDlgItem(m_Dlg, IDC_ALPHA_SLIDER), TRUE);

	// Initialize the sliders
	HWND hwndT;
    int pos;
    TCHAR sz[32];

	hwndT = GetDlgItem(m_Dlg, IDC_XPOS_SLIDER );
	pos = int(1000 * m_XPos) + 1000;
	SendMessage(hwndT, TBM_SETRANGE, TRUE, MAKELONG(0, (WORD)(2000)));
	SendMessage(hwndT, TBM_SETPOS, TRUE, (LPARAM)(pos));
	_stprintf(sz, TEXT("%.3f"), m_XPos);
	SetDlgItemText(m_Dlg, IDC_XPOS, sz);

	pos = int(1000 * m_YPos) + 1000;
	hwndT = GetDlgItem(m_Dlg, IDC_YPOS_SLIDER );
	SendMessage(hwndT, TBM_SETRANGE, TRUE, MAKELONG(0, (WORD)(2000)));
	SendMessage(hwndT, TBM_SETPOS, TRUE, (LPARAM)(pos));
	_stprintf(sz, TEXT("%.3f"), m_YPos);
	SetDlgItemText(m_Dlg, IDC_YPOS, sz);

	pos = int(1000 * m_XSize) + 1000;
	hwndT = GetDlgItem(m_Dlg, IDC_XSIZE_SLIDER );
	SendMessage(hwndT, TBM_SETRANGE, TRUE, MAKELONG(0, (WORD)(2000)));
	SendMessage(hwndT, TBM_SETPOS, TRUE, (LPARAM)(pos));
	_stprintf(sz, TEXT("%.3f"), m_XSize);
	SetDlgItemText(m_Dlg, IDC_XSIZE, sz);

	pos = int(1000 * m_YSize) + 1000;
	hwndT = GetDlgItem(m_Dlg, IDC_YSIZE_SLIDER );
	SendMessage(hwndT, TBM_SETRANGE, TRUE, MAKELONG(0, (WORD)(2000)));
	SendMessage(hwndT, TBM_SETPOS, TRUE, (LPARAM)(pos));
	_stprintf(sz, TEXT("%.3f"), m_YSize);
	SetDlgItemText(m_Dlg, IDC_YSIZE, sz);

	pos = int(1000 * m_Alpha);
	hwndT = GetDlgItem(m_Dlg, IDC_ALPHA_SLIDER );
	SendMessage(hwndT, TBM_SETRANGE, TRUE, MAKELONG(0, (WORD)(1000)));
	SendMessage(hwndT, TBM_SETPOS, TRUE, (LPARAM)(pos));
	_stprintf(sz, TEXT("%.3f"), m_Alpha);
	SetDlgItemText(m_Dlg, IDC_ALPHA, sz);
}// InitConfigControls


//
// OnHScroll
//
// Handles the scroll messages for our property window
//
void CVMRFilterConfigProp::OnHScroll(HWND hwnd, HWND hwndCtrl, UINT code, int pos)
{
	ASSERT(m_pIMixerControl);

    TCHAR sz[32];

    if (GetDlgItem(m_Dlg, IDC_ALPHA_SLIDER ) == hwndCtrl) {
        pos = (int)SendMessage(hwndCtrl, TBM_GETPOS, 0, 0);
        m_Alpha = (FLOAT)pos / 1000.0F;
        UpdatePinAlpha(m_CurPin);
        _stprintf(sz, TEXT("%.3f"), m_Alpha);
        SetDlgItemText(m_Dlg, IDC_ALPHA, sz);
    }
    else if (GetDlgItem(m_Dlg, IDC_XPOS_SLIDER ) == hwndCtrl) {
        pos = (int)SendMessage(hwndCtrl, TBM_GETPOS, 0, 0);
        m_XPos = ((FLOAT)pos - 1000.0F) / 1000.0F;
        UpdatePinPos(m_CurPin);
        _stprintf(sz, TEXT("%.3f"), m_XPos);
        SetDlgItemText(m_Dlg, IDC_XPOS, sz);
    }
    else if (GetDlgItem(m_Dlg, IDC_YPOS_SLIDER ) == hwndCtrl) {
        pos = (int)SendMessage(hwndCtrl, TBM_GETPOS, 0, 0);
        m_YPos = ((FLOAT)pos - 1000.0F) / 1000.0F;
        UpdatePinPos(m_CurPin);
        _stprintf(sz, TEXT("%.3f"), m_YPos);
        SetDlgItemText(m_Dlg, IDC_YPOS, sz);
    }
    else if (GetDlgItem(m_Dlg, IDC_XSIZE_SLIDER ) == hwndCtrl) {
        pos = (int)SendMessage(hwndCtrl, TBM_GETPOS, 0, 0);
        m_XSize = ((FLOAT)pos - 1000.0F) / 1000.0F;
        UpdatePinPos(m_CurPin);
        _stprintf(sz, TEXT("%.3f"), m_XSize);
        SetDlgItemText(m_Dlg, IDC_XSIZE, sz);
    }
    else if (GetDlgItem(m_Dlg, IDC_YSIZE_SLIDER ) == hwndCtrl) {
        pos = (int)SendMessage(hwndCtrl, TBM_GETPOS, 0, 0);
        m_YSize = ((FLOAT)pos - 1000.0F) / 1000.0F;
        UpdatePinPos(m_CurPin);
        _stprintf(sz, TEXT("%.3f"), m_YSize);
        SetDlgItemText(m_Dlg, IDC_YSIZE, sz);
    }
} // OnHScroll


//
// UpdatePinAlpha
//
// Update the alpha value of a stream
//
void CVMRFilterConfigProp::UpdatePinAlpha(DWORD dwStreamID)
{
    if (m_pIMixerControl)
	{
        m_pIMixerControl->SetAlpha(dwStreamID, m_Alpha);
	}
} // UpdatePinAlpha


//
// UpdatePinPos
//
// Update the position rectangle of a stream
//
void CVMRFilterConfigProp::UpdatePinPos(DWORD dwStreamID)
{
    NORMALIZEDRECT r = {m_XPos, m_YPos, m_XPos + m_XSize, m_YPos + m_YSize};

    if (m_pIMixerControl)
	{
        m_pIMixerControl->SetOutputRect(dwStreamID, &r);
	}
} // UpdatePinPos


//
// UpdateMixingData
//
// Query the filter for the current alpha value and position of a stream
//
HRESULT CVMRFilterConfigProp::UpdateMixingData(DWORD dwStreamID)
{
    NORMALIZEDRECT r;

    if (m_pIMixerControl)
	{
        HRESULT hr = m_pIMixerControl->GetOutputRect(dwStreamID, &r);
		if (FAILED(hr))
		{
			return hr;
		}
		m_XPos = r.left;
		m_YPos = r.top;
		m_XSize = r.right - r.left;
		m_YSize = r.bottom - r.top;

		return m_pIMixerControl->GetAlpha(dwStreamID, &m_Alpha);
	}
	return E_NOINTERFACE;
} // UpdateMixingData


//
// Data types and macros used for image capture
//
typedef     LPBITMAPINFOHEADER PDIB;

#define BFT_BITMAP 0x4d42   /* 'BM' */
#define DibNumColors(lpbi)      ((lpbi)->biClrUsed == 0 && (lpbi)->biBitCount <= 8 \
                                    ? (int)(1 << (int)(lpbi)->biBitCount)          \
                                    : (int)(lpbi)->biClrUsed)

#define DibSize(lpbi)           ((lpbi)->biSize + (lpbi)->biSizeImage + \
                                 (int)(lpbi)->biClrUsed * sizeof(RGBQUAD))

#define DibPaletteSize(lpbi)    (DibNumColors(lpbi) * sizeof(RGBQUAD))


//
// SaveCapturedImage
//
// Save a captured image (bitmap) to a file
//
bool CVMRFilterConfigProp::SaveCapturedImage(TCHAR* szFile, BYTE* lpCurrImage)
{

    BITMAPFILEHEADER    hdr;
    DWORD               dwSize;
    PDIB                pdib = (PDIB)lpCurrImage;

    //fh = OpenFile(szFile,&of,OF_CREATE|OF_READWRITE);
    HANDLE hFile = CreateFile(szFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,
        NULL);

    if (INVALID_HANDLE_VALUE == hFile)
        return FALSE;

    dwSize = DibSize(pdib);

    hdr.bfType          = BFT_BITMAP;
    hdr.bfSize          = dwSize + sizeof(BITMAPFILEHEADER);
    hdr.bfReserved1     = 0;
    hdr.bfReserved2     = 0;
    hdr.bfOffBits       = (DWORD)sizeof(BITMAPFILEHEADER) + pdib->biSize +
                          DibPaletteSize(pdib);

    DWORD dwWritten;
    WriteFile(hFile, (LPVOID)&hdr, sizeof(BITMAPFILEHEADER), &dwWritten, NULL);
    if (sizeof(BITMAPFILEHEADER) != dwWritten)
        return FALSE;
    WriteFile(hFile, (LPVOID)pdib, dwSize, &dwWritten, NULL);
    if (dwSize != dwWritten)
        return FALSE;

    CloseHandle(hFile);
    return TRUE;
}


//
// CaptureCurrentImage
//
// Captures the current VMR image and save it to a file
//
void CVMRFilterConfigProp::CaptureCurrentImage(void)
{
    IBasicVideo* iBV;
    BYTE* lpCurrImage = NULL;

    HRESULT hr = m_pIFilterConfig->QueryInterface(IID_IBasicVideo, (LPVOID*)&iBV);
    if (SUCCEEDED(hr)) {
        LONG BuffSize = 0;
        hr = iBV->GetCurrentImage(&BuffSize, NULL);
        if (SUCCEEDED(hr)) {
            lpCurrImage = new BYTE[BuffSize];
            if (lpCurrImage) {
                hr = iBV->GetCurrentImage(&BuffSize, (long*)lpCurrImage);
                if (FAILED(hr)) {
                    delete lpCurrImage;
                    lpCurrImage = NULL;
                }
            }
        }
    } // QI

    if (lpCurrImage) {
        // Get the path to the My Pictures folder.  Create it if it doesn't exist.
        // If we can't get it, don't use a path.  Picture will then be saved in 
        // current working directory.
        TCHAR tszPath[MAX_PATH];
        if (!SHGetSpecialFolderPath(NULL, tszPath, CSIDL_MYPICTURES, TRUE))
        {
            tszPath[0]=TEXT('\0');
        }

        DWORD dwTime = timeGetTime();

        TCHAR szFile[MAX_PATH];
        wsprintf(szFile, TEXT("%s\\VMRImage%X.bmp"), tszPath, dwTime);
        SaveCapturedImage(szFile, lpCurrImage);

        delete lpCurrImage;
    }

    if (iBV) {
        iBV->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\measure\perf.c ===
/******************************Module*Header*******************************\
* Module Name: Perf.c
*
* Performance counter functions.  Uses the Pentium performance counters
* if they are available, otherwise falls back to the system QueryPerformance
* api's.
*
* InitPerfCounter MUST be called before using the QUERY_PERFORMANCE_XXX macros
* as it initializes the two global functions pointers.
*
*
*
* Created: 13-10-95
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1995  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/
#include <windows.h>
#include "Perf.h"


PERFFUNCTION    lpQueryPerfCounter;
PERFFUNCTION    lpQueryPerfFreqency;

void
GetFrequencyEstimate(
    LARGE_INTEGER *li
    );


#ifdef TEST
#include <stdio.h>
/******************************Public*Routine******************************\
* main
*
* Program entry point.
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
int __cdecl main( void )
{
    LARGE_INTEGER liP1;
    LARGE_INTEGER liP2;
    LARGE_INTEGER liPf;

    InitPerfCounter();

    QUERY_PERFORMANCE_FREQUENCY(&liPf);

    // Time a 50 milli second sleep
    QUERY_PERFORMANCE_COUNTER(&liP1);
    Sleep(50);
    QUERY_PERFORMANCE_COUNTER(&liP2);

    printf("Pentium counter frequency = %u\n", liPf.LowPart );
    printf("Pentium counter %#X%X - %#X%X = %u\n",
           liP2.HighPart, liP2.LowPart, liP1.HighPart, liP1.LowPart,
           liP2.LowPart - liP1.LowPart
           );

    printf("Time taken = %6.6f seconds\n",
           (double)(liP2.LowPart - liP1.LowPart) / (double)liPf.QuadPart);

    return 0;
}
#endif



/******************************Public*Routine******************************\
* InitPerfCounter
*
* Determine (at runtime) if it is possible to use the Pentium performance
* counter.  If it is not fall back to the system performance counter.
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
InitPerfCounter(
    void
    )
{
    SYSTEM_INFO sysInfo;

    GetSystemInfo(&sysInfo);
    if (sysInfo.dwProcessorType == PROCESSOR_INTEL_PENTIUM) {
        lpQueryPerfFreqency = QueryPerfFrequency;
        lpQueryPerfCounter  = QueryPerfCounter;
    }
    else {
        lpQueryPerfFreqency = (PERFFUNCTION)QueryPerformanceFrequency;
        lpQueryPerfCounter  = (PERFFUNCTION)QueryPerformanceCounter;
    }
}


/******************************Public*Routine******************************\
* QueryPerfFrequency
*
* Determines the clock frequency of a (Pentium) microprocessor. Takes an
* averaged estimate of the clk frequency and then matches it to known
* Pentium clock frequencies.  Returns the estimate if a match is not found.
*
* This is an expensive call in cpu terms as it takes at least 16 milli seconds
* just to calculate an averaged estimate of the clock speed.  You only need
* to call this function once, make sure you don't call it more times.
*
* History:
* 13-10-95 - StephenE - Created
*
\**************************************************************************/
void WINAPI
QueryPerfFrequency(
    LARGE_INTEGER *li
    )
{
#ifdef _X86_
#define SAMPLE_SIZE     8

    LARGE_INTEGER   est;
    int             i;

    li->QuadPart = 0;
    for (i = 0; i < SAMPLE_SIZE; i++) {
        GetFrequencyEstimate(&est);
        li->QuadPart += est.QuadPart;
    }
    li->QuadPart /= SAMPLE_SIZE;

    //
    // At the moment Pentiums come in 60, 66, 75, 90, 100, 120 and 133 MHz
    // clock speeds.  So use the above estimation of the clock frequency
    // to determine the real clock frequency.
    //
    //  59Mhz to 61Mhz assume its a 60 Mhz
    if (li->QuadPart >= 59000000 && li->QuadPart < 61000000) {
        li->QuadPart = 60000000;

    }

    //  65Mhz to 67Mhz assume its a 66 Mhz
    else if (li->QuadPart >= 65000000 && li->QuadPart < 67000000) {
        li->QuadPart = 66000000;

    }

    //  74Mhz to 76Mhz assume its a 75 Mhz
    else if (li->QuadPart >= 74000000 && li->QuadPart < 76000000) {
        li->QuadPart = 75000000;

    }

    //  89Mhz to 91Mhz assume its a 90 Mhz
    else if (li->QuadPart >= 89000000 && li->QuadPart < 91000000) {
        li->QuadPart = 90000000;

    }

    //  99Mhz to 101Mhz assume its a 100 Mhz
    else if (li->QuadPart >= 99000000 && li->QuadPart < 101000000) {
        li->QuadPart = 100000000;

    }

    //  119Mhz to 121Mhz assume its a 120 Mhz
    else if (li->QuadPart >= 119000000 && li->QuadPart < 121000000) {
        li->QuadPart = 120000000;

    }
    //  132Mhz to 134Mhz assume its a 133 Mhz
    else if (li->QuadPart >= 132000000 && li->QuadPart < 134000000) {
        li->QuadPart = 133000000;
    }

    // if use our estimate.
#else
    li->QuadPart = -1;
#endif
}



/*****************************Private*Routine******************************\
* GetFrequencyEstimate
*
* Uses the system QueryPerformance counter to estimate the Pentium
* cpu clock * frequency
*
* History:
* 13-10-95 - StephenE - Created
*
\**************************************************************************/
void
GetFrequencyEstimate(
    LARGE_INTEGER *li
    )
{
    LARGE_INTEGER liP1;     // Pentium clk start
    LARGE_INTEGER liP2;     // Pentium clk end
    LARGE_INTEGER liS1;     // System clk end
    LARGE_INTEGER liS2;     // System clk end
    LARGE_INTEGER liSf;     // System clk frequency

    QueryPerformanceFrequency(&liSf);

    QueryPerformanceCounter(&liS1);
    QueryPerfCounter(&liP1);

    Sleep(2);         // Sleep for approx 2 milli- seconds

    QueryPerfCounter(&liP2);
    QueryPerformanceCounter(&liS2);

    //
    // Determine the time recorded by both clocks.
    //
    liP2.QuadPart = liP2.QuadPart - liP1.QuadPart;
    liS2.QuadPart = liS2.QuadPart - liS1.QuadPart;


    li->QuadPart = (liP2.QuadPart * liSf.QuadPart) / liS2.QuadPart;
}



/******************************Public*Routine******************************\
* QueryPerfCounter
*
* Query the internal clock counter on the Pentium, uses the undocumented
* rdtsc instruction, which copies the current 64 bit clock count into
* edx:eax.
*
* History:
* 13-10-95 - StephenE - Created
*
\**************************************************************************/
void WINAPI
QueryPerfCounter(
    LARGE_INTEGER *li
    )
{
#ifdef _X86_
    _asm    mov     ecx, dword ptr li           // copy li pointer value to ecx
    _asm    _emit   0x0f                        // opcode 0x0F31 is rdtsc
    _asm    _emit   0x31
    _asm    mov     dword ptr [ecx], eax        // save result in li->LowPart
    _asm    mov     dword ptr [ecx+4], edx      // and li->HighPart
#else
    ;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\vcdplyer\makefile.inc ===
# NOTE:
# this directory contains a makefile which contains a single line that
# includes the global build process makefile.def. If the
# NTTARGETFILE1 or NTTARGETFILE0 environment
# variable is set then makefile.def includes makefile.inc from the current
# directory. This makefile.inc creates an extra target for nmake to create
# when it is run. NTTARGETFILE0 is built before everything else, and
# NTTARGETFILE1 is built after everything else.

copyfiles:
  @if exist obj\$(TARGET_DIRECTORY)\$(TARGETNAME).exe  \
    copy obj\$(TARGET_DIRECTORY)\$(TARGETNAME).exe     \
         $(SDK_ROOT)\bin\$(DBG_RTL)\*.*


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\usbglitch\usbglitch.cpp ===
/*++

Copyright  2000 Microsoft Corporation

Module Name:

    usbglitch.c

Abstract:

    This module implements the USB glitch detector consumer. It's intended
    for use with the Intel USB audio glitch detection hardware connected
    via a serial port.
    
    COM port should be specified using the USB_AUDIO_GLITCH_DETECTOR_PORT
    environment variable. The format is: COMn, where n = 1, 2, 3, ..., 9.
    
    See the big comment at the end.

Author:

    Arthur Zwiegincew (arthurz) 14-Dec-00

Revision History:

    14-Dec-00 - Created

--*/

#pragma warning (disable:4201)

#include <streams.h>
#include <windows.h>
#include <tchar.h>
#include <winperf.h>
#include <wmistr.h>
#include <evntrace.h>
#include <stdio.h>
#include <initguid.h>
#include "perflog.h"

#include "usbglitch.h"

//
// Logging state.
//

USBAUDIOSTATE CurrentState;

char* StateNames[5] =
{
    "Disabled",
    "Enabled",
    "Stream",
    "Glitch",
    "Zero"
};

int NumberOfFramesInCurrentState;
BOOL StreamEncountered;

//
// Performance logging parameters.
//

// {28CF047A-2437-4b24-B653-B9446A419A69}
DEFINE_GUID(GUID_DSHOW_CTL, 
0x28cf047a, 0x2437, 0x4b24, 0xb6, 0x53, 0xb9, 0x44, 0x6a, 0x41, 0x9a, 0x69);

struct {
    PERFLOG_LOGGING_PARAMS Params;
    TRACE_GUID_REGISTRATION TraceGuids[1];
} g_perflogParams;

inline ULONGLONG _RDTSC( void ) {
#ifdef _X86_
    LARGE_INTEGER   li;
    __asm {
        _emit   0x0F
        _emit   0x31
        mov li.LowPart,eax
        mov li.HighPart,edx
    }
    return li.QuadPart;

#if 0 // This isn't tested yet

#elif defined (_IA64_)

#define INL_REGID_APITC 3116
    return __getReg( INL_REGID_APITC );

#endif // 0

#else // unsupported platform
    // not implemented on non x86/IA64 platforms
    return 0;
#endif // _X86_/_IA64_
}

#undef LogEvent

void LogEvent (USBAUDIOSTATE State, int Frames)
{
    _PERFINFO_WMI_USBAUDIOSTATE perfData;
    memset( &perfData, 0, sizeof (perfData));
    perfData.header.Size = sizeof (perfData);
    perfData.header.Flags = WNODE_FLAG_TRACED_GUID;
    perfData.header.Guid = GUID_DSOUNDGLITCH;
    perfData.data.cycleCounter = _RDTSC();
    perfData.data.usbAudioState = State;
    perfData.data.numberOfFrames = Frames;
    PerflogTraceEvent ((PEVENT_TRACE_HEADER) &perfData);

    printf ("%s: %d frames\n", StateNames[State], Frames);
}

void ProcessEvent (BYTE Data)
{
    if (Data != CurrentState) {

        if (CurrentState == ZERO) {
            if (StreamEncountered && (Data == STREAM || Data == GLITCH)) {
                LogEvent (CurrentState, NumberOfFramesInCurrentState);
            }
        }
        else if (CurrentState == GLITCH) {
            if (Data == ZERO || Data == STREAM) {
                LogEvent (CurrentState, NumberOfFramesInCurrentState);
            }
        }
        else {
            LogEvent (CurrentState, NumberOfFramesInCurrentState);
        }

        CurrentState = (USBAUDIOSTATE)Data;
        NumberOfFramesInCurrentState = 1;

        if (CurrentState == STREAM) {
            StreamEncountered = TRUE;
        }
    }
    else {
        NumberOfFramesInCurrentState += 1;
    }
}

BOOL WINAPI ConsoleCtrlHandler (DWORD CtrlType)
{
    PerflogShutdown();
    return FALSE;
}

void __cdecl main (void)
{
    char PortName[5] = {0};
    DWORD PortNameLength;
    HANDLE Port;
    COMMCONFIG CommConfig;
    BOOL bstatus;
    DWORD EventMask;
    BYTE Data;
    DWORD BytesRead;

    //
    // Get the port name.
    //
    
    PortNameLength = GetEnvironmentVariable ("USB_AUDIO_GLITCH_DETECTOR_PORT",
                                             PortName, 5);

    if (PortNameLength != 4
        || _strnicmp (PortName, "COM", 3) != 0
        || PortName[3] < '1' || PortName[3] > '9') {
    
        printf ("Please set USB_AUDIO_GLITCH_DETECTOR_PORT environment "
                "variable to COM[1..9].");
        return;
    }

    //
    // Open the port.
    //
    
    Port = CreateFile (PortName, GENERIC_READ | GENERIC_WRITE, 0, NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (Port == INVALID_HANDLE_VALUE) {
        printf ("Failed to open %s. GetLastError()=>%d\n", PortName, GetLastError());
        return;
    }

    printf ("%s opened.\n", PortName);
    Sleep (10000);

    //
    // Set port configuration.
    //
    
    CommConfig.dwSize = sizeof (CommConfig);
    CommConfig.wVersion = 1;
    CommConfig.dcb.DCBlength = sizeof (DCB);
    CommConfig.dcb.BaudRate = CBR_115200;
    CommConfig.dcb.fBinary = 1;
    CommConfig.dcb.fParity = 0;
    CommConfig.dcb.fOutxCtsFlow = 0;
    CommConfig.dcb.fOutxDsrFlow = 0;
    CommConfig.dcb.fDtrControl = DTR_CONTROL_ENABLE;
    CommConfig.dcb.fDsrSensitivity = 0;
    CommConfig.dcb.fTXContinueOnXoff = 0;
    CommConfig.dcb.fOutX = 0;
    CommConfig.dcb.fInX = 0;
    CommConfig.dcb.fErrorChar = 1;
    CommConfig.dcb.fNull = 0;
    CommConfig.dcb.fRtsControl = RTS_CONTROL_ENABLE;
    CommConfig.dcb.fAbortOnError = 0;
    CommConfig.dcb.wReserved = 0;
    CommConfig.dcb.XonLim = 128;
    CommConfig.dcb.XoffLim = 512;
    CommConfig.dcb.ByteSize = 8;
    CommConfig.dcb.Parity = NOPARITY;
    CommConfig.dcb.StopBits = ONESTOPBIT;
    CommConfig.dcb.XonChar = 0;
    CommConfig.dcb.XoffChar = 0;
    CommConfig.dcb.ErrorChar = 0;
    CommConfig.dcb.EofChar = 127;
    CommConfig.dcb.EvtChar = 126;
    CommConfig.dcb.wReserved1 = 0;
    CommConfig.dwProviderSubType = PST_RS232;
    CommConfig.dwProviderOffset = 0;
    CommConfig.dwProviderSize = 0;

    bstatus = SetCommConfig (Port, &CommConfig, sizeof (CommConfig));
    if (!bstatus) {
        printf ("Failed to configure %s. GetLastError()=>%d\n", PortName, GetLastError());
        return;
    }

    bstatus = SetupComm (Port, 8, 8);
    if (!bstatus) {
        printf ("Failed to configure %s. GetLastError()=>%d\n", PortName, GetLastError());
        return;
    }

    //
    // Initialize perf logging.
    //
    
    g_perflogParams.Params.ControlGuid = GUID_DSHOW_CTL;
    g_perflogParams.Params.OnStateChanged = NULL;
    g_perflogParams.Params.NumberOfTraceGuids = 1;
    g_perflogParams.Params.TraceGuids[0].Guid = &GUID_USBAUDIOSTATE;

    PerflogInitialize (&g_perflogParams.Params);
    SetConsoleCtrlHandler (ConsoleCtrlHandler, TRUE);

    //
    // Receive data.
    //
    
    CurrentState = DISABLED;
    NumberOfFramesInCurrentState = 0;
    StreamEncountered = FALSE;

    bstatus = SetCommMask (Port, EV_RXCHAR);
    if (!bstatus) {
        printf ("Internal error (1). GetLastError()=>%d\n", GetLastError());
        return;
    }

    for (;;) {

        EventMask = 0;
        WaitCommEvent (Port, &EventMask, NULL);

        if (EventMask & EV_RXCHAR) {

            bstatus = ReadFile (Port, &Data, 1, &BytesRead, NULL);
            if (!bstatus || BytesRead != 1) {
                ClearCommError (Port, &BytesRead, NULL);
                continue;
            }

            ProcessEvent (Data);
        }
    }
}

/*

John.keys@intel.com has provided the following information:

Intel Hardware USB Audio Glitch Detector
Theory of Operation
-----------------------------------------

Serial Port Configuration:
115,200 baud
8 bit words
1 stop bit
no parity

The Glitch detector's port (outside port, labeled UART) is configured as DTE,
so only straight-through cables should be used. A pc-pc debug cable will not 
work.

Because of special reset circuitry on the board, both DTR and RTS should be
enabled. The detector is stuck in reset if all LEDs are lit. 

When plugged into the USB port and receiving SOFs (Start Of Frame packets, one
received every millisecond), the HW glitch detector will output the following
values once per millisecond:
    0 -	Device is disabled
    1 -	Device is enabled - SetInterface Request received
    2 -	Frame with Streaming data
    3 -	Frame with no streaming data 
    4 -	Frame with Zero-stuffed data 


To determine which value to send, the device contains a small state machine.
The states it moves through are DISABLED, ENABLED, STREAM, GLITCH, and ZERO.
Note that these states duplicate the values returned on the serial port. In 
fact, the detector sends back it's state at every frame.

DISABLED: device starts in this state, returns to this state when unplugged.
    This is a special case, and the device can return to this state from 
    any other state. The device can only move to ENABLED from this state.

ENABLED: Device goes to this state with every SetConfiguration or SetInterface
    request. Since SetInterface requests are made to open and close Audio
    pipes, this allows the device to detect the end of audio streams.
    The will stay in this state until it is disconnected or it receives
    Isochronous data. It can then go to either STREAM or ZERO, 
    depending on the data payload received. This prevents false glitch
    detection while waiting for the stream to start.
         
STREAM:  Valid data was received. The device can move to this state from any 
    other state, with the exception of DISABLED.  It can move to any other
    state.
         
GLITCH:  No data received. The device can only move to this state from STREAM
    or ZERO. It can change from this state to any other state.
         
ZERO:	Data was received, but all samples had zero value. The device can move
    to this state from any other state except DISABLED. It can change to 
    any other state from ZERO.         


----------------------------------------------------------------------------
Application Processing Considerations
----------------------------------------------------------------------------
The difference between ZERO and GLITCH: Glitch indicates that no data was 
received by the board. This indicates low-level ISR, DPC, IRQL, or Critical
Work Items.  ZERO: indicates high-level thread latencies that result in 
KMIXER data starvation.

Accurate glitch detection requires looking at the stream over time. The board
can only report it's state at any given frame. Therefore, the application must
perform some additional processing of state to eliminate false glitches. 
Specifically, it must look at the transitions between states.

ZERO:  Zero state should be ignored until the first STREAM state is encountered.
    This prevents false detection of rate-lock packets and of initial 
    attenuated streams. After the first STREAM state is encountered, ZERO 
    should only be reported when a ZERO->STREAM or a ZERO->GLITCH transition 
    is seen. ZERO->ENABLED transitions should not be reported as they can 
    occur normally when shutting down the stream. Also, ZERO->GLITCH->ENABLED
    transitions must be ignored for the same reason.
      
GLITCH: Only GLITCH->ZERO and GLITCH->STREAM transitions should be reported as
    glitches. GLITCH->ENA transitions always occur at the end of a stream 
    and are normal.


When enabled, the device will send one state byte every 1 millisecond. This
means that the stream can also be used as a clock source for time-stamping 
glitches.
 
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\vcdplyer\app.cpp ===
/******************************Module*Header*******************************\
* Module Name: app.cpp
*
* A simple Video CD player
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/
#include <streams.h>
#include <atlbase.h>
#include <atlconv.cpp>
#include <mmreg.h>
#include <commctrl.h>

#include "project.h"
#include <initguid.h>
#include "mpgcodec.h"

#include <stdarg.h>
#include <stdio.h>

/* -------------------------------------------------------------------------
** Global variables that are initialized at run time and then stay constant.
** -------------------------------------------------------------------------
*/
HINSTANCE           hInst;
HICON               hIconVideoCd;
HWND                hwndApp;
HWND                g_hwndToolbar;
HWND                g_hwndStatusbar;
HWND                g_hwndTrackbar;
CMpegMovie          *pMpegMovie;
double              g_TrackBarScale = 1.0;
BOOL                g_bUseThreadedGraph;
BOOL                g_bPlay = FALSE;

int                 dyToolbar, dyStatusbar, dyTrackbar;

MSR_DUMPPROC        *lpDumpProc;
MSR_CONTROLPROC     *lpControlProc;
HINSTANCE           hInstMeasure;



/* -------------------------------------------------------------------------
** True Globals - these may change during execution of the program.
** -------------------------------------------------------------------------
*/
TCHAR               g_achFileName[MAX_PATH];
TCHAR               g_szPerfLog[MAX_PATH];
OPENFILENAME        ofn;
DWORD               g_State = VCD_NO_CD;
RECENTFILES         aRecentFiles[MAX_RECENT_FILES];
int                 nRecentFiles;
LONG                lMovieOrgX, lMovieOrgY;
int                 g_TimeFormat = IDM_TIME;
HANDLE              hRenderLog = INVALID_HANDLE_VALUE;
TCHAR *		    g_szOtherStuff;
BOOL                g_IsNT;


/* -------------------------------------------------------------------------
** Constants
** -------------------------------------------------------------------------
*/
const TCHAR szClassName[] = TEXT("SJE_VCDPlayer_CLASS");
const TCHAR g_szNULL[]    = TEXT("\0");
const TCHAR g_szEmpty[]   = TEXT("");
const TCHAR g_szMovieX[]  = TEXT("MovieOriginX");
const TCHAR g_szMovieY[]  = TEXT("MovieOriginY");

/*
** these values are defined by the UI gods...
*/
const int   dxBitmap        = 16;
const int   dyBitmap        = 15;
const int   dxButtonSep     = 8;
const TCHAR g_chNULL        = TEXT('\0');


const TBBUTTON tbButtons[DEFAULT_TBAR_SIZE] = {
    { IDX_SEPARATOR,    1,                    0,               TBSTYLE_SEP           },
    { IDX_1,            IDM_MOVIE_PLAY,       TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_2,            IDM_MOVIE_PAUSE,      TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_3,            IDM_MOVIE_STOP,       TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_SEPARATOR,    2,                    0,               TBSTYLE_SEP           },
    { IDX_4,            IDM_MOVIE_PREVTRACK,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_5,            IDM_MOVIE_SKIP_BACK,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_6,            IDM_MOVIE_SKIP_FORE,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_7,            IDM_MOVIE_NEXTTRACK,  TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_SEPARATOR,    3,                    0,               TBSTYLE_SEP           },
    { IDX_9,            IDM_PERF_NEW,         TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_10,           IDM_PERF_DUMP,        TBSTATE_ENABLED, TBSTYLE_BUTTON, 0, 0, 0, -1 },
    { IDX_SEPARATOR,    4,                    0,               TBSTYLE_SEP           },
    { IDX_11,           IDM_FULL_SCREEN,      TBSTATE_ENABLED, TBSTYLE_CHECK,  0, 0, 0, -1 }
};

const int CX_DEFAULT	      = 310;
const int CY_DEFAULT	      = 120;

const int CX_MOVIE_DEFAULT    = 352;
const int CY_MOVIE_DEFAULT    = 120;



/******************************Public*Routine******************************\
* WinMain
*
*
* Windows recognizes this function by name as the initial entry point
* for the program.  This function calls the application initialization
* routine, if no other instance of the program is running, and always
* calls the instance initialization routine.  It then executes a message
* retrieval and dispatch loop that is the top-level control structure
* for the remainder of execution.  The loop is terminated when a WM_QUIT
* message is received, at which time this function exits the application
* instance by returning the value passed by PostQuitMessage().
*
* If this function must abort before entering the message loop, it
* returns the conventional value NULL.
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
int PASCAL
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLineOld,
    int nCmdShow
    )
{
    USES_CONVERSION;
    lstrcpy(g_szPerfLog, TEXT("c:\\perfdata.log"));
    LPTSTR lpCmdLine = A2T(lpCmdLineOld);

    if ( !hPrevInstance ) {
        if ( !InitApplication( hInstance ) ) {
            return FALSE;
        }
    }

    /*
    ** Perform initializations that apply to a specific instance
    */
    if ( !InitInstance( hInstance, nCmdShow ) ) {
        return FALSE;
    }

    /* Look for options */
    while (lpCmdLine && (*lpCmdLine == '-' || *lpCmdLine == '/')) {
        if (lpCmdLine[1] == 'T') {
            //  No threaded graph
            g_bUseThreadedGraph = TRUE;
            lpCmdLine += 2;
        } else if (lpCmdLine[1] == 'P') {
            g_bPlay = TRUE;
            lpCmdLine += 2;
        } else {
            break;
        }
        while (lpCmdLine[0] == ' ') {
            lpCmdLine++;
        }
    }


    if (lpCmdLine != NULL && lstrlen(lpCmdLine) > 0) {
        ProcessOpen(lpCmdLine, g_bPlay);
        SetPlayButtonsEnableState();
    }

    /*
    ** Acquire and dispatch messages until a WM_QUIT message is received.
    */
    return DoMainLoop();
}


/*****************************Private*Routine******************************\
* DoMainLoop
*
* Process the main message loop
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
int
DoMainLoop(
    void
    )
{
    MSG         msg;
    HANDLE      ahObjects[1];   // handles that need to be waited on
    const int   cObjects = 1;   // no of objects that we are waiting on
    HACCEL      haccel = LoadAccelerators(hInst, MAKEINTRESOURCE(IDR_ACCELERATOR));

    //
    // message loop lasts until we get a WM_QUIT message
    // upon which we shall return from the function
    //

    for ( ;; ) {

        if (pMpegMovie != NULL) {
            ahObjects[0] = pMpegMovie->GetMovieEventHandle();
        }
        else {
            ahObjects[0] = NULL;
        }

        if (ahObjects[0] == NULL) {
            WaitMessage();
        }
        else {

            //
            // wait for any message sent or posted to this queue
            // or for a graph notification
            //
            DWORD result;

            result = MsgWaitForMultipleObjects(cObjects, ahObjects, FALSE,
                                               INFINITE, QS_ALLINPUT);
            if (result != (WAIT_OBJECT_0 + cObjects)) {

                if (result == WAIT_OBJECT_0) {
                    VideoCd_OnGraphNotify();
                }
                continue;
            }
        }

        //
        // When here, we either have a message or no event handle
        // has been created yet.
        //
        // read all of the messages in this next loop
        // removing each message as we read it
        //

        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {

            if (msg.message == WM_QUIT) {
                return (int) msg.wParam;
            }

            if (!TranslateAccelerator(hwndApp, haccel, &msg)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }

} // DoMainLoop


//
// InitAboutString
//
// Obtains the version information from the binary file. Note that if
// we fail we just return. The template for the about dialog has a
// "Version not available" as default.
//
TCHAR *InitAboutString()
{
    //
    // Find the version of this binary
    //
    TCHAR achFileName[128];
    if ( !GetModuleFileName(hInst, achFileName, sizeof(achFileName)) )
        return((TCHAR *)g_szEmpty);

    DWORD dwTemp;
    DWORD dwVerSize = GetFileVersionInfoSize( achFileName, &dwTemp );
    if ( !dwVerSize)
        return((TCHAR *)g_szEmpty);

    HLOCAL hTemp = LocalAlloc( LHND, dwVerSize );
    if (!hTemp)
        return((TCHAR *)g_szEmpty);

    LPVOID lpvVerBuffer = LocalLock( hTemp );
    if (!lpvVerBuffer) {
        LocalFree( hTemp );
        return((TCHAR *)g_szEmpty);
    }

    if ( !GetFileVersionInfo( achFileName, 0L, dwVerSize, lpvVerBuffer ) ) {
        LocalUnlock( hTemp );
        LocalFree( hTemp );
        return((TCHAR *)g_szEmpty);
    }

    // "040904E4" is the code page for US English (Andrew believes).
    LPVOID lpvValue;
    UINT uLen;
    if (VerQueryValue( lpvVerBuffer,
                   TEXT("\\StringFileInfo\\040904E4\\ProductVersion"),
                   (LPVOID *) &lpvValue, &uLen)) {

        //
        // Get creation date of executable (date of build)
        //
        WIN32_FIND_DATA FindFileData;
        HANDLE hFind = FindFirstFile(achFileName, &FindFileData);
        ASSERT(hFind != INVALID_HANDLE_VALUE);
        FindClose(hFind);

        FILETIME ModTime = FindFileData.ftLastWriteTime;
        SYSTEMTIME SysTime;
        FileTimeToSystemTime(&ModTime,&SysTime);
        char szBuildDate[20];
        sprintf(szBuildDate, " - Build: %2.2u%2.2u%2.2u",
              SysTime.wYear % 100, SysTime.wMonth, SysTime.wDay);
        strcat((LPSTR) lpvValue, szBuildDate);
    }

    TCHAR *szAbout = (TCHAR *) _strdup((LPSTR) lpvValue);

    LocalUnlock( hTemp );
    LocalFree( hTemp );

    return(szAbout);
}


/*****************************Private*Routine******************************\
* InitApplication(HANDLE)
*
* This function is called at initialization time only if no other
* instances of the application are running.  This function performs
* initialization tasks that can be done once for any number of running
* instances.
*
* In this case, we initialize a window class by filling out a data
* structure of type WNDCLASS and calling the Windows RegisterClass()
* function.  Since all instances of this application use the same window
* class, we only need to do this when the first instance is initialized.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
InitApplication(
    HINSTANCE hInstance
    )
{
    WNDCLASS  wc;

    hInstMeasure = LoadLibraryA("measure.dll");
    if (hInstMeasure) {
        *(FARPROC *)&lpDumpProc = GetProcAddress(hInstMeasure, "Msr_Dump");
        *(FARPROC *)&lpControlProc = GetProcAddress(hInstMeasure, "Msr_Control");
    }

    /*
    ** Fill in window class structure with parameters that describe the
    ** main window.
    */
    hIconVideoCd     = LoadIcon( hInstance, MAKEINTRESOURCE(IDR_VIDEOCD_ICON) );

    wc.style         = CS_VREDRAW | CS_HREDRAW;
    wc.lpfnWndProc   = VideoCdWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = hIconVideoCd;
    wc.hCursor       = LoadCursor( NULL, IDC_ARROW );
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszMenuName  = MAKEINTRESOURCE( IDR_MAIN_MENU);
    wc.lpszClassName = szClassName;

    OSVERSIONINFO OSVer;
    OSVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    BOOL bRet = GetVersionEx((LPOSVERSIONINFO) &OSVer);
    ASSERT(bRet);

    g_IsNT = (OSVer.dwPlatformId == VER_PLATFORM_WIN32_NT);

    g_szOtherStuff = InitAboutString();

    /*
    ** Register the window class and return success/failure code.
    */
    return RegisterClass( &wc );

}


/*****************************Private*Routine******************************\
* InitInstance
*
*
* This function is called at initialization time for every instance of
* this application.  This function performs initialization tasks that
* cannot be shared by multiple instances.
*
* In this case, we save the instance handle in a static variable and
* create and display the main program window.
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
InitInstance(
    HINSTANCE hInstance,
    int nCmdShow
    )
{
    HWND    hwnd;
    RECT    rc;
    POINT   pt;

    /*
    ** Save the instance handle in static variable, which will be used in
    ** many subsequence calls from this application to Windows.
    */
    hInst = hInstance;

    if ( ! LoadWindowPos(&rc))
       rc.left = rc.top = CW_USEDEFAULT;

    /*
    ** Create a main window for this application instance.
    */
    hwnd = CreateWindow( szClassName, IdStr(STR_APP_TITLE),
                         WS_THICKFRAME | WS_POPUP | WS_CAPTION  |
                         WS_SYSMENU | WS_MINIMIZEBOX,
                         rc.left, rc.top,
                         rc.right - rc.left, rc.bottom - rc.top,
                         NULL, NULL, hInstance, NULL );

    /*
    ** If window could not be created, return "failure"
    */
    if ( NULL == hwnd ) {
        return FALSE;
    }


    hwndApp = hwnd;
    nRecentFiles = GetRecentFiles(nRecentFiles);

    pt.x = lMovieOrgX =  ProfileIntIn(g_szMovieX, 0);
    pt.y = lMovieOrgY =  ProfileIntIn(g_szMovieY, 0);

    // if we fail to get the working area (screen-tray), then assume
    // the screen is 640x480
    //
    if (!SystemParametersInfo(SPI_GETWORKAREA, 0, &rc, FALSE)) {
        rc.top = rc.left = 0;
        rc.right = 640;
        rc.bottom = 480;
    }

    if (!PtInRect(&rc, pt)) {
        lMovieOrgX = lMovieOrgY = 0L;
    }


    /*
    ** Make the window visible; update its client area; and return "success"
    */
    SetPlayButtonsEnableState();
    ShowWindow( hwnd, nCmdShow );
    UpdateWindow( hwnd );

    return TRUE;
}


/******************************Public*Routine******************************\
* VideoCdWndProc
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
LRESULT CALLBACK
VideoCdWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch ( message ) {

    HANDLE_MSG( hwnd, WM_CREATE,            VideoCd_OnCreate );
    HANDLE_MSG( hwnd, WM_PAINT,             VideoCd_OnPaint );
    HANDLE_MSG( hwnd, WM_COMMAND,           VideoCd_OnCommand );
    HANDLE_MSG( hwnd, WM_CLOSE,             VideoCd_OnClose );
    HANDLE_MSG( hwnd, WM_QUERYENDSESSION,   VideoCd_OnQueryEndSession );
    HANDLE_MSG( hwnd, WM_DESTROY,           VideoCd_OnDestroy );
    HANDLE_MSG( hwnd, WM_SIZE,              VideoCd_OnSize );
    HANDLE_MSG( hwnd, WM_SYSCOLORCHANGE,    VideoCd_OnSysColorChange );
    HANDLE_MSG( hwnd, WM_MENUSELECT,        VideoCd_OnMenuSelect );
    HANDLE_MSG( hwnd, WM_INITMENUPOPUP,     VideoCd_OnInitMenuPopup );
    HANDLE_MSG( hwnd, WM_HSCROLL,           VideoCd_OnHScroll );
    HANDLE_MSG( hwnd, WM_TIMER,             VideoCd_OnTimer );
    HANDLE_MSG( hwnd, WM_NOTIFY,            VideoCd_OnNotify );
    HANDLE_MSG( hwnd, WM_DROPFILES,         VideoCd_OnDropFiles);
    HANDLE_MSG( hwnd, WM_KEYUP,             VideoCd_OnKeyUp);

    // Note: we do not use HANDLE_MSG here as we want to call
    // DefWindowProc after we have notifed the FilterGraph Resource Manager,
    // otherwise our window will not finish its activation process.

    case WM_ACTIVATE: VideoCd_OnActivate(hwnd, wParam, lParam);

	// IMPORTANT - let this drop through to DefWindowProc

    default:
        return DefWindowProc( hwnd, message, wParam, lParam );
    }

    return 0L;
}


/*****************************Private*Routine******************************\
* VideoCd_OnCreate
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
BOOL
VideoCd_OnCreate(
    HWND hwnd,
    LPCREATESTRUCT lpCreateStruct
    )
{
    RECT rc;
    int Pane[2];

    InitCommonControls();

    /*
    ** Create the toolbar and statusbar.
    */
    g_hwndToolbar = CreateToolbarEx( hwnd,
                                     WS_VISIBLE | WS_CHILD |
                                     TBSTYLE_TOOLTIPS | CCS_NODIVIDER,
                                     ID_TOOLBAR, NUMBER_OF_BITMAPS,
                                     hInst, IDR_TOOLBAR, tbButtons,
                                     DEFAULT_TBAR_SIZE, dxBitmap, dyBitmap,
                                     dxBitmap, dyBitmap, sizeof(TBBUTTON) );

    if ( g_hwndToolbar == NULL ) {
        return FALSE;
    }


    g_hwndStatusbar = CreateStatusWindow( WS_VISIBLE | WS_CHILD | CCS_BOTTOM,
                                          TEXT("Example Text"),
                                          hwnd, ID_STATUSBAR );

    GetWindowRect(g_hwndToolbar, &rc);
    dyToolbar = rc.bottom - rc.top;

    GetWindowRect(g_hwndStatusbar, &rc);
    dyStatusbar = rc.bottom - rc.top;

    dyTrackbar = 30;

    GetClientRect(hwnd, &rc);
    Pane[0] = (rc.right - rc.left) / 2 ;
    Pane[1] = -1;
    SendMessage(g_hwndStatusbar, SB_SETPARTS, 2, (LPARAM)Pane);


    g_hwndTrackbar = CreateWindowEx(0, TRACKBAR_CLASS, TEXT("Trackbar Control"),
                                    WS_CHILD | WS_VISIBLE |
                                    TBS_AUTOTICKS | TBS_ENABLESELRANGE,
                                    LEFT_MARGIN, dyToolbar - 1,
                                    (rc.right - rc.left) - (2* LEFT_MARGIN),
                                    dyTrackbar, hwnd, (HMENU)ID_TRACKBAR,
                                    hInst, NULL);

    SetDurationLength((REFTIME)0);
    SetCurrentPosition((REFTIME)0);

    SetTimer(hwnd, StatusTimer, 500, NULL);

    if (g_hwndStatusbar == NULL || g_hwndTrackbar == NULL) {
        return FALSE;
    }

    // accept filemanager WM_DROPFILES messages
    DragAcceptFiles(hwnd, TRUE);

    return TRUE;
}

/*****************************Private*Routine******************************\
* VideoCd_OnActivate
*
*
*
* History:
* 18/9/1996 - SteveDav - Created
*
\**************************************************************************/

void
VideoCd_OnActivate(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    )

{
    if ((UINT)LOWORD(wParam)) {
	// we are being activated - tell the Filter graph (for Sound follows focus)
        if (pMpegMovie) {
            pMpegMovie->SetFocus();
        }
    }
}

/*****************************Private*Routine******************************\
* VideoCd_OnKeyUp
*
*
*
* History:
* 23/3/1996 - AnthonyP - Created
*
\**************************************************************************/
void
VideoCd_OnKeyUp(
    HWND hwnd,
    UINT vk,
    BOOL fDown,
    int cRepeat,
    UINT flags
    )
{
    // Catch escape sequences to stop fullscreen mode

    if (vk == VK_ESCAPE) {
        if (pMpegMovie) {
            pMpegMovie->SetFullScreenMode(FALSE);
            SetPlayButtonsEnableState();
        }
    }
}


/*****************************Private*Routine******************************\
* VideoCd_OnHScroll
*
*
*
* History:
* 11/3/1995 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnHScroll(
    HWND hwnd,
    HWND hwndCtl,
    UINT code,
    int pos
    )
{
    static BOOL fWasPlaying = FALSE;
    static BOOL fBeginScroll = FALSE;

    if (pMpegMovie == NULL) {
        return;
    }

    if (hwndCtl == g_hwndTrackbar) {

        REFTIME     rtCurrPos;
        REFTIME     rtTrackPos;
        REFTIME     rtDuration;

        pos = (int)SendMessage(g_hwndTrackbar, TBM_GETPOS, 0, 0);
        rtTrackPos = (REFTIME)pos * g_TrackBarScale;

        switch (code) {
        case TB_BOTTOM:
            rtDuration = pMpegMovie->GetDuration();
            rtCurrPos = pMpegMovie->GetCurrentPosition();
            VcdPlayerSeekCmd(rtDuration - rtCurrPos);
            SetCurrentPosition(pMpegMovie->GetCurrentPosition());
            break;

        case TB_TOP:
            rtCurrPos = pMpegMovie->GetCurrentPosition();
            VcdPlayerSeekCmd(-rtCurrPos);
            SetCurrentPosition(pMpegMovie->GetCurrentPosition());
            break;

        case TB_LINEDOWN:
            VcdPlayerSeekCmd(10.0);
            SetCurrentPosition(pMpegMovie->GetCurrentPosition());
            break;

        case TB_LINEUP:
            VcdPlayerSeekCmd(-10.0);
            SetCurrentPosition(pMpegMovie->GetCurrentPosition());
            break;

        case TB_ENDTRACK:
            fBeginScroll = FALSE;
            if (fWasPlaying) {
                VcdPlayerPauseCmd();
                fWasPlaying = FALSE;
            }
            break;

        case TB_THUMBTRACK:
            if (!fBeginScroll) {
                fBeginScroll = TRUE;
                fWasPlaying = (g_State & VCD_PLAYING);
                if (fWasPlaying) {
                    VcdPlayerPauseCmd();
                }
            }
        case TB_PAGEUP:
        case TB_PAGEDOWN:
            rtCurrPos = pMpegMovie->GetCurrentPosition();
            VcdPlayerSeekCmd(rtTrackPos - rtCurrPos);
            SetCurrentPosition(pMpegMovie->GetCurrentPosition());
            break;
        }
    }
}


/*****************************Private*Routine******************************\
* VideoCd_OnTimer
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnTimer(
    HWND hwnd,
    UINT id
    )
{
    HDC     hdc;

    if (pMpegMovie && pMpegMovie->StatusMovie() == MOVIE_PLAYING) {

        switch (id) {
        case StatusTimer:
            SetCurrentPosition(pMpegMovie->GetCurrentPosition());
            break;

        case PerformanceTimer:
            hdc = GetDC(hwnd);
            DrawStats(hdc);
            ReleaseDC(hwnd, hdc);
            break;
        }
    }
}


/*****************************Private*Routine******************************\
* DrawStats
*
* Gets some stats from the decoder and displays them on the display.
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
BOOL
DrawStats(
    HDC hdc
    )
{
    HFONT   hFont;

    TCHAR   Text[1024];
    TCHAR   szSurface[64];

    RECT    rc;

    DWORD   IFramesDecoded;
    DWORD   PFramesDecoded;
    DWORD   BFramesDecoded;
    DWORD   IFramesSkipped;
    DWORD   PFramesSkipped;
    DWORD   BFramesSkipped;

    DWORD   dwTotalFrames;
    DWORD   dwTotalDecoded;
    DWORD   dwSurface;

    int     cFramesDropped;
    int     cFramesDrawn;
    int     iAvgFrameRate;
    int     iAvgFrameRateFraction;
    int     iAvgFrameRateWhole;
    int     iJitter;
    int     iSyncAvg;
    int     iSyncDev;

    BOOL    fClipped;
    BOOL    fHalfWidth;

    if (pMpegMovie == NULL) {
        return FALSE;
    }

    GetAdjustedClientRect(&rc);
    hFont = (HFONT)SelectObject(hdc, GetStockObject(ANSI_FIXED_FONT));

    if (pMpegMovie->pMpegDecoder) {
        pMpegMovie->pMpegDecoder->get_OutputFormat(&dwSurface);
        pMpegMovie->pMpegDecoder->get_FrameStatistics(
                                           &IFramesDecoded, &PFramesDecoded,
                                           &BFramesDecoded, &IFramesSkipped,
                                           &PFramesSkipped, &BFramesSkipped);
    }
    else {
        IFramesDecoded = PFramesDecoded = BFramesDecoded = 0;
        IFramesSkipped = PFramesSkipped = BFramesSkipped = 0;
        dwSurface = MM_RGB8_DIB;
    }

    fClipped = ((dwSurface & MM_CLIPPED) == MM_CLIPPED);
    fHalfWidth = ((dwSurface & MM_HRESOLUTION) == MM_HRESOLUTION);

    dwSurface &= ~(MM_HRESOLUTION | MM_CLIPPED);
    switch (dwSurface) {

    case MM_NOCONV:
        lstrcpy(szSurface, TEXT("MM_NOCONV"));
        break;

    case MM_420PL:
        lstrcpy(szSurface, TEXT("MM_420PL"));
        break;

    case MM_420PL_:
        lstrcpy(szSurface, TEXT("MM_420PL_"));
        break;

    case MM_422PK:
        lstrcpy(szSurface, TEXT("MM_422PK"));
        break;

    case MM_422PK_:
        lstrcpy(szSurface, TEXT("MM_422PK_"));
        break;

    case MM_422SPK:
        lstrcpy(szSurface, TEXT("MM_422SPK"));
        break;

    case MM_422SPK_:
        lstrcpy(szSurface, TEXT("MM_422SPK_"));
        break;

    case MM_411PK:
        lstrcpy(szSurface, TEXT("MM_411PK"));
        break;

    case MM_410PL_:
        lstrcpy(szSurface, TEXT("MM_410PL_"));
        break;

    case MM_Y_DIB:
        lstrcpy(szSurface, TEXT("MM_Y_DIB"));
        break;

    case MM_RGB24_DIB:
        lstrcpy(szSurface, TEXT("MM_RGB24_DIB"));
        break;

    case MM_RGB32_DIB:
        lstrcpy(szSurface, TEXT("MM_RGB32_DIB"));
        break;

    case MM_RGB565_DIB:
        lstrcpy(szSurface, TEXT("MM_RGB565_DIB"));
        break;

    case MM_RGB555_DIB:
        lstrcpy(szSurface, TEXT("MM_RGB555_DIB"));
        break;

    case MM_RGB8_DIB:
        lstrcpy(szSurface, TEXT("MM_RGB8_DIB"));
        break;

    case MM_Y_DDB:
        lstrcpy(szSurface, TEXT("MM_Y_DDB"));
        break;

    case MM_RGB24_DDB:
        lstrcpy(szSurface, TEXT("MM_RGB24_DDB"));
        break;

    case MM_RGB32_DDB:
        lstrcpy(szSurface, TEXT("MM_RGB32_DDB"));
        break;

    case MM_RGB565_DDB:
        lstrcpy(szSurface, TEXT("MM_RGB565_DDB"));
        break;

    case MM_RGB555_DDB:
        lstrcpy(szSurface, TEXT("MM_RGB555_DDB"));
        break;

    case MM_RGB8_DDB:
        lstrcpy(szSurface, TEXT("MM_RGB8_DDB"));
        break;
    }

    if (fHalfWidth) {
        lstrcat(szSurface, TEXT(" Decimated"));
    }

    if (fClipped) {
        lstrcat(szSurface, TEXT(" Clipped"));
    }

    dwTotalDecoded = IFramesDecoded + PFramesDecoded + BFramesDecoded;
    dwTotalFrames  = IFramesSkipped + PFramesSkipped + BFramesSkipped
                     + dwTotalDecoded;


    if (pMpegMovie->pVideoRenderer) {

        pMpegMovie->pVideoRenderer->get_FramesDroppedInRenderer(&cFramesDropped);
        pMpegMovie->pVideoRenderer->get_FramesDrawn(&cFramesDrawn);
        pMpegMovie->pVideoRenderer->get_AvgFrameRate(&iAvgFrameRate);
        iAvgFrameRateWhole    = iAvgFrameRate / 100;
        iAvgFrameRateFraction = iAvgFrameRate % 100;
        pMpegMovie->pVideoRenderer->get_Jitter(&iJitter);
        pMpegMovie->pVideoRenderer->get_AvgSyncOffset(&iSyncAvg);
        pMpegMovie->pVideoRenderer->get_DevSyncOffset(&iSyncDev);
    }
    else {

        cFramesDropped = 0;
        cFramesDrawn = 0;
        iAvgFrameRate = 0;
        iAvgFrameRateWhole = 0;
        iAvgFrameRateFraction = 0;
        iJitter = 0;
        iSyncAvg = 0;
        iSyncDev = 0;
    }


    wsprintf(Text,
            TEXT("Decoded %08.8ld out of %08.8ld frames\r\n")
            TEXT("Proportion decoded = %d%%\r\n")
            TEXT("Avg Frame Rate = %d.%02d fps\r\n")
            TEXT("Frames drawn by renderer = %d\r\n")
            TEXT("Frames dropped by renderer = %d\r\n")
            TEXT("Frame jitter = %4d mSec\r\n")
            TEXT("Avg Sync Offset (neg = early) = %4d mSec\r\n")
            TEXT("Std Dev Sync Offset = %4d mSec\r\n")
            TEXT("Surface type = %s\r\n")
            TEXT("I Frames: Decoded %8.8ld Skipped %8.8ld\r\n")
            TEXT("P Frames: Decoded %8.8ld Skipped %8.8ld\r\n")
            TEXT("B Frames: Decoded %8.8ld Skipped %8.8ld\r\n"),
             dwTotalDecoded, dwTotalFrames,
             (100 * dwTotalDecoded) / (dwTotalFrames ? dwTotalFrames : 1),
             iAvgFrameRateWhole, iAvgFrameRateFraction,
             cFramesDrawn, cFramesDropped,
             iJitter, iSyncAvg, iSyncDev,
             szSurface,
             IFramesDecoded, IFramesSkipped,
             PFramesDecoded, PFramesSkipped,
             BFramesDecoded, BFramesSkipped);

    COLORREF clr = SetBkColor(hdc, GetSysColor(COLOR_BTNFACE));
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
    DrawText(hdc, Text, -1, &rc, DT_LEFT | DT_BOTTOM);
    SetBkColor(hdc, clr);

    SelectObject(hdc, hFont);
    return TRUE;
}


/*****************************Private*Routine******************************\
* VideoCd_OnPaint
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnPaint(
    HWND hwnd
    )
{
    PAINTSTRUCT ps;
    HDC         hdc;
    RECT        rc;

    /*
    ** Draw a frame around the movie playback area.
    */
    hdc = BeginPaint( hwnd, &ps );
    if (!DrawStats(hdc)) {
        GetClientRect(hwnd, &rc);
        FillRect(hdc, &rc, (HBRUSH)(COLOR_BTNFACE + 1));
    }
    EndPaint( hwnd, &ps );
}


/*****************************Private*Routine******************************\
* VideoCd_OnCommand
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnCommand(
    HWND hwnd,
    int id,
    HWND hwndCtl,
    UINT codeNotify
    )
{
    switch (id) {

    case IDM_FILE_SET_LOG:
        VcdPlayerSetLog();    // set RenderFile log
        break;

    case IDM_FILE_SET_PERF_LOG:
        VcdPlayerSetPerfLogFile();    // set perf log
        break;

    case IDM_FILE_OPEN:
        VcdPlayerOpenCmd();
        break;

    case IDM_FILE_CLOSE:
        VcdPlayerCloseCmd();
        QzFreeUnusedLibraries();
        break;

    case IDM_FILE_EXIT:
        PostMessage( hwnd, WM_CLOSE, 0, 0L );
        break;

    case IDM_MOVIE_PLAY:
        VcdPlayerPlayCmd();
        break;

    case IDM_MOVIE_STOP:
        VcdPlayerStopCmd();
        break;

    case IDM_MOVIE_PAUSE:
        VcdPlayerPauseCmd();
        break;

    case IDM_MOVIE_SKIP_FORE:
        VcdPlayerSeekCmd(1.0);
        break;

    case IDM_MOVIE_SKIP_BACK:
        VcdPlayerSeekCmd(-1.0);
        break;

    case IDM_MOVIE_PREVTRACK:
        if (pMpegMovie) {
            VcdPlayerSeekCmd(-pMpegMovie->GetCurrentPosition());
        }
        break;

    case IDM_TIME:
    case IDM_FRAME:
    case IDM_FIELD:
    case IDM_SAMPLE:
    case IDM_BYTES:
        if (pMpegMovie) {
            g_TimeFormat = VcdPlayerChangeTimeFormat(id);
        }
        break;

    case IDM_MOVIE_NEXTTRACK:
        if (pMpegMovie) {
            REFTIME rtDur = pMpegMovie->GetDuration();
            REFTIME rtPos = pMpegMovie->GetCurrentPosition();
            VcdPlayerSeekCmd(rtDur - rtPos);
        }
        break;

    case IDM_PERF_NEW:
        if (lpControlProc) (*lpControlProc)(MSR_RESET_ALL);
        break;

    case IDM_PERF_DUMP:
        if (lpDumpProc) {

            HANDLE hFile;
            hFile = CreateFile(g_szPerfLog, GENERIC_WRITE, 0, NULL,
                               CREATE_ALWAYS, 0, NULL);
            (*lpDumpProc)(hFile);
            CloseHandle(hFile);
        }
        break;

    case IDM_FULL_SCREEN:
        if (pMpegMovie) {
            BOOL bFullScreen = (BOOL) SendMessage( g_hwndToolbar, TB_ISBUTTONCHECKED, IDM_FULL_SCREEN, 0 );
            pMpegMovie->SetFullScreenMode(bFullScreen);
        }
        break;

    case IDM_VIDEO_DECODER:
        DoMpegVideoPropertyPage();
        break;

    case IDM_AUDIO_DECODER:
        DoMpegAudioPropertyPage();
        break;

    case IDM_FILTERS:
        if (pMpegMovie) {
            pMpegMovie->ConfigDialog(hwnd);
        }
        break;

    case IDM_MOVIE_ALIGN:
        {
            RECT rc, rcWnd;
            HWND hwndRenderer = FindWindow(TEXT("VideoRenderer"), NULL);
            if (hwndRenderer) {
                GetClientRect(hwndRenderer, &rc);
                GetWindowRect(hwndRenderer, &rcWnd);

                MapWindowPoints(hwndRenderer, HWND_DESKTOP, (LPPOINT)&rc, 2);
                rcWnd.left -= rc.left & 3;
                rcWnd.top  -= rc.top  & 3;

                SetWindowPos(hwndRenderer, NULL, rcWnd.left, rcWnd.top, 0, 0,
                             SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOZORDER);
            }
        }
        break;

    case IDM_HELP_ABOUT:
        {
            TCHAR  szApp[STR_MAX_STRING_LEN];
            TCHAR  szOtherStuff[STR_MAX_STRING_LEN];

            lstrcpy( szApp, IdStr(STR_APP_TITLE) );
            lstrcat( szApp, TEXT("#") );
            if (g_IsNT)
		lstrcat( szApp, TEXT("Windows NT") );
	    // for some reason ShellAbout prints OS uner Win95 but not NT
	    // else
	    //	strcat( szApp, "Windows 95" );
            lstrcpy( szOtherStuff, IdStr(STR_APP_TITLE) );
            lstrcat( szOtherStuff, TEXT("\n") );
            lstrcat( szOtherStuff, g_szOtherStuff );
            ShellAbout( hwnd, szApp, szOtherStuff, hIconVideoCd );
        }
        break;

    default:
        if (id > ID_RECENT_FILE_BASE
         && id <= (ID_RECENT_FILE_BASE + MAX_RECENT_FILES + 1)) {

            ProcessOpen(aRecentFiles[id - ID_RECENT_FILE_BASE - 1]);
        } else if (id >= 2000 && id <= 2050) {
	    pMpegMovie->SelectStream(id - 2000);
	}
	break;
	
    }

    SetPlayButtonsEnableState();
}




/******************************Public*Routine******************************\
* VideoCd_OnDestroy
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnDestroy(
    HWND hwnd
    )
{
    PostQuitMessage( 0 );
}




/******************************Public*Routine******************************\
* VideoCd_OnClose
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnClose(
    HWND hwnd
    )
{

    // stop accepting dropped filenames
    DragAcceptFiles(hwnd, FALSE);

    VcdPlayerCloseCmd();
    ProfileIntOut(g_szMovieX, lMovieOrgX);
    ProfileIntOut(g_szMovieY, lMovieOrgY);

    SaveWindowPos( hwnd );
    DestroyWindow( hwnd );
}

BOOL
VideoCd_OnQueryEndSession(
    HWND hwnd
    )
{
    SaveWindowPos( hwnd );
    return TRUE;
}


/******************************Public*Routine******************************\
* VideoCd_OnSize
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnSize(
    HWND hwnd,
    UINT state,
    int dx,
    int dy
    )
{
    if (IsWindow(g_hwndStatusbar)) {

        int Pane[2] = {dx/2-8, -1};

        SendMessage(g_hwndStatusbar, WM_SIZE, 0, 0L);
        SendMessage(g_hwndStatusbar, SB_SETPARTS, 2, (LPARAM)Pane);
    }

    if (IsWindow(g_hwndTrackbar)) {
        SetWindowPos(g_hwndTrackbar, HWND_TOP, LEFT_MARGIN, dyToolbar - 1,
                     dx - (2 * LEFT_MARGIN), dyTrackbar, SWP_NOZORDER );
    }

    if (IsWindow(g_hwndToolbar)) {
        SendMessage( g_hwndToolbar, WM_SIZE, 0, 0L );
    }
}


/*****************************Private*Routine******************************\
* VideoCd_OnSysColorChange
*
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnSysColorChange(
    HWND hwnd
    )
{
    FORWARD_WM_SYSCOLORCHANGE(g_hwndToolbar, SendMessage);
    FORWARD_WM_SYSCOLORCHANGE(g_hwndStatusbar, SendMessage);
}




/*****************************Private*Routine******************************\
* VideoCd_OnInitMenuPopup
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnInitMenuPopup(
    HWND hwnd,
    HMENU hMenu,
    UINT item,
    BOOL fSystemMenu
    )
{
    UINT uFlags;

    switch (item) {

    case 0: // File menu
        if (g_State & (VCD_IN_USE | VCD_NO_CD | VCD_DATA_CD_LOADED)) {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        EnableMenuItem(hMenu, IDM_FILE_CLOSE, uFlags );

        if (lpControlProc == NULL) {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        EnableMenuItem(hMenu, IDM_FILE_SET_PERF_LOG, uFlags );
        break;

    case 1: // Properties menu
        if (pMpegMovie && pMpegMovie->pMpegDecoder) {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        EnableMenuItem(hMenu, IDM_VIDEO_DECODER, uFlags );

        if (pMpegMovie && pMpegMovie->pMpegAudioDecoder) {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        EnableMenuItem(hMenu, IDM_AUDIO_DECODER, uFlags );

        if (pMpegMovie) {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        EnableMenuItem(hMenu, IDM_FILTERS, uFlags );
        break;

    case 2: // Time formats menu

        // Can only change time format when stopped
    {
        EMpegMovieMode State = MOVIE_NOTOPENED;
        if (pMpegMovie) {
            State = pMpegMovie->StatusMovie();
        }
	

        if (State && pMpegMovie->IsTimeSupported()) {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        EnableMenuItem(hMenu, IDM_TIME, uFlags );

        if (State && pMpegMovie->IsTimeFormatSupported(TIME_FORMAT_FRAME)) {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        EnableMenuItem(hMenu, IDM_FRAME, uFlags );

        if (State && pMpegMovie->IsTimeFormatSupported(TIME_FORMAT_FIELD)) {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        EnableMenuItem(hMenu, IDM_FIELD, uFlags );

        if (State && pMpegMovie->IsTimeFormatSupported(TIME_FORMAT_SAMPLE)) {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        EnableMenuItem(hMenu, IDM_SAMPLE, uFlags );

        if (State && pMpegMovie->IsTimeFormatSupported(TIME_FORMAT_BYTE)) {
            uFlags = (MF_BYCOMMAND | MF_ENABLED);
        }
        else {
            uFlags = (MF_BYCOMMAND | MF_GRAYED);
        }
        EnableMenuItem(hMenu, IDM_BYTES, uFlags );

        CheckMenuItem(hMenu, IDM_BYTES, MF_BYCOMMAND | MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_SAMPLE, MF_BYCOMMAND | MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_FRAME, MF_BYCOMMAND | MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_FIELD, MF_BYCOMMAND | MF_UNCHECKED);
        CheckMenuItem(hMenu, IDM_TIME, MF_BYCOMMAND | MF_UNCHECKED);
        CheckMenuItem(hMenu, g_TimeFormat, MF_BYCOMMAND | MF_CHECKED);
    }
	break;
	
    case 3: // streams menu

	if (pMpegMovie && pMpegMovie->m_pStreamSelect) {
	    DWORD	cStreams;

	    pMpegMovie->m_pStreamSelect->Count(&cStreams);

	    for (DWORD i = 0; i < cStreams; i++) {
		DWORD dwFlags;
		
		pMpegMovie->m_pStreamSelect->Info(i, NULL, &dwFlags, NULL, NULL, NULL, NULL, NULL);

		CheckMenuItem(hMenu, 2000+i, MF_BYCOMMAND |
			      ((dwFlags & AMSTREAMSELECTINFO_ENABLED) ? MF_CHECKED : MF_UNCHECKED));
	    }
	}
	
        break;
    }
}


/*****************************Private*Routine******************************\
* VideoCd_OnGraphNotify
*
* This is where we get any notifications from the filter graph.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnGraphNotify(
    void
    )
{
    long    lEventCode;
    HDC     hdc;

    lEventCode = pMpegMovie->GetMovieEventCode();
    switch (lEventCode) {
    case EC_FULLSCREEN_LOST:
        pMpegMovie->SetFullScreenMode(FALSE);
        SetPlayButtonsEnableState();
        break;

    case EC_COMPLETE:
    case EC_USERABORT:
    case EC_ERRORABORT:
        VcdPlayerStopCmd();
        SetPlayButtonsEnableState();
        hdc = GetDC(hwndApp);
        DrawStats(hdc);
        ReleaseDC(hwndApp, hdc);
        break;

    default:
        break;
    }
}


/*****************************Private*Routine******************************\
* VideoCd_OnNotify
*
* This is where we get the text for the little tooltips
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
LRESULT
VideoCd_OnNotify(
    HWND hwnd,
    int idFrom,
    NMHDR FAR* pnmhdr
    )
{
    switch (pnmhdr->code) {

    case TTN_NEEDTEXT:
        {
            LPTOOLTIPTEXT   lpTt;

            lpTt = (LPTOOLTIPTEXT)pnmhdr;
            LoadString( hInst, (UINT) lpTt->hdr.idFrom, lpTt->szText,
                        sizeof(lpTt->szText) );
        }
        break;
    }

    return 0;
}




/*****************************Private*Routine******************************\
* VideoCd_OnMenuSelect
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
void
VideoCd_OnMenuSelect(
    HWND hwnd,
    HMENU hmenu,
    int item,
    HMENU hmenuPopup,
    UINT flags
    )
{

    TCHAR szString[STR_MAX_STRING_LEN + 1];

    /*
    ** Is it time to end the menu help ?
    */

    if ( (flags == 0xFFFFFFFF) && (hmenu == NULL) ) {

        SendMessage(g_hwndStatusbar, SB_SIMPLE, 0, 0L);
    }

    /*
    ** Do we have a separator, popup or the system menu ?
    */
    else if ( flags & MF_POPUP ) {

        SendMessage(g_hwndStatusbar, SB_SIMPLE, 0, 0L);
    }

    else if (flags & MF_SYSMENU) {

        switch (item) {

        case SC_RESTORE:
            lstrcpy( szString, IdStr(STR_SYSMENU_RESTORE) );
            break;

        case SC_MOVE:
            lstrcpy( szString, IdStr(STR_SYSMENU_MOVE) );
            break;

        case SC_MINIMIZE:
            lstrcpy( szString, IdStr(STR_SYSMENU_MINIMIZE) );
            break;

        case SC_MAXIMIZE:
            lstrcpy( szString, IdStr(STR_SYSMENU_MAXIMIZE) );
            break;

        case SC_TASKLIST:
            lstrcpy( szString, IdStr(STR_SYSMENU_TASK_LIST) );
            break;

        case SC_CLOSE:
            lstrcpy( szString, IdStr(STR_SYSMENU_CLOSE) );
            break;
        }

        SendMessage( g_hwndStatusbar, SB_SETTEXT, SBT_NOBORDERS|255,
                     (LPARAM)(LPTSTR)szString );
        SendMessage( g_hwndStatusbar, SB_SIMPLE, 1, 0L );
        UpdateWindow(g_hwndStatusbar);

    }

    /*
    ** Hopefully its one of ours
    */
    else {

        if ((flags & MF_SEPARATOR)) {

            szString[0] = g_chNULL;
        }
        else {

            lstrcpy( szString, IdStr(item + MENU_STRING_BASE) );

        }

        SendMessage( g_hwndStatusbar, SB_SETTEXT, SBT_NOBORDERS|255,
                     (LPARAM)(LPTSTR)szString );
        SendMessage( g_hwndStatusbar, SB_SIMPLE, 1, 0L );
        UpdateWindow(g_hwndStatusbar);
    }
}

/*****************************Private*Routine******************************\
* VideoCd_OnDropFiles
*
* -- handle a file-manager drop of a filename to indicate a movie we should
*    open.
*
*
* History:
* 22-01-96 - GeraintD - Created
*
\**************************************************************************/
void
VideoCd_OnDropFiles(
    HWND hwnd,
    HDROP hdrop)
{
    // if there is more than one file, simply open the first one

    // find the length of the path (plus the null
    int cch = DragQueryFile(hdrop, 0, NULL, 0) + 1;
    TCHAR * pName = new TCHAR[cch];

    DragQueryFile(hdrop, 0, pName, cch);

    // open the file
    ProcessOpen(pName);

    // update the toolbar state
    SetPlayButtonsEnableState();

    // free up used resources
    delete [] pName;
    DragFinish(hdrop);
}


/******************************Public*Routine******************************\
* SetPlayButtonsEnableState
*
* Sets the play buttons enable state to match the state of the current
* cdrom device.  See below...
*
*
*                 VCD Player buttons enable state table
* 
* E=Enabled D=Disabled       Play  Pause  Eject  Stop   Other 
* 
* Disk in use                 D     D      D       D      D   
* 
* No video cd or data cdrom   D     D      E       D      D   
* 
* Video cd (playing)          D     E      E       E      E   
* 
* Video cd (paused)           E     D      E       E      E   
* 
* Video cd (stopped)          E     D      E       D      E   
* 
*
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
void
SetPlayButtonsEnableState(
    void
    )
{
    BOOL    fEnable, fPress;
    BOOL    fVideoCdLoaded;

    /*
    ** Do we have a video cd loaded.
    */
    if (g_State & (VCD_NO_CD | VCD_DATA_CD_LOADED | VCD_IN_USE)) {
        fVideoCdLoaded = FALSE;
    }
    else {
        fVideoCdLoaded = TRUE;
    }


    /*
    ** Do the play button
    */
    if ( fVideoCdLoaded
      && ((g_State & VCD_STOPPED) || (g_State & VCD_PAUSED))) {

        fEnable = TRUE;
    }
    else {
        fEnable = FALSE;
    }
    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON, IDM_MOVIE_PLAY, fEnable );


    /*
    ** Do the stop button
    */
    if ( fVideoCdLoaded
      && ((g_State & VCD_PLAYING) || (g_State & VCD_PAUSED))) {

        fEnable = TRUE;
    }
    else {
        fEnable = FALSE;
    }
    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON, IDM_MOVIE_STOP, fEnable );


    /*
    ** Do the pause button
    */
    if ( fVideoCdLoaded && (g_State & VCD_PLAYING) ) {
        fEnable = TRUE;
    }
    else {
        fEnable = FALSE;
    }
    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON, IDM_MOVIE_PAUSE, fEnable );


    /*
    ** Do the remaining buttons
    */

    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON,
                 IDM_MOVIE_SKIP_FORE, fVideoCdLoaded );

    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON,
                 IDM_MOVIE_SKIP_BACK, fVideoCdLoaded );

    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON,
                 IDM_MOVIE_NEXTTRACK, fVideoCdLoaded );

    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON,
                 IDM_MOVIE_PREVTRACK, fVideoCdLoaded );


    /*
    ** Do the fullscreen button
    */
    if ( fVideoCdLoaded && pMpegMovie->IsFullScreenMode() ) {
        fPress = TRUE;
    }
    else {
        fPress = FALSE;
    }
    SendMessage( g_hwndToolbar, TB_CHECKBUTTON, IDM_FULL_SCREEN, MAKELONG(fPress,0) );
    SendMessage( g_hwndToolbar, TB_ENABLEBUTTON, IDM_FULL_SCREEN, fVideoCdLoaded );


    //
    // do "new log" and "dump log" buttons
    //
    SendMessage( g_hwndToolbar, TB_HIDEBUTTON,
                 IDM_PERF_NEW, lpControlProc == NULL);

    SendMessage( g_hwndToolbar, TB_HIDEBUTTON,
                 IDM_PERF_DUMP, lpDumpProc == NULL);
}


/*****************************Private*Routine******************************\
* GetAdjustedClientRect
*
* Calculate the size of the client rect and then adjusts it to take into
* account the space taken by the toolbar and status bar.
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
GetAdjustedClientRect(
    RECT *prc
    )
{
    RECT    rcTool;

    GetClientRect(hwndApp, prc);

    GetWindowRect(g_hwndToolbar, &rcTool);
    prc->top += (rcTool.bottom - rcTool.top);

    GetWindowRect(g_hwndTrackbar, &rcTool);
    prc->top += (rcTool.bottom - rcTool.top);

    GetWindowRect(g_hwndStatusbar, &rcTool);
    prc->bottom -= (rcTool.bottom - rcTool.top);
}


/******************************Public*Routine******************************\
* IdStr
*
* Loads the given string resource ID into the passed storage.
*
* History:
* 18-11-93 - StephenE - Created
*
\**************************************************************************/
LPCTSTR
IdStr(
    int idResource
    )
{
    static TCHAR    chBuffer[ STR_MAX_STRING_LEN ];

    if (LoadString(hInst, idResource, chBuffer, STR_MAX_STRING_LEN) == 0) {
        return g_szEmpty;
    }

    return chBuffer;

}

/*+ GetAppKey
 *
 *-=================================================================*/

static TCHAR cszWindow[] = TEXT("Window");
static TCHAR cszAppKey[] = TEXT("Software\\Microsoft\\Multimedia Tools\\VCDPlayer");

HKEY
GetAppKey(
    BOOL fCreate
    )
{
    HKEY hKey = 0;

    if (fCreate) {
       if (RegCreateKey(HKEY_CURRENT_USER, cszAppKey, &hKey) == ERROR_SUCCESS)
          return hKey;
    }
    else {
       if (RegOpenKey(HKEY_CURRENT_USER, cszAppKey, &hKey) == ERROR_SUCCESS)
          return hKey;
    }

    return NULL;
}

/*+ ProfileIntIn
 *
 *-=================================================================*/

int
ProfileIntIn(
    const TCHAR *szKey,
    int iDefault
    )
{
    DWORD dwType;
    int   iValue;
    BYTE  aData[20];
    DWORD cb;
    HKEY  hKey;

    if (!(hKey = GetAppKey(TRUE))) {
        return iDefault;
    }

    *(UINT *)&aData = 0;
    cb = sizeof(aData);

    if (RegQueryValueEx (hKey, szKey, NULL, &dwType, aData, &cb)) {
       iValue = iDefault;
    }
    else {

        if (dwType == REG_DWORD || dwType == REG_BINARY) {
            iValue = *(int *)&aData;
        }
        else if (dwType == REG_SZ) {
            iValue = _ttoi((LPTSTR)aData);
        }
    }

    RegCloseKey (hKey);
    return iValue;
}


/*+ ProfileIntOut
 *
 *-=================================================================*/

BOOL
ProfileIntOut (
    const TCHAR *szKey,
    int iVal
    )
{
    HKEY  hKey;
    BOOL  bRet = FALSE;

    hKey = GetAppKey(TRUE);
    if (hKey) {
        RegSetValueEx(hKey, szKey, 0, REG_DWORD, (LPBYTE)&iVal, sizeof(DWORD));
        RegCloseKey (hKey);
        bRet = TRUE;
    }
    return bRet;
}


/*+ ProfileString
 *
 *-=================================================================*/

UINT
ProfileStringIn (
    LPTSTR  szKey,
    LPTSTR  szDef,
    LPTSTR  sz,
    DWORD   cb
    )
{
    HKEY  hKey;
    DWORD dwType;

    if (!(hKey = GetAppKey (FALSE)))
    {
        lstrcpy (sz, szDef);
        return lstrlen (sz);
    }

    if (RegQueryValueEx(hKey, szKey, NULL, &dwType, (LPBYTE)sz, &cb) || dwType != REG_SZ)
    {
        lstrcpy (sz, szDef);
        cb = lstrlen (sz);
    }

    RegCloseKey (hKey);
    return cb;
}

void
ProfileStringOut (
    LPTSTR  szKey,
    LPTSTR  sz
    )
{
    HKEY  hKey;

    hKey = GetAppKey(TRUE);
    if (hKey)
        RegSetValueEx(hKey, szKey, 0, REG_SZ, (LPBYTE)sz, lstrlen(sz)+1);

    RegCloseKey (hKey);
}


/*+ LoadWindowPos
 *
 * retrieve the window position information from dragn.ini
 *
 *-=================================================================*/

#ifndef SPI_GETWORKAREA
 #define SPI_GETWORKAREA 48  // because NT doesnt have this define yet
#endif

BOOL
LoadWindowPos(
    LPRECT lprc
    )
{
    static RECT rcDefault = {0,0,CX_DEFAULT,CY_DEFAULT};
    RECT  rcScreen;
    RECT  rc;
    HKEY  hKey = GetAppKey(FALSE);

    // read window placement from the registry.
    //
    *lprc = rcDefault;
    if (hKey)
    {
        DWORD cb;
        DWORD dwType;

        cb = sizeof(rc);
        if ( ! RegQueryValueEx(hKey, cszWindow, NULL, &dwType, (LPBYTE)&rc, &cb)
            && dwType == REG_BINARY && cb == sizeof(RECT))
        {
            *lprc = rc;
        }

        RegCloseKey (hKey);
    }

    // if we fail to get the working area (screen-tray), then assume
    // the screen is 640x480
    //
    if ( ! SystemParametersInfo(SPI_GETWORKAREA, 0, &rcScreen, FALSE))
    {
        rcScreen.top = rcScreen.left = 0;
        rcScreen.right = 640;
        rcScreen.bottom = 480;
    }

    // if the proposed window position is outside the screen,
    // use the default placement
    //
    if ( ! IntersectRect(&rc, &rcScreen, lprc)) {
        *lprc = rcDefault;
    }

    return ! IsRectEmpty (lprc);
}


/*+ SaveWindowPos
 *
 * store the window position information in dragn.ini
 *
 *-=================================================================*/

BOOL
SaveWindowPos(
    HWND hwnd
    )
{
    WINDOWPLACEMENT wpl;
    HKEY  hKey = GetAppKey(TRUE);

    if (!hKey) {
       return FALSE;
    }

    // save the current size and position of the window to the registry
    //
    ZeroMemory (&wpl, sizeof(wpl));
    wpl.length = sizeof(wpl);
    GetWindowPlacement (hwnd, &wpl);


    RegSetValueEx( hKey, cszWindow, 0, REG_BINARY,
                   (LPBYTE)&wpl.rcNormalPosition,
                   sizeof(wpl.rcNormalPosition));

    RegCloseKey (hKey);
    return TRUE;
}


/*****************************Private*Routine******************************\
* GetRecentFiles
*
* Reads at most MAX_RECENT_FILES from vcdplyer.ini. Returns the number
* of files actually read.  Updates the File menu to show the "recent" files.
*
* History:
* 26-10-95 - StephenE - Created
*
\**************************************************************************/
int
GetRecentFiles(
    int iLastCount
    )
{
    int     i;
    TCHAR   FileName[MAX_PATH];
    TCHAR   szKey[32];
    HMENU   hSubMenu;

    //
    // Delete the files from the menu
    //
    hSubMenu = GetSubMenu(GetMenu(hwndApp), 0);

    // Delete the separator at slot 2 and all the other recent file entries

    if (iLastCount != 0) {
        DeleteMenu(hSubMenu, 2, MF_BYPOSITION);

        for (i = 1; i <= iLastCount; i++) {
            DeleteMenu(hSubMenu, ID_RECENT_FILE_BASE + i, MF_BYCOMMAND);
        }
    }


    for (i = 1; i <= MAX_RECENT_FILES; i++) {

        DWORD   len;
        TCHAR   szMenuName[MAX_PATH + 3];

        wsprintf(szKey, TEXT("File %d"), i);
        len = ProfileStringIn(szKey, TEXT(""), FileName, MAX_PATH);
        if (len == 0) {
            i = i - 1;
            break;
        }

        lstrcpy(aRecentFiles[i - 1], FileName);
        wsprintf(szMenuName, TEXT("&%d %s"), i, FileName);

        if (i == 1) {
            InsertMenu(hSubMenu, 2, MF_SEPARATOR | MF_BYPOSITION, (UINT)-1, NULL );
        }

        InsertMenu(hSubMenu, 2 + i, MF_STRING | MF_BYPOSITION,
                   ID_RECENT_FILE_BASE + i, szMenuName );
    }

    //
    // i is the number of recent files in the array.
    //
    return i;
}


/*****************************Private*Routine******************************\
* SetRecentFiles
*
* Writes the most recent files to the vcdplyer.ini file.  Purges the oldest
* file if necessary.
*
* History:
* 26-10-95 - StephenE - Created
*
\**************************************************************************/
int
SetRecentFiles(
    TCHAR *FileName,    // File name to add
    int iCount          // Current count of files
    )
{
    TCHAR   FullPathFileName[MAX_PATH];
    TCHAR   *lpFile;
    TCHAR   szKey[32];
    int     iCountNew;
    int     i;

    //
    // Check for dupes - we don't allow them !
    //
    for (i = 0; i < iCount; i++) {
        if (0 == lstrcmpi(FileName, aRecentFiles[i])) {
            return iCount;
        }
    }

    //
    // Throw away the oldest entry
    //
    MoveMemory(&aRecentFiles[1], &aRecentFiles[0],
               sizeof(aRecentFiles) - sizeof(aRecentFiles[1]));

    //
    // Copy in the full path of the new file.
    //
    GetFullPathName(FileName, MAX_PATH, FullPathFileName, &lpFile);
    lstrcpy(aRecentFiles[0], FullPathFileName);

    //
    // Update the count of files, saturate to MAX_RECENT_FILES.
    //
    iCountNew = min(iCount + 1, MAX_RECENT_FILES);

    //
    // Clear the old stuff and the write out the recent files to disk
    //
    for (i = 1; i <= iCountNew; i++) {
        wsprintf(szKey, TEXT("File %d"), i);
        ProfileStringOut(szKey, aRecentFiles[i - 1]);
    }

    //
    // Update the file menu
    //
    GetRecentFiles(iCount);

    return iCountNew;  // the updated count of files.
}

/*****************************Private*Routine******************************\
* SetDurationLength
*
* Updates pane 0 on the status bar
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
void
SetDurationLength(
    REFTIME rt
    )
{
    TCHAR   szFmt[64];
    TCHAR   sz[64];

    g_TrackBarScale = 1.0;
    while (rt / g_TrackBarScale > 30000) {
        g_TrackBarScale *= 10;
    }

    SendMessage(g_hwndTrackbar, TBM_SETRANGE, TRUE,
                MAKELONG(0, (WORD)(rt / g_TrackBarScale)));

    SendMessage(g_hwndTrackbar, TBM_SETTICFREQ, (WPARAM)((int)(rt / g_TrackBarScale) / 9), 0);
    SendMessage(g_hwndTrackbar, TBM_SETPAGESIZE, 0, (LPARAM)((int)(rt / g_TrackBarScale) / 9));

    wsprintf(sz, TEXT("Length: %s"), FormatRefTime(szFmt, rt));
    SendMessage(g_hwndStatusbar, SB_SETTEXT, 0, (LPARAM)sz);
}


/*****************************Private*Routine******************************\
* SetCurrentPosition
*
* Updates pane 1 on the status bar
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
void
SetCurrentPosition(
    REFTIME rt
    )
{
    TCHAR   szFmt[64];
    TCHAR   sz[64];

    SendMessage(g_hwndTrackbar, TBM_SETPOS, TRUE, (LPARAM)(rt / g_TrackBarScale));

    wsprintf(sz, TEXT("Elapsed: %s"), FormatRefTime(szFmt, rt));
    SendMessage(g_hwndStatusbar, SB_SETTEXT, 1, (LPARAM)sz);
}


/*****************************Private*Routine******************************\
* FormatRefTime
*
* Formats the given RefTime into the passed in character buffer,
* returns a pointer to the character buffer.
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
TCHAR *
FormatRefTime(
    TCHAR *sz,
    REFTIME rt
    )
{
    // If we are not seeking in time then format differently

    if (pMpegMovie && pMpegMovie->GetTimeFormat() != TIME_FORMAT_MEDIA_TIME) {
        wsprintf(sz,TEXT("%s"),(LPCTSTR) CDisp ((LONGLONG) rt,CDISP_DEC));
        return sz;
    }

    int hrs, mins, secs;

    rt += 0.49;

    hrs  =  (int)rt / 3600;
    mins = ((int)rt % 3600) / 60;
    secs = ((int)rt % 3600) % 60;

#ifdef UNICODE
    swprintf(sz, L"%02d:%02d:%02d h:m:s", rt);
#else
    sprintf(sz, "%02d:%02d:%02d h:m:s", hrs, mins, secs);
#endif

    return sz;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\measure\perf.h ===
/******************************Module*Header*******************************\
* Module Name: Perf.h
*
* Performance counter functions.  Uses the Pentium performance counters
* if they are available, otherwise falls back to the system QueryPerformance
* api's.
*
* InitPerfCounter MUST be called before using the QUERY_PERFORMANCE_XXX macros
* as it initializes the two global functions pointers.
*
*
* Created: 13-10-95
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1995 Microsoft Corporation
\**************************************************************************/
#ifndef _PERF_
#define _PERF_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */

void
InitPerfCounter(
    void
    );

void
QueryPerfCounter(
    LARGE_INTEGER *li
    );

void
QueryPerfFrequency(
    LARGE_INTEGER *li
    );


typedef void (WINAPI* PERFFUNCTION)(LARGE_INTEGER *li);
extern PERFFUNCTION    lpQueryPerfCounter;
extern PERFFUNCTION    lpQueryPerfFreqency;

#define QUERY_PERFORMANCE_FREQUENCY(x)  (*lpQueryPerfFreqency)(x)
#define QUERY_PERFORMANCE_COUNTER(x)    (*lpQueryPerfCounter)(x)

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif /* !_PERF_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\usbglitch\usbglitch.h ===
/*++

Copyright  2000 Microsoft Corporation

Module Name:

    usbglitch.h

Abstract:

    This module contains the USB glitch detector event tracing definitions.

Author:

    Arthur Zwiegincew (arthurz) 08-Jan-01

Revision History:

    08-Jan-01 - Created

--*/

// {7142FDF3-6FAE-40d3-A2AC-F912C039848D}
static const GUID GUID_USBAUDIOSTATE = 
{ 0x7142fdf3, 0x6fae, 0x40d3, { 0xa2, 0xac, 0xf9, 0x12, 0xc0, 0x39, 0x84, 0x8d } };

typedef enum _USBAUDIOSTATE {
    DISABLED = 0,
    ENABLED = 1,
    STREAM = 2,
    GLITCH = 3,
    ZERO = 4
} USBAUDIOSTATE;

typedef struct _PERFINFO_CORE_USBAUDIOSTATE {
    ULONGLONG       cycleCounter;
    USBAUDIOSTATE   usbAudioState;
    int             numberOfFrames;
} PERFINFO_CORE_USBAUDIOSTATE, *PPERFINFO_CORE_USBAUDIOSTATE;

typedef struct _PERFINFO_WMI_USBAUDIOSTATE {
    EVENT_TRACE_HEADER          header;
    PERFINFO_CORE_USBAUDIOSTATE data;
} PERFINFO_WMI_USBAUDIOSTATE, *PPERFINFO_WMI_USBAUDIOSTATE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\vcdplyer\project.h ===
/******************************Module*Header*******************************\
* Module Name: project.h
*
*  Master header file that includes all the other header files used by the
* project.  This enables compiled headers to work using build.
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1996  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/

#include "app.h"
#include "vcdplyer.h"
#include "resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\vcdplyer\mpgcodec.h ===
// Copyright (c) 1995 - 1997  Microsoft Corporation.  All Rights Reserved.
#include <mpegtype.h>   // IMpegAudioDecoder

typedef struct {
    LONG           lWidth;             //  Native Width in pixels
    LONG           lHeight;            //  Native Height in pixels
    LONG           lvbv;               //  vbv
    REFERENCE_TIME PictureTime;        //  Time per picture in 100ns units
    LONG           lTimePerFrame;      //  Time per picture in MPEG units
    LONG           dwBitRate;          //  Bits per second
    LONG           lXPelsPerMeter;     //  Pel aspect ratio
    LONG           lYPelsPerMeter;     //  Pel aspect ratio
    DWORD          dwStartTimeCode;    //  First GOP time code (or -1)
    LONG           lActualHeaderLen;   //  Length of valid bytes in raw seq hdr
    BYTE           RawHeader[140];     //  The real sequence header
} SEQHDR_INFO;


#define DECODE_I        0x0001L
#define DECODE_IP       0x0003L
#define DECODE_IPB      0x0007L     // Normal B Frame
#define DECODE_IPB1     0x000FL     // Decode 1 out of 4 B frames
#define DECODE_IPB2     0x0010L     // Decode 2 out of 4 B frames
#define DECODE_IPB3     0x0020L     // Decode 3 out of 4 B frames
#define DECODE_DIS      0x0040L     // No Decode, Convert only

#define DECODE_BQUAL_HIGH   0x00000000L  // Normal B Decode
#define DECODE_BQUAL_MEDIUM 0x10000000L  // Fast B Frame (No Half Pixel)
#define DECODE_BQUAL_LOW    0x20000000L  // Super Fast B Frame (No Half Pixel & Fast IDCT)

#define MM_NOCONV       0x00000000L     // No Conversion
#define MM_HRESOLUTION  0x10000000L     // Half Resolution
#define MM_CLIPPED      0x20000000L     // Clipped version (RGB8 only at present)

#define MM_420PL        0x00000001L     // YU12 :: YCbCr
#define MM_420PL_       0x00000002L     // YV12 :: YCrCb

#define MM_422PK        0x00000010L     // YUY2 :: YCbCr
#define MM_422PK_       0x00000020L     // YVY2 :: YCrCb
#define MM_422SPK       0x00000040L     //      :: CbYCrY
#define MM_422SPK_      0x00000080L     //      :: CrYCbY
#define MM_411PK        0x00000100L     // BT41
#define MM_410PL_       0x00000200L     // YVU9 - 16:1:1 Planar format


#define MM_Y_DIB        0x00001000L     // Luminance Only DIB
#define MM_Y_DDB        0x00002000L     // Luminance Only DDB

#define MM_RGB24_DIB    0x00010000L     // RGB 8:8:8 DIB   (Not Supported)
#define MM_RGB24_DDB    0x00020000L     // RGB 8:8:8 DDB   (Not Supported)
#define MM_RGB32_DIB    0x00040000L     // RGB a:8:8:8 DIB   (Not Supported)
#define MM_RGB32_DDB    0x00080000L     // RGB a:8:8:8 DDB   (Not Supported)

#define MM_RGB565_DIB   0x00100000L     // RGB 5:6:5 DIB
#define MM_RGB565_DDB   0x00200000L     // RGB 5:6:5 DDB
#define MM_RGB555_DIB   0x00400000L     // RGB 5:5:5 DIB
#define MM_RGB555_DDB   0x00800000L     // RGB 5:5:5 DDB

#define MM_RGB8_DIB     0x01000000L     // 8 Bit Paletized RGB DIB
#define MM_RGB8_DDB     0x02000000L     // 8 Bit Paletized RGB DDB


#define DECODE_HALF_HIQ	  0x00004000L
#define DECODE_HALF_FULLQ 0x00008000L


// {CC785860-B2CA-11ce-8D2B-0000E202599C}
DEFINE_GUID(CLSID_MpegAudioDecodePropertyPage,
0xcc785860, 0xb2ca, 0x11ce, 0x8d, 0x2b, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x9c);


// {E5B4EAA0-B2CA-11ce-8D2B-0000E202599C}
DEFINE_GUID(CLSID_MpegVideoDecodePropertyPage,
0xe5b4eaa0, 0xb2ca, 0x11ce, 0x8d, 0x2b, 0x0, 0x0, 0xe2, 0x2, 0x59, 0x9c);


// {EB1BB270-F71F-11CE-8E85-02608C9BABA2}
DEFINE_GUID(IID_IMpegVideoDecoder,
0xeb1bb270, 0xf71f, 0x11ce, 0x8e, 0x85, 0x02, 0x60, 0x8c, 0x9b, 0xab, 0xa2);


//
// Structure to describe the caps of the mpeg video decoder.
//
typedef struct {
    DWORD   VideoMaxBitRate;
} MPEG_VIDEO_DECODER_CAPS;


//
// IMpegVideoDecoder
//
DECLARE_INTERFACE_(IMpegVideoDecoder, IUnknown) {

    STDMETHOD(get_CurrentDecoderOption)
    ( THIS_
      DWORD *pOptions
    ) PURE;

    STDMETHOD(set_CurrentDecoderOption)
    ( THIS_
      DWORD Options
    ) PURE;

    STDMETHOD(get_DefaultDecoderOption)
    ( THIS_
      DWORD *pOptions
    ) PURE;

    STDMETHOD(set_DefaultDecoderOption)
    ( THIS_
      DWORD Options
    ) PURE;

    STDMETHOD(get_QualityMsgProcessing)
    ( THIS_
      BOOL *pfIgnore
    ) PURE;

    STDMETHOD(set_QualityMsgProcessing)
    ( THIS_
      BOOL fIgnore
    ) PURE;

    STDMETHOD(get_GreyScaleOutput)
    ( THIS_
      BOOL *pfGrey
    ) PURE;

    STDMETHOD(set_GreyScaleOutput)
    ( THIS_
      BOOL fGrey
    ) PURE;

    STDMETHOD(get_SequenceHeader)
    ( THIS_
      SEQHDR_INFO *pSeqHdrInfo
    ) PURE;

    STDMETHOD(get_OutputFormat)
    ( THIS_
      DWORD *pOutputFormat
    ) PURE;

    STDMETHOD(get_FrameStatistics)
    ( THIS_
      DWORD *pIFramesDecoded,
      DWORD *pPFramesDecoded,
      DWORD *pBFramesDecoded,
      DWORD *pIFramesSkipped,
      DWORD *pPFramesSkipped,
      DWORD *pBFramesSkipped
    ) PURE;

    STDMETHOD(ResetFrameStatistics)
    ( THIS_
    ) PURE;

    STDMETHOD(get_DecoderPaletteInfo)
    ( THIS_
      LPDWORD lpdwFirstEntry,
      LPDWORD lpdwLastEntry
    ) PURE;

    STDMETHOD(get_DecoderPaletteEntries)
    ( THIS_
      DWORD dwStartEntry,
      DWORD dwNumEntries,
      LPPALETTEENTRY lppe
    ) PURE;

    STDMETHOD(get_EncryptionKey)
    ( THIS_
      DWORD *dwEncrptionKey
    ) PURE;

    STDMETHOD(put_EncryptionKey)
    ( THIS_
      DWORD dwEncrptionKey
    ) PURE;

    STDMETHOD(get_DecoderCaps)
    ( THIS_
      MPEG_VIDEO_DECODER_CAPS *pCaps
    ) PURE;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\vcdplyer\commands.cpp ===
/******************************Module*Header*******************************\
* Module Name: commands.cpp
*
*  Processes commands from the user.
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/
#include <streams.h>
#include <mmreg.h>
#include <commctrl.h>

#include "project.h"
#include "mpgcodec.h"
#include <stdio.h>


BOOL GetAMErrorText(HRESULT hr, TCHAR *Buffer, DWORD dwLen);

extern CMpegMovie *pMpegMovie;

/******************************Public*Routine******************************\
* VcdPlayerOpenCmd
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
VcdPlayerOpenCmd(
    void
    )
{
    static BOOL fFirstTime = TRUE;
    BOOL fRet;
    TCHAR achFileName[MAX_PATH];
    TCHAR achFilter[MAX_PATH];
    LPTSTR lp;

    if (fFirstTime) {

        ofn.lStructSize = sizeof(ofn);
        ofn.hwndOwner = hwndApp;
        ofn.Flags = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST |
                    OFN_SHAREAWARE | OFN_PATHMUSTEXIST;
    }

    lstrcpy(achFilter, IdStr(STR_FILE_FILTER) );
    ofn.lpstrFilter = achFilter;

    /*
    ** Convert the resource string into to something suitable for
    ** GetOpenFileName ie.  replace '#' characters with '\0' characters.
    */
    for (lp = achFilter; *lp; lp++ ) {
        if (*lp == TEXT('#')) {
            *lp = TEXT('\0');
        }
    }

    ofn.lpstrFile = achFileName;
    ofn.nMaxFile = sizeof(achFileName) / sizeof(TCHAR);
    ZeroMemory(achFileName, sizeof(achFileName));

    fRet = GetOpenFileName(&ofn);
    if ( fRet ) {

        fFirstTime = FALSE;
        ProcessOpen(achFileName);

    }

    return fRet;
}



/******************************Public*Routine******************************\
* VcdPlayerSetLog
*
*
*
* History:
* 11-04-94 - LaurieGr - Created
*
\**************************************************************************/
BOOL
VcdPlayerSetLog(
    void
    )
{

    BOOL fRet;
    TCHAR achFileName[MAX_PATH];
    TCHAR achFilter[MAX_PATH];
    LPTSTR lp;
    OPENFILENAME opfn;

    ZeroMemory(&opfn, sizeof(opfn));

    opfn.lStructSize = sizeof(opfn);
    opfn.hwndOwner = hwndApp;
    opfn.Flags = OFN_HIDEREADONLY | OFN_SHAREAWARE | OFN_PATHMUSTEXIST;

    lstrcpy(achFilter, IdStr(STR_FILE_LOG_FILTER) );
    opfn.lpstrFilter = achFilter;

    /*
    ** Convert the resource string into to something suitable for
    ** GetOpenFileName ie.  replace '#' characters with '\0' characters.
    */
    for (lp = achFilter; *lp; lp++ ) {
        if (*lp == TEXT('#')) {
            *lp = TEXT('\0');
        }
    }

    opfn.lpstrFile = achFileName;
    opfn.nMaxFile = sizeof(achFileName) / sizeof(TCHAR);
    ZeroMemory(achFileName, sizeof(achFileName));

    fRet = GetOpenFileName(&opfn);
    if ( fRet ) {
        hRenderLog = CreateFile( achFileName
                               , GENERIC_WRITE
                               , 0    // no sharing
                               , NULL // no security
                               , OPEN_ALWAYS
                               , 0    // no attributes, no flags
                               , NULL // no template
                               );
        if (hRenderLog==INVALID_HANDLE_VALUE) {
            volatile int Err = GetLastError();
            fRet = FALSE;
        }
        // Seek to end of file
        SetFilePointer(hRenderLog, 0, NULL, FILE_END);
    }

    return fRet;
}

/******************************Public*Routine******************************\
* VcdPlayerSetPerfLogFile
*
*
*
* History:
* 30-05-96 - StephenE - Created
*
\**************************************************************************/
BOOL
VcdPlayerSetPerfLogFile(
    void
    )
{

    BOOL fRet;
    TCHAR achFileName[MAX_PATH];
    TCHAR achFilter[MAX_PATH];
    LPTSTR lp;
    OPENFILENAME opfn;

    ZeroMemory(&opfn, sizeof(opfn));

    opfn.lStructSize = sizeof(opfn);
    opfn.hwndOwner = hwndApp;
    opfn.Flags = OFN_HIDEREADONLY | OFN_SHAREAWARE | OFN_PATHMUSTEXIST;

    lstrcpy(achFilter, IdStr(STR_FILE_PERF_LOG) );
    opfn.lpstrFilter = achFilter;

    /*
    ** Convert the resource string into to something suitable for
    ** GetOpenFileName ie.  replace '#' characters with '\0' characters.
    */
    for (lp = achFilter; *lp; lp++ ) {
        if (*lp == TEXT('#')) {
            *lp = TEXT('\0');
        }
    }

    opfn.lpstrFile = achFileName;
    opfn.nMaxFile = sizeof(achFileName) / sizeof(TCHAR);
    lstrcpy(achFileName, g_szPerfLog);

    fRet = GetOpenFileName(&opfn);
    if ( fRet ) {
        lstrcpy(g_szPerfLog, achFileName);
    }

    return fRet;
}



/******************************Public*Routine******************************\
* VcdPlayerCloseCmd
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
VcdPlayerCloseCmd(
    void
    )
{
    if (pMpegMovie) {

        LONG cx, cy;

        if (pMpegMovie->pMpegDecoder != NULL) {
            KillTimer(hwndApp, 32);
        }

        g_State = VCD_NO_CD;
        pMpegMovie->GetMoviePosition(&lMovieOrgX, &lMovieOrgY, &cx, &cy);
        pMpegMovie->CloseMovie();

        SetDurationLength((REFTIME)0);
        SetCurrentPosition((REFTIME)0);

        delete pMpegMovie;
        pMpegMovie = NULL;
    }
    InvalidateRect( hwndApp, NULL, FALSE );
    UpdateWindow( hwndApp );
    return TRUE;
}


/******************************Public*Routine******************************\
* VcdPlayerPlayCmd
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
VcdPlayerPlayCmd(
    void
    )
{
    BOOL fStopped = (g_State & VCD_STOPPED);
    BOOL fPaused  = (g_State & VCD_PAUSED);

    if ( (fStopped || fPaused) ) {

        HDC hdc;
        RECT rc;


        //
        // Clear out the old stats from the main window
        //
        hdc = GetDC(hwndApp);
        GetAdjustedClientRect(&rc);
        FillRect(hdc, &rc, (HBRUSH)(COLOR_BTNFACE + 1));
        ReleaseDC(hwndApp, hdc);

        if (pMpegMovie) {
            pMpegMovie->PlayMovie();
        }

        g_State &= ~(fStopped ? VCD_STOPPED : VCD_PAUSED);
        g_State |= VCD_PLAYING;
    }

    return TRUE;
}


/******************************Public*Routine******************************\
* VcdPlayerPlayCmd
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
VcdPlayerStopCmd(
    void
    )
{
    BOOL fPlaying = (g_State & VCD_PLAYING);
    BOOL fPaused  = (g_State & VCD_PAUSED);

    if ( (fPlaying || fPaused) ) {

        if (pMpegMovie) {
            pMpegMovie->StopMovie();
            pMpegMovie->SetFullScreenMode(FALSE);
            SetCurrentPosition(pMpegMovie->GetCurrentPosition());
        }

        g_State &= ~(fPlaying ? VCD_PLAYING : VCD_PAUSED);
        g_State |= VCD_STOPPED;
    }
    return TRUE;
}


/******************************Public*Routine******************************\
* VcdPlayerPauseCmd
*
*
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
BOOL
VcdPlayerPauseCmd(
    void
    )
{
    BOOL fPlaying = (g_State & VCD_PLAYING);
    BOOL fPaused  = (g_State & VCD_PAUSED);

    if (fPlaying) {

        if (pMpegMovie) {
            pMpegMovie->PauseMovie();
            SetCurrentPosition(pMpegMovie->GetCurrentPosition());
        }

        g_State &= ~VCD_PLAYING;
        g_State |= VCD_PAUSED;
    }
    else if (fPaused) {

        if (pMpegMovie) {
            pMpegMovie->PlayMovie();
        }

        g_State &= ~VCD_PAUSED;
        g_State |= VCD_PLAYING;
    }

    return TRUE;
}

/******************************Public*Routine******************************\
* VcdPlayerSeekCmd
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
VcdPlayerSeekCmd(
    REFTIME rtSeekBy
    )
{
    REFTIME rt;
    REFTIME rtDur;

    rtDur = pMpegMovie->GetDuration();
    rt = pMpegMovie->GetCurrentPosition() + rtSeekBy;

    rt = max(0, min(rt, rtDur));

    pMpegMovie->SeekToPosition(rt,TRUE);
    SetCurrentPosition(pMpegMovie->GetCurrentPosition());
}


/******************************Public*Routine******************************\
* ProcessOpen
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
void
ProcessOpen(
    TCHAR *achFileName,
    BOOL bPlay
    )
{
    /*
    ** If we currently have a video loaded we need to discard it here.
    */
    if ( g_State & VCD_LOADED) {
        VcdPlayerCloseCmd();
    }

    lstrcpy(g_achFileName, achFileName);

    pMpegMovie = new CMpegMovie(hwndApp);
    if (pMpegMovie) {

        HRESULT hr = pMpegMovie->OpenMovie(g_achFileName);
        if (SUCCEEDED(hr)) {

            TCHAR achTmp[MAX_PATH];
            LONG  x, y, cx, cy;

            nRecentFiles = SetRecentFiles(achFileName, nRecentFiles);

            wsprintf( achTmp, IdStr(STR_APP_TITLE_LOADED),
                      g_achFileName );
            g_State = (VCD_LOADED | VCD_STOPPED);

            if (pMpegMovie->pMpegDecoder != NULL
             || pMpegMovie->pVideoRenderer != NULL) {
                SetTimer(hwndApp, PerformanceTimer, 1000, NULL);
            }

            // SetDurationLength(pMpegMovie->GetDuration());
            g_TimeFormat = VcdPlayerChangeTimeFormat(g_TimeFormat);

            pMpegMovie->GetMoviePosition(&x, &y, &cx, &cy);
            pMpegMovie->PutMoviePosition(lMovieOrgX, lMovieOrgY, cx, cy);
            pMpegMovie->SetWindowForeground(OATRUE);

            //  If play
            if (bPlay) {
                pMpegMovie->PlayMovie();
            }
        }
        else {
            TCHAR Buffer[MAX_ERROR_TEXT_LEN];

            if (GetAMErrorText(hr, Buffer, MAX_ERROR_TEXT_LEN)) {
                MessageBox( hwndApp, Buffer,
                            IdStr(STR_APP_TITLE), MB_OK );
            }
            else {
                MessageBox( hwndApp,
                            TEXT("Failed to open the movie; ")
                            TEXT("either the file was not found or ")
                            TEXT("the wave device is in use"),
                            IdStr(STR_APP_TITLE), MB_OK );
            }

            pMpegMovie->CloseMovie();
            delete pMpegMovie;
            pMpegMovie = NULL;
        }
    }

    InvalidateRect( hwndApp, NULL, FALSE );
    UpdateWindow( hwndApp );
}


/******************************Public*Routine******************************\
* VcdPlayerChangeTimeFormat
*
* Tries to change the time format to id.  Returns the time format that
* actually got set.  This may differ from id if the graph does not support
* the requested time format.
*
* History:
* 15-04-96 - AnthonyP - Created
*
\**************************************************************************/
int
VcdPlayerChangeTimeFormat(
    int id
    )
{
    // Menu items are disabled while we are playing

    BOOL    bRet = FALSE;
    int     idActual = id;

    ASSERT(pMpegMovie);
    ASSERT(pMpegMovie->StatusMovie() != MOVIE_NOTOPENED);

    // Change the time format with the filtergraph

    switch (id) {
    case IDM_FRAME:
        bRet = pMpegMovie->SetTimeFormat(TIME_FORMAT_FRAME);
        break;

    case IDM_FIELD:
        bRet = pMpegMovie->SetTimeFormat(TIME_FORMAT_FIELD);
        break;

    case IDM_SAMPLE:
        bRet = pMpegMovie->SetTimeFormat(TIME_FORMAT_SAMPLE);
        break;

    case IDM_BYTES:
        bRet = pMpegMovie->SetTimeFormat(TIME_FORMAT_BYTE);
        break;
    }

    if (!bRet) {
        // IDM_TIME and all other cases,  everyone should support IDM_TIME
        bRet = pMpegMovie->SetTimeFormat(TIME_FORMAT_MEDIA_TIME);
        ASSERT(bRet);
        idActual = IDM_TIME;
    }

    // Pause the movie to get a current position

    SetDurationLength(pMpegMovie->GetDuration());
    SetCurrentPosition(pMpegMovie->GetCurrentPosition());

    return idActual;
}


const TCHAR quartzdllname[] = TEXT("quartz.dll");
#ifdef UNICODE
const char  amgeterrorprocname[] = "AMGetErrorTextW";
#else
const char  amgeterrorprocname[] = "AMGetErrorTextA";
#endif

BOOL GetAMErrorText(HRESULT hr, TCHAR *Buffer, DWORD dwLen)
{
    HMODULE hInst = GetModuleHandle(quartzdllname);
    if (hInst) {
        AMGETERRORTEXTPROC lpProc;
        *((FARPROC *)&lpProc) = GetProcAddress(hInst, amgeterrorprocname);
        if (lpProc) {
            return 0 != (*lpProc)(hr, Buffer, dwLen);
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\vcdplyer\app.h ===
/******************************Module*Header*******************************\
* Module Name: app.h
*
* Function prototype for the Video CD Player application.
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/




/* -------------------------------------------------------------------------
** Functions prototypes
** -------------------------------------------------------------------------
*/
int
DoMainLoop(
    void
    );

BOOL
InitApplication(
    HINSTANCE hInstance
    );

BOOL
InitInstance(
    HINSTANCE hInstance,
    int nCmdShow
    );

BOOL
LoadWindowPos(
    LPRECT lprc
    );

BOOL
SaveWindowPos(
    HWND hwnd
    );

void
PatB(
    HDC hdc,
    int x,
    int y,
    int dx,
    int dy,
    DWORD rgb
    );

void
UpdateMpegMovieRect(
    void
    );

void
GetAdjustedClientRect(
    RECT *prc
    );

BOOL
DrawStats(
    HDC hdc
    );

void
CalcMovieRect(
    LPRECT lprc
    );

LPCTSTR
IdStr(
    int idResource
    );

void
UpdateSystemColors(
    void
    );

#if 0
void
DrawShadowRect(
    HDC hdc,
    LPRECT lprc
    );
#endif

void
SetDurationLength(
    REFTIME rt
    );

void
SetCurrentPosition(
    REFTIME rt
    );

TCHAR *
FormatRefTime(
    TCHAR *sz,
    REFTIME rt
    );

void
DoMpegVideoPropertyPage();

void
DoMpegAudioPropertyPage();

/* -------------------------------------------------------------------------
** Registry stuff
** -------------------------------------------------------------------------
*/
int
ProfileIntIn(
   const TCHAR *szKey,
   int iDefault
   );

BOOL
ProfileIntOut(
   const TCHAR *szKey,
   int iDefault
   );

void
ProfileStringOut (
    LPTSTR  szKey,
    LPTSTR  sz
    );

UINT
ProfileStringIn (
    LPTSTR  szKey,
    LPTSTR  szDef,
    LPTSTR  sz,
    DWORD   cb
    );

BOOL
LoadWindowPos(
    LPRECT lprc
    );

BOOL
SaveWindowPos(
    HWND hwnd
    );

HKEY
GetAppKey(
    BOOL fCreate
    );


/* -------------------------------------------------------------------------
** Message crackers
** -------------------------------------------------------------------------
*/
/* void Cls_OnUser(HWND hwnd, WPARAM wParam, LPARAM lParam ) */
#define HANDLE_WM_USER(hwnd, wParam, lParam, fn) \
    ((fn)(hwnd, wParam, lParam), 0L)

#ifndef HANDLE_WM_NOTIFY
/* LRESULT Cls_OnNotify(HWND hwnd, int idFrom, NMHDR FAR* pnmhdr); */
#define HANDLE_WM_NOTIFY(hwnd, wParam, lParam, fn) \
    (fn)((hwnd), (int)(wParam), (NMHDR FAR*)(lParam))
#endif



/* -------------------------------------------------------------------------
** VideoCd window class prototypes
** -------------------------------------------------------------------------
*/
extern "C" LRESULT CALLBACK
VideoCdWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

void
VideoCd_OnClose(
    HWND hwnd
    );

BOOL
VideoCd_OnQueryEndSession(
    HWND hwnd
    );

void
VideoCd_OnDestroy(
    HWND hwnd
    );

void
VideoCd_OnCommand(
    HWND hwnd,
    int id,
    HWND hwndCtl,
    UINT codeNotify
    );

void
VideoCd_OnPaint(
    HWND hwnd
    );

void
VideoCd_OnTimer(
    HWND hwnd,
    UINT id
    );

BOOL
VideoCd_OnCreate(
    HWND hwnd,
    LPCREATESTRUCT lpCreateStruct
    );

void
VideoCd_OnSize(
    HWND hwnd,
    UINT state,
    int cx,
    int cy
    );

void
VideoCd_OnKeyUp(
    HWND hwnd,
    UINT vk,
    BOOL fDown,
    int cRepeat,
    UINT flags
    );

void
VideoCd_OnActivate(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    );

void
VideoCd_OnHScroll(
    HWND hwnd,
    HWND hwndCtl,
    UINT code,
    int pos
    );

void
VideoCd_OnUser(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    );

void
VideoCd_OnSysColorChange(
    HWND hwnd
    );

void
VideoCd_OnMenuSelect(
    HWND hwnd,
    HMENU hmenu,
    int item,
    HMENU hmenuPopup,
    UINT flags
    );

void
VideoCd_OnInitMenuPopup(
    HWND hwnd,
    HMENU hMenu,
    UINT item,
    BOOL fSystemMenu
    );

#ifdef WM_NOTIFY
LRESULT
VideoCd_OnNotify(
    HWND hwnd,
    int idFrom,
    NMHDR FAR* pnmhdr
    );
#endif


void
VideoCd_OnGraphNotify(
    void
    );

void
VideoCd_OnDropFiles(
    HWND hwnd,
    HDROP hdrop);

void
SetPlayButtonsEnableState(
    void
    );



/* -------------------------------------------------------------------------
** Command processing functions
** -------------------------------------------------------------------------
*/

BOOL
VcdPlayerSetLog(
    void
    );

BOOL
VcdPlayerSetPerfLogFile(
    void
    );

BOOL
VcdPlayerOpenCmd(
    void
    );

BOOL
VcdPlayerCloseCmd(
    void
    );

BOOL
VcdPlayerPlayCmd(
    void
    );

BOOL
VcdPlayerStopCmd(
    void
    );

BOOL
VcdPlayerPauseCmd(
    void
    );

BOOL
VcdPlayerPauseCmd(
    void
    );

void
VcdPlayerSeekCmd(
    REFTIME rtSeekBy
    );

void
ProcessOpen(
    TCHAR *achFileName,
    BOOL bPlay = FALSE
    );

int
VcdPlayerChangeTimeFormat(
    int id
    );


/* -------------------------------------------------------------------------
** Recent filename stuff
** -------------------------------------------------------------------------
*/
typedef TCHAR RECENTFILES[MAX_PATH];
#define MAX_RECENT_FILES    5
#define ID_RECENT_FILE_BASE 500

int
GetRecentFiles(
    int LastCount
    );

int
SetRecentFiles(
    TCHAR *FileName,
    int iCount
    );


/* -------------------------------------------------------------------------
** Global Variables
** -------------------------------------------------------------------------
*/
extern int              cxMovie;
extern int              cyMovie;
extern HWND             hwndApp;
extern HWND             g_hwndStatusbar;

extern int              cx;
extern int              cy;
extern int              xOffset;
extern int              yOffset;
extern TCHAR            g_achFileName[];
extern OPENFILENAME     ofn;
extern DWORD            g_State;
extern HANDLE           hRenderLog;
extern int              nRecentFiles;
extern LONG             lMovieOrgX, lMovieOrgY;
extern TCHAR            g_szPerfLog[];
extern int              g_TimeFormat;
extern BOOL             g_bUseThreadedGraph;




/* -------------------------------------------------------------------------
** Constants
** -------------------------------------------------------------------------
*/
#define LEFT_MARGIN 2



/* -------------------------------------------------------------------------
** Video CD Player states
**
**  These are bit flags
** -------------------------------------------------------------------------
*/

#define VCD_PLAYING          0x0001
#define VCD_STOPPED          0x0002
#define VCD_PAUSED           0x0004
#define VCD_SKIP_F           0x0008
#define VCD_SKIP_B           0x0010
#define VCD_FF               0x0020
#define VCD_RW               0x0040
#define VCD_SEEKING          (VCD_FF | VCD_RW)
#define VCD_LOADED           0x0080
#define VCD_NO_CD            0x0100
#define VCD_DATA_CD_LOADED   0x0200
#define VCD_EDITING          0x0400
#define VCD_PAUSED_AND_MOVED 0x0800
#define VCD_PLAY_PENDING     0x1000
#define VCD_WAS_PLAYING      0x2000
#define VCD_IN_USE           0x4000

enum {PerformanceTimer = 32, StatusTimer = 33};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\vcdplyer\property.cpp ===
/******************************Module*Header*******************************\
* Module Name: property.cpp
*
* Support for the mpeg video and audio decoder property pages.
*
*
* Created: 24-01-96
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/
#include <streams.h>
#include <mmreg.h>
#include <commctrl.h>

#include "project.h"
#include "mpgcodec.h"

#include <stdarg.h>
#include <stdio.h>

extern HINSTANCE           hInst;
extern HWND                hwndApp;
extern CMpegMovie          *pMpegMovie;

extern "C" {
INT_PTR CALLBACK
VideoStatsDialogProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
VideoDialogProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

INT_PTR CALLBACK
AudioDialogProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );
}

void
UpdateStats(
    HWND hwnd
    );

TCHAR *
StringFromId(
    int idResource
    );

void
SetDecoderOption(
    HWND m_hwnd,
    DWORD dwOptions
    );

DWORD
GetDecoderOption(
    HWND m_hwnd
    );

void
GetButtonValues(
    HWND m_hwnd,
    LPDWORD iChannels,
    LPDWORD iSkip,
    LPDWORD iQuality,
    LPDWORD iInteger,
    LPDWORD iOutputWordSize
    );

void
SetButtonValues(
    HWND m_hwnd,
    DWORD iChannels,
    DWORD iSkip,
    DWORD iQuality,
    DWORD iInteger,
    DWORD iOutputWordSize
    );

void
PutDecoderInteger(
    const TCHAR *pKey,
    int iValue
    );

/* -------------------------------------------------------------------------
** Decoder strings
** -------------------------------------------------------------------------
*/
const TCHAR chVideoFramesDecoded[] = TEXT("VideoFramesDecoded");
const TCHAR chVideoQuality[]       = TEXT("VideoQuality");
const TCHAR chGreyScale[]          = TEXT("GreyScale");
const TCHAR chIgnoreQMessages[]    = TEXT("IgnoreQMessages");

const TCHAR chAudioChannels[]      = TEXT("AudioChannels");
const TCHAR chAudioFreqDivider[]   = TEXT("AudioFreqDivider");
const TCHAR chAudioQuality[]       = TEXT("AudioQuality");
const TCHAR chAudioQuarterInt[]    = TEXT("AudioQuarterInt");
const TCHAR chAudioBits[]          = TEXT("AudioBits");
const TCHAR chRegistryKey[]        = TEXT("Software\\Microsoft\\Multimedia\\ActiveMovie Filters\\MPEG Decoder");


/******************************Public*Routine******************************\
* DoMpegVideoPropertyPage
*
*
*
* History:
* 24-01-96 - StephenE - Created
*
\**************************************************************************/
void
DoMpegVideoPropertyPage()
{
    DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_VIDEOPROP),
                   hwndApp, VideoDialogProc, (LPARAM)NULL);
}



/******************************Public*Routine******************************\
* DoMpegAudioPropertyPage
*
*
*
* History:
* 24-01-96 - StephenE - Created
*
\**************************************************************************/
void
DoMpegAudioPropertyPage()
{
    DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_AUDIOPROP),
                   hwndApp, AudioDialogProc, (LPARAM)NULL);
}


/******************************Public*Routine******************************\
* VideoDialogProc
*
* Handles the messages for our property window
*
* History:
* 27-09-95 - StephenE - Created
*
\**************************************************************************/
INT_PTR CALLBACK
VideoDialogProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD m_dwDecoderOptions;
    BOOL  m_fQualityOption;
    BOOL  m_fGreyScaleOption;

    switch (uMsg) {
    case WM_INITDIALOG:
        pMpegMovie->pMpegDecoder->get_DefaultDecoderOption(&m_dwDecoderOptions);
        pMpegMovie->pMpegDecoder->get_QualityMsgProcessing(&m_fQualityOption);
        pMpegMovie->pMpegDecoder->get_GreyScaleOutput(&m_fGreyScaleOption);

        SetDecoderOption(hwnd, m_dwDecoderOptions);
        Button_SetCheck(GetDlgItem(hwnd, B_GREY), m_fGreyScaleOption);
        Button_SetCheck(GetDlgItem(hwnd, IGNORE_QUALITY), m_fQualityOption);
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDCANCEL:
            EndDialog(hwnd, wParam);
            break;

        case IDOK:
            m_dwDecoderOptions = GetDecoderOption(hwnd);
            m_fQualityOption   = Button_GetCheck(GetDlgItem(hwnd, IGNORE_QUALITY));
            m_fGreyScaleOption = Button_GetCheck(GetDlgItem(hwnd, B_GREY));

            pMpegMovie->pMpegDecoder->set_DefaultDecoderOption(m_dwDecoderOptions);
            pMpegMovie->pMpegDecoder->set_QualityMsgProcessing(m_fQualityOption);
            pMpegMovie->pMpegDecoder->set_GreyScaleOutput(m_fGreyScaleOption);
            EndDialog(hwnd, wParam);
            break;

        case STATS_BUTTON:
            DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_VIDEOSTATS),
                           hwnd, VideoStatsDialogProc, (LPARAM)NULL);
            break;

        case ID_DEFAULT:
            m_dwDecoderOptions = GetDecoderOption(hwnd);
            PutDecoderInteger(chVideoFramesDecoded, m_dwDecoderOptions & 0x3F);
            PutDecoderInteger(chVideoQuality, m_dwDecoderOptions & 0x30000000);

            PutDecoderInteger(chGreyScale,
                              Button_GetCheck(GetDlgItem(hwnd, B_GREY)));

            PutDecoderInteger(chIgnoreQMessages,
                              Button_GetCheck(GetDlgItem(hwnd, IGNORE_QUALITY)));
            break;
        }
        return TRUE;

    default:
        return FALSE;

    }
}

/*****************************Private*Routine******************************\
* SetDecoderOption
*
* This function puts the buttons on the property page into the state that
* corresponds to the passed in dwOptions parameter.
*
* History:
* 27-09-95 - StephenE - Created
*
\**************************************************************************/
void
SetDecoderOption(
    HWND m_hwnd,
    DWORD dwOptions
    )
{
    switch (dwOptions & 0x0FFFFFFF) {

    case DECODE_I:
        Button_SetCheck(GetDlgItem(m_hwnd, I_ONLY), TRUE );
        break;

    case DECODE_IP:
        Button_SetCheck(GetDlgItem(m_hwnd, IP_ONLY), TRUE );
        break;

    case DECODE_IPB:
        Button_SetCheck(GetDlgItem(m_hwnd, IP_ALL_B), TRUE );
        break;

    case DECODE_IPB1:
        Button_SetCheck(GetDlgItem(m_hwnd, IP_1_IN_4_B), TRUE );
        break;

    case DECODE_IPB2:
        Button_SetCheck(GetDlgItem(m_hwnd, IP_2_IN_4_B), TRUE );
        break;

    case DECODE_IPB3:
        Button_SetCheck(GetDlgItem(m_hwnd, IP_3_IN_4_B), TRUE );
        break;
    }

    switch (dwOptions & 0xF0000000) {
    case DECODE_BQUAL_HIGH:
        Button_SetCheck(GetDlgItem(m_hwnd, B_HIGH), TRUE );
        break;

    case DECODE_BQUAL_MEDIUM:
        Button_SetCheck(GetDlgItem(m_hwnd, B_MEDIUM), TRUE );
        break;

    case DECODE_BQUAL_LOW:
        Button_SetCheck(GetDlgItem(m_hwnd, B_LOW), TRUE );
        break;
    }
}

/*****************************Private*Routine******************************\
* GetDecoderOption
*
* Returns the decoder options from the property page dialog.
*
* History:
* 27-09-95 - StephenE - Created
*
\**************************************************************************/
DWORD
GetDecoderOption(
    HWND m_hwnd
    )
{
    DWORD dwOption = 0L;

    if (Button_GetCheck(GetDlgItem(m_hwnd, I_ONLY))) {
        dwOption = DECODE_I;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, I_ONLY))) {
        dwOption = DECODE_I;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, IP_ONLY))) {
        dwOption = DECODE_IP;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, IP_ALL_B))) {
        dwOption = DECODE_IPB;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, IP_1_IN_4_B))) {
        dwOption = DECODE_IPB1;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, IP_2_IN_4_B))) {
        dwOption = DECODE_IPB2;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, IP_3_IN_4_B))) {
        dwOption = DECODE_IPB3;
    }


    if (Button_GetCheck(GetDlgItem(m_hwnd, B_HIGH))) {
        dwOption |= DECODE_BQUAL_HIGH;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, B_MEDIUM))) {
        dwOption |= DECODE_BQUAL_MEDIUM;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, B_LOW))) {
        dwOption |= DECODE_BQUAL_LOW;
    }

    return dwOption;
}

/******************************Public*Routine******************************\
* VideoStatsDialogProc
*
* Handles the messages for our property window
*
* History:
* 27-09-95 - StephenE - Created
*
\**************************************************************************/
INT_PTR CALLBACK
VideoStatsDialogProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMsg) {
    case WM_INITDIALOG:
        SetWindowFont(GetDlgItem(hwnd,ID_STATSBOX),
                      GetStockObject(ANSI_FIXED_FONT), FALSE);
        UpdateStats(hwnd);
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDCANCEL:
        case IDOK:
            EndDialog(hwnd, wParam);
            break;

        case ID_REFRESH:
            UpdateStats(hwnd);
            break;
        }
        return TRUE;

    default:
        return FALSE;
    }
}

/*****************************Private*Routine******************************\
* UpdateStats
*
* Gets the video decoder statics and then formats and displays then in the
* read only edit field.
*
* History:
* 27-09-95 - StephenE - Created
*
\**************************************************************************/
void
UpdateStats(
    HWND hwnd
    )
{
    DWORD       dwIFramesDecoded;
    DWORD       dwPFramesDecoded;
    DWORD       dwBFramesDecoded;
    DWORD       dwIFramesSkipped;
    DWORD       dwPFramesSkipped;
    DWORD       dwBFramesSkipped;
    DWORD       dwTotalFrames;
    DWORD       dwTotalIFrames;
    DWORD       dwTotalPFrames;
    DWORD       dwTotalBFrames;
    DWORD       dwTotalDecoded;
    TCHAR       Text[1024];
    SEQHDR_INFO SeqHdr;

    pMpegMovie->pMpegDecoder->get_SequenceHeader(&SeqHdr);

    pMpegMovie->pMpegDecoder->get_FrameStatistics(
                    &dwIFramesDecoded, &dwPFramesDecoded, &dwBFramesDecoded,
                    &dwIFramesSkipped, &dwPFramesSkipped, &dwBFramesSkipped);

    dwTotalIFrames = dwIFramesDecoded + dwIFramesSkipped;
    dwTotalPFrames = dwPFramesDecoded + dwPFramesSkipped;
    dwTotalBFrames = dwBFramesDecoded + dwBFramesSkipped;
    dwTotalFrames  = dwTotalIFrames   + dwTotalPFrames   + dwTotalBFrames;
    dwTotalDecoded = dwIFramesDecoded + dwPFramesDecoded + dwBFramesDecoded;

    wsprintf(Text, StringFromId(IDS_IMAGE_SIZE), SeqHdr.lWidth, SeqHdr.lHeight);
    wsprintf(Text + lstrlen(Text), StringFromId(IDS_BUFFER_VBV), SeqHdr.lvbv);
    wsprintf(Text + lstrlen(Text), StringFromId(IDS_BITRATE), SeqHdr.dwBitRate);

    if (dwTotalFrames != 0) {

        lstrcat(Text, StringFromId(IDS_NEWLINE));
        wsprintf(Text + lstrlen(Text), StringFromId(IDS_FRAMES_DEC),
                 dwTotalDecoded, dwTotalFrames);
        wsprintf(Text + lstrlen(Text), StringFromId(IDS_PROPORTION),
                 (100 * dwTotalDecoded) / dwTotalFrames);

        lstrcat(Text, StringFromId(IDS_NEWLINE));
        wsprintf(Text + lstrlen(Text), StringFromId(IDS_SKIP_I),
                 dwIFramesDecoded, dwIFramesSkipped);

        wsprintf(Text + lstrlen(Text), StringFromId(IDS_SKIP_P),
                 dwPFramesDecoded, dwPFramesSkipped);

        wsprintf(Text + lstrlen(Text), StringFromId(IDS_SKIP_B),
                 dwBFramesDecoded, dwBFramesSkipped);
    }

    SetWindowText(GetDlgItem(hwnd, ID_STATSBOX), Text);
}


/******************************Public*Routine******************************\
* AudioDialogProc
*
* Handles the messages for our property window
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
INT_PTR CALLBACK
AudioDialogProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD m_iChannels;
    DWORD m_iSkip;
    DWORD m_iQuality;
    DWORD m_iInteger;
    DWORD m_iWordSize;

    switch (uMsg) {
    case WM_INITDIALOG:
        pMpegMovie->pMpegAudioDecoder->get_Stereo(&m_iChannels);
        pMpegMovie->pMpegAudioDecoder->get_IntegerDecode(&m_iInteger );
        pMpegMovie->pMpegAudioDecoder->get_FrequencyDivider(&m_iSkip);
        pMpegMovie->pMpegAudioDecoder->get_DecoderAccuracy(&m_iQuality);
        pMpegMovie->pMpegAudioDecoder->get_DecoderWordSize(&m_iWordSize);
        SetButtonValues(hwnd, m_iChannels, m_iSkip,
                        m_iQuality, m_iInteger, m_iWordSize);
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDCANCEL:
            EndDialog(hwnd, wParam);
            break;

        case IDOK:
            GetButtonValues(hwnd, &m_iChannels, &m_iSkip, &m_iQuality,
                            &m_iInteger, &m_iWordSize);

            pMpegMovie->pMpegAudioDecoder->put_Stereo(m_iChannels);
            pMpegMovie->pMpegAudioDecoder->put_IntegerDecode(m_iInteger );
            pMpegMovie->pMpegAudioDecoder->put_FrequencyDivider(m_iSkip);
            pMpegMovie->pMpegAudioDecoder->put_DecoderAccuracy(m_iQuality);
            pMpegMovie->pMpegAudioDecoder->put_DecoderWordSize(m_iWordSize);
            EndDialog(hwnd, wParam);
            break;

        case IDC_AINFO:
//          DialogBoxParam(g_hInst, MAKEINTRESOURCE(IDD_VIDEOSTATS),
//                         hwnd, VideoStatsDialogProc, (LPARAM)pThis);
            break;

        case IDC_ADEFAULT:
            GetButtonValues(hwnd, &m_iChannels, &m_iSkip,
                            &m_iQuality, &m_iInteger, &m_iWordSize);

            PutDecoderInteger(chAudioChannels,    m_iChannels);
            PutDecoderInteger(chAudioFreqDivider, m_iSkip);
            PutDecoderInteger(chAudioQuality,     m_iQuality);
            PutDecoderInteger(chAudioQuarterInt,  m_iInteger);
            PutDecoderInteger(chAudioBits,        m_iWordSize);
            break;
        }
        return TRUE;

    default:
        return FALSE;

    }
}

/*****************************Private*Routine******************************\
*
* SetButtonValues
*
* Sets the buttons in the dialog
*
* History:
* dd-mm-96 - StephenE - Created
*
\**************************************************************************/
void
SetButtonValues(
    HWND m_hwnd,
    DWORD iChannels,
    DWORD iSkip,
    DWORD iQuality,
    DWORD iInteger,
    DWORD iWordSize
    )
{
    Button_SetCheck(GetDlgItem(m_hwnd, STEREO_OUTPUT), iChannels == 2);

    int iButton;
    if (iInteger) {
        iButton = IDC_INTEGER;
    }
    else {
        switch (iSkip) {
        case 1:
            iButton = FULL_FREQ;
            break;
        case 2:
            iButton = HALF_FREQ;
            break;
        case 4:
            iButton = QUARTER_FREQ;
            break;
        default:
            DbgBreak("Illegal case");
        }
    }
    Button_SetCheck(GetDlgItem(m_hwnd, iButton), TRUE);

    switch (iQuality) {
    case DECODE_HALF_FULLQ:
        iButton = D_MEDIUM;
        break;

    case DECODE_HALF_HIQ:
        iButton = D_LOW;
        break;

    default:
        iButton = D_HIGH;
        break;
    }
    Button_SetCheck(GetDlgItem(m_hwnd, iButton), TRUE);

    switch(iWordSize) {
    case 16:
        iButton = IDC_16_BIT;
        break;

    default:
        iButton = IDC_8_BIT;
        break;
    }
    Button_SetCheck(GetDlgItem(m_hwnd, iButton), TRUE);
}

/*****************************Private*Routine******************************\
* GetButtonValues
*
* Gets the values of the button settings
*
* History:
* dd-mm-96 - StephenE - Created
*
\**************************************************************************/
void
GetButtonValues(
    HWND m_hwnd,
    LPDWORD iChannels,
    LPDWORD iSkip,
    LPDWORD iQuality,
    LPDWORD iInteger,
    LPDWORD iOutputWordSize
    )
{

    *iChannels = Button_GetCheck(GetDlgItem(m_hwnd, STEREO_OUTPUT)) ? 2 : 1;
    *iInteger = 0;

    if (Button_GetCheck(GetDlgItem(m_hwnd, FULL_FREQ))) {
        *iSkip = 1;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, HALF_FREQ))) {
        *iSkip = 2;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, QUARTER_FREQ))) {
        *iSkip = 4;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, IDC_INTEGER))) {
        *iSkip = 4;
        *iInteger = 1;
    }
    else {
        DbgBreak("One button should be set");
    }

    if (Button_GetCheck(GetDlgItem(m_hwnd, D_MEDIUM))) {
        *iQuality = DECODE_HALF_FULLQ;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, D_LOW))) {
        *iQuality = DECODE_HALF_HIQ;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, D_HIGH))) {
        *iQuality = 0L;
    }
    else {
        DbgBreak("One button should be set");
    }

    if (Button_GetCheck(GetDlgItem(m_hwnd, IDC_8_BIT))) {
        *iOutputWordSize = 8;
    }
    else if (Button_GetCheck(GetDlgItem(m_hwnd, IDC_16_BIT))) {
        *iOutputWordSize = 16;
    }
    else {
        DbgBreak("One button should be set");
    }
}


/******************************Public*Routine******************************\
* StringFromId
*
*
*
* History:
* dd-mm-96 - StephenE - Created
*
\**************************************************************************/
TCHAR *
StringFromId(
    int idResource
    )
{
    static TCHAR chBuffer[ STR_MAX_STRING_LEN ];
    static TCHAR chEmpty[] = TEXT("");

    if (LoadString(hInst, idResource, chBuffer, STR_MAX_STRING_LEN) == 0) {
        return chEmpty;
    }

    return chBuffer;
}


/******************************Public*Routine******************************\
* PutDecoderDword
*
*
*
* History:
* dd-mm-96 - StephenE - Created
*
\**************************************************************************/
void
PutDecoderInteger(
    const TCHAR *pKey,
    int iValue
    )
{
    HKEY hKey;

    if (ERROR_SUCCESS == RegCreateKey(HKEY_CURRENT_USER,
                                      chRegistryKey, &hKey)) {
        DWORD dwTmp = (DWORD)iValue;
        RegSetValueEx(hKey, pKey, 0L, REG_DWORD, (LPBYTE)&dwTmp, sizeof(dwTmp));
        RegCloseKey(hKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\vcdplyer\qprops.cpp ===
// Copyright (c) 1996 - 1998  Microsoft Corporation.  All Rights Reserved.
#include <streams.h>
#include <mmreg.h>
#include <commctrl.h>

#include "project.h"
#include "mpgcodec.h"
#include <olectl.h>
#include <stdio.h>
extern HINSTANCE hInst;

// these lines copied from SDK\CLASSES\BASE\FILTER.H
#define QueryFilterInfoReleaseGraph(fi) if ((fi).pGraph) (fi).pGraph->Release();

typedef HRESULT (STDAPICALLTYPE *LPOCPF)(HWND hwndOwner, UINT x, UINT y,
    LPCOLESTR lpszCaption, ULONG cObjects, LPUNKNOWN FAR* ppUnk, ULONG cPages,
    LPCLSID pPageClsID, LCID lcid, DWORD dwReserved, LPVOID pvReserved);

typedef HRESULT (STDAPICALLTYPE *LPOI)(LPVOID pvReserved);
typedef void (STDAPICALLTYPE *LPOUI)(void);


//
// Release the reference count for those filters put into the configuration
// listbox
//

void ReleaseFilters(HWND hwndListbox)
{
    if (hwndListbox) {
        IBaseFilter* pFilter;

        for (int i=ListBox_GetCount(hwndListbox); i--;) {
            if (pFilter = (IBaseFilter*)ListBox_GetItemData(hwndListbox, i))
                pFilter->Release();
            else
                break;
        }
    }
}

INT_PTR CALLBACK ConfigDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    switch (wMsg) {
    case WM_INITDIALOG:
        {
            IFilterGraph *pFG = (IFilterGraph *) lParam;

            IEnumFilters* pEF;	
            IBaseFilter* pFilter;
            FILTER_INFO Info;

            HWND hlist = GetDlgItem(hDlg, IDC_FILTERS);
            if (pFG == NULL)
                return FALSE;

            // Grab an enumerator for the filter graph.
            HRESULT hr = pFG->EnumFilters(&pEF);

            // ASSERT(SUCCEEDED(hr));

            // Check out each filter.
            while (pEF->Next(1, &pFilter, NULL) == S_OK)
            {
                int Index;

                hr = pFilter->QueryFilterInfo(&Info);
                // ASSERT(SUCCEEDED(hr));
                QueryFilterInfoReleaseGraph(Info);

#ifdef UNICODE
                Index = ListBox_AddString(hlist, Info.achName);
#else
                CHAR    aFilterName[MAX_FILTER_NAME];
                WideCharToMultiByte(CP_ACP, 0, Info.achName, -1, aFilterName, MAX_FILTER_NAME, NULL, NULL);
                Index = ListBox_AddString(hlist, aFilterName);
#endif

                // ASSERT(Index != LB_ERR);
                // ASSERT(Index != LB_ERRSPACE);

                // Store the IBaseFilter pointer with the listbox item.
                // it gets used if the properties have to be queried
                ListBox_SetItemData(hlist, Index, pFilter);
            }

            pEF->Release();
        }
        return TRUE;

    case WM_ENDSESSION:
        if (wParam)	{
            ReleaseFilters(GetDlgItem(hDlg, IDC_FILTERS));
            EndDialog(hDlg, FALSE);
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            ReleaseFilters(GetDlgItem(hDlg, IDC_FILTERS));
            EndDialog(hDlg, TRUE);
            break;

        case IDCANCEL:
            ReleaseFilters(GetDlgItem(hDlg, IDC_FILTERS));
            EndDialog(hDlg, FALSE);
            break;

        case IDC_FILTERS:
            if (HIWORD(wParam) == LBN_SELCHANGE) {

                HRESULT hr = E_FAIL;

                HWND    hlist = GetDlgItem(hDlg, IDC_FILTERS);
                IBaseFilter *pF;
                ISpecifyPropertyPages *pSPP;

                pF = (IBaseFilter *)
                     ListBox_GetItemData(hlist, ListBox_GetCurSel(hlist));

                if (pF) {
                    hr = pF->QueryInterface(IID_ISpecifyPropertyPages,
                                                    (void **)&pSPP);
                }

                if (hr == S_OK) {
                    pSPP->Release();
                }
                EnableWindow(GetDlgItem(hDlg, IDC_PROPERTIES), hr == S_OK);
            }
            else if (HIWORD(wParam) == LBN_DBLCLK) {
                HWND hwndBtn = GetDlgItem(hDlg, IDC_PROPERTIES);
                SendMessage(hwndBtn, WM_LBUTTONDOWN, 0, 0L);
                SendMessage(hwndBtn, WM_LBUTTONUP, 0, 0L);
            }
            break;

        case IDC_PROPERTIES:
            {
                HWND hlist = GetDlgItem(hDlg, IDC_FILTERS);
                IBaseFilter *pF;
                pF = (IBaseFilter *)
                ListBox_GetItemData(hlist, ListBox_GetCurSel(hlist));

                static const TCHAR szOleControlDll[] = TEXT("OLEPRO32.dll");
                static const char szOCPF[] = "OleCreatePropertyFrame";
                static const TCHAR szOleDll[] = TEXT("OLE32.dll");
                static const char szOleInit[] = "OleInitialize";
                static const char szOleUninit[] = "OleUninitialize";

                HINSTANCE hinst = LoadLibrary(szOleControlDll);
                if (!hinst) break;

                LPOCPF lpfn = (LPOCPF)GetProcAddress(hinst, szOCPF);
                HINSTANCE hinstOLE = LoadLibrary(szOleDll);

                if (hinstOLE) {
                    LPOI lpfnInit = (LPOI)GetProcAddress(hinstOLE, szOleInit);
                    LPOUI lpfnUninit = (LPOUI)GetProcAddress(hinstOLE, szOleUninit);

                    if (lpfn && lpfnInit && lpfnUninit) {

                        (*lpfnInit) (NULL);
                        (*lpfn)(hDlg,               // Parent
                            0,                      // x coordinate
                            0,                      // y coordinate
                            L"Filter",              // Caption
                            1,                      // Number of objects
                            (IUnknown**)&pF,        // 1 object
                            0,                      // No pages :- will use
                            NULL,                   // ISpecifyPropertyPages	
                            0,                      // AmbientLocaleID(),
                            0,                      // Reserved
                            NULL);                  // Reserved
                        (*lpfnUninit) ();
                    }
                    FreeLibrary(hinstOLE);
                }
                FreeLibrary(hinst);
            }
            break;
        }
        break;
    }
    return FALSE;
}



BOOL CMpegMovie::ConfigDialog(HWND hwnd)
{
    BOOL f = TRUE;

    f = (BOOL) DialogBoxParam(hInst, MAKEINTRESOURCE(IDD_PROPPAGE),
                       hwnd, ConfigDlgProc, (DWORD_PTR)m_Fg);

    return f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\vcdplyer\resource.h ===
// Copyright (c) 1995 - 1996  Microsoft Corporation.  All Rights Reserved.
//
// These are indexes used by the toolbar.
//
#define IDC_ADEFAULT2                   4013
#define IDC_STATIC                      -1

#define IDX_SEPARATOR                   -1
#define IDX_1                           0
#define IDX_2                           1
#define IDX_3                           2
#define IDX_4                           3
#define IDX_5                           4
#define IDX_6                           5
#define IDX_7                           6
#define IDX_8                           7
#define IDX_9                           8
#define IDX_10                          9
#define IDX_11                          10
#define DEFAULT_TBAR_SIZE               14
#define NUMBER_OF_BITMAPS               11


#define ID_STATUSBAR                    8
#define ID_TOOLBAR                      9
#define ID_TRACKBAR                     10

#define IDR_MAIN_MENU                   101
#define IDR_TOOLBAR                     102
#define IDR_VIDEOCD_ICON                103
#define IDR_ACCELERATOR                 104

#define IDM_FILE_OPEN                   40001
#define IDM_FILE_CLOSE                  40002
#define IDM_FILE_EXIT                   40003


#define IDM_PROPERTIES                  40004
#define IDM_VIDEO_DECODER               40005
#define IDM_AUDIO_DECODER               40006
#define IDM_FILTERS                     40007

#define IDM_FILE_SET_LOG                40008
#define IDM_FILE_SET_PERF_LOG           40009

#define IDM_HELP_INDEX                  40100
#define IDM_HELP_USING                  40101
#define IDM_HELP_ABOUT                  40102
#define IDM_HELP_SEARCH                 40103

// Different time formats
#define IDM_TIME                        40150
#define IDM_FRAME                       40151
#define IDM_FIELD                       40152
#define IDM_SAMPLE                      40153
#define IDM_BYTES                       40154

// Toolbar commands
#define IDM_MOVIE_STOP                  40010
#define IDM_MOVIE_PLAY                  40011
#define IDM_MOVIE_PREVTRACK             40012
#define IDM_MOVIE_PAUSE                 40013
#define IDM_MOVIE_SKIP_FORE             40014
#define IDM_MOVIE_SKIP_BACK             40015
#define IDM_MOVIE_NEXTTRACK             40016

#define IDM_PERF_NEW                    40017
#define IDM_PERF_DUMP                   40018
#define IDM_FULL_SCREEN                 40019

#define IDM_MOVIE_ALIGN                 40020



#define MENU_STRING_BASE                1000

        // File
#define STR_FILE_OPEN           IDM_FILE_OPEN  + MENU_STRING_BASE
#define STR_FILE_CLOSE          IDM_FILE_CLOSE + MENU_STRING_BASE
#define STR_FILE_EXIT           IDM_FILE_EXIT  + MENU_STRING_BASE
#define STR_FILE_SET_LOG        IDM_FILE_SET_LOG  + MENU_STRING_BASE
#define STR_FILE_SET_PERF_LOG   IDM_FILE_SET_PERF_LOG  + MENU_STRING_BASE


        // Properties Menu
#define STR_PROP_VIDEO_DECODER  IDM_VIDEO_DECODER + MENU_STRING_BASE
#define STR_PROP_AUDIO_DECODER  IDM_AUDIO_DECODER + MENU_STRING_BASE
#define STR_PROP_OTHER          IDM_FILTERS + MENU_STRING_BASE

        // Time format menu
#define STR_PROP_IDM_TIME       IDM_TIME      + MENU_STRING_BASE
#define STR_PROP_IDM_FRAME      IDM_FRAME     + MENU_STRING_BASE
#define STR_PROP_IDM_FIELD      IDM_FIELD     + MENU_STRING_BASE
#define STR_PROP_IDM_SAMPLE     IDM_SAMPLE    + MENU_STRING_BASE
#define STR_PROP_IDM_BYTES      IDM_BYTES     + MENU_STRING_BASE

        // Dither Menu          OPTIONS_MENU_BASE


        // Help Menu            HELP_MENU_BASE
#define STR_HELP_INDEX          IDM_HELP_INDEX    + MENU_STRING_BASE
#define STR_HELP_USING          IDM_HELP_USING    + MENU_STRING_BASE
#define STR_HELP_ABOUT          IDM_HELP_ABOUT    + MENU_STRING_BASE
#define STR_HELP_SEARCH         IDM_HELP_SEARCH   + MENU_STRING_BASE


        // System Menu
#define STR_SYSMENU_RESTORE     1800
#define STR_SYSMENU_MOVE        1801
#define STR_SYSMENU_MINIMIZE    1802
#define STR_SYSMENU_CLOSE       1803
#define STR_SYSMENU_MAXIMIZE    1804
#define STR_SYSMENU_TASK_LIST   1805



#define STR_FILE_FILTER         2000
#define STR_APP_TITLE           2001
#define STR_APP_TITLE_LOADED    2002
#define STR_FILE_LOG_FILTER     2003
#define STR_FILE_PERF_LOG       2004


#define MPEG_CODEC_BASE         4000

#define IDD_AUDIOPROP           4000    //  MPEG_CODEC_BASE + 0
#define FULL_FREQ               MPEG_CODEC_BASE + 1
#define HALF_FREQ               MPEG_CODEC_BASE + 2
#define QUARTER_FREQ            MPEG_CODEC_BASE + 3
#define IDC_INTEGER             MPEG_CODEC_BASE + 4
#define D_HIGH                  MPEG_CODEC_BASE + 5
#define D_MEDIUM                MPEG_CODEC_BASE + 6
#define D_LOW                   MPEG_CODEC_BASE + 7
#define STEREO_OUTPUT           MPEG_CODEC_BASE + 8
#define IDC_8_BIT               MPEG_CODEC_BASE + 9
#define IDC_16_BIT              MPEG_CODEC_BASE + 10
#define IDC_ADEFAULT            MPEG_CODEC_BASE + 11
#define IDC_AINFO               MPEG_CODEC_BASE + 12


#define IDD_VIDEOPROP           4008    //  MPEG_CODEC_BASE + 9
#define NO_DECODE               MPEG_CODEC_BASE + 10
#define I_ONLY                  MPEG_CODEC_BASE + 11
#define IP_ONLY                 MPEG_CODEC_BASE + 12
#define IP_1_IN_4_B             MPEG_CODEC_BASE + 13
#define IP_2_IN_4_B             MPEG_CODEC_BASE + 14
#define IP_3_IN_4_B             MPEG_CODEC_BASE + 15
#define IP_ALL_B                MPEG_CODEC_BASE + 16
#define B_HIGH                  MPEG_CODEC_BASE + 17
#define B_MEDIUM                MPEG_CODEC_BASE + 18
#define B_LOW                   MPEG_CODEC_BASE + 19
#define OUTPUT_16BIT            MPEG_CODEC_BASE + 20
#define OUTPUT_8BIT             MPEG_CODEC_BASE + 21
#define CONVERT_OUTPUT          MPEG_CODEC_BASE + 22
#define HI_QUALITY_OUTPUT       MPEG_CODEC_BASE + 23

#define B_GREY                  MPEG_CODEC_BASE + 24
#define IGNORE_QUALITY          MPEG_CODEC_BASE + 25
#define STATS_BUTTON            MPEG_CODEC_BASE + 26
#define ID_DEFAULT              MPEG_CODEC_BASE + 27

#define IDD_VIDEOSTATS          4027    //  MPEG_CODEC_BASE + 28
#define ID_STATSBOX             MPEG_CODEC_BASE + 29
#define ID_REFRESH              MPEG_CODEC_BASE + 30

#define IDD_PROPPAGE            4040    //  MPEG_CODEC_BASE + 40
#define IDC_FILTERS             MPEG_CODEC_BASE + 41
#define IDC_PROPERTIES          MPEG_CODEC_BASE + 42

#define STR_MAX_STRING_LEN      256
#define IDS_FRAMES_DEC          MPEG_CODEC_BASE + 31
#define IDS_PROPORTION          MPEG_CODEC_BASE + 32
#define IDS_IMAGE_SIZE          MPEG_CODEC_BASE + 33
#define IDS_BUFFER_VBV          MPEG_CODEC_BASE + 34
#define IDS_BITRATE             MPEG_CODEC_BASE + 35
#define IDS_PROP_I              MPEG_CODEC_BASE + 36
#define IDS_PROP_P              MPEG_CODEC_BASE + 37
#define IDS_PROP_B              MPEG_CODEC_BASE + 38
#define IDS_SKIP_I              MPEG_CODEC_BASE + 39
#define IDS_SKIP_P              MPEG_CODEC_BASE + 40
#define IDS_SKIP_B              MPEG_CODEC_BASE + 41
#define IDS_NO_DATA             MPEG_CODEC_BASE + 42
#define IDS_NEWLINE             MPEG_CODEC_BASE + 43
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\vcdplyer\vcdplyer.cpp ===
/******************************Module*Header*******************************\
* Module Name: vcdplyer.cpp
*
* A simple Video CD player
*
*
* Created: 30-10-95
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1999  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/
#include <streams.h>
#include <mmreg.h>
#include <commctrl.h>

#include "project.h"
#include "mpgcodec.h"

#include <stdarg.h>
#include <stdio.h>


/******************************Public*Routine******************************\
* CMpegMovie
*
* Constructors and destructors
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
CMpegMovie::CMpegMovie(HWND hwndApplication)
    : m_hwndApp(hwndApplication),
      m_MediaEvent(NULL),
      m_Mode(MOVIE_NOTOPENED),
      m_Fg(NULL),
      m_Gb(NULL),
      m_Mc(NULL),
      m_Ms(NULL),
      m_Me(NULL),
      m_Vw(NULL),
      m_pStreamSelect(NULL),
      m_bFullScreen(FALSE),
      pMpegDecoder(NULL),
      pMpegAudioDecoder(NULL),
      pVideoRenderer(NULL),
      m_TimeFormat(TIME_FORMAT_MEDIA_TIME)
    {}
CMpegMovie::~CMpegMovie() {}



/******************************Public*Routine******************************\
* OpenMovie
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
HRESULT
CMpegMovie::OpenMovie(
    TCHAR *lpFileName
    )
{
    IUnknown        *pUnk;
    HRESULT         hres;

    WCHAR           FileName[MAX_PATH];

#ifdef UNICODE
    lstrcpy(FileName, lpFileName);
#else
    swprintf(FileName, L"%hs", lpFileName);
#endif

    hres = CoInitialize(NULL);
    if (hres == S_FALSE) {
        CoUninitialize();
    }

    hres = CoCreateInstance(
        g_bUseThreadedGraph ?
            CLSID_FilterGraph :
            CLSID_FilterGraphNoThread,
        NULL,
        CLSCTX_INPROC,
        IID_IUnknown,
        (LPVOID *)&pUnk);

    if (SUCCEEDED(hres)) {

        m_Mode = MOVIE_OPENED;
        hres = pUnk->QueryInterface(IID_IFilterGraph, (LPVOID *)&m_Fg);
        if (FAILED(hres)) {
            pUnk->Release();
            return hres;
        }

        hres = pUnk->QueryInterface(IID_IGraphBuilder, (LPVOID *)&m_Gb);
        if (FAILED(hres)) {
            pUnk->Release();
            m_Fg->Release(); m_Fg = NULL;
            return hres;
        }

        if (hRenderLog!=INVALID_HANDLE_VALUE) {
            m_Gb->SetLogFile((DWORD_PTR) hRenderLog);
        }

        hres = m_Gb->RenderFile(FileName, NULL);
        if (FAILED(hres)) {
            pUnk->Release();
            m_Fg->Release(); m_Fg = NULL;
            m_Gb->Release(); m_Gb = NULL;
            return hres;
        }

        if (hRenderLog!=INVALID_HANDLE_VALUE) {
            CloseHandle(hRenderLog);
            hRenderLog = INVALID_HANDLE_VALUE;
        }

        hres = pUnk->QueryInterface(IID_IMediaControl, (LPVOID *)&m_Mc);
        if (FAILED(hres)) {
            pUnk->Release();
            m_Fg->Release(); m_Fg = NULL;
            m_Gb->Release(); m_Gb = NULL;
            return hres;
        }

        //
        // Not being able to get the IMediaEvent interface does
        // necessarly mean that we can't play the graph.
        //
        pUnk->QueryInterface(IID_IMediaEvent, (LPVOID *)&m_Me);
        GetMovieEventHandle();

        pUnk->QueryInterface(IID_IMediaSeeking, (LPVOID *)&m_Ms);

        GetPerformanceInterfaces();

        if (SUCCEEDED(pUnk->QueryInterface(IID_IVideoWindow, (LPVOID *)&m_Vw))) {
            m_Vw->put_Caption(FileName);
            m_Vw->put_AutoShow(0);
        }

	hres = FindInterfaceFromFilterGraph(IID_IAMStreamSelect, (LPVOID *)&m_pStreamSelect);
	if (SUCCEEDED(hres)) {
	    DWORD cStreams;

	    m_pStreamSelect->Count(&cStreams);

	    DWORD i;

	    int iMenuItemsAdded = 0;

	    HMENU hmenu = GetMenu(m_hwndApp);
	    hmenu = GetSubMenu(hmenu, 3);

	    RemoveMenu(hmenu, 0, MF_BYPOSITION);
	    
	    DWORD dwLastGroup;
	    
	    for (i = 0; i < cStreams; i++) {
		WCHAR *pwszName;
		DWORD dwGroup;
		DWORD dwFlags;

		m_pStreamSelect->Info(i, NULL, &dwFlags, NULL, &dwGroup, &pwszName, NULL, NULL);

		if (iMenuItemsAdded > 0 && dwGroup != dwLastGroup)
		    InsertMenu(hmenu, iMenuItemsAdded++,
			       MF_SEPARATOR | MF_BYPOSITION, -1, NULL);

		dwLastGroup = dwGroup;

		TCHAR	ach[200];
		if (pwszName) {
#ifndef UNICODE
		    WideCharToMultiByte(CP_ACP,0,pwszName,-1,ach,200,NULL,NULL);
		    CoTaskMemFree(pwszName);
#else
		    lstrcpyW(ach, pwszName);
#endif
		} else {
		    wsprintf(ach, TEXT("Stream %d"), i);
		}

		DWORD dwMenuFlags = MF_STRING | MF_BYPOSITION;
		if (dwFlags & AMSTREAMSELECTINFO_ENABLED)
		    dwMenuFlags |= MF_CHECKED;
		
		InsertMenu(hmenu, iMenuItemsAdded++, dwMenuFlags, 2000+i, ach);
	    }
	}
	
        pUnk->Release();
        return S_OK;

    }
    else {
        m_Fg = NULL;
    }

    return hres;
}


/******************************Public*Routine******************************\
* CloseMovie
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
DWORD
CMpegMovie::CloseMovie(
    )
{
    m_Mode = MOVIE_NOTOPENED;
    m_bFullScreen = FALSE;

    if (m_Mc) {

        if (pMpegDecoder) {
            pMpegDecoder->Release();
            pMpegDecoder = NULL;
        }

        if (pMpegAudioDecoder) {
            pMpegAudioDecoder->Release();
            pMpegAudioDecoder = NULL;
        }

        if (pVideoRenderer) {
            pVideoRenderer->Release();
            pVideoRenderer = NULL;
        }

        if (m_Me) {
            m_MediaEvent = NULL;
            m_Me->Release();
            m_Me = NULL;
        }

        if (m_Ms) {
            m_Ms->Release();
            m_Ms = NULL;
        }

        if (m_Vw) {
            m_Vw->Release();
            m_Vw = NULL;
        }

	if (m_pStreamSelect) {
	    HMENU hmenu = GetMenu(m_hwndApp);
	    hmenu = GetSubMenu(hmenu, 3);

	    while (RemoveMenu(hmenu, 0, MF_BYPOSITION));
	    InsertMenu(hmenu, 0, MF_BYPOSITION | MF_STRING | MF_GRAYED,
		       -1, TEXT("(not available)"));
	    
	    m_pStreamSelect->Release();
	    m_pStreamSelect = NULL;
	}

        m_Mc->Release();
        m_Mc = NULL;

        if (m_Gb) {
            m_Gb->Release();
            m_Gb = NULL;
        }

        if (m_Fg) {
            m_Fg->Release();
            m_Fg = NULL;
        }


    }
    QzUninitialize();
    return 0L;
}


/******************************Public*Routine******************************\
* GetMoviePosition
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::GetMoviePosition(
    LONG *x,
    LONG *y,
    LONG *cx,
    LONG *cy
    )
{
    BOOL    bRet = FALSE;

    if (m_Vw) {
        bRet = (m_Vw->GetWindowPosition(x, y, cx, cy) == S_OK);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* PutMoviePosition
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::PutMoviePosition(
    LONG x,
    LONG y,
    LONG cx,
    LONG cy
    )
{
    BOOL    bRet = FALSE;

    if (m_Vw) {
        bRet = (m_Vw->SetWindowPosition(x, y, cx, cy) == S_OK);
    }

    return bRet;
}


/******************************Public*Routine******************************\
* SetMovieWindowState
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::SetMovieWindowState(
    long uState
    )
{
    return SUCCEEDED(m_Vw->put_WindowState(uState));
}


/******************************Public*Routine******************************\
* SetWindowForeground
*
*
*
* History:
* dd-mm-95 - Anthonyp - Created
*
\**************************************************************************/
BOOL
CMpegMovie::SetWindowForeground(
    long Focus
    )
{
    return SUCCEEDED(m_Vw->SetWindowForeground(Focus));
}


/******************************Public*Routine******************************\
* GetMovieWindowState
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::GetMovieWindowState(
    long *lpuState
    )
{
    return S_OK == m_Vw->get_WindowState(lpuState);
}


/******************************Public*Routine******************************\
* PlayMovie
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::PlayMovie(
    )
{
    REFTIME rt;
    REFTIME rtAbs;
    REFTIME rtDur;

    rt = GetCurrentPosition();
    rtDur = GetDuration();

    //
    // If we are near the end of the movie seek to the start, otherwise
    // stay where we are.
    //
    rtAbs = rt - rtDur;
    if (rtAbs < (REFTIME)0) {
        rtAbs = -rtAbs;
    }

    if (rtAbs < (REFTIME)1) {
        SeekToPosition((REFTIME)0,FALSE);
    }

    //
    // Start playing from the begining of the movie
    //
    if (pMpegDecoder) {
        pMpegDecoder->ResetFrameStatistics();
    }

    if (m_Vw) {
        long lVis;
        m_Vw->get_Visible(&lVis);
        if (lVis == OAFALSE) {
            m_Vw->put_Visible(OATRUE);
        }
    }

    //
    // Change mode after setting m_Mode but before starting the graph
    //
    m_Mode = MOVIE_PLAYING;
    SetFullScreenMode(m_bFullScreen);
    m_Mc->Run();
    return TRUE;
}


/******************************Public*Routine******************************\
* PauseMovie
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::PauseMovie(
    )
{
    m_Mode = MOVIE_PAUSED;
    m_Mc->Pause();
    return TRUE;
}


/******************************Public*Routine******************************\
* GetStateMovie
*
*
*
* History:
* 15-04-96 - AnthonyP - Created
*
\**************************************************************************/

OAFilterState
CMpegMovie::GetStateMovie(
    )
{
    OAFilterState State;
    m_Mc->GetState(INFINITE,&State);
    return State;
}


/******************************Public*Routine******************************\
* StopMovie
*
*
*
* History:
* dd-mm-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::StopMovie(
    )
{
    m_Mode = MOVIE_STOPPED;
    m_Mc->Stop();
    return TRUE;
}


/******************************Public*Routine******************************\
* StatusMovie
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
EMpegMovieMode
CMpegMovie::StatusMovie(
    )
{
    if (m_Mc) {

        FILTER_STATE    fs;
        HRESULT         hr;

        hr = m_Mc->GetState(100, (OAFilterState *)&fs);

        // Don't know what the state is so just stay at old state.
        if (hr == VFW_S_STATE_INTERMEDIATE) {
            return m_Mode;
        }

        switch (fs) {

        case State_Stopped:
            m_Mode = MOVIE_STOPPED;
            break;

        case State_Paused:
            m_Mode = MOVIE_PAUSED;
            break;

        case State_Running:
            m_Mode = MOVIE_PLAYING;
            break;
        }
    }

    return m_Mode;
}


/******************************Public*Routine******************************\
* GetMediaEventHandle
*
* Returns the IMediaEvent event hamdle for the filter graph iff the
* filter graph exists.
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
HANDLE
CMpegMovie::GetMovieEventHandle(
    )
{
    HRESULT     hr;

    if (m_Me != NULL) {

        if ( m_MediaEvent == NULL) {
            hr = m_Me->GetEventHandle((OAEVENT *)&m_MediaEvent);
        }
    }
    else {
        m_MediaEvent = NULL;
    }

    return m_MediaEvent;
}


/******************************Public*Routine******************************\
* GetMovieEventCode
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
long
CMpegMovie::GetMovieEventCode()
{
    HRESULT hr;
    long    lEventCode;
	LONG_PTR	lParam1, lParam2;

    if (m_Me != NULL) {
        hr = m_Me->GetEvent(&lEventCode, &lParam1, &lParam2, 0);
        if (SUCCEEDED(hr)) {
            return lEventCode;
        }
    }

    return 0L;
}


/******************************Public*Routine******************************\
* GetDuration
*
* Returns the duration of the current movie
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
REFTIME
CMpegMovie::GetDuration()
{
    HRESULT hr;
    LONGLONG Duration;

    // Should we seek using IMediaSelection

    if (m_TimeFormat != TIME_FORMAT_MEDIA_TIME) {
        hr = m_Ms->GetDuration(&Duration);
        if (SUCCEEDED(hr)) {
            return double(Duration);
        }
    } else if (m_Ms != NULL) {
        hr = m_Ms->GetDuration(&Duration);
        if (SUCCEEDED(hr)) {
            return double(Duration) / UNITS;
        }
    }
    return 0;
}


/******************************Public*Routine******************************\
* GetCurrentPosition
*
* Returns the duration of the current movie
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
REFTIME
CMpegMovie::GetCurrentPosition()
{
    REFTIME rt = (REFTIME)0;
    HRESULT hr;
    LONGLONG Position;

    // Should we return a media position

    if (m_TimeFormat != TIME_FORMAT_MEDIA_TIME) {
        hr = m_Ms->GetPositions(&Position, NULL);
        if (SUCCEEDED(hr)) {
            return double(Position);
        }
    } else if (m_Ms != NULL) {
        hr = m_Ms->GetPositions(&Position, NULL);
        if (SUCCEEDED(hr)) {
            return double(Position) / UNITS;
        }
    }
    return rt;
}


/*****************************Private*Routine******************************\
* SeekToPosition
*
*
*
* History:
* 30-10-95 - StephenE - Created
*
\**************************************************************************/
BOOL
CMpegMovie::SeekToPosition(
    REFTIME rt,
    BOOL bFlushData
    )
{
    HRESULT hr;
    LONGLONG llTime = LONGLONG( m_TimeFormat == TIME_FORMAT_MEDIA_TIME ? rt * double(UNITS) : rt );

    if (m_Ms != NULL) {

        FILTER_STATE fs;
        m_Mc->GetState(100, (OAFilterState *)&fs);

        m_Ms->SetPositions(&llTime, AM_SEEKING_AbsolutePositioning, NULL, 0);

        // This gets new data through to the renderers

        if (fs == State_Stopped && bFlushData){
            m_Mc->Pause();
            hr = m_Mc->GetState(INFINITE, (OAFilterState *)&fs);
            m_Mc->Stop();
        }

        if (SUCCEEDED(hr)) {
            return TRUE;
        }
    }
    return FALSE;
}


/*****************************Private*Routine******************************\
* GetPerformanceInterfaces
*
*
*
* History:
* 31-10-95 - StephenE - Created
*
\**************************************************************************/
void
CMpegMovie::GetPerformanceInterfaces(
    )
{
    FindInterfaceFromFilterGraph(IID_IMpegVideoDecoder, (LPVOID *)&pMpegDecoder);
    FindInterfaceFromFilterGraph(IID_IMpegAudioDecoder, (LPVOID *)&pMpegAudioDecoder);
    FindInterfaceFromFilterGraph(IID_IQualProp, (LPVOID *)&pVideoRenderer);
}


HRESULT
CMpegMovie::FindInterfaceFromFilterGraph(
    REFIID iid, // interface to look for
    LPVOID *lp  // place to return interface pointer in
    )
{
    IEnumFilters*   pEF;	
    IBaseFilter*        pFilter;

    // Grab an enumerator for the filter graph.
    HRESULT hr = m_Fg->EnumFilters(&pEF);

    if (FAILED(hr)) {
        return hr;
    }

    // Check out each filter.
    while (pEF->Next(1, &pFilter, NULL) == S_OK)
    {
        hr = pFilter->QueryInterface(iid, lp);
        pFilter->Release();

        if (SUCCEEDED(hr)) {
            break;
        }
    }

    pEF->Release();

    return hr;
}


/*****************************Public*Routine******************************\
* SetFullScreenMode
*
*
*
* History:
* 17-03-96 - AnthonyP - Created
*
\**************************************************************************/
void
CMpegMovie::SetFullScreenMode(BOOL bMode)
{
    m_bFullScreen = bMode;

    // Defer until we activate the movie

    if (m_Mode != MOVIE_PLAYING) {
        if (bMode == TRUE) {
            return;
        }
    }

    // Make the change now

    if (bMode == FALSE) {
        m_Vw->put_FullScreenMode(OAFALSE);
        m_Vw->put_MessageDrain((OAHWND) NULL);
    } else {
        m_Vw->put_MessageDrain((OAHWND) hwndApp);
        m_Vw->put_FullScreenMode(OATRUE);
    }
}


/*****************************Public*Routine******************************\
* IsFullScreenMode
*
*
*
* History:
* 17-03-96 - AnthonyP - Created
*
\**************************************************************************/
BOOL
CMpegMovie::IsFullScreenMode()
{
    return m_bFullScreen;
}


/*****************************Public*Routine******************************\
* IsTimeFormatSupported
*
*
*
* History:
* 12-04-96 - AnthonyP - Created
*
\**************************************************************************/
BOOL
CMpegMovie::IsTimeFormatSupported(GUID Format)
{
    return m_Ms != NULL && m_Ms->IsFormatSupported(&Format) == S_OK;
}


/*****************************Public*Routine******************************\
* IsTimeSupported
*
*
*
* History:
* 12-04-96 - AnthonyP - Created
*
\**************************************************************************/
BOOL
CMpegMovie::IsTimeSupported()
{
    return m_Ms != NULL && m_Ms->IsFormatSupported(&TIME_FORMAT_MEDIA_TIME) == S_OK;
}


/*****************************Public*Routine******************************\
* GetTimeFormat
*
*
*
* History:
* 12-04-96 - AnthonyP - Created
*
\**************************************************************************/
GUID
CMpegMovie::GetTimeFormat()
{
    return m_TimeFormat;
}

/*****************************Public*Routine******************************\
* SetTimeFormat
*
*
*
* History:
* 12-04-96 - AnthonyP - Created
*
\**************************************************************************/
BOOL
CMpegMovie::SetTimeFormat(GUID Format)
{
    HRESULT hr = m_Ms->SetTimeFormat(&Format);
    if (SUCCEEDED(hr)) {
        m_TimeFormat = Format;
    }
    return SUCCEEDED(hr);
}

/******************************Public*Routine******************************\
* SetFocus
*
*
*
* History:
* 18-09-96 - SteveDav - Created
*
\**************************************************************************/
void
CMpegMovie::SetFocus()
{
    if (m_Fg) {

	// Tell the resource manager that we are being made active.  This
	// will then cause the sound to switch to us.  This is especially
	// important when playing audio only files as there is no other
	// playback window.
        IResourceManager* pResourceManager;

        HRESULT hr = m_Fg->QueryInterface(IID_IResourceManager, (void**)&pResourceManager);

        if (SUCCEEDED(hr)) {
            IUnknown* pUnknown;

            hr = m_Fg->QueryInterface(IID_IUnknown, (void**)&pUnknown);

            if (SUCCEEDED(hr)) {
                pResourceManager->SetFocus(pUnknown);
                pUnknown->Release();
            }

            pResourceManager->Release();
        }
    }
}

BOOL CMpegMovie::SelectStream(int iStream)
{
    HRESULT hr = E_NOINTERFACE;
    
    if (m_pStreamSelect) {
	hr = m_pStreamSelect->Enable(iStream, AMSTREAMSELECTENABLE_ENABLE);
    }

    return SUCCEEDED(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\analogtunerimpl.h ===
//==========================================================================;
//
// devimpl.h : additional infrastructure to support implementing IMSVidDevice 
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef ANALOGTUNERIMPL_H
#define ANALOGTUNERIMPL_H

#include "tunerimpl.h"

namespace MSVideoControl {

template<class T, 
		 LPCGUID LibID, 
		 LPCGUID KSCategory, 
		 class MostDerivedInterface = IMSVidDevice>
    class DECLSPEC_NOVTABLE IMSVidAnalogTunerImpl : public IMSVidTunerImpl<T, LibID, KSCategory, MostDerivedInterface> {
public:
	virtual ~IMSVidAnalogTunerImpl() {}
    virtual PQTVTuner GetTuner() = 0;

	virtual HRESULT DoTune(PQTuneRequest &pTR) {
		PQChannelTuneRequest ctr(pTR);
		if (!ctr) {
	        return ImplReportError(__uuidof(T), IDS_INVALID_TR, __uuidof(IMSVidAnalogTuner), DISP_E_TYPEMISMATCH);
		}
		return NOERROR;
	}
    // IMSVidAnalogTuner
	STDMETHOD(get_Channel)(LONG * Channel)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidAnalogTuner), CO_E_NOTINITIALIZED);
        }
		if (Channel == NULL)
			return E_POINTER;
        try {
            PQTVTuner pTV(GetTuner());
            if (!pTV) {
				return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidAnalogTuner), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }
            long vsc, asc;
            return pTV->get_Channel(Channel, &vsc, &asc);
        } catch(...) {
            return E_UNEXPECTED;
        }
	}
	STDMETHOD(put_Channel)(LONG Channel)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidAnalogTuner), CO_E_NOTINITIALIZED);
        }
        try {
            PQTVTuner pTV(GetTuner());
            if (!pTV) {
				return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidAnalogTuner), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }
            return pTV->put_Channel(Channel, 0, 0);
        } catch(...) {
            return E_UNEXPECTED;
        }
	}
	STDMETHOD(get_VideoFrequency)(LONG * lcc)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidAnalogTuner), CO_E_NOTINITIALIZED);
        }
		if (lcc == NULL)
			return E_POINTER;			
        try {
            PQTVTuner pTV(GetTuner());
            if (!pTV) {
				return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidAnalogTuner), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }
            return pTV->get_VideoFrequency(lcc);
        } catch(...) {
            return E_UNEXPECTED;
        }
	}
	STDMETHOD(get_AudioFrequency)(LONG * lcc)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidAnalogTuner), CO_E_NOTINITIALIZED);
        }
		if (lcc == NULL)
			return E_POINTER;
		try {
            PQTVTuner pTV(GetTuner());
            if (!pTV) {
				return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidAnalogTuner), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }
            return pTV->get_AudioFrequency(lcc);
        } catch(...) {
            return E_UNEXPECTED;
        }
	}
	STDMETHOD(get_CountryCode)(LONG * lcc)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidAnalogTuner), CO_E_NOTINITIALIZED);
        }
		if (lcc == NULL)
			return E_POINTER;
		try {
            PQTVTuner pTV(GetTuner());
            if (!pTV) {
				return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidAnalogTuner), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }
            return pTV->get_CountryCode(lcc);
        } catch(...) {
            return E_UNEXPECTED;
        }
	}
	STDMETHOD(put_CountryCode)(LONG lcc)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidAnalogTuner), CO_E_NOTINITIALIZED);
        }
		try {
            PQTVTuner pTV(GetTuner());
            if (!pTV) {
                return HRESULT_FROM_WIN32(ERROR_INVALID_STATE);
            }
            return pTV->put_CountryCode(lcc);
        } catch(...) {
            return E_UNEXPECTED;
        }
	}
	STDMETHOD(get_SAP)(VARIANT_BOOL *pfSAP)
	{
        HRESULT hr = S_OK;
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidAnalogTuner), CO_E_NOTINITIALIZED);
        }
		if (pfSAP == NULL)
			return E_POINTER;
        DSFilterList::iterator i;
        CComQIPtr<IAMTVAudio>spTVAudio;
        for(i = m_Filters.begin(); i != m_Filters.end(); ++i){
            spTVAudio = *i;
            if(spTVAudio){
                break;
            }
        }
        
        if(i == m_Filters.end()){
            return E_NOINTERFACE;
        }
        
        long dwMode = 0;
#if 0
        hr = spTVAudio->GetHardwareSupportedTVAudioModes(&dwMode);
        if(FAILED(hr)){
            return hr;
        }  
        hr = spTVAudio->GetAvailableTVAudioModes(&dwMode);
        if(FAILED(hr)){
            return hr;
        }
#endif
        hr = spTVAudio->get_TVAudioMode(&dwMode);
        if(FAILED(hr)){
            return hr;
        }
        if(dwMode & AMTVAUDIO_MODE_LANG_B){
            *pfSAP = VARIANT_FALSE;
        }
        else{
            *pfSAP = VARIANT_TRUE;
        }
        return S_OK;
	}
	STDMETHOD(put_SAP)(VARIANT_BOOL fSAP)
	{
        HRESULT hr = S_OK;
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidAnalogTuner), CO_E_NOTINITIALIZED);
        }
        DSFilterList::iterator i;
        CComQIPtr<IAMTVAudio>spTVAudio;
        for(i = m_Filters.begin(); i != m_Filters.end(); ++i){
            spTVAudio = *i;
            if(spTVAudio){
                break;
            }
        }
        if(i == m_Filters.end()){
            return E_NOINTERFACE;
        }
        long dwMode = 0;
        if(fSAP == VARIANT_TRUE){
            dwMode = AMTVAUDIO_MODE_LANG_B | AMTVAUDIO_MODE_MONO;
            hr = spTVAudio->put_TVAudioMode(dwMode);
        }
        else{
            dwMode = AMTVAUDIO_MODE_STEREO | AMTVAUDIO_MODE_LANG_A;
            hr = spTVAudio->put_TVAudioMode(dwMode);
        }
        if(FAILED(hr)){
            return hr;
        }
		return S_OK;
	}
	STDMETHOD(ChannelAvailable)(LONG nChannel, LONG * SignalStrength, VARIANT_BOOL * fSignalPresent)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidAnalogTuner), CO_E_NOTINITIALIZED);
        }
		if (SignalStrength == NULL)
			return E_POINTER;
			
		if (fSignalPresent == NULL)
			return E_POINTER;
        CComQIPtr<IAMTuner> pTV(GetTuner());
        if (!pTV) {
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidAnalogTuner), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }			
        long curChannel = 0;
        HRESULT hr = get_Channel(&curChannel);
        if(nChannel != curChannel){
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidAnalogTuner), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }
        hr = pTV->SignalPresent(SignalStrength);
        if(FAILED(hr)){
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidAnalogTuner), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }
        if(hr == S_FALSE){
            *SignalStrength = 0;
            *fSignalPresent = VARIANT_FALSE;
            return S_OK;
        }
        CComQIPtr<IAMTVTuner> qiTV(GetTuner());
        if (!qiTV){
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidAnalogTuner), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        }
        long foundSignal;
        hr = qiTV->AutoTune(curChannel, &foundSignal);
        if(hr == S_FALSE){
            *SignalStrength = 0;
            *fSignalPresent = VARIANT_FALSE;
            return S_OK;
        }
        if(foundSignal){
            *fSignalPresent = VARIANT_TRUE;
        }
        else{
            *fSignalPresent = VARIANT_FALSE;
        }
		return S_OK;
	}
#if 0
	STDMETHOD(MinMaxChannel)(LONG * lChannelMin, LONG * lChannelMax)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidAnalogTuner), CO_E_NOTINITIALIZED);
        }
		if (lChannelMin == NULL)
			return E_POINTER;
			
		if (lChannelMax == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
#endif
};

}; //namespace

#endif
// end of file - analogtunerimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\tools\vcdplyer\vcdplyer.h ===
/******************************Module*Header*******************************\
* Module Name: vcdplyer.h
*
* Function prototype for the Video CD Player application.
*
*
* Created: dd-mm-94
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1994 - 1997  Microsoft Corporation.  All Rights Reserved.
\**************************************************************************/



/* -------------------------------------------------------------------------
** CMpegMovie - an Mpeg movie playback class.
** -------------------------------------------------------------------------
*/
enum EMpegMovieMode { MOVIE_NOTOPENED = 0x00,
                      MOVIE_OPENED = 0x01,
                      MOVIE_PLAYING = 0x02,
                      MOVIE_STOPPED = 0x03,
                      MOVIE_PAUSED = 0x04 };

struct IMpegAudioDecoder;
struct IMpegVideoDecoder;
struct IQualProp;

class CMpegMovie {

private:
    // Our state variable - records whether we are opened, playing etc.
    EMpegMovieMode   m_Mode;
    HANDLE           m_MediaEvent;
    HWND             m_hwndApp;
    BOOL             m_bFullScreen;
    GUID             m_TimeFormat;

    IFilterGraph     *m_Fg;
    IGraphBuilder    *m_Gb;
    IMediaControl    *m_Mc;
    IMediaSeeking    *m_Ms;
    IMediaEvent      *m_Me;
    IVideoWindow     *m_Vw;

    void GetPerformanceInterfaces();
    HRESULT FindInterfaceFromFilterGraph(
        REFIID iid, // interface to look for
        LPVOID *lp  // place to return interface pointer in
        );

public:
     CMpegMovie(HWND hwndApplication);
    ~CMpegMovie();

    HRESULT         OpenMovie(TCHAR *lpFileName);
    DWORD           CloseMovie();
    BOOL            PlayMovie();
    BOOL            PauseMovie();
    BOOL            StopMovie();
    OAFilterState   GetStateMovie();
    HANDLE          GetMovieEventHandle();
    long            GetMovieEventCode();
    BOOL            PutMoviePosition(LONG x, LONG y, LONG cx, LONG cy);
    BOOL            GetMoviePosition(LONG *x, LONG *y, LONG *cx, LONG *cy);
    BOOL            GetMovieWindowState(long *lpuState);
    BOOL            SetMovieWindowState(long uState);
    REFTIME         GetDuration();
    REFTIME         GetCurrentPosition();
    BOOL            SeekToPosition(REFTIME rt,BOOL bFlushData);
    EMpegMovieMode  StatusMovie();
    void            SetFullScreenMode(BOOL bMode);
    BOOL            IsFullScreenMode();
    BOOL            SetWindowForeground(long Focus);
    BOOL            IsTimeFormatSupported(GUID Format);
    BOOL            IsTimeSupported();
    BOOL            SetTimeFormat(GUID Format);
    GUID            GetTimeFormat();
    void            SetFocus();
    BOOL            ConfigDialog(HWND hwnd);
    BOOL	    SelectStream(int iStream);


    IMpegVideoDecoder   *pMpegDecoder;
    IMpegAudioDecoder   *pMpegAudioDecoder;
    IQualProp           *pVideoRenderer;
    IAMStreamSelect	*m_pStreamSelect;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\analogradiotsimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// analogradiotsimpl.h : 
// Copyright (c) Microsoft Corporation 1999.

#ifndef ANALOGRADIOTSIMPL_H
#define ANALOGRADIOTSIMPL_H

#include "tuningspaceimpl.h"

namespace BDATuningModel {

template<class T,
         class MostDerived = IAnalogRadioTuningSpace, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IAnalogRadioTSImpl : 
	public ITuningSpaceImpl<T, CChannelTuneRequest, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{

public:
    IAnalogRadioTSImpl() : m_MinFreq(BDA_UNDEFINED_CHANNEL), m_MaxFreq(BDA_UNDEFINED_CHANNEL), m_Step(0) {}
    virtual ~IAnalogRadioTSImpl() {}
    typedef ITuningSpaceImpl<T, CChannelTuneRequest, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    
    BEGIN_PROP_MAP(IAnalogRadioTSImpl)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("MinFrequency", m_MinFreq, VT_I4)
        PROP_DATA_ENTRY("MaxFrequency", m_MaxFreq, VT_I4)
        PROP_DATA_ENTRY("Step", m_Step, VT_I4)
    END_PROPERTY_MAP()

    long m_MinFreq;
    long m_MaxFreq;
    long m_Step;

// IAnalogRadioTS
    STDMETHOD(get_MinFrequency)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_MinFreq;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_MinFrequency)(long newVal)
    {   
		ATL_LOCKT();
        if (newVal > m_MaxFreq) {
		  return ImplReportError(__uuidof(T), IDS_E_INVALIDARG, __uuidof(IAnalogRadioTuningSpace), E_INVALIDARG);
		}
        m_MinFreq = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_MaxFrequency)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_MaxFreq;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_MaxFrequency)(long newVal)
    {
        if (newVal < m_MinFreq) {
		  return ImplReportError(__uuidof(T), IDS_E_INVALIDARG, __uuidof(IAnalogRadioTuningSpace), E_INVALIDARG);
		}
		ATL_LOCKT();
        m_MaxFreq = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_Step)(long* pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_Step;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_Step)(long newVal)
    {
		ATL_LOCKT();
        m_Step = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(Clone) (ITuningSpace **ppTS) {
        try {
			if (!ppTS) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppTS);
			if (FAILED(hr)) {
				return hr;
			}

			T* pt = static_cast<T*>(*ppTS);

            pt->m_MinFreq = m_MinFreq;
            pt->m_MaxFreq = m_MaxFreq;
            pt->m_Step = m_Step;

			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}

};

}; // namespace
#endif // ANALOGRADIOTSIMPL_H
// end of file -- analogradiotsimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\atscchanneltunerequestimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ATSCChannelTuneRequestimpl.h : implementation helper template for component type interface
// Copyright (c) Microsoft Corporation 1999.

#ifndef ATSCCHANNELTUNEREQUESTIMPL_H
#define ATSCCHANNELTUNEREQUESTIMPL_H

#include "channeltunerequestimpl.h"
#include "atsclocator.h"

namespace BDATuningModel {

template<class T,
         class MostDerived = IATSCChannelTuneRequest, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IATSCChannelTuneRequestImpl : 
	public IChannelTuneRequestImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// IATSCChannelTuneRequest
public:
    typedef IChannelTuneRequestImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
	virtual ~IATSCChannelTuneRequestImpl() {}
	IATSCChannelTuneRequestImpl() : m_MinorChannel(-1){}

    BEGIN_PROP_MAP(IATSCChannelTuneRequestImpl)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("Minor Channel", m_MinorChannel, VT_I4)
    END_PROP_MAP()

	long m_MinorChannel;

    STDMETHOD(get_MinorChannel)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_MinorChannel;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_MinorChannel)(long newVal)
    {
		ATL_LOCKT();
		TNATSCTuningSpace ts(m_TS);
		if (!m_TS) {
			return E_UNEXPECTED;
		}
		if (newVal != BDA_UNDEFINED_CHANNEL) {
			if (newVal < ts.MinMinorChannel()) {
				newVal = ts.MaxMinorChannel();
			} else if (newVal > ts.MaxMinorChannel()) {
				newVal = ts.MinMinorChannel();
			}
		}
        m_MinorChannel = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }

	STDMETHOD(Clone) (ITuneRequest **ppTR) {
		try {
			if (!ppTR) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppTR);
			if (FAILED(hr)) {
				return hr;
			}
			T* pt = static_cast<T*>(*ppTR);
			pt->m_MinorChannel = m_MinorChannel;

			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}

    STDMETHOD(put_Locator)(ILocator *pLocator)
    {
        try {
            if (pLocator) {
                PQATSCLocator pL(pLocator);
                if (!pL) {
                    return DISP_E_TYPEMISMATCH;
                }
            }
            return basetype::put_Locator(pLocator);
        } catch (...) {
            return E_POINTER;
        }
    }


};

}; // namespace

#endif // ATSCCHANNELTUNEREQUESTIMPL_H
// end of file -- atschchanneltunerequestimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\atsccomponenttypeimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ATSCComponentTypeimpl.h : implementation helper template for component type interface
// Copyright (c) Microsoft Corporation 1999.

#ifndef ATSCCOMPONENTTYPEIMPL_H
#define ATSCCOMPONENTTYPEIMPL_H

#include "componenttypeimpl.h"

namespace BDATuningModel {

template<class T,
         class MostDerived = IATSCComponentType, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IATSCComponentTypeImpl : 
	public IMPEG2ComponentTypeImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// IATSCComponentType
public:
    DWORD m_dwFlags;

    IATSCComponentTypeImpl() : m_dwFlags(0) {}
	virtual ~IATSCComponentTypeImpl() {}
//    typedef IATSCComponentTypeImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> thistype;
    typedef IMPEG2ComponentTypeImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    BEGIN_PROP_MAP(IATSCComponentTypeImpl)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("Flags", m_dwFlags, VT_UI4)
    END_PROP_MAP()

    STDMETHOD(get_Flags)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_dwFlags;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_Flags)(long newVal)
    {
		ATL_LOCKT();
        m_dwFlags = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
	STDMETHOD(Clone) (IComponentType **ppCT) {
		try {
			if (!ppCT) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppCT);
			if (FAILED(hr)) {
				return hr;
			}
			T* pt = static_cast<T*>(*ppCT);
			pt->m_dwFlags = m_dwFlags;

			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}
};

}; // namespace

#endif // ATSCCOMPONENTTYPEIMPL_H
// end of file -- ATSCcomponenttypeimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\atsclocatorimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ATSCLocatorimpl.h : implementation helper template for ATSClocator interface
// Copyright (c) Microsoft Corporation 2000.

#ifndef ATSCLOCATORIMPL_H
#define ATSCLOCATORIMPL_H

#include <locatorimpl.h>

namespace BDATuningModel {

template<class T,
         class MostDerived = IATSCLocator, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IATSCLocatorImpl : 
	public ILocatorImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// IATSCLocator
public:

	typedef ILocatorImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    typedef IATSCLocatorImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> thistype;

	long m_PhysicalChannel;
	long m_TSID;
	long m_ProgramNumber;

    IATSCLocatorImpl() : m_PhysicalChannel(BDA_UNDEFINED_CHANNEL),
                         m_TSID(-1),
                         m_ProgramNumber(-1) {}
	virtual ~IATSCLocatorImpl() {}
    BEGIN_PROP_MAP(thistype)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("Physical Channel", m_PhysicalChannel, VT_I4)
        PROP_DATA_ENTRY("Transport Stream ID", m_TSID, VT_I4)
        PROP_DATA_ENTRY("Program Number", m_ProgramNumber, VT_I4)
    END_PROP_MAP()

// IATSCLocator
public:
    STDMETHOD(get_PhysicalChannel)(/*[out, retval]*/ long *pPhysicalChannel) {
        try {
            if (!pPhysicalChannel) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pPhysicalChannel = m_PhysicalChannel;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_PhysicalChannel)(/*[in]*/ long NewPhysicalChannel) {
		ATL_LOCKT();
        m_PhysicalChannel = NewPhysicalChannel;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_TSID)(/*[out, retval]*/ long *pTSID) {
        try {
            if (!pTSID) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pTSID = m_TSID;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_TSID)(/*[in]*/ long NewTSID) {
		ATL_LOCKT();
        m_TSID = NewTSID;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_ProgramNumber)(/*[out, retval]*/ long *pProgramNumber) {
        try {
            if (!pProgramNumber) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pProgramNumber = m_ProgramNumber;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_ProgramNumber)(/*[in]*/ long NewProgramNumber) {
		ATL_LOCKT();
        m_ProgramNumber = NewProgramNumber;
        MARK_DIRTY(T);

	    return NOERROR;
    }
	STDMETHOD(Clone) (ILocator **ppNew) {
		try {
			if (!ppNew) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppNew);
			if (FAILED(hr)) {
				return hr;
			}
            T* pt = static_cast<T*>(*ppNew);
			pt->m_PhysicalChannel = m_PhysicalChannel;
			pt->m_TSID = m_TSID;
			pt->m_ProgramNumber = m_ProgramNumber;
			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}
};

typedef CComQIPtr<IATSCLocator> PQATSCLocator;

}; // namespace

#endif // ATSCLOCATORIMPL_H
// end of file -- ATSClocatorimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\analogtvtsimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// analogtvtsimpl.h : 
// Copyright (c) Microsoft Corporation 1999.

#ifndef ANALOGTVTSIMPL_H
#define ANALOGTVTSIMPL_H

#include "errsupp.h"
#include "tuningspaceimpl.h"
#include "ChannelTuneRequest.h"

namespace BDATuningModel {

template<class T,
         class TUNEREQUESTTYPE = CChannelTuneRequest,
         class MostDerived = IAnalogTVTuningSpace, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IAnalogTVTSImpl : 
	public ITuningSpaceImpl<T, TUNEREQUESTTYPE, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{

public:
    IAnalogTVTSImpl() : m_MinChan(BDA_UNDEFINED_CHANNEL), m_MaxChan(BDA_UNDEFINED_CHANNEL), m_InputType(TunerInputCable), m_CountryCode(0) {}
	virtual ~IAnalogTVTSImpl() {}
    typedef ITuningSpaceImpl<T, TUNEREQUESTTYPE, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    
    BEGIN_PROP_MAP(IAnalogTVTSImpl)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("MinChannel", m_MinChan, VT_I4)
        PROP_DATA_ENTRY("MaxChannel", m_MaxChan, VT_I4)
        PROP_DATA_ENTRY("InputType", m_InputType, VT_UI4)
        PROP_DATA_ENTRY("CountryCode", m_CountryCode, VT_I4)
    END_PROPERTY_MAP()

    long m_MinChan;
    long m_MaxChan;
    TunerInputType m_InputType;
    long m_CountryCode;

// IAnalogTVTS
    STDMETHOD(get_MinChannel)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_MinChan;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_MinChannel)(long newVal)
    {
		if (newVal > m_MaxChan) {
	 	    return ImplReportError(__uuidof(T), IDS_E_INVALIDARG, __uuidof(IAnalogTVTuningSpace), E_INVALIDARG);
		}
		ATL_LOCKT();
        m_MinChan = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_MaxChannel)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_MaxChan;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_MaxChannel)(long newVal)
    {
		if (newVal < m_MinChan) {
	 	    return ImplReportError(__uuidof(T), IDS_E_INVALIDARG, __uuidof(IAnalogTVTuningSpace), E_INVALIDARG);
		}
		ATL_LOCKT();
        m_MaxChan = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_InputType)(TunerInputType* pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_InputType;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_InputType)(TunerInputType newVal)
    {
		ATL_LOCKT();
        m_InputType = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }

    STDMETHOD(get_CountryCode)(long* pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_CountryCode;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_CountryCode)(long newVal)
    {
		ATL_LOCKT();
        m_CountryCode = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(Clone) (ITuningSpace **ppTS) {
        try {
			if (!ppTS) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppTS);
			if (FAILED(hr)) {
				return hr;
			}

			T* pt = static_cast<T*>(*ppTS);

            pt->m_MinChan = m_MinChan;
            pt->m_MaxChan = m_MaxChan;
            pt->m_InputType = m_InputType;
            pt->m_CountryCode = m_CountryCode;

			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}

};

}; // namespace

#endif // ANALOGTVTSIMPL_H
// end of file -- analogtvtsimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\auxintsimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// auxintsimpl.h : 
// Copyright (c) Microsoft Corporation 1999.

#ifndef AUXINTSIMPL_H
#define AUXINTSIMPL_H

#include "tuningspaceimpl.h"

namespace BDATuningModel {

template<class T,
         class MostDerived = IAuxInTuningSpace, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IAuxInTSImpl : 
	public ITuningSpaceImpl<T, CChannelTuneRequest, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{

public:
    IAuxInTSImpl() {}
    virtual ~IAuxInTSImpl() {}
    typedef ITuningSpaceImpl<T, CChannelTuneRequest, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    
    BEGIN_PROP_MAP(IAuxInTSImpl)
        CHAIN_PROP_MAP(basetype)
    END_PROPERTY_MAP()

// IAuxInTS

    STDMETHOD(Clone) (ITuningSpace **ppTS) {
        try {
			if (!ppTS) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppTS);
			if (FAILED(hr)) {
				return hr;
			}

            //			T* pt = static_cast<T*>(*ppTS);
			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}

};

}; // namespace
#endif // AUXINTSIMPL_H
// end of file -- AuxIntsimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\arity.h ===
///////////////////////////////////////////
// helper templates for use with stl <functional>
// providing argument binding for more arities
// and proper const support
///////////////////////////////////////////

#pragma once
#pragma warning(disable:4181)

#include <functional>

///////////////////////////////////////////
// Types
///////////////////////////////////////////

// Type classes for arity 0

template<class R> class arity0_function {
public:
    typedef R result_type;
};

// Template Class to define Object Type
template<class Object> class ObjectType {
public:
    typedef Object object_type;
};

// template class for arity0 member function type
template<class Object, class R> class arity0_mf :
    public  ObjectType<Object> ,
    public arity0_function<R> {
public:
    typedef R (Object::*pmf0type)();
};

// template class for arity0 member function type
template<class Object, class R> class arity0_const_mf :
    public  ObjectType<Object> ,
    public arity0_function<R> {
public:
    typedef R (Object::*pmf0type)() const;
};


// Type classes for arity 1

// template class for arity1 member function type
template<class Object, 
        class A1, 
        class R> class arity1_mf :
    public  ObjectType<Object> ,
    public std::unary_function<A1,
                             R> {
public:
    typedef R (Object::*pmf1type)(A1);
};

// template class for arity1 member function type
template<class Object, 
        class A1, 
        class R> class arity1_const_mf :
    public  ObjectType<Object> ,
    public std::unary_function<A1,
                             R> {
public:
    typedef R (Object::*pmf1type)(A1) const;
};


// Type classes for arity 2

// template class for arity2 member function type
template<class Object, 
        class A1, 
        class A2, 
        class R> class arity2_mf :
    public  ObjectType<Object> ,
    public std::binary_function<A1, 
                            A2,
                             R> {
public:
    typedef first_argument_type argument_type;
typedef R (Object::*pmf2type)(A1, A2);
};

// template class for arity2 member function type
template<class Object, 
        class A1, 
        class A2, 
        class R> class arity2_const_mf :
    public  ObjectType<Object> ,
    public std::binary_function<A1, 
                            A2,
                             R> {
public:
    typedef first_argument_type argument_type;
typedef R (Object::*pmf2type)(A1, A2) const;
};


// Type classes for arity 3

template<class A1, 
        class A2, 
        class A3, 
        class R> class arity3_function :
            public std::binary_function<A1, 
                                    A2,
                                     R> {
public:typedef first_argument_type argument_type;

    typedef A3 argument_3_type;
};

// template class for arity3 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class R> class arity3_mf :
    public  ObjectType<Object> ,
    public arity3_function<A1, 
                            A2, 
                            A3,
                             R> {
public:
    typedef R (Object::*pmf3type)(A1, A2, A3);
};

// template class for arity3 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class R> class arity3_const_mf :
    public  ObjectType<Object> ,
    public arity3_function<A1, 
                            A2, 
                            A3,
                             R> {
public:
    typedef R (Object::*pmf3type)(A1, A2, A3) const;
};


// Type classes for arity 4

template<class A1, 
        class A2, 
        class A3, 
        class A4, 
        class R> class arity4_function :
            public arity3_function<A1, 
                                    A2, 
                                    A3,
                                     R> {
public:
    typedef A4 argument_4_type;
};

// template class for arity4 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class R> class arity4_mf :
    public  ObjectType<Object> ,
    public arity4_function<A1, 
                            A2, 
                            A3, 
                            A4,
                             R> {
public:
    typedef R (Object::*pmf4type)(A1, A2, A3, A4);
};

// template class for arity4 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class R> class arity4_const_mf :
    public  ObjectType<Object> ,
    public arity4_function<A1, 
                            A2, 
                            A3, 
                            A4,
                             R> {
public:
    typedef R (Object::*pmf4type)(A1, A2, A3, A4) const;
};


// Type classes for arity 5

template<class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class R> class arity5_function :
            public arity4_function<A1, 
                                    A2, 
                                    A3, 
                                    A4,
                                     R> {
public:
    typedef A5 argument_5_type;
};

// template class for arity5 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class R> class arity5_mf :
    public  ObjectType<Object> ,
    public arity5_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5,
                             R> {
public:
    typedef R (Object::*pmf5type)(A1, A2, A3, A4, A5);
};

// template class for arity5 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class R> class arity5_const_mf :
    public  ObjectType<Object> ,
    public arity5_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5,
                             R> {
public:
    typedef R (Object::*pmf5type)(A1, A2, A3, A4, A5) const;
};


// Type classes for arity 6

template<class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class R> class arity6_function :
            public arity5_function<A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5,
                                     R> {
public:
    typedef A6 argument_6_type;
};

// template class for arity6 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class R> class arity6_mf :
    public  ObjectType<Object> ,
    public arity6_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6,
                             R> {
public:
    typedef R (Object::*pmf6type)(A1, A2, A3, A4, A5, A6);
};

// template class for arity6 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class R> class arity6_const_mf :
    public  ObjectType<Object> ,
    public arity6_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6,
                             R> {
public:
    typedef R (Object::*pmf6type)(A1, A2, A3, A4, A5, A6) const;
};


// Type classes for arity 7

template<class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class R> class arity7_function :
            public arity6_function<A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6,
                                     R> {
public:
    typedef A7 argument_7_type;
};

// template class for arity7 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class R> class arity7_mf :
    public  ObjectType<Object> ,
    public arity7_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7,
                             R> {
public:
    typedef R (Object::*pmf7type)(A1, A2, A3, A4, A5, A6, A7);
};

// template class for arity7 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class R> class arity7_const_mf :
    public  ObjectType<Object> ,
    public arity7_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7,
                             R> {
public:
    typedef R (Object::*pmf7type)(A1, A2, A3, A4, A5, A6, A7) const;
};


// Type classes for arity 8

template<class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class R> class arity8_function :
            public arity7_function<A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6, 
                                    A7,
                                     R> {
public:
    typedef A8 argument_8_type;
};

// template class for arity8 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class R> class arity8_mf :
    public  ObjectType<Object> ,
    public arity8_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8,
                             R> {
public:
    typedef R (Object::*pmf8type)(A1, A2, A3, A4, A5, A6, A7, A8);
};

// template class for arity8 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class R> class arity8_const_mf :
    public  ObjectType<Object> ,
    public arity8_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8,
                             R> {
public:
    typedef R (Object::*pmf8type)(A1, A2, A3, A4, A5, A6, A7, A8) const;
};


// Type classes for arity 9

template<class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class R> class arity9_function :
            public arity8_function<A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6, 
                                    A7, 
                                    A8,
                                     R> {
public:
    typedef A9 argument_9_type;
};

// template class for arity9 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class R> class arity9_mf :
    public  ObjectType<Object> ,
    public arity9_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9,
                             R> {
public:
    typedef R (Object::*pmf9type)(A1, A2, A3, A4, A5, A6, A7, A8, A9);
};

// template class for arity9 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class R> class arity9_const_mf :
    public  ObjectType<Object> ,
    public arity9_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9,
                             R> {
public:
    typedef R (Object::*pmf9type)(A1, A2, A3, A4, A5, A6, A7, A8, A9) const;
};


// Type classes for arity 10

template<class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class R> class arity10_function :
            public arity9_function<A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6, 
                                    A7, 
                                    A8, 
                                    A9,
                                     R> {
public:
    typedef A10 argument_10_type;
};

// template class for arity10 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class R> class arity10_mf :
    public  ObjectType<Object> ,
    public arity10_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10,
                             R> {
public:
    typedef R (Object::*pmf10type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
};

// template class for arity10 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class R> class arity10_const_mf :
    public  ObjectType<Object> ,
    public arity10_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10,
                             R> {
public:
    typedef R (Object::*pmf10type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const;
};


// Type classes for arity 11

template<class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class R> class arity11_function :
            public arity10_function<A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6, 
                                    A7, 
                                    A8, 
                                    A9, 
                                    A10,
                                     R> {
public:
    typedef A11 argument_11_type;
};

// template class for arity11 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class R> class arity11_mf :
    public  ObjectType<Object> ,
    public arity11_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11,
                             R> {
public:
    typedef R (Object::*pmf11type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
};

// template class for arity11 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class R> class arity11_const_mf :
    public  ObjectType<Object> ,
    public arity11_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11,
                             R> {
public:
    typedef R (Object::*pmf11type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const;
};


// Type classes for arity 12

template<class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class R> class arity12_function :
            public arity11_function<A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6, 
                                    A7, 
                                    A8, 
                                    A9, 
                                    A10, 
                                    A11,
                                     R> {
public:
    typedef A12 argument_12_type;
};

// template class for arity12 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class R> class arity12_mf :
    public  ObjectType<Object> ,
    public arity12_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12,
                             R> {
public:
    typedef R (Object::*pmf12type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
};

// template class for arity12 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class R> class arity12_const_mf :
    public  ObjectType<Object> ,
    public arity12_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12,
                             R> {
public:
    typedef R (Object::*pmf12type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const;
};


// Type classes for arity 13

template<class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class R> class arity13_function :
            public arity12_function<A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6, 
                                    A7, 
                                    A8, 
                                    A9, 
                                    A10, 
                                    A11, 
                                    A12,
                                     R> {
public:
    typedef A13 argument_13_type;
};

// template class for arity13 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class R> class arity13_mf :
    public  ObjectType<Object> ,
    public arity13_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12, 
                            A13,
                             R> {
public:
    typedef R (Object::*pmf13type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
};

// template class for arity13 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class R> class arity13_const_mf :
    public  ObjectType<Object> ,
    public arity13_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12, 
                            A13,
                             R> {
public:
    typedef R (Object::*pmf13type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const;
};


// Type classes for arity 14

template<class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class A14, 
        class R> class arity14_function :
            public arity13_function<A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6, 
                                    A7, 
                                    A8, 
                                    A9, 
                                    A10, 
                                    A11, 
                                    A12, 
                                    A13,
                                     R> {
public:
    typedef A14 argument_14_type;
};

// template class for arity14 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class A14, 
        class R> class arity14_mf :
    public  ObjectType<Object> ,
    public arity14_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12, 
                            A13, 
                            A14,
                             R> {
public:
    typedef R (Object::*pmf14type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
};

// template class for arity14 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class A14, 
        class R> class arity14_const_mf :
    public  ObjectType<Object> ,
    public arity14_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12, 
                            A13, 
                            A14,
                             R> {
public:
    typedef R (Object::*pmf14type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const;
};


// Type classes for arity 15

template<class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class A14, 
        class A15, 
        class R> class arity15_function :
            public arity14_function<A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6, 
                                    A7, 
                                    A8, 
                                    A9, 
                                    A10, 
                                    A11, 
                                    A12, 
                                    A13, 
                                    A14,
                                     R> {
public:
    typedef A15 argument_15_type;
};

// template class for arity15 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class A14, 
        class A15, 
        class R> class arity15_mf :
    public  ObjectType<Object> ,
    public arity15_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12, 
                            A13, 
                            A14, 
                            A15,
                             R> {
public:
    typedef R (Object::*pmf15type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
};

// template class for arity15 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class A14, 
        class A15, 
        class R> class arity15_const_mf :
    public  ObjectType<Object> ,
    public arity15_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12, 
                            A13, 
                            A14, 
                            A15,
                             R> {
public:
    typedef R (Object::*pmf15type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const;
};

// template class for arity0 member function type
template<class Object, class R> class std_arity0_mf :
    public  ObjectType<Object> ,
    public arity0_function<R> {
public:
    typedef R ( __stdcall Object::*pmf0type)();
};

// template class for arity0 member function type
template<class Object, class R> class std_arity0_const_mf :
    public  ObjectType<Object> ,
    public arity0_function<R> {
public:
    typedef R ( __stdcall Object::*pmf0type)() const;
};

// template class for arity1 member function type
template<class Object, 
        class A1, 
        class R> class std_arity1_mf :
    public  ObjectType<Object> ,
    public std::unary_function<A1,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf1type)(A1);
};

// template class for arity1 member function type
template<class Object, 
        class A1, 
        class R> class std_arity1_const_mf :
    public  ObjectType<Object> ,
    public std::unary_function<A1,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf1type)(A1) const;
};

// template class for arity2 member function type
template<class Object, 
        class A1, 
        class A2, 
        class R> class std_arity2_mf :
    public  ObjectType<Object> ,
    public std::binary_function<A1, 
                            A2,
                             R> {
public:
    typedef first_argument_type argument_type;
typedef R ( __stdcall Object::*pmf2type)(A1, A2);
};

// template class for arity2 member function type
template<class Object, 
        class A1, 
        class A2, 
        class R> class std_arity2_const_mf :
    public  ObjectType<Object> ,
    public std::binary_function<A1, 
                            A2,
                             R> {
public:
    typedef first_argument_type argument_type;
typedef R ( __stdcall Object::*pmf2type)(A1, A2) const;
};

// template class for arity3 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class R> class std_arity3_mf :
    public  ObjectType<Object> ,
    public arity3_function<A1, 
                            A2, 
                            A3,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf3type)(A1, A2, A3);
};

// template class for arity3 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class R> class std_arity3_const_mf :
    public  ObjectType<Object> ,
    public arity3_function<A1, 
                            A2, 
                            A3,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf3type)(A1, A2, A3) const;
};

// template class for arity4 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class R> class std_arity4_mf :
    public  ObjectType<Object> ,
    public arity4_function<A1, 
                            A2, 
                            A3, 
                            A4,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf4type)(A1, A2, A3, A4);
};

// template class for arity4 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class R> class std_arity4_const_mf :
    public  ObjectType<Object> ,
    public arity4_function<A1, 
                            A2, 
                            A3, 
                            A4,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf4type)(A1, A2, A3, A4) const;
};

// template class for arity5 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class R> class std_arity5_mf :
    public  ObjectType<Object> ,
    public arity5_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf5type)(A1, A2, A3, A4, A5);
};

// template class for arity5 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class R> class std_arity5_const_mf :
    public  ObjectType<Object> ,
    public arity5_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf5type)(A1, A2, A3, A4, A5) const;
};

// template class for arity6 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class R> class std_arity6_mf :
    public  ObjectType<Object> ,
    public arity6_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf6type)(A1, A2, A3, A4, A5, A6);
};

// template class for arity6 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class R> class std_arity6_const_mf :
    public  ObjectType<Object> ,
    public arity6_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf6type)(A1, A2, A3, A4, A5, A6) const;
};

// template class for arity7 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class R> class std_arity7_mf :
    public  ObjectType<Object> ,
    public arity7_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf7type)(A1, A2, A3, A4, A5, A6, A7);
};

// template class for arity7 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class R> class std_arity7_const_mf :
    public  ObjectType<Object> ,
    public arity7_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf7type)(A1, A2, A3, A4, A5, A6, A7) const;
};

// template class for arity8 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class R> class std_arity8_mf :
    public  ObjectType<Object> ,
    public arity8_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf8type)(A1, A2, A3, A4, A5, A6, A7, A8);
};

// template class for arity8 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class R> class std_arity8_const_mf :
    public  ObjectType<Object> ,
    public arity8_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf8type)(A1, A2, A3, A4, A5, A6, A7, A8) const;
};

// template class for arity9 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class R> class std_arity9_mf :
    public  ObjectType<Object> ,
    public arity9_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf9type)(A1, A2, A3, A4, A5, A6, A7, A8, A9);
};

// template class for arity9 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class R> class std_arity9_const_mf :
    public  ObjectType<Object> ,
    public arity9_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf9type)(A1, A2, A3, A4, A5, A6, A7, A8, A9) const;
};

// template class for arity10 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class R> class std_arity10_mf :
    public  ObjectType<Object> ,
    public arity10_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf10type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10);
};

// template class for arity10 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class R> class std_arity10_const_mf :
    public  ObjectType<Object> ,
    public arity10_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf10type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10) const;
};

// template class for arity11 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class R> class std_arity11_mf :
    public  ObjectType<Object> ,
    public arity11_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf11type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11);
};

// template class for arity11 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class R> class std_arity11_const_mf :
    public  ObjectType<Object> ,
    public arity11_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf11type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11) const;
};

// template class for arity12 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class R> class std_arity12_mf :
    public  ObjectType<Object> ,
    public arity12_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf12type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12);
};

// template class for arity12 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class R> class std_arity12_const_mf :
    public  ObjectType<Object> ,
    public arity12_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf12type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12) const;
};

// template class for arity13 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class R> class std_arity13_mf :
    public  ObjectType<Object> ,
    public arity13_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12, 
                            A13,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf13type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13);
};

// template class for arity13 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class R> class std_arity13_const_mf :
    public  ObjectType<Object> ,
    public arity13_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12, 
                            A13,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf13type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13) const;
};

// template class for arity14 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class A14, 
        class R> class std_arity14_mf :
    public  ObjectType<Object> ,
    public arity14_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12, 
                            A13, 
                            A14,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf14type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14);
};

// template class for arity14 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class A14, 
        class R> class std_arity14_const_mf :
    public  ObjectType<Object> ,
    public arity14_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12, 
                            A13, 
                            A14,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf14type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14) const;
};

// template class for arity15 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class A14, 
        class A15, 
        class R> class std_arity15_mf :
    public  ObjectType<Object> ,
    public arity15_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12, 
                            A13, 
                            A14, 
                            A15,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf15type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15);
};

// template class for arity15 member function type
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class A14, 
        class A15, 
        class R> class std_arity15_const_mf :
    public  ObjectType<Object> ,
    public arity15_function<A1, 
                            A2, 
                            A3, 
                            A4, 
                            A5, 
                            A6, 
                            A7, 
                            A8, 
                            A9, 
                            A10, 
                            A11, 
                            A12, 
                            A13, 
                            A14, 
                            A15,
                             R> {
public:
    typedef R ( __stdcall Object::*pmf15type)(A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14, A15) const;
};


///////////////////////////////////////////
// Storage
///////////////////////////////////////////
// Template Class for object storage
template<class Object> class store_object {
public:
    explicit inline store_object(Object objinit) : objval(objinit) {}
    inline store_object(const store_object &init) : objval(init.objval) {}
protected:
    Object objval;
};


// storage allocation classes for arity 0

// Template Class for arity 0 function ptr storage
template<class R> class arity0fp:
                public arity0_function<R> {
public:
    typedef R (*const pf0type) ();
    explicit inline arity0fp(pf0type pfi) : 
        pf0(pfi) {}
    inline arity0fp(const arity0fp& fi) : 
        pf0(fi.pf0) {}
    inline R operator()() const {
        return pf0();
    }
    pf0type pf0;
};

// Template Function for arity 0 function ptr storage
template<class R> inline arity0fp<R> 
            arity0_pointer(R (*const pfi)()) {
                return arity0fp<R>(pfi);
};


// Template Class for arity 0 pmf storage
template<class Object, class R> class arity0pmf:
                public arity0_mf<Object, R> {
public:
    typedef arity0_mf<Object, R>::object_type object_type;
    explicit inline arity0pmf(pmf0type pmfi) : 
        pmf0(pmfi) {}
    inline arity0pmf(const arity0pmf& pmfi) : pmf0(pmfi.pmf0) {}
    inline virtual R operator()(Object& o ) const {
        return (o.*pmf0)();
    }
    pmf0type pmf0;
};

template<class Object, class R> class arity0pmf_ptr:
    public arity0pmf<Object, R>, public std::unary_function<Object, R> {
public:
    explicit inline arity0pmf_ptr(pmf0type pmfi) : arity0pmf<Object, R>(pmfi) {}
    inline arity0pmf_ptr(const arity0pmf_ptr& pmfi) : arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o ) const {
        return (o.*pmf0)();
    }
    inline virtual R operator()(Object* o ) const {
        return (o->*pmf0)();
    }
};

// Template Function for arity 0 pmf storage
template<class Object, class R> inline arity0pmf_ptr<Object, R>
            arity0_member_ptr(R (Object::*const pmfi)()) {
                return arity0pmf_ptr<Object, R>(pmfi);
};

// Template Function for arity 0 pmf storage
template<class Object, class R> inline arity0pmf<Object, R>
            arity0_member(R (Object::*const pmfi)()) {
                return arity0pmf<Object, R>(pmfi);
};


// Template Class for arity 0 const pmf storage
template<class Object, class R> class arity0pmf_const:
                public arity0_const_mf<const Object, R> {
public:
    typedef arity0_const_mf<const Object, R>::object_type object_type;
    explicit inline arity0pmf_const(pmf0type pmfi) : 
        pmf0(pmfi) {}
    inline arity0pmf_const(const arity0pmf_const& pmfi) : pmf0(pmfi.pmf0) {}
    inline virtual R operator()(const Object& o ) const {
        return (o.*pmf0)();
    }
    pmf0type pmf0;
};

// Template Function for arity 0 const pmf storage
template<const class Object, class R> inline arity0pmf_const<const Object, R>
            arity0_const_member(R (Object::*const pmfi)() const) {
                return arity0pmf_const<const Object, R>(pmfi);
};


// Template Class for arity 0 obj&pmf ref storage
template<class Function> class arity0opmf:
                public arity0pmf<Function::object_type, Function::result_type>,
                public store_object<Function::object_type&> {
public:
    explicit inline arity0opmf(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), arity0pmf<Function::object_type, Function::result_type>(f) {}
    explicit inline arity0opmf(Function::object_type& oi, pmf0type pmfi) : 
        store_object<Function::object_type&>(oi), arity0pmf<Function::object_type, Function::result_type>(pmfi) {}
    inline arity0opmf(const arity0opmf& bndri) : 
        store_object<Function::object_type&>(bndri), arity0pmf<Function::object_type, Function::result_type>(bndri) {}
    inline Function::result_type operator()() const {
        return (objval.*pmf0)();
    }
    pmf0type pmf0;
};


// Template Function for arity 0 obj&pmf ref storage
template<class Function, class Object> inline arity0opmf<Function>
            arity0_member_obj(Object& oi, const Function &f) {
                return arity0opmf<Function>(Function::object_type(oi), Function::pmf0type(f.pmf0));
};


// Template Class for arity 0 const obj&pmf ref storage
template<class Function> class arity0opmf_const:
                public arity0pmf_const<const Function::object_type, Function::result_type>,
                public store_object<const Function::object_type&> {
public:
    explicit inline arity0opmf_const(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), arity0pmf_const<Function::object_type, Function::result_type>(f) {}
    explicit inline arity0opmf_const(Function::object_type& oi, pmf0type pmfi) : 
        store_object<Function::object_type&>(oi), arity0pmf_const<Function::object_type, Function::result_type>(pmfi) {}
    inline arity0opmf_const(const arity0opmf_const& bndri) : 
        store_object<Function::object_type&>(bndri), arity0pmf_const<Function::object_type, Function::result_type>(bndri) {}
    inline Function::result_type operator()() const {
        return (objval.*pmf0)();
    }
    pmf0type pmf0;
};


// Template Function for arity 0 const obj&pmf ref storage
template<class Function, class Object> inline arity0opmf_const<Function>
            arity0_const_member_obj(Object& oi, const Function &f) {
                return arity0opmf_const<Function>(Function::object_type(oi), Function::pmf0type(f.pmf0));
};



// storage allocation classes for arity 1

// Template Class for arity 1 function ptr storage
template<class A1, 
        class R> class arity1fp:
                public std::unary_function<A1, 
                R>,
                public arity0fp<R> {
public:
    typedef std::unary_function<A1, 
            R>::result_type result_type;
    typedef R (*const pf1type) (A1);
    explicit inline arity1fp(pf1type pfi) : 
        arity0fp<R>(reinterpret_cast<pf0type>(pfi)) {}
    inline arity1fp(const arity1fp& fi) : 
        arity0fp<R>(fi) {}
    inline R operator()(A1 a1) const {
        pf1type pf = reinterpret_cast<pf1type>(pf0);
        return pf(a1);
    }
};

// Template Function for arity 1 function ptr storage
template<class A1, 
                class R> inline arity1fp<A1, 
                R> 
            arity1_pointer(R (*const pfi)(A1)) {
                return arity1fp<A1, 
                R>(pfi);
};


// Template Class for arity 1 pmf storage
template<class Object, 
        class A1, 
        class R> class arity1pmf:
                public arity1_mf<Object, 
                A1, 
                R>,
                public arity0pmf<Object, R> {
public:
    typedef std::unary_function<A1, 
            R>::result_type result_type;
    typedef arity1_mf<Object, 
                A1, 
                R>::object_type object_type;
    explicit inline arity1pmf(pmf1type pmfi) : 
        arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline arity1pmf(const arity1pmf& pmfi) : arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1) const {
        pmf1type pmf = reinterpret_cast<pmf1type>(pmf0);
        return (o.*pmf)(a1);
    }
};

// Template Function for arity 1 pmf storage
template<class Object, 
                class A1, 
                class R> inline arity1pmf<Object, 
                A1, 
                R>
            arity1_member(R (Object::*const pmfi)(A1)) {
                return arity1pmf<Object, 
                A1, 
                R>(pmfi);
};


// Template Class for arity 1 const pmf storage
template<class Object, 
        class A1, 
        class R> class arity1pmf_const:
                public arity1_const_mf<const Object, 
                A1, 
                R>,
                public arity0pmf_const<const Object, R> {
public:
    typedef std::unary_function<A1, 
            R>::result_type result_type;
    typedef arity1_const_mf<const Object, 
                A1, 
                R>::object_type object_type;
    explicit inline arity1pmf_const(pmf1type pmfi) : 
        arity0pmf_const<const Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline arity1pmf_const(const arity1pmf_const& pmfi) : arity0pmf_const<Object, R>(pmfi) {}
    inline virtual R operator()(const Object& o, A1 a1) const {
        pmf1type pmf = reinterpret_cast<pmf1type>(pmf0);
        return (o.*pmf)(a1);
    }
};

// Template Function for arity 1 const pmf storage
template<const class Object, 
                class A1, 
                class R> inline arity1pmf_const<const Object, 
                A1, 
                R>
            arity1_const_member(R (Object::*const pmfi)(A1) const) {
                return arity1pmf_const<const Object, 
                A1, 
                R>(pmfi);
};


// Template Class for arity 1 obj&pmf ref storage
template<class Function> class arity1opmf:
                public arity1pmf<Function::object_type, 
                Function::argument_type, 
                Function::result_type>,
                public store_object<Function::object_type&> {
public:
    explicit inline arity1opmf(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), arity1pmf<Function::object_type, 
                Function::argument_type, 
                Function::result_type>(f) {}
    explicit inline arity1opmf(Function::object_type& oi, pmf1type pmfi) : 
        store_object<Function::object_type&>(oi), arity1pmf<Function::object_type, 
                Function::argument_type, 
                Function::result_type>(pmfi) {}
    inline arity1opmf(const arity1opmf& bndri) : 
        store_object<Function::object_type&>(bndri), arity1pmf<Function::object_type, 
                Function::argument_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::argument_type a1) const {
        pmf1type pmf = reinterpret_cast<pmf1type>(pmf0);
        return (objval.*pmf)(a1);
    }
};


// Template Function for arity 1 obj&pmf ref storage
template<class Function, class Object> inline arity1opmf<Function>
            arity1_member_obj(Object& oi, const Function &f) {
                return arity1opmf<Function>(Function::object_type(oi), Function::pmf1type(f.pmf0));
};


// Template Class for arity 1 const obj&pmf ref storage
template<class Function> class arity1opmf_const:
                public arity1pmf_const<const Function::object_type, 
                Function::argument_type, 
                Function::result_type>,
                public store_object<const Function::object_type&> {
public:
    explicit inline arity1opmf_const(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), arity1pmf_const<Function::object_type, 
                Function::argument_type, 
                Function::result_type>(f) {}
    explicit inline arity1opmf_const(Function::object_type& oi, pmf1type pmfi) : 
        store_object<Function::object_type&>(oi), arity1pmf_const<Function::object_type, 
                Function::argument_type, 
                Function::result_type>(pmfi) {}
    inline arity1opmf_const(const arity1opmf_const& bndri) : 
        store_object<Function::object_type&>(bndri), arity1pmf_const<Function::object_type, 
                Function::argument_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::argument_type a1) const {
        pmf1type pmf = reinterpret_cast<pmf1type>(pmf0);
        return (objval.*pmf)(a1);
    }
};


// Template Function for arity 1 const obj&pmf ref storage
template<class Function, class Object> inline arity1opmf_const<Function>
            arity1_const_member_obj(Object& oi, const Function &f) {
                return arity1opmf_const<Function>(Function::object_type(oi), Function::pmf1type(f.pmf0));
};



// storage allocation classes for arity 2

// Template Class for arity 2 function ptr storage
template<class A1, 
        class A2, 
        class R> class arity2fp:
                public std::binary_function<A1, 
                A2, 
                R>,
                public arity0fp<R> {
public:
    typedef std::binary_function<A1, 
            A2, 
            R>::result_type result_type;
    typedef std::binary_function<A1, 
            A2, 
            R>::first_argument_type first_argument_type;
    typedef R (*const pf2type) (A1, A2);
    explicit inline arity2fp(pf2type pfi) : 
        arity0fp<R>(reinterpret_cast<pf0type>(pfi)) {}
    inline arity2fp(const arity2fp& fi) : 
        arity0fp<R>(fi) {}
    inline R operator()(A1 a1, 
                        A2 a2) const {
        pf2type pf = reinterpret_cast<pf2type>(pf0);
        return pf(a1, a2);
    }
};

// Template Function for arity 2 function ptr storage
template<class A1, 
                class A2, 
                class R> inline arity2fp<A1, 
                A2, 
                R> 
            arity2_pointer(R (*const pfi)(A1, 
                                    A2)) {
                return arity2fp<A1, 
                A2, 
                R>(pfi);
};

// Template Class for arity 2 pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class R> class arity2pmf:
                public arity2_mf<Object, 
                A1, 
                A2, 
                R>,
                public arity0pmf<Object, R> {
public:
    typedef std::binary_function<A1, 
            A2, 
            R>::result_type result_type;
    typedef std::binary_function<A1, 
            A2, 
            R>::first_argument_type first_argument_type;
    typedef arity2_mf<Object, 
                A1, 
                A2, 
                R>::object_type object_type;
    explicit inline arity2pmf(pmf2type pmfi) : 
        arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline arity2pmf(const arity2pmf& pmfi) : arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1, 
                        A2 a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (o.*pmf)(a1, a2);
    }
};

// Template Function for arity 2 pmf storage
template<class Object, 
                class A1, 
                class A2, 
                class R> inline arity2pmf<Object, 
                A1, 
                A2, 
                R>
            arity2_member(R (Object::*const pmfi)(A1, 
                                    A2)) {
                return arity2pmf<Object, 
                A1, 
                A2, 
                R>(pmfi);
};


// Template Class for arity 2 const pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class R> class arity2pmf_const:
                public arity2_const_mf<const Object, 
                A1, 
                A2, 
                R>,
                public arity0pmf_const<const Object, R> {
public:
    typedef std::binary_function<A1, 
            A2, 
            R>::result_type result_type;
    typedef std::binary_function<A1, 
            A2, 
            R>::first_argument_type first_argument_type;
    typedef arity2_const_mf<const Object, 
                A1, 
                A2, 
                R>::object_type object_type;
    explicit inline arity2pmf_const(pmf2type pmfi) : 
        arity0pmf_const<const Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline arity2pmf_const(const arity2pmf_const& pmfi) : arity0pmf_const<Object, R>(pmfi) {}
    inline virtual R operator()(const Object& o, A1 a1, 
                        A2 a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (o.*pmf)(a1, a2);
    }
};

// Template Function for arity 2 const pmf storage
template<const class Object, 
                class A1, 
                class A2, 
                class R> inline arity2pmf_const<const Object, 
                A1, 
                A2, 
                R>
            arity2_const_member(R (Object::*const pmfi)(A1, 
                                    A2) const) {
                return arity2pmf_const<const Object, 
                A1, 
                A2, 
                R>(pmfi);
};

// Template Class for arity 2 obj&pmf ref storage
template<class Function> class arity2opmf:
                public arity2pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::result_type>,
                public store_object<Function::object_type&> {
public:
    explicit inline arity2opmf(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), arity2pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::result_type>(f) {}
    explicit inline arity2opmf(Function::object_type& oi, pmf2type pmfi) : 
        store_object<Function::object_type&>(oi), arity2pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::result_type>(pmfi) {}
    inline arity2opmf(const arity2opmf& bndri) : 
        store_object<Function::object_type&>(bndri), arity2pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::first_argument_type a1, 
                        Function::second_argument_type a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (objval.*pmf)(a1, a2);
    }
};


// Template Function for arity 2 obj&pmf ref storage
template<class Function, class Object> inline arity2opmf<Function>
            arity2_member_obj(Object& oi, const Function &f) {
                return arity2opmf<Function>(Function::object_type(oi), Function::pmf2type(f.pmf0));
};


// Template Class for arity 2 const obj&pmf ref storage
template<class Function> class arity2opmf_const:
                public arity2pmf_const<const Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::result_type>,
                public store_object<const Function::object_type&> {
public:
    explicit inline arity2opmf_const(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), arity2pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::result_type>(f) {}
    explicit inline arity2opmf_const(Function::object_type& oi, pmf2type pmfi) : 
        store_object<Function::object_type&>(oi), arity2pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::result_type>(pmfi) {}
    inline arity2opmf_const(const arity2opmf_const& bndri) : 
        store_object<Function::object_type&>(bndri), arity2pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::first_argument_type a1, 
                        Function::second_argument_type a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (objval.*pmf)(a1, a2);
    }
};


// Template Function for arity 2 const obj&pmf ref storage
template<class Function, class Object> inline arity2opmf_const<Function>
            arity2_const_member_obj(Object& oi, const Function &f) {
                return arity2opmf_const<Function>(Function::object_type(oi), Function::pmf2type(f.pmf0));
};



// storage allocation classes for arity 3

// Template Class for arity 3 function ptr storage
template<class A1, 
        class A2, 
        class A3, 
        class R> class arity3fp:
                public arity3_function<A1, 
                A2, 
                A3, 
                R>,
                public arity0fp<R> {
public:
    typedef arity3_function<A1, 
            A2, 
            A3, 
            R>::result_type result_type;
    typedef arity3_function<A1, 
            A2, 
            A3, 
            R>::first_argument_type first_argument_type;
    typedef arity3_function<A1, 
            A2, 
            A3, 
            R>::second_argument_type second_argument_type;
    typedef R (*const pf3type) (A1, A2, A3);
    explicit inline arity3fp(pf3type pfi) : 
        arity0fp<R>(reinterpret_cast<pf0type>(pfi)) {}
    inline arity3fp(const arity3fp& fi) : 
        arity0fp<R>(fi) {}
    inline R operator()(A1 a1, 
                        A2 a2, 
                        A3 a3) const {
        pf3type pf = reinterpret_cast<pf3type>(pf0);
        return pf(a1, a2, a3);
    }
};

// Template Function for arity 3 function ptr storage
template<class A1, 
                class A2, 
                class A3, 
                class R> inline arity3fp<A1, 
                A2, 
                A3, 
                R> 
            arity3_pointer(R (*const pfi)(A1, 
                                    A2, 
                                    A3)) {
                return arity3fp<A1, 
                A2, 
                A3, 
                R>(pfi);
};


// Template Class for arity 3 pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class R> class arity3pmf:
                public arity3_mf<Object, 
                A1, 
                A2, 
                A3, 
                R>,
                public arity0pmf<Object, R> {
public:
    typedef arity3_function<A1, 
            A2, 
            A3, 
            R>::result_type result_type;
    typedef arity3_function<A1, 
            A2, 
            A3, 
            R>::first_argument_type first_argument_type;
    typedef arity3_function<A1, 
            A2, 
            A3, 
            R>::second_argument_type second_argument_type;
    typedef arity3_mf<Object, 
                A1, 
                A2, 
                A3, 
                R>::object_type object_type;
    explicit inline arity3pmf(pmf3type pmfi) : 
        arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline arity3pmf(const arity3pmf& pmfi) : arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(a1, a2, a3);
    }
};

// Template Function for arity 3 pmf storage
template<class Object, 
                class A1, 
                class A2, 
                class A3, 
                class R> inline arity3pmf<Object, 
                A1, 
                A2, 
                A3, 
                R>
            arity3_member(R (Object::*const pmfi)(A1, 
                                    A2, 
                                    A3)) {
                return arity3pmf<Object, 
                A1, 
                A2, 
                A3, 
                R>(pmfi);
};


// Template Class for arity 3 const pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class R> class arity3pmf_const:
                public arity3_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                R>,
                public arity0pmf_const<const Object, R> {
public:
    typedef arity3_function<A1, 
            A2, 
            A3, 
            R>::result_type result_type;
    typedef arity3_function<A1, 
            A2, 
            A3, 
            R>::first_argument_type first_argument_type;
    typedef arity3_function<A1, 
            A2, 
            A3, 
            R>::second_argument_type second_argument_type;
    typedef arity3_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                R>::object_type object_type;
    explicit inline arity3pmf_const(pmf3type pmfi) : 
        arity0pmf_const<const Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline arity3pmf_const(const arity3pmf_const& pmfi) : arity0pmf_const<Object, R>(pmfi) {}
    inline virtual R operator()(const Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(a1, a2, a3);
    }
};

// Template Function for arity 3 const pmf storage
template<const class Object, 
                class A1, 
                class A2, 
                class A3, 
                class R> inline arity3pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                R>
            arity3_const_member(R (Object::*const pmfi)(A1, 
                                    A2, 
                                    A3) const) {
                return arity3pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                R>(pmfi);
};


// Template Class for arity 3 obj&pmf ref storage
template<class Function> class arity3opmf:
                public arity3pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::result_type>,
                public store_object<Function::object_type&> {
public:
    explicit inline arity3opmf(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), arity3pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::result_type>(f) {}
    explicit inline arity3opmf(Function::object_type& oi, pmf3type pmfi) : 
        store_object<Function::object_type&>(oi), arity3pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::result_type>(pmfi) {}
    inline arity3opmf(const arity3opmf& bndri) : 
        store_object<Function::object_type&>(bndri), arity3pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::first_argument_type a1, 
                        Function::second_argument_type a2, 
                        Function::argument_3_type a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(a1, a2, a3);
    }
};


// Template Function for arity 3 obj&pmf ref storage
template<class Function, class Object> inline arity3opmf<Function>
            arity3_member_obj(Object& oi, const Function &f) {
                return arity3opmf<Function>(Function::object_type(oi), Function::pmf3type(f.pmf0));
};


// Template Class for arity 3 const obj&pmf ref storage
template<class Function> class arity3opmf_const:
                public arity3pmf_const<const Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::result_type>,
                public store_object<const Function::object_type&> {
public:
    explicit inline arity3opmf_const(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), arity3pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::result_type>(f) {}
    explicit inline arity3opmf_const(Function::object_type& oi, pmf3type pmfi) : 
        store_object<Function::object_type&>(oi), arity3pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::result_type>(pmfi) {}
    inline arity3opmf_const(const arity3opmf_const& bndri) : 
        store_object<Function::object_type&>(bndri), arity3pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::first_argument_type a1, 
                        Function::second_argument_type a2, 
                        Function::argument_3_type a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(a1, a2, a3);
    }
};


// Template Function for arity 3 const obj&pmf ref storage
template<class Function, class Object> inline arity3opmf_const<Function>
            arity3_const_member_obj(Object& oi, const Function &f) {
                return arity3opmf_const<Function>(Function::object_type(oi), Function::pmf3type(f.pmf0));
};



// storage allocation classes for arity 4

// Template Class for arity 4 pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class R> class arity4pmf:
                public arity4_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>,
                public arity0pmf<Object, R> {
public:
    typedef arity4_function<A1, 
            A2, 
            A3, 
            A4, 
            R>::result_type result_type;
    typedef arity4_function<A1, 
            A2, 
            A3, 
            A4, 
            R>::first_argument_type first_argument_type;
    typedef arity4_function<A1, 
            A2, 
            A3, 
            A4, 
            R>::second_argument_type second_argument_type;
    typedef arity4_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>::object_type object_type;
    explicit inline arity4pmf(pmf4type pmfi) : 
        arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline arity4pmf(const arity4pmf& pmfi) : arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4);
    }
};

// Template Function for arity 4 pmf storage
template<class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class R> inline arity4pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>
            arity4_member(R (Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4)) {
                return arity4pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>(pmfi);
};


// Template Class for arity 4 const pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class R> class arity4pmf_const:
                public arity4_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>,
                public arity0pmf_const<const Object, R> {
public:
    typedef arity4_function<A1, 
            A2, 
            A3, 
            A4, 
            R>::result_type result_type;
    typedef arity4_function<A1, 
            A2, 
            A3, 
            A4, 
            R>::first_argument_type first_argument_type;
    typedef arity4_function<A1, 
            A2, 
            A3, 
            A4, 
            R>::second_argument_type second_argument_type;
    typedef arity4_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>::object_type object_type;
    explicit inline arity4pmf_const(pmf4type pmfi) : 
        arity0pmf_const<const Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline arity4pmf_const(const arity4pmf_const& pmfi) : arity0pmf_const<Object, R>(pmfi) {}
    inline virtual R operator()(const Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4);
    }
};

// Template Function for arity 4 const pmf storage
template<const class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class R> inline arity4pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>
            arity4_const_member(R (Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4) const) {
                return arity4pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>(pmfi);
};


// Template Class for arity 4 obj&pmf ref storage
template<class Function> class arity4opmf:
                public arity4pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::result_type>,
                public store_object<Function::object_type&> {
public:
    explicit inline arity4opmf(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), arity4pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::result_type>(f) {}
    explicit inline arity4opmf(Function::object_type& oi, pmf4type pmfi) : 
        store_object<Function::object_type&>(oi), arity4pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::result_type>(pmfi) {}
    inline arity4opmf(const arity4opmf& bndri) : 
        store_object<Function::object_type&>(bndri), arity4pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::first_argument_type a1, 
                        Function::second_argument_type a2, 
                        Function::argument_3_type a3, 
                        Function::argument_4_type a4) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4);
    }
};


// Template Function for arity 4 obj&pmf ref storage
template<class Function, class Object> inline arity4opmf<Function>
            arity4_member_obj(Object& oi, const Function &f) {
                return arity4opmf<Function>(Function::object_type(oi), Function::pmf4type(f.pmf0));
};


// Template Class for arity 4 const obj&pmf ref storage
template<class Function> class arity4opmf_const:
                public arity4pmf_const<const Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::result_type>,
                public store_object<const Function::object_type&> {
public:
    explicit inline arity4opmf_const(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), arity4pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::result_type>(f) {}
    explicit inline arity4opmf_const(Function::object_type& oi, pmf4type pmfi) : 
        store_object<Function::object_type&>(oi), arity4pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::result_type>(pmfi) {}
    inline arity4opmf_const(const arity4opmf_const& bndri) : 
        store_object<Function::object_type&>(bndri), arity4pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::first_argument_type a1, 
                        Function::second_argument_type a2, 
                        Function::argument_3_type a3, 
                        Function::argument_4_type a4) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4);
    }
};


// Template Function for arity 4 const obj&pmf ref storage
template<class Function, class Object> inline arity4opmf_const<Function>
            arity4_const_member_obj(Object& oi, const Function &f) {
                return arity4opmf_const<Function>(Function::object_type(oi), Function::pmf4type(f.pmf0));
};



// storage allocation classes for arity 5

// Template Class for arity 5 pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class R> class arity5pmf:
                public arity5_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>,
                public arity0pmf<Object, R> {
public:
    typedef arity5_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            R>::result_type result_type;
    typedef arity5_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            R>::first_argument_type first_argument_type;
    typedef arity5_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            R>::second_argument_type second_argument_type;
    typedef arity5_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>::object_type object_type;
    explicit inline arity5pmf(pmf5type pmfi) : 
        arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline arity5pmf(const arity5pmf& pmfi) : arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4, 
                        A5 a5) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4, a5);
    }
};

// Template Function for arity 5 pmf storage
template<class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class R> inline arity5pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>
            arity5_member(R (Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5)) {
                return arity5pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>(pmfi);
};


// Template Class for arity 5 const pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class R> class arity5pmf_const:
                public arity5_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>,
                public arity0pmf_const<const Object, R> {
public:
    typedef arity5_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            R>::result_type result_type;
    typedef arity5_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            R>::first_argument_type first_argument_type;
    typedef arity5_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            R>::second_argument_type second_argument_type;
    typedef arity5_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>::object_type object_type;
    explicit inline arity5pmf_const(pmf5type pmfi) : 
        arity0pmf_const<const Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline arity5pmf_const(const arity5pmf_const& pmfi) : arity0pmf_const<Object, R>(pmfi) {}
    inline virtual R operator()(const Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4, 
                        A5 a5) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4, a5);
    }
};

// Template Function for arity 5 const pmf storage
template<const class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class R> inline arity5pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>
            arity5_const_member(R (Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5) const) {
                return arity5pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>(pmfi);
};


// Template Class for arity 5 obj&pmf ref storage
template<class Function> class arity5opmf:
                public arity5pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::result_type>,
                public store_object<Function::object_type&> {
public:
    explicit inline arity5opmf(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), arity5pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::result_type>(f) {}
    explicit inline arity5opmf(Function::object_type& oi, pmf5type pmfi) : 
        store_object<Function::object_type&>(oi), arity5pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::result_type>(pmfi) {}
    inline arity5opmf(const arity5opmf& bndri) : 
        store_object<Function::object_type&>(bndri), arity5pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::first_argument_type a1, 
                        Function::second_argument_type a2, 
                        Function::argument_3_type a3, 
                        Function::argument_4_type a4, 
                        Function::argument_5_type a5) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4, a5);
    }
};


// Template Function for arity 5 obj&pmf ref storage
template<class Function, class Object> inline arity5opmf<Function>
            arity5_member_obj(Object& oi, const Function &f) {
                return arity5opmf<Function>(Function::object_type(oi), Function::pmf5type(f.pmf0));
};


// Template Class for arity 5 const obj&pmf ref storage
template<class Function> class arity5opmf_const:
                public arity5pmf_const<const Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::result_type>,
                public store_object<const Function::object_type&> {
public:
    explicit inline arity5opmf_const(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), arity5pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::result_type>(f) {}
    explicit inline arity5opmf_const(Function::object_type& oi, pmf5type pmfi) : 
        store_object<Function::object_type&>(oi), arity5pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::result_type>(pmfi) {}
    inline arity5opmf_const(const arity5opmf_const& bndri) : 
        store_object<Function::object_type&>(bndri), arity5pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::first_argument_type a1, 
                        Function::second_argument_type a2, 
                        Function::argument_3_type a3, 
                        Function::argument_4_type a4, 
                        Function::argument_5_type a5) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4, a5);
    }
};


// Template Function for arity 5 const obj&pmf ref storage
template<class Function, class Object> inline arity5opmf_const<Function>
            arity5_const_member_obj(Object& oi, const Function &f) {
                return arity5opmf_const<Function>(Function::object_type(oi), Function::pmf5type(f.pmf0));
};



// storage allocation classes for arity 6

// Template Class for arity 6 pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class R> class arity6pmf:
                public arity6_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>,
                public arity0pmf<Object, R> {
public:
    typedef arity6_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            R>::result_type result_type;
    typedef arity6_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            R>::first_argument_type first_argument_type;
    typedef arity6_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            R>::second_argument_type second_argument_type;
    typedef arity6_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>::object_type object_type;
    explicit inline arity6pmf(pmf6type pmfi) : 
        arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline arity6pmf(const arity6pmf& pmfi) : arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4, 
                        A5 a5, 
                        A6 a6) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4, a5, a6);
    }
};

// Template Function for arity 6 pmf storage
template<class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6, 
                class R> inline arity6pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>
            arity6_member(R (Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6)) {
                return arity6pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>(pmfi);
};


// Template Class for arity 6 const pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class R> class arity6pmf_const:
                public arity6_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>,
                public arity0pmf_const<const Object, R> {
public:
    typedef arity6_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            R>::result_type result_type;
    typedef arity6_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            R>::first_argument_type first_argument_type;
    typedef arity6_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            R>::second_argument_type second_argument_type;
    typedef arity6_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>::object_type object_type;
    explicit inline arity6pmf_const(pmf6type pmfi) : 
        arity0pmf_const<const Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline arity6pmf_const(const arity6pmf_const& pmfi) : arity0pmf_const<Object, R>(pmfi) {}
    inline virtual R operator()(const Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4, 
                        A5 a5, 
                        A6 a6) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4, a5, a6);
    }
};

// Template Function for arity 6 const pmf storage
template<const class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6, 
                class R> inline arity6pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>
            arity6_const_member(R (Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6) const) {
                return arity6pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>(pmfi);
};


// Template Class for arity 6 obj&pmf ref storage
template<class Function> class arity6opmf:
                public arity6pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::argument_6_type, 
                Function::result_type>,
                public store_object<Function::object_type&> {
public:
    explicit inline arity6opmf(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), arity6pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::argument_6_type, 
                Function::result_type>(f) {}
    explicit inline arity6opmf(Function::object_type& oi, pmf6type pmfi) : 
        store_object<Function::object_type&>(oi), arity6pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::argument_6_type, 
                Function::result_type>(pmfi) {}
    inline arity6opmf(const arity6opmf& bndri) : 
        store_object<Function::object_type&>(bndri), arity6pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::argument_6_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::first_argument_type a1, 
                        Function::second_argument_type a2, 
                        Function::argument_3_type a3, 
                        Function::argument_4_type a4, 
                        Function::argument_5_type a5, 
                        Function::argument_6_type a6) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4, a5, a6);
    }
};


// Template Function for arity 6 obj&pmf ref storage
template<class Function, class Object> inline arity6opmf<Function>
            arity6_member_obj(Object& oi, const Function &f) {
                return arity6opmf<Function>(Function::object_type(oi), Function::pmf6type(f.pmf0));
};


// Template Class for arity 6 const obj&pmf ref storage
template<class Function> class arity6opmf_const:
                public arity6pmf_const<const Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::argument_6_type, 
                Function::result_type>,
                public store_object<const Function::object_type&> {
public:
    explicit inline arity6opmf_const(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), arity6pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::argument_6_type, 
                Function::result_type>(f) {}
    explicit inline arity6opmf_const(Function::object_type& oi, pmf6type pmfi) : 
        store_object<Function::object_type&>(oi), arity6pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::argument_6_type, 
                Function::result_type>(pmfi) {}
    inline arity6opmf_const(const arity6opmf_const& bndri) : 
        store_object<Function::object_type&>(bndri), arity6pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::argument_6_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::first_argument_type a1, 
                        Function::second_argument_type a2, 
                        Function::argument_3_type a3, 
                        Function::argument_4_type a4, 
                        Function::argument_5_type a5, 
                        Function::argument_6_type a6) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4, a5, a6);
    }
};


// Template Function for arity 6 const obj&pmf ref storage
template<class Function, class Object> inline arity6opmf_const<Function>
            arity6_const_member_obj(Object& oi, const Function &f) {
                return arity6opmf_const<Function>(Function::object_type(oi), Function::pmf6type(f.pmf0));
};


#if defined(_M_ALPHA) || (_MSC_VER < 1300)
// Template Function for arity 3 pmf storage
template<class Object, 
                class A1, 
                const class A2, 
                const class A3, 
                class R> inline arity3pmf<Object, 
                A1, 
                const A2, 
                const A3, 
                R>
            arity3_member(R (Object::*const pmfi)(A1, 
                                    const A2, 
                                    const A3)) {
                return arity3pmf<Object, 
                A1, 
                const A2, 
                const A3, 
                R>(pmfi);
};
#endif

#if defined(_M_ALPHA) || (_MSC_VER < 1300)
// Template Function for arity 4 const pmf storage
template<const class Object, 
                const class A1, 
                const class A2, 
                class A3, 
                const class A4, 
                class R> inline arity4pmf_const<const Object, 
                const A1, 
                const A2, 
                A3, 
                const A4, 
                R>
            arity4_const_member(R (Object::*const pmfi)(const A1, 
                                    const A2, 
                                    A3, 
                                    const A4) const) {
                return arity4pmf_const<const Object, 
                const A1, 
                const A2, 
                A3, 
                const A4, 
                R>(pmfi);
};
#endif


// storage allocation classes for arity 0

// Template Class for arity 0 function ptr storage
template<class R> class std_arity0fp:
                public arity0_function<R> {
public:
    typedef R ( __stdcall *const pf0type) ();
    explicit inline std_arity0fp(pf0type pfi) : 
        pf0(pfi) {}
    inline std_arity0fp(const std_arity0fp& fi) : 
        pf0(fi.pf0) {}
    inline R operator()() const {
        return pf0();
    }
    pf0type pf0;
};

// Template Function for arity 0 function ptr storage
template<class R> inline std_arity0fp<R> 
            std_arity0_pointer(R ( __stdcall *const pfi)()) {
                return std_arity0fp<R>(pfi);
};


// Template Class for arity 0 pmf storage
template<class Object, class R> class std_arity0pmf:
                public std_arity0_mf<Object, R> {
public:
    typedef std_arity0_mf<Object, R>::object_type object_type;
    explicit inline std_arity0pmf(pmf0type pmfi) : 
        pmf0(pmfi) {}
    inline std_arity0pmf(const std_arity0pmf& pmfi) : pmf0(pmfi.pmf0) {}
    inline virtual R operator()(Object& o ) const {
        return (o.*pmf0)();
    }
    pmf0type pmf0;
};

// Template Function for arity 0 pmf storage
template<class Object, class R> inline std_arity0pmf<Object, R>
            std_arity0_member(R ( __stdcall Object::*const pmfi)()) {
                return std_arity0pmf<Object, R>(pmfi);
};


// Template Class for arity 0 const pmf storage
template<class Object, class R> class std_arity0pmf_const:
                public std_arity0_const_mf<const Object, R> {
public:
    typedef std_arity0_const_mf<const Object, R>::object_type object_type;
    explicit inline std_arity0pmf_const(pmf0type pmfi) : 
        pmf0(pmfi) {}
    inline std_arity0pmf_const(const std_arity0pmf_const& pmfi) : pmf0(pmfi.pmf0) {}
    inline virtual R operator()(const Object& o ) const {
        return (o.*pmf0)();
    }
    pmf0type pmf0;
};

// Template Function for arity 0 const pmf storage
template<const class Object, class R> inline std_arity0pmf_const<const Object, R>
            std_arity0_const_member(R ( __stdcall Object::*const pmfi)() const) {
                return std_arity0pmf_const<const Object, R>(pmfi);
};

template<class Object, class R> class std_arity0pmf_ptr:
    public std_arity0pmf<Object, R>, public std::unary_function<Object, R> {
public:
    explicit inline std_arity0pmf_ptr(pmf0type pmfi) : std_arity0pmf<Object, R>(pmfi) {}
    inline std_arity0pmf_ptr(const std_arity0pmf_ptr& pmfi) : std_arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o ) const {
        return (o.*pmf0)();
    }
    inline virtual R operator()(Object* o ) const {
        return (o->*pmf0)();
    }
};

// Template Function for arity 0 pmf storage
template<class Object, class R> inline std_arity0pmf_ptr<Object, R>
            std_arity0_member_ptr(R (__stdcall Object::*const pmfi)()) {
                return std_arity0pmf_ptr<Object, R>(pmfi);
};

// Template Class for arity 0 obj&pmf ref storage
template<class Function> class std_arity0opmf:
                public std_arity0pmf<Function::object_type, Function::result_type>,
                public store_object<Function::object_type&> {
public:
    explicit inline std_arity0opmf(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), std_arity0pmf<Function::object_type, Function::result_type>(f) {}
    explicit inline std_arity0opmf(Function::object_type& oi, pmf0type pmfi) : 
        store_object<Function::object_type&>(oi), std_arity0pmf<Function::object_type, Function::result_type>(pmfi) {}
    inline std_arity0opmf(const std_arity0opmf& bndri) : 
        store_object<Function::object_type&>(bndri), std_arity0pmf<Function::object_type, Function::result_type>(bndri) {}
    inline Function::result_type operator()() const {
        return (objval.*pmf0)();
    }
    pmf0type pmf0;
};


// Template Function for arity 0 obj&pmf ref storage
template<class Function, class Object> inline std_arity0opmf<Function>
            std_arity0_member_obj(Object& oi, const Function &f) {
                return std_arity0opmf<Function>(Function::object_type(oi), Function::pmf0type(f.pmf0));
};


// Template Class for arity 0 const obj&pmf ref storage
template<class Function> class std_arity0opmf_const:
                public std_arity0pmf_const<const Function::object_type, Function::result_type>,
                public store_object<const Function::object_type&> {
public:
    explicit inline std_arity0opmf_const(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), std_arity0pmf_const<Function::object_type, Function::result_type>(f) {}
    explicit inline std_arity0opmf_const(Function::object_type& oi, pmf0type pmfi) : 
        store_object<Function::object_type&>(oi), std_arity0pmf_const<Function::object_type, Function::result_type>(pmfi) {}
    inline std_arity0opmf_const(const std_arity0opmf_const& bndri) : 
        store_object<Function::object_type&>(bndri), std_arity0pmf_const<Function::object_type, Function::result_type>(bndri) {}
    inline Function::result_type operator()() const {
        return (objval.*pmf0)();
    }
    pmf0type pmf0;
};


// Template Function for arity 0 const obj&pmf ref storage
template<class Function, class Object> inline std_arity0opmf_const<Function>
            std_arity0_const_member_obj(Object& oi, const Function &f) {
                return std_arity0opmf_const<Function>(Function::object_type(oi), Function::pmf0type(f.pmf0));
};



// storage allocation classes for arity 1

// Template Class for arity 1 function ptr storage
template<class A1, 
        class R> class std_arity1fp:
                public std::unary_function<A1, 
                R>,
                public std_arity0fp<R> {
public:
    typedef std::unary_function<A1, 
            R>::result_type result_type;
    typedef R ( __stdcall *const pf1type) (A1);
    explicit inline std_arity1fp(pf1type pfi) : 
        std_arity0fp<R>(reinterpret_cast<pf0type>(pfi)) {}
    inline std_arity1fp(const std_arity1fp& fi) : 
        std_arity0fp<R>(fi) {}
    inline R operator()(A1 a1) const {
        pf1type pf = reinterpret_cast<pf1type>(pf0);
        return pf(a1);
    }
};

// Template Function for arity 1 function ptr storage
template<class A1, 
                class R> inline std_arity1fp<A1, 
                R> 
            std_arity1_pointer(R ( __stdcall *const pfi)(A1)) {
                return std_arity1fp<A1, 
                R>(pfi);
};


// Template Class for arity 1 pmf storage
template<class Object, 
        class A1, 
        class R> class std_arity1pmf:
                public std_arity1_mf<Object, 
                A1, 
                R>,
                public std_arity0pmf<Object, R> {
public:
    typedef std::unary_function<A1, 
            R>::result_type result_type;
    typedef std_arity1_mf<Object, 
                A1, 
                R>::object_type object_type;
    explicit inline std_arity1pmf(pmf1type pmfi) : 
        std_arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity1pmf(const std_arity1pmf& pmfi) : std_arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1) const {
        pmf1type pmf = reinterpret_cast<pmf1type>(pmf0);
        return (o.*pmf)(a1);
    }
};

// Template Function for arity 1 pmf storage
template<class Object, 
                class A1, 
                class R> inline std_arity1pmf<Object, 
                A1, 
                R>
            std_arity1_member(R ( __stdcall Object::*const pmfi)(A1)) {
                return std_arity1pmf<Object, 
                A1, 
                R>(pmfi);
};


// Template Class for arity 1 const pmf storage
template<class Object, 
        class A1, 
        class R> class std_arity1pmf_const:
                public std_arity1_const_mf<const Object, 
                A1, 
                R>,
                public std_arity0pmf_const<const Object, R> {
public:
    typedef std::unary_function<A1, 
            R>::result_type result_type;
    typedef std_arity1_const_mf<const Object, 
                A1, 
                R>::object_type object_type;
    explicit inline std_arity1pmf_const(pmf1type pmfi) : 
        std_arity0pmf_const<const Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity1pmf_const(const std_arity1pmf_const& pmfi) : std_arity0pmf_const<Object, R>(pmfi) {}
    inline virtual R operator()(const Object& o, A1 a1) const {
        pmf1type pmf = reinterpret_cast<pmf1type>(pmf0);
        return (o.*pmf)(a1);
    }
};

// Template Function for arity 1 const pmf storage
template<const class Object, 
                class A1, 
                class R> inline std_arity1pmf_const<const Object, 
                A1, 
                R>
            std_arity1_const_member(R ( __stdcall Object::*const pmfi)(A1) const) {
                return std_arity1pmf_const<const Object, 
                A1, 
                R>(pmfi);
};


// Template Class for arity 1 obj&pmf ref storage
template<class Function> class std_arity1opmf:
                public std_arity1pmf<Function::object_type, 
                Function::argument_type, 
                Function::result_type>,
                public store_object<Function::object_type&> {
public:
    explicit inline std_arity1opmf(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), std_arity1pmf<Function::object_type, 
                Function::argument_type, 
                Function::result_type>(f) {}
    explicit inline std_arity1opmf(Function::object_type& oi, pmf1type pmfi) : 
        store_object<Function::object_type&>(oi), std_arity1pmf<Function::object_type, 
                Function::argument_type, 
                Function::result_type>(pmfi) {}
    inline std_arity1opmf(const std_arity1opmf& bndri) : 
        store_object<Function::object_type&>(bndri), std_arity1pmf<Function::object_type, 
                Function::argument_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::argument_type a1) const {
        pmf1type pmf = reinterpret_cast<pmf1type>(pmf0);
        return (objval.*pmf)(a1);
    }
};


// Template Function for arity 1 obj&pmf ref storage
template<class Function, class Object> inline std_arity1opmf<Function>
            std_arity1_member_obj(Object& oi, const Function &f) {
                return std_arity1opmf<Function>(Function::object_type(oi), Function::pmf1type(f.pmf0));
};


// Template Class for arity 1 const obj&pmf ref storage
template<class Function> class std_arity1opmf_const:
                public std_arity1pmf_const<const Function::object_type, 
                Function::argument_type, 
                Function::result_type>,
                public store_object<const Function::object_type&> {
public:
    explicit inline std_arity1opmf_const(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), std_arity1pmf_const<Function::object_type, 
                Function::argument_type, 
                Function::result_type>(f) {}
    explicit inline std_arity1opmf_const(Function::object_type& oi, pmf1type pmfi) : 
        store_object<Function::object_type&>(oi), std_arity1pmf_const<Function::object_type, 
                Function::argument_type, 
                Function::result_type>(pmfi) {}
    inline std_arity1opmf_const(const std_arity1opmf_const& bndri) : 
        store_object<Function::object_type&>(bndri), std_arity1pmf_const<Function::object_type, 
                Function::argument_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::argument_type a1) const {
        pmf1type pmf = reinterpret_cast<pmf1type>(pmf0);
        return (objval.*pmf)(a1);
    }
};


// Template Function for arity 1 const obj&pmf ref storage
template<class Function, class Object> inline std_arity1opmf_const<Function>
            std_arity1_const_member_obj(Object& oi, const Function &f) {
                return std_arity1opmf_const<Function>(Function::object_type(oi), Function::pmf1type(f.pmf0));
};



// storage allocation classes for arity 2

// Template Class for arity 2 function ptr storage
template<class A1, 
        class A2, 
        class R> class std_arity2fp:
                public std::binary_function<A1, 
                A2, 
                R>,
                public std_arity0fp<R> {
public:
    typedef std::binary_function<A1, 
            A2, 
            R>::result_type result_type;
    typedef std::binary_function<A1, 
            A2, 
            R>::first_argument_type first_argument_type;
    typedef R ( __stdcall *const pf2type) (A1, A2);
    explicit inline std_arity2fp(pf2type pfi) : 
        std_arity0fp<R>(reinterpret_cast<pf0type>(pfi)) {}
    inline std_arity2fp(const std_arity2fp& fi) : 
        std_arity0fp<R>(fi) {}
    inline R operator()(A1 a1, 
                        A2 a2) const {
        pf2type pf = reinterpret_cast<pf2type>(pf0);
        return pf(a1, a2);
    }
};

// Template Function for arity 2 function ptr storage
template<class A1, 
                class A2, 
                class R> inline std_arity2fp<A1, 
                A2, 
                R> 
            std_arity2_pointer(R ( __stdcall *const pfi)(A1, 
                                    A2)) {
                return std_arity2fp<A1, 
                A2, 
                R>(pfi);
};


// Template Class for arity 2 pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class R> class std_arity2pmf:
                public std_arity2_mf<Object, 
                A1, 
                A2, 
                R>,
                public std_arity0pmf<Object, R> {
public:
    typedef std::binary_function<A1, 
            A2, 
            R>::result_type result_type;
    typedef std::binary_function<A1, 
            A2, 
            R>::first_argument_type first_argument_type;
    typedef std_arity2_mf<Object, 
                A1, 
                A2, 
                R>::object_type object_type;
    explicit inline std_arity2pmf(pmf2type pmfi) : 
        std_arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity2pmf(const std_arity2pmf& pmfi) : std_arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1, 
                        A2 a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (o.*pmf)(a1, a2);
    }
};

// Template Function for arity 2 pmf storage
template<class Object, 
                class A1, 
                class A2, 
                class R> inline std_arity2pmf<Object, 
                A1, 
                A2, 
                R>
            std_arity2_member(R ( __stdcall Object::*const pmfi)(A1, 
                                    A2)) {
                return std_arity2pmf<Object, 
                A1, 
                A2, 
                R>(pmfi);
};


// Template Class for arity 2 const pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class R> class std_arity2pmf_const:
                public std_arity2_const_mf<const Object, 
                A1, 
                A2, 
                R>,
                public std_arity0pmf_const<const Object, R> {
public:
    typedef std::binary_function<A1, 
            A2, 
            R>::result_type result_type;
    typedef std::binary_function<A1, 
            A2, 
            R>::first_argument_type first_argument_type;
    typedef std_arity2_const_mf<const Object, 
                A1, 
                A2, 
                R>::object_type object_type;
    explicit inline std_arity2pmf_const(pmf2type pmfi) : 
        std_arity0pmf_const<const Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity2pmf_const(const std_arity2pmf_const& pmfi) : std_arity0pmf_const<Object, R>(pmfi) {}
    inline virtual R operator()(const Object& o, A1 a1, 
                        A2 a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (o.*pmf)(a1, a2);
    }
};

// Template Function for arity 2 const pmf storage
template<const class Object, 
                class A1, 
                class A2, 
                class R> inline std_arity2pmf_const<const Object, 
                A1, 
                A2, 
                R>
            std_arity2_const_member(R ( __stdcall Object::*const pmfi)(A1, 
                                    A2) const) {
                return std_arity2pmf_const<const Object, 
                A1, 
                A2, 
                R>(pmfi);
};


// Template Class for arity 2 obj&pmf ref storage
template<class Function> class std_arity2opmf:
                public std_arity2pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::result_type>,
                public store_object<Function::object_type&> {
public:
    explicit inline std_arity2opmf(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), std_arity2pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::result_type>(f) {}
    explicit inline std_arity2opmf(Function::object_type& oi, pmf2type pmfi) : 
        store_object<Function::object_type&>(oi), std_arity2pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::result_type>(pmfi) {}
    inline std_arity2opmf(const std_arity2opmf& bndri) : 
        store_object<Function::object_type&>(bndri), std_arity2pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::first_argument_type a1, 
                        Function::second_argument_type a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (objval.*pmf)(a1, a2);
    }
};


// Template Function for arity 2 obj&pmf ref storage
template<class Function, class Object> inline std_arity2opmf<Function>
            std_arity2_member_obj(Object& oi, const Function &f) {
                return std_arity2opmf<Function>(Function::object_type(oi), Function::pmf2type(f.pmf0));
};


// Template Class for arity 2 const obj&pmf ref storage
template<class Function> class std_arity2opmf_const:
                public std_arity2pmf_const<const Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::result_type>,
                public store_object<const Function::object_type&> {
public:
    explicit inline std_arity2opmf_const(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), std_arity2pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::result_type>(f) {}
    explicit inline std_arity2opmf_const(Function::object_type& oi, pmf2type pmfi) : 
        store_object<Function::object_type&>(oi), std_arity2pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::result_type>(pmfi) {}
    inline std_arity2opmf_const(const std_arity2opmf_const& bndri) : 
        store_object<Function::object_type&>(bndri), std_arity2pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::first_argument_type a1, 
                        Function::second_argument_type a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (objval.*pmf)(a1, a2);
    }
};


// Template Function for arity 2 const obj&pmf ref storage
template<class Function, class Object> inline std_arity2opmf_const<Function>
            std_arity2_const_member_obj(Object& oi, const Function &f) {
                return std_arity2opmf_const<Function>(Function::object_type(oi), Function::pmf2type(f.pmf0));
};



// storage allocation classes for arity 3

// Template Class for arity 3 function ptr storage
template<class A1, 
        class A2, 
        class A3, 
        class R> class std_arity3fp:
                public arity3_function<A1, 
                A2, 
                A3, 
                R>,
                public std_arity0fp<R> {
public:
    typedef arity3_function<A1, 
            A2, 
            A3, 
            R>::result_type result_type;
    typedef arity3_function<A1, 
            A2, 
            A3, 
            R>::first_argument_type first_argument_type;
    typedef arity3_function<A1, 
            A2, 
            A3, 
            R>::second_argument_type second_argument_type;
    typedef R ( __stdcall *const pf3type) (A1, A2, A3);
    explicit inline std_arity3fp(pf3type pfi) : 
        std_arity0fp<R>(reinterpret_cast<pf0type>(pfi)) {}
    inline std_arity3fp(const std_arity3fp& fi) : 
        std_arity0fp<R>(fi) {}
    inline R operator()(A1 a1, 
                        A2 a2, 
                        A3 a3) const {
        pf3type pf = reinterpret_cast<pf3type>(pf0);
        return pf(a1, a2, a3);
    }
};

// Template Function for arity 3 function ptr storage
template<class A1, 
                class A2, 
                class A3, 
                class R> inline std_arity3fp<A1, 
                A2, 
                A3, 
                R> 
            std_arity3_pointer(R ( __stdcall *const pfi)(A1, 
                                    A2, 
                                    A3)) {
                return std_arity3fp<A1, 
                A2, 
                A3, 
                R>(pfi);
};


// Template Class for arity 3 pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class R> class std_arity3pmf:
                public std_arity3_mf<Object, 
                A1, 
                A2, 
                A3, 
                R>,
                public std_arity0pmf<Object, R> {
public:
    typedef arity3_function<A1, 
            A2, 
            A3, 
            R>::result_type result_type;
    typedef arity3_function<A1, 
            A2, 
            A3, 
            R>::first_argument_type first_argument_type;
    typedef arity3_function<A1, 
            A2, 
            A3, 
            R>::second_argument_type second_argument_type;
    typedef std_arity3_mf<Object, 
                A1, 
                A2, 
                A3, 
                R>::object_type object_type;
    explicit inline std_arity3pmf(pmf3type pmfi) : 
        std_arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity3pmf(const std_arity3pmf& pmfi) : std_arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(a1, a2, a3);
    }
};

// Template Function for arity 3 pmf storage
template<class Object, 
                class A1, 
                class A2, 
                class A3, 
                class R> inline std_arity3pmf<Object, 
                A1, 
                A2, 
                A3, 
                R>
            std_arity3_member(R ( __stdcall Object::*const pmfi)(A1, 
                                    A2, 
                                    A3)) {
                return std_arity3pmf<Object, 
                A1, 
                A2, 
                A3, 
                R>(pmfi);
};


// Template Class for arity 3 const pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class R> class std_arity3pmf_const:
                public std_arity3_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                R>,
                public std_arity0pmf_const<const Object, R> {
public:
    typedef arity3_function<A1, 
            A2, 
            A3, 
            R>::result_type result_type;
    typedef arity3_function<A1, 
            A2, 
            A3, 
            R>::first_argument_type first_argument_type;
    typedef arity3_function<A1, 
            A2, 
            A3, 
            R>::second_argument_type second_argument_type;
    typedef std_arity3_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                R>::object_type object_type;
    explicit inline std_arity3pmf_const(pmf3type pmfi) : 
        std_arity0pmf_const<const Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity3pmf_const(const std_arity3pmf_const& pmfi) : std_arity0pmf_const<Object, R>(pmfi) {}
    inline virtual R operator()(const Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(a1, a2, a3);
    }
};

// Template Function for arity 3 const pmf storage
template<const class Object, 
                class A1, 
                class A2, 
                class A3, 
                class R> inline std_arity3pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                R>
            std_arity3_const_member(R ( __stdcall Object::*const pmfi)(A1, 
                                    A2, 
                                    A3) const) {
                return std_arity3pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                R>(pmfi);
};


// Template Class for arity 3 obj&pmf ref storage
template<class Function> class std_arity3opmf:
                public std_arity3pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::result_type>,
                public store_object<Function::object_type&> {
public:
    explicit inline std_arity3opmf(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), std_arity3pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::result_type>(f) {}
    explicit inline std_arity3opmf(Function::object_type& oi, pmf3type pmfi) : 
        store_object<Function::object_type&>(oi), std_arity3pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::result_type>(pmfi) {}
    inline std_arity3opmf(const std_arity3opmf& bndri) : 
        store_object<Function::object_type&>(bndri), std_arity3pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::first_argument_type a1, 
                        Function::second_argument_type a2, 
                        Function::argument_3_type a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(a1, a2, a3);
    }
};


// Template Function for arity 3 obj&pmf ref storage
template<class Function, class Object> inline std_arity3opmf<Function>
            std_arity3_member_obj(Object& oi, const Function &f) {
                return std_arity3opmf<Function>(Function::object_type(oi), Function::pmf3type(f.pmf0));
};


// Template Class for arity 3 const obj&pmf ref storage
template<class Function> class std_arity3opmf_const:
                public std_arity3pmf_const<const Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::result_type>,
                public store_object<const Function::object_type&> {
public:
    explicit inline std_arity3opmf_const(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), std_arity3pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::result_type>(f) {}
    explicit inline std_arity3opmf_const(Function::object_type& oi, pmf3type pmfi) : 
        store_object<Function::object_type&>(oi), std_arity3pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::result_type>(pmfi) {}
    inline std_arity3opmf_const(const std_arity3opmf_const& bndri) : 
        store_object<Function::object_type&>(bndri), std_arity3pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::first_argument_type a1, 
                        Function::second_argument_type a2, 
                        Function::argument_3_type a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(a1, a2, a3);
    }
};


// Template Function for arity 3 const obj&pmf ref storage
template<class Function, class Object> inline std_arity3opmf_const<Function>
            std_arity3_const_member_obj(Object& oi, const Function &f) {
                return std_arity3opmf_const<Function>(Function::object_type(oi), Function::pmf3type(f.pmf0));
};



// storage allocation classes for arity 4

// Template Class for arity 4 pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class R> class std_arity4pmf:
                public std_arity4_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>,
                public std_arity0pmf<Object, R> {
public:
    typedef arity4_function<A1, 
            A2, 
            A3, 
            A4, 
            R>::result_type result_type;
    typedef arity4_function<A1, 
            A2, 
            A3, 
            A4, 
            R>::first_argument_type first_argument_type;
    typedef arity4_function<A1, 
            A2, 
            A3, 
            A4, 
            R>::second_argument_type second_argument_type;
    typedef std_arity4_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>::object_type object_type;
    explicit inline std_arity4pmf(pmf4type pmfi) : 
        std_arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity4pmf(const std_arity4pmf& pmfi) : std_arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4);
    }
};

// Template Function for arity 4 pmf storage
template<class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class R> inline std_arity4pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>
            std_arity4_member(R ( __stdcall Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4)) {
                return std_arity4pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>(pmfi);
};


// Template Class for arity 4 const pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class R> class std_arity4pmf_const:
                public std_arity4_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>,
                public std_arity0pmf_const<const Object, R> {
public:
    typedef arity4_function<A1, 
            A2, 
            A3, 
            A4, 
            R>::result_type result_type;
    typedef arity4_function<A1, 
            A2, 
            A3, 
            A4, 
            R>::first_argument_type first_argument_type;
    typedef arity4_function<A1, 
            A2, 
            A3, 
            A4, 
            R>::second_argument_type second_argument_type;
    typedef std_arity4_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>::object_type object_type;
    explicit inline std_arity4pmf_const(pmf4type pmfi) : 
        std_arity0pmf_const<const Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity4pmf_const(const std_arity4pmf_const& pmfi) : std_arity0pmf_const<Object, R>(pmfi) {}
    inline virtual R operator()(const Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4);
    }
};

// Template Function for arity 4 const pmf storage
template<const class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class R> inline std_arity4pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>
            std_arity4_const_member(R ( __stdcall Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4) const) {
                return std_arity4pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                R>(pmfi);
};


// Template Class for arity 4 obj&pmf ref storage
template<class Function> class std_arity4opmf:
                public std_arity4pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::result_type>,
                public store_object<Function::object_type&> {
public:
    explicit inline std_arity4opmf(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), std_arity4pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::result_type>(f) {}
    explicit inline std_arity4opmf(Function::object_type& oi, pmf4type pmfi) : 
        store_object<Function::object_type&>(oi), std_arity4pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::result_type>(pmfi) {}
    inline std_arity4opmf(const std_arity4opmf& bndri) : 
        store_object<Function::object_type&>(bndri), std_arity4pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::first_argument_type a1, 
                        Function::second_argument_type a2, 
                        Function::argument_3_type a3, 
                        Function::argument_4_type a4) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4);
    }
};


// Template Function for arity 4 obj&pmf ref storage
template<class Function, class Object> inline std_arity4opmf<Function>
            std_arity4_member_obj(Object& oi, const Function &f) {
                return std_arity4opmf<Function>(Function::object_type(oi), Function::pmf4type(f.pmf0));
};


// Template Class for arity 4 const obj&pmf ref storage
template<class Function> class std_arity4opmf_const:
                public std_arity4pmf_const<const Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::result_type>,
                public store_object<const Function::object_type&> {
public:
    explicit inline std_arity4opmf_const(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), std_arity4pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::result_type>(f) {}
    explicit inline std_arity4opmf_const(Function::object_type& oi, pmf4type pmfi) : 
        store_object<Function::object_type&>(oi), std_arity4pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::result_type>(pmfi) {}
    inline std_arity4opmf_const(const std_arity4opmf_const& bndri) : 
        store_object<Function::object_type&>(bndri), std_arity4pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::first_argument_type a1, 
                        Function::second_argument_type a2, 
                        Function::argument_3_type a3, 
                        Function::argument_4_type a4) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4);
    }
};


// Template Function for arity 4 const obj&pmf ref storage
template<class Function, class Object> inline std_arity4opmf_const<Function>
            std_arity4_const_member_obj(Object& oi, const Function &f) {
                return std_arity4opmf_const<Function>(Function::object_type(oi), Function::pmf4type(f.pmf0));
};



// storage allocation classes for arity 5

// Template Class for arity 5 pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class R> class std_arity5pmf:
                public std_arity5_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>,
                public std_arity0pmf<Object, R> {
public:
    typedef arity5_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            R>::result_type result_type;
    typedef arity5_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            R>::first_argument_type first_argument_type;
    typedef arity5_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            R>::second_argument_type second_argument_type;
    typedef std_arity5_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>::object_type object_type;
    explicit inline std_arity5pmf(pmf5type pmfi) : 
        std_arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity5pmf(const std_arity5pmf& pmfi) : std_arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4, 
                        A5 a5) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4, a5);
    }
};

// Template Function for arity 5 pmf storage
template<class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class R> inline std_arity5pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>
            std_arity5_member(R ( __stdcall Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5)) {
                return std_arity5pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>(pmfi);
};


// Template Class for arity 5 const pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class R> class std_arity5pmf_const:
                public std_arity5_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>,
                public std_arity0pmf_const<const Object, R> {
public:
    typedef arity5_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            R>::result_type result_type;
    typedef arity5_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            R>::first_argument_type first_argument_type;
    typedef arity5_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            R>::second_argument_type second_argument_type;
    typedef std_arity5_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>::object_type object_type;
    explicit inline std_arity5pmf_const(pmf5type pmfi) : 
        std_arity0pmf_const<const Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity5pmf_const(const std_arity5pmf_const& pmfi) : std_arity0pmf_const<Object, R>(pmfi) {}
    inline virtual R operator()(const Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4, 
                        A5 a5) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4, a5);
    }
};

// Template Function for arity 5 const pmf storage
template<const class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class R> inline std_arity5pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>
            std_arity5_const_member(R ( __stdcall Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5) const) {
                return std_arity5pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                R>(pmfi);
};


// Template Class for arity 5 obj&pmf ref storage
template<class Function> class std_arity5opmf:
                public std_arity5pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::result_type>,
                public store_object<Function::object_type&> {
public:
    explicit inline std_arity5opmf(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), std_arity5pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::result_type>(f) {}
    explicit inline std_arity5opmf(Function::object_type& oi, pmf5type pmfi) : 
        store_object<Function::object_type&>(oi), std_arity5pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::result_type>(pmfi) {}
    inline std_arity5opmf(const std_arity5opmf& bndri) : 
        store_object<Function::object_type&>(bndri), std_arity5pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::first_argument_type a1, 
                        Function::second_argument_type a2, 
                        Function::argument_3_type a3, 
                        Function::argument_4_type a4, 
                        Function::argument_5_type a5) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4, a5);
    }
};


// Template Function for arity 5 obj&pmf ref storage
template<class Function, class Object> inline std_arity5opmf<Function>
            std_arity5_member_obj(Object& oi, const Function &f) {
                return std_arity5opmf<Function>(Function::object_type(oi), Function::pmf5type(f.pmf0));
};


// Template Class for arity 5 const obj&pmf ref storage
template<class Function> class std_arity5opmf_const:
                public std_arity5pmf_const<const Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::result_type>,
                public store_object<const Function::object_type&> {
public:
    explicit inline std_arity5opmf_const(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), std_arity5pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::result_type>(f) {}
    explicit inline std_arity5opmf_const(Function::object_type& oi, pmf5type pmfi) : 
        store_object<Function::object_type&>(oi), std_arity5pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::result_type>(pmfi) {}
    inline std_arity5opmf_const(const std_arity5opmf_const& bndri) : 
        store_object<Function::object_type&>(bndri), std_arity5pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::first_argument_type a1, 
                        Function::second_argument_type a2, 
                        Function::argument_3_type a3, 
                        Function::argument_4_type a4, 
                        Function::argument_5_type a5) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4, a5);
    }
};


// Template Function for arity 5 const obj&pmf ref storage
template<class Function, class Object> inline std_arity5opmf_const<Function>
            std_arity5_const_member_obj(Object& oi, const Function &f) {
                return std_arity5opmf_const<Function>(Function::object_type(oi), Function::pmf5type(f.pmf0));
};



// storage allocation classes for arity 6

// Template Class for arity 6 pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class R> class std_arity6pmf:
                public std_arity6_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>,
                public std_arity0pmf<Object, R> {
public:
    typedef arity6_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            R>::result_type result_type;
    typedef arity6_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            R>::first_argument_type first_argument_type;
    typedef arity6_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            R>::second_argument_type second_argument_type;
    typedef std_arity6_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>::object_type object_type;
    explicit inline std_arity6pmf(pmf6type pmfi) : 
        std_arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity6pmf(const std_arity6pmf& pmfi) : std_arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4, 
                        A5 a5, 
                        A6 a6) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4, a5, a6);
    }
};

// Template Function for arity 6 pmf storage
template<class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6, 
                class R> inline std_arity6pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>
            std_arity6_member(R ( __stdcall Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6)) {
                return std_arity6pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>(pmfi);
};


// Template Class for arity 6 const pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class R> class std_arity6pmf_const:
                public std_arity6_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>,
                public std_arity0pmf_const<const Object, R> {
public:
    typedef arity6_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            R>::result_type result_type;
    typedef arity6_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            R>::first_argument_type first_argument_type;
    typedef arity6_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            R>::second_argument_type second_argument_type;
    typedef std_arity6_const_mf<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>::object_type object_type;
    explicit inline std_arity6pmf_const(pmf6type pmfi) : 
        std_arity0pmf_const<const Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity6pmf_const(const std_arity6pmf_const& pmfi) : std_arity0pmf_const<Object, R>(pmfi) {}
    inline virtual R operator()(const Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4, 
                        A5 a5, 
                        A6 a6) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4, a5, a6);
    }
};

// Template Function for arity 6 const pmf storage
template<const class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6, 
                class R> inline std_arity6pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>
            std_arity6_const_member(R ( __stdcall Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6) const) {
                return std_arity6pmf_const<const Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                R>(pmfi);
};


// Template Class for arity 6 obj&pmf ref storage
template<class Function> class std_arity6opmf:
                public std_arity6pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::argument_6_type, 
                Function::result_type>,
                public store_object<Function::object_type&> {
public:
    explicit inline std_arity6opmf(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), std_arity6pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::argument_6_type, 
                Function::result_type>(f) {}
    explicit inline std_arity6opmf(Function::object_type& oi, pmf6type pmfi) : 
        store_object<Function::object_type&>(oi), std_arity6pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::argument_6_type, 
                Function::result_type>(pmfi) {}
    inline std_arity6opmf(const std_arity6opmf& bndri) : 
        store_object<Function::object_type&>(bndri), std_arity6pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::argument_6_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::first_argument_type a1, 
                        Function::second_argument_type a2, 
                        Function::argument_3_type a3, 
                        Function::argument_4_type a4, 
                        Function::argument_5_type a5, 
                        Function::argument_6_type a6) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4, a5, a6);
    }
};


// Template Function for arity 6 obj&pmf ref storage
template<class Function, class Object> inline std_arity6opmf<Function>
            std_arity6_member_obj(Object& oi, const Function &f) {
                return std_arity6opmf<Function>(Function::object_type(oi), Function::pmf6type(f.pmf0));
};


// Template Class for arity 6 const obj&pmf ref storage
template<class Function> class std_arity6opmf_const:
                public std_arity6pmf_const<const Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::argument_6_type, 
                Function::result_type>,
                public store_object<const Function::object_type&> {
public:
    explicit inline std_arity6opmf_const(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), std_arity6pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::argument_6_type, 
                Function::result_type>(f) {}
    explicit inline std_arity6opmf_const(Function::object_type& oi, pmf6type pmfi) : 
        store_object<Function::object_type&>(oi), std_arity6pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::argument_6_type, 
                Function::result_type>(pmfi) {}
    inline std_arity6opmf_const(const std_arity6opmf_const& bndri) : 
        store_object<Function::object_type&>(bndri), std_arity6pmf_const<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::argument_6_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::first_argument_type a1, 
                        Function::second_argument_type a2, 
                        Function::argument_3_type a3, 
                        Function::argument_4_type a4, 
                        Function::argument_5_type a5, 
                        Function::argument_6_type a6) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4, a5, a6);
    }
};


// Template Function for arity 6 const obj&pmf ref storage
template<class Function, class Object> inline std_arity6opmf_const<Function>
            std_arity6_const_member_obj(Object& oi, const Function &f) {
                return std_arity6opmf_const<Function>(Function::object_type(oi), Function::pmf6type(f.pmf0));
};


// Template Class for arity 15 pmf storage
template<class Object, 
        class A1, 
        class A2, 
        class A3, 
        class A4, 
        class A5, 
        class A6, 
        class A7, 
        class A8, 
        class A9, 
        class A10, 
        class A11, 
        class A12, 
        class A13, 
        class A14, 
        class A15, 
        class R> class std_arity15pmf:
                public std_arity15_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                A7, 
                A8, 
                A9, 
                A10, 
                A11, 
                A12, 
                A13, 
                A14, 
                A15, 
                R>,
                public std_arity0pmf<Object, R> {
public:
    typedef arity15_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            A7, 
            A8, 
            A9, 
            A10, 
            A11, 
            A12, 
            A13, 
            A14, 
            A15, 
            R>::result_type result_type;
    typedef arity15_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            A7, 
            A8, 
            A9, 
            A10, 
            A11, 
            A12, 
            A13, 
            A14, 
            A15, 
            R>::first_argument_type first_argument_type;
    typedef arity15_function<A1, 
            A2, 
            A3, 
            A4, 
            A5, 
            A6, 
            A7, 
            A8, 
            A9, 
            A10, 
            A11, 
            A12, 
            A13, 
            A14, 
            A15, 
            R>::second_argument_type second_argument_type;
    typedef std_arity15_mf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                A7, 
                A8, 
                A9, 
                A10, 
                A11, 
                A12, 
                A13, 
                A14, 
                A15, 
                R>::object_type object_type;
    explicit inline std_arity15pmf(pmf15type pmfi) : 
        std_arity0pmf<Object, R>(reinterpret_cast<pmf0type>(pmfi)) {}
    inline std_arity15pmf(const std_arity15pmf& pmfi) : std_arity0pmf<Object, R>(pmfi) {}
    inline virtual R operator()(Object& o, A1 a1, 
                        A2 a2, 
                        A3 a3, 
                        A4 a4, 
                        A5 a5, 
                        A6 a6, 
                        A7 a7, 
                        A8 a8, 
                        A9 a9, 
                        A10 a10, 
                        A11 a11, 
                        A12 a12, 
                        A13 a13, 
                        A14 a14, 
                        A15 a15) const {
        pmf15type pmf = reinterpret_cast<pmf15type>(pmf0);
        return (o.*pmf)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
    }
};

// Template Function for arity 15 pmf storage
template<class Object, 
                class A1, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6, 
                class A7, 
                class A8, 
                class A9, 
                class A10, 
                class A11, 
                class A12, 
                class A13, 
                class A14, 
                class A15, 
                class R> inline std_arity15pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                A7, 
                A8, 
                A9, 
                A10, 
                A11, 
                A12, 
                A13, 
                A14, 
                A15, 
                R>
            std_arity15_member(R ( __stdcall Object::*const pmfi)(A1, 
                                    A2, 
                                    A3, 
                                    A4, 
                                    A5, 
                                    A6, 
                                    A7, 
                                    A8, 
                                    A9, 
                                    A10, 
                                    A11, 
                                    A12, 
                                    A13, 
                                    A14, 
                                    A15)) {
                return std_arity15pmf<Object, 
                A1, 
                A2, 
                A3, 
                A4, 
                A5, 
                A6, 
                A7, 
                A8, 
                A9, 
                A10, 
                A11, 
                A12, 
                A13, 
                A14, 
                A15, 
                R>(pmfi);
};


// Template Class for arity 15 obj&pmf ref storage
template<class Function> class std_arity15opmf:
                public std_arity15pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::argument_6_type, 
                Function::argument_7_type, 
                Function::argument_8_type, 
                Function::argument_9_type, 
                Function::argument_10_type, 
                Function::argument_11_type, 
                Function::argument_12_type, 
                Function::argument_13_type, 
                Function::argument_14_type, 
                Function::argument_15_type, 
                Function::result_type>,
                public store_object<Function::object_type&> {
public:
    explicit inline std_arity15opmf(Function::object_type& oi, const Function &f) : 
        store_object<Function::object_type&>(oi), std_arity15pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::argument_6_type, 
                Function::argument_7_type, 
                Function::argument_8_type, 
                Function::argument_9_type, 
                Function::argument_10_type, 
                Function::argument_11_type, 
                Function::argument_12_type, 
                Function::argument_13_type, 
                Function::argument_14_type, 
                Function::argument_15_type, 
                Function::result_type>(f) {}
    explicit inline std_arity15opmf(Function::object_type& oi, pmf15type pmfi) : 
        store_object<Function::object_type&>(oi), std_arity15pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::argument_6_type, 
                Function::argument_7_type, 
                Function::argument_8_type, 
                Function::argument_9_type, 
                Function::argument_10_type, 
                Function::argument_11_type, 
                Function::argument_12_type, 
                Function::argument_13_type, 
                Function::argument_14_type, 
                Function::argument_15_type, 
                Function::result_type>(pmfi) {}
    inline std_arity15opmf(const std_arity15opmf& bndri) : 
        store_object<Function::object_type&>(bndri), std_arity15pmf<Function::object_type, 
                Function::first_argument_type, 
                Function::second_argument_type, 
                Function::argument_3_type, 
                Function::argument_4_type, 
                Function::argument_5_type, 
                Function::argument_6_type, 
                Function::argument_7_type, 
                Function::argument_8_type, 
                Function::argument_9_type, 
                Function::argument_10_type, 
                Function::argument_11_type, 
                Function::argument_12_type, 
                Function::argument_13_type, 
                Function::argument_14_type, 
                Function::argument_15_type, 
                Function::result_type>(bndri) {}
    inline Function::result_type operator()(Function::first_argument_type a1, 
                        Function::second_argument_type a2, 
                        Function::argument_3_type a3, 
                        Function::argument_4_type a4, 
                        Function::argument_5_type a5, 
                        Function::argument_6_type a6, 
                        Function::argument_7_type a7, 
                        Function::argument_8_type a8, 
                        Function::argument_9_type a9, 
                        Function::argument_10_type a10, 
                        Function::argument_11_type a11, 
                        Function::argument_12_type a12, 
                        Function::argument_13_type a13, 
                        Function::argument_14_type a14, 
                        Function::argument_15_type a15) const {
        pmf15type pmf = reinterpret_cast<pmf15type>(pmf0);
        return (objval.*pmf)(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
    }
};


// Template Function for arity 15 obj&pmf ref storage
template<class Function, class Object> inline std_arity15opmf<Function>
            std_arity15_member_obj(Object& oi, const Function &f) {
                return std_arity15opmf<Function>(Function::object_type(oi), Function::pmf15type(f.pmf0));
};



///////////////////////////////////////////
// Binders
///////////////////////////////////////////

//
// binders for arity 2
//


// Template Classes for binding arity 2 to arity 1


// Template Classes for binding function ptrs of arity 2 to arity 1

template<class Function> class bndr_2 : 
                public arity1fp<Function::first_argument_type, Function::result_type> {
public:
    typedef Function::result_type (*const pf2type) (Function::first_argument_type, Function::second_argument_type);
    explicit inline bndr_2(const Function &f, Function::second_argument_type a2) : 
        arity1fp<Function::first_argument_type, Function::result_type>(reinterpret_cast<pf1type>(f.pf0)), arg2val(a2) {}
    inline bndr_2(const bndr_2& bndri) : 
        arity1fp<Function::first_argument_type, Function::result_type>(reinterpret_cast<pf1type>(bndri.pf0)), arg2val(bndri.arg2val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pf2type pf = reinterpret_cast<pf2type>(pf0);
        return pf(a1, arg2val);
    }
public:
    Function::second_argument_type arg2val;
};

template<class Function> class bndr_1 : 
                public arity1fp<Function::second_argument_type, Function::result_type> {
public:
    typedef Function::result_type (*const pf2type) (Function::first_argument_type, Function::second_argument_type);
    explicit inline bndr_1(const Function &f, Function::first_argument_type a1) : 
        arity1fp<Function::second_argument_type, Function::result_type>(reinterpret_cast<pf1type>(f.pf0)), arg1val(a1) {}
    inline bndr_1(const bndr_1& bndri) : 
        arity1fp<Function::second_argument_type, Function::result_type>(reinterpret_cast<pf1type>(bndri.pf0)), arg1val(bndri.arg1val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pf2type pf = reinterpret_cast<pf2type>(pf0);
        return pf(arg1val, a2);
    }
public:
    Function::first_argument_type arg1val;
};



// Template Classes for binding pmf  of arity 2 to arity 1

template<class Function> class bndr_mf_2 : 
                public arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>, 
                private arity2_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type> {
public:
    explicit inline bndr_mf_2(const Function &f, Function::second_argument_type a2) : 
        arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity2_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(f), arg2val(a2) {}
    inline bndr_mf_2(const bndr_mf_2& bndri) : 
        arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity2_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(bndri), arg2val(bndri.arg2val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::first_argument_type a1) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (o.*pmf)(a1, arg2val);
    }
public:
    Function::second_argument_type arg2val;
};

template<class Function> class bndr_mf_1 : 
                public arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>, 
                private arity2_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type> {
public:
    explicit inline bndr_mf_1(const Function &f, Function::first_argument_type a1) : 
        arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity2_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(f), arg1val(a1) {}
    inline bndr_mf_1(const bndr_mf_1& bndri) : 
        arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity2_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(bndri), arg1val(bndri.arg1val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::second_argument_type a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (o.*pmf)(arg1val, a2);
    }
public:
    Function::first_argument_type arg1val;
};



// Template Classes for binding const pmf  of arity 2 to arity 1

template<class Function> class bndr_const_mf_2 : 
                public arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>, 
                private arity2_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type> {
public:
    explicit inline bndr_const_mf_2(const Function &f, Function::second_argument_type a2) : 
        arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity2_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(f), arg2val(a2) {}
    inline bndr_const_mf_2(const bndr_const_mf_2& bndri) : 
        arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity2_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(bndri), arg2val(bndri.arg2val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::first_argument_type a1) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (o.*pmf)(a1, arg2val);
    }
public:
    Function::second_argument_type arg2val;
};

template<class Function> class bndr_const_mf_1 : 
                public arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>, 
                private arity2_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type> {
public:
    explicit inline bndr_const_mf_1(const Function &f, Function::first_argument_type a1) : 
        arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity2_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(f), arg1val(a1) {}
    inline bndr_const_mf_1(const bndr_const_mf_1& bndri) : 
        arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity2_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(bndri), arg1val(bndri.arg1val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::second_argument_type a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (o.*pmf)(arg1val, a2);
    }
public:
    Function::first_argument_type arg1val;
};



// Template Classes for binding obj&pmf Ref of arity 2 to arity 1

template<class Function> class bndr_obj_2 : 
                public arity1opmf<Function>, 
                private arity2_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type> {
public:
    explicit inline bndr_obj_2(Function::object_type& oi, const Function &f, Function::second_argument_type a2) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity2_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(f), arg2val(a2) {}
    inline bndr_obj_2(const bndr_obj_2& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity2_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(bndri), arg2val(bndri.arg2val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (objval.*pmf)(a1, arg2val);
    }
public:
    Function::second_argument_type arg2val;
};

template<class Function> class bndr_obj_1 : 
                public arity1opmf<Function>, 
                private arity2_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type> {
public:
    explicit inline bndr_obj_1(Function::object_type& oi, const Function &f, Function::first_argument_type a1) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity2_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(f), arg1val(a1) {}
    inline bndr_obj_1(const bndr_obj_1& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity2_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(bndri), arg1val(bndri.arg1val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (objval.*pmf)(arg1val, a2);
    }
public:
    Function::first_argument_type arg1val;
};



// Template Classes for binding const obj&pmf Ref of arity 2 to arity 1

template<class Function> class bndr_const_obj_2 : 
                public arity1opmf_const<Function>, 
                private arity2_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type> {
public:
    explicit inline bndr_const_obj_2(const Function::object_type& oi, const Function &f, Function::second_argument_type a2) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity2_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(f), arg2val(a2) {}
    inline bndr_const_obj_2(const bndr_const_obj_2& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity2_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(bndri), arg2val(bndri.arg2val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (objval.*pmf)(a1, arg2val);
    }
public:
    Function::second_argument_type arg2val;
};

template<class Function> class bndr_const_obj_1 : 
                public arity1opmf_const<Function>, 
                private arity2_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type> {
public:
    explicit inline bndr_const_obj_1(const Function::object_type& oi, const Function &f, Function::first_argument_type a1) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity2_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(f), arg1val(a1) {}
    inline bndr_const_obj_1(const bndr_const_obj_1& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity2_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(bndri), arg1val(bndri.arg1val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (objval.*pmf)(arg1val, a2);
    }
public:
    Function::first_argument_type arg1val;
};



// Template Functions for binding arity 2 to arity 1


// Template Functions for binding function ptrs of arity 2 to arity 1

template<class Function, class A2> inline bndr_2<Function>
            bind_fp_2(const Function &f, A2 a2) {
                return bndr_2<Function>(f, Function::second_argument_type(a2));
};

template<class Function, class A1> inline bndr_1<Function>
            bind_fp_1(const Function &f, A1 a1) {
                return bndr_1<Function>(f, Function::first_argument_type(a1));
};



// Template Functions for binding pmf  of arity 2 to arity 1

template<class Function, class A2> inline bndr_mf_2<Function>
            bind_mf_2(const Function &f, A2 a2) {
                return bndr_mf_2<Function>(f, Function::second_argument_type(a2));
};

template<class Function, class A1> inline bndr_mf_1<Function>
            bind_mf_1(const Function &f, A1 a1) {
                return bndr_mf_1<Function>(f, Function::first_argument_type(a1));
};



// Template Functions for binding const pmf  of arity 2 to arity 1

template<class Function, class A2> inline bndr_const_mf_2<Function>
            bind_const_mf_2(const Function &f, A2 a2) {
                return bndr_const_mf_2<Function>(f, Function::second_argument_type(a2));
};

template<class Function, class A1> inline bndr_const_mf_1<Function>
            bind_const_mf_1(const Function &f, A1 a1) {
                return bndr_const_mf_1<Function>(f, Function::first_argument_type(a1));
};



// Template Functions for binding obj&pmf Ref of arity 2 to arity 1

template<class Function, class Object, 
                class A2> inline bndr_obj_2<Function>
            bind_obj_2(Object& oi, const Function &f, A2 a2) {
                return bndr_obj_2<Function>(static_cast<Function::object_type&>(oi), f, Function::second_argument_type(a2));
};

template<class Function, class Object, 
                class A1> inline bndr_obj_1<Function>
            bind_obj_1(Object& oi, const Function &f, A1 a1) {
                return bndr_obj_1<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1));
};



// Template Functions for binding const obj&pmf Ref of arity 2 to arity 1

template<class Function, const class Object, 
                class A2> inline bndr_const_obj_2<Function>
            bind_const_obj_2(const Object& oi, const Function &f, A2 a2) {
                return bndr_const_obj_2<Function>(static_cast<Function::object_type&>(oi), f, Function::second_argument_type(a2));
};

template<class Function, const class Object, 
                class A1> inline bndr_const_obj_1<Function>
            bind_const_obj_1(const Object& oi, const Function &f, A1 a1) {
                return bndr_const_obj_1<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1));
};



//
// binders for arity 3
//


// Template Classes for binding arity 3 to arity 1


// Template Classes for binding function ptrs of arity 3 to arity 1

template<class Function> class bndr_2_3 : 
                public arity1fp<Function::first_argument_type, Function::result_type> {
public:
    typedef Function::result_type (*const pf3type) (Function::first_argument_type, Function::second_argument_type, Function::argument_3_type);
    explicit inline bndr_2_3(const Function &f, Function::second_argument_type a2, 
                    Function::argument_3_type a3) : 
        arity1fp<Function::first_argument_type, Function::result_type>(reinterpret_cast<pf1type>(f.pf0)), arg2val(a2), arg3val(a3) {}
    inline bndr_2_3(const bndr_2_3& bndri) : 
        arity1fp<Function::first_argument_type, Function::result_type>(reinterpret_cast<pf1type>(bndri.pf0)), arg2val(bndri.arg2val), arg3val(bndri.arg3val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pf3type pf = reinterpret_cast<pf3type>(pf0);
        return pf(a1, arg2val, arg3val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
};

template<class Function> class bndr_1_3 : 
                public arity1fp<Function::second_argument_type, Function::result_type> {
public:
    typedef Function::result_type (*const pf3type) (Function::first_argument_type, Function::second_argument_type, Function::argument_3_type);
    explicit inline bndr_1_3(const Function &f, Function::first_argument_type a1, 
                    Function::argument_3_type a3) : 
        arity1fp<Function::second_argument_type, Function::result_type>(reinterpret_cast<pf1type>(f.pf0)), arg1val(a1), arg3val(a3) {}
    inline bndr_1_3(const bndr_1_3& bndri) : 
        arity1fp<Function::second_argument_type, Function::result_type>(reinterpret_cast<pf1type>(bndri.pf0)), arg1val(bndri.arg1val), arg3val(bndri.arg3val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pf3type pf = reinterpret_cast<pf3type>(pf0);
        return pf(arg1val, a2, arg3val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
};

template<class Function> class bndr_1_2 : 
                public arity1fp<Function::argument_3_type, Function::result_type> {
public:
    typedef Function::result_type (*const pf3type) (Function::first_argument_type, Function::second_argument_type, Function::argument_3_type);
    explicit inline bndr_1_2(const Function &f, Function::first_argument_type a1, 
                    Function::second_argument_type a2) : 
        arity1fp<Function::argument_3_type, Function::result_type>(reinterpret_cast<pf1type>(f.pf0)), arg1val(a1), arg2val(a2) {}
    inline bndr_1_2(const bndr_1_2& bndri) : 
        arity1fp<Function::argument_3_type, Function::result_type>(reinterpret_cast<pf1type>(bndri.pf0)), arg1val(bndri.arg1val), arg2val(bndri.arg2val) {}
    inline Function::result_type operator()(Function::argument_3_type a3) const {
        pf3type pf = reinterpret_cast<pf3type>(pf0);
        return pf(arg1val, arg2val, a3);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
};



// Template Classes for binding pmf  of arity 3 to arity 1

template<class Function> class bndr_mf_2_3 : 
                public arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>, 
                private arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type> {
public:
    explicit inline bndr_mf_2_3(const Function &f, Function::second_argument_type a2, Function::argument_3_type a3) : 
        arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(f), arg2val(a2), arg3val(a3) {}
    inline bndr_mf_2_3(const bndr_mf_2_3& bndri) : 
        arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::first_argument_type a1) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
};

template<class Function> class bndr_mf_1_3 : 
                public arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>, 
                private arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type> {
public:
    explicit inline bndr_mf_1_3(const Function &f, Function::first_argument_type a1, Function::argument_3_type a3) : 
        arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(f), arg1val(a1), arg3val(a3) {}
    inline bndr_mf_1_3(const bndr_mf_1_3& bndri) : 
        arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::second_argument_type a2) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
};

template<class Function> class bndr_mf_1_2 : 
                public arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>, 
                private arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type> {
public:
    explicit inline bndr_mf_1_2(const Function &f, Function::first_argument_type a1, Function::second_argument_type a2) : 
        arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(f), arg1val(a1), arg2val(a2) {}
    inline bndr_mf_1_2(const bndr_mf_1_2& bndri) : 
        arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::argument_3_type a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
};



// Template Classes for binding const pmf  of arity 3 to arity 1

template<class Function> class bndr_const_mf_2_3 : 
                public arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>, 
                private arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type> {
public:
    explicit inline bndr_const_mf_2_3(const Function &f, Function::second_argument_type a2, Function::argument_3_type a3) : 
        arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(f), arg2val(a2), arg3val(a3) {}
    inline bndr_const_mf_2_3(const bndr_const_mf_2_3& bndri) : 
        arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::first_argument_type a1) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
};

template<class Function> class bndr_const_mf_1_3 : 
                public arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>, 
                private arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type> {
public:
    explicit inline bndr_const_mf_1_3(const Function &f, Function::first_argument_type a1, Function::argument_3_type a3) : 
        arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(f), arg1val(a1), arg3val(a3) {}
    inline bndr_const_mf_1_3(const bndr_const_mf_1_3& bndri) : 
        arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::second_argument_type a2) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
};

template<class Function> class bndr_const_mf_1_2 : 
                public arity1pmf_const<Function::object_type, Function::argument_3_type, Function::result_type>, 
                private arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type> {
public:
    explicit inline bndr_const_mf_1_2(const Function &f, Function::first_argument_type a1, Function::second_argument_type a2) : 
        arity1pmf_const<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(f), arg1val(a1), arg2val(a2) {}
    inline bndr_const_mf_1_2(const bndr_const_mf_1_2& bndri) : 
        arity1pmf_const<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::argument_3_type a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
};



// Template Classes for binding obj&pmf Ref of arity 3 to arity 1

template<class Function> class bndr_obj_2_3 : 
                public arity1opmf<Function>, 
                private arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type> {
public:
    explicit inline bndr_obj_2_3(Function::object_type& oi, const Function &f, Function::second_argument_type a2, Function::argument_3_type a3) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(f), arg2val(a2), arg3val(a3) {}
    inline bndr_obj_2_3(const bndr_obj_2_3& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
};

template<class Function> class bndr_obj_1_3 : 
                public arity1opmf<Function>, 
                private arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type> {
public:
    explicit inline bndr_obj_1_3(Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::argument_3_type a3) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(f), arg1val(a1), arg3val(a3) {}
    inline bndr_obj_1_3(const bndr_obj_1_3& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
};

template<class Function> class bndr_obj_1_2 : 
                public arity1opmf<Function>, 
                private arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type> {
public:
    explicit inline bndr_obj_1_2(Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::second_argument_type a2) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(f), arg1val(a1), arg2val(a2) {}
    inline bndr_obj_1_2(const bndr_obj_1_2& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val) {}
    inline Function::result_type operator()(Function::argument_3_type a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
};



// Template Classes for binding const obj&pmf Ref of arity 3 to arity 1

template<class Function> class bndr_const_obj_2_3 : 
                public arity1opmf_const<Function>, 
                private arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type> {
public:
    explicit inline bndr_const_obj_2_3(const Function::object_type& oi, const Function &f, Function::second_argument_type a2, Function::argument_3_type a3) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(f), arg2val(a2), arg3val(a3) {}
    inline bndr_const_obj_2_3(const bndr_const_obj_2_3& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
};

template<class Function> class bndr_const_obj_1_3 : 
                public arity1opmf_const<Function>, 
                private arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type> {
public:
    explicit inline bndr_const_obj_1_3(const Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::argument_3_type a3) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(f), arg1val(a1), arg3val(a3) {}
    inline bndr_const_obj_1_3(const bndr_const_obj_1_3& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
};

template<class Function> class bndr_const_obj_1_2 : 
                public arity1opmf_const<Function>, 
                private arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type> {
public:
    explicit inline bndr_const_obj_1_2(const Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::second_argument_type a2) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(f), arg1val(a1), arg2val(a2) {}
    inline bndr_const_obj_1_2(const bndr_const_obj_1_2& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val) {}
    inline Function::result_type operator()(Function::argument_3_type a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
};



// Template Functions for binding arity 3 to arity 1


// Template Functions for binding function ptrs of arity 3 to arity 1

template<class Function, class A2, 
                class A3> inline bndr_2_3<Function>
            bind_fp_2_3(const Function &f, A2 a2, 
                                A3 a3) {
                return bndr_2_3<Function>(f, Function::second_argument_type(a2), Function::argument_3_type(a3));
};

template<class Function, class A1, 
                class A3> inline bndr_1_3<Function>
            bind_fp_1_3(const Function &f, A1 a1, 
                                A3 a3) {
                return bndr_1_3<Function>(f, Function::first_argument_type(a1), Function::argument_3_type(a3));
};

template<class Function, class A1, 
                class A2> inline bndr_1_2<Function>
            bind_fp_1_2(const Function &f, A1 a1, 
                                A2 a2) {
                return bndr_1_2<Function>(f, Function::first_argument_type(a1), Function::second_argument_type(a2));
};



// Template Functions for binding pmf  of arity 3 to arity 1

template<class Function, class A2, 
                class A3> inline bndr_mf_2_3<Function>
            bind_mf_2_3(const Function &f, A2 a2, 
                                A3 a3) {
                return bndr_mf_2_3<Function>(f, Function::second_argument_type(a2), Function::argument_3_type(a3));
};

template<class Function, class A1, 
                class A3> inline bndr_mf_1_3<Function>
            bind_mf_1_3(const Function &f, A1 a1, 
                                A3 a3) {
                return bndr_mf_1_3<Function>(f, Function::first_argument_type(a1), Function::argument_3_type(a3));
};

template<class Function, class A1, 
                class A2> inline bndr_mf_1_2<Function>
            bind_mf_1_2(const Function &f, A1 a1, 
                                A2 a2) {
                return bndr_mf_1_2<Function>(f, Function::first_argument_type(a1), Function::second_argument_type(a2));
};



// Template Functions for binding const pmf  of arity 3 to arity 1

template<class Function, class A2, 
                class A3> inline bndr_const_mf_2_3<Function>
            bind_const_mf_2_3(const Function &f, A2 a2, 
                                A3 a3) {
                return bndr_const_mf_2_3<Function>(f, Function::second_argument_type(a2), Function::argument_3_type(a3));
};

template<class Function, class A1, 
                class A3> inline bndr_const_mf_1_3<Function>
            bind_const_mf_1_3(const Function &f, A1 a1, 
                                A3 a3) {
                return bndr_const_mf_1_3<Function>(f, Function::first_argument_type(a1), Function::argument_3_type(a3));
};

template<class Function, class A1, 
                class A2> inline bndr_const_mf_1_2<Function>
            bind_const_mf_1_2(const Function &f, A1 a1, 
                                A2 a2) {
                return bndr_const_mf_1_2<Function>(f, Function::first_argument_type(a1), Function::second_argument_type(a2));
};



// Template Functions for binding obj&pmf Ref of arity 3 to arity 1

template<class Function, class Object, 
                class A2, 
                class A3> inline bndr_obj_2_3<Function>
            bind_obj_2_3(Object& oi, const Function &f, A2 a2, 
                                A3 a3) {
                return bndr_obj_2_3<Function>(static_cast<Function::object_type&>(oi), f, Function::second_argument_type(a2), Function::argument_3_type(a3));
};

template<class Function, class Object, 
                class A1, 
                class A3> inline bndr_obj_1_3<Function>
            bind_obj_1_3(Object& oi, const Function &f, A1 a1, 
                                A3 a3) {
                return bndr_obj_1_3<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::argument_3_type(a3));
};

template<class Function, class Object, 
                class A1, 
                class A2> inline bndr_obj_1_2<Function>
            bind_obj_1_2(Object& oi, const Function &f, A1 a1, 
                                A2 a2) {
                return bndr_obj_1_2<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::second_argument_type(a2));
};



// Template Functions for binding const obj&pmf Ref of arity 3 to arity 1

template<class Function, const class Object, 
                class A2, 
                class A3> inline bndr_const_obj_2_3<Function>
            bind_const_obj_2_3(const Object& oi, const Function &f, A2 a2, 
                                A3 a3) {
                return bndr_const_obj_2_3<Function>(static_cast<Function::object_type&>(oi), f, Function::second_argument_type(a2), Function::argument_3_type(a3));
};

template<class Function, const class Object, 
                class A1, 
                class A3> inline bndr_const_obj_1_3<Function>
            bind_const_obj_1_3(const Object& oi, const Function &f, A1 a1, 
                                A3 a3) {
                return bndr_const_obj_1_3<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::argument_3_type(a3));
};

template<class Function, const class Object, 
                class A1, 
                class A2> inline bndr_const_obj_1_2<Function>
            bind_const_obj_1_2(const Object& oi, const Function &f, A1 a1, 
                                A2 a2) {
                return bndr_const_obj_1_2<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::second_argument_type(a2));
};



//
// binders for arity 4
//


// Template Classes for binding arity 4 to arity 1


// Template Classes for binding pmf  of arity 4 to arity 1

template<class Function> class bndr_mf_2_3_4 : 
                public arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>, 
                private arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type> {
public:
    explicit inline bndr_mf_2_3_4(const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4) : 
        arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4) {}
    inline bndr_mf_2_3_4(const bndr_mf_2_3_4& bndri) : 
        arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::first_argument_type a1) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
};

template<class Function> class bndr_mf_1_3_4 : 
                public arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>, 
                private arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type> {
public:
    explicit inline bndr_mf_1_3_4(const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4) : 
        arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4) {}
    inline bndr_mf_1_3_4(const bndr_mf_1_3_4& bndri) : 
        arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::second_argument_type a2) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
};

template<class Function> class bndr_mf_1_2_4 : 
                public arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>, 
                private arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type> {
public:
    explicit inline bndr_mf_1_2_4(const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4) : 
        arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4) {}
    inline bndr_mf_1_2_4(const bndr_mf_1_2_4& bndri) : 
        arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::argument_3_type a3) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
};



// Template Classes for binding const pmf  of arity 4 to arity 1

template<class Function> class bndr_const_mf_2_3_4 : 
                public arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>, 
                private arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type> {
public:
    explicit inline bndr_const_mf_2_3_4(const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4) : 
        arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4) {}
    inline bndr_const_mf_2_3_4(const bndr_const_mf_2_3_4& bndri) : 
        arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::first_argument_type a1) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
};

template<class Function> class bndr_const_mf_1_3_4 : 
                public arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>, 
                private arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type> {
public:
    explicit inline bndr_const_mf_1_3_4(const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4) : 
        arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4) {}
    inline bndr_const_mf_1_3_4(const bndr_const_mf_1_3_4& bndri) : 
        arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::second_argument_type a2) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
};

template<class Function> class bndr_const_mf_1_2_4 : 
                public arity1pmf_const<Function::object_type, Function::argument_3_type, Function::result_type>, 
                private arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type> {
public:
    explicit inline bndr_const_mf_1_2_4(const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4) : 
        arity1pmf_const<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4) {}
    inline bndr_const_mf_1_2_4(const bndr_const_mf_1_2_4& bndri) : 
        arity1pmf_const<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::argument_3_type a3) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
};



// Template Classes for binding obj&pmf Ref of arity 4 to arity 1

template<class Function> class bndr_obj_2_3_4 : 
                public arity1opmf<Function>, 
                private arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type> {
public:
    explicit inline bndr_obj_2_3_4(Function::object_type& oi, const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4) {}
    inline bndr_obj_2_3_4(const bndr_obj_2_3_4& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
};

template<class Function> class bndr_obj_1_3_4 : 
                public arity1opmf<Function>, 
                private arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type> {
public:
    explicit inline bndr_obj_1_3_4(Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4) {}
    inline bndr_obj_1_3_4(const bndr_obj_1_3_4& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
};

template<class Function> class bndr_obj_1_2_4 : 
                public arity1opmf<Function>, 
                private arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type> {
public:
    explicit inline bndr_obj_1_2_4(Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4) {}
    inline bndr_obj_1_2_4(const bndr_obj_1_2_4& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val) {}
    inline Function::result_type operator()(Function::argument_3_type a3) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
};



// Template Classes for binding const obj&pmf Ref of arity 4 to arity 1

template<class Function> class bndr_const_obj_2_3_4 : 
                public arity1opmf_const<Function>, 
                private arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type> {
public:
    explicit inline bndr_const_obj_2_3_4(const Function::object_type& oi, const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4) {}
    inline bndr_const_obj_2_3_4(const bndr_const_obj_2_3_4& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
};

template<class Function> class bndr_const_obj_1_3_4 : 
                public arity1opmf_const<Function>, 
                private arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type> {
public:
    explicit inline bndr_const_obj_1_3_4(const Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4) {}
    inline bndr_const_obj_1_3_4(const bndr_const_obj_1_3_4& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
};

template<class Function> class bndr_const_obj_1_2_4 : 
                public arity1opmf_const<Function>, 
                private arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type> {
public:
    explicit inline bndr_const_obj_1_2_4(const Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4) {}
    inline bndr_const_obj_1_2_4(const bndr_const_obj_1_2_4& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val) {}
    inline Function::result_type operator()(Function::argument_3_type a3) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
};



// Template Functions for binding arity 4 to arity 1


// Template Functions for binding pmf  of arity 4 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4> inline bndr_mf_2_3_4<Function>
            bind_mf_2_3_4(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4) {
                return bndr_mf_2_3_4<Function>(f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4));
};

template<class Function, class A1, 
                class A3, 
                class A4> inline bndr_mf_1_3_4<Function>
            bind_mf_1_3_4(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4) {
                return bndr_mf_1_3_4<Function>(f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4));
};

template<class Function, class A1, 
                class A2, 
                class A4> inline bndr_mf_1_2_4<Function>
            bind_mf_1_2_4(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4) {
                return bndr_mf_1_2_4<Function>(f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4));
};



// Template Functions for binding const pmf  of arity 4 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4> inline bndr_const_mf_2_3_4<Function>
            bind_const_mf_2_3_4(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4) {
                return bndr_const_mf_2_3_4<Function>(f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4));
};

template<class Function, class A1, 
                class A3, 
                class A4> inline bndr_const_mf_1_3_4<Function>
            bind_const_mf_1_3_4(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4) {
                return bndr_const_mf_1_3_4<Function>(f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4));
};

template<class Function, class A1, 
                class A2, 
                class A4> inline bndr_const_mf_1_2_4<Function>
            bind_const_mf_1_2_4(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4) {
                return bndr_const_mf_1_2_4<Function>(f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4));
};



// Template Functions for binding obj&pmf Ref of arity 4 to arity 1

template<class Function, class Object, 
                class A2, 
                class A3, 
                class A4> inline bndr_obj_2_3_4<Function>
            bind_obj_2_3_4(Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4) {
                return bndr_obj_2_3_4<Function>(static_cast<Function::object_type&>(oi), f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4));
};

template<class Function, class Object, 
                class A1, 
                class A3, 
                class A4> inline bndr_obj_1_3_4<Function>
            bind_obj_1_3_4(Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4) {
                return bndr_obj_1_3_4<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4));
};

template<class Function, class Object, 
                class A1, 
                class A2, 
                class A4> inline bndr_obj_1_2_4<Function>
            bind_obj_1_2_4(Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4) {
                return bndr_obj_1_2_4<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4));
};



// Template Functions for binding const obj&pmf Ref of arity 4 to arity 1

template<class Function, const class Object, 
                class A2, 
                class A3, 
                class A4> inline bndr_const_obj_2_3_4<Function>
            bind_const_obj_2_3_4(const Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4) {
                return bndr_const_obj_2_3_4<Function>(static_cast<Function::object_type&>(oi), f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4));
};

template<class Function, const class Object, 
                class A1, 
                class A3, 
                class A4> inline bndr_const_obj_1_3_4<Function>
            bind_const_obj_1_3_4(const Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4) {
                return bndr_const_obj_1_3_4<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4));
};

template<class Function, const class Object, 
                class A1, 
                class A2, 
                class A4> inline bndr_const_obj_1_2_4<Function>
            bind_const_obj_1_2_4(const Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4) {
                return bndr_const_obj_1_2_4<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4));
};



//
// binders for arity 5
//


// Template Classes for binding arity 5 to arity 1


// Template Classes for binding pmf  of arity 5 to arity 1

template<class Function> class bndr_mf_2_3_4_5 : 
                public arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>, 
                private arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type> {
public:
    explicit inline bndr_mf_2_3_4_5(const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5) : 
        arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline bndr_mf_2_3_4_5(const bndr_mf_2_3_4_5& bndri) : 
        arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::first_argument_type a1) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val, arg5val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
};

template<class Function> class bndr_mf_1_3_4_5 : 
                public arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>, 
                private arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type> {
public:
    explicit inline bndr_mf_1_3_4_5(const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5) : 
        arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline bndr_mf_1_3_4_5(const bndr_mf_1_3_4_5& bndri) : 
        arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::second_argument_type a2) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val, arg5val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
};

template<class Function> class bndr_mf_1_2_4_5 : 
                public arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>, 
                private arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type> {
public:
    explicit inline bndr_mf_1_2_4_5(const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4, Function::argument_5_type a5) : 
        arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5) {}
    inline bndr_mf_1_2_4_5(const bndr_mf_1_2_4_5& bndri) : 
        arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::argument_3_type a3) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val, arg5val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
};



// Template Classes for binding const pmf  of arity 5 to arity 1

template<class Function> class bndr_const_mf_2_3_4_5 : 
                public arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>, 
                private arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type> {
public:
    explicit inline bndr_const_mf_2_3_4_5(const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5) : 
        arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline bndr_const_mf_2_3_4_5(const bndr_const_mf_2_3_4_5& bndri) : 
        arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::first_argument_type a1) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val, arg5val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
};

template<class Function> class bndr_const_mf_1_3_4_5 : 
                public arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>, 
                private arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type> {
public:
    explicit inline bndr_const_mf_1_3_4_5(const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5) : 
        arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline bndr_const_mf_1_3_4_5(const bndr_const_mf_1_3_4_5& bndri) : 
        arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::second_argument_type a2) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val, arg5val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
};

template<class Function> class bndr_const_mf_1_2_4_5 : 
                public arity1pmf_const<Function::object_type, Function::argument_3_type, Function::result_type>, 
                private arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type> {
public:
    explicit inline bndr_const_mf_1_2_4_5(const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4, Function::argument_5_type a5) : 
        arity1pmf_const<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5) {}
    inline bndr_const_mf_1_2_4_5(const bndr_const_mf_1_2_4_5& bndri) : 
        arity1pmf_const<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::argument_3_type a3) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val, arg5val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
};



// Template Classes for binding obj&pmf Ref of arity 5 to arity 1

template<class Function> class bndr_obj_2_3_4_5 : 
                public arity1opmf<Function>, 
                private arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type> {
public:
    explicit inline bndr_obj_2_3_4_5(Function::object_type& oi, const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline bndr_obj_2_3_4_5(const bndr_obj_2_3_4_5& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val, arg5val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
};

template<class Function> class bndr_obj_1_3_4_5 : 
                public arity1opmf<Function>, 
                private arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type> {
public:
    explicit inline bndr_obj_1_3_4_5(Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline bndr_obj_1_3_4_5(const bndr_obj_1_3_4_5& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val, arg5val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
};

template<class Function> class bndr_obj_1_2_4_5 : 
                public arity1opmf<Function>, 
                private arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type> {
public:
    explicit inline bndr_obj_1_2_4_5(Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4, Function::argument_5_type a5) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5) {}
    inline bndr_obj_1_2_4_5(const bndr_obj_1_2_4_5& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline Function::result_type operator()(Function::argument_3_type a3) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val, arg5val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
};



// Template Classes for binding const obj&pmf Ref of arity 5 to arity 1

template<class Function> class bndr_const_obj_2_3_4_5 : 
                public arity1opmf_const<Function>, 
                private arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type> {
public:
    explicit inline bndr_const_obj_2_3_4_5(const Function::object_type& oi, const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline bndr_const_obj_2_3_4_5(const bndr_const_obj_2_3_4_5& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val, arg5val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
};

template<class Function> class bndr_const_obj_1_3_4_5 : 
                public arity1opmf_const<Function>, 
                private arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type> {
public:
    explicit inline bndr_const_obj_1_3_4_5(const Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline bndr_const_obj_1_3_4_5(const bndr_const_obj_1_3_4_5& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val, arg5val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
};

template<class Function> class bndr_const_obj_1_2_4_5 : 
                public arity1opmf_const<Function>, 
                private arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type> {
public:
    explicit inline bndr_const_obj_1_2_4_5(const Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4, Function::argument_5_type a5) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5) {}
    inline bndr_const_obj_1_2_4_5(const bndr_const_obj_1_2_4_5& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline Function::result_type operator()(Function::argument_3_type a3) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val, arg5val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
};



// Template Functions for binding arity 5 to arity 1


// Template Functions for binding pmf  of arity 5 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4, 
                class A5> inline bndr_mf_2_3_4_5<Function>
            bind_mf_2_3_4_5(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return bndr_mf_2_3_4_5<Function>(f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5));
};

template<class Function, class A1, 
                class A3, 
                class A4, 
                class A5> inline bndr_mf_1_3_4_5<Function>
            bind_mf_1_3_4_5(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return bndr_mf_1_3_4_5<Function>(f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5));
};

template<class Function, class A1, 
                class A2, 
                class A4, 
                class A5> inline bndr_mf_1_2_4_5<Function>
            bind_mf_1_2_4_5(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5) {
                return bndr_mf_1_2_4_5<Function>(f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4), Function::argument_5_type(a5));
};



// Template Functions for binding const pmf  of arity 5 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4, 
                class A5> inline bndr_const_mf_2_3_4_5<Function>
            bind_const_mf_2_3_4_5(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return bndr_const_mf_2_3_4_5<Function>(f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5));
};

template<class Function, class A1, 
                class A3, 
                class A4, 
                class A5> inline bndr_const_mf_1_3_4_5<Function>
            bind_const_mf_1_3_4_5(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return bndr_const_mf_1_3_4_5<Function>(f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5));
};

template<class Function, class A1, 
                class A2, 
                class A4, 
                class A5> inline bndr_const_mf_1_2_4_5<Function>
            bind_const_mf_1_2_4_5(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5) {
                return bndr_const_mf_1_2_4_5<Function>(f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4), Function::argument_5_type(a5));
};



// Template Functions for binding obj&pmf Ref of arity 5 to arity 1

template<class Function, class Object, 
                class A2, 
                class A3, 
                class A4, 
                class A5> inline bndr_obj_2_3_4_5<Function>
            bind_obj_2_3_4_5(Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return bndr_obj_2_3_4_5<Function>(static_cast<Function::object_type&>(oi), f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5));
};

template<class Function, class Object, 
                class A1, 
                class A3, 
                class A4, 
                class A5> inline bndr_obj_1_3_4_5<Function>
            bind_obj_1_3_4_5(Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return bndr_obj_1_3_4_5<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5));
};

template<class Function, class Object, 
                class A1, 
                class A2, 
                class A4, 
                class A5> inline bndr_obj_1_2_4_5<Function>
            bind_obj_1_2_4_5(Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5) {
                return bndr_obj_1_2_4_5<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4), Function::argument_5_type(a5));
};



// Template Functions for binding const obj&pmf Ref of arity 5 to arity 1

template<class Function, const class Object, 
                class A2, 
                class A3, 
                class A4, 
                class A5> inline bndr_const_obj_2_3_4_5<Function>
            bind_const_obj_2_3_4_5(const Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return bndr_const_obj_2_3_4_5<Function>(static_cast<Function::object_type&>(oi), f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5));
};

template<class Function, const class Object, 
                class A1, 
                class A3, 
                class A4, 
                class A5> inline bndr_const_obj_1_3_4_5<Function>
            bind_const_obj_1_3_4_5(const Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return bndr_const_obj_1_3_4_5<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5));
};

template<class Function, const class Object, 
                class A1, 
                class A2, 
                class A4, 
                class A5> inline bndr_const_obj_1_2_4_5<Function>
            bind_const_obj_1_2_4_5(const Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5) {
                return bndr_const_obj_1_2_4_5<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4), Function::argument_5_type(a5));
};



//
// binders for arity 6
//


// Template Classes for binding arity 6 to arity 1


// Template Classes for binding pmf  of arity 6 to arity 1

template<class Function> class bndr_mf_2_3_4_5_6 : 
                public arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>, 
                private arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type> {
public:
    explicit inline bndr_mf_2_3_4_5_6(const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6) : 
        arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline bndr_mf_2_3_4_5_6(const bndr_mf_2_3_4_5_6& bndri) : 
        arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::first_argument_type a1) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val, arg5val, arg6val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
};

template<class Function> class bndr_mf_1_3_4_5_6 : 
                public arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>, 
                private arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type> {
public:
    explicit inline bndr_mf_1_3_4_5_6(const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6) : 
        arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline bndr_mf_1_3_4_5_6(const bndr_mf_1_3_4_5_6& bndri) : 
        arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::second_argument_type a2) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val, arg5val, arg6val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
};

template<class Function> class bndr_mf_1_2_4_5_6 : 
                public arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>, 
                private arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type> {
public:
    explicit inline bndr_mf_1_2_4_5_6(const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6) : 
        arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline bndr_mf_1_2_4_5_6(const bndr_mf_1_2_4_5_6& bndri) : 
        arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::argument_3_type a3) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val, arg5val, arg6val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
};



// Template Classes for binding const pmf  of arity 6 to arity 1

template<class Function> class bndr_const_mf_2_3_4_5_6 : 
                public arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>, 
                private arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type> {
public:
    explicit inline bndr_const_mf_2_3_4_5_6(const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6) : 
        arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline bndr_const_mf_2_3_4_5_6(const bndr_const_mf_2_3_4_5_6& bndri) : 
        arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::first_argument_type a1) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val, arg5val, arg6val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
};

template<class Function> class bndr_const_mf_1_3_4_5_6 : 
                public arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>, 
                private arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type> {
public:
    explicit inline bndr_const_mf_1_3_4_5_6(const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6) : 
        arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline bndr_const_mf_1_3_4_5_6(const bndr_const_mf_1_3_4_5_6& bndri) : 
        arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::second_argument_type a2) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val, arg5val, arg6val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
};

template<class Function> class bndr_const_mf_1_2_4_5_6 : 
                public arity1pmf_const<Function::object_type, Function::argument_3_type, Function::result_type>, 
                private arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type> {
public:
    explicit inline bndr_const_mf_1_2_4_5_6(const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6) : 
        arity1pmf_const<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline bndr_const_mf_1_2_4_5_6(const bndr_const_mf_1_2_4_5_6& bndri) : 
        arity1pmf_const<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::argument_3_type a3) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val, arg5val, arg6val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
};



// Template Classes for binding obj&pmf Ref of arity 6 to arity 1

template<class Function> class bndr_obj_2_3_4_5_6 : 
                public arity1opmf<Function>, 
                private arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type> {
public:
    explicit inline bndr_obj_2_3_4_5_6(Function::object_type& oi, const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline bndr_obj_2_3_4_5_6(const bndr_obj_2_3_4_5_6& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val, arg5val, arg6val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
};

template<class Function> class bndr_obj_1_3_4_5_6 : 
                public arity1opmf<Function>, 
                private arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type> {
public:
    explicit inline bndr_obj_1_3_4_5_6(Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline bndr_obj_1_3_4_5_6(const bndr_obj_1_3_4_5_6& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val, arg5val, arg6val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
};

template<class Function> class bndr_obj_1_2_4_5_6 : 
                public arity1opmf<Function>, 
                private arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type> {
public:
    explicit inline bndr_obj_1_2_4_5_6(Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6) : 
        arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline bndr_obj_1_2_4_5_6(const bndr_obj_1_2_4_5_6& bndri) : 
        arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline Function::result_type operator()(Function::argument_3_type a3) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val, arg5val, arg6val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
};



// Template Classes for binding const obj&pmf Ref of arity 6 to arity 1

template<class Function> class bndr_const_obj_2_3_4_5_6 : 
                public arity1opmf_const<Function>, 
                private arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type> {
public:
    explicit inline bndr_const_obj_2_3_4_5_6(const Function::object_type& oi, const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline bndr_const_obj_2_3_4_5_6(const bndr_const_obj_2_3_4_5_6& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val, arg5val, arg6val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
};

template<class Function> class bndr_const_obj_1_3_4_5_6 : 
                public arity1opmf_const<Function>, 
                private arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type> {
public:
    explicit inline bndr_const_obj_1_3_4_5_6(const Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline bndr_const_obj_1_3_4_5_6(const bndr_const_obj_1_3_4_5_6& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val, arg5val, arg6val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
};

template<class Function> class bndr_const_obj_1_2_4_5_6 : 
                public arity1opmf_const<Function>, 
                private arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type> {
public:
    explicit inline bndr_const_obj_1_2_4_5_6(const Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6) : 
        arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline bndr_const_obj_1_2_4_5_6(const bndr_const_obj_1_2_4_5_6& bndri) : 
        arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline Function::result_type operator()(Function::argument_3_type a3) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val, arg5val, arg6val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
};



// Template Functions for binding arity 6 to arity 1


// Template Functions for binding pmf  of arity 6 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline bndr_mf_2_3_4_5_6<Function>
            bind_mf_2_3_4_5_6(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return bndr_mf_2_3_4_5_6<Function>(f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6));
};

template<class Function, class A1, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline bndr_mf_1_3_4_5_6<Function>
            bind_mf_1_3_4_5_6(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return bndr_mf_1_3_4_5_6<Function>(f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6));
};

template<class Function, class A1, 
                class A2, 
                class A4, 
                class A5, 
                class A6> inline bndr_mf_1_2_4_5_6<Function>
            bind_mf_1_2_4_5_6(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return bndr_mf_1_2_4_5_6<Function>(f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6));
};



// Template Functions for binding const pmf  of arity 6 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline bndr_const_mf_2_3_4_5_6<Function>
            bind_const_mf_2_3_4_5_6(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return bndr_const_mf_2_3_4_5_6<Function>(f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6));
};

template<class Function, class A1, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline bndr_const_mf_1_3_4_5_6<Function>
            bind_const_mf_1_3_4_5_6(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return bndr_const_mf_1_3_4_5_6<Function>(f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6));
};

template<class Function, class A1, 
                class A2, 
                class A4, 
                class A5, 
                class A6> inline bndr_const_mf_1_2_4_5_6<Function>
            bind_const_mf_1_2_4_5_6(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return bndr_const_mf_1_2_4_5_6<Function>(f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6));
};



// Template Functions for binding obj&pmf Ref of arity 6 to arity 1

template<class Function, class Object, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline bndr_obj_2_3_4_5_6<Function>
            bind_obj_2_3_4_5_6(Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return bndr_obj_2_3_4_5_6<Function>(static_cast<Function::object_type&>(oi), f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6));
};

template<class Function, class Object, 
                class A1, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline bndr_obj_1_3_4_5_6<Function>
            bind_obj_1_3_4_5_6(Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return bndr_obj_1_3_4_5_6<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6));
};

template<class Function, class Object, 
                class A1, 
                class A2, 
                class A4, 
                class A5, 
                class A6> inline bndr_obj_1_2_4_5_6<Function>
            bind_obj_1_2_4_5_6(Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return bndr_obj_1_2_4_5_6<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6));
};



// Template Functions for binding const obj&pmf Ref of arity 6 to arity 1

template<class Function, const class Object, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline bndr_const_obj_2_3_4_5_6<Function>
            bind_const_obj_2_3_4_5_6(const Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return bndr_const_obj_2_3_4_5_6<Function>(static_cast<Function::object_type&>(oi), f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6));
};

template<class Function, const class Object, 
                class A1, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline bndr_const_obj_1_3_4_5_6<Function>
            bind_const_obj_1_3_4_5_6(const Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return bndr_const_obj_1_3_4_5_6<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6));
};

template<class Function, const class Object, 
                class A1, 
                class A2, 
                class A4, 
                class A5, 
                class A6> inline bndr_const_obj_1_2_4_5_6<Function>
            bind_const_obj_1_2_4_5_6(const Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return bndr_const_obj_1_2_4_5_6<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6));
};



//
// binders for arity 2
//


// Template Classes for binding arity 2 to arity 1


// Template Classes for binding function ptrs of arity 2 to arity 1

template<class Function> class std_bndr_2 : 
                public std_arity1fp<Function::first_argument_type, Function::result_type> {
public:
    typedef Function::result_type ( __stdcall *const pf2type) (Function::first_argument_type, Function::second_argument_type);
    explicit inline std_bndr_2(const Function &f, Function::second_argument_type a2) : 
        std_arity1fp<Function::first_argument_type, Function::result_type>(reinterpret_cast<pf1type>(f.pf0)), arg2val(a2) {}
    inline std_bndr_2(const std_bndr_2& bndri) : 
        std_arity1fp<Function::first_argument_type, Function::result_type>(reinterpret_cast<pf1type>(bndri.pf0)), arg2val(bndri.arg2val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pf2type pf = reinterpret_cast<pf2type>(pf0);
        return pf(a1, arg2val);
    }
public:
    Function::second_argument_type arg2val;
};

template<class Function> class std_bndr_1 : 
                public std_arity1fp<Function::second_argument_type, Function::result_type> {
public:
    typedef Function::result_type ( __stdcall *const pf2type) (Function::first_argument_type, Function::second_argument_type);
    explicit inline std_bndr_1(const Function &f, Function::first_argument_type a1) : 
        std_arity1fp<Function::second_argument_type, Function::result_type>(reinterpret_cast<pf1type>(f.pf0)), arg1val(a1) {}
    inline std_bndr_1(const std_bndr_1& bndri) : 
        std_arity1fp<Function::second_argument_type, Function::result_type>(reinterpret_cast<pf1type>(bndri.pf0)), arg1val(bndri.arg1val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pf2type pf = reinterpret_cast<pf2type>(pf0);
        return pf(arg1val, a2);
    }
public:
    Function::first_argument_type arg1val;
};



// Template Classes for binding pmf  of arity 2 to arity 1

template<class Function> class std_bndr_mf_2 : 
                public std_arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>, 
                private std_arity2_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type> {
public:
    explicit inline std_bndr_mf_2(const Function &f, Function::second_argument_type a2) : 
        std_arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity2_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(f), arg2val(a2) {}
    inline std_bndr_mf_2(const std_bndr_mf_2& bndri) : 
        std_arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity2_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(bndri), arg2val(bndri.arg2val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::first_argument_type a1) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (o.*pmf)(a1, arg2val);
    }
public:
    Function::second_argument_type arg2val;
};

template<class Function> class std_bndr_mf_1 : 
                public std_arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>, 
                private std_arity2_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type> {
public:
    explicit inline std_bndr_mf_1(const Function &f, Function::first_argument_type a1) : 
        std_arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity2_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(f), arg1val(a1) {}
    inline std_bndr_mf_1(const std_bndr_mf_1& bndri) : 
        std_arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity2_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(bndri), arg1val(bndri.arg1val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::second_argument_type a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (o.*pmf)(arg1val, a2);
    }
public:
    Function::first_argument_type arg1val;
};



// Template Classes for binding const pmf  of arity 2 to arity 1

template<class Function> class std_bndr_const_mf_2 : 
                public std_arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>, 
                private std_arity2_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type> {
public:
    explicit inline std_bndr_const_mf_2(const Function &f, Function::second_argument_type a2) : 
        std_arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity2_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(f), arg2val(a2) {}
    inline std_bndr_const_mf_2(const std_bndr_const_mf_2& bndri) : 
        std_arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity2_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(bndri), arg2val(bndri.arg2val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::first_argument_type a1) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (o.*pmf)(a1, arg2val);
    }
public:
    Function::second_argument_type arg2val;
};

template<class Function> class std_bndr_const_mf_1 : 
                public std_arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>, 
                private std_arity2_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type> {
public:
    explicit inline std_bndr_const_mf_1(const Function &f, Function::first_argument_type a1) : 
        std_arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity2_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(f), arg1val(a1) {}
    inline std_bndr_const_mf_1(const std_bndr_const_mf_1& bndri) : 
        std_arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity2_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(bndri), arg1val(bndri.arg1val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::second_argument_type a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (o.*pmf)(arg1val, a2);
    }
public:
    Function::first_argument_type arg1val;
};



// Template Classes for binding obj&pmf Ref of arity 2 to arity 1

template<class Function> class std_bndr_obj_2 : 
                public std_arity1opmf<Function>, 
                private std_arity2_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type> {
public:
    explicit inline std_bndr_obj_2(Function::object_type& oi, const Function &f, Function::second_argument_type a2) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity2_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(f), arg2val(a2) {}
    inline std_bndr_obj_2(const std_bndr_obj_2& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity2_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(bndri), arg2val(bndri.arg2val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (objval.*pmf)(a1, arg2val);
    }
public:
    Function::second_argument_type arg2val;
};

template<class Function> class std_bndr_obj_1 : 
                public std_arity1opmf<Function>, 
                private std_arity2_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type> {
public:
    explicit inline std_bndr_obj_1(Function::object_type& oi, const Function &f, Function::first_argument_type a1) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity2_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(f), arg1val(a1) {}
    inline std_bndr_obj_1(const std_bndr_obj_1& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity2_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(bndri), arg1val(bndri.arg1val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (objval.*pmf)(arg1val, a2);
    }
public:
    Function::first_argument_type arg1val;
};



// Template Classes for binding const obj&pmf Ref of arity 2 to arity 1

template<class Function> class std_bndr_const_obj_2 : 
                public std_arity1opmf_const<Function>, 
                private std_arity2_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type> {
public:
    explicit inline std_bndr_const_obj_2(const Function::object_type& oi, const Function &f, Function::second_argument_type a2) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity2_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(f), arg2val(a2) {}
    inline std_bndr_const_obj_2(const std_bndr_const_obj_2& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity2_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(bndri), arg2val(bndri.arg2val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (objval.*pmf)(a1, arg2val);
    }
public:
    Function::second_argument_type arg2val;
};

template<class Function> class std_bndr_const_obj_1 : 
                public std_arity1opmf_const<Function>, 
                private std_arity2_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type> {
public:
    explicit inline std_bndr_const_obj_1(const Function::object_type& oi, const Function &f, Function::first_argument_type a1) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity2_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(f), arg1val(a1) {}
    inline std_bndr_const_obj_1(const std_bndr_const_obj_1& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity2_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, Function::result_type>(bndri), arg1val(bndri.arg1val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pmf2type pmf = reinterpret_cast<pmf2type>(pmf0);
        return (objval.*pmf)(arg1val, a2);
    }
public:
    Function::first_argument_type arg1val;
};



// Template Functions for binding arity 2 to arity 1


// Template Functions for binding function ptrs of arity 2 to arity 1

template<class Function, class A2> inline std_bndr_2<Function>
            std_bind_fp_2(const Function &f, A2 a2) {
                return std_bndr_2<Function>(f, Function::second_argument_type(a2));
};

template<class Function, class A1> inline std_bndr_1<Function>
            std_bind_fp_1(const Function &f, A1 a1) {
                return std_bndr_1<Function>(f, Function::first_argument_type(a1));
};



// Template Functions for binding pmf  of arity 2 to arity 1

template<class Function, class A2> inline std_bndr_mf_2<Function>
            std_bind_mf_2(const Function &f, A2 a2) {
                return std_bndr_mf_2<Function>(f, Function::second_argument_type(a2));
};

template<class Function, class A1> inline std_bndr_mf_1<Function>
            std_bind_mf_1(const Function &f, A1 a1) {
                return std_bndr_mf_1<Function>(f, Function::first_argument_type(a1));
};



// Template Functions for binding const pmf  of arity 2 to arity 1

template<class Function, class A2> inline std_bndr_const_mf_2<Function>
            std_bind_const_mf_2(const Function &f, A2 a2) {
                return std_bndr_const_mf_2<Function>(f, Function::second_argument_type(a2));
};

template<class Function, class A1> inline std_bndr_const_mf_1<Function>
            std_bind_const_mf_1(const Function &f, A1 a1) {
                return std_bndr_const_mf_1<Function>(f, Function::first_argument_type(a1));
};



// Template Functions for binding obj&pmf Ref of arity 2 to arity 1

template<class Function, class Object, 
                class A2> inline std_bndr_obj_2<Function>
            std_bind_obj_2(Object& oi, const Function &f, A2 a2) {
                return std_bndr_obj_2<Function>(static_cast<Function::object_type&>(oi), f, Function::second_argument_type(a2));
};

template<class Function, class Object, 
                class A1> inline std_bndr_obj_1<Function>
            std_bind_obj_1(Object& oi, const Function &f, A1 a1) {
                return std_bndr_obj_1<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1));
};



// Template Functions for binding const obj&pmf Ref of arity 2 to arity 1

template<class Function, const class Object, 
                class A2> inline std_bndr_const_obj_2<Function>
            std_bind_const_obj_2(const Object& oi, const Function &f, A2 a2) {
                return std_bndr_const_obj_2<Function>(static_cast<Function::object_type&>(oi), f, Function::second_argument_type(a2));
};

template<class Function, const class Object, 
                class A1> inline std_bndr_const_obj_1<Function>
            std_bind_const_obj_1(const Object& oi, const Function &f, A1 a1) {
                return std_bndr_const_obj_1<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1));
};



//
// binders for arity 3
//


// Template Classes for binding arity 3 to arity 1


// Template Classes for binding function ptrs of arity 3 to arity 1

template<class Function> class std_bndr_2_3 : 
                public std_arity1fp<Function::first_argument_type, Function::result_type> {
public:
    typedef Function::result_type ( __stdcall *const pf3type) (Function::first_argument_type, Function::second_argument_type, Function::argument_3_type);
    explicit inline std_bndr_2_3(const Function &f, Function::second_argument_type a2, 
                    Function::argument_3_type a3) : 
        std_arity1fp<Function::first_argument_type, Function::result_type>(reinterpret_cast<pf1type>(f.pf0)), arg2val(a2), arg3val(a3) {}
    inline std_bndr_2_3(const std_bndr_2_3& bndri) : 
        std_arity1fp<Function::first_argument_type, Function::result_type>(reinterpret_cast<pf1type>(bndri.pf0)), arg2val(bndri.arg2val), arg3val(bndri.arg3val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pf3type pf = reinterpret_cast<pf3type>(pf0);
        return pf(a1, arg2val, arg3val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
};

template<class Function> class std_bndr_1_3 : 
                public std_arity1fp<Function::second_argument_type, Function::result_type> {
public:
    typedef Function::result_type ( __stdcall *const pf3type) (Function::first_argument_type, Function::second_argument_type, Function::argument_3_type);
    explicit inline std_bndr_1_3(const Function &f, Function::first_argument_type a1, 
                    Function::argument_3_type a3) : 
        std_arity1fp<Function::second_argument_type, Function::result_type>(reinterpret_cast<pf1type>(f.pf0)), arg1val(a1), arg3val(a3) {}
    inline std_bndr_1_3(const std_bndr_1_3& bndri) : 
        std_arity1fp<Function::second_argument_type, Function::result_type>(reinterpret_cast<pf1type>(bndri.pf0)), arg1val(bndri.arg1val), arg3val(bndri.arg3val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pf3type pf = reinterpret_cast<pf3type>(pf0);
        return pf(arg1val, a2, arg3val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
};

template<class Function> class std_bndr_1_2 : 
                public std_arity1fp<Function::argument_3_type, Function::result_type> {
public:
    typedef Function::result_type ( __stdcall *const pf3type) (Function::first_argument_type, Function::second_argument_type, Function::argument_3_type);
    explicit inline std_bndr_1_2(const Function &f, Function::first_argument_type a1, 
                    Function::second_argument_type a2) : 
        std_arity1fp<Function::argument_3_type, Function::result_type>(reinterpret_cast<pf1type>(f.pf0)), arg1val(a1), arg2val(a2) {}
    inline std_bndr_1_2(const std_bndr_1_2& bndri) : 
        std_arity1fp<Function::argument_3_type, Function::result_type>(reinterpret_cast<pf1type>(bndri.pf0)), arg1val(bndri.arg1val), arg2val(bndri.arg2val) {}
    inline Function::result_type operator()(Function::argument_3_type a3) const {
        pf3type pf = reinterpret_cast<pf3type>(pf0);
        return pf(arg1val, arg2val, a3);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
};



// Template Classes for binding pmf  of arity 3 to arity 1

template<class Function> class std_bndr_mf_2_3 : 
                public std_arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>, 
                private std_arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type> {
public:
    explicit inline std_bndr_mf_2_3(const Function &f, Function::second_argument_type a2, Function::argument_3_type a3) : 
        std_arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(f), arg2val(a2), arg3val(a3) {}
    inline std_bndr_mf_2_3(const std_bndr_mf_2_3& bndri) : 
        std_arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::first_argument_type a1) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
};

template<class Function> class std_bndr_mf_1_3 : 
                public std_arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>, 
                private std_arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type> {
public:
    explicit inline std_bndr_mf_1_3(const Function &f, Function::first_argument_type a1, Function::argument_3_type a3) : 
        std_arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(f), arg1val(a1), arg3val(a3) {}
    inline std_bndr_mf_1_3(const std_bndr_mf_1_3& bndri) : 
        std_arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::second_argument_type a2) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
};

template<class Function> class std_bndr_mf_1_2 : 
                public std_arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>, 
                private std_arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type> {
public:
    explicit inline std_bndr_mf_1_2(const Function &f, Function::first_argument_type a1, Function::second_argument_type a2) : 
        std_arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(f), arg1val(a1), arg2val(a2) {}
    inline std_bndr_mf_1_2(const std_bndr_mf_1_2& bndri) : 
        std_arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::argument_3_type a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
};



// Template Classes for binding const pmf  of arity 3 to arity 1

template<class Function> class std_bndr_const_mf_2_3 : 
                public std_arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>, 
                private std_arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type> {
public:
    explicit inline std_bndr_const_mf_2_3(const Function &f, Function::second_argument_type a2, Function::argument_3_type a3) : 
        std_arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(f), arg2val(a2), arg3val(a3) {}
    inline std_bndr_const_mf_2_3(const std_bndr_const_mf_2_3& bndri) : 
        std_arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::first_argument_type a1) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
};

template<class Function> class std_bndr_const_mf_1_3 : 
                public std_arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>, 
                private std_arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type> {
public:
    explicit inline std_bndr_const_mf_1_3(const Function &f, Function::first_argument_type a1, Function::argument_3_type a3) : 
        std_arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(f), arg1val(a1), arg3val(a3) {}
    inline std_bndr_const_mf_1_3(const std_bndr_const_mf_1_3& bndri) : 
        std_arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::second_argument_type a2) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
};

template<class Function> class std_bndr_const_mf_1_2 : 
                public std_arity1pmf_const<Function::object_type, Function::argument_3_type, Function::result_type>, 
                private std_arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type> {
public:
    explicit inline std_bndr_const_mf_1_2(const Function &f, Function::first_argument_type a1, Function::second_argument_type a2) : 
        std_arity1pmf_const<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(f), arg1val(a1), arg2val(a2) {}
    inline std_bndr_const_mf_1_2(const std_bndr_const_mf_1_2& bndri) : 
        std_arity1pmf_const<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::argument_3_type a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
};



// Template Classes for binding obj&pmf Ref of arity 3 to arity 1

template<class Function> class std_bndr_obj_2_3 : 
                public std_arity1opmf<Function>, 
                private std_arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type> {
public:
    explicit inline std_bndr_obj_2_3(Function::object_type& oi, const Function &f, Function::second_argument_type a2, Function::argument_3_type a3) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(f), arg2val(a2), arg3val(a3) {}
    inline std_bndr_obj_2_3(const std_bndr_obj_2_3& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
};

template<class Function> class std_bndr_obj_1_3 : 
                public std_arity1opmf<Function>, 
                private std_arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type> {
public:
    explicit inline std_bndr_obj_1_3(Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::argument_3_type a3) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(f), arg1val(a1), arg3val(a3) {}
    inline std_bndr_obj_1_3(const std_bndr_obj_1_3& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
};

template<class Function> class std_bndr_obj_1_2 : 
                public std_arity1opmf<Function>, 
                private std_arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type> {
public:
    explicit inline std_bndr_obj_1_2(Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::second_argument_type a2) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(f), arg1val(a1), arg2val(a2) {}
    inline std_bndr_obj_1_2(const std_bndr_obj_1_2& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity3_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val) {}
    inline Function::result_type operator()(Function::argument_3_type a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
};



// Template Classes for binding const obj&pmf Ref of arity 3 to arity 1

template<class Function> class std_bndr_const_obj_2_3 : 
                public std_arity1opmf_const<Function>, 
                private std_arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type> {
public:
    explicit inline std_bndr_const_obj_2_3(const Function::object_type& oi, const Function &f, Function::second_argument_type a2, Function::argument_3_type a3) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(f), arg2val(a2), arg3val(a3) {}
    inline std_bndr_const_obj_2_3(const std_bndr_const_obj_2_3& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
};

template<class Function> class std_bndr_const_obj_1_3 : 
                public std_arity1opmf_const<Function>, 
                private std_arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type> {
public:
    explicit inline std_bndr_const_obj_1_3(const Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::argument_3_type a3) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(f), arg1val(a1), arg3val(a3) {}
    inline std_bndr_const_obj_1_3(const std_bndr_const_obj_1_3& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
};

template<class Function> class std_bndr_const_obj_1_2 : 
                public std_arity1opmf_const<Function>, 
                private std_arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type> {
public:
    explicit inline std_bndr_const_obj_1_2(const Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::second_argument_type a2) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(f), arg1val(a1), arg2val(a2) {}
    inline std_bndr_const_obj_1_2(const std_bndr_const_obj_1_2& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity3_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val) {}
    inline Function::result_type operator()(Function::argument_3_type a3) const {
        pmf3type pmf = reinterpret_cast<pmf3type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
};



// Template Functions for binding arity 3 to arity 1


// Template Functions for binding function ptrs of arity 3 to arity 1

template<class Function, class A2, 
                class A3> inline std_bndr_2_3<Function>
            std_bind_fp_2_3(const Function &f, A2 a2, 
                                A3 a3) {
                return std_bndr_2_3<Function>(f, Function::second_argument_type(a2), Function::argument_3_type(a3));
};

template<class Function, class A1, 
                class A3> inline std_bndr_1_3<Function>
            std_bind_fp_1_3(const Function &f, A1 a1, 
                                A3 a3) {
                return std_bndr_1_3<Function>(f, Function::first_argument_type(a1), Function::argument_3_type(a3));
};

template<class Function, class A1, 
                class A2> inline std_bndr_1_2<Function>
            std_bind_fp_1_2(const Function &f, A1 a1, 
                                A2 a2) {
                return std_bndr_1_2<Function>(f, Function::first_argument_type(a1), Function::second_argument_type(a2));
};



// Template Functions for binding pmf  of arity 3 to arity 1

template<class Function, class A2, 
                class A3> inline std_bndr_mf_2_3<Function>
            std_bind_mf_2_3(const Function &f, A2 a2, 
                                A3 a3) {
                return std_bndr_mf_2_3<Function>(f, Function::second_argument_type(a2), Function::argument_3_type(a3));
};

template<class Function, class A1, 
                class A3> inline std_bndr_mf_1_3<Function>
            std_bind_mf_1_3(const Function &f, A1 a1, 
                                A3 a3) {
                return std_bndr_mf_1_3<Function>(f, Function::first_argument_type(a1), Function::argument_3_type(a3));
};

template<class Function, class A1, 
                class A2> inline std_bndr_mf_1_2<Function>
            std_bind_mf_1_2(const Function &f, A1 a1, 
                                A2 a2) {
                return std_bndr_mf_1_2<Function>(f, Function::first_argument_type(a1), Function::second_argument_type(a2));
};



// Template Functions for binding const pmf  of arity 3 to arity 1

template<class Function, class A2, 
                class A3> inline std_bndr_const_mf_2_3<Function>
            std_bind_const_mf_2_3(const Function &f, A2 a2, 
                                A3 a3) {
                return std_bndr_const_mf_2_3<Function>(f, Function::second_argument_type(a2), Function::argument_3_type(a3));
};

template<class Function, class A1, 
                class A3> inline std_bndr_const_mf_1_3<Function>
            std_bind_const_mf_1_3(const Function &f, A1 a1, 
                                A3 a3) {
                return std_bndr_const_mf_1_3<Function>(f, Function::first_argument_type(a1), Function::argument_3_type(a3));
};

template<class Function, class A1, 
                class A2> inline std_bndr_const_mf_1_2<Function>
            std_bind_const_mf_1_2(const Function &f, A1 a1, 
                                A2 a2) {
                return std_bndr_const_mf_1_2<Function>(f, Function::first_argument_type(a1), Function::second_argument_type(a2));
};



// Template Functions for binding obj&pmf Ref of arity 3 to arity 1

template<class Function, class Object, 
                class A2, 
                class A3> inline std_bndr_obj_2_3<Function>
            std_bind_obj_2_3(Object& oi, const Function &f, A2 a2, 
                                A3 a3) {
                return std_bndr_obj_2_3<Function>(static_cast<Function::object_type&>(oi), f, Function::second_argument_type(a2), Function::argument_3_type(a3));
};

template<class Function, class Object, 
                class A1, 
                class A3> inline std_bndr_obj_1_3<Function>
            std_bind_obj_1_3(Object& oi, const Function &f, A1 a1, 
                                A3 a3) {
                return std_bndr_obj_1_3<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::argument_3_type(a3));
};

template<class Function, class Object, 
                class A1, 
                class A2> inline std_bndr_obj_1_2<Function>
            std_bind_obj_1_2(Object& oi, const Function &f, A1 a1, 
                                A2 a2) {
                return std_bndr_obj_1_2<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::second_argument_type(a2));
};



// Template Functions for binding const obj&pmf Ref of arity 3 to arity 1

template<class Function, const class Object, 
                class A2, 
                class A3> inline std_bndr_const_obj_2_3<Function>
            std_bind_const_obj_2_3(const Object& oi, const Function &f, A2 a2, 
                                A3 a3) {
                return std_bndr_const_obj_2_3<Function>(static_cast<Function::object_type&>(oi), f, Function::second_argument_type(a2), Function::argument_3_type(a3));
};

template<class Function, const class Object, 
                class A1, 
                class A3> inline std_bndr_const_obj_1_3<Function>
            std_bind_const_obj_1_3(const Object& oi, const Function &f, A1 a1, 
                                A3 a3) {
                return std_bndr_const_obj_1_3<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::argument_3_type(a3));
};

template<class Function, const class Object, 
                class A1, 
                class A2> inline std_bndr_const_obj_1_2<Function>
            std_bind_const_obj_1_2(const Object& oi, const Function &f, A1 a1, 
                                A2 a2) {
                return std_bndr_const_obj_1_2<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::second_argument_type(a2));
};



//
// binders for arity 4
//


// Template Classes for binding arity 4 to arity 1


// Template Classes for binding pmf  of arity 4 to arity 1

template<class Function> class std_bndr_mf_2_3_4 : 
                public std_arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>, 
                private std_arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type> {
public:
    explicit inline std_bndr_mf_2_3_4(const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4) : 
        std_arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4) {}
    inline std_bndr_mf_2_3_4(const std_bndr_mf_2_3_4& bndri) : 
        std_arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::first_argument_type a1) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
};

template<class Function> class std_bndr_mf_1_3_4 : 
                public std_arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>, 
                private std_arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type> {
public:
    explicit inline std_bndr_mf_1_3_4(const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4) : 
        std_arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4) {}
    inline std_bndr_mf_1_3_4(const std_bndr_mf_1_3_4& bndri) : 
        std_arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::second_argument_type a2) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
};

template<class Function> class std_bndr_mf_1_2_4 : 
                public std_arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>, 
                private std_arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type> {
public:
    explicit inline std_bndr_mf_1_2_4(const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4) : 
        std_arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4) {}
    inline std_bndr_mf_1_2_4(const std_bndr_mf_1_2_4& bndri) : 
        std_arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::argument_3_type a3) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
};



// Template Classes for binding const pmf  of arity 4 to arity 1

template<class Function> class std_bndr_const_mf_2_3_4 : 
                public std_arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>, 
                private std_arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type> {
public:
    explicit inline std_bndr_const_mf_2_3_4(const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4) : 
        std_arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4) {}
    inline std_bndr_const_mf_2_3_4(const std_bndr_const_mf_2_3_4& bndri) : 
        std_arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::first_argument_type a1) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
};

template<class Function> class std_bndr_const_mf_1_3_4 : 
                public std_arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>, 
                private std_arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type> {
public:
    explicit inline std_bndr_const_mf_1_3_4(const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4) : 
        std_arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4) {}
    inline std_bndr_const_mf_1_3_4(const std_bndr_const_mf_1_3_4& bndri) : 
        std_arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::second_argument_type a2) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
};

template<class Function> class std_bndr_const_mf_1_2_4 : 
                public std_arity1pmf_const<Function::object_type, Function::argument_3_type, Function::result_type>, 
                private std_arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type> {
public:
    explicit inline std_bndr_const_mf_1_2_4(const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4) : 
        std_arity1pmf_const<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4) {}
    inline std_bndr_const_mf_1_2_4(const std_bndr_const_mf_1_2_4& bndri) : 
        std_arity1pmf_const<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::argument_3_type a3) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
};



// Template Classes for binding obj&pmf Ref of arity 4 to arity 1

template<class Function> class std_bndr_obj_2_3_4 : 
                public std_arity1opmf<Function>, 
                private std_arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type> {
public:
    explicit inline std_bndr_obj_2_3_4(Function::object_type& oi, const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4) {}
    inline std_bndr_obj_2_3_4(const std_bndr_obj_2_3_4& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
};

template<class Function> class std_bndr_obj_1_3_4 : 
                public std_arity1opmf<Function>, 
                private std_arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type> {
public:
    explicit inline std_bndr_obj_1_3_4(Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4) {}
    inline std_bndr_obj_1_3_4(const std_bndr_obj_1_3_4& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
};

template<class Function> class std_bndr_obj_1_2_4 : 
                public std_arity1opmf<Function>, 
                private std_arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type> {
public:
    explicit inline std_bndr_obj_1_2_4(Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4) {}
    inline std_bndr_obj_1_2_4(const std_bndr_obj_1_2_4& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity4_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val) {}
    inline Function::result_type operator()(Function::argument_3_type a3) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
};



// Template Classes for binding const obj&pmf Ref of arity 4 to arity 1

template<class Function> class std_bndr_const_obj_2_3_4 : 
                public std_arity1opmf_const<Function>, 
                private std_arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type> {
public:
    explicit inline std_bndr_const_obj_2_3_4(const Function::object_type& oi, const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4) {}
    inline std_bndr_const_obj_2_3_4(const std_bndr_const_obj_2_3_4& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
};

template<class Function> class std_bndr_const_obj_1_3_4 : 
                public std_arity1opmf_const<Function>, 
                private std_arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type> {
public:
    explicit inline std_bndr_const_obj_1_3_4(const Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4) {}
    inline std_bndr_const_obj_1_3_4(const std_bndr_const_obj_1_3_4& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
};

template<class Function> class std_bndr_const_obj_1_2_4 : 
                public std_arity1opmf_const<Function>, 
                private std_arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type> {
public:
    explicit inline std_bndr_const_obj_1_2_4(const Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4) {}
    inline std_bndr_const_obj_1_2_4(const std_bndr_const_obj_1_2_4& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity4_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val) {}
    inline Function::result_type operator()(Function::argument_3_type a3) const {
        pmf4type pmf = reinterpret_cast<pmf4type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
};



// Template Functions for binding arity 4 to arity 1


// Template Functions for binding pmf  of arity 4 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4> inline std_bndr_mf_2_3_4<Function>
            std_bind_mf_2_3_4(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4) {
                return std_bndr_mf_2_3_4<Function>(f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4));
};

template<class Function, class A1, 
                class A3, 
                class A4> inline std_bndr_mf_1_3_4<Function>
            std_bind_mf_1_3_4(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4) {
                return std_bndr_mf_1_3_4<Function>(f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4));
};

template<class Function, class A1, 
                class A2, 
                class A4> inline std_bndr_mf_1_2_4<Function>
            std_bind_mf_1_2_4(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4) {
                return std_bndr_mf_1_2_4<Function>(f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4));
};



// Template Functions for binding const pmf  of arity 4 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4> inline std_bndr_const_mf_2_3_4<Function>
            std_bind_const_mf_2_3_4(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4) {
                return std_bndr_const_mf_2_3_4<Function>(f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4));
};

template<class Function, class A1, 
                class A3, 
                class A4> inline std_bndr_const_mf_1_3_4<Function>
            std_bind_const_mf_1_3_4(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4) {
                return std_bndr_const_mf_1_3_4<Function>(f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4));
};

template<class Function, class A1, 
                class A2, 
                class A4> inline std_bndr_const_mf_1_2_4<Function>
            std_bind_const_mf_1_2_4(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4) {
                return std_bndr_const_mf_1_2_4<Function>(f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4));
};



// Template Functions for binding obj&pmf Ref of arity 4 to arity 1

template<class Function, class Object, 
                class A2, 
                class A3, 
                class A4> inline std_bndr_obj_2_3_4<Function>
            std_bind_obj_2_3_4(Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4) {
                return std_bndr_obj_2_3_4<Function>(static_cast<Function::object_type&>(oi), f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4));
};

template<class Function, class Object, 
                class A1, 
                class A3, 
                class A4> inline std_bndr_obj_1_3_4<Function>
            std_bind_obj_1_3_4(Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4) {
                return std_bndr_obj_1_3_4<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4));
};

template<class Function, class Object, 
                class A1, 
                class A2, 
                class A4> inline std_bndr_obj_1_2_4<Function>
            std_bind_obj_1_2_4(Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4) {
                return std_bndr_obj_1_2_4<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4));
};



// Template Functions for binding const obj&pmf Ref of arity 4 to arity 1

template<class Function, const class Object, 
                class A2, 
                class A3, 
                class A4> inline std_bndr_const_obj_2_3_4<Function>
            std_bind_const_obj_2_3_4(const Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4) {
                return std_bndr_const_obj_2_3_4<Function>(static_cast<Function::object_type&>(oi), f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4));
};

template<class Function, const class Object, 
                class A1, 
                class A3, 
                class A4> inline std_bndr_const_obj_1_3_4<Function>
            std_bind_const_obj_1_3_4(const Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4) {
                return std_bndr_const_obj_1_3_4<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4));
};

template<class Function, const class Object, 
                class A1, 
                class A2, 
                class A4> inline std_bndr_const_obj_1_2_4<Function>
            std_bind_const_obj_1_2_4(const Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4) {
                return std_bndr_const_obj_1_2_4<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4));
};



//
// binders for arity 5
//


// Template Classes for binding arity 5 to arity 1


// Template Classes for binding pmf  of arity 5 to arity 1

template<class Function> class std_bndr_mf_2_3_4_5 : 
                public std_arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>, 
                private std_arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type> {
public:
    explicit inline std_bndr_mf_2_3_4_5(const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5) : 
        std_arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline std_bndr_mf_2_3_4_5(const std_bndr_mf_2_3_4_5& bndri) : 
        std_arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::first_argument_type a1) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val, arg5val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
};

template<class Function> class std_bndr_mf_1_3_4_5 : 
                public std_arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>, 
                private std_arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type> {
public:
    explicit inline std_bndr_mf_1_3_4_5(const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5) : 
        std_arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline std_bndr_mf_1_3_4_5(const std_bndr_mf_1_3_4_5& bndri) : 
        std_arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::second_argument_type a2) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val, arg5val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
};

template<class Function> class std_bndr_mf_1_2_4_5 : 
                public std_arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>, 
                private std_arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type> {
public:
    explicit inline std_bndr_mf_1_2_4_5(const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4, Function::argument_5_type a5) : 
        std_arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5) {}
    inline std_bndr_mf_1_2_4_5(const std_bndr_mf_1_2_4_5& bndri) : 
        std_arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::argument_3_type a3) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val, arg5val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
};



// Template Classes for binding const pmf  of arity 5 to arity 1

template<class Function> class std_bndr_const_mf_2_3_4_5 : 
                public std_arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>, 
                private std_arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type> {
public:
    explicit inline std_bndr_const_mf_2_3_4_5(const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5) : 
        std_arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline std_bndr_const_mf_2_3_4_5(const std_bndr_const_mf_2_3_4_5& bndri) : 
        std_arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::first_argument_type a1) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val, arg5val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
};

template<class Function> class std_bndr_const_mf_1_3_4_5 : 
                public std_arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>, 
                private std_arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type> {
public:
    explicit inline std_bndr_const_mf_1_3_4_5(const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5) : 
        std_arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline std_bndr_const_mf_1_3_4_5(const std_bndr_const_mf_1_3_4_5& bndri) : 
        std_arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::second_argument_type a2) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val, arg5val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
};

template<class Function> class std_bndr_const_mf_1_2_4_5 : 
                public std_arity1pmf_const<Function::object_type, Function::argument_3_type, Function::result_type>, 
                private std_arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type> {
public:
    explicit inline std_bndr_const_mf_1_2_4_5(const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4, Function::argument_5_type a5) : 
        std_arity1pmf_const<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5) {}
    inline std_bndr_const_mf_1_2_4_5(const std_bndr_const_mf_1_2_4_5& bndri) : 
        std_arity1pmf_const<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::argument_3_type a3) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val, arg5val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
};



// Template Classes for binding obj&pmf Ref of arity 5 to arity 1

template<class Function> class std_bndr_obj_2_3_4_5 : 
                public std_arity1opmf<Function>, 
                private std_arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type> {
public:
    explicit inline std_bndr_obj_2_3_4_5(Function::object_type& oi, const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline std_bndr_obj_2_3_4_5(const std_bndr_obj_2_3_4_5& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val, arg5val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
};

template<class Function> class std_bndr_obj_1_3_4_5 : 
                public std_arity1opmf<Function>, 
                private std_arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type> {
public:
    explicit inline std_bndr_obj_1_3_4_5(Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline std_bndr_obj_1_3_4_5(const std_bndr_obj_1_3_4_5& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val, arg5val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
};

template<class Function> class std_bndr_obj_1_2_4_5 : 
                public std_arity1opmf<Function>, 
                private std_arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type> {
public:
    explicit inline std_bndr_obj_1_2_4_5(Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4, Function::argument_5_type a5) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5) {}
    inline std_bndr_obj_1_2_4_5(const std_bndr_obj_1_2_4_5& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity5_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline Function::result_type operator()(Function::argument_3_type a3) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val, arg5val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
};



// Template Classes for binding const obj&pmf Ref of arity 5 to arity 1

template<class Function> class std_bndr_const_obj_2_3_4_5 : 
                public std_arity1opmf_const<Function>, 
                private std_arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type> {
public:
    explicit inline std_bndr_const_obj_2_3_4_5(const Function::object_type& oi, const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline std_bndr_const_obj_2_3_4_5(const std_bndr_const_obj_2_3_4_5& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val, arg5val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
};

template<class Function> class std_bndr_const_obj_1_3_4_5 : 
                public std_arity1opmf_const<Function>, 
                private std_arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type> {
public:
    explicit inline std_bndr_const_obj_1_3_4_5(const Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5) {}
    inline std_bndr_const_obj_1_3_4_5(const std_bndr_const_obj_1_3_4_5& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val, arg5val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
};

template<class Function> class std_bndr_const_obj_1_2_4_5 : 
                public std_arity1opmf_const<Function>, 
                private std_arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type> {
public:
    explicit inline std_bndr_const_obj_1_2_4_5(const Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4, Function::argument_5_type a5) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5) {}
    inline std_bndr_const_obj_1_2_4_5(const std_bndr_const_obj_1_2_4_5& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity5_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val) {}
    inline Function::result_type operator()(Function::argument_3_type a3) const {
        pmf5type pmf = reinterpret_cast<pmf5type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val, arg5val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
};



// Template Functions for binding arity 5 to arity 1


// Template Functions for binding pmf  of arity 5 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4, 
                class A5> inline std_bndr_mf_2_3_4_5<Function>
            std_bind_mf_2_3_4_5(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return std_bndr_mf_2_3_4_5<Function>(f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5));
};

template<class Function, class A1, 
                class A3, 
                class A4, 
                class A5> inline std_bndr_mf_1_3_4_5<Function>
            std_bind_mf_1_3_4_5(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return std_bndr_mf_1_3_4_5<Function>(f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5));
};

template<class Function, class A1, 
                class A2, 
                class A4, 
                class A5> inline std_bndr_mf_1_2_4_5<Function>
            std_bind_mf_1_2_4_5(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5) {
                return std_bndr_mf_1_2_4_5<Function>(f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4), Function::argument_5_type(a5));
};



// Template Functions for binding const pmf  of arity 5 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4, 
                class A5> inline std_bndr_const_mf_2_3_4_5<Function>
            std_bind_const_mf_2_3_4_5(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return std_bndr_const_mf_2_3_4_5<Function>(f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5));
};

template<class Function, class A1, 
                class A3, 
                class A4, 
                class A5> inline std_bndr_const_mf_1_3_4_5<Function>
            std_bind_const_mf_1_3_4_5(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return std_bndr_const_mf_1_3_4_5<Function>(f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5));
};

template<class Function, class A1, 
                class A2, 
                class A4, 
                class A5> inline std_bndr_const_mf_1_2_4_5<Function>
            std_bind_const_mf_1_2_4_5(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5) {
                return std_bndr_const_mf_1_2_4_5<Function>(f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4), Function::argument_5_type(a5));
};



// Template Functions for binding obj&pmf Ref of arity 5 to arity 1

template<class Function, class Object, 
                class A2, 
                class A3, 
                class A4, 
                class A5> inline std_bndr_obj_2_3_4_5<Function>
            std_bind_obj_2_3_4_5(Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return std_bndr_obj_2_3_4_5<Function>(static_cast<Function::object_type&>(oi), f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5));
};

template<class Function, class Object, 
                class A1, 
                class A3, 
                class A4, 
                class A5> inline std_bndr_obj_1_3_4_5<Function>
            std_bind_obj_1_3_4_5(Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return std_bndr_obj_1_3_4_5<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5));
};

template<class Function, class Object, 
                class A1, 
                class A2, 
                class A4, 
                class A5> inline std_bndr_obj_1_2_4_5<Function>
            std_bind_obj_1_2_4_5(Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5) {
                return std_bndr_obj_1_2_4_5<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4), Function::argument_5_type(a5));
};



// Template Functions for binding const obj&pmf Ref of arity 5 to arity 1

template<class Function, const class Object, 
                class A2, 
                class A3, 
                class A4, 
                class A5> inline std_bndr_const_obj_2_3_4_5<Function>
            std_bind_const_obj_2_3_4_5(const Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return std_bndr_const_obj_2_3_4_5<Function>(static_cast<Function::object_type&>(oi), f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5));
};

template<class Function, const class Object, 
                class A1, 
                class A3, 
                class A4, 
                class A5> inline std_bndr_const_obj_1_3_4_5<Function>
            std_bind_const_obj_1_3_4_5(const Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5) {
                return std_bndr_const_obj_1_3_4_5<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5));
};

template<class Function, const class Object, 
                class A1, 
                class A2, 
                class A4, 
                class A5> inline std_bndr_const_obj_1_2_4_5<Function>
            std_bind_const_obj_1_2_4_5(const Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5) {
                return std_bndr_const_obj_1_2_4_5<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4), Function::argument_5_type(a5));
};



//
// binders for arity 6
//


// Template Classes for binding arity 6 to arity 1


// Template Classes for binding pmf  of arity 6 to arity 1

template<class Function> class std_bndr_mf_2_3_4_5_6 : 
                public std_arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>, 
                private std_arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type> {
public:
    explicit inline std_bndr_mf_2_3_4_5_6(const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6) : 
        std_arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline std_bndr_mf_2_3_4_5_6(const std_bndr_mf_2_3_4_5_6& bndri) : 
        std_arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::first_argument_type a1) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val, arg5val, arg6val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
};

template<class Function> class std_bndr_mf_1_3_4_5_6 : 
                public std_arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>, 
                private std_arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type> {
public:
    explicit inline std_bndr_mf_1_3_4_5_6(const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6) : 
        std_arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline std_bndr_mf_1_3_4_5_6(const std_bndr_mf_1_3_4_5_6& bndri) : 
        std_arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::second_argument_type a2) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val, arg5val, arg6val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
};

template<class Function> class std_bndr_mf_1_2_4_5_6 : 
                public std_arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>, 
                private std_arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type> {
public:
    explicit inline std_bndr_mf_1_2_4_5_6(const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6) : 
        std_arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline std_bndr_mf_1_2_4_5_6(const std_bndr_mf_1_2_4_5_6& bndri) : 
        std_arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::argument_3_type a3) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val, arg5val, arg6val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
};



// Template Classes for binding const pmf  of arity 6 to arity 1

template<class Function> class std_bndr_const_mf_2_3_4_5_6 : 
                public std_arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>, 
                private std_arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type> {
public:
    explicit inline std_bndr_const_mf_2_3_4_5_6(const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6) : 
        std_arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline std_bndr_const_mf_2_3_4_5_6(const std_bndr_const_mf_2_3_4_5_6& bndri) : 
        std_arity1pmf_const<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::first_argument_type a1) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val, arg5val, arg6val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
};

template<class Function> class std_bndr_const_mf_1_3_4_5_6 : 
                public std_arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>, 
                private std_arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type> {
public:
    explicit inline std_bndr_const_mf_1_3_4_5_6(const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6) : 
        std_arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline std_bndr_const_mf_1_3_4_5_6(const std_bndr_const_mf_1_3_4_5_6& bndri) : 
        std_arity1pmf_const<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::second_argument_type a2) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val, arg5val, arg6val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
};

template<class Function> class std_bndr_const_mf_1_2_4_5_6 : 
                public std_arity1pmf_const<Function::object_type, Function::argument_3_type, Function::result_type>, 
                private std_arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type> {
public:
    explicit inline std_bndr_const_mf_1_2_4_5_6(const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6) : 
        std_arity1pmf_const<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline std_bndr_const_mf_1_2_4_5_6(const std_bndr_const_mf_1_2_4_5_6& bndri) : 
        std_arity1pmf_const<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::argument_3_type a3) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val, arg5val, arg6val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
};



// Template Classes for binding obj&pmf Ref of arity 6 to arity 1

template<class Function> class std_bndr_obj_2_3_4_5_6 : 
                public std_arity1opmf<Function>, 
                private std_arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type> {
public:
    explicit inline std_bndr_obj_2_3_4_5_6(Function::object_type& oi, const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline std_bndr_obj_2_3_4_5_6(const std_bndr_obj_2_3_4_5_6& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val, arg5val, arg6val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
};

template<class Function> class std_bndr_obj_1_3_4_5_6 : 
                public std_arity1opmf<Function>, 
                private std_arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type> {
public:
    explicit inline std_bndr_obj_1_3_4_5_6(Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline std_bndr_obj_1_3_4_5_6(const std_bndr_obj_1_3_4_5_6& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val, arg5val, arg6val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
};

template<class Function> class std_bndr_obj_1_2_4_5_6 : 
                public std_arity1opmf<Function>, 
                private std_arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type> {
public:
    explicit inline std_bndr_obj_1_2_4_5_6(Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline std_bndr_obj_1_2_4_5_6(const std_bndr_obj_1_2_4_5_6& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity6_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline Function::result_type operator()(Function::argument_3_type a3) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val, arg5val, arg6val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
};



// Template Classes for binding const obj&pmf Ref of arity 6 to arity 1

template<class Function> class std_bndr_const_obj_2_3_4_5_6 : 
                public std_arity1opmf_const<Function>, 
                private std_arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type> {
public:
    explicit inline std_bndr_const_obj_2_3_4_5_6(const Function::object_type& oi, const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline std_bndr_const_obj_2_3_4_5_6(const std_bndr_const_obj_2_3_4_5_6& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val, arg5val, arg6val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
};

template<class Function> class std_bndr_const_obj_1_3_4_5_6 : 
                public std_arity1opmf_const<Function>, 
                private std_arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type> {
public:
    explicit inline std_bndr_const_obj_1_3_4_5_6(const Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline std_bndr_const_obj_1_3_4_5_6(const std_bndr_const_obj_1_3_4_5_6& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val, arg5val, arg6val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
};

template<class Function> class std_bndr_const_obj_1_2_4_5_6 : 
                public std_arity1opmf_const<Function>, 
                private std_arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type> {
public:
    explicit inline std_bndr_const_obj_1_2_4_5_6(const Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6) : 
        std_arity1opmf_const<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5), arg6val(a6) {}
    inline std_bndr_const_obj_1_2_4_5_6(const std_bndr_const_obj_1_2_4_5_6& bndri) : 
        std_arity1opmf_const<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity6_const_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val) {}
    inline Function::result_type operator()(Function::argument_3_type a3) const {
        pmf6type pmf = reinterpret_cast<pmf6type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val, arg5val, arg6val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
};



// Template Functions for binding arity 6 to arity 1


// Template Functions for binding pmf  of arity 6 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline std_bndr_mf_2_3_4_5_6<Function>
            std_bind_mf_2_3_4_5_6(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return std_bndr_mf_2_3_4_5_6<Function>(f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6));
};

template<class Function, class A1, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline std_bndr_mf_1_3_4_5_6<Function>
            std_bind_mf_1_3_4_5_6(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return std_bndr_mf_1_3_4_5_6<Function>(f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6));
};

template<class Function, class A1, 
                class A2, 
                class A4, 
                class A5, 
                class A6> inline std_bndr_mf_1_2_4_5_6<Function>
            std_bind_mf_1_2_4_5_6(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return std_bndr_mf_1_2_4_5_6<Function>(f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6));
};



// Template Functions for binding const pmf  of arity 6 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline std_bndr_const_mf_2_3_4_5_6<Function>
            std_bind_const_mf_2_3_4_5_6(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return std_bndr_const_mf_2_3_4_5_6<Function>(f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6));
};

template<class Function, class A1, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline std_bndr_const_mf_1_3_4_5_6<Function>
            std_bind_const_mf_1_3_4_5_6(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return std_bndr_const_mf_1_3_4_5_6<Function>(f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6));
};

template<class Function, class A1, 
                class A2, 
                class A4, 
                class A5, 
                class A6> inline std_bndr_const_mf_1_2_4_5_6<Function>
            std_bind_const_mf_1_2_4_5_6(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return std_bndr_const_mf_1_2_4_5_6<Function>(f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6));
};



// Template Functions for binding obj&pmf Ref of arity 6 to arity 1

template<class Function, class Object, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline std_bndr_obj_2_3_4_5_6<Function>
            std_bind_obj_2_3_4_5_6(Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return std_bndr_obj_2_3_4_5_6<Function>(static_cast<Function::object_type&>(oi), f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6));
};

template<class Function, class Object, 
                class A1, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline std_bndr_obj_1_3_4_5_6<Function>
            std_bind_obj_1_3_4_5_6(Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return std_bndr_obj_1_3_4_5_6<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6));
};

template<class Function, class Object, 
                class A1, 
                class A2, 
                class A4, 
                class A5, 
                class A6> inline std_bndr_obj_1_2_4_5_6<Function>
            std_bind_obj_1_2_4_5_6(Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return std_bndr_obj_1_2_4_5_6<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6));
};



// Template Functions for binding const obj&pmf Ref of arity 6 to arity 1

template<class Function, const class Object, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline std_bndr_const_obj_2_3_4_5_6<Function>
            std_bind_const_obj_2_3_4_5_6(const Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return std_bndr_const_obj_2_3_4_5_6<Function>(static_cast<Function::object_type&>(oi), f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6));
};

template<class Function, const class Object, 
                class A1, 
                class A3, 
                class A4, 
                class A5, 
                class A6> inline std_bndr_const_obj_1_3_4_5_6<Function>
            std_bind_const_obj_1_3_4_5_6(const Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return std_bndr_const_obj_1_3_4_5_6<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6));
};

template<class Function, const class Object, 
                class A1, 
                class A2, 
                class A4, 
                class A5, 
                class A6> inline std_bndr_const_obj_1_2_4_5_6<Function>
            std_bind_const_obj_1_2_4_5_6(const Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6) {
                return std_bndr_const_obj_1_2_4_5_6<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6));
};



// Template Classes for binding arity 15 to 1


// Template Classes for binding pmf  of arity 15 to arity 1

template<class Function> class std_bndr_mf_2_3_4_5_6_7_8_9_10_11_12_13_14_15 : 
                public std_arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>, 
                private std_arity15_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, 
                                Function::argument_7_type, 
                                Function::argument_8_type, 
                                Function::argument_9_type, 
                                Function::argument_10_type, 
                                Function::argument_11_type, 
                                Function::argument_12_type, 
                                Function::argument_13_type, 
                                Function::argument_14_type, 
                                Function::argument_15_type, Function::result_type> {
public:
    explicit inline std_bndr_mf_2_3_4_5_6_7_8_9_10_11_12_13_14_15(const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6, Function::argument_7_type a7, Function::argument_8_type a8, Function::argument_9_type a9, Function::argument_10_type a10, Function::argument_11_type a11, Function::argument_12_type a12, Function::argument_13_type a13, Function::argument_14_type a14, Function::argument_15_type a15) : 
        std_arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity15_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, 
                                Function::argument_7_type, 
                                Function::argument_8_type, 
                                Function::argument_9_type, 
                                Function::argument_10_type, 
                                Function::argument_11_type, 
                                Function::argument_12_type, 
                                Function::argument_13_type, 
                                Function::argument_14_type, 
                                Function::argument_15_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6), arg7val(a7), arg8val(a8), arg9val(a9), arg10val(a10), arg11val(a11), arg12val(a12), arg13val(a13), arg14val(a14), arg15val(a15) {}
    inline std_bndr_mf_2_3_4_5_6_7_8_9_10_11_12_13_14_15(const std_bndr_mf_2_3_4_5_6_7_8_9_10_11_12_13_14_15& bndri) : 
        std_arity1pmf<Function::object_type, Function::first_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity15_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, 
                                Function::argument_7_type, 
                                Function::argument_8_type, 
                                Function::argument_9_type, 
                                Function::argument_10_type, 
                                Function::argument_11_type, 
                                Function::argument_12_type, 
                                Function::argument_13_type, 
                                Function::argument_14_type, 
                                Function::argument_15_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val), arg7val(bndri.arg7val), arg8val(bndri.arg8val), arg9val(bndri.arg9val), arg10val(bndri.arg10val), arg11val(bndri.arg11val), arg12val(bndri.arg12val), arg13val(bndri.arg13val), arg14val(bndri.arg14val), arg15val(bndri.arg15val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::first_argument_type a1) const {
        pmf15type pmf = reinterpret_cast<pmf15type>(pmf0);
        return (o.*pmf)(a1, arg2val, arg3val, arg4val, arg5val, arg6val, arg7val, arg8val, arg9val, arg10val, arg11val, arg12val, arg13val, arg14val, arg15val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
    Function::argument_7_type arg7val;
    Function::argument_8_type arg8val;
    Function::argument_9_type arg9val;
    Function::argument_10_type arg10val;
    Function::argument_11_type arg11val;
    Function::argument_12_type arg12val;
    Function::argument_13_type arg13val;
    Function::argument_14_type arg14val;
    Function::argument_15_type arg15val;
};

template<class Function> class std_bndr_mf_1_3_4_5_6_7_8_9_10_11_12_13_14_15 : 
                public std_arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>, 
                private std_arity15_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, 
                                Function::argument_7_type, 
                                Function::argument_8_type, 
                                Function::argument_9_type, 
                                Function::argument_10_type, 
                                Function::argument_11_type, 
                                Function::argument_12_type, 
                                Function::argument_13_type, 
                                Function::argument_14_type, 
                                Function::argument_15_type, Function::result_type> {
public:
    explicit inline std_bndr_mf_1_3_4_5_6_7_8_9_10_11_12_13_14_15(const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6, Function::argument_7_type a7, Function::argument_8_type a8, Function::argument_9_type a9, Function::argument_10_type a10, Function::argument_11_type a11, Function::argument_12_type a12, Function::argument_13_type a13, Function::argument_14_type a14, Function::argument_15_type a15) : 
        std_arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity15_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, 
                                Function::argument_7_type, 
                                Function::argument_8_type, 
                                Function::argument_9_type, 
                                Function::argument_10_type, 
                                Function::argument_11_type, 
                                Function::argument_12_type, 
                                Function::argument_13_type, 
                                Function::argument_14_type, 
                                Function::argument_15_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6), arg7val(a7), arg8val(a8), arg9val(a9), arg10val(a10), arg11val(a11), arg12val(a12), arg13val(a13), arg14val(a14), arg15val(a15) {}
    inline std_bndr_mf_1_3_4_5_6_7_8_9_10_11_12_13_14_15(const std_bndr_mf_1_3_4_5_6_7_8_9_10_11_12_13_14_15& bndri) : 
        std_arity1pmf<Function::object_type, Function::second_argument_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity15_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, 
                                Function::argument_7_type, 
                                Function::argument_8_type, 
                                Function::argument_9_type, 
                                Function::argument_10_type, 
                                Function::argument_11_type, 
                                Function::argument_12_type, 
                                Function::argument_13_type, 
                                Function::argument_14_type, 
                                Function::argument_15_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val), arg7val(bndri.arg7val), arg8val(bndri.arg8val), arg9val(bndri.arg9val), arg10val(bndri.arg10val), arg11val(bndri.arg11val), arg12val(bndri.arg12val), arg13val(bndri.arg13val), arg14val(bndri.arg14val), arg15val(bndri.arg15val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::second_argument_type a2) const {
        pmf15type pmf = reinterpret_cast<pmf15type>(pmf0);
        return (o.*pmf)(arg1val, a2, arg3val, arg4val, arg5val, arg6val, arg7val, arg8val, arg9val, arg10val, arg11val, arg12val, arg13val, arg14val, arg15val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
    Function::argument_7_type arg7val;
    Function::argument_8_type arg8val;
    Function::argument_9_type arg9val;
    Function::argument_10_type arg10val;
    Function::argument_11_type arg11val;
    Function::argument_12_type arg12val;
    Function::argument_13_type arg13val;
    Function::argument_14_type arg14val;
    Function::argument_15_type arg15val;
};

template<class Function> class std_bndr_mf_1_2_4_5_6_7_8_9_10_11_12_13_14_15 : 
                public std_arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>, 
                private std_arity15_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, 
                                Function::argument_7_type, 
                                Function::argument_8_type, 
                                Function::argument_9_type, 
                                Function::argument_10_type, 
                                Function::argument_11_type, 
                                Function::argument_12_type, 
                                Function::argument_13_type, 
                                Function::argument_14_type, 
                                Function::argument_15_type, Function::result_type> {
public:
    explicit inline std_bndr_mf_1_2_4_5_6_7_8_9_10_11_12_13_14_15(const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6, Function::argument_7_type a7, Function::argument_8_type a8, Function::argument_9_type a9, Function::argument_10_type a10, Function::argument_11_type a11, Function::argument_12_type a12, Function::argument_13_type a13, Function::argument_14_type a14, Function::argument_15_type a15) : 
        std_arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(f.pmf0)), std_arity15_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, 
                                Function::argument_7_type, 
                                Function::argument_8_type, 
                                Function::argument_9_type, 
                                Function::argument_10_type, 
                                Function::argument_11_type, 
                                Function::argument_12_type, 
                                Function::argument_13_type, 
                                Function::argument_14_type, 
                                Function::argument_15_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5), arg6val(a6), arg7val(a7), arg8val(a8), arg9val(a9), arg10val(a10), arg11val(a11), arg12val(a12), arg13val(a13), arg14val(a14), arg15val(a15) {}
    inline std_bndr_mf_1_2_4_5_6_7_8_9_10_11_12_13_14_15(const std_bndr_mf_1_2_4_5_6_7_8_9_10_11_12_13_14_15& bndri) : 
        std_arity1pmf<Function::object_type, Function::argument_3_type, Function::result_type>(reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity15_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, 
                                Function::argument_7_type, 
                                Function::argument_8_type, 
                                Function::argument_9_type, 
                                Function::argument_10_type, 
                                Function::argument_11_type, 
                                Function::argument_12_type, 
                                Function::argument_13_type, 
                                Function::argument_14_type, 
                                Function::argument_15_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val), arg7val(bndri.arg7val), arg8val(bndri.arg8val), arg9val(bndri.arg9val), arg10val(bndri.arg10val), arg11val(bndri.arg11val), arg12val(bndri.arg12val), arg13val(bndri.arg13val), arg14val(bndri.arg14val), arg15val(bndri.arg15val) {}
    inline virtual Function::result_type operator()(Function::object_type& o, Function::argument_3_type a3) const {
        pmf15type pmf = reinterpret_cast<pmf15type>(pmf0);
        return (o.*pmf)(arg1val, arg2val, a3, arg4val, arg5val, arg6val, arg7val, arg8val, arg9val, arg10val, arg11val, arg12val, arg13val, arg14val, arg15val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
    Function::argument_7_type arg7val;
    Function::argument_8_type arg8val;
    Function::argument_9_type arg9val;
    Function::argument_10_type arg10val;
    Function::argument_11_type arg11val;
    Function::argument_12_type arg12val;
    Function::argument_13_type arg13val;
    Function::argument_14_type arg14val;
    Function::argument_15_type arg15val;
};



// Template Classes for binding obj&pmf Ref of arity 15 to arity 1

template<class Function> class std_bndr_obj_2_3_4_5_6_7_8_9_10_11_12_13_14_15 : 
                public std_arity1opmf<Function>, 
                private std_arity15_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, 
                                Function::argument_7_type, 
                                Function::argument_8_type, 
                                Function::argument_9_type, 
                                Function::argument_10_type, 
                                Function::argument_11_type, 
                                Function::argument_12_type, 
                                Function::argument_13_type, 
                                Function::argument_14_type, 
                                Function::argument_15_type, Function::result_type> {
public:
    explicit inline std_bndr_obj_2_3_4_5_6_7_8_9_10_11_12_13_14_15(Function::object_type& oi, const Function &f, Function::second_argument_type a2, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6, Function::argument_7_type a7, Function::argument_8_type a8, Function::argument_9_type a9, Function::argument_10_type a10, Function::argument_11_type a11, Function::argument_12_type a12, Function::argument_13_type a13, Function::argument_14_type a14, Function::argument_15_type a15) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity15_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, 
                                Function::argument_7_type, 
                                Function::argument_8_type, 
                                Function::argument_9_type, 
                                Function::argument_10_type, 
                                Function::argument_11_type, 
                                Function::argument_12_type, 
                                Function::argument_13_type, 
                                Function::argument_14_type, 
                                Function::argument_15_type, Function::result_type>(f), arg2val(a2), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6), arg7val(a7), arg8val(a8), arg9val(a9), arg10val(a10), arg11val(a11), arg12val(a12), arg13val(a13), arg14val(a14), arg15val(a15) {}
    inline std_bndr_obj_2_3_4_5_6_7_8_9_10_11_12_13_14_15(const std_bndr_obj_2_3_4_5_6_7_8_9_10_11_12_13_14_15& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity15_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, 
                                Function::argument_7_type, 
                                Function::argument_8_type, 
                                Function::argument_9_type, 
                                Function::argument_10_type, 
                                Function::argument_11_type, 
                                Function::argument_12_type, 
                                Function::argument_13_type, 
                                Function::argument_14_type, 
                                Function::argument_15_type, Function::result_type>(bndri), arg2val(bndri.arg2val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val), arg7val(bndri.arg7val), arg8val(bndri.arg8val), arg9val(bndri.arg9val), arg10val(bndri.arg10val), arg11val(bndri.arg11val), arg12val(bndri.arg12val), arg13val(bndri.arg13val), arg14val(bndri.arg14val), arg15val(bndri.arg15val) {}
    inline Function::result_type operator()(Function::first_argument_type a1) const {
        pmf15type pmf = reinterpret_cast<pmf15type>(pmf0);
        return (objval.*pmf)(a1, arg2val, arg3val, arg4val, arg5val, arg6val, arg7val, arg8val, arg9val, arg10val, arg11val, arg12val, arg13val, arg14val, arg15val);
    }
public:
    Function::second_argument_type arg2val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
    Function::argument_7_type arg7val;
    Function::argument_8_type arg8val;
    Function::argument_9_type arg9val;
    Function::argument_10_type arg10val;
    Function::argument_11_type arg11val;
    Function::argument_12_type arg12val;
    Function::argument_13_type arg13val;
    Function::argument_14_type arg14val;
    Function::argument_15_type arg15val;
};

template<class Function> class std_bndr_obj_1_3_4_5_6_7_8_9_10_11_12_13_14_15 : 
                public std_arity1opmf<Function>, 
                private std_arity15_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, 
                                Function::argument_7_type, 
                                Function::argument_8_type, 
                                Function::argument_9_type, 
                                Function::argument_10_type, 
                                Function::argument_11_type, 
                                Function::argument_12_type, 
                                Function::argument_13_type, 
                                Function::argument_14_type, 
                                Function::argument_15_type, Function::result_type> {
public:
    explicit inline std_bndr_obj_1_3_4_5_6_7_8_9_10_11_12_13_14_15(Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::argument_3_type a3, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6, Function::argument_7_type a7, Function::argument_8_type a8, Function::argument_9_type a9, Function::argument_10_type a10, Function::argument_11_type a11, Function::argument_12_type a12, Function::argument_13_type a13, Function::argument_14_type a14, Function::argument_15_type a15) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity15_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, 
                                Function::argument_7_type, 
                                Function::argument_8_type, 
                                Function::argument_9_type, 
                                Function::argument_10_type, 
                                Function::argument_11_type, 
                                Function::argument_12_type, 
                                Function::argument_13_type, 
                                Function::argument_14_type, 
                                Function::argument_15_type, Function::result_type>(f), arg1val(a1), arg3val(a3), arg4val(a4), arg5val(a5), arg6val(a6), arg7val(a7), arg8val(a8), arg9val(a9), arg10val(a10), arg11val(a11), arg12val(a12), arg13val(a13), arg14val(a14), arg15val(a15) {}
    inline std_bndr_obj_1_3_4_5_6_7_8_9_10_11_12_13_14_15(const std_bndr_obj_1_3_4_5_6_7_8_9_10_11_12_13_14_15& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity15_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, 
                                Function::argument_7_type, 
                                Function::argument_8_type, 
                                Function::argument_9_type, 
                                Function::argument_10_type, 
                                Function::argument_11_type, 
                                Function::argument_12_type, 
                                Function::argument_13_type, 
                                Function::argument_14_type, 
                                Function::argument_15_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg3val(bndri.arg3val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val), arg7val(bndri.arg7val), arg8val(bndri.arg8val), arg9val(bndri.arg9val), arg10val(bndri.arg10val), arg11val(bndri.arg11val), arg12val(bndri.arg12val), arg13val(bndri.arg13val), arg14val(bndri.arg14val), arg15val(bndri.arg15val) {}
    inline Function::result_type operator()(Function::second_argument_type a2) const {
        pmf15type pmf = reinterpret_cast<pmf15type>(pmf0);
        return (objval.*pmf)(arg1val, a2, arg3val, arg4val, arg5val, arg6val, arg7val, arg8val, arg9val, arg10val, arg11val, arg12val, arg13val, arg14val, arg15val);
    }
public:
    Function::first_argument_type arg1val;
    Function::argument_3_type arg3val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
    Function::argument_7_type arg7val;
    Function::argument_8_type arg8val;
    Function::argument_9_type arg9val;
    Function::argument_10_type arg10val;
    Function::argument_11_type arg11val;
    Function::argument_12_type arg12val;
    Function::argument_13_type arg13val;
    Function::argument_14_type arg14val;
    Function::argument_15_type arg15val;
};

template<class Function> class std_bndr_obj_1_2_4_5_6_7_8_9_10_11_12_13_14_15 : 
                public std_arity1opmf<Function>, 
                private std_arity15_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, 
                                Function::argument_7_type, 
                                Function::argument_8_type, 
                                Function::argument_9_type, 
                                Function::argument_10_type, 
                                Function::argument_11_type, 
                                Function::argument_12_type, 
                                Function::argument_13_type, 
                                Function::argument_14_type, 
                                Function::argument_15_type, Function::result_type> {
public:
    explicit inline std_bndr_obj_1_2_4_5_6_7_8_9_10_11_12_13_14_15(Function::object_type& oi, const Function &f, Function::first_argument_type a1, Function::second_argument_type a2, Function::argument_4_type a4, Function::argument_5_type a5, Function::argument_6_type a6, Function::argument_7_type a7, Function::argument_8_type a8, Function::argument_9_type a9, Function::argument_10_type a10, Function::argument_11_type a11, Function::argument_12_type a12, Function::argument_13_type a13, Function::argument_14_type a14, Function::argument_15_type a15) : 
        std_arity1opmf<Function>(oi, reinterpret_cast<pmf1type>(f.pmf0)), std_arity15_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, 
                                Function::argument_7_type, 
                                Function::argument_8_type, 
                                Function::argument_9_type, 
                                Function::argument_10_type, 
                                Function::argument_11_type, 
                                Function::argument_12_type, 
                                Function::argument_13_type, 
                                Function::argument_14_type, 
                                Function::argument_15_type, Function::result_type>(f), arg1val(a1), arg2val(a2), arg4val(a4), arg5val(a5), arg6val(a6), arg7val(a7), arg8val(a8), arg9val(a9), arg10val(a10), arg11val(a11), arg12val(a12), arg13val(a13), arg14val(a14), arg15val(a15) {}
    inline std_bndr_obj_1_2_4_5_6_7_8_9_10_11_12_13_14_15(const std_bndr_obj_1_2_4_5_6_7_8_9_10_11_12_13_14_15& bndri) : 
        std_arity1opmf<Function>(bndri.objval, reinterpret_cast<pmf1type>(bndri.pmf0)), std_arity15_mf<Function::object_type, Function::first_argument_type, 
                                Function::second_argument_type, 
                                Function::argument_3_type, 
                                Function::argument_4_type, 
                                Function::argument_5_type, 
                                Function::argument_6_type, 
                                Function::argument_7_type, 
                                Function::argument_8_type, 
                                Function::argument_9_type, 
                                Function::argument_10_type, 
                                Function::argument_11_type, 
                                Function::argument_12_type, 
                                Function::argument_13_type, 
                                Function::argument_14_type, 
                                Function::argument_15_type, Function::result_type>(bndri), arg1val(bndri.arg1val), arg2val(bndri.arg2val), arg4val(bndri.arg4val), arg5val(bndri.arg5val), arg6val(bndri.arg6val), arg7val(bndri.arg7val), arg8val(bndri.arg8val), arg9val(bndri.arg9val), arg10val(bndri.arg10val), arg11val(bndri.arg11val), arg12val(bndri.arg12val), arg13val(bndri.arg13val), arg14val(bndri.arg14val), arg15val(bndri.arg15val) {}
    inline Function::result_type operator()(Function::argument_3_type a3) const {
        pmf15type pmf = reinterpret_cast<pmf15type>(pmf0);
        return (objval.*pmf)(arg1val, arg2val, a3, arg4val, arg5val, arg6val, arg7val, arg8val, arg9val, arg10val, arg11val, arg12val, arg13val, arg14val, arg15val);
    }
public:
    Function::first_argument_type arg1val;
    Function::second_argument_type arg2val;
    Function::argument_4_type arg4val;
    Function::argument_5_type arg5val;
    Function::argument_6_type arg6val;
    Function::argument_7_type arg7val;
    Function::argument_8_type arg8val;
    Function::argument_9_type arg9val;
    Function::argument_10_type arg10val;
    Function::argument_11_type arg11val;
    Function::argument_12_type arg12val;
    Function::argument_13_type arg13val;
    Function::argument_14_type arg14val;
    Function::argument_15_type arg15val;
};



// Template Functions for binding arity 15 to 1


// Template Functions for binding pmf  of arity 15 to arity 1

template<class Function, class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6, 
                class A7, 
                class A8, 
                class A9, 
                class A10, 
                class A11, 
                class A12, 
                class A13, 
                class A14, 
                class A15> inline std_bndr_mf_2_3_4_5_6_7_8_9_10_11_12_13_14_15<Function>
            std_bind_mf_2_3_4_5_6_7_8_9_10_11_12_13_14_15(const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6, 
                                A7 a7, 
                                A8 a8, 
                                A9 a9, 
                                A10 a10, 
                                A11 a11, 
                                A12 a12, 
                                A13 a13, 
                                A14 a14, 
                                A15 a15) {
                return std_bndr_mf_2_3_4_5_6_7_8_9_10_11_12_13_14_15<Function>(f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6), Function::argument_7_type(a7), Function::argument_8_type(a8), Function::argument_9_type(a9), Function::argument_10_type(a10), Function::argument_11_type(a11), Function::argument_12_type(a12), Function::argument_13_type(a13), Function::argument_14_type(a14), Function::argument_15_type(a15));
};

template<class Function, class A1, 
                class A3, 
                class A4, 
                class A5, 
                class A6, 
                class A7, 
                class A8, 
                class A9, 
                class A10, 
                class A11, 
                class A12, 
                class A13, 
                class A14, 
                class A15> inline std_bndr_mf_1_3_4_5_6_7_8_9_10_11_12_13_14_15<Function>
            std_bind_mf_1_3_4_5_6_7_8_9_10_11_12_13_14_15(const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6, 
                                A7 a7, 
                                A8 a8, 
                                A9 a9, 
                                A10 a10, 
                                A11 a11, 
                                A12 a12, 
                                A13 a13, 
                                A14 a14, 
                                A15 a15) {
                return std_bndr_mf_1_3_4_5_6_7_8_9_10_11_12_13_14_15<Function>(f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6), Function::argument_7_type(a7), Function::argument_8_type(a8), Function::argument_9_type(a9), Function::argument_10_type(a10), Function::argument_11_type(a11), Function::argument_12_type(a12), Function::argument_13_type(a13), Function::argument_14_type(a14), Function::argument_15_type(a15));
};

template<class Function, class A1, 
                class A2, 
                class A4, 
                class A5, 
                class A6, 
                class A7, 
                class A8, 
                class A9, 
                class A10, 
                class A11, 
                class A12, 
                class A13, 
                class A14, 
                class A15> inline std_bndr_mf_1_2_4_5_6_7_8_9_10_11_12_13_14_15<Function>
            std_bind_mf_1_2_4_5_6_7_8_9_10_11_12_13_14_15(const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6, 
                                A7 a7, 
                                A8 a8, 
                                A9 a9, 
                                A10 a10, 
                                A11 a11, 
                                A12 a12, 
                                A13 a13, 
                                A14 a14, 
                                A15 a15) {
                return std_bndr_mf_1_2_4_5_6_7_8_9_10_11_12_13_14_15<Function>(f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6), Function::argument_7_type(a7), Function::argument_8_type(a8), Function::argument_9_type(a9), Function::argument_10_type(a10), Function::argument_11_type(a11), Function::argument_12_type(a12), Function::argument_13_type(a13), Function::argument_14_type(a14), Function::argument_15_type(a15));
};



// Template Functions for binding obj&pmf Ref of arity 15 to arity 1

template<class Function, class Object, 
                class A2, 
                class A3, 
                class A4, 
                class A5, 
                class A6, 
                class A7, 
                class A8, 
                class A9, 
                class A10, 
                class A11, 
                class A12, 
                class A13, 
                class A14, 
                class A15> inline std_bndr_obj_2_3_4_5_6_7_8_9_10_11_12_13_14_15<Function>
            std_bind_obj_2_3_4_5_6_7_8_9_10_11_12_13_14_15(Object& oi, const Function &f, A2 a2, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6, 
                                A7 a7, 
                                A8 a8, 
                                A9 a9, 
                                A10 a10, 
                                A11 a11, 
                                A12 a12, 
                                A13 a13, 
                                A14 a14, 
                                A15 a15) {
                return std_bndr_obj_2_3_4_5_6_7_8_9_10_11_12_13_14_15<Function>(static_cast<Function::object_type&>(oi), f, Function::second_argument_type(a2), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6), Function::argument_7_type(a7), Function::argument_8_type(a8), Function::argument_9_type(a9), Function::argument_10_type(a10), Function::argument_11_type(a11), Function::argument_12_type(a12), Function::argument_13_type(a13), Function::argument_14_type(a14), Function::argument_15_type(a15));
};

template<class Function, class Object, 
                class A1, 
                class A3, 
                class A4, 
                class A5, 
                class A6, 
                class A7, 
                class A8, 
                class A9, 
                class A10, 
                class A11, 
                class A12, 
                class A13, 
                class A14, 
                class A15> inline std_bndr_obj_1_3_4_5_6_7_8_9_10_11_12_13_14_15<Function>
            std_bind_obj_1_3_4_5_6_7_8_9_10_11_12_13_14_15(Object& oi, const Function &f, A1 a1, 
                                A3 a3, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6, 
                                A7 a7, 
                                A8 a8, 
                                A9 a9, 
                                A10 a10, 
                                A11 a11, 
                                A12 a12, 
                                A13 a13, 
                                A14 a14, 
                                A15 a15) {
                return std_bndr_obj_1_3_4_5_6_7_8_9_10_11_12_13_14_15<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::argument_3_type(a3), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6), Function::argument_7_type(a7), Function::argument_8_type(a8), Function::argument_9_type(a9), Function::argument_10_type(a10), Function::argument_11_type(a11), Function::argument_12_type(a12), Function::argument_13_type(a13), Function::argument_14_type(a14), Function::argument_15_type(a15));
};

template<class Function, class Object, 
                class A1, 
                class A2, 
                class A4, 
                class A5, 
                class A6, 
                class A7, 
                class A8, 
                class A9, 
                class A10, 
                class A11, 
                class A12, 
                class A13, 
                class A14, 
                class A15> inline std_bndr_obj_1_2_4_5_6_7_8_9_10_11_12_13_14_15<Function>
            std_bind_obj_1_2_4_5_6_7_8_9_10_11_12_13_14_15(Object& oi, const Function &f, A1 a1, 
                                A2 a2, 
                                A4 a4, 
                                A5 a5, 
                                A6 a6, 
                                A7 a7, 
                                A8 a8, 
                                A9 a9, 
                                A10 a10, 
                                A11 a11, 
                                A12 a12, 
                                A13 a13, 
                                A14 a14, 
                                A15 a15) {
                return std_bndr_obj_1_2_4_5_6_7_8_9_10_11_12_13_14_15<Function>(static_cast<Function::object_type&>(oi), f, Function::first_argument_type(a1), Function::second_argument_type(a2), Function::argument_4_type(a4), Function::argument_5_type(a5), Function::argument_6_type(a6), Function::argument_7_type(a7), Function::argument_8_type(a8), Function::argument_9_type(a9), Function::argument_10_type(a10), Function::argument_11_type(a11), Function::argument_12_type(a12), Function::argument_13_type(a13), Function::argument_14_type(a14), Function::argument_15_type(a15));
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\atsctsimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ATSCtsimpl.h : 
// Copyright (c) Microsoft Corporation 1999.

#ifndef ATSCTSIMPL_H
#define ATSCTSIMPL_H

#include "errsupp.h"
#include "analogtvtsimpl.h"
#include "ATSCChannelTuneRequest.h"

namespace BDATuningModel {

template<class T,
         class MostDerived = IATSCTuningSpace, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IATSCTSImpl : 
	public IAnalogTVTSImpl<T, CATSCChannelTuneRequest, MostDerived, iid, LibID, wMajor, wMinor, tihclass>,
    public IMPEG2TuneRequestSupport
{

public:
    IATSCTSImpl() : 
	    m_MinMinorChannel(-1), 
		m_MaxMinorChannel(-1),
	    m_MinPhysicalChannel(-1), 
		m_MaxPhysicalChannel(-1)
		{}
	virtual ~IATSCTSImpl() {}
    typedef IAnalogTVTSImpl<T, CATSCChannelTuneRequest, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    
    BEGIN_PROP_MAP(IATSCTSImpl)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("Min Minor Channel", m_MinMinorChannel, VT_I4)
        PROP_DATA_ENTRY("Max Minor Channel", m_MaxMinorChannel, VT_I4)
        PROP_DATA_ENTRY("Min Physical Channel", m_MinPhysicalChannel, VT_I4)
        PROP_DATA_ENTRY("Max Physical Channel", m_MaxPhysicalChannel, VT_I4)
    END_PROPERTY_MAP()

	long m_MinMinorChannel;
	long m_MaxMinorChannel;
	long m_MinPhysicalChannel;
	long m_MaxPhysicalChannel;

    // override standard ITuningSpaceImpl
    STDMETHOD(put_DefaultLocator)(ILocator *pLoc) {
        if (pLoc) {
            PQATSCLocator p(pLoc);
            if (!p) {
                return DISP_E_TYPEMISMATCH;
            }
        }
        return basetype::put_DefaultLocator(pLoc);
    }

    // IATSCTuningSpace
    STDMETHOD(get_MinMinorChannel)(long *pVal)
    {
        if (!pVal) {
            return E_POINTER;
        }
		ATL_LOCKT();
        *pVal = m_MinMinorChannel;

	    return NOERROR;
    }
    STDMETHOD(put_MinMinorChannel)(long newVal)
    {
		ATL_LOCKT();
		if (newVal > m_MaxMinorChannel) {
	 	    return ImplReportError(__uuidof(T), IDS_E_INVALIDARG, __uuidof(IATSCTuningSpace), E_INVALIDARG);
		}

        m_MinMinorChannel = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_MaxMinorChannel)(long *pVal)
    {
        if (!pVal) {
            return E_POINTER;
        }
		ATL_LOCKT();
        *pVal = m_MaxMinorChannel;

	    return NOERROR;
    }
    STDMETHOD(put_MaxMinorChannel)(long newVal)
    {
		ATL_LOCKT();
		if (newVal < m_MinMinorChannel) {
	 	    return ImplReportError(__uuidof(T), IDS_E_INVALIDARG, __uuidof(IATSCTuningSpace), E_INVALIDARG);
		}
        m_MaxMinorChannel = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_MinPhysicalChannel)(long *pVal)
    {
        if (!pVal) {
            return E_POINTER;
        }
		ATL_LOCKT();
        *pVal = m_MinPhysicalChannel;

	    return NOERROR;
    }
    STDMETHOD(put_MinPhysicalChannel)(long newVal)
    {
		ATL_LOCKT();
		if (newVal > m_MaxPhysicalChannel) {
	 	    return ImplReportError(__uuidof(T), IDS_E_INVALIDARG, __uuidof(IATSCTuningSpace), E_INVALIDARG);
		}
        m_MinPhysicalChannel = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_MaxPhysicalChannel)(long *pVal)
    {
        if (!pVal) {
            return E_POINTER;
        }
		ATL_LOCKT();
        *pVal = m_MaxPhysicalChannel;

	    return NOERROR;
    }
    STDMETHOD(put_MaxPhysicalChannel)(long newVal)
    {
		ATL_LOCKT();
		if (newVal < m_MinPhysicalChannel) {
	 	    return ImplReportError(__uuidof(T), IDS_E_INVALIDARG, __uuidof(IATSCTuningSpace), E_INVALIDARG);
		}
        m_MaxPhysicalChannel = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }

    STDMETHOD(Clone) (ITuningSpace **ppTS) {
		if (!ppTS) {
			return E_POINTER;
		}
        *ppTS = NULL;
		ATL_LOCKT();
        try {
			HRESULT hr = basetype::Clone(ppTS);
			if (FAILED(hr)) {
				return hr;
			}

			T* pt = static_cast<T*>(*ppTS);

            pt->m_MinMinorChannel = m_MinMinorChannel;
            pt->m_MaxMinorChannel = m_MaxMinorChannel;
            pt->m_MinPhysicalChannel = m_MinPhysicalChannel;
            pt->m_MaxPhysicalChannel = m_MaxPhysicalChannel;

			return NOERROR;
        } CATCHCOM_CLEANUP(if (*ppTS) {
                               (*ppTS)->Release();
                               *ppTS = NULL;
                           }
                          );
	}




};

}; // namespace

#endif // ATSCTSIMPL_H
// end of file -- ATSCtsimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\cc2impl.h ===
//==========================================================================;
//
// closedcaptioningimpl.h : additional infrastructure to support implementing IMSVidClosedCaptionings
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef CLOSEDCAPTIONINGIMPL2_H
#define CLOSEDCAPTIONINGIMPL2_H

#include "ccimpl.h"

namespace MSVideoControl {

template<class T, LPCGUID LibID, LPCGUID KSCategory, class MostDerivedInterface = IMSVidClosedCaptioning>
    class DECLSPEC_NOVTABLE IMSVidClosedCaptioningImpl2 : public IMSVidClosedCaptioningImpl<T, LibID, KSCategory, MostDerivedInterface> {
public:

    IMSVidClosedCaptioningImpl2() {}

    STDMETHOD(put_Service)(MSVidCCService ccServ) {
        return E_NOTIMPL;
    }
    STDMETHOD(get_Service)(MSVidCCService *ccServ) {
        if (!ccServ) {
            return E_POINTER;
        }
        return E_NOTIMPL;
    }
};

}; /// namespace

#endif
// end of file - closedcaptioningimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\ccimpl.h ===
//==========================================================================;
//
// closedcaptioningimpl.h : additional infrastructure to support implementing IMSVidClosedCaptionings
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef CLOSEDCAPTIONINGIMPL_H
#define CLOSEDCAPTIONINGIMPL_H

#include "featureimpl.h"

namespace MSVideoControl {

template<class T, LPCGUID LibID, LPCGUID KSCategory, class MostDerivedInterface = IMSVidClosedCaptioning>
    class DECLSPEC_NOVTABLE IMSVidClosedCaptioningImpl : public IMSVidFeatureImpl<T, LibID, KSCategory, MostDerivedInterface> {
public:

    IMSVidClosedCaptioningImpl() : m_fCCEnable(false) {}
    bool m_fCCEnable;

    STDMETHOD(put_Enable)(VARIANT_BOOL fEnable) {
        m_fCCEnable = (fEnable == VARIANT_TRUE);
		return NOERROR;
    }
    STDMETHOD(get_Enable)(VARIANT_BOOL *pfEnable) {
        if (!pfEnable) {
            return E_POINTER;
        }
        try {
            *pfEnable = m_fCCEnable ? VARIANT_TRUE : VARIANT_FALSE;
			return NOERROR;
        } catch(...) {
            return E_POINTER;
        }
	}
};

}; /// namespace

#endif
// end of file - closedcaptioningimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\bcasteventimpl.h ===
//==========================================================================;
//
// bcasteventimpl.h : additional infrastructure to support implementing IMSVidGraphSegment for
//   playback segments
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef BCASTEVENTIMPL_H
#define BCASTEVENTIMPL_H

namespace MSVideoControl {

template<class T> 
    class DECLSPEC_NOVTABLE IBroadcastEventImpl : public IBroadcastEvent {
protected:
    PQBroadcastEvent m_pBcast;
    DWORD m_dwEventCookie;
	
public:
    IBroadcastEventImpl<T>() : m_dwEventCookie(0) {}
    virtual ~IBroadcastEventImpl<T>() {}

    HRESULT RegisterService() {
        T* pT = static_cast<T*>(this);
        if (!pT->m_pGraph) {
            return E_UNEXPECTED;
        }
        if (!m_pBcast) {
            PQServiceProvider sp(pT->m_pGraph);
            if (!sp) {
                TRACELM(TRACE_ERROR, "BroadcastEventImpl::RegisterService() can't get service provider i/f");
    		    return ImplReportError(__uuidof(T), IDS_CANT_NOTIFY_CHANNEL_CHANGE, __uuidof(IBroadcastEvent), E_UNEXPECTED);
            }
            HRESULT hr = sp->QueryService(SID_SBroadcastEventService, IID_IBroadcastEvent, reinterpret_cast<LPVOID*>(&m_pBcast));
            if (FAILED(hr) || !m_pBcast) {
                hr = m_pBcast.CoCreateInstance(CLSID_BroadcastEventService, 0, CLSCTX_INPROC_SERVER);
                if (FAILED(hr)) {
                    TRACELM(TRACE_ERROR, "BroadcastEventImpl::RegisterService() can't create bcast service");
    		        return ImplReportError(__uuidof(T), IDS_CANT_NOTIFY_CHANNEL_CHANGE, __uuidof(IBroadcastEvent), E_UNEXPECTED);
                }
                PQRegisterServiceProvider rsp(pT->m_pGraph);
                if (!sp) {
                    TRACELM(TRACE_ERROR, "BroadcastEventImpl::RegisterService() can't get get register service provider i/f");
    		        return ImplReportError(__uuidof(T), IDS_CANT_NOTIFY_CHANNEL_CHANGE, __uuidof(IBroadcastEvent), E_UNEXPECTED);
                }
                hr = rsp->RegisterService(SID_SBroadcastEventService, m_pBcast);
                if (FAILED(hr)) {
                    TRACELSM(TRACE_ERROR, (dbgDump << "BroadcastEventImpl::RegisterService() can't get register service provider. hr = " << hexdump(hr)), "");
    		        return ImplReportError(__uuidof(T), IDS_CANT_NOTIFY_CHANNEL_CHANGE, __uuidof(IBroadcastEvent), E_UNEXPECTED);
                }

            }
        }
        return NOERROR;
    }

    HRESULT BroadcastFire(GUID2& eventid) {
        HRESULT hr = RegisterService();
        if (FAILED(hr)) {
            return hr;
        }
        ASSERT(m_pBcast);
        return m_pBcast->Fire(eventid);
    }
	HRESULT BroadcastAdvise() {
        HRESULT hr = RegisterService();
        if (FAILED(hr)) {
            return hr;
        }
        ASSERT(m_pBcast);
        PQConnectionPoint cp(m_pBcast);
        if (!cp) {
            TRACELSM(TRACE_ERROR, (dbgDump << "BroadcastEventImpl::Advise() can't QI event notification for connection point i/f. hr = " << hexdump(hr)), "");
    		return ImplReportError(__uuidof(T), IDS_CANT_NOTIFY_CHANNEL_CHANGE, __uuidof(IBroadcastEvent), E_UNEXPECTED);
        }

        hr = cp->Advise(static_cast<IBroadcastEvent*>(this) /* IBroadcastEvent implementing event receiving object*/, &m_dwEventCookie);
        if (FAILED(hr)) {
            TRACELSM(TRACE_ERROR, (dbgDump << "BroadcastEventImpl::Advise() can't advise event notification. hr = " << hexdump(hr)), "");
    		return ImplReportError(__uuidof(T), IDS_CANT_NOTIFY_CHANNEL_CHANGE, __uuidof(IBroadcastEvent), E_UNEXPECTED);
        }

        return NOERROR;
	}
    HRESULT BroadcastUnadvise() {
        if (m_pBcast && m_dwEventCookie) {
            PQConnectionPoint cp(m_pBcast);
            if (cp) {
                HRESULT hr = cp->Unadvise(m_dwEventCookie);
                if (FAILED(hr)) {
                    TRACELSM(TRACE_ERROR, (dbgDump << "BroadcastEventImpl::Unadvise() can't unadvise event notification. hr = " << hexdump(hr)), "");
                }
            } else {
                TRACELM(TRACE_ERROR, "CMSVidBDATuner::Unload() can't QI event notification for connection point i/f.");
            }
            m_pBcast.Release();
            m_dwEventCookie = 0;
        }
        ASSERT(!m_pBcast && !m_dwEventCookie);
        return NOERROR;
    }

};


}; // namespace

#endif
// end of file - bcasteventimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\channeltunerequestimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ChannelTuneRequestimpl.h : implementation helper template for component type interface
// Copyright (c) Microsoft Corporation 1999.

#ifndef CHANNELTUNEREQUESTIMPL_H
#define CHANNELTUNEREQUESTIMPL_H

#include <tune.h>
#include "tunerequestimpl.h"

namespace BDATuningModel {

template<class T,
         class MostDerived = IChannelTuneRequest, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IChannelTuneRequestImpl : 
	public ITuneRequestImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// IChannelTuneRequest
public:
	typedef ITuneRequestImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;

	IChannelTuneRequestImpl() : m_Channel(-1) {}
	virtual ~IChannelTuneRequestImpl() {}
    BEGIN_PROP_MAP(IChannelTuneRequestImpl)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("Channel", m_Channel, VT_I4)
    END_PROP_MAP()

	long m_Channel;
    STDMETHOD(get_Channel)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_Channel;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_Channel)(long newVal)
    {
		ATL_LOCKT();
		if (!m_TS) {
			return E_UNEXPECTED;
		}
		long maxval;
		long minval;
		TNAnalogTVTuningSpace ts(m_TS);
        if (ts) {
			maxval = ts.MaxChannel();
			minval = ts.MinChannel();
        } else {
            TNAnalogRadioTuningSpace ts2(m_TS);
            if (ts2) {
                maxval = ts2.MaxFrequency();
                minval = ts2.MinFrequency();
            } else {
                TNAuxInTuningSpace ts3(m_TS);
                if(ts3){
                    maxval = 1;
                    minval = 0;
                }
                else{
                    return E_UNEXPECTED;
                }
            }
        }
		if (newVal != BDA_UNDEFINED_CHANNEL) {
			if (newVal < minval) {
				newVal = maxval;
			} else if (newVal > maxval) {
				newVal = minval;
			}
		}
        m_Channel = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
	STDMETHOD(Clone) (ITuneRequest **ppTR) {
		try {
			if (!ppTR) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppTR);
			if (FAILED(hr)) {
				return hr;
			}
			T* pt = static_cast<T*>(*ppTR);
			pt->m_Channel = m_Channel;
			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}

};
typedef CComQIPtr<IChannelTuneRequest> PQChannelTuneRequest;

}; // namespace

#endif // CHANNELTUNEREQUESTIMPL_H
// end of file -- channeltunerequestimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\compimpl.h ===
//==========================================================================;
//
// compimpl.h : additional infrastructure to support implementing IMSVidCompositionSegment 
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef COMPIMPL_H
#define COMPIMPL_H

#include <segimpl.h>

namespace MSVideoControl {

typedef CComQIPtr<IMSVidCompositionSegment, &__uuidof(IMSVidCompositionSegment)> PQCompositionSegment;

template<class T, class DerivedMost = IMSVidCompositionSegment> class DECLSPEC_NOVTABLE IMSVidCompositionSegmentImpl : 
    public IMSVidGraphSegmentImpl<T, MSVidSEG_XFORM, &GUID_NULL, DerivedMost> {
public:

    bool m_fComposed;
    VWSegmentList m_Segments;
    VWSegmentList::iterator m_pUp;
    VWSegmentList::iterator m_pDown;

    IMSVidCompositionSegmentImpl() : 
            m_fComposed(false), 
            m_Segments(VWSegmentList()),
            m_pUp(m_Segments.end()),
            m_pDown(m_Segments.end())
        {}

    virtual ~IMSVidCompositionSegmentImpl() {
        m_fComposed = false;
    }

    STDMETHOD(GetClassID) (LPCLSID guid) {
        try {
            memcpy(guid, &__uuidof(T), sizeof(CLSID));
            return NOERROR;
        } catch(...) {
            return E_POINTER;
        }
    }
    STDMETHOD(get_Up)(IMSVidGraphSegment **upstream)
	{
        if (!m_fComposed) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidCompositionSegment), CO_E_NOTINITIALIZED);
        }
        ASSERT(m_pGraph);
        try {
            return (*m_pUp).CopyTo(upstream);
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
		return NOERROR;
	}
    STDMETHOD(get_Down)(IMSVidGraphSegment **downstream)
	{
        if (!m_fComposed) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidCompositionSegment), CO_E_NOTINITIALIZED);
        }
        ASSERT(m_pGraph);
        try {
            return (*m_pDown).CopyTo(downstream);
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
		return NOERROR;
	}

};

}; // namespace

#endif
// end of file compimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\dataserviceimpl.h ===
//==========================================================================;
//
// dataserviceimpl.h : additional infrastructure to support implementing IMSVidDataServices
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef DATASERVICEIMPL_H
#define DATASERVICEIMPL_H

#include "featureimpl.h"

namespace MSVideoControl {

template<class T, LPCGUID LibID, LPCGUID KSCategory, class MostDerivedInterface = IMSVidDataServiceDevice>
    class DECLSPEC_NOVTABLE IMSVidDataServicesImpl : public IMSVidFeatureImpl<T, LibID, KSCategory, MostDerivedInterface> {
public:
	    virtual ~IMSVidDataServicesImpl() {}
};

}; /// namespace

#endif
// end of file - dataserviceimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\componenttypeimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ComponentTypeimpl.h : implementation helper template for component type interface
// Copyright (c) Microsoft Corporation 1999.

#ifndef COMPONENTTYPEIMPL_H
#define COMPONENTTYPEIMPL_H

#pragma once
#include <tuner.h>
#include "errsupp.h"

namespace BDATuningModel {

template<class T,
         class MostDerived = IComponentType, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IComponentTypeImpl : 
    public IPersistPropertyBagImpl<T>,
	public IDispatchImpl<MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// IComponentType
public:
    BEGIN_PROP_MAP(IComponentTypeImpl)
        PROP_DATA_ENTRY("Category", m_ComponentCategory, VT_I4)
        PROP_DATA_ENTRY("Media Major Type", m_MediaMajorType, VT_BSTR)
        PROP_DATA_ENTRY("Media Sub Type", m_MediaSubType, VT_BSTR)
        PROP_DATA_ENTRY("Media Format Type", m_MediaFormatType, VT_BSTR)
	END_PROP_MAP()

    ComponentCategory m_ComponentCategory;
	CComBSTR m_MediaMajorType;
	CComBSTR m_MediaSubType;
	CComBSTR m_MediaFormatType;

    IComponentTypeImpl() : m_ComponentCategory(CategoryNotSet) {
      GUID2 g(GUID_NULL);
      m_MediaMajorType = g.GetBSTR();
      m_MediaSubType = g.GetBSTR();
      m_MediaFormatType = g.GetBSTR();
    }
    virtual ~IComponentTypeImpl() {}
    STDMETHOD(get_Category)(/*[out, retval]*/ ComponentCategory *pVal) {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_ComponentCategory;
        } catch (...) {
            return E_POINTER;
        }

    	return NOERROR;
    }
    STDMETHOD(put_Category)(/*[in]*/ ComponentCategory newVal) {
		ATL_LOCKT();
        m_ComponentCategory = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }

    STDMETHOD(get_MediaMajorType)(/*[out, retval]*/ BSTR *pVal) {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            return m_MediaMajorType.CopyTo(pVal);
        } catch (...) {
            return E_POINTER;
        }

    	return NOERROR;
    }

	STDMETHOD(get__MediaMajorType)(/*[out, retval]*/ GUID* pMediaMajorTypeGuid) {
        try {
            if (!pMediaMajorTypeGuid) {
                return E_POINTER;
            }
			ATL_LOCKT();
			GUID2 g(m_MediaMajorType);
            memcpy(pMediaMajorTypeGuid, &g, sizeof(GUID));
      		return NOERROR;
        } catch (...) {
            return E_POINTER;
        }

    	return NOERROR;
    }

    STDMETHOD(put_MediaMajorType)(/*[in]*/ BSTR newVal) {
		try {
			GUID2 g(newVal);
			return put__MediaMajorType(g);
		} catch (ComException &e) {
			return e;
		} catch (...) {
			return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IComponentType), E_UNEXPECTED);
		}
    }
    
    STDMETHOD(put__MediaMajorType)(/*[in]*/REFCLSID newVal) {
        try {
		    GUID2 g(newVal);
			ATL_LOCKT();
		    m_MediaMajorType = g.GetBSTR();
			MARK_DIRTY(T);
			return NOERROR;
		} catch(...) {
			return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IComponentType), E_UNEXPECTED);
		}
    }

    STDMETHOD(get_MediaSubType)(/*[out, retval]*/ BSTR *pVal) {
        try {
            if (!pVal) {
				return E_POINTER;
            }
			ATL_LOCKT();
            return m_MediaSubType.CopyTo(pVal);
        } catch (...) {
            return E_POINTER;
        }

    	return NOERROR;
    }

	STDMETHOD(get__MediaSubType)(/*[out, retval]*/ GUID* pMediaSubTypeGuid) {
        try {
            if (!pMediaSubTypeGuid) {
                return E_POINTER;
            }
			ATL_LOCKT();
			GUID2 g(m_MediaSubType);
            memcpy(pMediaSubTypeGuid, &g, sizeof(GUID));
      		return NOERROR;
        } catch (...) {
            return E_POINTER;
        }

    	return NOERROR;
    }

    STDMETHOD(put_MediaSubType)(/*[in]*/ BSTR newVal) {
        try {
			return put__MediaSubType(GUID2(newVal));
		} catch (ComException &e) {
			return e;
		} catch (...) {
			return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IComponentType), E_UNEXPECTED);
		}
    }

    STDMETHOD(put__MediaSubType)(/*[in]*/ REFCLSID newVal) {
        try {
            GUID2 g(newVal);
			ATL_LOCKT();
			m_MediaSubType = g.GetBSTR();
			MARK_DIRTY(T);

			return NOERROR;
		} catch(...) {
			return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IComponentType), E_UNEXPECTED);
		}
    }

    STDMETHOD(get_MediaFormatType)(/*[out, retval]*/ BSTR *pVal) {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            return m_MediaFormatType.CopyTo(pVal);
        } catch (...) {
            return E_POINTER;
        }

    	return NOERROR;
    }

    STDMETHOD(get__MediaFormatType)(/*[out, retval]*/ GUID* pMediaFormatTypeGuid) {
        try {
            if (!pMediaFormatTypeGuid) {
                return E_POINTER;
            }
			ATL_LOCKT();
			GUID2 g(m_MediaFormatType);
            memcpy(pMediaFormatTypeGuid, &g, sizeof(GUID));
      		return NOERROR;
        } catch (...) {
            return E_POINTER;
        }

    	return NOERROR;
    }

    STDMETHOD(put_MediaFormatType)(/*[in]*/ BSTR newVal) {  
        try {
            return put__MediaFormatType(GUID2(newVal));
		} catch (ComException &e) {
            return e;
		} catch (...) {
			return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IComponentType), E_UNEXPECTED);
		}
   }
   STDMETHOD(put__MediaFormatType)(/*[in]*/ REFCLSID newVal) {
		try {
			GUID2 g(newVal);
			ATL_LOCKT();
			m_MediaFormatType =  g.GetBSTR();
			MARK_DIRTY(T);
			return NOERROR;
		} catch(...) {
			return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IComponentType), E_UNEXPECTED);
		}
    }

    STDMETHOD(get_MediaType)(/*[out, retval]*/ AM_MEDIA_TYPE *pVal) {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();

			pVal->majortype = GUID2(m_MediaMajorType);
			pVal->subtype = GUID2(m_MediaSubType);
			pVal->formattype = GUID2(m_MediaFormatType);

            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }

    }
    STDMETHOD(put_MediaType)(/*[in]*/ AM_MEDIA_TYPE *pnewVal) {
        try {
            if (!pnewVal) {
                return E_POINTER;
            }
			ATL_LOCKT();

			m_MediaMajorType = GUID2(pnewVal->majortype).GetBSTR();
			m_MediaSubType = GUID2(pnewVal->subtype).GetBSTR();
			m_MediaFormatType = GUID2(pnewVal->formattype).GetBSTR();

			MARK_DIRTY(T);
			return NOERROR;
        } catch (...) {
            return E_FAIL;
        }

    }

	STDMETHOD(Clone) (IComponentType **ppCT) {
		try {
			if (!ppCT) {
				return E_POINTER;
			}
			ATL_LOCKT();

			T* pt = static_cast<T*>(new CComObject<T>);
			if (!pt) {
				return ImplReportError(__uuidof(T), IDS_E_OUTOFMEMORY, __uuidof(IComponentType), E_OUTOFMEMORY);
			}
			pt->m_ComponentCategory = m_ComponentCategory;
   			pt->m_MediaMajorType = m_MediaMajorType;
			pt->m_MediaSubType = m_MediaSubType;
			pt->m_MediaFormatType = m_MediaFormatType;
			pt->m_bRequiresSave = true;
			pt->AddRef();
			*ppCT = pt;
			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}

};

}; // namespace

#endif // COMPONENTTYPEIMPL_H
// end of file -- componenttypeimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\componentimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// Componentimpl.h : implementation helper template for component interface
// Copyright (c) Microsoft Corporation 1999.

#ifndef COMPONENTIMPL_H
#define COMPONENTIMPL_H

#include "componenttype.h"

namespace BDATuningModel {

template<class T,
         class MostDerived = IComponent, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IComponentImpl : 
    public IPersistPropertyBagImpl<T>,
	public IDispatchImpl<MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// IComponent
public:
    PQComponentType m_Type;
    CComBSTR m_Desc;
    ComponentStatus m_ComponentStatus;
    long m_DescLangID;

    IComponentImpl() : m_ComponentStatus(StatusUnavailable), 
                       m_DescLangID(-1) {}
	virtual ~IComponentImpl() {}
    typedef IComponentImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> thistype;
    BEGIN_PROP_MAP(thistype)
        PROP_DATA_QI_ENTRY("Type", m_Type.p, __uuidof(IComponentType))
        PROP_DATA_ENTRY("Description", m_Desc.m_str, VT_BSTR)
        PROP_DATA_ENTRY("DescLangID", m_DescLangID, VT_I4)
        PROP_DATA_ENTRY("Status", m_ComponentStatus, VT_I4)
    END_PROP_MAP()

// IComponent
public:
    STDMETHOD(get_Type)(/*[out, retval]*/ IComponentType** ppVal) {
        try {
            if (!ppVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            return m_Type.CopyTo(ppVal);
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_Type)(/*[in]*/ IComponentType*  pNewVal) {
		ATL_LOCKT();
        m_Type = pNewVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pVal) {
        try {
			ATL_LOCKT();
            return m_Desc.CopyTo(pVal);
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_Description)(/*[in]*/ BSTR newVal) {
        try {
			CHECKBSTRLIMIT(newVal);
			ATL_LOCKT();
            m_Desc = newVal;
            MARK_DIRTY(T);
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }
    STDMETHOD(get_DescLangID)(/*[out, retval]*/ long *pLangID) {
        try {
            if (!pLangID) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pLangID = m_DescLangID;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_DescLangID)(/*[in]*/ long NewLangID) {
		ATL_LOCKT();
        m_DescLangID = NewLangID;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_Status)(/*[out, retval]*/ ComponentStatus *pVal) {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_ComponentStatus;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }
    STDMETHOD(put_Status)(/*[in]*/ ComponentStatus newVal) {
		ATL_LOCKT();
        m_ComponentStatus = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(Clone)(/*[out, retval]*/ IComponent **ppNew) {
		try {
			if (!ppNew) {
				return E_POINTER;
			}
			ATL_LOCKT();
			T* pt = static_cast<T*>(new CComObject<T>);
			if (!pt) {
				return E_OUTOFMEMORY;
			}
			if(m_Type){
              ASSERT(!pt->m_Type);
			  HRESULT hr = m_Type->Clone(&pt->m_Type);
			  if (FAILED(hr)) {
			    delete pt;
			    return hr;
			  }
			}
			pt->AddRef();
    	    pt->m_Desc = m_Desc.Copy();
        	pt->m_DescLangID = m_DescLangID;
	        pt->m_ComponentStatus = m_ComponentStatus;

			pt->m_bRequiresSave = true;

			*ppNew = pt;
			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}

	    return NOERROR;
    }
};

}; // namespace

#endif // COMPONENTIMPL_H
// end of file -- componentimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\deviceeventimpl.h ===
// Copyright (c) 1999-2002  Microsoft Corporation.  All Rights Reserved.

#pragma once 

#ifndef _MSVIDDEVICEEVENT_H_
#define _MSVIDDEVICEEVENT_H_

template <class T, const IID* piid = &IID_IMSVidDeviceEvent, class CDV = CComDynamicUnkArray>
class CProxy_DeviceEvent : public IConnectionPointImpl<T, piid, CDV>
{
public:

    void Fire_VoidMethod(DISPID eventid) {
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        int nConnections = m_vec.GetSize();

        for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {
                HRESULT hr;
                DISPPARAMS disp = { NULL, NULL, 0, 0 };
                hr = pDispatch->Invoke(eventid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
                if(FAILED(hr)){
                    TRACELSM(TRACE_ERROR, (dbgDump << "CProxy_DeviceEvent::Fire_VoidMethod() Eventid " << eventid << "Invoke " << nConnectionIndex << " failed hr = " << hexdump(hr)), "");
                }

            }
        }
    }

    void Fire_StateChange(IMSVidDevice *lpd, long oldState, long newState) 
    {
        T* pT = static_cast<T*>(this);
        int nConnectionIndex;
        CComVariant* pvars = new CComVariant[3];
        int nConnections = m_vec.GetSize();

        for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
        {
            pT->Lock();
            CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
            pT->Unlock();
            IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
            if (pDispatch != NULL)
            {

                pvars[0] = lpd;
                pvars[1] = oldState;
                pvars[2] = newState;
                DISPPARAMS disp = { pvars, NULL, 3, 0 };
                pDispatch->Invoke(eventidStateChange, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
            }
        }
        delete[] pvars;

    }

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\devsegimpl.h ===
//==========================================================================;
//
// devsegimpl.h : additional infrastructure to support implementing device segments
// virtual base class used by devimpl and segimpl to store shared data
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef DEVICESEGMENTIMPL_H
#define DEVICESEGMENTIMPL_H

#include <segment.h>
#include <seg.h>
#include <filterenum.h>
#include <errsupp.h>

#ifndef DECLSPEC_NOVTABLE
#define DECLSPEC_NOVTABLE __declspec(novtable)
#endif

namespace MSVideoControl {

class DECLSPEC_NOVTABLE CMSVidDeviceSegmentImpl {
public:
    bool m_fInit;
    VWSegmentContainer m_pContainer;
    DSGraph m_pGraph;
    DSFilterList m_Filters;
	DSFilterMoniker m_pDev;

    CMSVidDeviceSegmentImpl() : m_fInit(false), m_Filters(DSFilterList()) {}
    virtual ~CMSVidDeviceSegmentImpl() {
        m_pContainer.p = NULL;  // we didn't addref to avoid circular ref counts(we're guaranteed nested lifetimes) and
                                // we don't want to cause an unmatched release so manually clear the pointer
        
    }
};

}; // namespace

#endif 
// end of file - devsegimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\devseq.h ===
//==========================================================================;
//
// Devseq.h : types for device sequences
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef DEVSEQ_H
#define DEVSEQ_H

#include <w32extend.h>
#include <fwdseq.h>
#include <tuner.h>
#include <msvidctl.h>

namespace BDATuningModel {};

namespace MSVideoControl {

using namespace BDATuningModel;

typedef CComQIPtr<IMSVidDevice, &__uuidof(IMSVidDevice)> PQDevice;
typedef CComQIPtr<IMSVidInputDevice, &__uuidof(IMSVidInputDevice)> PQInputDevice;
typedef CComQIPtr<IMSVidOutputDevice, &__uuidof(IMSVidOutputDevice)> PQOutputDevice;
typedef CComQIPtr<IMSVidVideoRenderer, &__uuidof(IMSVidVideoRenderer)> PQVideoRenderer;
typedef CComQIPtr<IMSVidAudioRenderer, &__uuidof(IMSVidAudioRenderer)> PQAudioRenderer;
typedef CComQIPtr<IMSVidFeature, &__uuidof(IMSVidFeature)> PQFeature;
#if 0
typedef CComQIPtr<IMSVidDevices, &__uuidof(IMSVidDevices)> PQDevices;
#endif
typedef CComQIPtr<IMSVidInputDevices, &__uuidof(IMSVidInputDevices)> PQInputDevices;
typedef CComQIPtr<IMSVidOutputDevices, &__uuidof(IMSVidOutputDevices)> PQOutputDevices;
typedef CComQIPtr<IMSVidVideoRendererDevices, &__uuidof(IMSVidVideoRendererDevices)> PQVideoRendererDevices;
typedef CComQIPtr<IMSVidAudioRendererDevices, &__uuidof(IMSVidAudioRendererDevices)> PQAudioRendererDevices;
typedef CComQIPtr<IMSVidFeatures, &__uuidof(IMSVidFeatures)> PQFeatures;
typedef std::vector<PQDevice, PQDevice::stl_allocator> DeviceCollection;

// REV2:  since IMSVidXXXXXDevices is an ole collection rather than a com enumerator
// we could do a real random access container for it.  but, since all we need to do here
// is enumerate it, we won't bother to do that work, at least for now.

#if 0
typedef Forward_Sequence<
    PQDevices,
    PQEnumVARIANT,
    CComVariant,
    IMSVidDevices ,
    IEnumVARIANT,
    VARIANT,
    std::allocator<VARIANT> > VWDevices;
#endif

typedef Forward_Sequence<
    PQInputDevices,
    PQEnumVARIANT,
    CComVariant,
    IMSVidInputDevices ,
    IEnumVARIANT,
    VARIANT,
    std::allocator<VARIANT> > VWInputDevices;

typedef Forward_Sequence<
    PQOutputDevices,
    PQEnumVARIANT,
    CComVariant,
    IMSVidOutputDevices ,
    IEnumVARIANT,
    VARIANT,
    std::allocator<VARIANT> > VWOutputDevices;

typedef Forward_Sequence<
    PQVideoRendererDevices,
    PQEnumVARIANT,
    CComVariant,
    IMSVidVideoRendererDevices ,
    IEnumVARIANT,
    VARIANT,
    std::allocator<VARIANT> > VWVideoRendererDevices;

typedef Forward_Sequence<
    PQAudioRendererDevices,
    PQEnumVARIANT,
    CComVariant,
    IMSVidAudioRendererDevices ,
    IEnumVARIANT,
    VARIANT,
    std::allocator<VARIANT> > VWAudioRendererDevices;

typedef Forward_Sequence<
    PQFeatures,
    PQEnumVARIANT,
    CComVariant,
    IMSVidFeatures ,
    IEnumVARIANT,
    VARIANT,
    std::allocator<VARIANT> > VWFeatures;
#endif

}; // namespace
// end of file devseq.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\dsextend.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1995-2000.
//
//--------------------------------------------------------------------------;
//
// dsextend.cpp : implementation of various direct show extension classes
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include "ksextend.h"
#include "dsextend.h"

const int MAX_OCCURRENCE_COUNT = 2;

static DWORD dwFetch;
#if 0
// note: the compiler is generating but never calling the code to construct these initializers so the pointers
// are staying null.  we work around this by providing a function which dynamically allocating them on the heap
// and calling it in our dllmain.

// DSGraphContainer
std_arity1pmf<IGraphBuilder, IEnumFilters **, HRESULT> * DSGraphContainer::Fetch = &std_arity1pmf<IGraphBuilder, IEnumFilters **, HRESULT>(&IGraphBuilder::EnumFilters);
std_arity0pmf<IEnumFilters, HRESULT> * DSGraphContainer::iterator::Reset = &std_arity0_member(&IEnumFilters::Reset);
std_arity1pmf<IEnumFilters, IBaseFilter **, HRESULT> * DSGraphContainer::iterator::Next = &std_bind_mf_1_3(std_arity3_member(&IEnumFilters::Next), 1, &dwFetch);

// DSFilter
std_arity1pmf<IBaseFilter, IEnumPins **, HRESULT> * DSFilter::Fetch = &std_arity1_member(&IBaseFilter::EnumPins);
std_arity0pmf<IEnumPins, HRESULT> * DSFilter::iterator::Reset = &std_arity0_member(&IEnumPins::Reset);
std_arity1pmf<IEnumPins, IPin **, HRESULT> * DSFilter::iterator::Next = &std_bind_mf_1_3(std_arity3_member(&IEnumPins::Next), 1, &dwFetch);

// DSDevices
std_arity1pmf<ICreateDevEnum, IEnumMoniker **, HRESULT> * DSDeviceSequence::Fetch = NULL;  // no arity0 fetch actually exists. overridden with bound functor in DSDeviceSequence::GetFetch
std_arity0pmf<IEnumMoniker, HRESULT> * DSDevices::iterator::Reset = &std_arity0_member(&IEnumMoniker::Reset);
std_arity1pmf<IEnumMoniker, IMoniker **, HRESULT> * DSDevices::iterator::Next = &std_bind_mf_1_3(std_arity3_member(&IEnumMoniker::Next), 1, &dwFetch);

// DSFilterMapper
std_arity1pmf<IFilterMapper2, IEnumMoniker **, HRESULT> * DSFilterMapperSequence::Fetch = NULL;// no arity0 fetch actually exists. overridden with bound functor in DSFilterMapperSequence::GetFetch
// uses same types as DSDevices so its the same template expansion, already initialized

// DSPin
std_arity1pmf<IPin, IEnumMediaTypes **, HRESULT> * DSPin::Fetch = &std_arity1_member(&IPin::EnumMediaTypes);
std_arity0pmf<IEnumMediaTypes, HRESULT> * DSPin::iterator::Reset = &std_arity0_member(&IEnumMediaTypes::Reset);
std_arity1pmf<IEnumMediaTypes, AM_MEDIA_TYPE **, HRESULT> * DSPin::iterator::Next = &std_bind_mf_1_3(std_arity3_member(&IEnumMediaTypes::Next), 1, &dwFetch);
#else
// DSGraphContainer
std_arity1pmf<IGraphBuilder, IEnumFilters **, HRESULT> * DSGraphContainer::Fetch = NULL;
std_arity0pmf<IEnumFilters, HRESULT> * DSGraphContainer::iterator::Reset = NULL;
std_arity1pmf<IEnumFilters, IBaseFilter **, HRESULT> * DSGraphContainer::iterator::Next = NULL;

// DSFilter
std_arity1pmf<IBaseFilter, IEnumPins **, HRESULT> * DSFilter::Fetch = NULL;
std_arity0pmf<IEnumPins, HRESULT> * DSFilter::iterator::Reset = NULL;
std_arity1pmf<IEnumPins, IPin **, HRESULT> * DSFilter::iterator::Next = NULL;

// DSDevices
std_arity1pmf<ICreateDevEnum, IEnumMoniker **, HRESULT> * DSDeviceSequence::Fetch = NULL;  // no arity0 fetch actually exists. overridden with bound functor in DSDeviceSequence::GetFetch
std_arity0pmf<IEnumMoniker, HRESULT> * DSDevices::iterator::Reset = NULL;
std_arity1pmf<IEnumMoniker, IMoniker **, HRESULT> * DSDevices::iterator::Next = NULL;

// DSFilterMapper
std_arity1pmf<IFilterMapper2, IEnumMoniker **, HRESULT> * DSFilterMapperSequence::Fetch = NULL;// no arity0 fetch actually exists. overridden with bound functor in DSFilterMapperSequence::GetFetch
// uses same types as DSDevices so its the same template expansion, already initialized

// DSPin
std_arity1pmf<IPin, IEnumMediaTypes **, HRESULT> * DSPin::Fetch = NULL;
std_arity0pmf<IEnumMediaTypes, HRESULT> * DSPin::iterator::Reset = NULL;
std_arity1pmf<IEnumMediaTypes, AM_MEDIA_TYPE **, HRESULT> * DSPin::iterator::Next = NULL;
#endif


// work around compiler bug as per above description
void CtorStaticDSExtendFwdSeqPMFs(void) {
    // DSGraphContainer
    DSGraphContainer::Fetch = new std_arity1pmf<IGraphBuilder, IEnumFilters **, HRESULT>(&IGraphBuilder::EnumFilters);
    DSGraphContainer::iterator::Reset = new std_arity0pmf<IEnumFilters, HRESULT>(&IEnumFilters::Reset);
    DSGraphContainer::iterator::Next = new std_bndr_mf_1_3<std_arity3pmf<IEnumFilters, ULONG, IBaseFilter**, ULONG *, HRESULT> >(std_arity3_member(&IEnumFilters::Next), 1, &dwFetch);

    // DSFilter
    DSFilter::Fetch = new std_arity1pmf<IBaseFilter, IEnumPins **, HRESULT>(&IBaseFilter::EnumPins);
    DSFilter::iterator::Reset = new std_arity0pmf<IEnumPins, HRESULT>(&IEnumPins::Reset);
    DSFilter::iterator::Next = new std_bndr_mf_1_3<std_arity3pmf<IEnumPins, ULONG, IPin **, ULONG *, HRESULT> >(std_arity3_member(&IEnumPins::Next), 1, &dwFetch);

    // DSDevices
    // DSDeviceSequence::Fetch,  no arity0 fetch actually exists. overridden with bound functor in DSDeviceSequence::GetFetch
    DSDevices::iterator::Reset = new std_arity0pmf<IEnumMoniker, HRESULT>(&IEnumMoniker::Reset);
    DSDevices::iterator::Next = new std_bndr_mf_1_3<std_arity3pmf<IEnumMoniker, ULONG, IMoniker **, ULONG *, HRESULT> >(std_arity3_member(&IEnumMoniker::Next), 1, &dwFetch);

    // DSFilterMapper, no arity0 fetch actually exists. overridden with bound functor in DSFilterMapperSequence::GetFetch
    // uses same types as DSDevices so its the same template expansion, already initialized

    // DSPin
    DSPin::Fetch = new std_arity1pmf<IPin, IEnumMediaTypes **, HRESULT>(&IPin::EnumMediaTypes);
    DSPin::iterator::Reset = new std_arity0pmf<IEnumMediaTypes, HRESULT>(&IEnumMediaTypes::Reset);
    DSPin::iterator::Next = new std_bndr_mf_1_3<std_arity3pmf<IEnumMediaTypes, DWORD, AM_MEDIA_TYPE **, DWORD *, HRESULT> >(std_arity3_member(&IEnumMediaTypes::Next), 1, &dwFetch);
}

// work around compiler bug as per above description
void DtorStaticDSExtendFwdSeqPMFs(void) {
    // DSGraphContainer
    delete DSGraphContainer::Fetch;
    delete DSGraphContainer::iterator::Reset;
    delete DSGraphContainer::iterator::Next;

    // DSFilter
    delete DSFilter::Fetch;
    delete DSFilter::iterator::Reset;
    delete DSFilter::iterator::Next;

    // DSDevices
    // DSDeviceSequence::Fetch,  no arity0 fetch actually exists. overridden with bound functor in DSDeviceSequence::GetFetch
    delete DSDevices::iterator::Reset;
    delete DSDevices::iterator::Next;

    // DSFilterMapper, no arity0 fetch actually exists. overridden with bound functor in DSFilterMapperSequence::GetFetch
    // uses same types as DSDevices so its the same template expansion, already initialized

    // DSPin
    delete DSPin::Fetch;
    delete DSPin::iterator::Reset;
    delete DSPin::iterator::Next;
}

///////////////////////////////////////////////////////////////////////////////////////////////
// DSGraph
///////////////////////////////////////////////////////////////////////////////////////////////
HRESULT DSGraph::Connect(DSFilter &pStart, DSFilter &pStop, DSFilterList &Added, const DWORD dwFlags, PIN_DIRECTION pd)
{
    ASSERT(*this);
    ASSERT(pStart.GetGraph() == *this);
    ASSERT(pStop.GetGraph() == *this);
    try {
		DSFilterIDList AddedIDs;
        int origsize = Added.size();
        if (ConnectFilters(pStart, pStop, AddedIDs, dwFlags, pd)) {
			for (DSFilterIDList::iterator i = AddedIDs.begin(); i != AddedIDs.end(); ++i) {
				Added.push_back((*i).first);
			}
            return NOERROR;
        }
        ASSERT(!AddedIDs.size());
        ASSERT(Added.size() == origsize);
        return E_FAIL;
    } catch (ComException &e) {
        return e;
    } catch (...) {
        return E_UNEXPECTED;
    }
}

bool DSGraph::Connect(DSFilter &pStart, DSFilterMoniker &pStop, DSFilter &pEndPointAdded, DSFilterList &IntermediatesAdded, const DWORD dwFlags, PIN_DIRECTION pd)
{
    ASSERT(*this);
    ASSERT(pStart.GetGraph() == *this);
    pEndPointAdded = AddMoniker(pStop);
    if (!pEndPointAdded) {
        return false;
    }
    ASSERT(pEndPointAdded.GetGraph() == *this);
    int origsize = IntermediatesAdded.size();
    if (SUCCEEDED(Connect(pStart, pEndPointAdded, IntermediatesAdded, dwFlags, pd))) {
        return true;
    }
    RemoveFilter(pEndPointAdded);
    pEndPointAdded.Release();
    ASSERT(IntermediatesAdded.size() == origsize);
    return false;
}


#ifdef ATTEMPT_DIRECT_CONNECT
// attempt to connect the given pin to some pin on the given filter
bool DSGraph::ConnectPinDirect(DSPin &pPin, DSFilter &pFilter, DWORD dwFlags) {
    try {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectPinDirect() pPin = " << pPin << " pFilter = " << pFilter), "");
        TRACEINDENT();
        DSFilter::iterator i;
        for (i = pFilter.begin(); i != pFilter.end(); ++i) {
			if (!DSPin(*i).GetConnection()) {
				HRESULT hr = pPin.Connect(*i, NULL);
				if (SUCCEEDED(hr)) {
					TRACEOUTDENT();
					TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::ConnectPinDirect() connected " << pPin.GetFilter() << " " << pPin << " to " << DSPin(*i).GetFilter() << " " << *i), "");
					return true;
				}
			}
        }
        TRACEOUTDENT();
    } catch(...) {
        TRACEOUTDENT();
    }
#if 0
    // for perf reasons, we would like to short-circuit destinations that have no 
    // free pins by throwing, causing a roll back to the next filter to try
    // however, this breaks topologies where two source pins route through intermediate filters
    // and into a single pin going into the destination filter.
    // example: this causes the analog audio pin coming off an analog tuner to fail to connect
    // through to the crossbar because the capture filter is already connected to video.
    if (!cUseablePins) {
        TRACELM(TRACE_DETAIL, "ConnectPinDirect() no useable pins, throwing...");
        THROWCOM(HRESULT_FROM_WIN32(ERROR_OUT_OF_STRUCTURES));  // short cut the case where there aren't any useable pins by any criteria
    }
#endif
    TRACELM(TRACE_DETAIL, "ConnectPinDirect() failed");
    return false;
}
#endif

#ifndef ATTEMPT_DIRECT_CONNECT
// attempt to connect the given pin to some pin on the given filter
bool DSGraph::ConnectPinByMedium(DSPin &pPin, DSFilter &pFilter, DWORD dwFlags) {
    int cUseablePins = 0;
    try {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectPinByMedium() pPin = " << pPin << " pFilter = " << pFilter), "");
        TRACEINDENT();
        DSFilter::iterator i;
        for (i = pFilter.begin(); i != pFilter.end(); ++i) {
            if (HasUnconnectedMedium(pPin, *i, cUseablePins)) {
                break;
            }
        }
        if (i != pFilter.end()) {
            HRESULT hr = pPin.Connect(*i, NULL);
            if (FAILED(hr)) {
                TRACEOUTDENT();
                TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::ConnectPinByMedium() can't connect pin " << pPin << " to " << *i), " with matching medium");
                return false;
            }
            TRACEOUTDENT();
            TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::ConnectPinByMedium() connected " << pPin.GetFilter() << " " << pPin << " to " << DSPin(*i).GetFilter() << " " << *i), "");
            return true;
        }
        TRACEOUTDENT();
    } catch(...) {
        TRACEOUTDENT();
        TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::ConnectPinByMedium() connect pin "), " THREWUP");
    }
#if 0
    // for perf reasons, we would like to short-circuit destinations that have no 
    // free pins by throwing, causing a roll back to the next filter to try
    // however, this breaks topologies where two source pins route through intermediate filters
    // and into a single pin going into the destination filter.
    // example: this causes the analog audio pin coming off an analog tuner to fail to connect
    // through to the crossbar because the capture filter is already connected to video.
    if (!cUseablePins) {
        TRACELM(TRACE_DETAIL, "ConnectPinByMedium() no useable pins, throwing...");
        THROWCOM(HRESULT_FROM_WIN32(ERROR_OUT_OF_STRUCTURES));  // short cut the case where there aren't any useable pins by any criteria
    }
#endif
    TRACELM(TRACE_DETAIL, "ConnectPinByMedium() failed");
    return false;
}
#endif

// attempt to connect the given pin to the given filter by hunting for an indirection through
// another filter already in the graph
// then attempt to connect the new filter to the original destination
bool DSGraph::FindPinByMedium(DSPin &pPin1, DSFilter &pFDest, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::FindPinByMedium() pPin1 = " << pPin1 << " pFDest = " << pFDest), "");
    KSMediumList ml;
    HRESULT hr = pPin1.GetMediums(ml);
    if (FAILED(hr) || !ml.size()) {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::FindPinByMedium() " << pPin1 << " has no mediums"), "");
        return false;
    }

    try {
        TRACEINDENT();
        // possibly in the future we should find all of the possible choices and
        // use the shortest available path.  but for now, we're just going to
        // find the first one that exists

        // try all the direct connections
		for (DSGraphContainer::iterator i = begin(); i != end(); ++i) {
#ifdef ATTEMPT_DIRECT_CONNECT
			if (IsConnectable(pPin1, DSFilter(*i), pFDest, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinDirect))) {
#else
			if (IsConnectable(pPin1, DSFilter(*i), pFDest, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinByMedium))) {
#endif
                TRACEOUTDENT();
                TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMedium() succeeded");
				return true;
			}
		}
        TRACEOUTDENT();
    } catch(...) {
        TRACEOUTDENT();
    }
    TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMedium() can't connect pin to anything in graph");
    return false;
}

// we have already established that we can't connect directly or via other filters
// already in the graph so go hunt for a new filter to load
// if we fail we must leave the graph in its initial state
bool DSGraph::LoadPinByMedium(KSPinMedium &medium, DSPin &pPin1, DSFilter &pFilter1, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMedium() pPin1 = " << pPin1 << " pFilter1 = " << pFilter1), "");
    if (medium == NULL_MEDIUM || medium == HOST_MEMORY_MEDIUM) {
        TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByMedium() NULL Medium, don't bother");
        // don't build an enumerator for a null medium or we will search through every
        // single filter on the system that doesn't have mediums
        return false;
    }
    try {
        TRACEINDENT();
        TRACELSM(TRACE_PAINT, (dbgDump << "medium = " << medium), "");
        PIN_DIRECTION pd;
        HRESULT hr = pPin1->QueryDirection(&pd);
        if (FAILED(hr)) {
                TRACEOUTDENT();
                TRACELM(TRACE_ERROR, "DSGraph::LoadPinByMedium() can't query direction");
                THROWCOM(E_UNEXPECTED);
        }


        bool fInReq = false, fOutReq = false;
        DSREGPINMEDIUM *pInMed = NULL, *pOutMed = NULL;

        switch (pd) {
        case PINDIR_INPUT:  // hunting through graph from right to left

#ifdef FILTERDATA
                    fOutReq = true;
                    pOutMed = reinterpret_cast<DSREGPINMEDIUM *>(&medium);
#else
            // NOTE: because of mediums get registered from the .inf with an
            // incomplete registry blob, filtermapper thinks that any pin with a
            // medium is an input pin and we use the low flag bit in the second
            // medium dword to solve this problem. == 1 for input == 0 for output
                    fInReq = true;
                    pInMed = reinterpret_cast<DSREGPINMEDIUM *>(&medium);
            medium.Flags &= ~(KSMEDIUM_INPUTFLAG);
#endif
            break;
        case PINDIR_OUTPUT: // hunting through graph from left to right
            fInReq = true;
            pInMed = reinterpret_cast<DSREGPINMEDIUM *>(&medium);
#ifndef FILTERDATA
            medium.Flags |= KSMEDIUM_INPUTFLAG;
#endif
            break;
        }

        if (pInMed) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMedium() fInReq = " << fInReq << " pInMed = " << pInMed << " " << (*pInMed)), "");
        } else {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMedium() fInReq = " << fInReq << " pInMed = " << pInMed << " (NULL)"), "");
        }
        if (pOutMed) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMedium() fOutReq = " << fOutReq << " pOutMed = " << pOutMed << " " << (*pOutMed)), "");
        } else {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMedium() fOutReq = " << fOutReq << " pOutMed = " << pOutMed << " (Null)"), "");
        }
        // NOTE: since we're using mediums which are hw specific we include filters w/
        // MERIT_DO_NOT_USE since this is the default merit and most HW device filters
        // don't specify a merit.
        DSFilterMapper fmr(PQFilterMapper(*this),
                       0,
                       true,                                    // no wildcards
                       MERIT_DO_NOT_USE,                        // default merit for hw filters
                       fInReq,                                  // input required
                       0,
                       NULL,
                       pInMed,                                  // input medium
                       NULL,                                    // input pin cat
                       false,                                   // input rendered?
                       fOutReq,                                 // output required
                       0,
                       NULL,
                       pOutMed,                                 // output medium
                       NULL                                     // output pin cat
                      );
        if (fmr) {
            // try all the direct connections
			for (DSFilterMapper::iterator i = fmr.begin(); i != fmr.end(); ++i) {
#ifdef ATTEMPT_DIRECT_CONNECT
				if (IsLoadable(pPin1, DSFilterMoniker(*i), pFilter1, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinDirect))) {
#else
				if (IsLoadable(pPin1, DSFilterMoniker(*i), pFilter1, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinByMedium))) {
#endif
                    TRACEOUTDENT();
                    TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByMedium() succeeded");
					return true;
				}
			}
        }
        TRACEOUTDENT();
    } catch(...) {
        TRACEOUTDENT();
    }
    TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByMedium() failed");

    return false;
}

bool DSGraph::LoadPinByAnyMedium(DSPin &pPin, DSFilter &pRight, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags) {
    TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByAnyMedium()");
    try {
        KSMediumList ml;
        HRESULT hr = pPin.GetMediums(ml);
        if (FAILED(hr) || !ml.size()) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByAnyMedium() " << pPin << " has no mediums"), "");
            return false;
        }
		for (KSMediumList::iterator i = ml.begin(); i != ml.end(); ++i) {
			if (LoadPinByMedium(KSPinMedium(*i), pPin, pRight, IntermediatesAdded, dwFlags)) {
				return true;
			}
		}
	} catch(ComException& h) {
		if (h == E_UNEXPECTED) {
			try {
				TRACELM(TRACE_DEBUG, "DSGraph::LoadPinByAnyMedium() rethrowing E_UNEXPECTED");
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::LoadPinByAnyMedium() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch(...) {
    }

    return false;
}

#ifndef ATTEMPT_DIRECT_CONNECT
// attempt to connect these two filters.  if we fail we must remove
// any intermediate filters that we may have added and leave the graph in the
// state we started with.
bool DSGraph::ConnectPinByMediaType(DSPin &pPin1, DSFilter &pFilter1, DWORD dwFlags) {
    ASSERT(pPin1.GetGraph() == *this);
    ASSERT(pFilter1.GetGraph() == *this);
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectPinByMediaType(DSPin, DSFilter) pPin1 = " << pPin1 << " pFilter1 = " << pFilter1), "");
    try {
        TRACEINDENT();
        // try media types
		DSFilter::iterator i;
		for (i = pFilter1.begin(); i != pFilter1.end(); ++i) {
			if (HasUnconnectedMediaType(pPin1, *i, dwFlags)) {
				break;
			}
		}
        if (i != pFilter1.end()) {
            ASSERT(*this);
            ASSERT(pPin1.GetGraph() == *this);
            ASSERT((*i).GetGraph() == *this);
            HRESULT hr = pPin1.Connect(*i, NULL);
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::ConnectPinByMediaType(DSPin, DSFilter) can't connect pin " << pPin1 << " to " << *i << " hr = " << hexdump(hr)), " with matching media type.");
#ifdef DEBUG
                if (dwTraceLevel >= TRACE_DETAIL) {
                    DumpHdr(dbgDump) << "pin1 " << pPin1.GetFilter() << " " << pPin1 << std::endl;
                    DumpHdr(dbgDump) << "pin2 " << (*i).GetFilter() << " " << *i << std::endl;
                    DumpMediaTypes(pPin1, *i);
                }
#endif
                if (!(dwFlags & IGNORE_MEDIATYPE_ERRORS)) {
                    THROWCOM(HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH));
                } else {
                    return false;
                }
            }
            TRACEOUTDENT();
            TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::ConnectPinByMediaType(DSPin, DSFilter) connected " << pPin1.GetFilter() << " " << pPin1 << " to " << DSPin(*i).GetFilter() << " " << *i), "");
            return true;
        }
        TRACEOUTDENT();
	} catch(ComException& h) {
        TRACEOUTDENT();
		if (h == E_UNEXPECTED || h == HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH)) {
			try {
				TRACELM(TRACE_DEBUG, "DSGraph::ConnectPinByMediaType() rethrowing");
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::ConnectPinByMediaType() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch(...) {
        TRACEOUTDENT();
    }
    TRACELM(TRACE_DEBUG, "DSGraph::ConnectPinByMediaType(DSPin, DSFilter) failed");

    return false;
}
#endif

bool DSGraph::FindPinByMediaType(DSPin &pPinLeft, DSFilter &pRight, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags) {
    ASSERT(pPinLeft.GetGraph() == *this);
    ASSERT(pRight.GetGraph() == *this);
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::FindPinByMediaType() pPinLeft = " << pPinLeft << " filter = " << pRight), "");
    // possibly in the future we should find all of the possible choices and
    // use the shortest available path.  but for now, we're just going to
    // find the first one that exists
    try {
        TRACEINDENT();
		// NOTE: IFilterGraph::ConnectDirect() bumps the graph version number which invalidates
		// all the enumerators.  thus we'll run through and make a list of all the filters in the 
		// graph and then check them
		DSFilterList l;
		for (DSGraphContainer::iterator i = begin(); i != end(); ++i) {
			l.push_back(*i);
		}
		for (DSFilterList::iterator li = l.begin(); li != l.end(); ++li) {
#ifdef ATTEMPT_DIRECT_CONNECT
			if (IsConnectable(pPinLeft, DSFilter(*li), pRight, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinDirect))) {
#else
			if (IsConnectable(pPinLeft, DSFilter(*li), pRight, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinByMediaType))) {
#endif
                TRACEOUTDENT();
                TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMediaType() succeeded");
				return true;
			}
		}
		TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMediaType() enumeration exhausted");
        TRACEOUTDENT();
	} catch(ComException& h) {
        TRACEOUTDENT();
		if (h == E_UNEXPECTED) {
			TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMediaType() rethrowing E_UNEXPECTED");
			throw;
		}
		TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::FindPinByMediaType() suppressing HRESULT = " << hexdump(h)), "");
    } catch(...) {
		TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMediaType() catch ...");
        TRACEOUTDENT();
    }
    TRACELM(TRACE_DETAIL, "DSGraph::FindPinByMediaType() failed");

    return false;
}

bool DSGraph::LoadPinByAnyMediaType(DSPin &pPin, DSFilter &pRight, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByAnyMediaType() pPin = " << pPin.GetName() << " dwFlags = " << hexdump(dwFlags)), "");
    ASSERT(pPin.GetGraph() == *this);
    ASSERT(pRight.GetGraph() == *this);
#ifdef DEBUG
    BEGIN_TRACEL(TRACE_DETAIL)
        if (pPin.begin() == pPin.end()) {
            dbgDump << "DSGraph::LoadPinByAnyMediaType() pin has no media types\r\n";
            dbgDump.flush();
        }
    END_TRACEL
#endif
    try {
		DWORD dwMerit = MERIT_NORMAL;
		if (dwFlags & ATTEMPT_MERIT_UNLIKELY) {
			dwMerit = MERIT_UNLIKELY;
			TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByAnyMediaType() MERIT_UNLIKELY");
		} else if (dwFlags & ATTEMPT_MERIT_DO_NOT_USE) {
			dwMerit = MERIT_DO_NOT_USE;
			TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByAnyMediaType() MERIT_DO_NOT_USE");
		}

		return LoadPinByMediaType(pPin, pRight, IntermediatesAdded, dwFlags, dwMerit);
	} catch(ComException& h) {
		if ((h == E_UNEXPECTED) || 
			(h == HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH)) ||
			(h == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
			) {
			try {
				TRACELM(TRACE_DEBUG, "DSGraph::LoadPinByAnyMediaType() rethrowing");
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::LoadPinByAnyMediaType() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch(...) {
    }
    TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByAnyMediaType() failed");

    return false;
}

// we are trying to connect Pin1 to the Destination Filter.  we have already
// established that we cannot connect them directly.
// Mapper is a moniker for a filter provided by the filtermapper enumerator that we're
// going to attempt to use as an intermediate filter
bool DSGraph::IsConnectable(DSPin &pPin1, DSFilter &pNew, DSFilter &pFDestination, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags, ConnectPred_t ConnPred) {
    ASSERT(pPin1 != NULL);
    ASSERT(pPin1.GetGraph() == *this);
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsConnectable() pPin1 = " << pPin1 << " pNew = " << pNew << " pFDestination = " << pFDestination), "");
    try {
        PIN_INFO pinfo;
        HRESULT hr = pPin1->QueryPinInfo(&pinfo);
		if (FAILED(hr)) {
			THROWCOM(E_UNEXPECTED);
		}
        DSFilter Pin1Filter;
        Pin1Filter.p = pinfo.pFilter;  // transfer refcount ownership

        if (pNew && pNew != pFDestination && pNew != Pin1Filter) {
            bool f1 = (this->*ConnPred)(pPin1, pNew, dwFlags);
            if (f1) {
                TRACELM(TRACE_DETAIL, "DSGraph::IsConnectable() connpred == true");
                PIN_DIRECTION direction;
                hr = pPin1->QueryDirection(&direction);
                if (FAILED(hr)) {
                    TRACELM(TRACE_ERROR, "DSGraph::IsConnectable() can't query direction");
                    THROWCOM(E_UNEXPECTED);
                }
                if (ConnectFilters(pNew, pFDestination, IntermediatesAdded, dwFlags, direction)) {
                    TRACELM(TRACE_DETAIL, "DSGraph::IsConnectable() succeeded");
                    return true;
                }
            }
        }
	} catch(ComException& h) {
		if (h == E_UNEXPECTED) {
			try {
				TRACELM(TRACE_DEBUG, "DSGraph::IsConnectable() rethrowing E_UNEXPECTED");
			    pPin1.Disconnect();
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::IsConnectable() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch(...) {
    }

    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsConnectable() disconnecting " << pPin1), "");
    pPin1.Disconnect();
    return false;
}

// we are trying to connect Pin1 to the Destination Filter.  we have already
// established that we cannot connect them directly.
// Mapper is a moniker for a filter provided by the filtermapper enumerator that we're
// going to attempt to use as an intermediate filter
bool DSGraph::IsLoadable(DSPin &pPin1, DSFilterMoniker &Mapper, DSFilter &Destination, DSFilterIDList &IntermediatesAdded, DWORD dwFlags, ConnectPred_t ConnPred) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsLoadable() pPin1 = " << pPin1 << " " << pPin1.GetFilter() << " Destination = " << Destination), "");
    ASSERT(pPin1.GetGraph() == *this);
    DSFilter pNew;
    try {
		DSFilterIDList::iterator i = IntermediatesAdded.size() ? (IntermediatesAdded.end() - 1) : IntermediatesAdded.end();

		if (i != IntermediatesAdded.end()) {
			TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsLoadable() checking duplicate moniker last = " << (*i).second << " new = " << Mapper.DisplayName()), "");
		} else {
			TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsLoadable() first moniker can't be dup(no check) new = " << Mapper.DisplayName()), "");
		}

		// undone: if the chains get longer we should use a map for this.  this may explain why perf
        // collapses as soon as we end up over on the audio side of things
		int occurrences = 0;
		CString newmkrname = Mapper.DisplayName();
		for (i = IntermediatesAdded.begin(); i != IntermediatesAdded.end(); ++i) {
			if ((!(*i).second.IsEmpty()) && 
				(newmkrname == (*i).second)) {
				   ++occurrences;
			}
		}
		if (occurrences > MAX_OCCURRENCE_COUNT) {
			TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::IsLoadable() max occurrence count exceeded for mkr = " << newmkrname), "");
			return false;
		}
        pNew = AddMoniker(Mapper);
        IntermediatesAdded.push_back(DSFilterID(pNew, Mapper.DisplayName()));
// ???? implement flag
        if (pNew) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsLoadable() added moniker pNew = " << pNew), "");
            bool f1 = (this->*ConnPred)(pPin1, pNew, dwFlags);
            if (f1) {
                TRACELM(TRACE_DETAIL, "DSGraph::IsLoadable() connpred succeeded");
                PIN_DIRECTION direction;
                HRESULT hr = pPin1->QueryDirection(&direction);
                if (FAILED(hr)) {
                    TRACELM(TRACE_ERROR, "DSGraph::IsLoadable() can't query direction");
                    THROWCOM(E_UNEXPECTED);
                }
		        if (!pNew.PinCount(direction)) {
                    if (!(dwFlags & DONT_TERMINATE_ON_RENDERER)) {
                        TRACELM(TRACE_DETAIL, "DSGraph::IsLoadable() throwing ERROR_NO_MORE_ITEMS");
                        THROWCOM(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS));
                    }
		        }
                if (ConnectFilters(pNew, Destination, IntermediatesAdded, dwFlags, direction)) {
                    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::IsLoadable() succeeded.  pPin1 = " << pPin1 << " pNew = " << pNew << " Destination = " << Destination), "");
                    return true;
                }
            }
        }
	} catch(ComException& h) {
		if ((h == E_UNEXPECTED) || 
			(h == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))) {
			try {
				TRACELM(TRACE_DEBUG, "DSGraph::IsLoadable() rethrowing");
				TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::IsLoadable() disconnecting " << pPin1), "");
				pPin1.Disconnect();
				TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::IsLoadable() removing " << pNew), "");
				IntermediatesAdded.pop_back();
				RemoveFilter(pNew);
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::IsLoadable() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch(...) {
    }

    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::IsLoadable() disconnecting " << pPin1), "");
    pPin1.Disconnect();
	IntermediatesAdded.pop_back();
    if (pNew) {
        TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::IsLoadable() removing " << pNew), "");
        RemoveFilter(pNew);
    }
    return false;
}

bool DSGraph::ConnectPin(DSPin &pPin1, DSFilter &pFilter1, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags, PIN_DIRECTION pin1dir) {
    // NOTE: this is where we enforce the desired directional assymetry.  from now on through the call tree
    // we can assume that pin1 is already the desired directional type. and we only have to check
    // pin2 at the end in hasunconnectedxxxx()
    // this ensures that all of our connection paths are unidirectional through the graph. in other words,
    // make sure that we don't go downstream then back upstream or vice versa.
    // this allows all of our connection routines to be useable from either direction
    // since there are times when we have an input side starting point and other times the opposite
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectPin() pin1 = " << pPin1 << " " << pPin1.GetFilter() << " to " << pFilter1), "");
	TRACEINDENT();
    PIN_DIRECTION pd;

    HRESULT hr = pPin1->QueryDirection(&pd);
    if (pd != pin1dir) {
		TRACEOUTDENT();
        TRACELM(TRACE_PAINT, "DSGraph::ConnectPin() wrong dir");
        return false;
    }

	if (!(dwFlags & RENDER_ALL_PINS) &&  !pPin1.IsRenderable()) {
		TRACEOUTDENT();
        TRACELM(TRACE_PAINT, "DSGraph::ConnectPin() non-renderable");
		return false;
	}

    // make sure we're not trying to connect a filter to itself
    PIN_INFO pinfo;
    DSFilter PinFilter;
    hr = pPin1->QueryPinInfo(&pinfo);
    if (FAILED(hr)) {
		TRACEOUTDENT();
        TRACELM(TRACE_ERROR, "DSGraph::ConnectPin() can't get pin info");
        THROWCOM(E_UNEXPECTED);
    }
    PinFilter.p = pinfo.pFilter;  // transfer refcount ownership
    if (PinFilter == pFilter1) {
		TRACEOUTDENT();
        TRACELM(TRACE_PAINT, "DSGraph::ConnectPin() can't connect filter to itself");
        return false;
    }

    DSPin pConn = pPin1.GetConnection();
    if (!!pConn) {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectPin() pin1  = " << pPin1 << " connected, tracing through to next filter = " << pConn.GetFilter()), "");
        // a connected output pin should be traced through the next filter
        DSFilter pNext = pConn.GetFilter();
        if (!pNext) {
			TRACEOUTDENT();
            TRACELM(TRACE_ERROR, "DSGraph::ConnectPin() pNext has no filter");
            THROWCOM(E_UNEXPECTED);
        }
        if (pNext != pFilter1) {
	        bool rc = ConnectFilters(pNext, pFilter1, IntermediatesAdded, dwFlags, pin1dir);
			TRACEOUTDENT();
			return rc;
		} else {
			TRACEOUTDENT();
			TRACELM(TRACE_DETAIL, "DSGraph::ConnectPin() pNext == pFilter1");
			return true;
		}
    }

#if 0
    // for perf reasons, we would like to short-circuit destinations that have no 
    // free pins by returning, causing a roll back to the next filter to try
    // however, this breaks topologies where two source pins route through intermediate filters
    // and into a single pin going into the destination filter.
    // example: this causes the analog audio pin coming off an analog tuner to fail to connect
    // through to the crossbar because the capture filter is already connected to video.
    TRACELM(TRACE_DETAIL, "DSGraph::ConnectPin() pin free");
	PIN_DIRECTION pd2;
	pd2 = OppositeDirection(pd);
	if (!pFilter1.HasFreePins(pd2)) {
		TRACEOUTDENT();
		TRACELM(TRACE_DETAIL, "DSGraph::ConnectPin() filter has no free pins");
		return false;
	}
    TRACELM(TRACE_DETAIL, "DSGraph::ConnectPin() filter has free pins");
#endif

    try {
#ifdef ATTEMPT_DIRECT_CONNECT
        if (ConnectPinDirect(pPin1, pFilter1) ||     // can these connect direct
#else
        if (ConnectPinByMedium(pPin1, pFilter1, dwFlags) ||     // can these connect direct
#endif
            FindPinByMedium(pPin1, pFilter1, IntermediatesAdded, dwFlags)    ||     // any paths in graph
            (!(dwFlags & DO_NOT_LOAD) && LoadPinByAnyMedium(pPin1, pFilter1, IntermediatesAdded, dwFlags))    ||     // any filters in system
#ifndef ATTEMPT_DIRECT_CONNECT
			ConnectPinByMediaType(pPin1, pFilter1, dwFlags) ||     // can these connect direct
#endif
            FindPinByMediaType(pPin1, pFilter1, IntermediatesAdded, dwFlags)    ||
            (!(dwFlags & DO_NOT_LOAD) && LoadPinByAnyMediaType(pPin1, pFilter1, IntermediatesAdded, dwFlags))) {
			TRACEOUTDENT();
            TRACELM(TRACE_DETAIL, "DSGraph::ConnectPin() succeeded");
            return true;
        }
        TRACEOUTDENT(); // to avoid outdenting too far in a catch case
    } catch (ComException &h) {
		TRACEOUTDENT();
		if (h == E_UNEXPECTED) {
			try {
				TRACELM(TRACE_DEBUG, "DSGraph::ConnectPin() rethrowing E_UNEXPECTED");
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::ConnectPin() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch (...) {
		TRACEOUTDENT();
    }

	//TRACEOUTDENT();
    TRACELM(TRACE_DETAIL, "DSGraph::ConnectPin() failed");
    return false;
}

// attempt to disconnect this pin
bool DSGraph::DisconnectPin(DSPin &pPin, const bool fRecurseInputs, const bool fRecurseOutputs) {
    TRACELM(TRACE_DETAIL, "DSGraph::DisconnectPin()");

    PIN_DIRECTION pd;
    HRESULT hr = pPin->QueryDirection(&pd);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::DisconnectPin() can't get direction");
        THROWCOM(E_UNEXPECTED);
    }

    DSPin pConnection = pPin.GetConnection();
    if (!pConnection) {
        return false;
    }
    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::DisconnectPin() disconnecting " << pPin << " from " << pConnection), "");
    pPin.Disconnect();
    DSFilter pNext = pConnection.GetFilter();
    if (!pNext) {
        TRACELM(TRACE_ERROR, "DSGraph::DisconnectPin() pConnection has no filter");
        THROWCOM(E_UNEXPECTED);
    }

    switch (pd) {
    case PINDIR_INPUT:
        if (fRecurseInputs) {
#if 0
            std::for_each(pNext.begin(),
                     pNext.end(),
                     bind_obj_2_3(*this,
                                  arity3_member(&DSGraph::DisconnectPin),
                                  fRecurseInputs,
                                  false));  // we moving inputward, don't backtrack
#endif
		    for (DSFilter::iterator i = pNext.begin(); i != pNext.end(); ++i) {
				DisconnectPin(*i, fRecurseInputs, false);
			}
        }
        break;
    case PINDIR_OUTPUT:
        if (fRecurseOutputs) {
#if 0
            std::for_each(pNext.begin(),
                     pNext.end(),
                     bind_obj_2_3(*this,
                                  arity3_member(&DSGraph::DisconnectPin),
                                  false,
                                  fRecurseOutputs));
#endif
			for (DSFilter::iterator i = pNext.begin(); i != pNext.end(); ++i) {
				DisconnectPin(*i, false, fRecurseOutputs);
			}
        }
        break;
    }

    TRACELM(TRACE_DETAIL, "DSGraph::DisconnectPin() succeeded");
    return true;
}

// attempt to connect this from the graph
bool DSGraph::DisconnectFilter(DSFilter &pFilter, const bool fRecurseInputs, const bool fRecurseOutputs) {
    if (!pFilter) {
        TRACELM(TRACE_ERROR, "DSGraph::DisconnectFilter() can't disconnect NULL filter");
        return FALSE;
    }
    TRACELM(TRACE_DETAIL, "DSGraph::DisconnectFilter()");
    for (DSFilter::iterator i = pFilter.begin(); i != pFilter.end(); ++i) {
        DisconnectPin(*i, fRecurseInputs, fRecurseOutputs);
    }

    return true;
}


bool DSGraph::RemoveFilter(DSFilter &pFilter) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::RemoveFilter() removing " << pFilter), "");
    if (!pFilter) return false;

    DisconnectFilter(pFilter, false, false);

    HRESULT hr = (*this)->RemoveFilter(pFilter);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::RemoveFilter() can't remove filter");
        return false;
    }
    TRACELM(TRACE_DETAIL, "DSGraph::RemoveFilter() complete");

    return true;
}

// pin matches medium
// requires an exact match, won't treat GUID_NULL as wildcard and treats 'host memory' as unmatchable
bool DSGraph::HasMedium(const KSPinMedium &Medium1, const DSPin &pPin2) const {
    DSPin junk(pPin2);
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasMedium() medium1 = " << Medium1 << " pPin2 = " << junk), "");
    if (Medium1 == NULL_MEDIUM || Medium1 == HOST_MEMORY_MEDIUM) {
        TRACELM(TRACE_DETAIL, "DSGraph::HasMedium() medium1 == NULL");
        return false;
    }
    KSMediumList ml;

    HRESULT hr = pPin2.GetMediums(ml);
    if (FAILED(hr) || !ml.size()) {
        return false;
    }
#if 0
    KSMediumList::iterator i = std::find_if(ml.begin(),
                                       ml.end(),
                                       std::bind2nd(std::equal_to<KSPinMedium>(), Medium1));
    if (i != ml.end()) {
        TRACELM(TRACE_DETAIL, "DSGraph::HasMedium() succeeded");
        return true;
    }
#endif
	KSMediumList::iterator i;
	for (i = ml.begin(); i != ml.end(); ++i) {
		if (*i == Medium1) {
	        TRACELM(TRACE_DETAIL, "DSGraph::HasMedium() succeeded");
			return true;
		}
	}

    TRACELM(TRACE_DETAIL, "DSGraph::HasMedium() no match");

    return false;
}

bool DSGraph::HasMediaType(const DSMediaType &LeftMedia, const DSPin &pPinRight) const {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasMediaType() LeftMedia = " << LeftMedia << " LeftMedia.p " << LeftMedia.p << " pPinRight = " << pPinRight), "");

    if (pPinRight.IsKsProxied()) {
#if 0
        DSPin::iterator i = std::find_if(pPinRight.begin(),
                                         pPinRight.end(),
                                         std::bind2nd(std::equal_to<DSMediaType>(),
                                         LeftMedia) );
        if (i != pPinRight.end()) {
            TRACELM(TRACE_DETAIL, "DSGraph::HasMediaType() succeeded");
            return true;
        }
#endif
		DSPin::iterator i;
		for (i = pPinRight.begin(); i != pPinRight.end(); ++i) {
            // NOTE: DSMediaType operator== enables wildcard matches
			if (*i == LeftMedia) {
	            TRACELM(TRACE_DETAIL, "DSGraph::HasMediaType() succeeded");
				return true;
			}
		}
    } else {
        HRESULT hr = pPinRight->QueryAccept(LeftMedia);
        if (SUCCEEDED(hr) && hr != S_FALSE) {
            TRACELM(TRACE_DETAIL, "DSGraph::HasMediaType() succeeded");
            return true;
        }
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasMediaType() query accept refused hr = " << hexdump(hr)), "");
    }

    return false;
}

#ifndef ATTEMPT_DIRECT_CONNECT
// pin is unconnected, opposite direction, and has at least 1 matching medium
// requires an exact match, won't treat GUID_NULL as wildcard
bool DSGraph::HasUnconnectedMedium(const DSPin &pPin1, const DSPin &pPin2, int& cUseable) const {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasUnnconnectedMedium() pin1 = " << pPin1 << " pin2 = " << pPin2), "");
    PIN_DIRECTION pd1, pd2;
    HRESULT hr = pPin1->QueryDirection(&pd1);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::HasUnconnectedMedium() cant query pPin1 direction");
        return false;
    }
    hr = pPin2->QueryDirection(&pd2);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::HasUnconnectedMedium() cant query pPin2 direction");
        return false;
    }
    if (pd1 == pd2) {
        TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMedium() can't connect two pins w/ same direction");
        return false;  // can't connect two of same type pins
    }
    TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMedium() checking connection status");

    DSPin pConn = pPin2.GetConnection();
    if (!!pConn) {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasUnconnectedMedium() pPin2 = " << pPin2 << " already connected"), "");
        return false;
    }
    ++cUseable;

    KSMediumList ml;
    hr = pPin1.GetMediums(ml);
    if (FAILED(hr) || !ml.size()) {
        TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMedium() pin has no mediums");
        return false;
    }
    KSMediumList::iterator i;
    for (i = ml.begin(); i != ml.end(); ++i) {
        if (HasMedium(*i, pPin2)) {
            break;
        }
    }
    if (i != ml.end()) {
        TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMedium() succeeded");
        return true;
    }
    TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMedium() pPin2 has no matching medium");
    return false;
}

// pin is unconnected, opposite direction,  and there is at least 1 matching media type
bool DSGraph::HasUnconnectedMediaType(const DSPin &pPin1, const DSPin &pPin2, DWORD dwFlags) const {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasUnnconnectedMediaType() pPin1 = " << pPin1 << " pPin2 = " << pPin2), "");
    if (pPin1.GetDirection() == pPin2.GetDirection()) {
        TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMediaType() cant connect 2 pins w/ same direction");
        return false;  // can't connect two of same type pins
    }
    DSPin pConn = pPin2.GetConnection();
    if (!!pConn) {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::HasUnconnectedMediaType() pPin2 connected to " << pConn), "");
        return false;
    }
    TRACELM(TRACE_DETAIL, "DSGraph::HasUnnconnectedMediaType() finding");
    // pin right isn't connected to anything so hunt for a
    // compatible media type
	for (DSPin::iterator i = pPin1.begin(); i != pPin1.end(); ++i) {
		if (HasMediaType(*i, pPin2)) {
	        TRACELM(TRACE_DETAIL, "DSGraph::HasUnnconnectedMediaType() succeeded forward");
			return true;
		}
	}
    if (dwFlags & BIDIRECTIONAL_MEDIATYPE_MATCHING) {
	    for (DSPin::iterator i = pPin2.begin(); i != pPin2.end(); ++i) {
		    if (HasMediaType(*i, pPin1)) {
	            TRACELM(TRACE_DETAIL, "DSGraph::HasUnnconnectedMediaType() succeeded backward(bidi)");
			    return true;
		    }
	    }
    }
    TRACELM(TRACE_DETAIL, "DSGraph::HasUnconnectedMediaType() no matching media types");
    return false;
}
#endif

// we are checking to see if pPin1 is connected(possibly indirectly) to pFDestionation by traveling in destdir direction through
// the graph
bool DSGraph::IsPinConnected(const DSPin &pPin1, const DSFilter &pFDestination, DSFilterIDList &IntermediatesAdded, PIN_DIRECTION destdir) const {
    PIN_DIRECTION direction;
    HRESULT hr = pPin1->QueryDirection(&direction);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::IsPinConnected() can't query direction");
        THROWCOM(E_UNEXPECTED);
    }
    if (direction != destdir) {
        TRACELM(TRACE_DETAIL, "DSGraph::IsPinConnected() wrong direction");
        return false;
    }
    DSPin pConn = pPin1.GetConnection();
        if (!pConn) {
        TRACELM(TRACE_DETAIL, "DSGraph::IsPinConnected() unconnected to anything");
        return false;
        }
    PIN_INFO pinfo;
    DSFilter PinFilter;
    if (pConn) {
        hr = pConn->QueryPinInfo(&pinfo);
        PinFilter.p = pinfo.pFilter;  // transfer refcount ownership
    }
    if (PinFilter == pFDestination) {
        TRACELM(TRACE_DETAIL, "DSGraph::IsPinConnected() directly true");
        return true;
    }
#if 0
#if CRASH
    DSFilter::iterator i = std::find_if(PinFilter.begin(),
                                        PinFilter.end(),
                                        bind_const_obj_2_3_4(
                                            *this,
                                            arity4_const_member(&DSGraph::IsPinConnected),
                                            pFDestination,
                                            IntermediatesAdded,
                                            destdir));
#else
    DSFilter::iterator i = std::find_if(PinFilter.begin(),
                                        PinFilter.end(),
                                        bndr_const_obj_2_3_4<arity4pmf_const<const DSGraph, const DSPin&, const DSFilter&, DSFilterIDList &, const PIN_DIRECTION, bool> >(
                                            *this,
                                            arity4_const_member(&DSGraph::IsPinConnected),
                                            pFDestination,
                                            IntermediatesAdded,
                                            destdir));
#endif
    if (i != PinFilter.end()) {
        TRACELM(TRACE_DETAIL, "DSGraph::IsPinConnected() indirectly true");
        return true;
    }
#endif
	for (DSFilter::iterator i = PinFilter.begin(); i != PinFilter.end(); ++i) {
		if (IsPinConnected(*i, pFDestination, IntermediatesAdded, destdir)) {
			TRACELM(TRACE_DETAIL, "DSGraph::IsPinConnected() indirectly true");
			return true;
		}
	}
    TRACELM(TRACE_DETAIL, "DSGraph::IsPinConnected() unconnected to desired dest");
    return false;
}


#if 0
DSFilter DSGraph::LoadFilter(const PQMoniker &pM, CString &csName) {
    TRACELM(TRACE_DETAIL, "DSGraph::LoadFilter()");
    csName = _T("");
    PQFilter pFilter;
    PQPropertyBag pPropBag;
    HRESULT hr = (pM)->BindToStorage(0, 0, IID_IPropertyBag, reinterpret_cast<LPVOID *>(&pPropBag));
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::LoadFilter() can't bind to storage");
        THROWCOM(hr);
    }
    CComVariant vName;
    vName.vt = VT_BSTR;
    hr = pPropBag->Read(L"FriendlyName", &vName, NULL);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::LoadFilter() can't read friendly name");
        THROWCOM(hr);
    }
    USES_CONVERSION;
    BSTR p = vName.bstrVal;
    csName = OLE2T(p);
    TRACELM(TRACE_DETAIL, "DSGraph::LoadFilter() have propbag");
    hr = (pM)->BindToObject(0, 0, IID_IBaseFilter, reinterpret_cast<LPVOID *>(&pFilter));
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSGraph::LoadFilter() can't bind to object");
        THROWCOM(hr);
    }
    return pFilter;
}
#else
DSFilter DSGraph::LoadFilter(const DSFilterMoniker &pM, CString &csName) {
    TRACELM(TRACE_DETAIL, "DSGraph::LoadFilter()");
    CComBSTR p(pM.GetName());
        if (p) {
                USES_CONVERSION;
                csName = OLE2T(p);
        }
    return pM.GetFilter();
}
#endif

DSFilter DSGraph::AddMoniker(const DSFilterMoniker &pM) {
    TRACELM(TRACE_DETAIL, "DSGraph::AddMoniker()");
    CString csName;

    DSFilter pFilter = LoadFilter(pM, csName);
    if (!pFilter) {
        TRACELM(TRACE_ERROR, "DSGraph::AddMoniker() can't load filter");
        return pFilter;
    }

    TRACELM(TRACE_DETAIL, "DSGraph::AddMoniker() have pFilter");
    USES_CONVERSION;
    HRESULT hr = (*this)->AddFilter(pFilter, T2COLE(csName));
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::AddMoniker() can't add filter " << csName << " to graph"), "");
        return DSFilter();
    }
    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::AddMoniker() added " << csName), "");

    return pFilter;
}

HRESULT DSGraph::AddFilter(DSFilter &pFilter, CString &csName) {
    TRACELM(TRACE_DETAIL, "DSGraph::AddFilter()");
    HRESULT hr;
    USES_CONVERSION;
    hr = (*this)->AddFilter(pFilter, T2COLE(csName));
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::AddFilter() can't add filter " << csName << " to graph"), "");
    }
    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::AddFilter() added " << csName), "");

    return hr;
}

DSFilter DSGraph::AddFilter(const CLSID &cls, CString &csName) {
    TRACELM(TRACE_DETAIL, "DSGraph::AddFilter()");
    HRESULT hr;
    DSFilter pFilter(cls, NULL, CLSCTX_INPROC_SERVER);
    if (!pFilter) {
        TRACELM(TRACE_ERROR, "DSGraph::AddFilter() can't create filter");
        return pFilter;
    }
    hr = AddFilter(pFilter, csName);
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::AddFilter() can't add filter " << csName << " to graph"), "");
        THROWCOM(hr);
    }
    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::AddFilter() added " << csName), "");

    return pFilter;
}

// attempt to connect these two filters.  if we fail we must remove
// any intermediate filters that we've added and leave the graph in the
// state we started with.
// only look at pFilter1 pins of pFilter1Direction
bool DSGraph::ConnectFilters(DSFilter &pFilter1, DSFilter &pFilter2, DSFilterIDList &IntermediatesAdded, DWORD dwFlags, PIN_DIRECTION pFilter1Direction) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectFilters() pFilter1 = " << pFilter1 << " pFilter2 = " << pFilter2), "");
    if (pFilter1 == pFilter2) {
        TRACELM(TRACE_DETAIL, "DSGraph::ConnectFilters same filter");
        return false;
    }
    try {
        TRACEINDENT();
		// undone: there should be some way to preserve the info
		// from the following check to speed up the actual connection in the event
		// that they aren't already connected.

        // see if these filters are already connected
		DSFilter::iterator i;
		if (!(dwFlags & IGNORE_EXISTING_CONNECTIONS)) {
#if 0
#if CRASH
			i = std::find_if(pFilter1.begin(),
 							 pFilter1.end(),
 							 bind_obj_2_3_4(
								 *this,
								 arity4_const_member(&DSGraph::IsPinConnected),
								 pFilter2,
								 IntermediatesAdded,
								 pFilter1Direction));
#else
			i = std::find_if(pFilter1.begin(),
							 pFilter1.end(),
							 bndr_const_obj_2_3_4<arity4pmf_const<const DSGraph, const DSPin&, const DSFilter&, DSFilterIDList &, const PIN_DIRECTION, bool> >(
								 *this,
								 arity4_const_member(&DSGraph::IsPinConnected),
								 pFilter2,
								 IntermediatesAdded,
								 pFilter1Direction));
#endif
			if (i != pFilter1.end()) {
				TRACEOUTDENT();
				TRACELM(TRACE_DEBUG, "DSGraph::ConnectFilters already connected");
				return true;
			}
#endif
			for (DSFilter::iterator i = pFilter1.begin(); i != pFilter1.end(); ++i) {
				if (IsPinConnected(*i, pFilter2, IntermediatesAdded, pFilter1Direction)) {
					TRACEOUTDENT();
					TRACELM(TRACE_DEBUG, "DSGraph::ConnectFilters already connected");
					return true;
				}
			}
		}

        // they're not connected so see if we can connect them
        // connect every possible pin available and keep track of how many we connect
        int cConnected = 0;
		for (i = pFilter1.begin(); i != pFilter1.end(); ++i) {
			try {
				if (ConnectPin(DSPin(*i), pFilter2, IntermediatesAdded, dwFlags, pFilter1Direction)) {
					TRACELM(TRACE_DETAIL, "DSGraph::ConnectFilters() pin connected");
					cConnected++;
				}
			} catch(ComException &h) {
				if (h != HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS)) {
					try {
						TRACELM(TRACE_DETAIL, "DSGraph::ConnectFilters() rethrowing");
					} catch(...) {
					}
					throw;
				}
			}
		}
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectFilters() cConnected = " << cConnected), "");
        if (cConnected) {
            TRACEOUTDENT();// just inside try
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectFilters() succeeded pFilter1 = " << pFilter1 << " pFilter2 = " << pFilter2), "");
            return true;    // we connected at least one pin
        }
        TRACEOUTDENT();// just inside try
	} catch (ComException &h) {
        TRACEOUTDENT();// just inside try
		if (h == E_UNEXPECTED) {
			throw;
		}
    } catch (...) {
        TRACEOUTDENT();  // just inside try
        TRACELM(TRACE_DETAIL, "DSGraph::ConnectFilters() catch...");
    }

    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::ConnectFilters() failed pFilter1 = " << pFilter1 << " pFilter2 = " << pFilter2), "");
    return false;
}

// this function returns a list of pairs of input and output points
// that must be connected to activate the shortest path between two filters
// it returns the number of connections in the path.
// i.e if start is adjacent to stop then rc is 1. if a single filter is between them then 2, etc.
// 0 indicates no path found.
int DSGraph::BuildGraphPath(const DSFilter& pStart,
                            const DSFilter& pStop,
                            VWStream &path,
                            MediaMajorTypeList& MediaTypes,
                            PIN_DIRECTION direction,
                            const DSPin &InitialInput)
{
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() start = " << pStart << " stop = " << pStop), "");
    int pathlen = INT_MAX;
    VWStream returnpath;
    ASSERT(InitialInput || (!InitialInput && !pStart.IsXBar())); // first time in can't be an xbar unless original caller establishes InitialInput
    for (DSFilter::iterator i = pStart.begin(); i != pStart.end(); ++i) {
        DSPin pPin1(*i);
        if (pPin1.GetDirection() != direction) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() " << pStart << ", " << pPin1 << " wrong direction"), "");
            continue;  // search forward
        }
        DSPin pConnection = pPin1.GetConnection();
        if (!pConnection) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() " << pStart << ", " << pPin1 << " unconnected"), "");
            continue;
        }
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() checking " << pPin1 << " connected to " << pConnection.GetFilter() << " " << pConnection), "");
        if (InitialInput) {
            ASSERT(pPin1 != InitialInput);  // direction check should already have filtered for this

            DSMediaType amt(pPin1.GetConnectionMediaType());
            ASSERT(amt);
            if (amt->pUnk) {
                amt->pUnk->Release();
            }

            MediaMajorTypeList::iterator l;
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() searching for " << GUID2(amt.p->majortype)), "");
            l = std::find(MediaTypes.begin(), MediaTypes.end(), amt.p->majortype);
            if (l == MediaTypes.end()) {
                TRACELSM(TRACE_DETAIL, (dbgDump << "major media type not matched"), "");
                continue;
            }

            if (!pPin1.CanRoute(InitialInput)) {
                TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() " << pStart << ",  " << InitialInput << " Can't Route to " << pPin1), "");
                continue;
            }
        }

        DSFilter nextFilter = pConnection.GetFilter();
        ASSERT(nextFilter);
        TRACELSM(TRACE_PAINT, (dbgDump << "DSGraph::BuildGraphPath() nextFilter = " << nextFilter), "");

        if (nextFilter == pStop) {
            TRACELSM(TRACE_PAINT, (dbgDump << "DSGraph::BuildGraphPath() found stop filter"), "");
            // we found the destination, we're done with this one
                        if (pStart.IsXBar()) {
                // if we started on xbar then connected pin's outputpoint pairs with the
                // initialinput(&pin) to form the first pair in the return path
                    TRACELM(TRACE_PAINT, "DSGraph::BuildGraphPath() pstart is xbar");
                ASSERT(DSXBarPin(InitialInput));
                PQPoint p1(DSXBarPin(InitialInput).GetPoint());
                ASSERT(!!p1);

                ASSERT(DSXBarPin(pPin1));
                PQPoint p2(DSXBarPin(pPin1).GetPoint());
                ASSERT(!!p2);

                switch (direction) {
                case DOWNSTREAM:
                    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::BuildGraphPath()  saving pair (" << p1 << ", " << p2), ")");
                    returnpath.push_back(CIOPoint(p1, p2));
                    break;
                case UPSTREAM:
                    TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::BuildGraphPath()  saving pair (" << p2 << ", " << p1), ")");
                    returnpath.push_back(CIOPoint(p2, p1));
                    break;
                }
                        }
            pathlen = 1;
            break;
        } else {
            VWStream temp;
            int rc = BuildGraphPath(nextFilter, pStop, temp, MediaTypes, direction, pConnection);
            // undone: in win64 size() is really __int64.  fix output operator for
            // that type and remove cast

            TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::BuildGraphPath() recursed buildgraphpath returned rc = " << rc << " pathlen = " << pathlen << "sz = " << (long)temp.size()), "");

            // if we found a path and the new one is shorter then the current one
            if (rc && ((rc + 1) < pathlen)) {
                TRACELM(TRACE_PAINT, "DSGraph::BuildGraphPath() accepting new path");
                // save the new path
                pathlen = rc + 1;
                returnpath.clear();
                TRACELM(TRACE_PAINT, "DSGraph::BuildGraphPath() checking xbar adjacency");
                if (pStart.IsXBar()) {
                                        // if we started on xbar then connected pin's outputpoint pairs with the
                                        // initialinput(&pin) to form the next pair in the return path
                        TRACELM(TRACE_PAINT, "DSGraph::BuildGraphPath() pstart is xbar");
                    ASSERT(DSXBarPin(InitialInput));
                    PQPoint p1(DSXBarPin(InitialInput).GetPoint());
                    ASSERT(!!p1);

                    ASSERT(DSXBarPin(pPin1));
                    PQPoint p2(DSXBarPin(pPin1).GetPoint());
                    ASSERT(!!p2);

                    switch (direction) {
                    case DOWNSTREAM:
                        TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::BuildGraphPath()  saving pair (" << p1 << ", " << p2), ")");
                        returnpath.push_back(CIOPoint(p1, p2));
                        break;
                    case UPSTREAM:
                        TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::BuildGraphPath()  saving pair (" << p2 << ", " << p1), ")");
                        returnpath.push_back(CIOPoint(p2, p1));
                        break;
                    }
                }
                                // append onto path any further downstream xbars found by recursion
                returnpath.splice(returnpath.end(), temp);
            } else {
                TRACELM(TRACE_PAINT, "DSGraph::BuildGraphPath() discarding new path");
                // keep the old return path and cleanup the temp one we just got back
                temp.clear();
            }
        }
    }
    if (pathlen == INT_MAX) {  // didn't find anything
                return 0;
    }
    path = returnpath;
    return pathlen;
}

HRESULT DSGraph::AddToROT(DWORD *pdwObjectRegistration) {
    PQMoniker pGraphMK;
    PQROT pROT;
    if (FAILED(::GetRunningObjectTable(0, &pROT))) {
        return E_UNEXPECTED;
    }
    OLECHAR osz[256];
    // undone: in the ia64 case the following format spec isn't enough digits for an address
    //wsprintfW(osz, OLESTR("FilterGraph %08lx  pid %08lx"), (DWORD_PTR) this->p, ::GetCurrentProcessId());
    HRESULT hr = StringCchPrintfW(osz, sizeof(osz) / sizeof(osz[0]), OLESTR("FilterGraph %08lx  pid %08lx"), (DWORD_PTR) this->p, ::GetCurrentProcessId());
    if(FAILED(hr)){
        ASSERT(false);
    }
    hr = ::CreateItemMoniker(OLESTR("!"), osz, &pGraphMK);
    if (SUCCEEDED(hr)) {
        hr = pROT->Register(ROTFLAGS_REGISTRATIONKEEPSALIVE, *this, pGraphMK, pdwObjectRegistration);
    }
    return hr;
}

void DSGraph::RemoveFromROT(DWORD dwObjectRegistration) {
   PQROT pROT;
   if (SUCCEEDED(::GetRunningObjectTable(0, &pROT))) {
       pROT->Revoke(dwObjectRegistration);
   }
}


///////////////////////////////////////////////////////////////////////////////////////////////
// DSFilter
///////////////////////////////////////////////////////////////////////////////////////////////

DSGraph DSFilter::GetGraph(void) {
    FILTER_INFO finfo;
    HRESULT hr = (*this)->QueryFilterInfo(&finfo);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSFilter::GetGraph() failed");
        return DSGraph();
    }
    DSGraph graph = finfo.pGraph;
    if (finfo.pGraph) finfo.pGraph->Release(); // transfer ref count
    return graph;
}

///////////////////////////////////////////////////////////////////////////////////////////////
// DSFilter
///////////////////////////////////////////////////////////////////////////////////////////////
CString DSFilter::GetName(void) const {
    CString csName;
    FILTER_INFO finfo;
    if (*this) {
        HRESULT hr = (*this)->QueryFilterInfo(&finfo);
        if (SUCCEEDED(hr)) {
            csName = finfo.achName;
            if (csName.IsEmpty()) {
                csName = _T("");
            }
            if (finfo.pGraph) {
                finfo.pGraph->Release();
            }
        } else {
#ifdef _DEBUG
            csName = _T("**** UNKNOWN FILTER NAME ****");
#endif
        }
    } else {
#ifdef _DEBUG
        csName = _T("**** NULL FILTER POINTER ****");
#endif
    }
    return csName;
}

void DSFilter::GetPinCounts(ULONG &ulIn, ULONG &ulOut) const
{
    HRESULT hr;
    ulIn = ulOut = 0;
    PIN_DIRECTION pd;
    DSFilter::iterator i;
    for (i = begin(); i != end(); ++i) {
        hr = (*i)->QueryDirection(&pd);
        if (FAILED(hr)) {
            TRACELSM(TRACE_ERROR, (dbgDump << "DSFilter:GetPinCounts() can't query pin direction hr = " << hr), "");
            THROWCOM(E_UNEXPECTED);
        }
        switch (pd) {
        case PINDIR_INPUT:
            ulIn++;
            break;
        case PINDIR_OUTPUT:
            ulOut++;
            break;
        }
    }
    return;
}

///////////////////////////////////////////////////////////////////////////////////////////////
// DSPin
///////////////////////////////////////////////////////////////////////////////////////////////

bool DSPin::HasCategory(const GUID2 &clsCategory, const PIN_DIRECTION pd) const {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSPin::IsPinCategory() pin = " << this), "");
    PIN_DIRECTION pd1;
    HRESULT hr = (*this)->QueryDirection(&pd1);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSPIN::IsPinCategeory() cant query Pin direction");
        return false;
    }
    if (pd1 != pd) {
        TRACELM(TRACE_ERROR, "DSPin::IsPinCategeory() wrong direction");
        return false;
    }
    GUID2 pincat2;
    GetCategory(pincat2);
    return clsCategory == pincat2;
}

HRESULT DSPin::Connect(DSPin ConnectTo, const AM_MEDIA_TYPE *pMediaType) {
    DSGraph pGraph = GetGraph();
    DSGraph pConnGraph = ConnectTo.GetGraph();
    ASSERT(pGraph);
    ASSERT(pConnGraph);
    ASSERT(pGraph == pConnGraph);
    if (!pGraph || !pConnGraph || pGraph != pConnGraph) {
        TRACELM(TRACE_ERROR, "DSPin::Connect() pins not in same graph");
        THROWCOM(E_FAIL);
    }
	if (GetDirection() == PINDIR_OUTPUT) {
	    return pGraph->ConnectDirect(*this, ConnectTo, pMediaType);
	} else {
	    return pGraph->ConnectDirect(ConnectTo, *this, pMediaType);
	}
}

HRESULT DSPin::Disconnect(void) {
    DSPin ConnectedTo;
    HRESULT hr = (*this)->ConnectedTo(&ConnectedTo);
    if (FAILED(hr) || !ConnectedTo) {
        return NOERROR;  // not connected to anything
    }
    PIN_INFO pinfo;
    hr = (*this)->QueryPinInfo(&pinfo);
    if (FAILED(hr)) {
        TRACELM(TRACE_ERROR, "DSPin::Connect() can't call QueryPinInfo");
        THROWCOM(E_UNEXPECTED);
    }
    DSFilter PinFilter;
    PinFilter.p = pinfo.pFilter;  // directly transfer ownership of ref count
    DSGraph pGraph = PinFilter.GetGraph();
    if (!pGraph) {
        TRACELM(TRACE_ERROR, "DSPin::Disconnect() can't get graph from PinFilter");
        THROWCOM(E_UNEXPECTED);
    }
    hr = pGraph->Disconnect(ConnectedTo);
    if (FAILED(hr)) {
        return hr;
    }
    return pGraph->Disconnect(*this);
}

// for any pin to possibly route they must be on the same filter and different directions
bool DSPin::Routable(const DSPin pin2) const {
    if (GetFilter() != pin2.GetFilter()) {
        return false;
    }
    if (GetDirection() == pin2.GetDirection()) {
        return false;
    }
    return true;
}

bool DSPin::CanRoute(const DSPin pin2) const {
        ASSERT(GetFilter() == pin2.GetFilter());
    PQCrossbarSwitch px1(GetFilter());
    if (!px1) {
        return Routable(pin2);
    }

    return DSXBarPin(*this).CanRoute(DSXBarPin(pin2));
}

///////////////////////////////////////////////////////////////////////////////////////////////
// DSXBarPin
///////////////////////////////////////////////////////////////////////////////////////////////
#if 0
const DSXBarPin DSXBarPin::Find(const CPinPoints &pinpoints, const PQPoint &point, PIN_DIRECTION pindir) {
    CPinPoints::const_iterator i;
    TRACELSM(TRACE_DEBUG,  (dbgDump << "DSXBarPin::Find() finding " << point << " direction = " << pindir), "");
    for (i = pinpoints.begin(); i != pinpoints.end(); ++i) {
        TRACELSM(TRACE_DEBUG,  (dbgDump << "DSXBarPin::Find() checking " << DSPin((*i).first) << " direction " << DSPin((*i).first).GetDirection() << " " << (*i).second), "");
        if ((*i).second == point && DSPin((*i).first).GetDirection() == pindir) {
            DSPin p((*i).first);
            PQCrossbarSwitch px1(p.GetFilter());
            if (!px1) {
                TRACELSM(TRACE_ERROR,  (dbgDump << "DSXBarPin::Find() not an xbar " << p), "");
                THROWCOM(E_FAIL);
            }
            TRACELSM(TRACE_DEBUG,  (dbgDump << "DSXBarPin::Find() found " << p), "");
            return DSXBarPin(p);
        }
    }
    THROWCOM(E_FAIL);
    return DSXBarPin();
}
#endif
// undone: cache this lookup
const PQPoint DSXBarPin::GetPoint() const {
    DSFilter f= GetFilter();
    PQCrossbarSwitch px(f);
    if (!px) {
        TRACELSM(TRACE_ERROR,  (dbgDump << "DSXBarPin::Pin2Point() not an xbar" << *this), "");
        THROWCOM(E_INVALIDARG);
    }

    PIN_DIRECTION dir = GetDirection();
    long idx = 0;
    DSFilter::iterator i;
    for (i = f.begin(); i != f.end() && *i != *this; ++i) {
        if ((*i).GetDirection() == dir) {  // output idx's start over at 0
            ++idx;
        }
    }

    if (i != f.end()) {
        TRACELSM(TRACE_PAINT, (dbgDump << "DSXBarPin::GetPoint() " << *this << " pt = " << idx), "");
        return PQPoint(px, idx);
    } else {
        TRACELSM(TRACE_PAINT, (dbgDump << "DSXBarPin::GetPoint() No Point"), "");
        return PQPoint();
    }
}

bool DSXBarPin::CanRoute(const DSXBarPin pin2) const {
    if (!Routable(pin2)) {
        // pins not on same filter or both pins same direction
        return false;
    }
    PQPoint pt1(GetPoint());
    if (!pt1.first) {
        // not on xbar or something corrupt
        return false;
    }
    PQPoint pt2(pin2.GetPoint());
    if (!pt2.first) {
        // not on xbar or something corrupt
        return false;
    }
    ASSERT(pt1.first == pt2.first);  // must be on same xbar

    HRESULT hr = E_FAIL;
    switch(GetDirection()) {
    case PINDIR_INPUT:
        hr = (pt1.first)->CanRoute(pt2.second, pt1.second);
        TRACELSM(TRACE_PAINT, (dbgDump << "DSXBarPin::CanRoute() in 2.sec " << pt2.second << " 1.sec " << pt1.second << " hr = " << hr), "");
        break;
    case PINDIR_OUTPUT:
        hr = (pt1.first)->CanRoute(pt1.second, pt2.second);
        TRACELSM(TRACE_PAINT, (dbgDump << "DSXBarPin::CanRoute() out 1.sec " << pt1.second << " 2.sec " << pt2.second << " hr = " << hr), "");
        break;
    }
    return hr == S_OK;
}

void VWStream::Route() {
    for (iterator i = begin(); i != end(); ++i) {
        CIOPoint p(*i);
        ASSERT(p.first.first == p.second.first);
        PQCrossbarSwitch px(p.first.first);
        HRESULT hr = px->Route(p.second.second, p.first.second);
        ASSERT(SUCCEEDED(hr));
                TRACELSM(TRACE_DETAIL, (dbgDump << "VWStream::Route() hr = " << hr << " px = " << px << " P.2.2 = " << p.second.second << " p.1.2 " << p.first.second), "");
    }
}

bool IsVideoFilter(const DSFilter& f) {
    DSFilter::iterator i;
    for (i = f.begin(); i != f.end(); ++i) {
        if (IsVideoPin(*i)) {
            return true;
        }
    }
    return false;
}

bool IsVideoPin(const DSPin& p) {
    DSPin::iterator i;
    for (i = p.begin(); i != p.end(); ++i) {
        if (IsVideoMediaType(*i)) {
            return true;
        }
    }
    return false;
}

#if 0
// disable until we have pinpoints cache
void DSXBarPin::GetRelations(const CPinPoints &pinpoints, CString &csName, CString &csType, CString &csRelName) const {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSXBarPin::GetRelations()  examining xbar pin " << *this), "");
    CString csw;

    DSFilter f = GetFilter();
    PQCrossbarSwitch xbar(f);
    if (!xbar) {
        THROWCOM(E_FAIL);
    }
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSXBarPin::GetRelations()  examining xbar filter" << f), "");
    long rel, phys;
    HRESULT hr = xbar->get_CrossbarPinInfo(IsInput(), Pin2Point(pinpoints).second, &rel, &phys);
    if (FAILED(hr)) {
        THROWCOM(hr);
    }

    TRACELSM(TRACE_DEBUG, (dbgDump << "DSXBarPin::GetRelations()  have xbar info.  pin = " << (*this) << " rel = " << rel << " phys = " << phys), "");

    TCHAR tphys[256];
    _ltot(phys, tphys, 10);

    csName = GetName();
    csType = tphys;

    ULONG inc, outc;
    f.GetPinCounts(inc, outc);
    long pincount = inc + outc;
    if (rel >= 0 && rel < pincount) {
        DSXBarPin RelPin(Find(pinpoints, PQPoint(xbar, rel), (*this).GetDirection()));
        if (!RelPin) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSXBarPin::GetRelations()  can't build relpin.  rel = " << rel), "");
        } else {
            csRelName = RelPin.GetName();
        }
    }
    TRACELSM(TRACE_DEBUG, (dbgDump << "DSXBarPin::GetRelations()  Name " << csName << " Type " << csType << " RelName " << csRelName), "");

    return;
}
#endif

#ifdef _DEBUG
void DumpMediaTypes(DSPin &p1, DSPin &p2) {
    DSPin::iterator i;
    DumpHdr(dbgDump) << "DumpMediaTypes(): " << std::endl;
    TRACEINDENT();
    for (i = p1.begin(); i != p1.end(); ++i) {
        DumpHdr(dbgDump) << (*i) << " " << hexdump(p2->QueryAccept(*i)) << std::endl;
    }
    DumpHdr(dbgDump) << "----" << std::endl;
    for (i = p2.begin(); i != p2.end(); ++i) {
        DumpHdr(dbgDump) << (*i) << " " << hexdump(p1->QueryAccept(*i)) << std::endl;
    }
    TRACEOUTDENT();
    dbgDump.flush();
}
#endif

#pragma optimize("a", off)

bool DSGraph::LoadPinByMediaType(DSPin &pPin1, DSFilter &pFilter1, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags, const DWORD dwMerit) {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMediaType() pPin1 = " << pPin1 << " pFilter1 = " << pFilter1), "");
    ASSERT(pPin1.GetGraph() == *this);
    ASSERT(pFilter1.GetGraph() == *this);

    GUID2* pInMedia = NULL;
    GUID2* pOutMedia = NULL;

    try {
        TRACEINDENT();
        // possibly in the future we should find all of the possible choices and
        // use the shortest available path.  but for now, we're just going to
        // find the first one that exists

        PIN_DIRECTION pd;
        HRESULT hr = pPin1->QueryDirection(&pd);
        if (FAILED(hr)) {
            TRACEOUTDENT();
            TRACELM(TRACE_ERROR, "DSGraph::LoadPinByMedium() can't query direction");
            THROWCOM(E_UNEXPECTED);
        }
		PIN_DIRECTION pd2;
		switch (pd) {
		case PINDIR_INPUT:
			pd2 = PINDIR_OUTPUT;
			break;
		case PINDIR_OUTPUT:
			pd2 = PINDIR_INPUT;
			break;
		}

        bool fInReq = false, fOutReq = false;
        DWORD dwIn = 0;
        DWORD dwOut = 0;
        GUID2** ppMediaList = NULL;
        DWORD dwMediaCount = 0;

        for (DSPin::iterator i = pPin1.begin(); i != pPin1.end(); ++i) {
            ++dwMediaCount;
        }
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMediaType() pindir = " << pd << " mediacount = " << dwMediaCount), "");

        switch (pd) {
        case PINDIR_INPUT:
            // hunting through graph from right to left
            fOutReq = true;
            dwOut = dwMediaCount;
            pOutMedia = new GUID2[dwOut * 2];
            ppMediaList = &pOutMedia;
            break;
        case PINDIR_OUTPUT:
            // hunting through graph from left to right
            fInReq = true;
            dwIn = dwMediaCount;
            pInMedia = new GUID2[dwIn * 2];
            ppMediaList = &pInMedia;

            break;
        }
        DWORD idx = 0;
        // note: some buggy filters don't support the reuse of an IEnumMediaTypes even though
        // reset succeeds.  they AV during the next pass through the enumerator.  thus, we
        // just create a new iterator which fetches a new IEnumMediaTypes interface(and underlying object)
        for (DSPin::iterator i2 = pPin1.begin(); i2 != pPin1.end(); ++i2) {
            (*ppMediaList)[idx++] = (*i2)->majortype;
            (*ppMediaList)[idx++] =  (*i2)->subtype;
        }

        TRACELM(TRACE_DETAIL, "DSGraph::LoadPinByMediaType()  dwFlags = " << hexdump(dwFlags) << " Merit = " << hexdump(dwMerit) << " MediaList = ");
        TRACEINDENT();
        for (idx = 0; idx < dwMediaCount; ++idx) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "major = " << (*ppMediaList)[idx * 2] << " sub = " << (*ppMediaList)[(idx * 2) + 1] ), "");
        }
        TRACEOUTDENT();

        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMediaType() fInReq = " << fInReq), "");
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSGraph::LoadPinByMediaType() fOutReq = " << fOutReq), "");

                // try normal first
        {DSFilterMapper fmr(PQFilterMapper(*this),
                       0,										// 0 flags
                       !(dwFlags & ALLOW_WILDCARDS),			// bExactMatch
                       dwMerit,						            // merit
                       fInReq,                                  // input required
                       dwIn,
                       pInMedia,
                       NULL,                                    // input medium
                       NULL,                                    // input pin cat
                       false,                                   // input rendered?
                       fOutReq,                                 // output required
                       dwOut,
                       pOutMedia,
                       NULL,                                    // output medium
                       NULL                                             // output pin cat
                      );
        if (fmr) {
            // direct connect
			for (DSFilterMapper::iterator i = fmr.begin(); i != fmr.end(); ++i) {
#ifdef ATTEMPT_DIRECT_CONNECT
				if (IsLoadable(pPin1, DSFilterMoniker(*i), pFilter1, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinDirect))) {
#else
				if (IsLoadable(pPin1, DSFilterMoniker(*i), pFilter1, IntermediatesAdded, dwFlags, ConnectPred_t(&DSGraph::ConnectPinByMediaType))) {
#endif
                    TRACEOUTDENT();
                    TRACELM(TRACE_ERROR, "DSGraph::LoadPinByMediaType() succeeded");
                    delete[] pInMedia;
                    delete[] pOutMedia;
					return true;
				}
			}
        }}
        TRACEOUTDENT();
	} catch(ComException& h) {
        TRACEOUTDENT();
		if ((h == E_UNEXPECTED) || 
			(h == HRESULT_FROM_WIN32(ERROR_DATATYPE_MISMATCH)) ||
			(h == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
			) {
			try {
                delete[] pInMedia;
                delete[] pOutMedia;
				TRACELM(TRACE_DEBUG, "DSGraph::LoadPinByMediaType() rethrowing");
			} catch(...) {
			}
			throw;
		}
		try {
			TRACELSM(TRACE_DEBUG, (dbgDump << "DSGraph::LoadPinByMediaType() suppressing HRESULT = " << hexdump(h)), "");
		} catch(...) {
		}
    } catch(...) {
        TRACEOUTDENT();
    }
    delete[] pInMedia;
    delete[] pOutMedia;
    TRACELM(TRACE_ERROR, "DSGraph::LoadPinByMediaType() failed");
    return false;
}

#endif //TUNING_MODEL_ONLY

// end of file - dsextend.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\devimpl.h ===
//==========================================================================;
//
// devimpl.h : additional infrastructure to support implementing IMSVidDevice 
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef DEVIMPL_H
#define DEVIMPL_H

#include "devsegimpl.h"

namespace MSVideoControl {

template<class T, LPCGUID LibID, LPCGUID Category, class MostDerivedInterface = IMSVidDevice>
    class DECLSPEC_NOVTABLE IMSVidDeviceImpl :         
    	public IDispatchImpl<MostDerivedInterface, &__uuidof(MostDerivedInterface), LibID>,
        public virtual CMSVidDeviceSegmentImpl {
public:
	    virtual ~IMSVidDeviceImpl() {}
    CComBSTR GetName(DSFilter& pF, DSFilterMoniker& pDev, CComBSTR& DefName) {
        if (pF) {
            CString csName(pF.GetName());
            if (!csName.IsEmpty()) {
                return CComBSTR(csName);
            }
        }
        if (pDev) {
            return pDev.GetName();
        }
        return DefName;
    }

	STDMETHOD(get_Status)(LONG * Status)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidDevice), CO_E_NOTINITIALIZED);
        }
		if (Status == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
	STDMETHOD(get_Power)(VARIANT_BOOL * Status)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidDevice), CO_E_NOTINITIALIZED);
        }
		if (Status == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
	STDMETHOD(put_Power)(VARIANT_BOOL Status)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidDevice), CO_E_NOTINITIALIZED);
        }
		return E_NOTIMPL;
	}
	STDMETHOD(get_Category)(BSTR *guid)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidDevice), CO_E_NOTINITIALIZED);
        }

        if (!guid) {
            return E_POINTER;
        }
        try {
            GUID2 g(Category);
            *guid = g.GetBSTR();
        } catch(...) {
            return E_UNEXPECTED;
        }
		return NOERROR;
	}
	STDMETHOD(get__Category)(GUID* guid)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidDevice), CO_E_NOTINITIALIZED);
        }

        if (!guid) {
            return E_POINTER;
        }
        try {
            memcpy(guid, Category, sizeof(GUID));
        } catch(...) {
            return E_UNEXPECTED;
        }
		return NOERROR;
	}

	STDMETHOD(get_ClassID)(BSTR *guid)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidDevice), CO_E_NOTINITIALIZED);
        }

        if (!guid) {
            return E_POINTER;
        }
        try {
            GUID2 g(__uuidof(T));
            *guid = g.GetBSTR();
        } catch(...) {
            return E_UNEXPECTED;
        }

		return NOERROR;
	}
	STDMETHOD(get__ClassID)(GUID* guid)
	{
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidDevice), CO_E_NOTINITIALIZED);
        }

        if (!guid) {
            return E_POINTER;
        }
        try {
            memcpy(guid, &__uuidof(T), sizeof(GUID));
        } catch(...) {
            return E_UNEXPECTED;
        }

		return NOERROR;
	}
    STDMETHOD(IsEqualDevice)(IMSVidDevice *pDev, VARIANT_BOOL* pfAnswer) {
        if (!pDev || !pfAnswer) {
            return E_POINTER;
        }
        try {
            *pfAnswer = VARIANT_FALSE;
            PUnknown pt(this);
            PUnknown pd(pDev);
            if (pt == pd) {
                *pfAnswer = VARIANT_TRUE;
                return NOERROR;
            }
            GUID2 gt, gd;
            HRESULT hr = get__ClassID(&gt);
            if (FAILED(hr)) {
                return E_UNEXPECTED;
            }
            hr = pDev->get__ClassID(&gd);
            if (FAILED(hr)) {
                return E_UNEXPECTED;
            }
            if (gd != gt) {
                return S_FALSE;
            }
            PQGraphSegment pst(this), pdt(pDev);
            PUnknown pit, pid;
            hr = pst->get_Init(&pit);
            if (FAILED(hr)) {
                pit.Release();
            }
            hr = pdt->get_Init(&pid);
            if (FAILED(hr)) {
                pid.Release();
            }
            if (pit == pid) {
                *pfAnswer = VARIANT_TRUE;
                return NOERROR;
            }   
            PQMoniker pmt(pit), pmd(pid);
            if (!pmt || !pmd) {
                // we don't know how to deal with init data that isn't a moniker
                return S_FALSE;
            }
            PQMalloc pmalloc;
            hr = CoGetMalloc(1, &pmalloc);
            if (FAILED(hr)) {
                return E_UNEXPECTED;
            }
            LPOLESTR pnt, pnd;
            hr = pmt->GetDisplayName(NULL, NULL, &pnt);
            if (FAILED(hr)) {
                return S_FALSE;
            }
            hr = pmd->GetDisplayName(NULL, NULL, &pnd);
            if (FAILED(hr)) {
                pmalloc->Free(pnt);
                return S_FALSE;
            }
            int rc = wcscmp(pnt, pnd);
            pmalloc->Free(pnt);
            pmalloc->Free(pnd);
            if (rc) {
                return S_FALSE;
            }
            *pfAnswer = VARIANT_TRUE;
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

};

}; // namespace

#endif
// end of file - devimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\dvbstsimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBtsimpl.h : 
// Copyright (c) Microsoft Corporation 1999.

#ifndef DVBSTSIMPL_H
#define DVBSTSIMPL_H

#include "dvbtsimpl.h"

namespace BDATuningModel {

template<class T,
         class TUNEREQUESTTYPE = CDVBTuneRequest,
         class MostDerived = IDVBSTuningSpace, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IDVBSTuningSpaceImpl : 
	public IDVBTuningSpaceImpl<T, TUNEREQUESTTYPE, MostDerived, iid, 
                               LibID, wMajor, wMinor, tihclass>
{
public:

    long m_HiOsc;
    long m_LoOsc;
    long m_LNBSwitch;
    CComBSTR m_InputRange;
    SpectralInversion m_SpectralInversion;

    IDVBSTuningSpaceImpl() : m_HiOsc(-1), m_LoOsc(-1), m_LNBSwitch(-1), m_InputRange(0), m_SpectralInversion(BDA_SPECTRAL_INVERSION_NOT_SET), 
                             IDVBTuningSpaceImpl<T, TUNEREQUESTTYPE, MostDerived, iid, 
                                                 LibID, wMajor, wMinor, tihclass>(DVB_Satellite) {}
    virtual ~IDVBSTuningSpaceImpl() {}
    typedef IDVBTuningSpaceImpl<T, TUNEREQUESTTYPE, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    
    BEGIN_PROP_MAP(IDVBSTuningSpaceImpl)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("High Oscillator Frequency", m_HiOsc, VT_I4)
        PROP_DATA_ENTRY("Low Oscillator Frequency", m_LoOsc, VT_I4)
        PROP_DATA_ENTRY("LNB Switch Frequency", m_LNBSwitch, VT_I4)
        PROP_DATA_ENTRY("Input Range", m_InputRange.m_str, VT_BSTR_BLOB)
        PROP_DATA_ENTRY("Spectral Inversion", m_SpectralInversion, VT_I4)
    END_PROPERTY_MAP()

// IDVBSTS
    STDMETHOD(put_SystemType)(DVBSystemType NewSysType)
    {
        if (NewSysType != DVB_Satellite) {
            return DISP_E_TYPEMISMATCH;
        }
		ATL_LOCKT();
        m_SystemType = NewSysType;
        MARK_DIRTY(T);

	    return NOERROR;
    }


    STDMETHOD(get_HighOscillator)(long *pHiOsc)
    {
        try {
            if (!pHiOsc) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pHiOsc = m_HiOsc;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_HighOscillator)(long NewHiOsc)
    {
		ATL_LOCKT();
        m_HiOsc = NewHiOsc;
        MARK_DIRTY(T);

	    return NOERROR;
    }

    STDMETHOD(get_LowOscillator)(long *pLoOsc)
    {
        try {
            if (!pLoOsc) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pLoOsc = m_LoOsc;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_LowOscillator)(long NewLoOsc)
    {
		ATL_LOCKT();
        m_LoOsc = NewLoOsc;
        MARK_DIRTY(T);

	    return NOERROR;
    }

    STDMETHOD(get_LNBSwitch)(long *pLNBSwitch)
    {
        try {
            if (!pLNBSwitch) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pLNBSwitch = m_LNBSwitch;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_LNBSwitch)(long NewLNBSwitch)
    {
		ATL_LOCKT();
        m_LNBSwitch = NewLNBSwitch;
        MARK_DIRTY(T);

	    return NOERROR;
    }

    STDMETHOD(get_InputRange)(BSTR *pInputRange)
    {
        try {
            if (!pInputRange) {
                return E_POINTER;
            }
			ATL_LOCKT();
            return m_InputRange.CopyTo(pInputRange);
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_InputRange)(BSTR NewInputRange)
    {
		CHECKBSTRLIMIT(NewInputRange);
		ATL_LOCKT();
        m_InputRange = &NewInputRange;
        MARK_DIRTY(T);

	    return NOERROR;
    }

    STDMETHOD(get_SpectralInversion)(SpectralInversion *pSpectralInversion)
    {
        try {
            if (!pSpectralInversion) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pSpectralInversion = m_SpectralInversion;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_SpectralInversion)(SpectralInversion NewSpectralInversion)
    {
		ATL_LOCKT();
        m_SpectralInversion = NewSpectralInversion;
        MARK_DIRTY(T);

	    return NOERROR;
    }

    STDMETHOD(Clone) (ITuningSpace **ppTS) {
        try {
			if (!ppTS) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppTS);
			if (FAILED(hr)) {
				return hr;
			}
			T* pt = static_cast<T*>(*ppTS);
            pt->m_HiOsc = m_HiOsc;
            pt->m_LoOsc = m_LoOsc;
            pt->m_LNBSwitch = m_LNBSwitch;
            pt->m_InputRange = m_InputRange;
            pt->m_SpectralInversion = m_SpectralInversion;
			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}

};

}; // namespace

#endif // DVBSTSIMPL_H
// end of file -- DVBtsimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\dvbslocatorimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBSLocatorimpl.h : implementation helper template for DVBSlocator interface
// Copyright (c) Microsoft Corporation 2000.

#ifndef DVBSLOCATORIMPL_H
#define DVBSLOCATORIMPL_H

#include <locatorimpl.h>

namespace BDATuningModel {

template<class T,
         class MostDerived = IDVBSLocator, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IDVBSLocatorImpl : 
	public ILocatorImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// IDVBSLocator
public:

	typedef ILocatorImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    typedef IDVBSLocatorImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> thistype;

	Polarisation m_SignalPolarisation;
	VARIANT_BOOL m_WestPosition;
	long m_OrbitalPosition;
	long m_Azimuth;
	long m_Elevation;

	IDVBSLocatorImpl() : m_SignalPolarisation(BDA_POLARISATION_NOT_SET),
						 m_WestPosition(VARIANT_TRUE),
						 m_OrbitalPosition(-1),
						 m_Azimuth(-1),
						 m_Elevation(-1) {}
    virtual ~IDVBSLocatorImpl() {}
    BEGIN_PROP_MAP(thistype)
        CHAIN_PROP_MAP(basetype)
		PROP_DATA_ENTRY("Polarisation",  m_SignalPolarisation, VT_I4)
		PROP_DATA_ENTRY("OrbitalPosition", m_OrbitalPosition, VT_I4)
		PROP_DATA_ENTRY("Azimuth", m_Azimuth, VT_I4)
		PROP_DATA_ENTRY("Elevation", m_Elevation, VT_I4)
		PROP_DATA_ENTRY("WestPosition", m_WestPosition, VT_BOOL)
    END_PROP_MAP()

// IDVBSLocator
public:
    STDMETHOD(get_SignalPolarisation)(/*[out, retval]*/ Polarisation *pSignalPolarisation) {
        try {
            if (!pSignalPolarisation) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pSignalPolarisation = m_SignalPolarisation;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_SignalPolarisation)(/*[in]*/ Polarisation NewSignalPolarisation) {
		ATL_LOCKT();
        m_SignalPolarisation = NewSignalPolarisation;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_WestPosition)(/*[out, retval]*/ VARIANT_BOOL *pWestPosition) {
        try {
            if (!pWestPosition) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pWestPosition = m_WestPosition;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_WestPosition)(/*[in]*/ VARIANT_BOOL NewWestPosition) {
		ATL_LOCKT();
        m_WestPosition = NewWestPosition;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_OrbitalPosition)(/*[out, retval]*/ long *pOrbitalPosition) {
        try {
            if (!pOrbitalPosition) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pOrbitalPosition = m_OrbitalPosition;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_OrbitalPosition)(/*[in]*/ long NewOrbitalPosition) {
		ATL_LOCKT();
        m_OrbitalPosition = NewOrbitalPosition;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_Azimuth)(/*[out, retval]*/ long *pAzimuth) {
        try {
            if (!pAzimuth) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pAzimuth = m_Azimuth;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_Azimuth)(/*[in]*/ long NewAzimuth) {
		ATL_LOCKT();
        m_Azimuth = NewAzimuth;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_Elevation)(/*[out, retval]*/ long *pElevation) {
        try {
            if (!pElevation) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pElevation = m_Elevation;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_Elevation)(/*[in]*/ long NewElevation) {
		ATL_LOCKT();
        m_Elevation = NewElevation;
        MARK_DIRTY(T);

	    return NOERROR;
    }
	STDMETHOD(Clone) (ILocator **ppNew) {
		try {
			if (!ppNew) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppNew);
			if (FAILED(hr)) {
				return hr;
			}
            T* pt = static_cast<T*>(*ppNew);
			pt->m_SignalPolarisation = m_SignalPolarisation;
			pt->m_WestPosition = m_WestPosition;
			pt->m_OrbitalPosition = m_OrbitalPosition;
			pt->m_Azimuth = m_Azimuth;
			pt->m_Elevation = m_Elevation;

			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}
};

typedef CComQIPtr<IDVBSLocator> PQDVBSLocator;

}; // namespace

#endif // DVBSLOCATORIMPL_H
// end of file -- DVBSlocatorimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\dvbtlocatorimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBTLocatorimpl.h : implementation helper template for ATSClocator interface
// Copyright (c) Microsoft Corporation 2000.

#ifndef DVBTLOCATORIMPL_H
#define DVBTLOCATORIMPL_H

#include <locatorimpl.h>

namespace BDATuningModel {

template<class T,
         class MostDerived = IDVBTLocator, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IDVBTLocatorImpl : 
	public ILocatorImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// IDVBTLocator
public:

	typedef ILocatorImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    typedef IDVBTLocatorImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> thistype;

	IDVBTLocatorImpl() : m_Bandwidth(-1),
						 m_LPInnerFECMethod(BDA_FEC_METHOD_NOT_SET),
						 m_LPInnerFECRate(BDA_BCC_RATE_NOT_SET),
						 m_HAlpha(BDA_HALPHA_NOT_SET),
						 m_GuardInterval(BDA_GUARD_NOT_SET),
						 m_XmitMode(BDA_XMIT_MODE_NOT_SET),
						 m_OtherFreqInUse(VARIANT_FALSE) {}

    virtual ~IDVBTLocatorImpl() {}
	long m_Bandwidth;
	FECMethod m_LPInnerFECMethod;
	BinaryConvolutionCodeRate m_LPInnerFECRate;
	HierarchyAlpha m_HAlpha;
	GuardInterval m_GuardInterval;
	TransmissionMode m_XmitMode;
	VARIANT_BOOL m_OtherFreqInUse;

    BEGIN_PROP_MAP(thistype)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("Bandwidth", m_Bandwidth, VT_I4)
        PROP_DATA_ENTRY("LPInnerFECMethod", m_LPInnerFECMethod, VT_I4)
        PROP_DATA_ENTRY("LPInnerFECRate", m_LPInnerFECRate, VT_I4)
        PROP_DATA_ENTRY("HierarchyAlpha", m_HAlpha, VT_I4)
        PROP_DATA_ENTRY("GuardInterval", m_GuardInterval, VT_I4)
        PROP_DATA_ENTRY("TransmissionMode", m_XmitMode, VT_I4)
        PROP_DATA_ENTRY("OtherFrequencyInUse", m_OtherFreqInUse, VT_BOOL)
    END_PROP_MAP()

// IDVBTLocator
public:
    STDMETHOD(get_Bandwidth)(/*[out, retval]*/ long *pBandwidth) {
        try {
            if (!pBandwidth) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pBandwidth = m_Bandwidth;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_Bandwidth)(/*[in]*/ long NewBandwidth) {
		ATL_LOCKT();
        m_Bandwidth = NewBandwidth;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_LPInnerFEC)(/*[out, retval]*/ FECMethod *pLPInnerFECMethod) {
        try {
            if (!pLPInnerFECMethod) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pLPInnerFECMethod = m_LPInnerFECMethod;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_LPInnerFEC)(/*[in]*/ FECMethod NewLPInnerFECMethod) {
		ATL_LOCKT();
        m_LPInnerFECMethod = NewLPInnerFECMethod;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_LPInnerFECRate)(/*[out, retval]*/ BinaryConvolutionCodeRate *pLPInnerFECRate) {
        try {
            if (!pLPInnerFECRate) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pLPInnerFECRate = m_LPInnerFECRate;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_LPInnerFECRate)(/*[in]*/ BinaryConvolutionCodeRate NewLPInnerFECRate) {
		ATL_LOCKT();
        m_LPInnerFECRate = NewLPInnerFECRate;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_HAlpha)(/*[out, retval]*/ HierarchyAlpha *pHierarchyAlpha) {
        try {
            if (!pHierarchyAlpha) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pHierarchyAlpha = m_HAlpha;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_HAlpha)(/*[in]*/ HierarchyAlpha NewHierarchyAlpha) {
		ATL_LOCKT();
        m_HAlpha = NewHierarchyAlpha;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_Guard)(/*[out, retval]*/ GuardInterval *pGuardInterval) {
        try {
            if (!pGuardInterval) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pGuardInterval = m_GuardInterval;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_Guard)(/*[in]*/ GuardInterval NewGuardInterval) {
		ATL_LOCKT();
        m_GuardInterval = NewGuardInterval;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_Mode)(/*[out, retval]*/ TransmissionMode *pTransmissionMode) {
        try {
            if (!pTransmissionMode) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pTransmissionMode = m_XmitMode;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_Mode)(/*[in]*/ TransmissionMode NewTransmissionMode) {
		ATL_LOCKT();
        m_XmitMode = NewTransmissionMode;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_OtherFrequencyInUse)(/*[out, retval]*/ VARIANT_BOOL *pOtherFrequencyInUse) {
        try {
            if (!pOtherFrequencyInUse) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pOtherFrequencyInUse = m_OtherFreqInUse;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_OtherFrequencyInUse)(/*[in]*/ VARIANT_BOOL NewOtherFrequencyInUse) {
		ATL_LOCKT();
        m_OtherFreqInUse = NewOtherFrequencyInUse;
        MARK_DIRTY(T);

	    return NOERROR;
    }
	STDMETHOD(Clone) (ILocator **ppNew) {
		try {
			if (!ppNew) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppNew);
			if (FAILED(hr)) {
				return hr;
			}
            T* pt = static_cast<T*>(*ppNew);
			pt->m_Bandwidth = m_Bandwidth;
	        pt->m_LPInnerFECMethod = m_LPInnerFECMethod;;
            pt->m_LPInnerFECRate = m_LPInnerFECRate;
			pt->m_HAlpha = m_HAlpha;
			pt->m_GuardInterval = m_GuardInterval;
			pt->m_XmitMode = m_XmitMode;
			pt->m_OtherFreqInUse = m_OtherFreqInUse;

    

			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}
};

typedef CComQIPtr<IDVBTLocator> PQDVBTLocator;

}; // namespace

#endif // DVBTLOCATORIMPL_H
// end of file -- DVBTLocatorimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\dsextend.h ===
//==========================================================================;
//
// dsextend.h : additional infrastructure to extend the dshow stuff so that it
// works nicely from c++
// Copyright (c) Microsoft Corporation 1995-1999.
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef DSEXTEND_H
#define DSEXTEND_H

#include <algorithm>
#include <functional>
#include <utility>
#include <vector>
#include <list>
#include <map>
#include <trace.h>
#include <throw.h>
#include <stextend.h>
#include <w32extend.h>
#include <ksextend.h>
#include <fwdseq.h>
#include <control.h>
#include <mpconfig.h>
#include <vptype.h>
#include <vpnotify.h>
#include <il21dec.h>
#include <mtype.h>
#include <tuner.h>
#include <bdaiface.h>
#include <errors.h>
#include <winerror.h>
#include <evcode.h>

struct DECLSPEC_NOVTABLE DECLSPEC_UUID("6E8D4A21-310C-11d0-B79A-00AA003767A7") IAMLine21Decoder;

#define LINE21_BY_MAGIC
#define FILTERDATA

// #define ATTEMPT_DIRECT_CONNECT
// we'd like to check to see if two filters can be connected by just trying to connect them
// this is less work and techinically more accurate since pins aren't required to enumerate all
// of the media types they potentiall could support.
// however, this exposes bugs in the filters and causes random hangs and crashes.  instead
// we manually check mediums and media types and only attempt the connection when we find a match.
// this turns out to be much more stable. 


//#define FORWARD_TRACE

const PIN_DIRECTION DOWNSTREAM = PINDIR_OUTPUT;
const PIN_DIRECTION UPSTREAM = PINDIR_INPUT;


typedef CComQIPtr<IFileSourceFilter, &IID_IFileSourceFilter> PQFileSourceFilter;
#ifndef POLYMORPHIC_TUNERS
typedef CComQIPtr<IAMTVTuner, &IID_IAMTVTuner> PQTVTuner;
//typedef CComQIPtr<ISatelliteTuner, &IID_ISatelliteTuner> PQSatelliteTuner;
#else
typedef CComQIPtr<IAMTuner, &IID_IAMTuner> PQTuner;
typedef CComQIPtr<IAMTVTuner, &IID_IAMTVTuner> PQTVTuner;
typedef CComQIPtr<IBPCSatelliteTuner, &IID_IBPCSatelliteTuner> PQSatelliteTuner;
#endif
#if 0
typedef CComQIPtr<IVideoWindow, &IID_IVideoWindow> PQVideoWindow;
typedef CComQIPtr<IBasicVideo, &IID_IBasicVideo> PQBasicVideo;
#else
typedef CComQIPtr<IVMRWindowlessControl, &IID_IVMRWindowlessControl> PQVMRWindowlessControl;
#endif

typedef CComQIPtr<IPin, &IID_IPin> PQPin;
typedef CComQIPtr<IBaseFilter, &IID_IBaseFilter> PQFilter;
typedef CComQIPtr<IFilterInfo, &IID_IFilterInfo> PQFilterInfo;
typedef CComQIPtr<IEnumPins, &IID_IEnumPins> PQEnumPins;
typedef CComQIPtr<IEnumFilters, &IID_IEnumFilters> PQEnumFilters;
typedef CComQIPtr<IBasicAudio, &IID_IBasicAudio> PQBasicAudio;
typedef CComQIPtr<IAMCrossbar, &IID_IAMCrossbar> PQCrossbarSwitch;
typedef CComQIPtr<IMediaEventEx, &IID_IMediaEventEx> PQMediaEventEx;
typedef CComQIPtr<IMediaControl, &IID_IMediaControl> PQMediaControl;
typedef CComQIPtr<IMediaPosition, &IID_IMediaPosition> PQMediaPosition;
typedef CComQIPtr<IMediaSeeking, &IID_IMediaSeeking> PQMediaSeeking;
typedef CComQIPtr<IGraphBuilder, &IID_IGraphBuilder> PQGraphBuilder;
typedef CComQIPtr<ICreateDevEnum, &IID_ICreateDevEnum> PQCreateDevEnum;
typedef CComQIPtr<IEnumMoniker, &IID_IEnumMoniker> PQEnumMoniker;
typedef CComQIPtr<IFilterMapper2, &IID_IFilterMapper2> PQFilterMapper;
typedef CComQIPtr<IEnumMediaTypes, &IID_IEnumMediaTypes> PQEnumMediaTypes;
typedef CComQIPtr<IAMAnalogVideoDecoder, &IID_IAMAnalogVideoDecoder> PQAnalogVideoDecoder;
typedef CComQIPtr<IMixerPinConfig, &IID_IMixerPinConfig> PQMixerPinConfig;
typedef CComQIPtr<IAMAudioInputMixer, &IID_IAMAudioInputMixer> PQAudioInputMixer;
typedef CComQIPtr<IAMLine21Decoder, &IID_IAMLine21Decoder> PQLine21Decoder;
typedef CComQIPtr<IVPNotify2, &IID_IVPNotify2> PQVPNotify2;
typedef CComQIPtr<ITuner> PQBDATuner;
typedef CComQIPtr<IBDA_IPSinkControl> PQBDA_IPSinkControl;
typedef CComQIPtr<IDvdControl, &IID_IDvdControl> PQDVDNavigator;
typedef CComQIPtr<IVideoFrameStep> PQVideoFrameStep;
typedef CComQIPtr<IMediaEventSink> PQMediaEventSink;
typedef CComQIPtr<IVMRMonitorConfig> PQVMRMonitorConfig;
typedef CComQIPtr<IDirectDraw7, &IID_IDirectDraw7> PQDirectDraw7;
typedef CComQIPtr<IRegisterServiceProvider, &IID_IRegisterServiceProvider> PQRegisterServiceProvider;
typedef std::vector<GUID2> MediaMajorTypeList;

#if 0
typedef std::pair<PQCrossbarSwitch, long> PQBasePoint;

inline void clear(PQBasePoint &p) {p.first.Release(); p.second = 0;}
class PQPoint : public PQBasePoint {
public:
        //PQBasePoint p;
		inline PQPoint() :  PQBasePoint(PQCrossbarSwitch(), 0) {}
        inline PQPoint(const PQBasePoint &p2) : PQBasePoint(p2) {}
        inline PQPoint(const PQPoint &p2) : PQBasePoint(p2) {}
        inline PQPoint(const PQCrossbarSwitch &s, long i) : PQBasePoint(s, i) {}
        virtual ~PQPoint() { ::clear(*this); }
        inline void clear(void) { ::clear(*this); }
};
#else
typedef std::pair<PQCrossbarSwitch, long> PQPoint;
#endif

class CDevices;
class DSFilter;
class DSPin;
typedef std::vector< DSFilter, stl_smart_ptr_allocator<DSFilter> > DSFilterList;
typedef std::vector< DSPin, stl_smart_ptr_allocator<DSPin> > DSPinList;

typedef std::pair< DSFilter, CString> DSFilterID;
typedef std::vector< DSFilterID > DSFilterIDList;

typedef PQPoint XBarInputPoint, PQInputPoint;
typedef PQPoint XBarOutputPoint, PQOutputPoint;
typedef PQPoint XBarPoint;

typedef std::pair<XBarInputPoint, XBarOutputPoint> CIOPoint;
typedef std::list<CIOPoint> VWGraphPath;

class VWStream : public VWGraphPath {
public:
    //PQBasePoint p;
    VWStream() {}
    VWStream(const VWGraphPath &p2) : VWGraphPath(p2) {}
    VWStream(const VWStream &p2) : VWGraphPath(p2) {}
    virtual ~VWStream() {}
    void Route(void);
};

typedef std::list<VWStream> VWStreamList;

#ifdef _DEBUG
class DSREGPINMEDIUM;
class DSMediaType;
inline tostream &operator<<(tostream &dc, const DSREGPINMEDIUM &g);
inline tostream& operator<<(tostream &d, const PQPin &pin);
inline tostream &operator<<(tostream &dc, const DSREGPINMEDIUM &g);
inline tostream& operator<<(tostream &d, const PQPin &pin);
inline tostream& operator<<(tostream &d, const _AMMediaType *pmt);
#endif


// AM_MEDIA_TYPE:
//    GUID      majortype;
//    GUID      subtype;
//    BOOL      bFixedSizeSamples;
//    BOOL      bTemporalCompression;
//    ULONG     lSampleSize;
//    GUID      formattype;
//    IUnknown  *pUnk;
//    ULONG     cbFormat;

#define GUID0 0L, 0, 0, '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0'
const AM_MEDIA_TYPE NULL_AMMEDIATYPE = {
    GUID0,
    GUID0,
    0,
    0,
    0L,
    GUID0,
    NULL,
    0L
};


// this is basically a CComQIPtr with allocate/copy semantics instead of
// refcount semantics and without the QI stuff.
// i don't know why they didn't just implement media types as an
// com object with an IMediaType interface instead of this weird alloc stuff

// REV2: investigate inheriting from CMediaType class in mtype.h.  but, i'm not using anything
// from the filter implementation class hierarchy.  and, i'd like to keep this interface division
// clean.  right now we only use dshow sdk \include which is the external interface stuff.
class DSMediaType {
public:
    AM_MEDIA_TYPE *p;

    inline DSMediaType() : p(NULL) {}
    DSMediaType(GUID majortype, GUID subtype = GUID_NULL, GUID formattype = GUID_NULL) : p(NULL) {
        try {
            p = CreateMediaType(&NULL_AMMEDIATYPE);
            if (p) {
                p->majortype            = majortype;
                p->subtype              = subtype;
                p->formattype           = formattype;
            }
        } catch(...) {
            TRACELM(TRACE_ERROR, "DSMediaType::DSMediaType(const DSMediaType) Exception");
        }
    }
    DSMediaType(const DSMediaType &d) : p(NULL) {
        try {
            if (d.p) {
                p = CreateMediaType(d.p);
            }
        } catch(...) {
            TRACELM(TRACE_ERROR, "DSMediaType::DSMediaType(const DSMediaType) Exception");
        }
    }
    DSMediaType(int a) : p(NULL) {}
    ~DSMediaType() {
        try {
            if (p) {
                DeleteMediaType(p);
                p = NULL;
            }
        } catch(...) {
            TRACELM(TRACE_ERROR, "DSMediaType::~DSMediaType() Exception");
        }
    }

    inline operator AM_MEDIA_TYPE*() const {return p;}
    inline AM_MEDIA_TYPE& operator*() const {_ASSERTE(p!=NULL); return *p; }
    inline AM_MEDIA_TYPE ** operator&() {ASSERT(p == NULL); return &p; }
    inline AM_MEDIA_TYPE * operator->() const {_ASSERTE(p!=NULL); return p; }
    inline DSMediaType * address(void) { return this; }
    inline const DSMediaType * const_address(void) const { return this; }
	typedef stl_smart_ptr_allocator<DSMediaType> stl_allocator;
    DSMediaType& operator=(const AM_MEDIA_TYPE &d) {
        if (&d != p) {
            try {
                if (p) {
                    DeleteMediaType(p);
                    p = NULL;
                }
                if (&d) {
                    p = CreateMediaType(&d);
                }
            } catch(...) {
                TRACELM(TRACE_ERROR, "DSMediaType::operator=(const AM_MEDIA_TYPE &) Exception");
            }
        }
        return *this;
    }
    DSMediaType& operator=(const AM_MEDIA_TYPE *pd) {
        try {
            if (pd != p) {
                if (p) {
                    DeleteMediaType(p);
                    p = NULL;
                }
                if (pd) {
                    p = CreateMediaType(pd);
                }
            }
        } catch(...) {
            TRACELM(TRACE_ERROR, "DSMediaType::operator=(const AM_MEDIA_TYPE *) Exception");
        }
        return *this;
    }
    DSMediaType& operator=(const DSMediaType &d) {
        try {
            if (d.const_address() != this) {
                if (p) {
                    DeleteMediaType(p);
                    p = NULL;
                }
                if (d.p) {
                    p = CreateMediaType(d.p);
                }
            }
        } catch(...) {
            TRACELM(TRACE_ERROR, "DSMediaType::operator=(DSMediaType &)Exception");
        }
        return *this;
    }
    DSMediaType& operator=(int d) {
        ASSERT(d == 0);
        try {
            if (p) {
                DeleteMediaType(p);
                p = NULL;
            }
        } catch(...) {
            TRACELM(TRACE_ERROR, "DSMediaType::operator=(int) Exception");
        }
        return *this;
    }

    inline bool operator==(const DSMediaType &d) const {
        if (!p && !d.p) {
            // both null then they're the same
            return true;
        }
        if (!p || !d.p) {
            // if either one null but not both then they aren't the same
            return false;
        }
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSMediaType::operator==() this = " << *this << " d = " << d), "");
        return p->majortype == d.p->majortype &&
               (p->subtype == GUID_NULL || d.p->subtype == GUID_NULL || p->subtype == d.p->subtype);
    }
    inline bool operator==(const AM_MEDIA_TYPE &d) const {
        if (!p && !&d) {
            return true;
        }
        return p && (&d) && p->majortype == d.majortype &&
               (p->subtype == GUID_NULL || d.subtype == GUID_NULL || p->subtype == d.subtype);
    }
    inline bool operator==(const AM_MEDIA_TYPE *d) const {
        if (!p && !d) {
            return true;
        }
        return p && d && p->majortype == d->majortype &&
               (p->subtype == GUID_NULL || d->subtype == GUID_NULL || p->subtype == d->subtype);
    }
    inline bool operator!=(const DSMediaType &d) const {
        return !(*this == d);
    }
    inline bool operator!() const {
        return (p == NULL);
    }
    inline bool MatchingMajor(const AM_MEDIA_TYPE *prhs) const {
		if (!p && !prhs) {
			return true;
		}
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSMediaType::MatchingMajor() this = " << *this << "\rprhs = " << prhs), "");
        return p && prhs && p->majortype == prhs->majortype;
    }
    inline bool MatchingMajor(const DSMediaType &rhs) const {
        return MatchingMajor(rhs.p);
    }

#ifdef _DEBUG
	inline tostream& operator<<(tostream &d) {
		d << p;
		if (p) {
			d << _T(" major = ") << GUID2(p->majortype) << _T(" sub = ") << GUID2(p->subtype);
		}
		return d;
	}
#endif
};

class DSFilterMoniker : public W32Moniker {
public:
    inline DSFilterMoniker() {}
    inline DSFilterMoniker(const PQMoniker &a) : W32Moniker(a) {}
    inline DSFilterMoniker(const W32Moniker &a) : W32Moniker(a) {}
    inline DSFilterMoniker(IMoniker *p) : W32Moniker(p) {}
    inline DSFilterMoniker(IUnknown *p) : W32Moniker(p) {}
    inline DSFilterMoniker(const DSFilterMoniker &a) : W32Moniker(a) {}

    CComBSTR GetName() const {
        CComVariant vName;
        vName.vt = VT_BSTR;
        HRESULT hr = (GetPropertyBag())->Read(OLESTR("FriendlyName"), &vName, NULL);
        if (FAILED(hr)) {
            TRACELM(TRACE_ERROR, "DSFilterMoniker::GetName() can't read friendly name");
            return CComBSTR();
        }
        USES_CONVERSION;
        ASSERT(vName.vt == VT_BSTR);
        CComBSTR Name(vName.bstrVal);
        return Name;
    }
    DSFilter GetFilter() const;
};

typedef Forward_Sequence<
    PQCreateDevEnum,
    PQEnumMoniker,
    DSFilterMoniker,
    ICreateDevEnum,
    IEnumMoniker,
    IMoniker*> DSDeviceSequence;

typedef Forward_Sequence<
    PQFilterMapper,
    PQEnumMoniker,
    DSFilterMoniker,
    IFilterMapper2,
    IEnumMoniker,
    IMoniker*> DSFilterMapperSequence;

typedef Forward_Sequence<
    PQPin,
    PQEnumMediaTypes,
    DSMediaType,
    IPin,
    IEnumMediaTypes,
    AM_MEDIA_TYPE*> DSPinSequence;

class DSGraph;

class DSPin : public DSPinSequence {
public:
    DSPin() {}
    DSPin(const PQPin &a) : DSPinSequence(a) {}
    DSPin(IPin *p) : DSPinSequence(p) {}
    DSPin(IUnknown *p) : DSPinSequence(p) {}
    DSPin(const DSPin &a) : DSPinSequence(a) {}

    CString GetName() const {
        CString csPinName;
        PIN_INFO pinfo;
        HRESULT hr = (*this)->QueryPinInfo(&pinfo);
        if (SUCCEEDED(hr)) {
            csPinName = pinfo.achName;
            if (pinfo.pFilter) pinfo.pFilter->Release();
        }
        return csPinName;
    }

    PIN_DIRECTION GetDirection() const {
        PIN_DIRECTION pin1dir;
        HRESULT hr = (*this)->QueryDirection(&pin1dir);
        if (FAILED(hr)) {
            TRACELM(TRACE_ERROR, "DSPin::GetDirection() can't call QueryDirection");
            THROWCOM(E_UNEXPECTED);
        }
        return pin1dir;
    }

    bool IsConnected() const {
        return GetConnection() != DSPin();
    }

	bool IsRenderable() {
		CString csName(GetName());
		if (!csName.IsEmpty() && csName.GetAt(0) == '~') {
			return false;
		}
		return true;
	}
    bool IsInput() const {
        return GetDirection() == PINDIR_INPUT;
    }
    static inline bool IsInput(const DSPin pin) {
        PIN_DIRECTION pin1dir = pin.GetDirection();
        return pin1dir == PINDIR_INPUT;
    }
    bool IsKsProxied() const;
    HRESULT GetMediums(KSMediumList &MediumList) const {
        TRACELSM(TRACE_DETAIL, (dbgDump << "DSPin::GetMediums() " << this), "");
        PQKSPin pin(*this);
        if (!pin) {
            TRACELM(TRACE_DETAIL, "DSPin::GetMedium() can't get IKsPin");
            return E_FAIL;
        }
        HRESULT hr = pin->KsQueryMediums(&MediumList);
        // undone: in win64 mediumlist.size is really __int64.  fix output operator for
        // that type and remove cast
        TRACELSM(TRACE_DETAIL, (dbgDump <<
            "DSPin::GetMediums() hr = " <<
            hr <<
            " size = " <<
            (long) MediumList.size()), "");
        return hr;
    }

    static inline bool HasCategory(DSPin& pin, const GUID2 &clsCategory, const PIN_DIRECTION pd) {
        return pin.HasCategory(clsCategory, pd);
    }

    static inline bool HasCategory(DSPin& pin, const GUID2 &clsCategory) {
        return pin.HasCategory(clsCategory);
    }

    void GetCategory(CLSID &clsCategory) const {
        ULONG outcount;

        PQKSPropertySet ps(*this);
        if (!ps) {
            TRACELM(TRACE_ERROR, "DSPin::GetCategory() can't get IKsPropertySet");
            clsCategory = GUID_NULL;
            return;
        }

        HRESULT hr = ps->Get(AMPROPSETID_Pin, AMPROPERTY_PIN_CATEGORY,
                             NULL, 0, &clsCategory, sizeof(clsCategory), &outcount);
        if (FAILED(hr)) {
            TRACELSM(TRACE_ERROR, (dbgDump << "DSPin::GetCategory() can't get pin category hr = " << hr), "");
            clsCategory = GUID_NULL;
        }
        return;
    }
    DSPin GetConnection(void) const {
        DSPin pConn;
        HRESULT hr = (*this)->ConnectedTo(&pConn);
        if (FAILED(hr) || !pConn) {
            return DSPin();
        }
#ifdef _DEBUG
        DSPin pConn2;
        hr = pConn->ConnectedTo(&pConn2);
        if (FAILED(hr) || pConn2.IsEqualObject(*this)) {
            TRACELSM(TRACE_DETAIL, (dbgDump << "DSPin::GetConnection() " << *this << " is Connected to " << pConn << " but not vice versa"), "");
        }
#endif
        return pConn;
    }
    DSMediaType GetConnectionMediaType(void) const {
        DSMediaType amt(GUID_NULL);
        HRESULT hr = (*this)->ConnectionMediaType(amt);
        if (SUCCEEDED(hr)) {
            return amt;
        } else {
            return DSMediaType();
        }
    }
    DSGraph GetGraph(void) const;
    DSFilter GetFilter(void) const;

    bool HasCategory(const GUID2 &clsCategory, const PIN_DIRECTION pd) const;
    bool HasCategory(const GUID2 &clsCategory) const;
    HRESULT Connect(DSPin ConnectTo, const AM_MEDIA_TYPE *pMediaType = NULL);
    HRESULT IntelligentConnect(DSPin ConnectTo, const AM_MEDIA_TYPE *pMediaType = NULL) {
		// undone: implement this via igb2, currently we're just connecting directly via graph mgr.
		return Connect(ConnectTo, pMediaType);
	}
    HRESULT IntelligentConnect(DSFilter& Filter1, DSFilterList &intermediates, const DWORD dwFlags = 0, const PIN_DIRECTION pd = DOWNSTREAM);
    HRESULT Disconnect(void);
    bool CanRoute(const DSPin pin2) const;

protected:
    bool Routable(const DSPin pin2) const;
};

typedef Forward_Sequence<
    PQFilter,
    PQEnumPins,
    DSPin,
    IBaseFilter ,
    IEnumPins,
    IPin*> DSFilterSequence;

inline bool _cdecl operator==(const CString &cs, const DSFilterSequence& pF);
inline bool _cdecl operator==(const CLSID &cls, const DSFilterSequence& pF);

class DSFilter : public DSFilterSequence {
public:
    DSFilter() {}
    DSFilter(const PQFilter &a) : DSFilterSequence(a) {}
    DSFilter(const DSFilterSequence &a) : DSFilterSequence(a) {}
    DSFilter(IBaseFilter *p) : DSFilterSequence(p) {}
    DSFilter(IUnknown *p) : DSFilterSequence(p) {}
    DSFilter(const DSFilter &a) : DSFilterSequence(a) {}
    DSFilter(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL) : DSFilterSequence(rclsid, pUnkOuter, dwClsContext) {}
    DSGraph GetGraph(void);
    void GetPinCounts(ULONG &ulIn, ULONG &ulOut) const;
    ULONG PinCount(PIN_DIRECTION pd) {
        ULONG in, out;
        GetPinCounts(in, out);
        if (pd == PINDIR_INPUT) {
            return in;
        } else {
            return out;
        }
    }
	ULONG OutputPinCount() const {
		ULONG in, out;
		GetPinCounts(in, out);
		return out;
	}
	ULONG InputPinCount() const {
		ULONG in, out;
		GetPinCounts(in, out);
		return in;
	}
	bool HasFreePins(PIN_DIRECTION pd) const {
		int count = 0;
		for (iterator i = begin(); i != end(); ++i) {
			DSPin p(*i);
			if (p.GetDirection() != pd) {
				continue;
			}
			if (p.IsConnected()) {
				continue;
			}
			++count;
		}
		return !!count;
	}
    bool IsKsProxied() const {
        CLSID cls;
        HRESULT hr = (*this)->GetClassID(&cls);
        if (FAILED(hr)) {
            TRACELM(TRACE_ERROR, "DSFilter::IsKsProxied() can't get class id");
            return false;  // if it doesn't have a clsid it can't be the proxy
        }
#pragma warning(disable: 4800)
        return (cls == CLSID_Proxy);
#pragma warning(default: 4800)
    }
#if 0
    DSFilter *operator&() {  // using vector instead of list so don't need this
        return this;
    }
#endif
    bool IsXBar() const;
    CString GetName(void) const;
	DSPin FirstPin(PIN_DIRECTION pd = PINDIR_INPUT) const {
		for (DSFilter::iterator i = begin(); i != end(); ++i) {
			if ((*i).GetDirection() == pd) {
				return *i;
			}
		}
		return DSPin();
	}
    GUID2 ClassID() const {
        PQPersist p(*this);
        GUID2 g;
        p->GetClassID(&g);
        return g;
    }
};

typedef Forward_Sequence<
    PQGraphBuilder,
    PQEnumFilters,
    DSFilter,
    IGraphBuilder,
    IEnumFilters,
    IBaseFilter*> DSGraphContainer;

typedef std_arity3pmf<
                ICreateDevEnum, REFCLSID, IEnumMoniker **, ULONG, HRESULT
        > DSDevicesMFType;

typedef std_bndr_mf_1_3<DSDevicesMFType> DSDevicesFetchType;

class DSDevices : public DSDeviceSequence {
public:
    DSDevicesFetchType * Fetch;
    DSDevices(DSDeviceSequence &p, REFCLSID clsid) :  Fetch(NULL), DSDeviceSequence(p) {
        SetFetch(clsid);
    }
    DSDevices(PQCreateDevEnum &p, REFCLSID clsid) : Fetch(NULL), DSDeviceSequence(p) {
        SetFetch(clsid);
    }
    DSDevices(DSDevices &d) : DSDeviceSequence(d) {
        SetFetch((d.Fetch)->arg1val);
    }
    virtual DSDeviceSequence::FetchType * GetFetch() const { return Fetch; }
    ~DSDevices() { if (Fetch) delete Fetch; }
protected:
    // NOTE: this invalidates all currently outstanding iterators
    // don't use outside of construction
    void SetFetch(REFCLSID clsid) {
        if (Fetch) {
            delete Fetch;
        }
        Fetch =
            new DSDevicesFetchType(std_arity3_member(&ICreateDevEnum::CreateClassEnumerator),
                                   clsid,
                                   0);
    }

};

typedef std_arity15pmf<
                IFilterMapper2,
                IEnumMoniker **,           // enumerator returned
                DWORD,                   // 0 flags
                BOOL,                // don't match wildcards
                DWORD,                   // at least this merit needed
                BOOL,              // need at least one input pin
                DWORD,               // input media type count
                const GUID *,               // input major+sub pair array
                const REGPINMEDIUM *,      // input medium
                const CLSID*,             // input pin category
                BOOL,                   // must the input be rendered?
                BOOL,             // need at least one output pin
                DWORD,              // output media type count
                const GUID *,             // output major type
                const REGPINMEDIUM *,     // output medium
                const CLSID*,             // output pin category
                HRESULT
        > DSFilterMapperMFType;

typedef std_bndr_mf_2_3_4_5_6_7_8_9_10_11_12_13_14_15<DSFilterMapperMFType> DSFilterMapperFetchType;

class DSFilterMapper : public DSFilterMapperSequence {
public:
    DSFilterMapperFetchType *Fetch;

protected:
    // NOTE: this invalidates all currently outstanding iterators
    // don't use outside of construction
    void SetFetch(
        DWORD dwFlags,                   // 0
        BOOL bExactMatch,                // don't match wildcards
        DWORD dwMerit,                   // at least this merit needed
        BOOL  bInputNeeded,              // need at least one input pin
        DWORD cInputTypes,               // Number of input types to match
                                        // Any match is OK
        const GUID *pInputTypes, // input major+subtype pair array
        const REGPINMEDIUM *pMedIn,      // input medium
        const CLSID *pPinCategoryIn,     // input pin category
        BOOL  bRender,                   // must the input be rendered?
        BOOL  bOutputNeeded,             // need at least one output pin
        DWORD cOutputTypes,              // Number of output types to match
                                       // Any match is OK
        const GUID *pOutputTypes, // output major+subtype pair array
        const REGPINMEDIUM *pMedOut,     // output medium
        const CLSID *pPinCategoryOut     // output pin category
   ) {
        if (Fetch) {
            delete Fetch;
        }
        Fetch =
            new DSFilterMapperFetchType(std_arity15_member(&IFilterMapper2::EnumMatchingFilters),
                                        dwFlags,                   // 0
                                        bExactMatch,
                                        dwMerit,
                                        bInputNeeded,
                                        cInputTypes,               // Number of input types to match
                                        pInputTypes, // input major+subtype pair array
                                                    // Any match is OK
                                        pMedIn,
                                        pPinCategoryIn,
                                        bRender,
                                        bOutputNeeded,
                                        cOutputTypes,      // Number of output types to match
                                                           // Any match is OK
                                        pOutputTypes, // output major+subtype pair array
                                        pMedOut,
                                        pPinCategoryOut
                                       );
    }

public:
    DSFilterMapper(PQFilterMapper &p,
                   DWORD dwFlags,                   // 0
                   BOOL bExactMatch,                // don't match wildcards
                   DWORD dwMerit,                   // at least this merit needed
                   BOOL  bInputNeeded,              // need at least one input pin
                   DWORD cInputTypes,               // Number of input types to match
                                                    // Any match is OK
                   const GUID *pInputTypes, // input major+subtype pair array
                   const REGPINMEDIUM *pMedIn,      // input medium
                   const CLSID* pInCat,             // input pin category
                   BOOL  bRender,                   // must the input be rendered?
                   BOOL  bOutputNeeded,             // need at least one output pin
                   DWORD cOutputTypes,              // Number of output types to match
                                                   // Any match is OK
                   const GUID *pOutputTypes, // output major+subtype pair array
                   const REGPINMEDIUM *pMedOut,     // output medium
                   const CLSID* pOutCat             // output pin category
                  ) : Fetch(NULL), DSFilterMapperSequence(p) {
        SetFetch(
                 dwFlags,                   // 0
                 bExactMatch,
                 dwMerit,
                 bInputNeeded,
                 cInputTypes,               // Number of input types to match
                                                    // Any match is OK
                 pInputTypes, // input major+subtype pair array
                 pMedIn,
                 pInCat,
                 bRender,
                 bOutputNeeded,
                 cOutputTypes,              // Number of output types to match
                                                   // Any match is OK
                 pOutputTypes, // output major+subtype pair array
                 pMedOut,
                 pOutCat
                );
    }

    DSFilterMapper(DSFilterMapperSequence &p,
                   DWORD dwFlags,                   // 0
                   BOOL bExactMatch,                // don't match wildcards
                   DWORD dwMerit,                   // at least this merit needed
                   BOOL  bInputNeeded,              // need at least one input pin
                   DWORD cInputTypes,               // Number of input types to match
                                                    // Any match is OK
                   const GUID *pInputTypes, // input major+subtype pair array
                   const REGPINMEDIUM *pMedIn,      // input medium
                   const CLSID* pInCat,             // input pin category
                   BOOL  bRender,                   // must the input be rendered?
                   BOOL  bOutputNeeded,             // need at least one output pin
                   DWORD cOutputTypes,              // Number of output types to match
                                                   // Any match is OK
                   const GUID *pOutputTypes, // output major+subtype pair array
                   const REGPINMEDIUM *pMedOut,     // output medium
                   const CLSID* pOutCat             // output pin category
                  ) :  Fetch(NULL), DSFilterMapperSequence(p) {
        SetFetch(
                 dwFlags,                   // 0
                 bExactMatch,
                 dwMerit,
                 bInputNeeded,
                 cInputTypes,               // Number of input types to match
                                                    // Any match is OK
                 pInputTypes, // input major+subtype pair array
                 pMedIn,
                 pInCat,
                 bRender,
                 bOutputNeeded,
                 cOutputTypes,              // Number of output types to match
                                                   // Any match is OK
                 pOutputTypes, // output major+subtype pair array
                 pMedOut,
                 pOutCat
                );
    }

    DSFilterMapper(DSFilterMapper &d) : DSFilterMapperSequence(d) {
        SetFetch((d.Fetch)->arg2val, (d.Fetch)->arg3val, (d.Fetch)->arg4val, (d.Fetch)->arg5val,
                 (d.Fetch)->arg6val, (d.Fetch)->arg7val, (d.Fetch)->arg8val, (d.Fetch)->arg9val,
                 (d.Fetch)->arg10val, (d.Fetch)->arg11val, (d.Fetch)->arg12val,
                 (d.Fetch)->arg13val, (d.Fetch)->arg14val, (d.Fetch)->arg15val
                );
    }
    virtual DSFilterMapperSequence::FetchType *GetFetch() const { return Fetch; }
    ~DSFilterMapper() { if (Fetch) delete Fetch; }
};


class DSREGPINMEDIUM : public REGPINMEDIUM {
public:
    DSREGPINMEDIUM() { memset(this, 0, sizeof(*this)); }
    DSREGPINMEDIUM(REFGUID SetInit, ULONG IdInit, ULONG FlagsInit) {
        clsMedium = SetInit;
        dw1 = IdInit;
        dw2 = FlagsInit;
    }
    DSREGPINMEDIUM(DSREGPINMEDIUM &rhs) {
        clsMedium = rhs.clsMedium;
        dw1 = rhs.dw1;
        dw2 = rhs.dw2;
    }
    DSREGPINMEDIUM(KSPinMedium &rhs) {
        clsMedium = rhs.Set;
        dw1 = rhs.Id;
        dw2 = rhs.Flags;
    }

    DSREGPINMEDIUM& operator=(const KSPinMedium &rhs) {
        if (reinterpret_cast<const REGPINMEDIUM *>(&rhs) != this) {
            clsMedium = rhs.Set;
            dw1 = rhs.Id;
            dw2 = rhs.Flags;
        }
        return *this;
    }
    DSREGPINMEDIUM& operator=(const DSREGPINMEDIUM &rhs) {
        if (&rhs != this) {
            clsMedium = rhs.clsMedium;
            dw1 = rhs.dw1;
            dw2 = rhs.dw2;
        }
        return *this;
    }
    bool operator==(const DSREGPINMEDIUM &rhs) const {
        // NOTE: at some point there will be a flag in Flags to
        // indicate whether or not Id is significant for this object
        // at that point this method will need to change
        return (dw1 == rhs.dw1 && clsMedium == rhs.clsMedium);
    }
    bool operator!=(const DSREGPINMEDIUM &rhs) const {
        // NOTE: at some point there will be a flag in Flags to
        // indicate whether or not Id is significant for this object
        // at that point this method will need to change
        return !(*this == rhs);
    }
};

const long DEFAULT_GRAPH_STATE_TIMEOUT = 5000;

class DSGraph : public DSGraphContainer {
public:
    DSGraph() {}
    DSGraph(const DSGraph &a) : DSGraphContainer(a) {}
    DSGraph(const PQGraphBuilder &a) : DSGraphContainer(a) {}
    DSGraph(const DSGraphContainer &a) : DSGraphContainer(a) {}
    DSGraph(IGraphBuilder *p) : DSGraphContainer(p) {}
    DSGraph(IUnknown *p) : DSGraphContainer(p) {}

    HRESULT AddToROT(DWORD *pdwObjectRegistration);
    void RemoveFromROT(DWORD dwObjectRegistration);

    // graph operation
    inline OAFilterState GetState(long timeout = DEFAULT_GRAPH_STATE_TIMEOUT) {
        PQMediaControl pMC(*this);
        if(!pMC) {
            THROWCOM(E_UNEXPECTED);
        }
        OAFilterState state;
        HRESULT hr = pMC->GetState(timeout, &state);
        if (hr == VFW_S_CANT_CUE) {
            state = State_Paused;
        } else 	if (hr == VFW_S_STATE_INTERMEDIATE) {
            THROWCOM(HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
        } else 	if (FAILED(hr)) {
            TRACELSM(TRACE_ERROR, (dbgDump << "DSGraph::GetState() can't get graph state hr = " << hr), "");
            THROWCOM(hr);
		}
        return state;
    }
    inline bool IsPlaying() {
        try {
            return GetState() == State_Running;
        } catch(...) {
            return false;
        }
    }
    inline bool IsPaused() {
        try {
            return GetState() == State_Paused;
        } catch(...) {
            return false;
        }
    }
    inline bool IsStopped() {
        try {
            return GetState() == State_Stopped;
        } catch(...) {
            return false;
        }
    }

    // graph building helpers
    HRESULT Connect(DSFilter &pStart, DSFilter &pStop, DSFilterList &Added, const DWORD dwFlags = 0, PIN_DIRECTION pFilter1Direction = DOWNSTREAM);
    bool Connect(DSFilter &pFilter1, DSFilterMoniker &pMoniker, DSFilter &pAdded, DSFilterList &NewIntermediateFilters, const DWORD dwFlags = 0, PIN_DIRECTION pFilter1Direction = DOWNSTREAM);

    typedef bool (DSGraph::*ConnectPred_t)(DSPin&, DSFilter&, DWORD dwFlags);
    typedef arity5pmf<DSGraph, DSPin&, DSFilterMoniker&, DSFilter&, DSFilterIDList &, ConnectPred_t, bool> LoadCheck_t;
    typedef arity5pmf<DSGraph, DSPin&, DSFilter&, DSFilter&, DSFilterIDList &, ConnectPred_t, bool> ConnectCheck_t;

    bool DisconnectPin(DSPin &pPin, const bool fRecurseInputs, const bool fRecurseOutputs);
    bool DisconnectFilter(DSFilter &pFilter, const bool fRecurseInputs, const bool fRecurseOutputs);
    bool RemoveFilter(DSFilter &pFilter);

    bool IsConnectable(DSPin &pPin1, DSFilter &Mapper, DSFilter &Destination, DSFilterIDList &NewFilters, const DWORD dwFlags, ConnectPred_t ConnPred);
    bool IsLoadable(DSPin &pPin1, DSFilterMoniker &Mapper, DSFilter &Destination, DSFilterIDList &IntermediateFilters, const DWORD dwFlags, ConnectPred_t ConnPred);
    bool IsPinConnected(const DSPin &pPin1, const DSFilter &pFDestination, DSFilterIDList &IntermediateFilters, const PIN_DIRECTION destdir) const;


    // generic recursive build functions
#ifdef ATTEMPT_DIRECT_CONNECT    
	bool ConnectPinDirect(DSPin &pPin, DSFilter &pFilter2, DWORD dwFlags);
#else
    bool HasMediaType(const DSMediaType &LeftMedia, const DSPin &pPinRight) const;
    bool HasMedium(const KSPinMedium &Medium1, const DSPin &pPin2) const;
    bool HasUnconnectedMedium(const DSPin &pPinLeft, const DSPin &pPin2, int& cUseable) const;
    bool HasUnconnectedMediaType(const DSPin &pPinLeft, const DSPin &pPin2, DWORD dwFlags) const;
    bool ConnectPinByMedium(DSPin &pPin, DSFilter &pFilter2, DWORD dwFlags);
    bool ConnectPinByMediaType(DSPin &pPin1, DSFilter &pFilter1, DWORD dwFlags);
#endif
    bool FindPinByMedium(DSPin &pPin, DSFilter &pFilter2, DSFilterIDList &InterediateFilters, const DWORD dwFlags);
    bool LoadPinByMedium(KSPinMedium &medium, DSPin &pPinLeft, DSFilter &pFilter2, DSFilterIDList &IntermediateFilters, const DWORD dwFlags);
    bool LoadPinByAnyMedium(DSPin &pPin, DSFilter &pFilter2, DSFilterIDList &IntermediateFilters, const DWORD dwFlags);
    bool FindPinByMediaType(DSPin &pPin, DSFilter &pFilter2, DSFilterIDList &InterediateFilters, const DWORD dwFlags);
    bool LoadPinByMediaType(DSPin &pPin1, DSFilter &pFilter1, DSFilterIDList &IntermediatesAdded, const DWORD dwFlags, const DWORD dwMerit);
    bool LoadPinByAnyMediaType(DSPin &pPin, DSFilter &pFilter2, DSFilterIDList &IntermediateFilters, const DWORD dwFlags);

	enum {
		RENDER_ALL_PINS = 0x01,
		IGNORE_EXISTING_CONNECTIONS = 0x02,
		DO_NOT_LOAD = 0x04,
        ATTEMPT_MERIT_DO_NOT_USE = 0x08,
		ATTEMPT_MERIT_UNLIKELY = 0x10,
		ALLOW_WILDCARDS = 0x20,
        IGNORE_MEDIATYPE_ERRORS = 0x40,
        DONT_TERMINATE_ON_RENDERER= 0x80,
        BIDIRECTIONAL_MEDIATYPE_MATCHING = 0x100,
	}; // render flags

    bool ConnectPin(DSPin &pPin1, DSFilter &pFilter2, DSFilterIDList &NewFilters, const DWORD dwFlags, PIN_DIRECTION pin1dir);
    bool ConnectPin(DSPin &pPin1, DSFilter &pFilter2, DSFilterList &NewFilters, const DWORD dwFlags, PIN_DIRECTION pin1dir) {
		DSFilterIDList AddedIDs;
		bool rc = ConnectPin(pPin1, pFilter2, AddedIDs, dwFlags, pin1dir);
		if (rc) {
			for (DSFilterIDList::iterator i = AddedIDs.begin(); i != AddedIDs.end(); ++i) {
				NewFilters.push_back((*i).first);
			}
		}
		return rc;
	}
    DSFilter LoadFilter(const DSFilterMoniker &pM, CString &csName);
    DSFilter AddMoniker(const DSFilterMoniker &pM);
    HRESULT AddFilter(DSFilter &pFilter, CString &csName);
    DSFilter AddFilter(const CLSID &cls, CString &csName);
    bool ConnectFilters(DSFilter &pFilter1, DSFilter &pFilter2, DSFilterIDList &NewIntermediateFilters, const DWORD dwFlags = 0, PIN_DIRECTION pFilter1Direction = DOWNSTREAM);
    int BuildGraphPath(const DSFilter& pStart, const DSFilter& pStop,
                       VWStream &path, MediaMajorTypeList& MediaList, PIN_DIRECTION direction, const DSPin &InitialInput);

    HRESULT SetMediaEventNotificationWindow(HWND h, UINT msg, long lInstance) {
        // If windowless, WM_MEDIAEVENT is processed by the timer in OnTimer
        PQMediaEventEx pme(*this);
        if (!pme) {
            return E_UNEXPECTED;
        }
        HRESULT hr = pme->CancelDefaultHandling(EC_STATE_CHANGE);
        ASSERT(SUCCEEDED(hr));

        return pme->SetNotifyWindow((OAHWND) h, msg, lInstance);

    }
};

class DSXBarPin : public DSPin {
public:
    DSXBarPin() {}
    DSXBarPin(const DSPin &p) : DSPin(p) {
        PQCrossbarSwitch px1(GetFilter());
        if (!px1) {
            THROWCOM(E_FAIL);
        }
    }
    DSXBarPin(const PQPin &p) : DSPin(p) {
        PQCrossbarSwitch px1(GetFilter());
        if (!px1) {
            THROWCOM(E_FAIL);
        }
    }
    DSXBarPin(const DSXBarPin &p) : DSPin(p) {
        PQCrossbarSwitch px1(GetFilter());
        if (!px1) {
            THROWCOM(E_FAIL);
        }
    }
    DSXBarPin(IUnknown *p) : DSPin(p) {
        PQCrossbarSwitch px1(GetFilter());
        if (!px1) {
            THROWCOM(E_FAIL);
        }
    }
    DSXBarPin(IAMCrossbar *p) : DSPin(p) {
        PQCrossbarSwitch px1(GetFilter());
        if (!px1) {
            THROWCOM(E_FAIL);
        }
    }

#if 0
    static const DSXBarPin Find(const CPinPoints &pinpoints, const PQPoint &point, PIN_DIRECTION pindir);
#endif


//    static DSPin DSPinFromIndex(const DSFilter XBar, const ULONG index);
    const PQPoint GetPoint() const;
    bool CanRoute(const DSXBarPin pin2) const;
#if 0
    void GetRelations(const CPinPoints &pinpoint,
                      CString &csName, CString &csType, CString &csRelName) const;
#endif
};

inline DSFilter DSFilterMoniker::GetFilter() const {
    DSFilter pFilter;
    HRESULT hr = (*this)->BindToObject(0, 0, __uuidof(IBaseFilter), reinterpret_cast<LPVOID *>(&pFilter));
    if (FAILED(hr)) {
        // undone: it would be useful to dump the mkr display name here....
        TRACELSM(TRACE_ERROR, (dbgDump << "DSFilterMoniker::GetFilter() can't bind to object.  hr = " << hexdump(hr)), "");
        return DSFilter();
    }
    return pFilter;
}

#ifdef _DEBUG
//void WINAPI DumpGraph(IFilterGraph *pGraph, DWORD dwLevel);
inline tostream &operator<<(tostream &dc, const DSREGPINMEDIUM &g) {
    //TRACELM(TRACE_DETAIL, "operator<<(tostream, DSREGPINMEDIUM)");
        const GUID2 g2(g.clsMedium);
        dc << _T("DSREGPINMEDIUM( ") << g2 << _T(", ") << hexdump(g.dw1) << _T(", ") << hexdump(g.dw2) << _T(")");
        return dc;
}
inline tostream& operator<<(tostream &d, const PQPin &pin) {
    const CString csPinName(const DSPin(pin).GetName());

    d << (csPinName.IsEmpty() ? CString(_T("**** UNKNOWN PIN NAME ****")) : csPinName) << " " << reinterpret_cast<void *>(pin.p);
    return d;
}

inline tostream& operator<<(tostream &d, const DSFilter &filt) {
    d << filt.GetName() << _T(" ") << reinterpret_cast<void *>(filt.p);
    return d;
}

inline tostream& operator<<(tostream &d, const _AMMediaType *pamt) {
    d << reinterpret_cast<const void *>(pamt);
    if (pamt) {
        d << _T(" major = ") << GUID2(pamt->majortype) << _T(" sub = ") << GUID2(pamt->subtype);
	}
    return d;
}
inline tostream& operator<<(tostream &d, const PQPoint &p) {
    const DSFilter pF(p.first);
    d << _T("PQPoint( ") << pF << _T(", ") << p.second << _T(")");
    return d;
}

inline tostream& operator<<(tostream &d, const CIOPoint &p) {
    d << _T("CIOPoint( ") << p.first << _T(", ") << p.second << _T(")");
    return d;
}

void DumpMediaTypes(DSPin &p1, DSPin &p2);
#endif

inline bool _cdecl operator==(const CString &cs, const DSFilterSequence& pF) {
    // filter name
    FILTER_INFO fi;
    HRESULT hr = pF->QueryFilterInfo(&fi);
    if (SUCCEEDED(hr)) {
        USES_CONVERSION;
        if (fi.pGraph) fi.pGraph->Release();
        return (cs == OLE2T(fi.achName));
    }
    return false;
}
inline bool _cdecl operator!=(const CString &cs, const DSFilterSequence& pF) {
    return !(cs == pF);
}
inline bool _cdecl operator==(const DSFilterSequence& pF, const CString &cs) {
    return (cs == pF);
}
inline bool _cdecl operator!=(const DSFilterSequence& pF, const CString &cs) {
    return !(cs == pF);
}


inline bool _cdecl operator==(const CLSID &cls, const DSFilterSequence& pF) {
    // filter name
    CLSID cid;
    HRESULT hr = pF->GetClassID(&cid);
    if (SUCCEEDED(hr)) {
#pragma warning(disable: 4800)
        return (cid == cls);
#pragma warning(default: 4800)
    }
    return false;
}

inline bool _cdecl operator!=(const CLSID &cls, const DSFilterSequence& pF) {
    return !(cls == pF);
}
inline bool _cdecl operator==(const DSFilterSequence& pF, const CLSID &cls) {
    return (cls == pF);
}

inline bool _cdecl operator!=(const DSFilterSequence& pF, const CLSID &cls) {
    return !(cls == pF);
}


typedef enum {
    tempAMPROPERTY_OvMixerOwner = 0x01  //use AMOVMIXEROWNER
} tempAMPROPERTY_NOTIFYOWNER;

typedef enum {
    tempAM_OvMixerOwner_Unknown = 0x01,
    tempAM_OvMixerOwner_BPC = 0x02
} tempAMOVMIXEROWNER;

inline bool DSPin::IsKsProxied() const {
    return GetFilter().IsKsProxied();
}
inline bool DSFilter::IsXBar() const {
    PQCrossbarSwitch px(*this);
	TRACELSM(TRACE_PAINT, (dbgDump << "DSFilter::IsXBar() " << *this << " is " << ((!px) ? " not " : "")), "crossbar");
    return !!px;
}


void CtorStaticDSExtendFwdSeqPMFs(void);
void DtorStaticDSExtendFwdSeqPMFs(void);

bool IsVideoFilter(const DSFilter& f);
bool IsVideoPin(const DSPin& p);

inline PIN_DIRECTION OppositeDirection(PIN_DIRECTION pd) {
	if (pd == PINDIR_INPUT) {
		return PINDIR_OUTPUT;
	} else {
		return PINDIR_INPUT;
	}
}

inline bool IsVideoMediaType(const DSMediaType& mt) {
    GUID2 g(mt.p->majortype);
    if ((g == MEDIATYPE_Video) || (g == MEDIATYPE_AnalogVideo)) {
        return true;
    }
    return false;
}

inline bool IsAnalogVideoCapture(const DSFilter &f) {
    return !!PQAnalogVideoDecoder(f);
}

inline bool IsIPSink(const DSFilter &f) {
    return !!PQBDA_IPSinkControl(f);
}

inline bool IsVPM(const DSFilter &f) {
    return f.ClassID() == CLSID_VideoPortManager;
}

inline bool IsVideoRenderer(const DSFilter &f) {
    return f.ClassID() == CLSID_VideoMixingRenderer;
}

inline bool IsDigitalAudioRenderer(const DSFilter &f) {
    return f.ClassID() == CLSID_DSoundRender;
}

inline bool IsAnalogVideoCaptureViewingPin(const DSPin &p) {
    GUID2 pincat;
    p.GetCategory(pincat);
    return (pincat == PIN_CATEGORY_VIDEOPORT || pincat == PIN_CATEGORY_CAPTURE);
}

inline bool IsAnalogVideoCapturePreviewPin(const DSPin &p) {
    GUID2 pincat;
    p.GetCategory(pincat);
    return (pincat == PIN_CATEGORY_PREVIEW);
}

inline bool IsDVDNavigator(const DSFilter &f) {
    return !!PQDVDNavigator(f);
}

inline bool IsL21Decoder(const DSFilter &f) {
    return !!PQLine21Decoder(f);
}

inline bool IsDVDNavigatorVideoOutPin(const DSPin &p) {
    
    DSPin::iterator iMediaType;
    for (iMediaType = p.begin(); iMediaType != p.end(); ++iMediaType) {
        DSMediaType mt(*iMediaType);
        if ((mt.p->majortype == MEDIATYPE_MPEG2_PES ||
             mt.p->majortype == MEDIATYPE_DVD_ENCRYPTED_PACK ) &&
             mt.p->subtype == MEDIASUBTYPE_MPEG2_VIDEO)
            return true;
        
        // elementary stream
        if ((mt.p->majortype == MEDIATYPE_Video)  &&
            (mt.p->subtype == MEDIASUBTYPE_MPEG2_VIDEO ||
             mt.p->subtype == MEDIASUBTYPE_RGB8   ||
             mt.p->subtype == MEDIASUBTYPE_RGB565 ||
             mt.p->subtype == MEDIASUBTYPE_RGB555 ||
             mt.p->subtype == MEDIASUBTYPE_RGB24  ||
             mt.p->subtype == MEDIASUBTYPE_RGB32))
             return true;
    }

    return false;
}

inline bool IsDVDNavigatorSubpictureOutPin(const DSPin &p) {
    
    DSPin::iterator iMediaType;
    for (iMediaType = p.begin(); iMediaType != p.end(); ++iMediaType) {
        DSMediaType mt(*iMediaType);
        if ((mt.p->majortype == MEDIATYPE_MPEG2_PES ||
             mt.p->majortype == MEDIATYPE_DVD_ENCRYPTED_PACK ) &&
             mt.p->subtype == MEDIASUBTYPE_DVD_SUBPICTURE)
            return true;

        // elementary stream
        if ((mt.p->majortype == MEDIATYPE_Video)  &&
             mt.p->subtype == MEDIASUBTYPE_DVD_SUBPICTURE)
            return true;
    }

    return false;
}

///////// DSPin
inline  HRESULT DSPin::IntelligentConnect(DSFilter& Filter1, DSFilterList &intermediates, const DWORD dwFlags, const PIN_DIRECTION pd) {
	bool rc = GetGraph().ConnectPin(*this, Filter1, intermediates, dwFlags, pd);
	if (rc) {
		return NOERROR;
	}
	return E_FAIL;
}

inline DSFilter DSPin::GetFilter(void) const {
    PIN_INFO pinfo;

    HRESULT hr = (*this)->QueryPinInfo(&pinfo);
    if (FAILED(hr)) {
        return DSFilter();
    }
    DSFilter pRet;
    pRet.p = pinfo.pFilter;  // directly transfer ownership of ref count

    return pRet;
}

inline DSGraph DSPin::GetGraph(void) const {
    DSFilter f = GetFilter();
    return f.GetGraph();
}

inline bool DSPin::HasCategory(const GUID2 &clsCategory) const {
    TRACELSM(TRACE_DETAIL, (dbgDump << "DSPin::IsPinCategory() pin = " << this), "");
    GUID2 pincat2;
    GetCategory(pincat2);
    return clsCategory == pincat2;
}

#endif
// end of file - dsextend.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\dvbtsimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBtsimpl.h : 
// Copyright (c) Microsoft Corporation 1999.

#ifndef DVBTSIMPL_H
#define DVBTSIMPL_H

#include "tuningspaceimpl.h"
#include "dvbTuneRequest.h"

namespace BDATuningModel {

template<class T,
         class TUNEREQUESTTYPE = CDVBTuneRequest,
         class MostDerived = IDVBTuningSpace2, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IDVBTuningSpaceImpl : 
	public ITuningSpaceImpl<T, TUNEREQUESTTYPE, MostDerived, iid, LibID, wMajor, wMinor, tihclass>,
    public IMPEG2TuneRequestSupport
{

public:

    DVBSystemType m_SystemType;
    long m_NetworkID;

    IDVBTuningSpaceImpl(DVBSystemType systypei = DVB_Cable) : m_SystemType(systypei), m_NetworkID(-1) {}
    virtual ~IDVBTuningSpaceImpl() {}
    typedef ITuningSpaceImpl<T, TUNEREQUESTTYPE, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    
    BEGIN_PROP_MAP(IDVBTuningSpaceImpl)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("System Type", m_SystemType, VT_I4)
        PROP_DATA_ENTRY("Network ID", m_NetworkID, VT_I4)
    END_PROPERTY_MAP()

// IDVBTS
    STDMETHOD(get_SystemType)(DVBSystemType *pSysType)
    {
        if (!pSysType) {
            return E_POINTER;
        }
		ATL_LOCKT();
        *pSysType = m_SystemType;

	    return NOERROR;
    }

    STDMETHOD(put_SystemType)(DVBSystemType NewSysType)
    {
		ATL_LOCKT();
        m_SystemType = NewSysType;
        MARK_DIRTY(T);

	    return NOERROR;
    }

    STDMETHOD(get_NetworkID)(long *pNetID)
    {
        if (!pNetID) {
            return E_POINTER;
        }
		ATL_LOCKT();
        *pNetID = m_NetworkID;

	    return NOERROR;
    }

    STDMETHOD(put_NetworkID)(long NewNetID)
    {
		ATL_LOCKT();
        m_NetworkID = NewNetID;
        MARK_DIRTY(T);

	    return NOERROR;
    }

    // override standard ITuningSpaceImpl
    STDMETHOD(put_DefaultLocator)(ILocator *pLoc) {
		ATL_LOCKT();
        if (pLoc) {
            switch (m_SystemType) {
            case DVB_Terrestrial: {
                PQDVBTLocator p(pLoc);
                if (!p) {
                    return DISP_E_TYPEMISMATCH;
                }
                break;
            } 
            case DVB_Satellite: {
                PQDVBSLocator p(pLoc);
                if (!p) {
                    return DISP_E_TYPEMISMATCH;
                }
                break;
            }
            case DVB_Cable:
                // dvb cable locator is same as base locator
            default:
                break;
            };
        }
        return basetype::put_DefaultLocator(pLoc);
    }
    STDMETHOD(Clone) (ITuningSpace **ppTS) {
        try {
			if (!ppTS) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppTS);
			if (FAILED(hr)) {
				return hr;
			}
			T* pt = static_cast<T*>(*ppTS);
            pt->m_SystemType = m_SystemType;
            pt->m_NetworkID = m_NetworkID;
			return NOERROR;
        } CATCHCOM_CLEANUP(if (*ppTS) {
                               (*ppTS)->Release();
                               *ppTS = NULL;
                           }
                          );
	}

};

}; // namespace

#endif // DVBTSIMPL_H
// end of file -- DVBtsimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\errsupp.h ===
/////////////////////////////////////////////////////////////////////////////////////
// errsupp.h : error reporting for implementation helper templates
// Copyright (c) Microsoft Corporation 1999-2000.

#ifndef ERRSUPP_H
#define ERRSUPP_H
#include <winbase.h>
#pragma once

namespace BDATuningModel {
inline HRESULT WINAPI ImplReportError(const CLSID& clsid, UINT nID, const IID& iid,
	HRESULT hRes, HINSTANCE hInst = _Module.GetResourceInstance(), ...)
{    
	va_list arguments;
	va_start(arguments, hInst);
	return AtlSetErrorInfo(clsid, nID, iid, hRes, hInst, &arguments);
}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\encoderimpl.h ===
//==========================================================================;
//
// encoderimpl.h : additional infrastructure to support implementing IMSVidEncoder
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef ENCODERIMPL_H
#define ENCODERIMPL_H

#include "featureimpl.h"

namespace MSVideoControl {

template<class T, LPCGUID LibID, LPCGUID KSCategory, class MostDerivedInterface = IMSVidEncoder>
    class DECLSPEC_NOVTABLE IMSVidEncoderImpl : public IMSVidFeatureImpl<T, LibID, KSCategory, MostDerivedInterface> {
public:
	    virtual ~IMSVidEncoderImpl() {}
};

}; /// namespace

#endif
// end of file - encoderimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\dvbtunerequestimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// DVBTuneRequestimpl.h : implementation helper template for component type interface
// Copyright (c) Microsoft Corporation 1999.

#ifndef DVBTUNEREQUESTIMPL_H
#define DVBTUNEREQUESTIMPL_H

#include <tune.h>
#include "tunerequestimpl.h"

typedef CComQIPtr<IDVBTLocator> PQDVBTLocator;
typedef CComQIPtr<IDVBSLocator> PQDVBSLocator;

namespace BDATuningModel {

template<class T,
         class MostDerived = IDVBTuneRequest, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IDVBTuneRequestImpl : 
	public ITuneRequestImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// IDVBTuneRequest
public:
    typedef ITuneRequestImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;

	IDVBTuneRequestImpl() : m_ONID(-1), m_TSID(-1), m_SID(-1){}
    virtual ~IDVBTuneRequestImpl() {}
    BEGIN_PROP_MAP(IDVBTuneRequestImpl)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("Original Network ID", m_ONID, VT_I4)
        PROP_DATA_ENTRY("Transport Stream ID", m_TSID, VT_I4)
        PROP_DATA_ENTRY("Service ID", m_SID, VT_I4)
    END_PROP_MAP()

	long m_ONID;
	long m_TSID;
	long m_SID;

    STDMETHOD(get_ONID)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_ONID;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_ONID)(long newVal)
    {
		ATL_LOCKT();
        m_ONID = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }

    STDMETHOD(get_TSID)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_TSID;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_TSID)(long newVal)
    {
		ATL_LOCKT();
        m_TSID = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }

    STDMETHOD(get_SID)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_SID;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_SID)(long newVal)
    {
		ATL_LOCKT();
        m_SID = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }

	STDMETHOD(Clone) (ITuneRequest **ppTR) {
		try {
			if (!ppTR) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppTR);
			if (FAILED(hr)) {
				return hr;
			}
			T* pt = static_cast<T*>(*ppTR);
			pt->m_ONID = m_ONID;
			pt->m_TSID = m_TSID;
			pt->m_SID = m_SID;

			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}

    STDMETHOD(put_Locator)(ILocator *pLocator)
    {
        try {
			ATL_LOCKT();
            if (pLocator) {
                TNDVBTuningSpace ts(m_TS);
                if (!ts) {
                    return E_UNEXPECTED;
                }
                DVBSystemType st = ts.SystemType();
                switch (st) {
                case DVB_Terrestrial: {
                    PQDVBTLocator l(pLocator);
                    if (!l) {
                        return DISP_E_TYPEMISMATCH;
                    }
                    break;
                }
                case DVB_Satellite: {
                    PQDVBSLocator l(pLocator);
                    if (!l) {
                        return DISP_E_TYPEMISMATCH;
                    }
                    break;
                }
                case DVB_Cable:
                    //dvb c locator is same as base ILocator
                default: {

                }}
            }
            return basetype::put_Locator(pLocator);
        } catch (...) {
            return E_POINTER;
        }
    }


};

}; // namespace

#endif // DVBTUNEREQUESTIMPL_H
// end of file -- atschchanneltunerequestimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\fileplaybackimpl.h ===
//==========================================================================;
//
// fileplaybackimpl.h : additional infrastructure to support implementing IMSVidPlayback
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef FILEPLAYBACKIMPL_H
#define FILEPLAYBACKIMPL_H
#include "playbackimpl.h"

namespace MSVideoControl {

template<class T, LPCGUID LibID, LPCGUID KSCategory, class MostDerivedInterface = IMSVidFilePlayback>
    class DECLSPEC_NOVTABLE IMSVidFilePlaybackImpl :         
    	public IMSVidPlaybackImpl<T, LibID, KSCategory, MostDerivedInterface> {
protected:
    CComBSTR m_FileName;
    int m_iReader;
    bool m_fGraphInit;

public:
    IMSVidFilePlaybackImpl() : 
          m_iReader(-1),
          m_fGraphInit(false)
          {}
	
    virtual ~IMSVidFilePlaybackImpl() {} 


	STDMETHOD(get_FileName)(BSTR * pFileName) {
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidFilePlayback), CO_E_NOTINITIALIZED);
        }
        if (!pFileName) {
			return E_POINTER;
        }
			
        *pFileName = m_FileName.Copy();

		return NOERROR;
	}
    STDMETHOD(InitGraph)(){
        TRACELM(TRACE_DETAIL,  "MSVidFilePlaybackImpl::InitGraph()");
        HRESULT hr = put_CurrentPosition(0);
        if(FAILED(hr)){
            //ASSERT(SUCCEEDED(hr)); // This fails sometimes, we should just ignore it.
            TRACELM(TRACE_ERROR,  "MSVidFilePlaybackImpl::InitGraph() put_CurrentPosition(0) failed");
        }

        hr = put_Rate(1);
        if(FAILED(hr)){
            //ASSERT(SUCCEEDED(hr)); // This fails sometimes, we should just ignore it.
            TRACELM(TRACE_ERROR,  "MSVidFilePlaybackImpl::InitGraph() put_Rate(1) Normal failed");
        }
        hr = IMSVidPlaybackImpl<T, LibID, KSCategory, MostDerivedInterface>::put_Rate(1);
        if(FAILED(hr)){
            //ASSERT(SUCCEEDED(hr)); // This fails sometimes, we should just ignore it.
            TRACELM(TRACE_ERROR,  "MSVidFilePlaybackImpl::InitGraph() put_Rate(1) Base class failed");
        }
        return NOERROR;
    }
    STDMETHOD(put_FileName) (BSTR FileName) {
	    if (!FileName) {
		    return E_POINTER;
	    }
        if (!m_fInit) {
	        return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidFilePlayback), CO_E_NOTINITIALIZED);
        }
        try {
            HRESULT hr;
            TRACELSM(TRACE_DETAIL,  (dbgDump << "MSVidFilePlaybackImpl::put_FileName() name =  " << FileName), "");
            if (m_pGraph && !m_pGraph.IsStopped()) {
	            return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidFilePlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }
            if (m_pContainer) {
                InitGraph();
                
                T* pT = static_cast<T*>(this);
                hr = m_pContainer->Decompose(pT);
                if (FAILED(hr)) {
                    return ImplReportError(__uuidof(T), IDS_CANT_REMOVE_SEG, __uuidof(IMSVidFilePlayback), hr);
                }
            }
            if (m_Filters.size() && m_pContainer) {
                for (DSFilterList::iterator i = m_Filters.begin(); i != m_Filters.end(); ++i) {
                    bool rc = m_pGraph.RemoveFilter(*i);
                    if (!rc) {
                        TRACELM(TRACE_ERROR,  "MSVidFilePlaybackImpl::put_FileName() can't remove filter");
			            return ImplReportError(__uuidof(T), IDS_CANT_REMOVE_FILTER, __uuidof(IMSVidFilePlayback), E_UNEXPECTED);
                    }
                }
                m_Filters.clear();
            }
                        
            m_FileName = FileName;
            m_fGraphInit = true;
        } catch(ComException &e) {
            m_Filters.clear();
            m_iReader = -1;
            return e;
        }

        return NOERROR;
    }
};

}; // namespace

#endif
// end of file - fileplaybackimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\featureimpl.h ===
//==========================================================================;
//
// featureimpl.h : additional infrastructure to support implementing IMSVidFeatureDevice
// nicely from c++
// Copyright (c) Microsoft Corporation 2000.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef FEATUREIMPL_H
#define FEATUREIMPL_H

#include "devimpl.h"

namespace MSVideoControl {

template<class T, LPCGUID LibID, LPCGUID Category, class MostDerivedInterface = IMSVidFeatureDevice>
    class DECLSPEC_NOVTABLE IMSVidFeatureImpl : public IMSVidDeviceImpl<T, LibID, Category, MostDerivedInterface> {
public:
};

}; // namespace

#endif
// end of file - featureimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\filterenum.h ===
//////////////////////////////////////////
// filters.h : header for CFilters IEnumFilters implementation on 
// top of stl vector of filters
// copyright (c) 1999 Microsoft Corp.

#pragma once

#ifndef FILTERS_H_
#define FILTERS_H_

#include <vector>
#include <dsextend.h>
#include <objectwithsiteimplsec.h>

class ATL_NO_VTABLE CFilterEnumOnDSFilterListBase : public CComObjectRootEx<CComSingleThreadModel>,
	public IEnumFilters,
    public IObjectWithSiteImplSec<CFilterEnumOnDSFilterListBase>
{
    BEGIN_COM_MAP(CFilterEnumOnDSFilterListBase)
	    COM_INTERFACE_ENTRY(IEnumFilters)
        COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP()
    DECLARE_PROTECT_FINAL_CONSTRUCT()
    virtual ~CFilterEnumOnDSFilterListBase() {}
};

/////////////////////////////////////////////////////////////////////////////
// CFilters
class CFilterEnumOnDSFilterList : public CComObject<CFilterEnumOnDSFilterListBase>
{
public:
	CFilterEnumOnDSFilterList(DSFilterList &Fi) : m_Filters(Fi) {
        i = m_Filters.begin();
	}
	CFilterEnumOnDSFilterList(CFilterEnumOnDSFilterList &orig) : m_Filters(orig.m_Filters) {
        i = m_Filters.begin();
        DSFilterList::iterator i2 = orig.m_Filters.begin();
        for (; i2 != orig.i && i2 != orig.m_Filters.end(); ++i, ++i2);
	}

    virtual ~CFilterEnumOnDSFilterList() {
        m_Filters.clear();
    }


// IDevEnum
public:
	DSFilterList m_Filters;
	DSFilterList::iterator i;
// IEnumVARIANT
	STDMETHOD(Next)(ULONG celt, IBaseFilter **pOutF, ULONG * pceltFetched)
	{
		// pceltFetched can legally == 0
		//
		if (pceltFetched != NULL) {
			try {
				*pceltFetched = 0;
			} catch(...) {
				return E_POINTER;
			}
		}
	    HRESULT hr = NOERROR ;
		try {
		    // Retrieve the next celt elements.
		    for (;i != m_Filters.end() && celt != 0; ++i, --celt, ++pOutF) {
			    hr = (*i).CopyTo(pOutF);
                if (FAILED(hr)){
                    return hr;
                }
			    if (pceltFetched != NULL) {
				    (*pceltFetched)++ ;
			    }
		    }
		} catch(...) {
			return E_POINTER;
		}
		if (celt != 0) {
		   hr = ResultFromScode( S_FALSE ) ;
		}
		return hr;
	}
	STDMETHOD(Skip)(ULONG celt)
	{        
		for (;i != m_Filters.end() && celt--; ++i);
		return (celt == 0 ? NOERROR : ResultFromScode( S_FALSE )) ;
	}
	STDMETHOD(Reset)()
	{
		i = m_Filters.begin();
		return NOERROR;
	}
	STDMETHOD(Clone)(IEnumFilters **ppenum)
	{
		if (ppenum == NULL)
			return E_POINTER;
		PQEnumFilters temp;
		try {
			temp = new CFilterEnumOnDSFilterList(*this);
		} catch(...) {
			return E_OUTOFMEMORY;
		}
		try {
			*ppenum = temp.Detach();
		} catch(...) {
			return E_POINTER;
		}
		return NOERROR;
	}
};

#endif 
//end of file filters.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\inputimpl.h ===
//==========================================================================;
//
// inputimpl.h : additional infrastructure to support implementing IMSVidInputDevice
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef INPUTIMPL_H
#define INPUTIMPL_H

#include "devimpl.h"

namespace MSVideoControl {

template<class T, LPCGUID LibID, LPCGUID Category, class MostDerivedInterface = IMSVidInputDevice>
    class DECLSPEC_NOVTABLE IMSVidInputDeviceImpl : public IMSVidDeviceImpl<T, LibID, Category, MostDerivedInterface> {
public:
};

}; // namespace

#endif
// end of file - inputimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\languagecomponenttypeimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// LanguageComponentTypeimpl.h : implementation helper template for component type interface
// Copyright (c) Microsoft Corporation 1999.

#ifndef LANGUAGECOMPONENTTYPEIMPL_H
#define LANGUAGECOMPONENTTYPEIMPL_H

#include "componenttypeimpl.h"

namespace BDATuningModel {

template<class T,
         class MostDerived = ILanguageComponentType, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE ILanguageComponentTypeImpl : 
	public IComponentTypeImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// ILanguageComponentType
public:
    long m_LangID;

    ILanguageComponentTypeImpl() : m_LangID(-1) {}
    virtual ~ILanguageComponentTypeImpl() {}
//    typedef ILanguageComponentTypeImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> thistype;
    typedef IComponentTypeImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    BEGIN_PROP_MAP(ILanguageComponentTypeImpl)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("Content LangID", m_LangID, VT_I4)
    END_PROP_MAP()

    STDMETHOD(get_LangID)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_LangID;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_LangID)(long newVal)
    {
		ATL_LOCKT();
        m_LangID = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
	STDMETHOD(Clone) (IComponentType **ppCT) {
		try {
			if (!ppCT) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppCT);
			if (FAILED(hr)) {
				return hr;
			}
			T* pt = static_cast<T*>(*ppCT);
			pt->m_LangID = m_LangID;

			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}

};

}; // namespace

#endif // LANGUAGECOMPONENTTYPEIMPL_H
// end of file -- languagecomponenttypeimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\fwdseq.h ===
//==========================================================================;
//
// fwdseq.h : forward sequence infrastructure to extend the dshow stuff so that it
// works nicely from c++
// Copyright (c) Microsoft Corporation 1995-1999.
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef FWDSEQ_H
#define FWDSEQ_H

#include <arity.h>

template<class Base, class Enumerator_Type, class Value_Type,
         class Base_Inner = Base,
         class Enumerator_Type_Inner = Enumerator_Type,
         class Value_Type_Inner = Value_Type,
         class Allocator = Value_Type::stl_allocator>  class Forward_Sequence;

// NOTE: all of this stuff with the indirected static templated functions for fetch, reset, next
// is to get around an assortment of compiler bugs.
// a) you can't have a pointer to a member function as a template parm if it references earlier template parms
// b) in the initializations of these fetch,reset,next functions if we globally initialize the
// constructor isn't getting called and the vtable isn't set up.  hence we create them off the
// heap at runtime.

// enumerator_iterator
// this is an stl based forward iterator for dealing with legacy com enumerators with no prev method
template<
    class Enumerator_Type,
    class Value_Type,
    class Enumerator_Type_Inner = Enumerator_Type,
    class Value_Type_Inner = Value_Type,
    class difference_type = ptrdiff_t
    > class enumerator_iterator : public std::iterator<std::forward_iterator_tag, Value_Type, difference_type> {
public:
    // these are for com enumerators so use __stdcall version of binders
    static std_arity0pmf<Enumerator_Type_Inner, HRESULT> *Reset;
    static std_arity1pmf<Enumerator_Type_Inner, Value_Type_Inner *, HRESULT> *Next;

        inline enumerator_iterator(const Enumerator_Type e = Enumerator_Type(), const Value_Type c = Value_Type()) : enumerator_state(e), current_value(c) {
                if (enumerator_state != NULL) {
                        if (!current_value) {
#ifdef FORWARD_TRACE
                TRACELM(TRACE_PAINT, "enumerator_iterator constructor, attempting reset");
#endif
                                Enumerator_Type_Inner *peti = enumerator_state;
                                HRESULT hr = (*Reset)(*peti);
                                if (SUCCEEDED(hr)) {
                                        Value_Type temp_val;
#ifdef FORWARD_TRACE
                    TRACELM(TRACE_PAINT, "enumerator_iterator constructor, attempting next()");
#endif
                                        hr = (*Next)(*peti, &temp_val);
                                        if (SUCCEEDED(hr) && hr != S_FALSE) {
                                                current_value = temp_val;
#ifdef FORWARD_TRACE
                                                TRACELSM(TRACE_PAINT, (dbgDump << "enumerator_iterator constructor, set to first value = " << current_value), "");
#endif
                                        }
#ifdef FORWARD_TRACE
                                TRACELSM(TRACE_PAINT, (dbgDump << "enumerator_iterator constructor, next() hr = " << hr), "");
#endif
                                }
                        }
                } else {
                        current_value = Value_Type();
                }
#ifdef FORWARD_TRACE
        TRACELM(TRACE_PAINT, "enumerator_iterator constructor complete");
#endif
        }
        inline enumerator_iterator(const enumerator_iterator &e) : enumerator_state(e.enumerator_state), current_value(e.current_value) {}

        inline Value_Type operator*() const     { return current_value; }
        inline enumerator_iterator& operator++() {
                if (enumerator_state) {
                        Value_Type temp_val;
                        Enumerator_Type_Inner *peti = enumerator_state;
                        HRESULT hr = (*Next)(*peti, &temp_val);
                        if (SUCCEEDED(hr) && (hr != S_FALSE)) {
                                current_value = temp_val;
                        } else {
                                current_value = Value_Type();
                        }
                } else {
                        current_value = Value_Type();
                }
                return (*this);
        }
        inline enumerator_iterator operator++(int)      {
                enumerator_iterator Tmp = *this;
                ++*this;
                return (Tmp);
        }
        inline enumerator_iterator& operator=(const enumerator_iterator &e) {
                if (&e != this) {
                        enumerator_state = e.enumerator_state;
                        current_value = e.current_value;
                }
                return *this;
        }
        inline bool operator==(const enumerator_iterator& e) const {
#ifdef FORWARD_TRACE
                TRACELSM(TRACE_PAINT, (dbgDump << "enumerator_iterator operator==() current_value = " << current_value << " e.current_value = " << e.current_value), "");
#endif
                return (current_value == e.current_value);
        }
        inline bool operator!=(const enumerator_iterator& e) const
                {return (!(*this == e)); }
        inline Value_Type CurrentValue() const
                {return current_value; }
        protected:
                Enumerator_Type enumerator_state;
                Value_Type current_value;
};

// const_enumerator_iterator
template<class Enumerator_Type, class Value_Type,
                 class Enumerator_Type_Inner = Enumerator_Type,
                 class Value_Type_Inner = Value_Type,
                 class difference_type = ptrdiff_t> class const_enumerator_iterator :
                        public enumerator_iterator<Enumerator_Type, 
                                                   Value_Type,                                                                           
                                                   Enumerator_Type_Inner, 
                                                   Value_Type_Inner, 
                                                   difference_type> {
public:
        inline const_enumerator_iterator(const Enumerator_Type e = Enumerator_Type(), const Value_Type c = Value_Type()) :
                enumerator_iterator<Enumerator_Type, 
                                    Value_Type,
                                    Enumerator_Type_Inner, 
                                    Value_Type_Inner, 
                                    difference_type>(e, c) {}
        inline const_enumerator_iterator(const enumerator_iterator<Enumerator_Type, 
                                                                   Value_Type,
                                                                   Enumerator_Type_Inner,
                                                                   Value_Type_Inner, 
                                                                   difference_type> &e) :
                enumerator_iterator<Enumerator_Type, 
                                    Value_Type,
                                    Enumerator_Type_Inner, 
                                    Value_Type_Inner, 
                                    difference_type>(e) {}
        inline const_enumerator_iterator(const const_enumerator_iterator &e) :
                        enumerator_iterator<Enumerator_Type, 
                                            Value_Type,
                                            Enumerator_Type_Inner, 
                                            Value_Type_Inner, 
                                            difference_type>(e) {}
        inline const Value_Type operator*() const {
        return enumerator_iterator<Enumerator_Type, 
                                   Value_Type,
                                   Enumerator_Type_Inner,
                                   Value_Type_Inner, 
                                   difference_type>::operator*(); }
        inline const_enumerator_iterator& operator=(const const_enumerator_iterator &e) {
                if (&e != this) {
                        enumerator_iterator<Enumerator_Type, 
                                            Value_Type,
                                            Enumerator_Type_Inner,
                                            Value_Type_Inner, 
                                            difference_type>::operator=(e);
                }
                return *this;
        }
};

// this is a stl based template for containing legacy com collections
// this is *almost* a standard stl sequence container class.  the reason its
// not a complete sequence container is because for many of the com enumerators we have no prev method
// and therefore, no efficient way of reverse iterating through the collection.
// so we can't provide a bidirectional iterator only a forward one.
// call this a forward sequence container if you will

// Base is smart pointer wrapper class being contained in this container
// Base_Inner is actual wrapped class that the smart pointer class contains(usually com IXXX).
// if you're making a forward_sequence out of some ordinary class instead of a smart pointer class
// then use the default and make both Base_Inner == Base
template<
    class Base,
    class Enumerator_Type,
    class Value_Type,
    class Base_Inner = Base,
    class Enumerator_Type_Inner = Enumerator_Type,
    class Value_Type_Inner = Value_Type,
    class Allocator = Value_Type::stl_allocator
>  class Forward_Sequence : public Base {
public:

    Forward_Sequence(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL) : Base(rclsid, pUnkOuter, dwClsContext) {}
    virtual ~Forward_Sequence() {}

    typedef Allocator::value_type value_type;
        typedef Allocator::value_type& reference;
        typedef const Allocator::value_type& const_reference;
        typedef Allocator::size_type size_type;
        typedef Allocator::difference_type difference_type;



    // the compiler doesn't recognize this typedef in this template.  but, derived classes
    // can refer to it.
    typedef std_arity1pmf<Base_Inner, Enumerator_Type_Inner **, HRESULT> FetchType;

    static FetchType* Fetch;

    virtual FetchType* GetFetch() const {
        return Fetch;
    }

        typedef enumerator_iterator<Enumerator_Type, 
                                    Value_Type, 
                                    Enumerator_Type_Inner, 
                                    Value_Type_Inner, 
                                    difference_type> iterator;
        friend iterator;

        typedef const_enumerator_iterator<Enumerator_Type, 
                                          Value_Type, 
                                          Enumerator_Type_Inner, 
                                          Value_Type_Inner, 
                                          difference_type> const_iterator;
        friend const_iterator;

        Forward_Sequence() {}
        Forward_Sequence(const Forward_Sequence &a) : Base(a) { }
        Forward_Sequence(const Base &a) : Base(a) {}
        Forward_Sequence(Base_Inner *p) : Base(p) {}
		Forward_Sequence(IUnknown *p) : Base(p) {}
        iterator begin() {
                Enumerator_Type temp_enum;
                if (!(*this)) {
                    return iterator();
                }
#ifdef FORWARD_TRACE
        TRACELM(TRACE_DETAIL, "iterator ForwardSequence::begin() attempting fetch");
#endif
        Base_Inner *peti = *this;
        HRESULT hr = (*(GetFetch()))(*peti, &temp_enum);
                if (SUCCEEDED(hr)) {
#ifdef FORWARD_TRACE
            TRACELM(TRACE_DETAIL, "iterator ForwardSequence::begin() fetch succeeded");
#endif
                        return iterator(temp_enum);
                } else {
#ifdef FORWARD_TRACE
            TRACELM(TRACE_DETAIL, "iterator ForwardSequence::begin() fetch failed");
#endif
                        return iterator();
                }
        }
        const_iterator begin() const {
                Enumerator_Type temp_enum;
#ifdef FORWARD_TRACE
        TRACELM(TRACE_DETAIL, "const_iterator ForwardSequence::begin() attempting fetch");
#endif
        Base_Inner *peti = *this;
                HRESULT hr = (*(GetFetch()))(*peti, &temp_enum);
                if (SUCCEEDED(hr)) {
#ifdef FORWARD_TRACE
            TRACELM(TRACE_DETAIL, "const_iterator ForwardSequence::begin() fetch succeeded");
#endif
            return iterator(temp_enum);
                } else {
#ifdef FORWARD_TRACE
            TRACELM(TRACE_DETAIL, "const_iterator ForwardSequence::begin() fetch failed");
#endif
                        return iterator();
                }
        }

        iterator end() {
#ifdef FORWARD_TRACE
            TRACELM(TRACE_DETAIL, "iterator ForwardSequence::end()");
#endif
            return iterator();
        }
        const_iterator end() const { return const_iterator(); }

};


#endif
// end of file fwdseq.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\ksextend.h ===
//==========================================================================;
//
// ksextend.h : additional infrastructure to extend the ks stuff so that it
// works nicely from c++
// Copyright (c) Microsoft Corporation 1995-1997.
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef KSEXTEND_H
#define KSEXTEND_H

#include <strmif.h>
#include <uuids.h>

#include <ks.h>
#include <ksmedia.h>
//NOTE: ksproxy won't define IKsPin without __STREAMS__ and then it requires CMediaType from 
// mtype.h
#define __STREAMS__
// for some reason in the area of media types the am guys have severely blurred the distinction
// between their public client interface for apps and their internal class hierarchy for building
// filters.  mtype.h and mtype.cpp should be combined and placed into \sdk\include instead of
// classes\base\include.  they should also put an ifdef MMSYSTEM_H around their definitions
// that use WAVEFORMATEX, so its not necessary to put all that stuff into your app if you're not
// using it.  to work around this i'm using the following hack:
#include <mtype.h>

#include <ksproxy.h>
#include <stextend.h>
#include <w32extend.h>

const int KSMEDIUM_INPUTFLAG = 0x1;
typedef unsigned char UBYTE;

typedef CComQIPtr<IKsPropertySet, &IID_IKsPropertySet> PQKSPropertySet;
typedef CComQIPtr<IKsPin, &__uuidof(IKsPin)> PQKSPin;

class KSPinMedium : public KSIDENTIFIER {
public:
    KSPinMedium() { memset(this, 0, sizeof(*this)); }
    KSPinMedium(REFGUID SetInit, ULONG IdInit, ULONG FlagsInit) {
        Set = SetInit;
        Id = IdInit;
        Flags = FlagsInit;
    }
    KSPinMedium(const KSPinMedium &rhs) {
        Set = rhs.Set;
        Id = rhs.Id;
        Flags = rhs.Flags;
    }
    KSPinMedium(const KSIDENTIFIER &rhs) {
        Set = rhs.Set;
        Id = rhs.Id;
        Flags = rhs.Flags;
    }

    KSPinMedium& operator=(const KSPinMedium &rhs) {
        if (&rhs != this) {
            Set = rhs.Set;
            Id = rhs.Id;
            Flags = rhs.Flags;
        }
        return *this;
    }

#if 0
    // hopefully we can get the ks guys to fix their anonymous union problem
    // so that we don't need this hack
    operator KSIDENTIFIER() { return *(reinterpret_cast<KSIDENTIFIER*>(this)); }
#endif

    KSPinMedium& operator=(const KSIDENTIFIER &rhs) {
        if (&rhs != reinterpret_cast<KSIDENTIFIER*>(this)) {
            Set = rhs.Set;
            Id = rhs.Id;
            Flags = rhs.Flags;
        }
        return *this;
    }
    bool operator==(const KSPinMedium &rhs) const {
        // NOTE: at some point there will be a flag in Flags to
        // indicate whether or not Id is significant for this object
        // at that point this method will need to change
        return (Id == rhs.Id && Set == rhs.Set);
    }
    bool operator!=(const KSPinMedium &rhs) const {
        // NOTE: at some point there will be a flag in Flags to
        // indicate whether or not Id is significant for this object
        // at that point this method will need to change
        return !(*this == rhs);
    }
};


#ifdef _DEBUG
inline tostream &operator<<(tostream &dc, const KSPinMedium &g) {
        GUID2 g2(g.Set);
        dc << _T("KsPinMedium( ");
        g2.Dump(dc);
        dc << _T(", ") << hexdump(g.Id) << _T(", ") << hexdump(g.Flags) << _T(")");
        return dc;
}
#if 0
inline CDumpContext &operator<<(CDumpContext &dc, const KSPinMedium &g) {
        GUID2 g2(g.Set);
        dc << "KsPinMedium( ";
        g2.Dump(dc);
        dc << ", " << hexdump(g.Id) << ", " << hexdump(g.Flags) << ")";
        return dc;
}

template<> struct equal_to<KSPinMedium> {
    bool operator()(const KSPinMedium& _X, const KSPinMedium& _Y) const {
        TraceDump << "equal_to<KSPinMedium> x = " << _X << " y = " << _Y;
                return (_X == _Y);
    }
};
#endif

#endif

const KSPinMedium NULL_MEDIUM(GUID_NULL, 0, 0);
const KSPinMedium HOST_MEMORY_MEDIUM(KSMEDIUMSETID_Standard, 0, 0);

// this is basically a CComQIPtr with appropriate CoMem* allocate/copy semantics
// instead of refcount semantics and without the QI stuff.
class PQKsMultipleItem {
public:
    KSMULTIPLE_ITEM *p;

    PQKsMultipleItem() : p(NULL) {}
    virtual ~PQKsMultipleItem() {
        if (p) {
            CoTaskMemFree(p);
            p = NULL;
        }
    }

    operator KSMULTIPLE_ITEM*() const {return p;}
    KSMULTIPLE_ITEM& operator*() const {_ASSERTE(p!=NULL); return *p; }
    KSMULTIPLE_ITEM ** operator&() {ASSERT(p == NULL); return &p; }
    KSMULTIPLE_ITEM * operator->() const {_ASSERTE(p!=NULL); return p; }
    PQKsMultipleItem * address(void) { return this; }
    const PQKsMultipleItem * const_address(void) const { return this; }

    // this is expensive.  don't do it unless you have to.
    PQKsMultipleItem& operator=(const KSMULTIPLE_ITEM &d) {
        if (&d != p) {
            if (p) {
                CoTaskMemFree(p);
            }
            p = reinterpret_cast<KSMULTIPLE_ITEM *>(CoTaskMemAlloc(d.Size));
            memcpy(p, &d, d.Size);
        }
        return *this;
    }
    PQKsMultipleItem& operator=(const KSMULTIPLE_ITEM *pd) {
        if (pd != p) {
            if (p) {
                CoTaskMemFree(p);
            }
            p = reinterpret_cast<KSMULTIPLE_ITEM *>(CoTaskMemAlloc(pd->Size));
            memcpy(p, pd, pd->Size);
        }
        return *this;
    }
    PQKsMultipleItem& operator=(const PQKsMultipleItem &d) {
        if (d.const_address() != this) {
            if (p) {
                CoTaskMemFree(p);
            }
            p = reinterpret_cast<KSMULTIPLE_ITEM *>(CoTaskMemAlloc(d.p->Size));
            memcpy(p, d.p, d.p->Size);
        }
        return *this;
    }
    PQKsMultipleItem& operator=(int d) {
        if (p) {
            CoTaskMemFree(p);
            p = NULL;
        }
        return *this;
    }

#if 0
    bool operator==(const PQKsMultipleItem &d) const {
        return p->majortype == d.p->majortype &&
               (p->subtype == GUID_NULL || d.p->subtype == GUID_NULL || p->subtype == d.p->subtype);
    }
    bool operator!=(const PQKsMultipleItem &d) const {
        return !(*this == d);
    }
#endif

private:
    // i don't want spend the time to do a layered refcounted implementation here
    // but since these are CoTaskMem alloc'd we can't have multiple ref's without
    // a high risk of leaks.  so we're just going to disallow the copy constructor
    // since copying is expensive anyway.  we will allow explicit assignment which will
    // do a copy

    PQKsMultipleItem(const PQKsMultipleItem &d);

};

// this is a stl based template for containing KSMULTIPLEITEM lists
// i've only implemented the stuff i need for certain of the stl predicates so this
// isn't a complete collection with a true random access or bidirectional iterator
// furthermore this won't work correctly with hterogeneous KSMULTIPLEITEM lists it
// also won't work right for KSMI lists that have sizes and count headers in the sub items.
// it could be easily extended to do all of these things but i don't have time and all
// i need it for is mediums

// Base is smart pointer wrapper class being contained in this container
// Base_Inner is actual wrapped class that the smart pointer class contains
template<class Value_Type, class Allocator = std::allocator<Value_Type> >  class KsMultipleItem_Sequence : public PQKsMultipleItem {
public:

    typedef Allocator::value_type value_type;
        typedef Allocator::size_type size_type;
        typedef Allocator::difference_type difference_type;
        typedef Allocator allocator_type;
    typedef Allocator::pointer value_ptr;
    typedef Allocator::const_pointer value_cptr;
        typedef Allocator::reference reference;
        typedef Allocator::const_reference const_reference;


    // CLASS iterator
        class iterator;
        friend class iterator;
        class iterator : public std::_Bidit<Value_Type, difference_type> {
        public:
			iterator(KsMultipleItem_Sequence<Value_Type, Allocator> *outerinit = NULL, value_type *currentinit = NULL) :
				outer(outerinit), current(currentinit) {}
			iterator(iterator &e) : current(e.current), outer(e.outer) {}
			reference operator*() const {return *current;}
			value_ptr operator->() const {return current; }
			iterator& operator++() {
				if (current) {
					current++;
					if (current >= reinterpret_cast<value_type *>(reinterpret_cast<UBYTE *>(outer->p) + outer->p->Size)) {
						current = NULL;
					}
				} else {
					current = reinterpret_cast<value_type *>(const_cast<UBYTE *>(reinterpret_cast<const UBYTE *>(outer->p)) + sizeof(KSMULTIPLE_ITEM));
				}
				return *this;
			}
			iterator& operator++(int) {
				iterator Tmp = *this;
				++*this;
				return Tmp; 
			}
			iterator& operator--() {
				if (current) {
					current--;
					if (current < reinterpret_cast<value_type *>(const_cast<UBYTE *>(reinterpret_cast<const UBYTE *>(outer->p)) + sizeof(KSMULTIPLE_ITEM))) {
						current = NULL;
					}
				} else {
					current = reinterpret_cast<value_type *>(reinterpret_cast<UBYTE *>(outer->p) + (outer->p->Size - sizeof(value_type)));
				}
				return (*this);
			}
			iterator operator--(int) {
				iterator _Tmp = *this;
				--*this;
				return (_Tmp);
			}
			bool operator==(const iterator& rhs) const
					{return (current == rhs.current); }
			bool operator!=(const iterator& rhs) const
					{return (!(*this == rhs)); }
        protected:
			value_type *current;
			const KsMultipleItem_Sequence<Value_Type, Allocator> *outer;
        };
                // CLASS const_iterator
        class const_iterator;
        friend class const_iterator;
        class const_iterator : public iterator {
        public:
			const_iterator(const KsMultipleItem_Sequence<Value_Type, Allocator> *outerinit = NULL, value_type *currentinit = NULL) {
				outer = outerinit;
				current = currentinit;
			}
			const_iterator(const_iterator &e) {
				current = e.current;
				outer = e.outer;
			}
			const_reference operator*() const {return iterator::operator*(); }
			value_cptr operator->() const {return iterator::operator->(); }
			const_iterator& operator++() { iterator::operator++(); return *this;}
			const_iterator operator++(int) {
							const_iterator Tmp = *this;
							++*this;
							return (Tmp);
			}
			const_iterator& operator--() {iterator::operator--(); return (*this); }
			const_iterator operator--(int) {
							const_iterator Tmp = *this;
							--*this;
							return (Tmp); 
			}
            bool operator==(const const_iterator& rhs) const
		        {return iterator::operator==(rhs); }
            bool operator!=(const const_iterator& rhs) const
                {return (!(*this == rhs)); }
        };

		KsMultipleItem_Sequence() {}
		virtual ~KsMultipleItem_Sequence() {}
		iterator begin() {
			return iterator(this, ((p->Count) ? reinterpret_cast<value_ptr>(reinterpret_cast<UBYTE *>(p) + sizeof(KSMULTIPLE_ITEM)) : NULL));
		}
		const_iterator begin() const {
			return const_iterator(this, ((p->Count) ? reinterpret_cast<value_ptr>(reinterpret_cast<UBYTE *>(p) + sizeof(KSMULTIPLE_ITEM)) : NULL));
		}
		iterator end() { return iterator(); }
		const_iterator end() const { return const_iterator(); }
		size_type size() const {
			return p->Count;
		}



private:
    // no copy constructor, its too expensive.  see PQKsMultiple item for further details
        KsMultipleItem_Sequence(KsMultipleItem_Sequence &a);
        KsMultipleItem_Sequence(PQKsMultipleItem &a);

};

typedef KsMultipleItem_Sequence<KSPinMedium> KSMediumList;


#endif
// end of file - ksextend.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\locatorimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// Locatorimpl.h : implementation helper template for locator interface
// Copyright (c) Microsoft Corporation 2000.

#ifndef LOCATORIMPL_H
#define LOCATORIMPL_H

namespace BDATuningModel {

template<class T,
         class MostDerived = ILocator, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE ILocatorImpl : 
    public IPersistPropertyBagImpl<T>,
	public IDispatchImpl<MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// ILocator
public:

	long m_Frequency;
	FECMethod m_InnerFECMethod;
	BinaryConvolutionCodeRate m_InnerFECRate;
	FECMethod m_OuterFECMethod;
	BinaryConvolutionCodeRate m_OuterFECRate;
	ModulationType m_Modulation;
    long m_SymbolRate;

    ILocatorImpl() : m_Frequency(-1),
 	                 m_InnerFECMethod(BDA_FEC_METHOD_NOT_SET),
 	                 m_InnerFECRate(BDA_BCC_RATE_NOT_SET),
 	                 m_OuterFECMethod(BDA_FEC_METHOD_NOT_SET),
	                 m_OuterFECRate(BDA_BCC_RATE_NOT_SET),
	                 m_SymbolRate(-1),
                     m_Modulation(BDA_MOD_NOT_SET) {}
    virtual ~ILocatorImpl() {}
    typedef ILocatorImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> thistype;
    BEGIN_PROP_MAP(thistype)
        PROP_DATA_ENTRY("Frequency", m_Frequency, VT_I4)
        PROP_DATA_ENTRY("InnerFECMethod", m_InnerFECMethod, VT_I4)
        PROP_DATA_ENTRY("InnerFECRate", m_InnerFECRate, VT_I4)
        PROP_DATA_ENTRY("OuterFECMethod", m_OuterFECMethod, VT_I4)
        PROP_DATA_ENTRY("OuterFECRate", m_OuterFECRate, VT_I4)
        PROP_DATA_ENTRY("ModulationType", m_Modulation, VT_I4)
        PROP_DATA_ENTRY("SymbolRate", m_SymbolRate, VT_I4)
    END_PROP_MAP()

// ILocator
public:
    STDMETHOD(get_CarrierFrequency)(/*[out, retval]*/ long *pFrequency) {
        try {
            if (!pFrequency) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pFrequency = m_Frequency;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_CarrierFrequency)(/*[in]*/ long NewFrequency) {
		ATL_LOCKT();
        m_Frequency = NewFrequency;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_InnerFEC)(/*[out, retval]*/ FECMethod *pFEC) {
        try {
            if (!pFEC) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pFEC = m_InnerFECMethod;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_InnerFEC)(/*[in]*/ FECMethod NewFEC) {
		ATL_LOCKT();
        m_InnerFECMethod = NewFEC;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_InnerFECRate)(/*[out, retval]*/ BinaryConvolutionCodeRate *pFECRate) {
        try {
            if (!pFECRate) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pFECRate = m_InnerFECRate;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_InnerFECRate)(/*[in]*/ BinaryConvolutionCodeRate NewFECRate) {
		ATL_LOCKT();
        m_InnerFECRate = NewFECRate;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_OuterFEC)(/*[out, retval]*/ FECMethod *pFEC) {
        try {
            if (!pFEC) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pFEC = m_OuterFECMethod;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_OuterFEC)(/*[in]*/ FECMethod NewFEC) {
		ATL_LOCKT();
        m_OuterFECMethod = NewFEC;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_OuterFECRate)(/*[out, retval]*/ BinaryConvolutionCodeRate *pFECRate) {
        try {
            if (!pFECRate) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pFECRate = m_OuterFECRate;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_OuterFECRate)(/*[in]*/ BinaryConvolutionCodeRate NewFECRate) {
		ATL_LOCKT();
        m_OuterFECRate = NewFECRate;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_Modulation)(/*[out, retval]*/ ModulationType* pModulation) {
        try {
            if (!pModulation) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pModulation = m_Modulation;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_Modulation)(/*[in]*/ ModulationType NewModulation) {
		ATL_LOCKT();
        m_Modulation = NewModulation;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_SymbolRate)(/*[out, retval]*/ long* pSymbolRate) {
        try {
            if (!pSymbolRate) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pSymbolRate = m_SymbolRate;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_SymbolRate)(/*[in]*/ long NewSymbolRate) {
		ATL_LOCKT();
        m_SymbolRate = NewSymbolRate;
        MARK_DIRTY(T);

	    return NOERROR;
    }
	STDMETHOD(Clone) (ILocator **ppL) {
		try {
			if (!ppL) {
				return E_POINTER;
			}
			ATL_LOCKT();
			T* pt = static_cast<T*>(new CComObject<T>);
			if (!pt) {
				return E_OUTOFMEMORY;
			}
			pt->m_Frequency = m_Frequency;
			pt->m_InnerFECMethod = m_InnerFECMethod;
			pt->m_InnerFECRate = m_InnerFECRate;
			pt->m_OuterFECMethod = m_OuterFECMethod;
			pt->m_OuterFECRate = m_OuterFECRate;
			pt->m_Modulation = m_Modulation;
            pt->m_SymbolRate = m_SymbolRate;
			pt->m_bRequiresSave = true;
			pt->AddRef();
			*ppL = pt;
			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}
};

}; // namespace

#endif // LOCATORIMPL_H
// end of file -- locatorimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\mpeg2componenttypeimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// MPEG2ComponentTypeimpl.h : implementation helper template for component type interface
// Copyright (c) Microsoft Corporation 1999.

#ifndef MPEG2COMPONENTTYPEIMPL_H
#define MPEG2COMPONENTTYPEIMPL_H

#include "languagecomponenttypeimpl.h"

namespace BDATuningModel {

template<class T,
         class MostDerived = IMPEG2ComponentType, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IMPEG2ComponentTypeImpl : 
	public ILanguageComponentTypeImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// IMPEG2ComponentType
public:
    MPEG2StreamType m_StreamType;

    IMPEG2ComponentTypeImpl() : m_StreamType(BDA_UNITIALIZED_MPEG2STREAMTYPE) {}
    virtual ~IMPEG2ComponentTypeImpl() {}
//    typedef IMPEG2ComponentTypeImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> thistype;
    typedef ILanguageComponentTypeImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    BEGIN_PROP_MAP(IMPEG2ComponentTypeImpl)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("Stream Type", m_StreamType, VT_I4)
    END_PROP_MAP()

    STDMETHOD(get_StreamType)(MPEG2StreamType *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_StreamType;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_StreamType)(MPEG2StreamType newVal)
    {
		ATL_LOCKT();
        m_StreamType = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
	STDMETHOD(Clone) (IComponentType **ppCT) {
		try {
			if (!ppCT) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppCT);
			if (FAILED(hr)) {
				return hr;
			}
			T* pt = static_cast<T*>(*ppCT);
			pt->m_StreamType = m_StreamType;

			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}
};

}; // namespace

#endif // MPEG2COMPONENTTYPEIMPL_H
// end of file -- MPEG2componenttypeimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\mpeg2componentimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// MPEG2Componentimpl.h : implementation helper template for MPEG2component interface
// Copyright (c) Microsoft Corporation 1999.

#ifndef MPEG2COMPONENTIMPL_H
#define MPEG2COMPONENTIMPL_H

#include "componentimpl.h"
#include "MPEG2componenttype.h"

namespace BDATuningModel {

template<class T,
         class MostDerived = IMPEG2Component, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IMPEG2ComponentImpl : 
	public IComponentImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// IMPEG2Component
public:
    long m_PID;
    long m_PCRPID;
	long m_ProgramNumber;

    IMPEG2ComponentImpl() : m_PID(-1),
                            m_PCRPID(-1),
                            m_ProgramNumber(-1) {}
    virtual ~IMPEG2ComponentImpl() {}
    typedef IMPEG2ComponentImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> thistype;
	typedef IComponentImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;
    BEGIN_PROP_MAP(thistype)
        CHAIN_PROP_MAP(basetype)		
        PROP_DATA_ENTRY("PID", m_PID, VT_I4)
        PROP_DATA_ENTRY("PCRPID", m_PCRPID, VT_I4)
        PROP_DATA_ENTRY("ProgramNumber", m_ProgramNumber, VT_I4)
    END_PROP_MAP()

// IMPEG2Component
public:
    STDMETHOD(put_Type)(/*[in]*/ IComponentType*  pNewVal) {
        try {
            if (!pNewVal) {
                return E_POINTER;
            }
            PQMPEG2ComponentType pT(pNewVal);
            if (!pT) {
                return DISP_E_TYPEMISMATCH;
            }
            return basetype::put_Type(pNewVal);
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(get_PID)(/*[out, retval]*/ long *pPID) {
        try {
            if (!pPID) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pPID = m_PID;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_PID)(/*[in]*/ long NewPID) {
		ATL_LOCKT();
        m_PID = NewPID;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_PCRPID)(/*[out, retval]*/ long *pPCRPID) {
        try {
            if (!pPCRPID) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pPCRPID = m_PCRPID;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_PCRPID)(/*[in]*/ long NewPCRPID) {
        m_PCRPID = NewPCRPID;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_ProgramNumber)(/*[out, retval]*/ long *pProgramNumber) {
        try {
            if (!pProgramNumber) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pProgramNumber = m_ProgramNumber;
            return NOERROR;
        } catch (...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_ProgramNumber)(/*[in]*/ long NewProgramNumber) {
		ATL_LOCKT();
        m_ProgramNumber = NewProgramNumber;
        MARK_DIRTY(T);

	    return NOERROR;
    }
	STDMETHOD(Clone) (IComponent **ppNew) {
		try {
			if (!ppNew) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppNew);
			if (FAILED(hr)) {
				return hr;
			}
            T* pt = static_cast<T*>(*ppNew);
			pt->m_PCRPID = m_PCRPID;
			pt->m_PID = m_PID;
			pt->m_ProgramNumber = m_ProgramNumber;
			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}
};

}; // namespace
#endif // MPEG2COMPONENTIMPL_H
// end of file -- MPEG2componentimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\mtype.cpp ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 1999  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Class that holds and manages media type information, December 1994

// helper class that derived pin objects can use to compare media
// types etc. Has same data members as the struct AM_MEDIA_TYPE defined
// in the streams IDL file, but also has (non-virtual) functions

#include "stdafx.h"
#include <streams.h>
#include <mmreg.h>

CMediaType::~CMediaType(){
    FreeMediaType(*this);
}


CMediaType::CMediaType()
{
    InitMediaType();
}


CMediaType::CMediaType(const GUID * type)
{
    InitMediaType();
    majortype = *type;
}


// copy constructor does a deep copy of the format block

CMediaType::CMediaType(const AM_MEDIA_TYPE& rt)
{
    CopyMediaType(this, &rt);
}

CMediaType::CMediaType(const CMediaType& rt)
{
    CopyMediaType(this, &rt);
}

// this class inherits publicly from AM_MEDIA_TYPE so the compiler could generate
// the following assignment operator itself, however it could introduce some
// memory conflicts and leaks in the process because the structure contains
// a dynamically allocated block (pbFormat) which it will not copy correctly

CMediaType&
CMediaType::operator=(const AM_MEDIA_TYPE& rt)
{
    if (&rt != this) {
        FreeMediaType(*this);
        CopyMediaType(this, &rt);
    }
    return *this;
}


CMediaType&
CMediaType::operator=(const CMediaType& rt)
{
    *this = (AM_MEDIA_TYPE &) rt;
    return *this;
}

BOOL
CMediaType::operator == (const CMediaType& rt) const
{
    // I don't believe we need to check sample size or
    // temporal compression flags, since I think these must
    // be represented in the type, subtype and format somehow. They
    // are pulled out as separate flags so that people who don't understand
    // the particular format representation can still see them, but
    // they should duplicate information in the format block.

    return ((IsEqualGUID(majortype,rt.majortype) == TRUE) &&
        (IsEqualGUID(subtype,rt.subtype) == TRUE) &&
        (IsEqualGUID(formattype,rt.formattype) == TRUE) &&
        (cbFormat == rt.cbFormat) &&
        ( (cbFormat == 0) ||
          (memcmp(pbFormat, rt.pbFormat, cbFormat) == 0)));
}


BOOL
CMediaType::operator != (const CMediaType& rt) const
{
    /* Check to see if they are equal */

    if (*this == rt) {
        return FALSE;
    }
    return TRUE;
}


BOOL
CMediaType::IsValid() const
{
    return (!IsEqualGUID(majortype,GUID_NULL));
}


void
CMediaType::SetType(const GUID* ptype)
{
    majortype = *ptype;
}


void
CMediaType::SetSubtype(const GUID* ptype)
{
    subtype = *ptype;
}


ULONG
CMediaType::GetSampleSize() const {
    if (IsFixedSize()) {
        return lSampleSize;
    } else {
        return 0;
    }
}


void
CMediaType::SetSampleSize(ULONG sz) {
    if (sz == 0) {
        SetVariableSize();
    } else {
        bFixedSizeSamples = TRUE;
        lSampleSize = sz;
    }
}


void
CMediaType::SetVariableSize() {
    bFixedSizeSamples = FALSE;
}


void
CMediaType::SetTemporalCompression(BOOL bCompressed) {
    bTemporalCompression = bCompressed;
}

BOOL
CMediaType::SetFormat(BYTE * pformat, ULONG cb)
{
    if (NULL == AllocFormatBuffer(cb))
	return(FALSE);

    ASSERT(pbFormat);
    // pbFormat is memory CoTaskMemAlloc'd cb in length, in the AllocFormatBuffer function
    memcpy(pbFormat, pformat, cb);
    return(TRUE);
}


// set the type of the media type format block, this type defines what you
// will actually find in the format pointer. For example FORMAT_VideoInfo or
// FORMAT_WaveFormatEx. In the future this may be an interface pointer to a
// property set. Before sending out media types this should be filled in.

void
CMediaType::SetFormatType(const GUID *pformattype)
{
    formattype = *pformattype;
}


// reset the format buffer

void CMediaType::ResetFormatBuffer()
{
    if (cbFormat) {
        CoTaskMemFree((PVOID)pbFormat);
    }
    cbFormat = 0;
    pbFormat = NULL;
}


// allocate length bytes for the format and return a read/write pointer
// If we cannot allocate the new block of memory we return NULL leaving
// the original block of memory untouched (as does ReallocFormatBuffer)

BYTE*
CMediaType::AllocFormatBuffer(ULONG length)
{
    ASSERT(length);

    // do the types have the same buffer size

    if (cbFormat == length) {
        return pbFormat;
    }

    // allocate the new format buffer

    BYTE *pNewFormat = (PBYTE)CoTaskMemAlloc(length);
    if (pNewFormat == NULL) {
        if (length <= cbFormat) return pbFormat; //reuse the old block anyway.
        return NULL;
    }

    // delete the old format

    if (cbFormat != 0) {
        ASSERT(pbFormat);
        CoTaskMemFree((PVOID)pbFormat);
    }

    cbFormat = length;
    pbFormat = pNewFormat;
    return pbFormat;
}


// reallocate length bytes for the format and return a read/write pointer
// to it. We keep as much information as we can given the new buffer size
// if this fails the original format buffer is left untouched. The caller
// is responsible for ensuring the size of memory required is non zero

BYTE*
CMediaType::ReallocFormatBuffer(ULONG length)
{
    ASSERT(length);

    // do the types have the same buffer size

    if (cbFormat == length) {
        return pbFormat;
    }

    // allocate the new format buffer

    BYTE *pNewFormat = (PBYTE)CoTaskMemAlloc(length);
    if (pNewFormat == NULL) {
        if (length <= cbFormat) return pbFormat; //reuse the old block anyway.
        return NULL;
    }

    // copy any previous format (or part of if new is smaller)
    // delete the old format and replace with the new one

    if (cbFormat != 0) {
        ASSERT(pbFormat);
        memcpy(pNewFormat,pbFormat,min(length,cbFormat));
        CoTaskMemFree((PVOID)pbFormat);
    }

    cbFormat = length;
    pbFormat = pNewFormat;
    return pNewFormat;
}

// initialise a media type structure

void CMediaType::InitMediaType()
{
    ZeroMemory((PVOID)this, sizeof(*this));
    lSampleSize = 1;
    bFixedSizeSamples = TRUE;
}


// a partially specified media type can be passed to IPin::Connect
// as a constraint on the media type used in the connection.
// the type, subtype or format type can be null.
BOOL
CMediaType::IsPartiallySpecified(void) const
{
    if ((majortype == GUID_NULL) ||
        (formattype == GUID_NULL)) {
            return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
CMediaType::MatchesPartial(const CMediaType* ppartial) const
{
    if ((ppartial->majortype != GUID_NULL) &&
        (majortype != ppartial->majortype)) {
            return FALSE;
    }
    if ((ppartial->subtype != GUID_NULL) &&
        (subtype != ppartial->subtype)) {
            return FALSE;
    }

    if (ppartial->formattype != GUID_NULL) {
        // if the format block is specified then it must match exactly
        if (formattype != ppartial->formattype) {
            return FALSE;
        }
        if (cbFormat != ppartial->cbFormat) {
            return FALSE;
        }
        if ((cbFormat != 0) &&
            (memcmp(pbFormat, ppartial->pbFormat, cbFormat) != 0)) {
                return FALSE;
        }
    }

    return TRUE;

}



// general purpose function to delete a heap allocated AM_MEDIA_TYPE structure
// which is useful when calling IEnumMediaTypes::Next as the interface
// implementation allocates the structures which you must later delete
// the format block may also be a pointer to an interface to release

void WINAPI DeleteMediaType(AM_MEDIA_TYPE *pmt)
{
    // allow NULL pointers for coding simplicity

    if (pmt == NULL) {
        return;
    }

    FreeMediaType(*pmt);
    CoTaskMemFree((PVOID)pmt);
}


// this also comes in useful when using the IEnumMediaTypes interface so
// that you can copy a media type, you can do nearly the same by creating
// a CMediaType object but as soon as it goes out of scope the destructor
// will delete the memory it allocated (this takes a copy of the memory)

AM_MEDIA_TYPE * WINAPI CreateMediaType(AM_MEDIA_TYPE const *pSrc)
{
    ASSERT(pSrc);

    // Allocate a block of memory for the media type

    AM_MEDIA_TYPE *pMediaType =
        (AM_MEDIA_TYPE *)CoTaskMemAlloc(sizeof(AM_MEDIA_TYPE));

    if (pMediaType == NULL) {
        return NULL;
    }
    // Copy the variable length format block

    CopyMediaType(pMediaType,pSrc);

    return pMediaType;
}


//  Copy 1 media type to another

void WINAPI CopyMediaType(AM_MEDIA_TYPE *pmtTarget, const AM_MEDIA_TYPE *pmtSource)
{
    //  We'll leak if we copy onto one that already exists - there's one
    //  case we can check like that - copying to itself.
    ASSERT(pmtSource != pmtTarget);
    *pmtTarget = *pmtSource;
    if (pmtSource->cbFormat != 0) {
        ASSERT(pmtSource->pbFormat != NULL);
        pmtTarget->pbFormat = (PBYTE)CoTaskMemAlloc(pmtSource->cbFormat);
        if (pmtTarget->pbFormat == NULL) {
            pmtTarget->cbFormat = 0;
        } else {
            // pmtTarget->pbFormat equals memory CoTaskMemAlloc'd pmtSource->cbFormat in length
            CopyMemory((PVOID)pmtTarget->pbFormat, (PVOID)pmtSource->pbFormat,
                       pmtTarget->cbFormat);
        }
    }
    if (pmtTarget->pUnk != NULL) {
        pmtTarget->pUnk->AddRef();
    }
}

//  Free an existing media type (ie free resources it holds)

void WINAPI FreeMediaType(AM_MEDIA_TYPE& mt)
{
    if (mt.cbFormat != 0) {
        CoTaskMemFree((PVOID)mt.pbFormat);

        // Strictly unnecessary but tidier
        mt.cbFormat = 0;
        mt.pbFormat = NULL;
    }
    if (mt.pUnk != NULL) {
        mt.pUnk->Release();
        mt.pUnk = NULL;
    }
}

// eliminate very many spurious warnings from MS compiler
#pragma warning(disable:4514)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\mpeg2tunerequestimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// MPEG2TuneRequestimpl.h : implementation helper template for component type interface
// Copyright (c) Microsoft Corporation 1999.

#ifndef MPEG2TUNEREQUESTIMPL_H
#define MPEG2TUNEREQUESTIMPL_H

#include <tune.h>
#include "tunerequestimpl.h"

namespace BDATuningModel {

template<class T,
         class MostDerived = IMPEG2TuneRequest, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE IMPEG2TuneRequestImpl : 
	public ITuneRequestImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// IMPEG2TuneRequest
public:
	typedef ITuneRequestImpl<T, MostDerived, iid, LibID, wMajor, wMinor, tihclass> basetype;

	IMPEG2TuneRequestImpl() : m_TSID(-1), m_ProgNo(-1) {}
	virtual ~IMPEG2TuneRequestImpl() {}
    BEGIN_PROP_MAP(IMPEG2TuneRequestImpl)
        CHAIN_PROP_MAP(basetype)
        PROP_DATA_ENTRY("TSID", m_TSID, VT_I4)
        PROP_DATA_ENTRY("ProgNo", m_ProgNo, VT_I4)
    END_PROP_MAP()

	long m_TSID;
    long m_ProgNo;
    STDMETHOD(get_TSID)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_TSID;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_TSID)(long newVal)
    {
		ATL_LOCKT();
		if (!m_TS) {
			return E_UNEXPECTED;
		}
        m_TSID = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
    STDMETHOD(get_ProgNo)(long *pVal)
    {
        try {
            if (!pVal) {
                return E_POINTER;
            }
			ATL_LOCKT();
            *pVal = m_ProgNo;
        } catch (...) {
            return E_POINTER;
        }

	    return NOERROR;
    }

    STDMETHOD(put_ProgNo)(long newVal)
    {
		ATL_LOCKT();
		if (!m_TS) {
			return E_UNEXPECTED;
		}
        m_ProgNo = newVal;
        MARK_DIRTY(T);

	    return NOERROR;
    }
	STDMETHOD(Clone) (ITuneRequest **ppTR) {
		try {
			if (!ppTR) {
				return E_POINTER;
			}
			ATL_LOCKT();
			HRESULT hr = basetype::Clone(ppTR);
			if (FAILED(hr)) {
				return hr;
			}
			T* pt = static_cast<T*>(*ppTR);
			pt->m_TSID = m_TSID;
			pt->m_ProgNo = m_ProgNo;
			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}

};
typedef CComQIPtr<IMPEG2TuneRequest> PQMPEG2TuneRequest;

}; // namespace

#endif // MPEG2TUNEREQUESTIMPL_H
// end of file -- MPEG2tunerequestimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\objectwithsiteimplsec.h ===
///////////////////////////////////////////////////////////
// ObjectWithSiteImplSec.h : Secure implementation of IObjectWithSite
// Copyright (c) Microsoft Corporation 2002.

#pragma once

#ifndef OBJECTWITHSITEIMPLSEC_H
#define OBJECTWITHSITEIMPLSEC_H

#include <w32extend.h>

template<class T> 
class ATL_NO_VTABLE IObjectWithSiteImplSec : public IObjectWithSite {

public:

    PUnknown m_pSite;

// IObjectWithSite
    STDMETHOD(GetSite)(REFIID iid, void** ppvSite) {
        if (!ppvSite) {
            return E_POINTER;
        }
		T* pT = static_cast<T*>(this);

        if (!pT->m_pSite) {
            return E_NOINTERFACE;
        }
        return pT->m_pSite->QueryInterface(iid, ppvSite);
    }
    STDMETHOD(SetSite)(IUnknown* pSite) {
        HRESULT hr = IsSafeSite(pSite);
        if (SUCCEEDED(hr)) {
		    T* pT = static_cast<T*>(this);
            pT->m_pSite = pSite;
        }
        return hr;
    }

};

#endif // OBJECTWITHSITEIMPLSEC_H
// end of file objectwithsiteimplsec.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\objreghelp.h ===
//==========================================================================;
//
// reghelp : registration helpers that share .rgs scripts for various kinds of classes
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////
#pragma once

#ifndef OBJREGHELP_H_
#define OBJREGHELP_H_

#ifndef _ATL_STATIC_REGISTRY
#error these registration helpers only work when _ATL_STATIC_REGISTRY is defined
#endif

#include <atltmp.h>

// much code copied from atl's statreg.h

// atl middle layers filter out the registry return code and turns everything 
// into DISP_E_EXCEPTION.  by explicitly allocating a CRegObject
// and calling into it instead of through com into atl.dll we can
// trace in and figure out what's wrong with our script when we goof.

#ifndef MAX_GUID_LEN
#define MAX_GUID_LEN (39 * sizeof(OLECHAR))
#endif

__declspec(selectany) LPCOLESTR pszAutoReg = {
L"HKCR { "
	L"%COMPONENT%.%PROGID%.1 = s '%DESCRIPTION%' { "
		L"CLSID = s '%CLSID%' "
    L"} "
	L"%COMPONENT%.%PROGID% = s '%DESCRIPTION%' { "
		L"CLSID = s '%CLSID%' "
		L"CurVer = s '%COMPONENT%.%PROGID%.1' "
	L"} "
	L"NoRemove CLSID { "
		L"ForceRemove %CLSID% = s '%DESCRIPTION%' { "
			L"ProgID = s '%COMPONENT%.%PROGID%.1' "
			L"VersionIndependentProgID = s '%COMPONENT%.%PROGID%' "
			L"ForceRemove 'Programmable' "
			L"InprocServer32 = s '%MODULE%' { "
				L"val ThreadingModel = s '%THREAD%' "
			L"} "
			L"'TypeLib' = s '%TYPELIB%' "
		L"} "
	L"} "
L"} "
};

__declspec(selectany) LPCOLESTR pszNonAutoReg = {
L"HKCR { "
	L"NoRemove CLSID { "
		L"ForceRemove %CLSID% = s '%DESCRIPTION%' { "
			L"InprocServer32 = s '%MODULE%' { "
				L"val ThreadingModel = s '%THREAD%' "
			L"} "
			L"'TypeLib' = s '%TYPELIB%' "
		L"} "
	L"} "
L"} "
};


__declspec(selectany) LPCOLESTR pszFullControl = {
L"HKCR { "
	L"NoRemove CLSID { "
		L"%CLSID% { "
			L"ForceRemove 'Control' "
			L"ForceRemove 'Insertable' "
			L"ForceRemove 'ToolboxBitmap32' = s '%MODULE%, 101' "
			L"'MiscStatus' = s '0' { "
			    L"'1' = s '%OLEMISC%' "
			L"} "
			L"'Version' = s '%VERSION%' "
		L"} "
	L"} "
L"} "
};

__declspec(selectany) LPCOLESTR pszProtocol = {
L"HKCR { "
    L"NoRemove PROTOCOLS { "
		L"NoRemove Handler { "
			L"ForceRemove %PROTOCOL% { "
				L"val '' = s '%DESCRIPTION%' "
				L"val 'CLSID' = s '%CLSID%' "
			L"} "
		L"} "
    L"} "
L"} "
L"HKCU { "
    L"NoRemove Software { "
		L"NoRemove Microsoft { "
			L"NoRemove Windows { "
				L"NoRemove CurrentVersion { "
					L"NoRemove Internet Settings { "
						L"NoRemove ZoneMap { "
							L"NoRemove ProtocolDefaults { "
								L"val '%PROTOCOL%' = d 3 "
							L"} "
						L"} "
					L"} "
				L"} "
			L"} "
		L"} "
    L"} "
L"} "
};

enum MacroNameList {
	mnlModule,
	mnlComponent,
	mnlProgID,
	mnlCLSID,
	mnlDesc,
	mnlTypeLib,
	mnlVersion,
	mnlProtocol,
	mnlOleMisc,
	mnlThread,
};

__declspec(selectany) LPCOLESTR pszMacroNames[] = {
	L"MODULE",
	L"COMPONENT",
	L"PROGID",
	L"CLSID",
	L"DESCRIPTION",
	L"TYPELIB",
	L"VERSION",
	L"PROTOCOL",
	L"OLEMISC",
	L"THREAD",
};

enum ThreadVal {
	tvApartment,
	tvFree,
	tvBoth,
};

__declspec(selectany) LPCOLESTR pszThreadValNames[] = {
	L"Apartment",
	L"Free",
	L"Both",
};

using ::ATL::ATL::CRegObject;

class CObjRegHelp {
public:
	/////////// 
	static HRESULT InsertModuleName(CRegObject& ro) {
		/////////// from AtlLModuleupdate
		TCHAR szModule[_MAX_PATH];
		GetModuleFileName(_Module.m_hInst, szModule, _MAX_PATH);

		LPOLESTR pszModule;
		USES_CONVERSION;

		if ((_Module.m_hInst == NULL) || (_Module.m_hInst == GetModuleHandle(NULL))) { // register as EXE
			// Convert to short path to work around bug in NT4's CreateProcess
			TCHAR szModuleShort[_MAX_PATH];
			int cbShortName = GetShortPathName(szModule, szModuleShort, _MAX_PATH);

			if (cbShortName == _MAX_PATH)
				return E_OUTOFMEMORY;

			pszModule = (cbShortName == 0 || cbShortName == ERROR_INVALID_PARAMETER) ? T2OLE(szModule) : T2OLE(szModuleShort);
		} else {
			pszModule = T2OLE(szModule);
		}


		int nLen = ocslen(pszModule);
		LPOLESTR pszModuleQuote = new OLECHAR[nLen*2+1];
        if (!pszModuleQuote) {
            return E_OUTOFMEMORY;
        }
		CComModule::ReplaceSingleQuote(pszModuleQuote, pszModule);
		HRESULT hr = ro.AddReplacement(pszMacroNames[mnlModule], pszModuleQuote);
        delete[] pszModuleQuote;
        return hr;
	}
	/////////// 
	static HRESULT InsertGUID(CRegObject &ro, LPCOLESTR pszMacro, REFCLSID guid) {
			OLECHAR szGUID[MAX_GUID_LEN];
			int rc = StringFromGUID2(guid, szGUID, MAX_GUID_LEN);
			if (!rc) {
				return E_UNEXPECTED;
			}
			return ro.AddReplacement(pszMacro, szGUID);
	}

	/////////// 
	static HRESULT RegisterAutomationClass(bool bRegister,
									CRegObject& ro,
									const UINT nidComponent, 
									const UINT nidProgID, 
									const UINT nidDesc, 
									REFCLSID clsCLSID,
									REFCLSID clsTypeLib,
									ThreadVal tval = tvApartment) {

			USES_CONVERSION;
			// module
			HRESULT hr = InsertModuleName(ro);
			if (FAILED(hr)) {
				return hr;
			}

			// clsid
			hr = InsertGUID(ro, pszMacroNames[mnlCLSID], clsCLSID);
			if (FAILED(hr)) {
				return hr;
			}

			// typelib
			hr = InsertGUID(ro, pszMacroNames[mnlTypeLib], clsTypeLib);
			if (FAILED(hr)) {
				return hr;
			}

			// threading model
			hr = ro.AddReplacement(pszMacroNames[mnlThread], pszThreadValNames[tval]);
			if (FAILED(hr)) {
				return hr;
			}

			// component
			CString cs;
			if (!cs.LoadString(nidComponent)) {
				return E_INVALIDARG;
			}
			hr = ro.AddReplacement(pszMacroNames[mnlComponent], T2COLE(cs));
			if (FAILED(hr)) {
				return hr;
			}

			// progid
			if (!cs.LoadString(nidProgID)) {
				return E_INVALIDARG;
			}
			hr = ro.AddReplacement(pszMacroNames[mnlProgID], T2COLE(cs));
			if (FAILED(hr)) {
				return hr;
			}

			// desc
			if (!cs.LoadString(nidDesc)) {
				return E_INVALIDARG;
			}
			hr = ro.AddReplacement(pszMacroNames[mnlDesc], T2COLE(cs));
			if (FAILED(hr)) {
				return hr;
			}

			if (bRegister) {
				return ro.StringRegister(pszAutoReg);
			} else {
				return ro.StringUnregister(pszAutoReg);
			}
	}

	/////////// 
	static HRESULT RegisterNonAutomationClass(bool bRegister,
				  					   CRegObject& ro,
									   const UINT nidDesc, 
									   REFCLSID clsCLSID,
									   REFCLSID clsTypeLib,
									   ThreadVal tval = tvApartment) {
			// module
			HRESULT hr = InsertModuleName(ro);
			if (FAILED(hr)) {
				return hr;
			}

			// clsid
			hr = InsertGUID(ro, pszMacroNames[mnlCLSID], clsCLSID);
			if (FAILED(hr)) {
				return hr;
			}

			// typelib
			hr = InsertGUID(ro, pszMacroNames[mnlTypeLib], clsTypeLib);
			if (FAILED(hr)) {
				return hr;
			}

			// threading model
			hr = ro.AddReplacement(pszMacroNames[mnlThread], pszThreadValNames[tval]);
			if (FAILED(hr)) {
				return hr;
			}

			CString cs;
			USES_CONVERSION;
			// desc
			if (!cs.LoadString(nidDesc)) {
				return E_INVALIDARG;
			}
			hr = ro.AddReplacement(pszMacroNames[mnlDesc], T2COLE(cs));
			if (FAILED(hr)) {
				return hr;
			}

			if (bRegister) {
				return ro.StringRegister(pszNonAutoReg);
			} else {
				return ro.StringUnregister(pszAutoReg);
			}
	}

	/////////// 
	static HRESULT RegisterFullControl(bool bRegister,
				  					   CRegObject& ro,
									   const int iMajor,
									   const int iMinor,
									   const DWORD dwOleMiscStatusBits) {

			CString cs;
			USES_CONVERSION;
			// version
			cs.Format(_T("%d.%d"), iMajor, iMinor);
			HRESULT hr = ro.AddReplacement(pszMacroNames[mnlVersion], T2COLE(cs));
			if (FAILED(hr)) {
				return hr;
			}
			cs.Format(_T("%ld"), dwOleMiscStatusBits);
			hr = ro.AddReplacement(pszMacroNames[mnlOleMisc], T2COLE(cs));
			if (FAILED(hr)) {
				return hr;
			}

			if (bRegister) {
				return ro.StringRegister(pszFullControl);
			} else {
				return ro.StringUnregister(pszFullControl);
			}
	}

	/////////// 
	static HRESULT RegisterProtocol(bool bRegister,
				  					   CRegObject& ro,
									   LPCOLESTR szProtocol) {
			HRESULT hr = ro.AddReplacement(pszMacroNames[mnlProtocol], szProtocol);
			if (FAILED(hr)) {
				return hr;
			}

			if (bRegister) {
				return ro.StringRegister(pszProtocol);
			} else {
				return ro.StringUnregister(pszProtocol);
			}
	}

	/////////// 
	static HRESULT RegisterExtraScript(CRegObject &ro, bool bRegister, 
											  const UINT nidExtraScriptID) {
		TCHAR szModule[_MAX_PATH];
		USES_CONVERSION;
		GetModuleFileName(_Module.m_hInst, szModule, _MAX_PATH);
		if (bRegister) {
			return ro.ResourceRegister(T2OLE(szModule), nidExtraScriptID, OLESTR("REGISTRY"));
		} else {
			return ro.ResourceUnregister(T2OLE(szModule), nidExtraScriptID, OLESTR("REGISTRY"));
		}
	}

};

/////////// 
#define REGISTER_AUTOMATION_OBJECT(nidComponent, nidProgID, nidDESC, clsTypeLib, clsCLSID) \
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) { \
		CRegObject ro; \
		return CObjRegHelp::RegisterAutomationClass(bRegister ? true : false, ro, nidComponent, \
									   nidProgID, nidDESC, clsCLSID, clsTypeLib); \
	}

#define REGISTER_AUTOMATION_OBJECT_WITH_TM(nidComponent, nidProgID, nidDESC, clsTypeLib, clsCLSID, tvVal) \
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) { \
		CRegObject ro; \
		return CObjRegHelp::RegisterAutomationClass(bRegister ? true : false, ro, nidComponent, \
									   nidProgID, nidDESC, clsCLSID, clsTypeLib, tvVal); \
	}

/////////// 
#define REGISTER_AUTOMATION_OBJECT_AND_RGS(nidExtraScript, nidComponent, nidProgID, nidDESC, clsTypeLib, clsCLSID) \
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) { \
		CRegObject ro; \
		HRESULT hr = CObjRegHelp::RegisterAutomationClass(bRegister ? true : false, ro, nidComponent, \
												   	      nidProgID, nidDESC, clsCLSID, \
														  clsTypeLib); \
		if (FAILED(hr)) { \
			return hr; \
		} \
		return CObjRegHelp::RegisterExtraScript(ro, nidExtraScript); \
	}

/////////// 
#define REGISTER_NONAUTOMATION_OBJECT(nidComponent, nidDESC, clsTypeLib, clsCLSID) \
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) { \
		CRegObject ro; \
		return CObjRegHelp::RegisterNonAutomationClass(bRegister ? true : false, ro, nidDESC, clsCLSID, clsTypeLib); \
	}

#define REGISTER_NONAUTOMATION_OBJECT_WITH_TM(nidComponent, nidDESC, clsTypeLib, clsCLSID, tvVal) \
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) { \
		CRegObject ro; \
		return CObjRegHelp::RegisterNonAutomationClass(bRegister ? true : false, ro, nidDESC, clsCLSID, clsTypeLib, tvVal); \
	}

/////////// 
#define REGISTER_NONAUTOMATION_OBJECT_AND_RGS(nidExtraScript, nidDESC, clsTypeLib, clsCLSID) \
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) { \
		CRegObject ro; \
		HRESULT hr = CObjRegHelp::RegisterNonAutomationClass(bRegister ? true : false, ro, \
														     nidDESC, clsCLSID, \
															 clsTypeLib); \
		if (FAILED(hr)) { \
			return hr; \
		} \
		return CObjRegHelp::RegisterExtraScript(ro, nidExtraScript); \
	}

/////////// 
#define REGISTER_FULL_CONTROL(nidComponent, nidProgID, nidDESC, clsTypeLib, clsCLSID, wMajor, wMinor, OleMisc) \
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) { \
		CRegObject ro; \
		HRESULT hr = CObjRegHelp::RegisterAutomationClass(bRegister ? true : false, ro, nidComponent, \
												   	      nidProgID, nidDESC, clsCLSID, \
														  clsTypeLib); \
		if (FAILED(hr)) { \
			return hr; \
		} \
		return CObjRegHelp::RegisterFullControl(bRegister ? true : false, ro, wMajor, wMinor, OleMisc); \
	}


/////////// 
#define REGISTER_PROTOCOL(nidComponent, nidDESC, clsTypeLib, clsCLSID, szProtocol) \
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister) { \
		CRegObject ro; \
		HRESULT hr = CObjRegHelp::RegisterNonAutomationClass(bRegister ? true : false, \
															 ro, \
															 nidDESC, \
															 clsCLSID, \
															 clsTypeLib); \
		if (FAILED(hr)) { \
			return hr; \
		} \
		return CObjRegHelp::RegisterProtocol(bRegister ? true : false, ro, szProtocol); \
	}

#endif 
//end of file objreghelp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\pbsegimpl.h ===
//==========================================================================;
//
// pbsegimpl.h : additional infrastructure to support implementing IMSVidGraphSegment for
//   playback segments
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef PBSEGIMPL_H
#define PBSEGIMPL_H

#include <segimpl.h>
#include <evcode.h>
#include <deviceeventimpl.h>

namespace MSVideoControl {

template<class T, enum MSVidSegmentType segtype, LPCGUID pCategory, class MostDerivedClass = IMSVidGraphSegment> 
    class DECLSPEC_NOVTABLE IMSVidPBGraphSegmentImpl : 
        public IMSVidGraphSegmentImpl<T, segtype, pCategory, MostDerivedClass> {
protected:

public:
    // DON'T addref the container.  we're guaranteed nested lifetimes
    // and an addref creates circular refcounts so we never unload.

    IMSVidPBGraphSegmentImpl() {}
    virtual ~IMSVidPBGraphSegmentImpl() {}
    STDMETHOD(OnEventNotify)(LONG lEvent, LONG_PTR lParm1, LONG_PTR lParm2) {
        if (lEvent == EC_COMPLETE) {
            T* pt = static_cast<T*>(this);
            CComQIPtr<IMSVidPlayback> ppb(this);
            if (!ppb) {
                return E_UNEXPECTED;
            }
            pt->Fire_EndOfMedia(ppb);
    
            // call Stop to make sure graph is stopped properly
            PQVidCtl pV(m_pContainer);
            pV->Stop();
            return NOERROR;  // we notify caller that we handled the event if stop() fails
        } 
        return E_NOTIMPL;
    }

};

template <class T, const IID* piid = &IID_IMSVidPlaybackEvent, class CDV = CComDynamicUnkArray>
class CProxy_PlaybackEvent : public CProxy_DeviceEvent<T, piid, CDV>
{
public:
	VOID Fire_EndOfMedia(IMSVidPlayback *pPBDev)
	{
		T* pT = static_cast<T*>(this);
		int nConnectionIndex;
		CComVariant* pvars = new CComVariant[1];
		int nConnections = m_vec.GetSize();
		
		for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
		{
			pT->Lock();
			CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
			pT->Unlock();
			IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
			if (pDispatch != NULL)
			{
				pvars[0] = pPBDev;
				DISPPARAMS disp = { pvars, NULL, 1, 0 };
				pDispatch->Invoke(eventidEndOfMedia, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
			}
		}
		delete[] pvars;
	
	}

};


}; // namespace

#endif
// end of file - pbsegimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\odsstream.h ===
// odsstream.h c++ std lib output stream using win32 OutputDebugString
// copied from vc98 fstream
// Copyright (c) Microsoft Corporation 1998.

#pragma once

#if !defined(DEBUG) && (defined(_DBG) || defined(DBG) || defined(_DEBUG))
#define DEBUG 1
#endif

#if !defined(ODSSTREAM_H) && defined(DEBUG)
#define ODSSTREAM_H

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */

#include <tchar.h>
#include <ostream>
#include <tstring.h>

inline bool Debugputc(TCHAR outch) {
        TCHAR o[2];
        o[0] = outch;
        o[1] = 0;
        TCHAR *p = o;
        OutputDebugString(p);
        return true;
}

                // TEMPLATE CLASS basic_debugbuf
template<class _E, class _Tr = std::char_traits<_E> >
class basic_debugbuf : public std::basic_streambuf<_E, _Tr> {
public:

        typedef std::codecvt<_E, TCHAR, _Tr::state_type> _Cvt;
        typedef std::basic_streambuf<_E, _Tr> _Mysb;
        typedef basic_debugbuf<_E, _Tr> _Myt;

        basic_debugbuf() : _Loc(), _Mysb() {
                _Init();
        }
        virtual ~basic_debugbuf() {
                delete _Str;
        }
protected:
        virtual int_type overflow(int_type _C = _Tr::eof()) {
                if (_Tr::eq_int_type(_Tr::eof(), _C)) {
                        return (_Tr::not_eof(_C));
                } else if (pptr() != 0 && pptr() < epptr()) {
                        *_Pninc() = _Tr::to_char_type(_C);
                        return (_C);
                } else if (_Pcvt == 0) {
                        Debugputc(_Tr::to_char_type(_C));
                        return _C;
                } else {
                        const int _NC = 8;
                        const _E _X = _Tr::to_char_type(_C);
                        const _E *_S;
                        TCHAR *_D;
                        _Str->erase();
                        for (size_t _I = _NC; ; _I += _NC) {
                                _Str->append(_NC, '\0');
                                switch (_Pcvt->out(_State,
                                        &_X, &_X + 1, _S,
                                        _Str->begin(), _Str->end(), _D)) {
                                case std::codecvt_base::partial:
                                        if (_S == &_X)
                                                return (_Tr::eof());
                                case std::codecvt_base::ok:     {// can fall through
                                        size_t _N = _D - _Str->begin();
                                        OutputDebugString(_Str->begin());
                                        return _C;
                                }
                                case std::codecvt_base::noconv:
                                        Debugputc(_X);
                                        return _C;
                                default:
                                        return (_Tr::eof());
                                }
                        }
                }
        }
        virtual int_type uflow() {return (_Tr::eof());}
        void _Init() {
                static _Tr::state_type _Stinit;
                _Loc.locale::~locale();
                new (&_Loc) std::locale;
                _Str = 0;
                _Mysb::_Init();
                _State = _Stinit;
                _State0 = _Stinit;
                _Pcvt = 0;
        }

        void _Initcvt() {
                _Pcvt = (_Cvt *)&_USE(getloc(), _Cvt);
                _Loc = _ADDFAC(_Loc, _Pcvt);
                if (_Pcvt->always_noconv())
                        _Pcvt = 0;
                if (_Str == 0)
                        _Str = new string;
        }
private:
        _Cvt *_Pcvt;
        _Tr::state_type _State0;
        _Tr::state_type _State;
        Tstring *_Str;
        std::locale _Loc;
};

template<class _E, class _Tr = std::char_traits<_E> >
class basic_otstream : public std::basic_ostream<_E, _Tr> {
public:
        typedef std::basic_ostream<_E, _Tr> MytBase;
        typedef std::basic_ios<_E, _Tr> _Myios;
        typedef std::basic_streambuf<_E, _Tr> _Mysb;

        typedef basic_otstream<_E, _Tr> _Myt;
        basic_otstream() {}
        explicit basic_otstream(std::basic_streambuf<_E, _Tr> *_S,
                bool _Isstd = false, bool _Doinit = true) : std::basic_ostream<_E, _Tr>(_S, _Isstd, _Doinit) {}
        virtual ~basic_otstream()
                {}

#if 0
        template<class T> inline _Myt& operator<<(T i) {
                MytBase::operator<<(i);
                return *this;
        }
#endif

        inline _Myt& operator<<(_Myt& (__cdecl *_F)(_Myt&)) {
                return ((*_F)(*this));
        }

        inline _Myt& operator<<(MytBase& (__cdecl *_F)(MytBase&)) {
                MytBase::operator<<(_F);
                return *this;
        }

        inline _Myt& operator<<(_Myios& (__cdecl *_F)(_Myios&)) {
                MytBase::operator<<(f);
                return *this;
        }

        inline _Myt& operator<<(_Mysb *b) {
                MytBase::operator<<(b);
                return *this;
        }

        inline _Myt& operator<<(const void *const i) {
                MytBase::operator<<(i);
                return *this;
        }

        inline _Myt& operator<<(float i) {
                MytBase::operator<<(i);
                return *this;
        }

        inline _Myt& operator<<(double i) {
                MytBase::operator<<(i);
                return *this;
        }

        inline _Myt& operator<<(int i) {
                MytBase::operator<<(i);
                return *this;
        }

        inline _Myt& operator<<(unsigned int i) {
                MytBase::operator<<(i);
                return *this;
        }

        inline _Myt& operator<<(long i) {
                MytBase::operator<<(i);
                return *this;
        }

        inline _Myt& operator<<(unsigned long i) {
                MytBase::operator<<(i);
                return *this;
        }
#ifdef _UNICODE
        _Myt& operator<<(LPCSTR _X) {
                USES_CONVERSION;
                return operator<<(A2W(_X));
        }
#else
        _Myt& operator<<(const OLECHAR *_X) {
                USES_CONVERSION;
                operator<<(W2A(_X));
                return *this;
        }
#endif
        _Myt& operator<<(LPCTSTR _X) {
                std::operator<<(static_cast<MytBase&>(*this), _X);
                return *this;
        }

#if 0
        inline _Myt& operator<<(Tstring t) {
                return operator<<(t.c_str());
        }
#endif
};
typedef basic_otstream<TCHAR> tostream;

// TEMPLATE CLASS basic_ofstream
template<class _E, class _Tr = std::char_traits<_E> >
class basic_odebugstream : public basic_otstream<_E, _Tr> {
public:
        typedef basic_odebugstream<_E, _Tr> _Myt;
        typedef basic_debugbuf<_E, _Tr> _Myfb;
        basic_odebugstream()
                : basic_otstream<_E, _Tr>(&_Fb) {}
        basic_odebugstream(_Myt &mt) : basic_otstream<_E, _Tr>(mt._Fb) {}
        virtual ~basic_odebugstream()
                {}
private:
        _Myfb _Fb;
};



#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

typedef basic_debugbuf<TCHAR> TdbgBuf;
typedef basic_odebugstream<TCHAR> TdbgStream;

// the msvc 6 crt fstream header this was copied from contained the following notice:
/*
 * Copyright (c) 1994 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */


#endif
// end of file odsstream.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\outputimpl.h ===
//==========================================================================;
//
// inputimpl.h : additional infrastructure to support implementing IMSVidOutputDevice
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef OUTPUTIMPL_H
#define OUTPUTIMPL_H

#include "devimpl.h"

namespace MSVideoControl {

template<class T, LPCGUID LibID, LPCGUID Category, class MostDerivedInterface = IMSVidOutputDevice>
    class DECLSPEC_NOVTABLE IMSVidOutputDeviceImpl : public IMSVidDeviceImpl<T, LibID, Category, MostDerivedInterface> {
public:
};

}; // namespace

#endif
// end of file - inputimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\mtype.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992 - 2000  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;

// Class that holds and manages media type information, December 1994

#ifndef __MTYPE__
#define __MTYPE__

/* Helper class that derived pin objects can use to compare media
   types etc. Has same data members as the struct AM_MEDIA_TYPE defined
   in the streams IDL file, but also has (non-virtual) functions */

class CMediaType : public _AMMediaType {

public:

    ~CMediaType();
    CMediaType();
    CMediaType(const GUID * majortype);
    CMediaType(const AM_MEDIA_TYPE&);
    CMediaType(const CMediaType&);

    CMediaType& operator=(const CMediaType&);
    CMediaType& operator=(const AM_MEDIA_TYPE&);

    BOOL operator == (const CMediaType&) const;
    BOOL operator != (const CMediaType&) const;

    BOOL IsValid() const;

    const GUID *Type() const { return &majortype;} ;
    void SetType(const GUID *);
    const GUID *Subtype() const { return &subtype;} ;
    void SetSubtype(const GUID *);

    BOOL IsFixedSize() const {return bFixedSizeSamples; };
    BOOL IsTemporalCompressed() const {return bTemporalCompression; };
    ULONG GetSampleSize() const;

    void SetSampleSize(ULONG sz);
    void SetVariableSize();
    void SetTemporalCompression(BOOL bCompressed);

    // read/write pointer to format - can't change length without
    // calling SetFormat, AllocFormatBuffer or ReallocFormatBuffer

    BYTE*   Format() const {return pbFormat; };
    ULONG   FormatLength() const { return cbFormat; };

    void SetFormatType(const GUID *);
    const GUID *FormatType() const {return &formattype; };
    BOOL SetFormat(BYTE *pFormat, ULONG length);
    void ResetFormatBuffer();
    BYTE* AllocFormatBuffer(ULONG length);
    BYTE* ReallocFormatBuffer(ULONG length);

    void InitMediaType();

    BOOL MatchesPartial(const CMediaType* ppartial) const;
    BOOL IsPartiallySpecified(void) const;
};


/* General purpose functions to copy and delete a task allocated AM_MEDIA_TYPE
   structure which is useful when using the IEnumMediaFormats interface as
   the implementation allocates the structures which you must later delete */

void WINAPI DeleteMediaType(AM_MEDIA_TYPE *pmt);
AM_MEDIA_TYPE * WINAPI CreateMediaType(AM_MEDIA_TYPE const *pSrc);
void WINAPI CopyMediaType(AM_MEDIA_TYPE *pmtTarget, const AM_MEDIA_TYPE *pmtSource);
void WINAPI FreeMediaType(AM_MEDIA_TYPE& mt);

//  Initialize a media type from a WAVEFORMATEX

STDAPI CreateAudioMediaType(
    const WAVEFORMATEX *pwfx,
    AM_MEDIA_TYPE *pmt,
    BOOL bSetFormat);

#endif /* __MTYPE__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\playbackimpl.h ===
//==========================================================================;
//
// playbackimpl.h : additional infrastructure to support implementing IMSVidPlayback
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef PLAYBACKIMPL_H
#define PLAYBACKIMPL_H
#include <math.h>
#include "inputimpl.h"
#include <uuids.h>
namespace MSVideoControl {

#define BACKWARDS_STEPPING 0
const long nano_to_hundredths = 100000;    
template<class T, LPCGUID LibID, LPCGUID KSCategory, class MostDerivedInterface = IMSVidPlayback>
    class DECLSPEC_NOVTABLE IMSVidPlaybackImpl :         
    	public IMSVidInputDeviceImpl<T, LibID, KSCategory, MostDerivedInterface> {
protected:
    bool m_fEnableResetOnStop;
public:
    IMSVidPlaybackImpl():        
        m_fEnableResetOnStop(false) {}
	
    virtual ~IMSVidPlaybackImpl() {} 
//-----------------------------------------------------------------------------------------
// Name:
//-----------------------------------------------------------------------------------------
    STDMETHOD(get_Length)(/*[out, retval]*/long *lLength){
        HRESULT hr = S_OK;
        LONGLONG tempval;
        PositionModeList curMode;
        try{
            // Checking args and init'ing interfaces
            if (!lLength){
                return E_POINTER;
            }
            if (!m_pGraph) {
                // graph not valid
                return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }

            // See if object supports IMediaSeeking
            PQMediaSeeking PQIMSeeking(m_pGraph);
            if(PQIMSeeking){
                // Find out what postion mode is being used
                hr = get_PositionMode(&curMode);
                if(FAILED(hr)){
                    return hr;
                }
                hr = PQIMSeeking->GetDuration(&tempval);
                if(FAILED(hr)){
                    return hr;
                }
                // If it is FrameMode no conversion needed
                if(curMode == FrameMode){
                    *lLength = static_cast<long>(tempval);
                    hr = S_OK;
                    return hr;
                }
                // If it is TenthsSecondsMode need to be converted from 100 nanosecond units
                else if(curMode == TenthsSecondsMode){
                    *lLength = static_cast<long>(tempval / nano_to_hundredths);
                    hr = S_OK;
                    return hr;
                }
                // If it is some other mode not supported by the vidctl
                else{
                    return E_UNEXPECTED;
                }
            }
    
            // See if object supports IMediaPostion
            PQMediaPosition PQIMPos(m_pGraph);
            if(PQIMPos){
                // Get position
                double tempDub;
                hr =  PQIMPos->get_CurrentPosition(&tempDub);
                // IMediaPostion only supports 100 Nanosecond units
                *lLength = static_cast<long>(tempDub / nano_to_hundredths);
                hr = S_OK;
                return hr;
            }
            // Could Not QI IMedia Seeking or Position
            return ImplReportError(__uuidof(T), IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);
            
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;
        }
    }
    
//-----------------------------------------------------------------------------------------
// Name: get_CurrentPosition(LONGLONG*)
//-----------------------------------------------------------------------------------------
    STDMETHOD(get_CurrentPosition)(/*[out,retval]*/long *lPosition) {
        HRESULT hr = S_OK;
        LONGLONG tempval;
        PositionModeList curMode;
        try{
            // Checking args and init'ing interfaces
            if (!lPosition){
                return E_POINTER;
            }
            if (!m_pGraph) {
                // graph not valid
                return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }

            // See if object supports IMediaSeeking
            PQMediaSeeking PQIMSeeking(m_pGraph);
            if(PQIMSeeking){
                // Find out what postion mode is being used
                hr = get_PositionMode(&curMode);
                if(FAILED(hr)){
                    return hr;
                }
                hr = PQIMSeeking->GetCurrentPosition(&tempval);
                if(FAILED(hr)){
                    return hr;
                }
                // If it is FrameMode no conversion needed
                if(curMode == FrameMode){
                    *lPosition = static_cast<long>(tempval);
                    hr = S_OK;
                    return hr;
                }
                // If it is TenthsSecondsMode need to be converted from 100 nanosecond units
                else if(curMode == TenthsSecondsMode){
                    *lPosition = static_cast<long>(tempval / nano_to_hundredths);
                    hr = S_OK;
                    return hr;
                }
                // If it is some other mode not supported by the vidctl
                else{
                    return E_UNEXPECTED;
                }
            }
    
            // See if object supports IMediaPostion
            PQMediaPosition PQIMPos(m_pGraph);
            if(PQIMPos){
                // Get position
                double tempDub;
                hr =  PQIMPos->get_CurrentPosition(&tempDub);
                // IMediaPostion only supports 100 Nanosecond units
                *lPosition = static_cast<long>(tempDub / nano_to_hundredths);
                hr = S_OK;
                return hr;
            }
            // Could Not QI IMedia Seeking or Position
            return ImplReportError(__uuidof(T), IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);
            
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;
        }
    }
//-----------------------------------------------------------------------------------------
// Name: put_CurrentPosition(LONGLONG)
//-----------------------------------------------------------------------------------------
	STDMETHOD(put_CurrentPosition)(/*[in]*/long lPosition) {
        HRESULT hr = S_OK;
        LONGLONG tempval = 0;
        PositionModeList curMode;
            LONG curPos;
            try{
            // Checking args and interfaces
            if (!m_pGraph) {
                return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }

			hr = get_CurrentPosition(&curPos);
			if(curPos == lPosition){
				return NOERROR;
			}
            // Check for a IMediaSeeking Interface
            PQMediaSeeking PQIMSeeking(m_pGraph);
            if(PQIMSeeking){
                // Get the position Mode
                hr = get_PositionMode(&curMode);
                if(FAILED(hr)){
                    return hr;
                }
                tempval = lPosition;
                // If it is in TenthsSecondsMode convert input into 100 nanosecond units
                if(curMode == TenthsSecondsMode){
                    tempval = static_cast<LONGLONG>(lPosition);
                    tempval = tempval * nano_to_hundredths;
                }
                // If it is in some other mode
                else if(curMode != FrameMode){
                    return E_UNEXPECTED;
                }
                // Set the new Position
#if 0
                if(curPos > lPosition && !m_pGraph.IsStopped()){

					DWORD seekingFlags = AM_SEEKING_CanSeekBackwards;
					hr = PQIMSeeking->CheckCapabilities(&seekingFlags);
					if(FAILED(hr)){
						return hr;
					}

				}
#endif
                hr = PQIMSeeking->SetPositions(&tempval, AM_SEEKING_AbsolutePositioning, NULL, 0);
                return hr;
            }
            // Check for a IMediaPostion
            PQMediaPosition PQIMPos(m_pGraph);
            if(PQIMPos){
                if(curPos > lPosition && !m_pGraph.IsStopped()){
					long canSeekBackwardRetVal;
                	PQIMPos->CanSeekBackward(&canSeekBackwardRetVal);
            		if(canSeekBackwardRetVal != -1){// OATRUE = -1
                 		return E_INVALIDARG;
            		}
                }
                // IMediaPosition only does 100 nanosecond units
                double tempDub = lPosition;
                tempDub = tempDub * nano_to_hundredths;
                hr = PQIMPos->put_CurrentPosition(tempDub);
                return hr;
            }
            // Could Not QI Media Position or Seeking
            return ImplReportError(__uuidof(T), IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);
            
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;
        }
    }
//-----------------------------------------------------------------------------------------
// Name: put_PositionMode(LONGLONG)
//-----------------------------------------------------------------------------------------

    STDMETHOD(put_PositionMode)(/*[in]*/PositionModeList lPositionMode) {
        HRESULT hr = S_OK;
        double testval;
        get_Rate(&testval);
        try{
            // Checking args and interfaces
            if (!m_pGraph) {
                // graph not valid
                return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }
            // only valid values
            if(lPositionMode != FrameMode && lPositionMode != TenthsSecondsMode){
                return E_INVALIDARG;
            }
            // Try for a IMediaSeeking
            PQMediaSeeking PQIMSeeking(m_pGraph);
            if(PQIMSeeking){
                // Set the new mode
                if(lPositionMode == FrameMode){
                    return PQIMSeeking->SetTimeFormat( &( static_cast<GUID>(TIME_FORMAT_FRAME) ) );
                }
                if(lPositionMode == TenthsSecondsMode){
                    return PQIMSeeking->SetTimeFormat(&(static_cast<GUID>(TIME_FORMAT_MEDIA_TIME)));
                }
            }
            // Try for a IMediaPosition
            PQMediaPosition PQIMPos(m_pGraph);
            if(PQIMPos){
                // Only supports TenthsSecondsMode
                if(lPositionMode == TenthsSecondsMode){
                    return S_OK;
                }
                else{
                    return E_FAIL;
                }
            }
            // Could Not QI
            return ImplReportError(__uuidof(T), IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);
            
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;
        }
    }


//-----------------------------------------------------------------------------------------
// Name: get_PositionMode(LONGLONG*)
//-----------------------------------------------------------------------------------------
    STDMETHOD(get_PositionMode)(/*[out,retval]*/PositionModeList* lPositionMode) {
        HRESULT hr = S_OK;
        double testval;
        get_Rate(&testval);
        try{
            // Checking args and interfaces
            if(!lPositionMode){
                return E_POINTER;
            }
            if (!m_pGraph) {
                // graph not valid
                return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }
            // Get an IMediaSeeking Interface
            PQMediaSeeking PQIMSeeking(m_pGraph);
            if(PQIMSeeking){
                // Get the mode
                GUID cur_mode;
                hr = PQIMSeeking->GetTimeFormat(&cur_mode);
                if(FAILED(hr)){
                    return hr;
                }
                // Check to see which mode it is in
                if(cur_mode == static_cast<GUID>(TIME_FORMAT_FRAME)){
                    *lPositionMode = FrameMode;
                    return S_OK;
                }
                if(cur_mode == static_cast<GUID>(TIME_FORMAT_MEDIA_TIME)){
                    *lPositionMode = TenthsSecondsMode;
                    return S_OK;
                }
                // Not in a vidctl supported mode
                else{
                    return E_FAIL;
                }
            }
            // Get IMediaPosition
            PQMediaPosition PQIMPos(m_pGraph);
            if(PQIMPos){
                // Only supports TenthsSecondsMode
                *lPositionMode = TenthsSecondsMode;
                return S_OK;
            }
            // Could Not QI
            return ImplReportError(__uuidof(T), IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);
            
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;
        }
    }

	STDMETHOD(get_Duration)(double *dPos) {
        return E_NOTIMPL;
    }
	STDMETHOD(get_PrerollTime)(double *dPos) {
        return E_NOTIMPL;
    }
	STDMETHOD(put_PrerollTime)(double dPos) {
        return E_NOTIMPL;
    }
	STDMETHOD(get_StartTime)(double *StartTime) {
        return E_NOTIMPL;
    }
	STDMETHOD(put_StartTime)(double StartTime) {
        return E_NOTIMPL;
    }
	STDMETHOD(get_StopTime)(double *StopTime) {
        return E_NOTIMPL;
    }
	STDMETHOD(put_StopTime)(double StopTime) {
        return E_NOTIMPL;
    }

//-----------------------------------------------------------------------------------------
// Name: get_EnableResetOnStop(VARIANT_BOOL*)
//-----------------------------------------------------------------------------------------
    STDMETHOD(get_EnableResetOnStop)(/*[out, retval]*/ VARIANT_BOOL *pVal){
        HRESULT hr = S_OK;
        
        try {
            if(NULL == pVal){ 
                throw(E_POINTER);
            }

            if(m_fEnableResetOnStop == true){
                *pVal = VARIANT_TRUE;
            }
            else{
                *pVal = VARIANT_FALSE;
            }
       
        }
        
        catch(HRESULT hrTmp){  
            hr = hrTmp;
        }
        
        catch(...){
            hr = E_UNEXPECTED;
        }
        
        return hr;
    }// end of function get_EnableResetOnStop 
//-----------------------------------------------------------------------------------------
// Name: put_EnableResetOnStop(VARIANT_BOOL)
//-----------------------------------------------------------------------------------------
    STDMETHOD(put_EnableResetOnStop)(/*[in]*/ VARIANT_BOOL newVal){
        HRESULT hr = S_OK;
        
        try {
            if(newVal == VARIANT_TRUE){ 
                m_fEnableResetOnStop = true;
            }
            else{
                m_fEnableResetOnStop = false;
            }
        }
        catch(...){   
            hr = E_UNEXPECTED;
        }
        
        return hr;
    }// end of function put_EnableResetOnStop

//-----------------------------------------------------------------------------------------
// Name: get_CanStep(VARIANT_BOOL, VARIANT_BOOL*)
//-----------------------------------------------------------------------------------------
    STDMETHOD(get_CanStep)(VARIANT_BOOL fBackwards, VARIANT_BOOL *pfCan){
        // NOTE: NO ONE supports backwords stepping (why not? who knows)
        // so just like everyone else we dont either
        try{
            // Checking args and interfaces 
       
            if(NULL == pfCan){
                // Passed a NULL Pointer
                return E_POINTER;
            }

            if (!m_pGraph) {
                // graph not valid
                return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
			}

            //Get a VideoFrameStep Interface
			PQVideoFrameStep pVFS(m_pGraph);
            if(!pVFS){
                // Could Not QI
				return ImplReportError(__uuidof(T), IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);          
			}
            
            
#if BACKWARDS_STEPPING // Checking for Backward Stepping should always be 0
            if(fBackwards == VARIANT_TRUE){
                // Backwords Stepping Not Supported Most Likely
                if(pVFS->CanStep(TRUE, NULL)==S_OK){
                    // It is all Good, Can Step Backwords
                    *pfCan = VARIANT_TRUE;
                    return S_OK;
                }
                
                *pfCan = VARIANT_FALSE;
                return S_OK;
            }
#else // Still checking for Backward Stepping
            if(fBackwards == VARIANT_TRUE){
                *pfCan = VARIANT_FALSE;
                return S_OK;
            }
            
#endif // End checking for Backward Stepping          

            // Checking for Forward Stepping 
            else{
                if(pVFS->CanStep(FALSE, NULL)==S_OK){
                    // It is all Good, Can Step Forward
                    *pfCan = VARIANT_TRUE;
                    return S_OK;
                }
                
                else{
                    // Can't Step
                    *pfCan = VARIANT_FALSE;
                    return S_OK;
                }
            }
        }
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;   
        }
    }

//-----------------------------------------------------------------------------------------
// Name: Step(long)
//-----------------------------------------------------------------------------------------
    STDMETHOD(Step)(long lStep){
        try{
            // Checking args and interfaces
            
            if (!m_pGraph) {
                // graph not valid
                return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }
            
            PQVideoFrameStep pVFS(m_pGraph);
            
            if(!pVFS){
                // Could Not QI
                return ImplReportError(__uuidof(T), IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);
                
            }
            
#if BACKWARDS_STEPPING // Checking for Backward Stepping should always be 0
            // If backwords stepping set rate or what ever needs to be done
            
            if(lStep < 0){
                // Backwords Stepping Not Supported Most Likely
                if(pVFS->CanStep(TRUE, NULL)==S_OK){
                    // It is all Good, Can Step Backwords
                    CComQIPtr<IMediaPosition> IMPos(m_pGraph);
                    CComQIPtr<IMediaControl> IMCon(m_pGraph);
                    if(IMPos&&IMCon){
                        OAFilterState enterState;
                        IMCon->GetState(INFINITE , &enterState);
                        HRESULT hr = IMPos->put_Rate(1);
                        if(SUCCEEDED(hr)){
                            hr = pVFS->Step((-lStep), NULL);
                            if(SUCCEEDED(hr)){
                                return S_OK;
                            }
                            else{
                                return E_UNEXPECTED;
                            }
                            
                        }
                    }
                }
                // Backwords stepping not supported
                return E_NOTIMPL;
            }
#else // Still checking for Backward Stepping

            if(lStep < 0){
                return E_NOTIMPL;
            }

#endif // End checking for Backward Stepping 
            // Make it step
            return pVFS->Step(lStep, NULL);
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;
        }
    }
    
    // note: the following methods control the playback device *NOT* the graph. 
    // if the underlying source filter only supports these functions via 
    // imediacontrol on the graph then this device segment object should return E_NOTIMPL.
    STDMETHOD(Run)() {
        return E_NOTIMPL;
    }
    STDMETHOD(Pause)() {
        return E_NOTIMPL;
    }
    STDMETHOD(Stop)() {
        return E_NOTIMPL;
    }
//-----------------------------------------------------------------------------------------
// Name: put_Rate(double)
//-----------------------------------------------------------------------------------------
    STDMETHOD(put_Rate)(double lRate){
        HRESULT hr = S_OK;
        try{
            /*** Checking args and init'ing interfaces ***/
            
            if (!m_pGraph) {
                // graph not valid
                return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }

            // Attempt to set the rate using IMediaSeeking
            PQMediaSeeking PQIMSeeking(m_pGraph);
            if(PQIMSeeking){
                return PQIMSeeking->SetRate(lRate);
            }
            
            // If IMediaSeeking FAILS try IMediaPostion
            PQMediaPosition PQIMPos(m_pGraph);
            if(PQIMPos){
                // Change rate
                return PQIMPos->put_Rate((double)lRate);
            }
            
            // Could Not QI Either one set the error
                return ImplReportError(__uuidof(T), IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);

        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;
        }
    }
//-----------------------------------------------------------------------------------------
// Name: get_Rate(double*)
//-----------------------------------------------------------------------------------------
    STDMETHOD(get_Rate)(double *plRate){
        HRESULT hr = S_OK;
        double curRate = 1;
        try{
            /*** Checking args and init'ing interfaces ***/
            if (!plRate){
                return E_POINTER;
            }
            if (!m_pGraph) {
                // graph not valid
                return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidPlayback), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }
            PQMediaSeeking PQIMSeeking(m_pGraph);
            if(PQIMSeeking){
                hr = PQIMSeeking->GetRate(&curRate);
            }
            else{
                PQMediaPosition PQIMPos(m_pGraph);
                if(PQIMPos){
                    // Get rate
                    hr = PQIMPos->get_Rate(&curRate);
                }
                // Could Not QI
                else{
                    return ImplReportError(__uuidof(T), IDS_E_CANTQI , __uuidof(IMSVidPlayback), E_NOINTERFACE);
                }
            }
            
            if(SUCCEEDED(hr)){
                *plRate = curRate;
                TRACELSM(TRACE_DETAIL, (dbgDump << "Playbackimpl::get_Rate() rate = " << curRate), "");
            }
            else{
                TRACELSM(TRACE_ERROR, (dbgDump << "Playbackimpl::get_Rate() get_rate failed"), "");
            }
            return hr;
        }
        
        catch(HRESULT hrTmp){
            // Something went bad, threw a HRESULT				
            return ImplReportError(__uuidof(T), IDS_INVALID_STATE , __uuidof(IMSVidPlayback), hrTmp);
        }
        catch(...){
            // Something went bad, dont know what it threw
            return E_UNEXPECTED;
        }
    }

};

}; // namespace

#endif
// end of file - playbackimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\propertybag2impl.h ===
/////////////////////////////////////////////////////////////////////////////
//
// propertybag2impl.h : helper functions for implementing IPropertyBag2
// Copyright (c) Microsoft Corporation 1999.
//
// this code assumes that you're also implementing IPropertyBag and reflects
// bag2's read/write to bag's read/write
//


template <class T>
class ATL_NO_VTABLE IPropertyBag2Impl : public IPropertyBag2
{

// IPropertyBag2
STDMETHOD(Read)(ULONG cProperties, PROPBAG2* pPropBag, IErrorLog* pErrLog, VARIANT* pvarValue, HRESULT* phrError) {
    HRESULT hrc = NOERROR;
    if (!phrError || !pPropBag) {
        return E_POINTER;
    }
    try {            
		ATL_LOCKT();
       for (ULONG i = 0; i < cProperties; ++i) {
            phrError[i] = pT->Read(pPropBag[i].pstrName, pvarValue + i, pErrLog);
            if (FAILED(phrError[i])) {
                hrc = E_FAIL;
            }
        }
        return hrc;
    } catch (...) {
        return E_UNEXPECTED;
    }
}

STDMETHOD(Write)(ULONG cProperties, PROPBAG2* pPropBag, VARIANT* pvarValue) {
    HRESULT hrc = NOERROR;
    if (!pvarValue || !pPropBag) {
        return E_POINTER;
    }
    try {            
		ATL_LOCKT();
        for (ULONG i = 0; i < cProperties; ++i) {
            VARIANT *pVAR = pvarValue + i;
            LPCOLESTR s = pPropBag[i].pstrName;
            HRESULT hr = pT->Write(s, pVAR);
            if (FAILED(hr)) {
                hrc = E_FAIL;
            }
        }
        return hrc;
    } catch (...) {
        return E_UNEXPECTED;
    }
}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\segment.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1995-1999.
//
//--------------------------------------------------------------------------;
//
// segment.cpp : implementation of various graph segment extension classes
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include <bdamedia.h>

#include "devices.h"
#include "seg.h"

#include "closedcaptioning.h"
#include "MSViddataservices.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidClosedCaptioning, CClosedCaptioning)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidDataServices, CDataServices)

// VWSegment
#if 0
// note: the compiler is generating but never calling the code to construct these initializers so the pointers
// are staying null.  we work around this by providing a function which dynamically allocating them on the heap 
// and calling it in our dllmain.
std_arity1pmf<IMSVidGraphSegment, IEnumFilters **, HRESULT> * VWGraphSegment::Fetch = &std_arity1_member(&IMSVidGraphSegment::EnumFilters);
// reset and next use same types as DSGraphContainer so same template expansion already initialized
#else
std_arity1pmf<IMSVidGraphSegment, IEnumFilters **, HRESULT> * VWGraphSegment::Fetch = NULL;
// reset and next use same types as DSGraphContainer so same template expansion already initialized
#endif

namespace MSVideoControl {
// work around compiler bug as per above description
void CtorStaticVWSegmentFwdSeqPMFs(void) {
    // DSGraphContainer
    VWGraphSegment::Fetch = new std_arity1pmf<IMSVidGraphSegment, IEnumFilters **, HRESULT>(&IMSVidGraphSegment::EnumFilters);
}

// work around compiler bug as per above description
void DtorStaticVWSegmentFwdSeqPMFs(void) {
    // DSGraphContainer
    delete VWGraphSegment::Fetch;
}

VWSegmentContainer VWGraphSegment::Container(void) {
    VWSegmentContainer g;
    HRESULT hr = (*this)->get_Container(&g);
    ASSERT(SUCCEEDED(hr));
    return g;
}

MSVidSegmentType VWGraphSegment::Type(void) {
    MSVidSegmentType t;
    HRESULT hr = (*this)->get_Type(&t);
    ASSERT(SUCCEEDED(hr));
    return t;
}

DSGraph VWGraphSegment::Graph(void) {
    DSGraph g;
    HRESULT hr = (Container())->get_Graph(&g);
    ASSERT(SUCCEEDED(hr));
    return g;
}

GUID2 VWGraphSegment::Category(void) {
    GUID2 g;
    HRESULT hr = (*this)->get_Category(&g);
    ASSERT(SUCCEEDED(hr));
    return g;
}

GUID2 VWGraphSegment::ClassID(void) {
    GUID2 g;
    HRESULT hr = (*this)->GetClassID(&g);
    ASSERT(SUCCEEDED(hr));
    return g;
}

}; // namespace

#endif //TUNING_MODEL_ONLY

// end of file - segment.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\segimpl.h ===
//==========================================================================;
//
// segimpl.h : additional infrastructure to support implementing IMSVidGraphSegment 
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef SEGIMPL_H
#define SEGIMPL_H

#include <segment.h>
#include <seg.h>
#include <filterenum.h>
#include "devsegimpl.h"

namespace MSVideoControl {

typedef CComQIPtr<IMSVidCtl> PQVidCtl;

template<class T, enum MSVidSegmentType segtype, LPCGUID pCategory, class MostDerivedClass = IMSVidGraphSegment> 
    class DECLSPEC_NOVTABLE IMSVidGraphSegmentImpl : 
        public MostDerivedClass,
        public virtual CMSVidDeviceSegmentImpl {
protected:
    HRESULT Unload() {
        if (!m_fInit || !m_pContainer) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidGraphSegment), CO_E_NOTINITIALIZED);
        }
        try {
            ASSERT(m_pContainer.GetGraph() == m_pGraph);
            // undone: dynamic graph building may allow this
            if (!m_pGraph.IsStopped()) {
				return ImplReportError(__uuidof(T), IDS_INVALID_STATE, __uuidof(IMSVidGraphSegment), HRESULT_FROM_WIN32(ERROR_INVALID_STATE));
            }
            if (m_pGraph) {
#ifdef CRASH
                std::for_each(m_Filters.begin(), 
                              m_Filters.end(),
                               arity1_member_obj(m_pGraph, 
                                                 arity1_member(&DSGraph::RemoveFilter))
                             );
#else
#if 0                
                std::for_each(m_Filters.begin(), 
                              m_Filters.end(),
                              arity1opmf<arity1pmf<DSGraph, DSFilter&, bool> >(
                                  m_pGraph, 
                                  arity1_member(&DSGraph::RemoveFilter)));
#endif
                for(DSFilterList::iterator i = m_Filters.begin(); i != m_Filters.end(); ++i){
                    HRESULT hr = m_pGraph->RemoveFilter(*i);
                    _ASSERT((L"Failed to remove filter from graph during Unload.", SUCCEEDED(hr)));
                }
#endif
            }
            m_Filters.clear();
            m_pGraph.Release();
            // DON'T release the container.  we're guaranteed nested lifetimes
            // and an addref creates circular refcounts so we never unload.
            // thus, we didn't addref and a release will over release and
            // cause destruction before other people are done with the container
            m_pContainer.p = NULL;
        } catch(ComException &e) {
            return e;
        } catch(...) {
            return E_UNEXPECTED;
        }
  	    return NOERROR;
    }

public:
    // DON'T addref the container.  we're guaranteed nested lifetimes
    // and an addref creates circular refcounts so we never unload.

    IMSVidGraphSegmentImpl() {}
    virtual ~IMSVidGraphSegmentImpl() {
        if (m_fInit && m_pContainer) {
            Unload();
        }
    }
    STDMETHOD(GetClassID) (LPCLSID guid) {
        try {
            memcpy(guid, &__uuidof(T), sizeof(CLSID));
            return NOERROR;
        } catch(...) {
            return E_POINTER;
        }
    }
    STDMETHOD(put_Init)(IUnknown * pInit) {
        if (m_fInit) {
            return NOERROR;
        }
        try {
            m_pDev = pInit;
            m_fInit = true;
		    return NOERROR;
        } catch(...) {
            m_fInit = false;
            return E_POINTER;
        }
	}
	STDMETHOD(get_Init)(IUnknown **	pInit) {
		try{
			if (!pInit)	{
				return E_POINTER;
			}
			m_pDev.CopyTo(pInit);
			return NOERROR;
		} catch(...) {
			m_fInit	= false;
			return E_POINTER;
		}
    }

    STDMETHOD(get_Container)(IMSVidGraphSegmentContainer **ppCtl) {
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidGraphSegment), CO_E_NOTINITIALIZED);
        }
        try {
            return m_pContainer.CopyTo(ppCtl);
        } catch(...) {
            return E_POINTER;
        }
	}
    STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pCtl) {
        try {
            if (!pCtl) {
                return Unload();
            }
            if (m_pContainer) {
				if (!m_pContainer.IsEqualObject(VWSegmentContainer(pCtl))) {
					//undone: support moving to different graph
					return ImplReportError(__uuidof(T), IDS_OBJ_ALREADY_INIT, __uuidof(IMSVidGraphSegment), CO_E_ALREADYINITIALIZED);
				} else {
					return NO_ERROR;
				}
            }
            // DON'T addref the container.  we're guaranteed nested lifetimes
            // and an addref creates circular refcounts so we never unload.
            m_pContainer.p = pCtl;
            m_pGraph = m_pContainer.GetGraph();
        } catch(...) {
            return E_UNEXPECTED;
        }
		return NOERROR;
	}
    STDMETHOD(EnumFilters)(IEnumFilters * * pNewEnum) {
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidGraphSegment), CO_E_NOTINITIALIZED);
        }
		if (pNewEnum == NULL)
			return E_POINTER;
        PQEnumFilters p;
        try {
            p = new CFilterEnumOnDSFilterList(m_Filters);
        } catch (...) {
            return E_OUTOFMEMORY;
        }
        try {
            *pNewEnum = p.Detach();
        } catch (...) {
            return E_POINTER;
        }
        return NOERROR;
	}
    STDMETHOD(get_Type)(MSVidSegmentType *pType) { 
        try {
            *pType = segtype;
            return NOERROR;
        } catch(...) {
            return E_POINTER;
        }
    }
    STDMETHOD(get_Category)(GUID *pGuid) {
        if (!m_fInit) {
	 	    return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidGraphSegment), CO_E_NOTINITIALIZED);
        }
        try {
            memcpy(pGuid, pCategory, sizeof(*pGuid));
            return NOERROR;
        } catch(...) {
            return E_POINTER;
        }
	}
    STDMETHOD(Build)() {
        return E_NOTIMPL;
    }
    STDMETHOD(PreRun)() {
        return E_NOTIMPL;
    }
    STDMETHOD(PostRun)() {
        return E_NOTIMPL;
    }
    STDMETHOD(PreStop)() {
        return E_NOTIMPL;
    }
    STDMETHOD(PostStop)() {
        return E_NOTIMPL;
    }
    STDMETHOD(Select)(IUnknown *pItem) {
        return E_NOTIMPL;
    }
    STDMETHOD(OnEventNotify)(LONG lEvent, LONG_PTR lParm1, LONG_PTR lParm2) {
        return E_NOTIMPL;
    }
    STDMETHOD(OnWindowMessage)(UINT uMsg, WPARAM wParam, LPARAM lParam) {
        return E_NOTIMPL;
    }
    STDMETHOD(Decompose)(){
        return E_NOTIMPL;
    }

};

}; // namespace

#endif
// end of file - segimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\seg.h ===
//==========================================================================;
//
// seg.h : additional infrastructure to support using IMSVidGraphSegment nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef SEG_H
#define SEG_H

#include <segment.h>
#include <fwdseq.h>
#include <devseq.h>
#include <dsextend.h>
#include <objectwithsiteimplsec.h>

namespace MSVideoControl {

typedef CComQIPtr<IMSVidGraphSegment, &__uuidof(IMSVidGraphSegment)> PQGraphSegment;

typedef Forward_Sequence<
    PQGraphSegment,
    PQEnumFilters,
    DSFilter,
    IMSVidGraphSegment, 
    IEnumFilters, 
    IBaseFilter*> VWGraphSegmentSequence;

class VWSegmentContainer;

class VWGraphSegment : public VWGraphSegmentSequence {
public:
    inline VWGraphSegment() {}
    virtual ~VWGraphSegment() {}
    inline VWGraphSegment(const PQGraphSegment &a) : VWGraphSegmentSequence(a) {}
    inline VWGraphSegment(IMSVidGraphSegment *p) : VWGraphSegmentSequence(p) {}
    inline VWGraphSegment(IUnknown *p) : VWGraphSegmentSequence(p) {}
    inline VWGraphSegment(const VWGraphSegment &a) : VWGraphSegmentSequence(a) {}
    inline VWGraphSegment(const CComVariant &v) : VWGraphSegmentSequence(((v.vt == VT_UNKNOWN) ? v.punkVal : (v.vt == VT_DISPATCH ? v.pdispVal : NULL))) {}
    VWSegmentContainer Container(void);
    MSVidSegmentType Type(void);
    DSGraph Graph(void);
    GUID2 Category();
	GUID2 ClassID();
};

typedef CComQIPtr<IMSVidGraphSegmentContainer, &__uuidof(IMSVidGraphSegmentContainer)> PQSegmentContainer;
class VWSegmentContainer : public PQSegmentContainer {
public:
    inline VWSegmentContainer() {}
    inline VWSegmentContainer(const PQSegmentContainer &a) : PQSegmentContainer(a) {}
    inline VWSegmentContainer(IUnknown *p) : PQSegmentContainer(p) {}
    inline VWSegmentContainer(IMSVidGraphSegmentContainer *p) : PQSegmentContainer(p) {}
    inline VWSegmentContainer(const VWSegmentContainer &a) : PQSegmentContainer(a) {}
    virtual ~VWSegmentContainer() {}
    DSGraph GetGraph(void) {
        DSGraph g;
        IMSVidGraphSegmentContainer* p = (*this);
        if (p) {
            p->get_Graph(&g);
        }
        return g;
    }
};

typedef std::vector<VWGraphSegment> VWSegmentList;
typedef CComQIPtr<IEnumMSVidGraphSegment, &__uuidof(IEnumMSVidGraphSegment)> PQEnumSegment;

void CtorStaticVWSegmentFwdSeqPMFs(void);
void DtorStaticVWSegmentFwdSeqPMFs(void);


class ATL_NO_VTABLE CSegEnumBase : public CComObjectRootEx<CComSingleThreadModel>,
	public IEnumMSVidGraphSegment,
    public IObjectWithSiteImplSec<CSegEnumBase>
{
    BEGIN_COM_MAP(CSegEnumBase)
	    COM_INTERFACE_ENTRY(IEnumMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IObjectWithSite)
    END_COM_MAP()
    DECLARE_PROTECT_FINAL_CONSTRUCT()
    virtual ~CSegEnumBase() {}
};

/////////////////////////////////////////////////////////////////////////////
// CSegEnum
class CSegEnum : public CComObject<CSegEnumBase>
{
public:

    CSegEnum(DeviceCollection &d) {
		for (DeviceCollection::iterator i = d.begin(); i != d.end(); ++i) {
			VWGraphSegment seg(*i);
			ASSERT(seg);
			m_pSegments.push_back(seg);
		}
	}

    CSegEnum(VWSegmentList &s) : m_pSegments(s), i(s.begin()) {
	}
	CSegEnum(CSegEnum &orig) : m_pSegments(orig.m_pSegments) {
        i = m_pSegments.begin();
        VWSegmentList::iterator i2 = orig.m_pSegments.end();
        for (;i2 != orig.i; ++i2, ++i);
	}
    virtual ~CSegEnum() {
        i = m_pSegments.end();
        m_pSegments.clear();
    }
// ISegEnum
public:
	VWSegmentList m_pSegments;
    VWSegmentList::iterator i;
// IEnumMSVidGraphSegment
	STDMETHOD(Next)(ULONG celt, IMSVidGraphSegment **rgvar, ULONG * pceltFetched)
	{
		// pceltFetched can legally == 0
		//
		if (pceltFetched != NULL) {
			try {
				*pceltFetched = 0;
			} catch(...) {
				return E_POINTER;
			}
		}

		// Retrieve the next celt elements.
		HRESULT hr = NOERROR ;
		for (ULONG l = 0;i != m_pSegments.end() && celt != 0 ; ++i, ++l, --celt) {
			(*i).CopyTo(&rgvar[l]);
			if (pceltFetched != NULL) {
				(*pceltFetched)++ ;
			}
		}

		if (celt != 0) {
		   hr = ResultFromScode( S_FALSE ) ;
		}

		return hr ;
	}
	STDMETHOD(Skip)(ULONG celt)
	{
		for (;i != m_pSegments.end() && celt--; ++i);
		return (celt == 0 ? NOERROR : ResultFromScode( S_FALSE )) ;
	}
	STDMETHOD(Reset)()
	{
		i = m_pSegments.begin();
		return NOERROR;
	}
	STDMETHOD(Clone)(IEnumMSVidGraphSegment * * ppenum)
	{
		PQEnumSegment temp;
		try {
			temp = new CSegEnum(*this);
		} catch(...) {
			return E_OUTOFMEMORY;
		}
		try {
			*ppenum = temp.Detach();
		} catch(...) {
			return E_POINTER;
		}
		return NOERROR;
	}
};

};
#endif
// end of file seg.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\stextend.h ===
//==========================================================================;
//
// stextend.h : extensions to vc++ 5.0 stl templates
// Copyright (c) Microsoft Corporation 1997.
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef STEXTEND_H
#define STEXTEND_H

#include <utility>
#include <functional>

#if 1
#include <arity.h>  //generated .h from aritygen
#else
#include <stx.h>    // old one from win98
#endif


#pragma warning(disable:4503)
#pragma warning(disable:4181)

template<class _T1, class _T2> inline
bool __cdecl operator!(const std::pair<_T1, _T2>& _X)
        {return ((!(_X.first)) && (!(_X.second))); }

template<class Ty1, class Ty2> struct equal_to2 : std::binary_function<Ty1, Ty2, bool> {
	bool operator()(const Ty1& X, const Ty2& Y) const {return (X == Y); }
};



#endif
// end of file stextend.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\scalingrect.h ===
/////////////////////////////////////////////////////////////////////////////
// scalingrect.h : gdi based rect with auto scaling for associated window handle
// Copyright (c) Microsoft Corporation 2000.

#pragma once

#ifndef SCALINGRECT_H
#define SCALINGRECT_H

#include <atltmp.h>
#include <throw.h>
#include <trace.h>

#define INVALID_HWND ((HWND) INVALID_HANDLE_VALUE)
typedef CComQIPtr<IOleInPlaceSiteWindowless> PQSiteWindowless;

class CScalingRect : public CRect {
public:
    CScalingRect(const long l = 0,
                 const long t = 0,
                 const long r = 0,
                 const long b = 0,
                 const HWND iOwner = INVALID_HWND) :
                         CRect(l, t, r, b),
						 m_hOwner(iOwner),
						 m_bRequiresSave(true) {}

    CScalingRect(const HWND iOwner) : m_bRequiresSave(true) {
		if (iOwner == INVALID_HWND) {
			CRect(0, 0, 0, 0);
		} else if (::IsWindow(iOwner)) {
            if (!::GetWindowRect(iOwner, this)) {
                    THROWCOM(E_UNEXPECTED);
            }
		} else {
			THROWCOM(E_INVALIDARG);
		}
		m_hOwner = iOwner;
	}

    CScalingRect(const CSize& sz, const HWND iOwner = INVALID_HWND) : 
					CRect(CPoint(0, 0), sz),
					 m_hOwner(iOwner),
					 m_bRequiresSave(true) {}

    CScalingRect(const POINT& pt1, POINT& pt2 = CPoint(0, 0), const HWND iOwner = INVALID_HWND) : 
					CRect(pt1, pt2),
					 m_hOwner(iOwner),
					 m_bRequiresSave(true) {}

    CScalingRect(const POINT& pt1, SIZE& sz = CSize(0, 0), const HWND iOwner = INVALID_HWND) : 
					CRect(pt1, sz),
					 m_hOwner(iOwner),
					 m_bRequiresSave(true) {}

    CScalingRect(const RECT& iPos,
                 const HWND iOwner = INVALID_HWND) :
                         CRect(iPos),
						 m_hOwner(iOwner),
						 m_bRequiresSave(true) {}

    CScalingRect(const CRect& iPos,
                 const HWND iOwner = INVALID_HWND) :
                         CRect(iPos),
						 m_hOwner(iOwner),
						 m_bRequiresSave(true) {}

	CScalingRect& operator=(const CScalingRect& rhs) {
        if (this != &rhs && *this != rhs) {
			CRect::operator=(rhs);
			if ((m_hOwner != INVALID_HWND) && (rhs.m_hOwner != INVALID_HWND) && (m_hOwner != rhs.m_hOwner)) {
				::MapWindowPoints(rhs.m_hOwner, m_hOwner, reinterpret_cast<LPPOINT>(static_cast<LPRECT>(this)), 2);
			}
            m_bRequiresSave = true;
        }
        return *this;
    }

	CScalingRect& operator=(const CRect& rhs) {
        if (this != &rhs && (CRect(*this) != rhs)) {
            CRect::operator=(rhs);
            m_bRequiresSave = true;
        }
        return *this;
    }

    bool operator==(const CScalingRect& rhs) const {
            CRect r(rhs);
            if (rhs.m_hOwner != INVALID_HWND && m_hOwner != INVALID_HWND && rhs.m_hOwner != m_hOwner) {
				::MapWindowPoints(rhs.m_hOwner, m_hOwner, reinterpret_cast<LPPOINT>(static_cast<LPRECT>(r)), 2);
			}
            return !!CRect::operator==(r);
    }
    bool operator !=(const CScalingRect& rhs) const {
            return !operator==(rhs);
    }
    bool operator==(const CRect& rhs) const {
            return CRect::operator==(rhs) != 0;
    }
    bool operator !=(const CRect& rhs) const {
            return !operator==(rhs);
    }
    bool operator==(LPCRECT rhs) const {
            return CRect::operator==(*rhs) != 0;
    }
    bool operator !=(LPCRECT rhs) const {
            return !operator==(rhs);
    }
    bool operator==(const RECT& rhs) const {
            return CRect::operator==(rhs) != 0;
    }
    bool operator !=(const RECT& rhs) const {
            return !operator==(rhs);
    }

    long Width() { return CRect::Width(); }
    long Height() { return CRect::Height(); }
    void Width(long cx) {
        right = left + cx;
    }
    void Height(long cy) {
        bottom = top + cy;
    }
    HWND Owner() const { return m_hOwner; }
    void Owner(const HWND h) {
		if (m_hOwner != h) {
			if ((m_hOwner != INVALID_HWND) && (h != INVALID_HWND)) {
				::MapWindowPoints(m_hOwner, h, reinterpret_cast<LPPOINT>(static_cast<LPRECT>(this)), 2);
			}
			m_hOwner = h;
			m_bRequiresSave = true;
		}
        return;
    }

    bool IsDirty() const { return m_bRequiresSave; }
    void Dirty(const bool fVal) { m_bRequiresSave = fVal; }
    bool m_bRequiresSave;
private:
    HWND m_hOwner;
};


#endif
// end of file scalingrect.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\trace.cpp ===
//
// trace.cpp -- global vars for trace.h
// copyright (c) Microsoft Corp. 1998
//
// this file should be include in stdafx.cpp

#ifdef DEBUG
#include "tstring.h"
#include <ostream>
#include <fstream>
#include "trace.h"
#include <process.h>


DWORD dwTraceLevel = 0;  // default to trace_error
tostream* tdbgout;
DWORD dwTraceIndent = 0;

typedef basic_oftstream<TCHAR> tfstream;

void DebugInit(LPCTSTR pszModule) {
        if (!pszModule) {
                dwTraceLevel = TRACE_ERROR;
        tdbgout = new TdbgStream;
                return;
        }
        CRegKey c;
        TCHAR szLogFile[MAX_PATH + 1];
        szLogFile[0] = 0;
        CString keyname(_T("SOFTWARE\\Debug\\"));
        keyname += pszModule;
        DWORD rc = c.Open(HKEY_LOCAL_MACHINE, keyname, KEY_READ);
        if (rc == ERROR_SUCCESS) {
                rc = c.QueryValue(dwTraceLevel, _T("Trace"));
                if (rc != ERROR_SUCCESS) {
                        dwTraceLevel = 1;
                }
                DWORD len = sizeof(szLogFile);
                rc = c.QueryValue(szLogFile, _T("LogFile"), &len);
                if (rc != ERROR_SUCCESS) {
                        szLogFile[0] = 0;
                }
                if(_tcslen(szLogFile)){
                    TCHAR szPID[MAX_PATH+1];
                    _itot(_getpid(), szPID, 10);
                    StringCchCat(szLogFile, sizeof(szLogFile)/sizeof(szLogFile[0]), szPID);
                    StringCchCat(szLogFile, sizeof(szLogFile)/sizeof(szLogFile[0]), _T(".log"));
                }
        }
    if (!_tcslen(szLogFile)) {
        tdbgout = new TdbgStream;
    } else {
        USES_CONVERSION;
        tdbgout = new tfstream(T2CA(szLogFile), std::ios::out);
    }
}

void DebugTerm(void) {
    dbgDump.flush();
    delete tdbgout;
    tdbgout = NULL;
}

#endif

// end of file - trace.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\throw.h ===
//==========================================================================;
//
// throw.h : exception handling code
// Copyright (c) Microsoft Corporation 1998.
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef THROW_H
#define THROW_H

class ComException {
public:
    ComException(HRESULT hr) : m_hr(hr) {}
    ComException(ComException &ce) : m_hr(ce.m_hr) {}
        ComException& operator=(ComException &rhs) {
                if (this != &rhs) {
                        m_hr = rhs.m_hr;
                }
                return *this;
        }
        ComException& operator=(HRESULT rhs) {
                m_hr = rhs;
                return *this;
        }
        operator HRESULT() {
                return m_hr;
        }
private:
    HRESULT m_hr;
};


#define THROWCOM(x) throw ComException(x)

#define CATCHCOM_CLEANUP(x) catch (ComException& e) { \
                                { x; } \
                                return e; \
                            }

#define CATCHCOM() CATCHCOM_CLEANUP(;)

#define CATCHALL_CLEANUP(x) CATCHCOM_CLEANUP(x) \
                            catch (std::bad_alloc& e) { \
                                { x; } \
                                return E_OUTOFMEMORY; \
                            } catch (std::exception& e) { \
                                { x; } \
                                return E_UNEXPECTED; \
                            }

#define CATCHALL()  CATCHALL_CLEANUP(;)

#endif
// end of file throw.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\tunerequestimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// TuneRequestimpl.h : implementation helper template for component type interface
// Copyright (c) Microsoft Corporation 1999.

#ifndef TUNEREQUESTIMPL_H
#define TUNEREQUESTIMPL_H

#pragma once
#include <tuner.h>
#include <Components.h>

namespace BDATuningModel {

typedef CComQIPtr<ITuningSpace> PQTuningSpace;
typedef CComQIPtr<ILocator> PQLocator;

template<class T,
         class MostDerived = ITuneRequest, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE ITuneRequestImpl : 
    public IPersistPropertyBagImpl<T>,
	public IDispatchImpl<MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{
// ITuneRequest
public:
	bool m_bRequiresSave;
	ITuneRequestImpl() : m_bRequiresSave(false) {
        m_Components = new CComObject<CComponents>;
    }
    virtual ~ITuneRequestImpl() {}
	// undone: the below map entry stores a copy of the tuning space contents instead of a 
	// reference to the tuning space.  This should be changed to store a tuning space moniker
    BEGIN_PROP_MAP(ITuneRequestImpl)
        PROP_DATA_QI_ENTRY("Tuning Space", m_TS.p, __uuidof(ITuningSpace))
        PROP_DATA_QI_ENTRY("Locator", m_Locator.p, __uuidof(ILocator))
    END_PROP_MAP()

	PQTuningSpace m_TS;
	PQComponents m_Components;
	PQLocator m_Locator;

	STDMETHOD(get_TuningSpace)(/* [out, retval] */ ITuningSpace **ppTS){ 
		try {
			if (!ppTS) {
				return E_POINTER;
			}
			ATL_LOCKT();
            if (!m_TS) {
                return E_UNEXPECTED;
            }
			return m_TS.CopyTo(ppTS);
		} catch (...) {
			return E_OUTOFMEMORY;
		}
    }
	STDMETHOD(get_Components)(/* [out, retval] */ IComponents **ppC){ 
		try {
			if (!ppC) {
				return E_POINTER;
			}
			ATL_LOCKT();
            if (!m_Components) {
                return E_UNEXPECTED;
            }
			return m_Components.CopyTo(ppC);
		} catch (...) {
			return E_OUTOFMEMORY;
		}
    }
	STDMETHOD(Clone) (ITuneRequest **ppTR) {
		try {
			if (!ppTR) {
				return E_POINTER;
			}
			ATL_LOCKT();
			T* pt = static_cast<T*>(new CComObject<T>);
			if (!pt) {
				return E_OUTOFMEMORY;
			}
            if (!m_TS) {
                // corrupt tune request.  we can't have a tunerequest without an
                // attached tuning space since the tuning space is the factory
                // and always sets this property to non-null at creation time.
                // the only way to get a NULL is for an unpersist from a corrupt store
                // or a bug in a tuning space's implementation.
                return E_UNEXPECTED;
            }
            ASSERT(!pt->m_TS);
			HRESULT hr = m_TS->Clone(&pt->m_TS);
			if (m_Components) {
                if (pt->m_Components) {
                    pt->m_Components.Release();
                }
                ASSERT(!pt->m_Components);
				hr = m_Components->Clone(&pt->m_Components);
				if (FAILED(hr)) {
					delete pt;
					return hr;
				}
			}
			if (m_Locator) {
                ASSERT(!pt->m_Locator);
				hr = m_Locator->Clone(&pt->m_Locator);
				if (FAILED(hr)) {
					delete pt;
					return hr;
				}
			}
			pt->m_bRequiresSave = true;
			pt->AddRef();
			*ppTR = pt;
			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
	}
    STDMETHOD(get_Locator) (ILocator **ppLocator) {
		try {
			if (!ppLocator) {
				return E_POINTER;
			}
			ATL_LOCKT();
			return m_Locator.CopyTo(ppLocator);
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
    };

    STDMETHOD(put_Locator) (ILocator *pLocator) {
		try {
			ATL_LOCKT();
            m_Locator = pLocator;
	        MARK_DIRTY(T);

			return NOERROR;
		} catch (HRESULT h) {
			return h;
		} catch (...) {
			return E_POINTER;
		}
    };

};

typedef CComQIPtr<ITuneRequest> PQTuneRequest;

}; // namespace

#endif // TUNEREQUESTIMPL_H
// end of file -- tunerequestimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\tuningspacecollectionimpl.h ===
/////////////////////////////////////////////////////////////////////////////////////
// TuningSpaceCollectionImpl.h : Declaration of the TuningSpaceCollectionImpl.h
// Copyright (c) Microsoft Corporation 1999-2000

#include <tuner.h>

namespace BDATuningModel {

typedef CComQIPtr<ITuningSpace> PQTuningSpace;
typedef std::map<ULONG, CComVariant> TuningSpaceContainer_t;  // id->object mapping, id's not contiguous

// utilities for element management semantics for TuningSpaceContainerEnum_t
class stlmapClone
{
public:
	static HRESULT copy(VARIANT* p1, std::pair<const ULONG, CComVariant> *p2) {
		if (p2->second.vt != VT_DISPATCH && p2->second.vt != VT_UNKNOWN) {
			return DISP_E_TYPEMISMATCH;
		}
		PQTuningSpace pts(p2->second.punkVal);
		if (!pts) {
			return E_UNEXPECTED;
		}
		p1->vt = p2->second.vt;
		PQTuningSpace pnewts;
		HRESULT hr = pts->Clone(&pnewts);
		if (FAILED(hr)) {
			return hr;
		}
		p1->punkVal = pnewts.Detach();
		return NOERROR;
	}
	static void init(VARIANT* p) {VariantInit(p);}
	static void destroy(VARIANT* p) {VariantClear(p);}
};
typedef CComEnumOnSTL<IEnumVARIANT, &IID_IEnumVARIANT, VARIANT, stlmapClone, TuningSpaceContainer_t, CComMultiThreadModel> TuningSpaceContainerEnum_t;
class stlmapClone2
{
public:
	static HRESULT copy(ITuningSpace** p1, std::pair<const ULONG, CComVariant> *p2) {
		if (p2->second.vt != VT_DISPATCH && p2->second.vt != VT_UNKNOWN) {
			return DISP_E_TYPEMISMATCH;
		}
        PQTuningSpace p(p2->second.punkVal);
        if (!p) {
            return E_UNEXPECTED;
        }
        // don't ASSERT(p1 && !*p1);  if !p1 then clone will return E_POINTER and p1 itself
        // can point to unitialized memory if the caller passed down a new'd array of pointers
        // to enum::Next(). therefore if this clone causes a leak then its the callers bug
		return p->Clone(p1);
	}
	static void init(ITuningSpace** p) {*p = NULL;}
	static void destroy(ITuningSpace** p) {(*p)->Release(); *p = NULL;}
};
typedef CComEnumOnSTL<IEnumTuningSpaces, &__uuidof(IEnumTuningSpaces), ITuningSpace*, stlmapClone2, TuningSpaceContainer_t, CComMultiThreadModel> TuningSpaceEnum_t;


template<class T, class TSInterface, LPCGUID TSInterfaceID, LPCGUID TypeLibID> class TuningSpaceCollectionImpl : 
	public IDispatchImpl<TSInterface, TSInterfaceID, TypeLibID> {
public:

    TuningSpaceContainer_t m_mapTuningSpaces;

    virtual ~TuningSpaceCollectionImpl() {
        m_mapTuningSpaces.clear();
    }

	STDMETHOD(get__NewEnum)(/*[out, retval]*/ IEnumVARIANT** ppVal) {
		try {
			if (ppVal == NULL) {
				return E_POINTER;
			}
			CComObject<TuningSpaceContainerEnum_t>* p;

			*ppVal = NULL;

			HRESULT hr = CComObject<TuningSpaceContainerEnum_t>::CreateInstance(&p);
			if (FAILED(hr) || !p) {
				return E_OUTOFMEMORY;
			}
			ATL_LOCKT();
			hr = p->Init(pT->GetUnknown(), m_mapTuningSpaces);
			if (FAILED(hr)) {
				delete p;
				return hr;
			}
			hr = p->QueryInterface(__uuidof(IEnumVARIANT), reinterpret_cast<LPVOID *>(ppVal));
			if (FAILED(hr)) {
				delete p;
				return hr;
			}
			return NOERROR;
		} catch(...) {
			return E_POINTER;
		}

	}
	STDMETHOD(get_EnumTuningSpaces)(/*[out, retval]*/ IEnumTuningSpaces** ppNewEnum) {
		if (!ppNewEnum) {
			return E_POINTER;
		}
		try {
			CComObject<TuningSpaceEnum_t>* p;

			*ppNewEnum = NULL;

			HRESULT hr = CComObject<TuningSpaceEnum_t>::CreateInstance(&p);
			if (FAILED(hr) || !p) {
				return E_OUTOFMEMORY;
			}
			ATL_LOCKT();
			hr = p->Init(pT->GetUnknown(), m_mapTuningSpaces);
			if (FAILED(hr)) {
				delete p;
				return hr;
			}
			hr = p->QueryInterface(__uuidof(IEnumTuningSpaces), (void**)ppNewEnum);
			if (FAILED(hr)) {
				delete p;
				return hr;
			}

			return NOERROR;
		} catch(...) {
			return E_UNEXPECTED;
		}
	}

	STDMETHOD(get_Count)(/*[out, retval]*/ long *plVal) {
		if (!plVal) {
			return E_POINTER;
		}
		try {
			ATL_LOCKT();
			*plVal = static_cast<long>(m_mapTuningSpaces.size());
			return NOERROR;
		} catch(...) {
			return E_POINTER;
		}
	}

};

}; // namespace

// end of file - tuningspacecollectionimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\tunerimpl.h ===
//==========================================================================;
//
// tunerimpl.h : additional infrastructure to support implementing IMSVidTuner 
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef TUNERIMPL_H
#define TUNERIMPL_H

#include "videoinputimpl.h"
#include "tune.h"
#include <deviceeventimpl.h>

namespace MSVideoControl {

    template<class T, LPCGUID LibID, LPCGUID KSCategory, class MostDerivedInterface = IMSVidTuner>
    class DECLSPEC_NOVTABLE IMSVidTunerImpl :         
        public IMSVidVideoInputImpl<T, LibID, KSCategory, MostDerivedInterface> {
    public:

        TNTuningSpace m_TS;
        TNTuneRequest m_pCurrentTR;

        IMSVidTunerImpl() : m_TS(), m_pCurrentTR() {}
        virtual ~IMSVidTunerImpl() {}
        virtual HRESULT DoTune(TNTuneRequest& pTR) = 0;
        virtual HRESULT UpdateTR(TNTuneRequest& pTR) = 0;
        // IMSVidInputDevice
        STDMETHOD(IsViewable)(VARIANT* pv, VARIANT_BOOL *pfViewable)
        {
            if (!m_fInit) {
                return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidTuner), CO_E_NOTINITIALIZED);
            }
            if (!pv) {
                return E_POINTER;
            }
            return E_NOTIMPL;
        }

        STDMETHOD(View)(VARIANT* pv) {
            if (!m_fInit) {
                return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidTuner), CO_E_NOTINITIALIZED);
            }
            if (!pv) {
                return E_POINTER;
            }
            try {
                if (pv->vt != VT_DISPATCH && pv->vt != VT_UNKNOWN) {
                    return ImplReportError(__uuidof(T), IDS_INVALID_CONTENT, __uuidof(IMSVidTuner), E_INVALIDARG);
                }
                PQTuneRequest tr((pv->vt == VT_UNKNOWN) ? pv->punkVal : pv->pdispVal);
                if (!tr) {
                    return ImplReportError(__uuidof(T), IDS_INVALID_CONTENT, __uuidof(IMSVidTuner), E_INVALIDARG);
                }

                return put_Tune(tr);
            } catch(...) {
                return E_UNEXPECTED;
            }
        }

        // IMSVidTuner
        STDMETHOD(put_Tune)(ITuneRequest *pTR) {
            TRACELM(TRACE_DETAIL, "IMSVidTunerImpl<>::put_Tune()");
            if (!m_fInit) {
                return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidTuner), CO_E_NOTINITIALIZED);
            }
            if (!pTR) {
                return E_POINTER;
            }
            try {
                TNTuneRequest req(pTR);
                ASSERT(req);
                if (m_TS) {
                    // if this tuner has been initialized propertly it will have a tuning space
                    // that it handles already specified.  in that case, we should only
                    // handle tune requests for our ts
                    TNTuningSpace ts(req.TuningSpace());
                    if (ts != m_TS) {
                        return ImplReportError(__uuidof(T), IDS_INVALID_TS, __uuidof(IMSVidTuner), E_INVALIDARG);
                    }
                } else {
                    // undone: if dev init is correct this case should never occur
                    // return E_UNEXPECTED;
                }
                HRESULT hr = DoTune(req);
                if (SUCCEEDED(hr)) {
                    m_pCurrentTR = req;
                    m_pCurrentTR.Clone();
                    if (!m_TS) {
                        // undone: this is bad.  temporary hack until dev init is correct.
                        m_TS = req.TuningSpace();
                        m_TS.Clone();
                    }
                }
                return hr;
            } catch(...) {
                return E_INVALIDARG;
            }
        }
        STDMETHOD(get_Tune)(ITuneRequest **ppTR) {
            if (!m_fInit) {
                return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidTuner), CO_E_NOTINITIALIZED);
            }
            if (!ppTR) {
                return E_POINTER;
            }
            try {
                HRESULT hr = UpdateTR(m_pCurrentTR);
                if (FAILED(hr)) {
                    return hr;
                }
                return m_pCurrentTR.CopyTo(ppTR);
            } catch(...) {
                return E_INVALIDARG;
            }
        }

        STDMETHOD(get_TuningSpace)(ITuningSpace **ppTS) {
            if (!m_fInit) {
                return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidTuner), CO_E_NOTINITIALIZED);
            }
            if (ppTS == NULL)
                return E_POINTER;
            try {
                m_TS.CopyTo(ppTS);
                return NOERROR;
            } catch(...) {
                return E_UNEXPECTED;
            }
        }
        STDMETHOD(put_TuningSpace)(ITuningSpace* pTS) {
            return E_NOTIMPL;
        }
        };


    template <class T, const IID* piid = &IID_IMSVidTunerEvent, class CDV = CComDynamicUnkArray>
    class CProxy_Tuner : public CProxy_DeviceEvent<T, piid, CDV>
    {
        //Warning this class may be recreated by the wizard.
    public:
        VOID Fire_OnTuneChanged(IMSVidTuner *pTunerDev)
        {
            T* pT = static_cast<T*>(this);
            int nConnectionIndex;
            CComVariant* pvars = new CComVariant[1];
            int nConnections = m_vec.GetSize();

            for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
            {
                pT->Lock();
                CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
                pT->Unlock();
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
                if (pDispatch != NULL)
                {
                    pvars[0] = pTunerDev;
                    DISPPARAMS disp = { pvars, NULL, 1, 0 };
                    pDispatch->Invoke(eventidOnTuneChanged, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
                }
            }
            delete[] pvars;

        }

    };


}; // namespace

#endif
// end of file - tunerimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\trace.h ===
// trace.h : tracing helper macros
// Copyright (c) Microsoft Corporation 1995-1997.

#pragma once
#pragma warning(disable : 4296)
#ifndef TRACE_H
#define TRACE_H

// if you want to use the vidctl helper *impl templates without using the
// vidctl trace/debug infrastructure then #define NO_VIDCTL_TRACE_SUPPORT
// separately if you don't want to use the vidctl ASSERT then 
// #define NO_VIDCTL_ASSERT_SUPPORT
#ifdef NO_VIDCTL_TRACE_SUPPORT
#ifndef TRACELM
#define TRACELM(level, msg)
#endif
#ifndef TRACELS
#define TRACELS(level, stmt)
#endif
#ifndef TRACELSM
#define TRACELSM(level, stmt, msg)
#endif
#ifndef BEGIN_TRACEL
#define BEGIN_TRACEL(level)
#endif
#ifndef TRACES
#define TRACES(stmt)
#endif
#ifndef END_TRACEL
#define END_TRACEL
#endif
#ifndef END_TRACELM
#define END_TRACELM(msg)
#endif
#ifndef TRACEINDENT
#define TRACEINDENT()
#endif
#ifndef TRACEOUTDENT
#define TRACEOUTDENT()
#endif
#else // NO_VIDCTL_TRACE_SUPPORT
#ifdef NO_VIDCTL_ASSERT_SUPPORT
#ifndef ASSERT
#define ASSERT(x)
#endif
#else // NO_VIDCTL_ASSERT_SUPPORT
#if !defined(DEBUG) && (defined(_DBG) || defined(DBG) || defined(_DEBUG))
#define DEBUG 1
#endif
#if !defined(_DEBUG) && (defined(_DBG) || defined(DBG) || defined(DEBUG))
#define _DEBUG 1
#endif

#ifdef DEBUG

enum {
    TRACE_ALWAYS = 0,
    TRACE_ERROR,
    TRACE_DEBUG,
    TRACE_DETAIL,
    TRACE_PAINT,
    TRACE_TEMP,
};

#pragma warning (push)
#pragma warning (disable : 4018) // sign/unsign mismatch in ostream line 312
#include <fstream>
#include <tstring.h>
#include <odsstream.h>
#pragma warning (pop)

#define STRSAFE_NO_CB_FUNCTIONS
#include <strsafe.h>
#define SIZEOF_CH(X) (sizeof(X)/sizeof(X[0]))

inline Tstring hexdump(unsigned long ul) {
        TCHAR c[32];
        _ltot(ul, c, 16);
        return Tstring(c);
}

#ifdef DUMP_TIME_STAMPS
extern  _int64 g_ulFreq, g_ulTimeStart;
extern  DumpPerfTime();
#else
#define DumpPerfTime()
#endif

#define DUMP_TID
#ifdef DUMP_TID
inline Tstring DumpTid() {
    TCHAR c[32];
    (void) StringCchPrintf(c, SIZEOF_CH(c), _T("T0x%8.8lX: "), ::GetCurrentThreadId());
    return Tstring(c);
}
#else // DUMP_TID
#define DumpTid()
#endif // DUMP_TID

extern DWORD dwTraceLevel;
extern DWORD dwTraceIndent;
extern tostream* tdbgout;
#define dbgDump (*tdbgout)
void DebugInit(LPCTSTR pszLogFile = NULL);
void DebugTerm(void);

inline tostream& DumpHdr(tostream& tout) {
        DumpPerfTime();
        tout << DumpTid();
        for (DWORD i = 0; i < dwTraceIndent; ++i) {
                tout << "    ";
        }
        return tout;
}

template<class _E, class _Tr = std::char_traits<_E> >
        class basic_oftstream : public basic_otstream<_E, _Tr> {
public:
        typedef basic_oftstream<_E, _Tr> _Myt;
        typedef std::basic_filebuf<_E, _Tr> _Myfb;
        basic_oftstream()
                : basic_otstream<_E, _Tr>(&_Fb) {}
        explicit basic_oftstream(const char *_S,
                ios_base::openmode _M = out | trunc)
                : basic_otstream<_E, _Tr>(&_Fb)
                {if (_Fb.open(_S, _M | out) == 0)
                        setstate(failbit); }
        virtual ~basic_oftstream()
                {}
        _Myfb *rdbuf() const
                {return ((_Myfb *)&_Fb); }
        bool is_open() const
                {return (_Fb.is_open()); }
        void open(const char *_S, ios_base::openmode _M = out | trunc)
                {if (_Fb.open(_S, _M | out) == 0)
                        setstate(failbit); }
        void open(const char *_S, ios_base::open_mode _M)
                {open(_S, (openmode)_M); }
        void close()
                {if (_Fb.close() == 0)
                        setstate(failbit); }
private:
        _Myfb _Fb;
        };

#define TRACELM(level, msg) if (dwTraceLevel >= level) { DumpHdr(dbgDump) << msg << _T("\r\n"); dbgDump.flush(); };
#define TRACELS(level, stmt) if (dwTraceLevel >= level) { stmt; }
#define TRACELSM(level, stmt, msg) if (dwTraceLevel >= level) {DumpHdr(dbgDump);  stmt; dbgDump << msg << _T("\r\n");  dbgDump.flush(); }
#define BEGIN_TRACEL(level) if (dwTraceLevel >= level) {
#define TRACES(stmt) stmt;
#define END_TRACEL }
#define END_TRACELM(msg) {DumpHdr(dbgDump) << msg << _T("\r\n");  dbgDump.flush(); } }

#ifdef _M_IX86
#define ASSERT(f) \
        do  { \
                if (!(f)) { \
                        dbgDump << "ASSERT Failed (" #f ") at: " << __FILE__ << " " << __LINE__;  dbgDump.flush(); \
                        _ASSERT(f);\
                } \
        } while (0)
#else
#define ASSERT(f) \
        do  { \
                if (!(f)) { \
                        dbgDump << "ASSERT Failed (" #f ") at: " << __FILE__ << " " << __LINE__;  dbgDump.flush(); \
                        _ASSERT(f);\
                } \
        } while (0)
#endif // _M_IX86

inline void TRACEINDENT() { ++dwTraceIndent; }
inline void TRACEOUTDENT() { ASSERT(dwTraceIndent != 0); --dwTraceIndent; }

#else //debug

#define TRACELM(level, msg)
#define TRACELS(level, stmt)
#define TRACELSM(level, stmt, msg)
#define BEGIN_TRACEL(level)
#define TRACES(stmt)
#define END_TRACEL
#define END_TRACELM(msg)
#define ASSERT(x)
#define TRACEINDENT()
#define TRACEOUTDENT()
#pragma warning (push)
#pragma warning (disable : 4018) // sign/unsign mismatch in ostream line 312
#include <fstream>
#pragma warning (pop)
#define STRSAFE_NO_CB_FUNCTIONS
#include <strsafe.h>
#define SIZEOF_CH(X) (sizeof(X)/sizeof(X[0]))

#endif // DEBUG
#endif // NO_VIDCTL_ASSERT_SUPPORT
#endif // NO_VIDCTL_TRACE_SUPPORT

#endif // TRACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\tstring.h ===
// tstring.h string helpers
// Copyright (c) Microsoft Corporation 1998.

#pragma once

#ifndef TSTRING_H
#define TSTRING_H

#include <tchar.h>
#include <string>
#include <atlconv.h>
#ifndef USE_TSTRING_CSTRING
#include <atltmp.h>
#endif

#ifdef DEBUG
typedef std::basic_string<TCHAR> base_tstring;
class Tstring : public base_tstring {
public:
	inline Tstring() {}
	virtual ~Tstring() {}
	inline Tstring(const base_tstring &ts) : base_tstring(ts) {}
	inline Tstring(const Tstring &ts) : base_tstring(ts) {}

	inline Tstring &operator=(const Tstring &rhs) {
		if (this != rhs.const_address()) {
			base_tstring::operator=(rhs);
		}
		return *this;
	}
	inline Tstring &operator=(const TCHAR *rhs) {
		if (this != reinterpret_cast<const Tstring *>(rhs)) {
			base_tstring::operator=(rhs);
		}
		return *this;
	}

	inline LPCTSTR operator&() const {
    // NOTE: this is based on c++ std basic_string. all caveats about
    // c_str method apply: ptr is read-only and invalid after another
    // non-const member is called
		return c_str();
	}

#ifndef _UNICODE
	inline Tstring &operator=(const LPCOLESTR rhs) {
		if (this != reinterpret_cast<const Tstring *>(rhs)) {
			USES_CONVERSION;
			base_tstring::operator=(OLE2T(rhs));
		}
		return *this;
	}
#else
	inline Tstring &operator=(const LPCSTR rhs) {
		if (this != reinterpret_cast<const Tstring *>(rhs)) {
			USES_CONVERSION;
			base_tstring::operator=(A2T(rhs));
		}
		return *this;
	}
#endif

    inline const Tstring *const_address() const {
        return this;
    }

    inline Tstring *address() {
        return this;
    }

};
#endif

#ifdef USE_TSTRING_CSTRING
class CString : public Tstring {
public:
	inline CString() : Tstring() {}
	inline CString(const Tstring &ts) : Tstring(ts) {}
	inline CString(const CString &cs) : Tstring(cs) {}
	virtual ~CString() {}
	inline LPCTSTR operator&() const {
    // NOTE: this is based on c++ std basic_string. all caveats about
    // c_str method apply: ptr is read-only and invalid after another
    // non-const member is called
		return c_str();
	}
	inline CString &operator=(const CString &rhs) {
		if (this != rhs.const_address()) {
			Tstring::operator=(rhs);
		}
		return *this;
	}
	inline CString &operator=(const TCHAR *rhs) {
		if (this != reinterpret_cast<const CString *>(rhs)) {
			Tstring::operator=(rhs);
		}
		return *this;
	}
    inline const CString *const_address() const {
        return this;
    }

    inline CString *address() {
        return this;
    }

	bool IsEmpty(void) const {
		return size() == 0;
	};
};
#endif

#endif
// end of file tstring.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\tuningspaceimpl.h ===
// TuningSpace.h : Declaration of the CTuningSpace
// Copyright (c) Microsoft Corporation 1999.

#ifndef TUNINGSPACEIMPL_H
#define TUNINGSPACEIMPL_H

#include <tuner.h>
#include "componenttypes.h"

namespace BDATuningModel {

const int MAX_DEFAULT_PREFERRED_COMPONENT_TYPES = 64;

template<class T,
		 class TuneRequestType,
         class MostDerived = ITuningSpace, 
         LPCGUID iid = &__uuidof(MostDerived),
         LPCGUID LibID = &LIBID_TunerLib, 
         WORD wMajor = 1,
         WORD wMinor = 0, 
         class tihclass = CComTypeInfoHolder
        > class ATL_NO_VTABLE ITuningSpaceImpl : 
    public IPersistPropertyBagImpl<T>,
	public IDispatchImpl<MostDerived, iid, LibID, wMajor, wMinor, tihclass>
{

public:
    ITuningSpaceImpl() {}
    virtual ~ITuningSpaceImpl() {}
    typedef ITuningSpaceImpl<T, TuneRequestType, MostDerived, iid, LibID, wMajor, wMinor, tihclass> thistype;
    typedef CComQIPtr<ILocator> PQLocator;

    BEGIN_PROP_MAP(thistype)
        PROP_DATA_ENTRY("Name", m_UniqueName.m_str, VT_BSTR)
        PROP_DATA_ENTRY("Description", m_FriendlyName.m_str, VT_BSTR)
        PROP_DATA_ENTRY("Network Type", m_NetworkType.m_str, VT_BSTR)
        PROP_DATA_QI_ENTRY("Default Component Types", m_DefaultPreferredComponents.p, __uuidof(IComponentTypes))
        PROP_DATA_ENTRY("Frequency Mapping", m_FrequencyMapping.m_str, VT_BSTR_BLOB)
        PROP_DATA_QI_ENTRY("Default Locator", m_DefaultLocator.p, __uuidof(ILocator))
    END_PROPERTY_MAP()

	// note: don't put a com map in an impl.  it will override the derived classes
	// and script clients will get only get type info for the base class methods .  
	// only provide a com map in the most derived class representing the actual coclass
    
	CComBSTR m_UniqueName;
    CComBSTR m_FriendlyName;
    CComBSTR m_FrequencyMapping;
    CComBSTR m_NetworkType;
    PQComponentTypes m_DefaultPreferredComponents;
    PQLocator m_DefaultLocator;

// ITuningSpace
	STDMETHOD(get_UniqueName)(/* [out, retval] */ BSTR *pName){
		if (!pName) {
			return E_POINTER;
		}
		ATL_LOCKT();
        return m_UniqueName.CopyTo(pName);
    }
	STDMETHOD(put_UniqueName)(/* [in] */ BSTR Name){ 
		CHECKBSTRLIMIT(Name);
		ATL_LOCKT();
        m_UniqueName = Name;
        MARK_DIRTY(T);

    	return NOERROR;
    }
	STDMETHOD(get_FriendlyName)(/* [out, retval] */ BSTR *pName){ 
		if (!pName) {
			return E_POINTER;
		}
		ATL_LOCKT();
        return m_FriendlyName.CopyTo(pName);
    }
	STDMETHOD(put_FriendlyName)(/* [in] */ BSTR Name){ 
		CHECKBSTRLIMIT(Name);
		ATL_LOCKT();
        m_FriendlyName = Name;
        MARK_DIRTY(T);

    	return NOERROR;
    }
	STDMETHOD(get_CLSID)(/* [out, retval] */ BSTR *pbstrCLSID){ 
		if (!pbstrCLSID) {
			return E_POINTER;
		}
        try {
            GUID2 g;
			HRESULT hr = GetClassID(&g);
			if (FAILED(hr)) {
				return hr;
			}
			ATL_LOCKT();
            *pbstrCLSID = g.GetBSTR();
			return NOERROR;
        } CATCHCOM();
    }
	STDMETHOD(get_NetworkType)(/* [out, retval] */ BSTR *pNetworkTypeGuid){ 
		if (!pNetworkTypeGuid) {
			return E_POINTER;
		}
        try {
            GUID2 g;
			HRESULT hr = get__NetworkType(&g);
			if (FAILED(hr)) {
				return hr;
			}
            *pNetworkTypeGuid = g.GetBSTR();
			return NOERROR;
        } CATCHCOM();
    }
    // should be network provider clsid
	STDMETHOD(put_NetworkType)(/* [in] */ BSTR NetworkTypeGuid){ 
        try {
            GUID2 g(NetworkTypeGuid);
            return put__NetworkType(g);
        } CATCHCOM();
    }

	STDMETHOD(get__NetworkType)(/* [out, retval] */ GUID* pNetworkTypeGuid){ 
        if (!pNetworkTypeGuid) {
            return E_POINTER;
        }
        try {
			ATL_LOCKT();
            GUID2 g(m_NetworkType);
            memcpy(pNetworkTypeGuid, &g, sizeof(GUID));
    	    return NOERROR;
        } CATCHCOM();
    }
	STDMETHOD(put__NetworkType)(/* [out, retval] */ REFCLSID pNetworkTypeGuid){ 
        try {
            GUID2 g(pNetworkTypeGuid);
			ATL_LOCKT();
            // NOTE: the network type guid is the clsid for the network provider filter
            // for this type of this tuning space.  since we're only allowing 
            // ourselves to run from trusted zones we can assume that this clsid is also
            // trustworthy.  however, if we do more security review and decide to enable
            // use of the tuning model from the internet zone then this is no longer safe.
            // in this case, we need to get IInternetHostSecurityManager from IE and 
            // call ProcessURLAction(URLACTION_ACTIVEX_RUN) and make sure we get back
            // URLPOLICY_ALLOW.  otherwise, we're bypassing IE's list of known bad
            // objects.
            // see ericli's complete guide to script security part I on http://pgm/wsh
            // for more details.
            m_NetworkType = g.GetBSTR();
            MARK_DIRTY(T);
    	    return NOERROR;
        } CATCHCOM();
    }

	STDMETHOD(EnumCategoryGUIDs)(/* [out, retval] */ IEnumGUID **ppEnum){ 
        return E_NOTIMPL; 
    }
	STDMETHOD(EnumDeviceMonikers)(/* [out, retval] */ IEnumMoniker **ppEnum){ 
        return E_NOTIMPL; 
    }
	STDMETHOD(get_DefaultPreferredComponentTypes)(/* [out, retval] */ IComponentTypes** ppComponentTypes){ 
        if (!ppComponentTypes) {
            return E_POINTER;
        }

		ATL_LOCKT();
        m_DefaultPreferredComponents.CopyTo(ppComponentTypes);

    	return NOERROR;
    }
	STDMETHOD(put_DefaultPreferredComponentTypes)(/* [in] */ IComponentTypes* pNewComponentTypes){ 
        try {
            HRESULT hr = NOERROR;
            PQComponentTypes pct;
            if (pNewComponentTypes) {
                long lCount = 0;
                hr = pNewComponentTypes->get_Count(&lCount);
                if (FAILED(hr) || lCount > MAX_DEFAULT_PREFERRED_COMPONENT_TYPES) {
                    return E_INVALIDARG;
                }
                hr = pNewComponentTypes->Clone(&pct);
            }
            if (SUCCEEDED(hr)) {
    			ATL_LOCKT();
                m_DefaultPreferredComponents = pct;
                MARK_DIRTY(T);
            }
    	    return hr;
        } CATCHCOM();
    }
	STDMETHOD(CreateTuneRequest)(/* [out, retval] */ ITuneRequest **ppTuneRequest){ 
		if (!ppTuneRequest) {
			return E_POINTER;
		}
        TuneRequestType *pt = NULL;
		try {
			pt = new CComObject<TuneRequestType>;
			if (!pt) {
				return E_OUTOFMEMORY;
			}
			ATL_LOCKT();
			HRESULT hr = Clone(&pt->m_TS);
            if (FAILED(hr)) {
                delete pt;
                return hr;
            }
			pt->AddRef();
			*ppTuneRequest = pt;
			return NOERROR;
        } CATCHCOM_CLEANUP(delete pt);
    }
	STDMETHOD(get_FrequencyMapping)(/* [out, retval] */ BSTR *pMap){ 
        if(!pMap){
            return E_POINTER;
        }
		ATL_LOCKT();
        return m_FrequencyMapping.CopyTo(pMap);
    }
	STDMETHOD(put_FrequencyMapping)(/* [in] */ BSTR Map){ 
		CHECKBSTRLIMIT(Map);
		ATL_LOCKT();
        m_FrequencyMapping = &Map;
        MARK_DIRTY(T);

    	return NOERROR;
    }

	STDMETHOD(get_DefaultLocator)(/* [out, retval] */ ILocator** ppLocator){ 
        if (!ppLocator) {
            return E_POINTER;
        }
		ATL_LOCKT();
        m_DefaultLocator.CopyTo(ppLocator);

    	return NOERROR;
    }
	STDMETHOD(put_DefaultLocator)(/* [in] */ ILocator* NewLocator){ 
        try {
			ATL_LOCKT();
            PQLocator pl;
            HRESULT hr = NOERROR;
            if (NewLocator) {
                hr = NewLocator->Clone(&pl);
            }
            if (SUCCEEDED(hr)) {
                m_DefaultLocator = pl;
                MARK_DIRTY(T);
            }
    	    return hr;
        } CATCHCOM();
    }
	STDMETHOD(Clone) (ITuningSpace **ppTR) {
        T* pt = NULL;
		try {
			if (!ppTR) {
				return E_POINTER;
			}
			ATL_LOCKT();
			pt = static_cast<T*>(new CComObject<T>);
			if (!pt) {
				return E_OUTOFMEMORY;
			}
    
            pt->m_UniqueName = m_UniqueName;
            pt->m_FriendlyName = m_FriendlyName;
            pt->m_NetworkType = m_NetworkType;
            if (m_DefaultPreferredComponents) {
                ASSERT(!pt->m_DefaultPreferredComponents);
                HRESULT hr = m_DefaultPreferredComponents->Clone(&pt->m_DefaultPreferredComponents);
                if (FAILED(hr)) {
                    delete pt;
                    return hr;
                }
            }
            pt->m_FrequencyMapping = m_FrequencyMapping;
            if (m_DefaultLocator) {
                ASSERT(!pt->m_DefaultLocator);
                HRESULT hr = m_DefaultLocator->Clone(&pt->m_DefaultLocator);
                if (FAILED(hr)) {
                    delete pt;
                    return hr;
                }
            }
            
            pt->m_bRequiresSave = true;
			pt->AddRef();
			*ppTR = pt;
			return NOERROR;
        } CATCHCOM_CLEANUP(delete pt);
	}

};

}; //namespace

#endif // TUNINGSPACEIMPL_H
// end of file -- tuningspaceimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\videoinputimpl.h ===
//==========================================================================;
//
// videoinputmpl.h : additional infrastructure to support implementing IMSVidVideoInput
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef VIDEOINPUTIMPL_H
#define VIDEOINPUTIMPL_H

#include "inputimpl.h"

namespace MSVideoControl {

template<class T, LPCGUID LibID, LPCGUID KSCategory, class MostDerivedInterface = IMSVidVideoInputDevice>
    class DECLSPEC_NOVTABLE IMSVidVideoInputImpl :         
        public IMSVidInputDeviceImpl<T, LibID, KSCategory, MostDerivedInterface> {
//        public virtual CMSVidDeviceSegmentImpl {
public:
	IMSVidVideoInputImpl() {}
    virtual ~IMSVidVideoInputImpl() {}
    STDMETHOD(get_ImageSourceWidth)(long *x) {
        return E_NOTIMPL;
	}
    STDMETHOD(get_ImageSourceHeight)(long *y) {
        return E_NOTIMPL;
	}
    STDMETHOD(get_OverScan)(long *plPercent) {
        return E_NOTIMPL;
	}
    STDMETHOD(put_OverScan)(long lPercent) {
        return E_NOTIMPL;
	}
    STDMETHOD(get_Volume)(long *lVol) {
        return E_NOTIMPL;
	}
    STDMETHOD(put_Volume)(long lVol) {
        return E_NOTIMPL;
	}
    STDMETHOD(put_Balance)(long lBal) {
        return E_NOTIMPL;
	}
    STDMETHOD(get_Balance)(long *lBal) {
        return E_NOTIMPL;
	}
};

}; // namespace
#endif
// end of file - videoinputimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\vidvidimpl.h ===
//==========================================================================;
// MSVidVideoRenderer.h : Declaration of the CMSVidVideoRenderer
// copyright (c) Microsoft Corp. 1998-1999.
//==========================================================================;

#ifndef __MSVidVIDEORENDERERIMPL_H_
#define __MSVidVIDEORENDERERIMPL_H_

#pragma once

#include <algorithm>
#include <evcode.h>
#include <uuids.h>
#include <amvideo.h>
#include <strmif.h>
#include "vidrect.h"
#include "vrsegimpl.h"
#include "outputimpl.h"
#include "seg.h"
#include "videorenderercp.h"
#include "strmif.h"
#include "resource.h"       // main symbols



//typedef CComQIPtr<IVMRSurfaceAllocator> PQVMRSAlloc;
//typedef CComQIPtr<IVMRAlphaBitmap> PQVMRAlphaBitm;
/////////////////////////////////////////////////////////////////////////////
// CMSVidVideoRenderer
template<class T, LPCGUID LibID, LPCGUID Category, class MostDerivedClass = IMSVidVideoRenderer>
    class DECLSPEC_NOVTABLE IMSVidVideoRendererImpl :
        public IMSVidOutputDeviceImpl<T, LibID, Category, MostDerivedClass>,
    	public IMSVidVRGraphSegmentImpl<T> {
    public:
    IMSVidVideoRendererImpl() 
	{
        m_opacity = -1;
        m_rectPosition.top = -1;
        m_rectPosition.left = -1;
        m_rectPosition.bottom = -1;
        m_rectPosition.right = -1;
        m_SourceSize = sslFullSize;
        m_lOverScan = 1;
	}
    virtual ~IMSVidVideoRendererImpl() {
            m_PQIPicture.Release();
    }
protected:
typedef IMSVidVRGraphSegmentImpl<T> VRSegbasetype;
    PQIPic m_PQIPicture;
    FLOAT m_opacity;
    NORMALIZEDRECT m_rectPosition;
    SourceSizeList m_SourceSize;
    LONG m_lOverScan;
    CScalingRect m_ClipRect;

public:
    virtual HRESULT SetVRConfig() {
        HRESULT hr = S_OK;
        if (m_pVMR) {
            hr = VRSegbasetype::SetVRConfig();
            if (FAILED(hr)) {
                return hr;
            }
            if(m_pVMRWC){
                hr = m_pVMRWC->SetColorKey(m_ColorKey);
            }
            else{
                return ImplReportError(__uuidof(T), IDS_E_NOTWNDLESS, __uuidof(IVMRFilterConfig), E_FAIL);  
            }
            if (FAILED(hr)  && hr != E_NOTIMPL) {
                return hr;
            }
        }
        return NOERROR;
    }

    STDMETHOD(Refresh)() {
        ReComputeSourceRect();
        return VRSegbasetype::Refresh();
    }

// IMSVidVideoRenderer
	STDMETHOD(get_OverScan)(LONG * plPercent)
	{
        if (!m_fInit) {
	        return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
        }
        if (plPercent == NULL) {
			return E_POINTER;
        }
        try {
            *plPercent = m_lOverScan;
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }

	}
	STDMETHOD(put_OverScan)(LONG lPercent)
	{
        if (!m_fInit) {
	        return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
        }
        try {
            if(lPercent > 4900 || lPercent < 0){
                return ImplReportError(__uuidof(T), IDS_INVALID_OVERSCAN, __uuidof(IMSVidVideoRenderer), CO_E_ERRORINAPP);  
            }
            m_lOverScan = lPercent;
            return ReComputeSourceRect();
        } catch(...) {
            return E_UNEXPECTED;
        }
	}

	
    STDMETHOD(get_SourceSize)(/*[out, retval]*/ SourceSizeList *pCurrentSize) {
        if (!m_fInit) {
	        return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
        }
        if (!pCurrentSize) {
			return E_POINTER;
        }
        try {
            *pCurrentSize = m_SourceSize;
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
	}
    // TODO: add checks for input value being null
    STDMETHOD(get_MaxVidRect)(/*[out, retval]*/ IMSVidRect **ppVidRect){ 
        HRESULT hr = S_OK;
        CComQIPtr<IMSVidRect>PQIMSVRect;
        try{
            PQIMSVRect = static_cast<IMSVidRect *>(new CVidRect(0,0,0,0));
            if(!PQIMSVRect){
                throw(E_UNEXPECTED);
            }

            if(!m_pVMR){
                throw(ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED));
            }
            long dwWidth, dwHeight;
            if(m_pVMRWC){
                hr = m_pVMRWC->GetMaxIdealVideoSize(&dwWidth, &dwHeight);
                if(FAILED(hr)){
                    throw(hr);
                }
            }
            else{
                throw(ImplReportError(__uuidof(T), IDS_E_NOTWNDLESS, __uuidof(IVMRFilterConfig), E_FAIL));  
            }
            PQIMSVRect->put_Height(dwHeight);
            PQIMSVRect->put_Width(dwWidth);
        }
        catch(HRESULT hres){
            PQIMSVRect = static_cast<IMSVidRect *>(new CVidRect(-1,-1,-1,-1));
            *ppVidRect = PQIMSVRect.Detach();
            return hres;
        }
        *ppVidRect = PQIMSVRect.Detach();
        return hr;
        
    }
    STDMETHOD(get_MinVidRect)(/*[out, retval]*/ IMSVidRect **ppVidRect){ 
        HRESULT hr = S_OK;
        CComQIPtr<IMSVidRect>PQIMSVRect;
        try{
            PQIMSVRect = static_cast<IMSVidRect *>(new CVidRect(0,0,0,0));
            if(!PQIMSVRect){
                throw(E_UNEXPECTED);
            }
            if(!m_pVMR){
                throw(ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED));
            }
            long dwWidth, dwHeight;
            if(m_pVMRWC){
                hr = m_pVMRWC->GetMinIdealVideoSize(&dwWidth, &dwHeight);
                if(FAILED(hr)){
                    throw(hr);
                }
            }
            else{
                throw(ImplReportError(__uuidof(T), IDS_E_NOTWNDLESS, __uuidof(IMSVidVideoRenderer), E_FAIL));  
            }
            PQIMSVRect->put_Height(dwHeight);
            PQIMSVRect->put_Width(dwWidth);

        }
        catch(HRESULT hres){
            PQIMSVRect = static_cast<IMSVidRect *>(new CVidRect(-1,-1,-1,-1));
            *ppVidRect = PQIMSVRect.Detach();
            return hres;
        }
        *ppVidRect = PQIMSVRect.Detach();
        return hr;
        
    }
    STDMETHOD(put_SourceSize)(/*[in]*/ SourceSizeList NewSize) {
        if (!m_fInit) {
	        return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
        }
        try {
            SourceSizeList prev = m_SourceSize;
            m_SourceSize = NewSize;
            if (m_SourceSize != prev) {
                return ReComputeSourceRect();
            }
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
	}
    STDMETHOD(get_CustomCompositorClass)(/*[out, retval]*/ BSTR *CompositorCLSID) {
        try{
            if(!CompositorCLSID){
                return E_POINTER;
            }
            GUID2 gRetVal;
            HRESULT hr = get__CustomCompositorClass(&gRetVal);
            if(SUCCEEDED(hr)){
                *CompositorCLSID = gRetVal.GetBSTR();
                return S_OK;
            }
        }
        catch(...){
            return E_UNEXPECTED;
        }
		return S_OK;
	}
    STDMETHOD(get__CustomCompositorClass)(/*[out, retval]*/ GUID* CompositorCLSID) {
        HRESULT hr = S_OK;
        try{

            if(!CompositorCLSID){
                return E_POINTER;
            }
            if(m_compositorGuid != GUID_NULL){
                *CompositorCLSID = m_compositorGuid;
                return S_OK;
            }
            PQVMRImageComp pRetVal;
            hr = get__CustomCompositor(&pRetVal);            
            if(FAILED(hr)){
                return hr;
            }
            CComQIPtr<IPersist> ipRet(pRetVal);

            hr = ipRet->GetClassID((CLSID*)CompositorCLSID);
            if(SUCCEEDED(hr)){
                return S_OK;
            }
            else{
                return E_UNEXPECTED;
            }
            
        }
        catch(...){
            return E_UNEXPECTED;
        }
		return S_OK;
	}

    STDMETHOD(put_CustomCompositorClass)(/*[in]*/ BSTR CompositorCLSID) {
        try{
            GUID2 inGuid(CompositorCLSID);
            HRESULT hr = put__CustomCompositorClass(inGuid);
            if(SUCCEEDED(hr)){
                return S_OK;
            }
            else{
                return hr;
            }
        }
        catch(...){
            return E_UNEXPECTED;
        }
        return S_OK;
    }

    STDMETHOD(put__CustomCompositorClass)(/*[in]*/ REFCLSID CompositorCLSID) {
        try{
            CComQIPtr<IVMRImageCompositor>IVMRICPtr;
            IVMRICPtr.Release();
            HRESULT hr = CoCreateInstance( CompositorCLSID, NULL, CLSCTX_INPROC_SERVER, IID_IVMRImageCompositor, (LPVOID*) &IVMRICPtr);
            if(FAILED(hr)){
                return E_UNEXPECTED;
            }
            hr = put__CustomCompositor(IVMRICPtr);
            if(FAILED(hr)){
                return hr;
            }
            else{
                return S_OK;
            }
        }
        catch(...){
            return E_UNEXPECTED;
        }
        return S_OK;
	}

    STDMETHOD(get__CustomCompositor)(/*[out, retval]*/ IVMRImageCompositor** Compositor) {
        try{
            if(!Compositor){
                return E_POINTER;
            }
            if(!ImCompositor){
                return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);;
            }
            else{
                *Compositor = ImCompositor;
                return S_OK;
            }  
        }
        catch(...){
            return E_UNEXPECTED;
        }
		return S_OK;
	}

    STDMETHOD(put__CustomCompositor)(/*[in]*/ IVMRImageCompositor* Compositor) {
        try{
            if(!Compositor){
                return E_POINTER;
            }
            ImCompositor = Compositor;
            HRESULT hr = CleanupVMR();
            if(FAILED(hr)){
                return hr;
            }
        }
        catch(...){
            return E_UNEXPECTED;
        }
        return S_OK;
        
    }

    STDMETHOD(get_AvailableSourceRect)(IMSVidRect **ppVidRect) {
        CComQIPtr<IMSVidRect>PQIMSVRect =  static_cast<IMSVidRect *>(new CVidRect(0,0,0,0));
        try{
            if(!ppVidRect){
                return E_POINTER;
            }
            SIZE Size, Ar;
            HRESULT hr = get_NativeSize(&Size, &Ar);
            hr = PQIMSVRect->put_Height(Size.cy);
            if(FAILED(hr)){
                throw(hr);
            }
            hr = PQIMSVRect->put_Width(Size.cx);
            if(FAILED(hr)){
                throw(hr);
            }
        }
        catch(...){
            return E_UNEXPECTED;
        }
        *ppVidRect = PQIMSVRect.Detach();
        return S_OK;
    }

    STDMETHOD(put_ClippedSourceRect)(IMSVidRect *pVidRect) {
        if (!m_fInit) {
	        return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
        }
        if (!pVidRect) {
            return E_POINTER;
        }
        try {
            m_ClipRect = *(static_cast<CScalingRect*>(static_cast<CVidRect*>(pVidRect)));
            return ReComputeSourceRect();
        } catch(...) {
            return E_UNEXPECTED;
        }
	}

    STDMETHOD(get_ClippedSourceRect)(IMSVidRect **ppVidRect) {
        if (!m_fInit) {
	        return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
        }
        if (!ppVidRect) {
			return E_POINTER;
        }
        try {
            CComQIPtr<IMSVidRect>PQIMSVRect = static_cast<IMSVidRect *>(new CVidRect(-1,-1,-1,-1));
            PQIMSVRect->put_Left(m_ClipRect.left);
            PQIMSVRect->put_Height(m_ClipRect.bottom - m_ClipRect.top);
            PQIMSVRect->put_Top(m_ClipRect.top);
            PQIMSVRect->put_Width(m_ClipRect.right - m_ClipRect.left);            
            *ppVidRect = PQIMSVRect.Detach();
            return S_OK;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }
/*************************************************************************/
/* Function:    Capture                                                  */
/* Description: Returns the current image on screen                      */
/*************************************************************************/
 
STDMETHOD(Capture)(IPictureDisp **currentImage){
        HBITMAP hBitmap = 0;
        HPALETTE hPalette = 0;
        //VMRALPHABITMAP vmrAlphaBitmapStruct;
        CComQIPtr<IPicture> retPicture;
        PICTDESC PictDescStruct;
        HRESULT hr = S_OK;
        BYTE *lpDIB = NULL;
        try{
            if(!currentImage){
                throw(E_POINTER);
            }
            if(!m_pVMR){
                throw(E_FAIL);
            }
            if(m_pVMRWC){
                hr = m_pVMRWC->GetCurrentImage(&lpDIB);
            }
            else{
                throw(ImplReportError(__uuidof(T), IDS_E_NOTWNDLESS, __uuidof(IMSVidVideoRenderer), E_FAIL));  
            }
            if(FAILED(hr)){
                throw(hr);
            }
            HDC     curDC   = GetDC(NULL);
            UINT    wUsage  = DIB_RGB_COLORS;
            DWORD   dwFlags = CBM_INIT;
            hBitmap = CreateDIBitmap(curDC,
                reinterpret_cast<BITMAPINFOHEADER*>(lpDIB), dwFlags,
                reinterpret_cast<void *>((LPBYTE)(lpDIB) + (int)(reinterpret_cast<BITMAPINFOHEADER*>(lpDIB)->biSize)),
                reinterpret_cast<BITMAPINFO*>(lpDIB),
                wUsage);
            
            
            ReleaseDC(NULL,curDC);
            ZeroMemory(&PictDescStruct, sizeof(PictDescStruct));
            PictDescStruct.bmp.hbitmap = hBitmap;
            PictDescStruct.bmp.hpal = NULL;
            PictDescStruct.picType = PICTYPE_BITMAP; 
            PictDescStruct.cbSizeofstruct = sizeof(PictDescStruct);
            hr = OleCreatePictureIndirect(&PictDescStruct, IID_IPicture, TRUE, (void **)&retPicture);
            if(SUCCEEDED(hr)){
                hr = retPicture.QueryInterface(reinterpret_cast<IPictureDisp**>(currentImage));
                return hr;
            }
            else{
                throw(hr);
            }
            

        }
        catch(HRESULT hres){
            hr = hres;
        }
        catch(...){
            hr = E_UNEXPECTED;
        }
        if(lpDIB){
            CoTaskMemFree(lpDIB);
        }
        return hr;
}
/*************************************************************************/
/* Function:    get_MixerBitmap                                          */
/* Description: Returns the current alpha bitmap to script wrapped in a  */
/*              IPictureDisp.                                            */
/*************************************************************************/
    STDMETHOD(get_MixerBitmap)(/*[out,retval]*/ IPictureDisp** ppIPDisp){
#if 0
        HDC *pHDC = NULL; 
        HBITMAP hBitmap = 0;
        HPALETTE hPalette = 0;
        VMRALPHABITMAP vmrAlphaBitmapStruct;
        PQIPicDisp retPicture;
        CComQIPtr<IVMRMixerBitmap> PQIVMRMixerBitmap;
        PICTDESC PictDescStruct;
        try{
            HRESULT hr = get__MixerBitmap(&PQIVMRMixerBitmap);
            if(FAILED(hr)){
                return hr; 
            }
            hr = PQIVMRMixerBitmap->GetAlphaBitmapParameters(&vmrAlphaBitmapStruct);
            if(FAILED(hr)){
                return hr; 
            }
            hr = vmrAlphaBitmapStruct.pDDS->GetDC(pHDC); 
            if(FAILED(hr)){
                return hr;
            }
            hBitmap = static_cast<HBITMAP>(GetCurrentObject(*pHDC, OBJ_BITMAP));
            if(!hBitmap){ 
                return hr;
            }
            hPalette = static_cast<HPALETTE>(GetCurrentObject(*pHDC, OBJ_PAL)); 
            if(!hPalette){
                return hr ;
            }
            PictDescStruct.bmp.hbitmap = hBitmap;
            PictDescStruct.bmp.hpal = hPalette;
            PictDescStruct.picType = PICTYPE_BITMAP; 
            PictDescStruct.cbSizeofstruct = sizeof(PictDescStruct.bmp);
            hr = OleCreatePictureIndirect(&PictDescStruct, IID_IPictureDisp, true, reinterpret_cast<void**> (&retPicture));
            if(FAILED(hr)){
                return hr;
            }
        }
        catch(HRESULT hr){
            return hr;
        }
        catch(...){
            return E_FAIL;
        }
        ppIPDisp = &retPicture.Detach(); 
        return S_OK;
#endif    
        // If m_PQIPicture is set, return it
        try{
            if(m_PQIPicture){
                CComQIPtr<IPictureDisp> PQIPDisp(m_PQIPicture);
                *ppIPDisp = PQIPDisp.Detach();
                throw S_OK;
            }
            else{
                throw ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
            }

        }
        catch(HRESULT hres){
            return hres;
        }
        catch(...){
            return E_UNEXPECTED;
        }
        
    }
    
    /*************************************************************************/
    /* Function:    get__MixerBitmap                                         */
    /* Description: Returns the IVMRMixerBitmap from the VMR                 */
    /*************************************************************************/
    STDMETHOD(get__MixerBitmap)(/*[out, retval]*/ IVMRMixerBitmap ** ppIVMRMBitmap){
        try{
            if(!ppIVMRMBitmap){
                return E_POINTER;
            }
            // Make sure there is a VMR filter init'ed
            if(!m_pVMR){
                return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
            }
            CComQIPtr<IVMRMixerBitmap> PQIVMRMBitmap(m_pVMR);
            *ppIVMRMBitmap = PQIVMRMBitmap.Detach();
        }
        catch(HRESULT hr){
            return hr;
        }
        catch(...){
            return E_UNEXPECTED;
        }
        return S_OK;
    }
    /*************************************************************************/
    /* Function:    put_MixerBitmap                                          */
    /* Description: Updates the current VMR Alpha Bitmap                     */
    /*              uses SutupMixerBitmap helper function                    */
    /*************************************************************************/    
    STDMETHOD(put_MixerBitmap)(/*[in*/  IPictureDisp* pIPDisp){ 
        try{
            return SetupMixerBitmap(pIPDisp);
        }
        catch(HRESULT hr){
            return hr;
        }
        catch(...){
            return E_UNEXPECTED;
        }
    }

    /*************************************************************************/
    /* Function:    put__MixerBitmap                                         */
    /* Description: Updates the current VMR Alpha Bitmap                     */
    /*              directly using the VMR fucntions                         */
    /*************************************************************************/    
    STDMETHOD(put__MixerBitmap)(/*[in]*/ VMRALPHABITMAP * pVMRAlphaBitmapStruct){ //pMixerPicture
        try{
            HRESULT hr = S_OK;
            if(!pVMRAlphaBitmapStruct){
                return E_POINTER;   
            }
            // Make sure there is a vmr to add the bitmap to
            if(!m_pVMR){
                return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
            }
            // Querry the vmr for the MixerBitmap Interface
            CComQIPtr<IVMRMixerBitmap> pVMRMBitmap(m_pVMR);
            if (!pVMRMBitmap) {
                return E_UNEXPECTED;
            }
            // Set the mixer bitmap to pVMRAlphaBitmapStruct
            hr = pVMRMBitmap->SetAlphaBitmap(pVMRAlphaBitmapStruct);
            return hr;
        }
        catch(HRESULT hr){
            return hr;
        }
        catch(...){
            return E_UNEXPECTED;
        }
    }
    
    /**************************************************************************/
    /* Function:    get_MixerBitmapPositionRect                               */
    /* Description: Lets script folk access the position of the overlay bitmap*/
    /*              the units are normalized vs the display rect so the values*/
    /*              should be between 0 and 1 though will be converted if they*/
    /*              are not                                                   */
    /**************************************************************************/   
    STDMETHOD(get_MixerBitmapPositionRect)(/*[out,retval]*/IMSVidRect **ppIMSVRect){
        HRESULT hr = S_OK;
        CComQIPtr<IMSVidRect>PQIMSVRect;
        try{
            CComQIPtr<IVMRMixerBitmap> PQIVMRMBitmap;
            PQIMSVRect = static_cast<IMSVidRect *>(new CVidRect(-1,-1,-1,-1));
            VMRALPHABITMAP VMRAlphaBitmap;
            if(!m_pVMR){
                hr = S_FALSE;
                throw(hr);
            }
            hr = get__MixerBitmap(&PQIVMRMBitmap);
            // If the VMRBitmap is not set on the VRM, if it is not make sure that the local one is set
            if(SUCCEEDED(hr) ){    
                // QI for the Parameters
                hr = PQIVMRMBitmap->GetAlphaBitmapParameters(&VMRAlphaBitmap);
                // if it fails or they are not set make sure that the local copy is
                if(SUCCEEDED(hr)){
                    // Make sure that the rDest points are valid top and left : [0,1)
                    // and right and bottom (0,1]
                    if(VMRAlphaBitmap.rDest.top >= 0   && VMRAlphaBitmap.rDest.left >= 0   && 
                        VMRAlphaBitmap.rDest.top < 1    && VMRAlphaBitmap.rDest.left < 1    &&
                        VMRAlphaBitmap.rDest.right <= 1 && VMRAlphaBitmap.rDest.bottom <= 1 &&
                        VMRAlphaBitmap.rDest.right > 0 && VMRAlphaBitmap.rDest.bottom > 0){
                        // Make sure the local copy of the normalized rect is upto date
                        m_rectPosition = VMRAlphaBitmap.rDest;           
                    }
                }
            }
            if( m_rectPosition.left < 0 || m_rectPosition.top < 0 || 
                m_rectPosition.right < 0 || m_rectPosition.bottom < 0 ){ 
                hr = S_FALSE;
                throw(hr);
            }
            else{
                // Convert and copy the values in the local copy of the normalized rect to the return rect
                hr = PQIMSVRect->put_Top(static_cast<long> (m_rectPosition.top * m_rectDest.Height()));
                if(FAILED(hr)){
                    hr = ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
                    throw(hr);
                }
                // bottom * height - top
                hr = PQIMSVRect->put_Height(static_cast<long>((m_rectPosition.bottom * m_rectDest.Height())
                    - (m_rectPosition.top * m_rectDest.Height())));
                if(FAILED(hr)){
                    hr = ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
                    throw(hr);
                }            
                // right * width - left
                hr = PQIMSVRect->put_Width(static_cast<long>(m_rectPosition.right * m_rectDest.Width() 
                    - (m_rectPosition.left * m_rectDest.Width())));
                if(FAILED(hr)){
                    hr = ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
                    throw(hr);
                }
                hr = PQIMSVRect->put_Left(static_cast<long>(m_rectPosition.left * m_rectDest.Width()));
                if(FAILED(hr)){
                    hr = ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
                    throw(hr);
                }
            }
            *ppIMSVRect = PQIMSVRect.Detach();
            return S_OK;
        }
        catch(HRESULT hres){
            if(FAILED(hres)){
                return hres;
            }
            if(m_rectDest){
                PQIMSVRect.Release();
                PQIMSVRect = static_cast<IMSVidRect *>(new CVidRect(m_rectDest));
            }
            else{
                PQIMSVRect.Release();
                PQIMSVRect = static_cast<IMSVidRect *>(new CVidRect(-1,-1,-1,-1));
            }
            *ppIMSVRect = PQIMSVRect.Detach();                    
            return S_FALSE;
        }
        catch(...){
            return E_UNEXPECTED;
        }
    }

    /**************************************************************************/
    /* Function:    put_MixerBitmapPositionRect                               */
    /* Description: Lets script folk change the position of the overlay bitmap*/
    /*              the units are normalized vs the display rect so the values*/
    /*              should be between 0 and 1 though will be converted if they*/
    /*              are not                                                   */
    /**************************************************************************/       
    STDMETHOD(put_MixerBitmapPositionRect)(/*[in]*/ IMSVidRect *pIMSVRect){ 

        if(pIMSVRect){
            NORMALIZEDRECT NormalizedRectStruct;
            long lValue;
            NormalizedRectStruct.left = -1.f;
            NormalizedRectStruct.top = -1.f;
            NormalizedRectStruct.right = -1.f;
            NormalizedRectStruct.bottom = -1.f;
            if(SUCCEEDED(pIMSVRect->get_Left(&lValue))){
                if(m_rectDest.Width() != 0){
                    // check m_rectDest.Width() for zero
                    if(lValue > 0){
                        NormalizedRectStruct.left = 
                            static_cast<float>(lValue)/static_cast<float>(m_rectDest.Width());
                    }
                    else{
                        NormalizedRectStruct.left = static_cast<float>(lValue); 
                    }
                }
            }
            if(SUCCEEDED(pIMSVRect->get_Top(&lValue))){
                if(m_rectDest.Height() != 0){
                    if(lValue > 0){
                        NormalizedRectStruct.top = 
                            static_cast<float>(lValue)/static_cast<float>(m_rectDest.Height());
                    }
                    else{
                        NormalizedRectStruct.top = static_cast<float>(lValue);
                    }
                }
            }
            if(SUCCEEDED(pIMSVRect->get_Width(&lValue))){
                if(m_rectDest.Width() != 0){      
                    if(lValue > 0){
                        NormalizedRectStruct.right = 
                            (static_cast<float>(lValue)/static_cast<float>(m_rectDest.Width())) 
                            + static_cast<float>(NormalizedRectStruct.left);
                    }
                }
            }
            if(SUCCEEDED(pIMSVRect->get_Height(&lValue))){
                if(m_rectDest.Width() != 0){
                    if(lValue > 0){
                        NormalizedRectStruct.bottom = 
                            (static_cast<float>(lValue)/static_cast<float>(m_rectDest.Height())) 
                            + static_cast<float>(NormalizedRectStruct.top);
                    }
                }
            }
            if(NormalizedRectStruct.top < 0 || NormalizedRectStruct.left < 0 || 
                NormalizedRectStruct.top > 1 || NormalizedRectStruct.left > 1 || 
                NormalizedRectStruct.right < 0 || NormalizedRectStruct.bottom < 0 || 
                NormalizedRectStruct.right > 1 || NormalizedRectStruct.bottom > 1){
                return ImplReportError(__uuidof(T), IDS_E_MIXERSRC, __uuidof(IMSVidVideoRenderer), CO_E_ERRORINAPP);
            }
            m_rectPosition = NormalizedRectStruct;
        }
        if(m_PQIPicture == NULL){
            return S_OK;
        }
        else{
            return SetupMixerBitmap(reinterpret_cast<IPictureDisp*>(-1));
        }
    }
    /**************************************************************************/
    /* Function:    get_MixerBitmapOpacity                                    */
    /* Description: lets script access the opacity value                      */
    /*              should be between 0 and 100 (%)                           */
    /**************************************************************************/    
    STDMETHOD(get_MixerBitmapOpacity)(/*[out,retval]*/ int *pwOpacity){
        CComQIPtr<IVMRMixerBitmap> PQIVMRMBitmap;
        VMRALPHABITMAP VMRAlphaBitmapStruct;
        HRESULT hr = get__MixerBitmap(&PQIVMRMBitmap);
        if(SUCCEEDED(hr)){
            hr = PQIVMRMBitmap->GetAlphaBitmapParameters(&VMRAlphaBitmapStruct);
            if(SUCCEEDED(hr)){    
                if(m_opacity != VMRAlphaBitmapStruct.fAlpha){
                    m_opacity = VMRAlphaBitmapStruct.fAlpha;
                }
            }
        }
        if(m_opacity == -1){ 
            return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED);
        }
        if(m_opacity > 1 || m_opacity < 0){
            return E_UNEXPECTED;
        }
        *pwOpacity = static_cast<int>(m_opacity*100);
        return S_OK;
    }
    /**************************************************************************/
    /* Function:    put_MixerBitmapOpacity                                    */
    /* Description: lets script set the value opacity                         */
    /*              should be between 0 and 100 (%)                           */
    /**************************************************************************/     
    STDMETHOD(put_MixerBitmapOpacity)(/*[in]*/ int wOpacity){
        // make sure the value is between 0 and 100
        if(wOpacity >=0 && wOpacity <= 100){
            if(wOpacity == 0){
                //if it is 0 set it by hand instead of deviding by 0
                m_opacity = static_cast<float>(wOpacity);
            }
            m_opacity = static_cast<float>(wOpacity)/100.f;
        }
        else{
            return ImplReportError(__uuidof(T), IDS_E_OPACITY, __uuidof(IMSVidVideoRenderer), CO_E_ERRORINAPP);
        }
        if(!m_PQIPicture){
            return S_OK;
        }
        else{
            HRESULT hr = SetupMixerBitmap(reinterpret_cast<IPictureDisp*>(-1));
            return hr;
        }
    }
    /**************************************************************************/
    /* Function:    SetupMixerBitmap                                          */
    /* Description: big nasty function to set bitmap, opacity and the position*/
    /*              rect. It wraps everyting up in a mixer bitmap struct and  */
    /*              then passes it off to put__MixerBitmap                    */
    /*              It is both a helper function and a automation method so   */
    /*              that script people can make sure that transparent overlays*/
    /*              dont show up opaque for a few frames                      */
    /*                  for reference the vmralphabitmap struct               */
    /* typedef struct _VMRALPHABITMAP {                                       */
    /*  DWORD                   dwFlags;// flags word = VMRBITMAP_HDC         */
    /*  HDC                     hdc;    // DC for the bitmap to copy          */
    /*  LPDIRECTDRAWSURFACE7    pDDS;   // DirectDraw surface to copy IGNORED */
    /*  RECT                    rSrc;   // rectangle to copy from the sourceR */
    /*  NORMALIZEDRECT          rDest;  // output rectangle in composition space*/
    /*  FLOAT	            fAlpha;     // opacity of the bitmap              */
    /*  } VMRALPHABITMAP, *PVMRALPHABITMAP;                                   */
    /**************************************************************************/ 
    STDMETHOD(SetupMixerBitmap)(/*[in]*/ IPictureDisp* pIPDisp = NULL, /*[in]*/ long wOpacity = -1, 
        /*[in]*/ IMSVidRect *pIMSVRect = NULL){
        VMRALPHABITMAP VMRAlphaBitmapStruct;
        ZeroMemory(&VMRAlphaBitmapStruct, sizeof(VMRALPHABITMAP));

        RECT rSource;
        ZeroMemory(&rSource, sizeof(RECT));
        
        long lPicHeight, lPicWidth;
        
        HRESULT hr = S_OK;
        
        try{
            if(!pIPDisp){
				if(m_PQIPicture){
					m_PQIPicture.Release();
				}
                VMRAlphaBitmapStruct.dwFlags = VMRBITMAP_DISABLE;
                return hr = put__MixerBitmap(&VMRAlphaBitmapStruct);
            }
            // Our input is a IPictureDisp which we need to massage into a VMRALPHABITMAP
            // Problem is that it does not quite all go in but what does we will keep and pass on up
			
			if(pIPDisp == reinterpret_cast<IPictureDisp*>(-1)){
				CComQIPtr<IPicture>PQIPicture(m_PQIPicture); 
                if(!PQIPicture){
                    return S_OK;
                }
			} 
			else if(pIPDisp){
                // QI for a IPicture
                CComQIPtr<IPicture>PQIPicture(pIPDisp); 
                if(!PQIPicture){
                    return E_NOINTERFACE;
                }
                // Save the IPicture for possible use later
                m_PQIPicture = PQIPicture;
            }

            // Get the source rect size (and for some reason ole returns the size 
            // in tenths of a millimeter so I need to convert it)
            short shortType;
            m_PQIPicture->get_Type(&shortType);
            if(shortType != PICTYPE_BITMAP){
                return ImplReportError(__uuidof(T), IDS_E_MIXERBADFORMAT, __uuidof(IMSVidVideoRenderer), E_INVALIDARG); // Need to add a the is not a valid picture string 
            }
            hr = m_PQIPicture->get_Height(&lPicHeight);
            if(FAILED(hr)){
                return ImplReportError(__uuidof(T), IDS_E_IPICTURE, __uuidof(IMSVidVideoRenderer), CO_E_ERRORINAPP);
            }
            hr = m_PQIPicture->get_Width(&lPicWidth);
            if(FAILED(hr)){
                return ImplReportError(__uuidof(T), IDS_E_IPICTURE, __uuidof(IMSVidVideoRenderer), CO_E_ERRORINAPP);
            }
            SIZEL x, y; 
            AtlHiMetricToPixel((const SIZEL*)&lPicWidth, &(x));
            AtlHiMetricToPixel((const SIZEL*)&lPicHeight, &(y));
            // The AtlHiMetricToPixel function returns a size with the cx value set (no idea why)
            rSource.right = x.cx;
            rSource.bottom = y.cx;
            

            // create a hdc to store the bitmap
            HDC memHDC = CreateCompatibleDC(NULL);
            
            // create a bitmap to store in the hdc
            HBITMAP memHBIT = 0; 

            // pull out the bitmap from the IlPicture
            hr = m_PQIPicture->get_Handle(reinterpret_cast<OLE_HANDLE*>(&memHBIT));
            if(FAILED(hr)){
                return ImplReportError(__uuidof(T), IDS_E_IPICTURE, __uuidof(IMSVidVideoRenderer), CO_E_ERRORINAPP);
            }

            // Stuff the bitmap into a hdc and keep handle to delete bitmap later
            HBITMAP delHBIT = static_cast<HBITMAP>(SelectObject(memHDC, memHBIT));

            // Put all of the collected info into a VMRBITMAP stuct and pass it on
            VMRAlphaBitmapStruct.rSrc = rSource;
            VMRAlphaBitmapStruct.hdc = memHDC;
            VMRAlphaBitmapStruct.dwFlags = VMRBITMAP_HDC;
            
            // If the wOpacity value is valid use it
            if(wOpacity >=0 && wOpacity <= 100){
                if(wOpacity == 0){
                    m_opacity = wOpacity;
                }
                m_opacity = static_cast<float>(wOpacity/100.f);
                VMRAlphaBitmapStruct.fAlpha = static_cast<float>(m_opacity);
            }
            // wOpacity is not set so check other values
            // if m_opacity is set use it, if not default to 50% (.5)
            else if (wOpacity == -1){
                if(m_opacity < 0){
                    VMRAlphaBitmapStruct.fAlpha = .5f;
                }
                else{
                    VMRAlphaBitmapStruct.fAlpha = m_opacity;
                }
            } 
            // Bad wOpacity value give them an error
            else{
                return ImplReportError(__uuidof(T), IDS_E_OPACITY, __uuidof(IMSVidVideoRenderer), CO_E_ERRORINAPP);
            }
            // If the m_rectPostion is set use it, else default to full screen 
            if(pIMSVRect){
                NORMALIZEDRECT NormalizedRectStruct;
                long lValue;
                NormalizedRectStruct.left = -1.f;
                NormalizedRectStruct.top = -1.f;
                NormalizedRectStruct.right = -1.f;
                NormalizedRectStruct.bottom = -1.f;
                if(SUCCEEDED(pIMSVRect->get_Left(&lValue))){
                    if(m_rectDest.Width() != 0){
                        // check m_rectDest.Width() for zero
                        if(lValue > 0){
                            NormalizedRectStruct.left = 
                                static_cast<float>(lValue)/static_cast<float>(m_rectDest.Width());
                        }
                        else{
                            NormalizedRectStruct.left = static_cast<float>(lValue); 
                        }
                    }
                }
                if(SUCCEEDED(pIMSVRect->get_Top(&lValue))){
                    if(m_rectDest.Height() != 0){
                        if(lValue > 0){
                            NormalizedRectStruct.top = 
                                static_cast<float>(lValue)/static_cast<float>(m_rectDest.Height());
                        }
                        else{
                            NormalizedRectStruct.top = static_cast<float>(lValue);
                        }
                    }
                }
                if(SUCCEEDED(pIMSVRect->get_Width(&lValue))){
                    if(m_rectDest.Width() != 0){      
                        if(lValue > 0){
                            NormalizedRectStruct.right = 
                                (static_cast<float>(lValue)/static_cast<float>(m_rectDest.Width())) 
                                + static_cast<float>(NormalizedRectStruct.left);
                        }
                    }
                }
                if(SUCCEEDED(pIMSVRect->get_Height(&lValue))){
                    if(m_rectDest.Width() != 0){
                        if(lValue > 0){
                            NormalizedRectStruct.bottom = 
                                (static_cast<float>(lValue)/static_cast<float>(m_rectDest.Height())) 
                                + static_cast<float>(NormalizedRectStruct.top);
                        }
                    }
                }
                if(NormalizedRectStruct.top < 0 || NormalizedRectStruct.left < 0 || 
                    NormalizedRectStruct.top > 1 || NormalizedRectStruct.left > 1 || 
                    NormalizedRectStruct.right < 0 || NormalizedRectStruct.bottom < 0 || 
                    NormalizedRectStruct.right > 1 || NormalizedRectStruct.bottom > 1){
                    return ImplReportError(__uuidof(T), IDS_E_MIXERSRC, __uuidof(IMSVidVideoRenderer), CO_E_ERRORINAPP);
                }
                m_rectPosition = NormalizedRectStruct;
                VMRAlphaBitmapStruct.rDest = m_rectPosition;
            }
            else{
                if( m_rectPosition.left < 0 || m_rectPosition.top < 0 || m_rectPosition.right < 0 || m_rectPosition.bottom < 0 ){
                    VMRAlphaBitmapStruct.rDest.left = 0.f;
                    VMRAlphaBitmapStruct.rDest.top = 0.f;
                    VMRAlphaBitmapStruct.rDest.right = 1.f;
                    VMRAlphaBitmapStruct.rDest.bottom = 1.f;
                }
                else{
                    VMRAlphaBitmapStruct.rDest = m_rectPosition;
                }
            }
            // If it is all valid then this is all good
            hr = put__MixerBitmap(&VMRAlphaBitmapStruct);

            if(!DeleteDC(memHDC)){
                return ImplReportError(__uuidof(T), IDS_E_CANT_DELETE, __uuidof(IMSVidVideoRenderer), ERROR_DS_CANT_DELETE);
            }
            if(SUCCEEDED(hr)){
                return S_OK;
            }
            else{
                return hr;
            }
        }
        catch(...){
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(get_UsingOverlay)(/*[out, retval]*/ VARIANT_BOOL *pfUseOverlay) {
        return get_UseOverlay(pfUseOverlay);
    }
    STDMETHOD(put_UsingOverlay)(/*[in]*/ VARIANT_BOOL fUseOverlayVal) {
        return put_UseOverlay(fUseOverlayVal);
    }
    STDMETHOD(get_FramesPerSecond)(/*[out, retval]*/ long *pVal){
        try{
            if(pVal){
                if(!m_pVMR){
                    throw(ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED));
                }
                IQualProp *IQProp = NULL;
                HRESULT hr = m_pVMR->QueryInterface(IID_IQualProp, reinterpret_cast<void**>(&IQProp));
                if(FAILED(hr)){
                    return hr;
                } 
                if(!IQProp){
                    return E_NOINTERFACE;
                }
                hr = IQProp->get_AvgFrameRate(reinterpret_cast<int*>(pVal));
                IQProp->Release();
                return hr;
            }
            else{
                return E_POINTER;
            }
        }
        catch(...){
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(put_DecimateInput)(/*[in]*/ VARIANT_BOOL bDeci){
        try{
            if(bDeci != VARIANT_TRUE && bDeci != VARIANT_FALSE){
                return E_INVALIDARG;
            }
            m_Decimate = (bDeci == VARIANT_TRUE);
            if(!m_pVMR){
                return S_OK;
            }
            DWORD curPrefs;
            DWORD deci;
            CComQIPtr<IVMRMixerControl>PQIVMRMixer(m_pVMR);
            if(!PQIVMRMixer){
                return E_UNEXPECTED;
            }
            HRESULT hr = PQIVMRMixer->GetMixingPrefs(&curPrefs);
            if(FAILED(hr)){
                return hr;
            }
            deci = (m_Decimate?MixerPref_DecimateOutput:MixerPref_NoDecimation);
            if(!(curPrefs&deci)){
                hr = CleanupVMR();
                if(FAILED(hr)){
                    return hr;
                }
            }
            return NOERROR;
        }
        catch(...){
            return E_UNEXPECTED;
        }

    }

    STDMETHOD(get_DecimateInput)(/*[out,retval]*/ VARIANT_BOOL *pDeci){
        try{
            if(!pDeci){
                return E_POINTER;
            }
            if(!m_pVMR){
                throw(ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVideoRenderer), CO_E_NOTINITIALIZED));
            }
            DWORD curPrefs;
            CComQIPtr<IVMRMixerControl>PQIVMRMixer(m_pVMR);
            if(!PQIVMRMixer){
                return E_UNEXPECTED;
            }
            HRESULT hr = PQIVMRMixer->GetMixingPrefs(&curPrefs);
            if(FAILED(hr)){
                return hr;
            }
            *pDeci = ((curPrefs&MixerPref_DecimateMask)==MixerPref_DecimateOutput)? VARIANT_TRUE : VARIANT_FALSE;
            return NOERROR;
        }
        catch(...){
            return E_UNEXPECTED;
        }

    }

    STDMETHOD(ReComputeSourceRect)() {
        switch (m_SourceSize) {
    case sslFullSize: {
        CSize sz;
        CSize ar;
        if(m_pVMRWC){
            HRESULT hr = m_pVMRWC->GetNativeVideoSize(&sz.cx, &sz.cy, &ar.cx, &ar.cy);
            if (FAILED(hr)) {
                return hr;
            }
            TRACELSM(TRACE_PAINT, (dbgDump << "CMSVidVideoRenderer::ReComputeSourceRect() sslFullSize vmr sz = " << sz), "");
        }
        CRect r(0, 0, sz.cx, sz.cy);
        TRACELSM(TRACE_DETAIL, (dbgDump << "CMSVidVideoRenderer::ReComputeSource() full = " << r), "");
        return put_Source(r);
                      } break;
    case sslClipByOverScan: {
        CSize sz;
        CSize ar;
        if(m_pVMRWC){
            HRESULT hr = m_pVMRWC->GetNativeVideoSize(&sz.cx, &sz.cy, &ar.cx, &ar.cy);
            if (FAILED(hr)) {
                return hr;
            }
            TRACELSM(TRACE_PAINT, (dbgDump << "CMSVidVideoRenderer::ReComputeSourceRect() sslClipByOverScan vmr sz = " << sz), "");
        }
        CRect r(0, 0, sz.cx, sz.cy);
        CRect r2;
        float fpct = m_lOverScan / 10000.0; // overscan is in hundredths of pct, i.e 1.75% == 175
        long wcrop = (long)(r.Width() * fpct + 0.5);
        long hcrop = (long)(r.Height() * fpct + 0.5);
        r2.left = 0 + wcrop;
        r2.top = 0 + hcrop;
        r2.right = r2.left + r.Width() - (2.0 * wcrop);
        r2.bottom = r2.top + r.Height() - (2.0 * hcrop);
        TRACELSM(TRACE_DETAIL, (dbgDump << "CMSVidVideoRenderer::ReComputeSource() over = " << m_lOverScan <<
            " w " << wcrop <<
            " h " << hcrop), "");
        TRACELSM(TRACE_DETAIL, (dbgDump << "CMSVidVideoRenderer::ReComputeSource() full = " << r << " clip = " << r2), "");

        return put_Source(r2);
                            } break;
    case sslClipByClipRect: {
        TRACELSM(TRACE_DETAIL, (dbgDump << "CMSVidVideoRenderer::ReComputeSource() cliprect = " << m_ClipRect), "");
        if(m_ClipRect.Width() == 0 && m_ClipRect.Height() == 0){
            CSize sz;
            CSize ar;
            if(m_pVMRWC){
                HRESULT hr = m_pVMRWC->GetNativeVideoSize(&sz.cx, &sz.cy, &ar.cx, &ar.cy);
                if (FAILED(hr)) {
                    return hr;
                }

                TRACELSM(TRACE_PAINT, (dbgDump << "CMSVidVideoRenderer::ReComputeSourceRect() sslClipByClipRect vmr sz = " << sz), "");
            }
            CRect r(0, 0, sz.cx, sz.cy);
            TRACELSM(TRACE_DETAIL, (dbgDump << "CMSVidVideoRenderer::ReComputeSource() full = " << r), "");
            return put_Source(r);   
        } else{
            TRACELSM(TRACE_PAINT, (dbgDump << "CMSVidVideoRenderer::ReComputeSourceRect() sslClipByClipRect cliprect = " << m_ClipRect), "");
            return put_Source(m_ClipRect);
        }
                            } break;
    default:{
        return E_INVALIDARG;
            } break;
        }

        return NOERROR;
    }
};
#endif //__MSVidVIDEORENDERER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\vidrect.h ===
//==========================================================================;
//
// vidrect.h : automation compliant auto-scaling gdi rect object
// Copyright (c) Microsoft Corporation 2000.
//
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef VIDRECT_H
#define VIDRECT_H

#include <scalingrect.h>
#include <segment.h>
#include <dsextend.h>
#include <objectwithsiteimplsec.h>

#define INVALID_HWND_VALUE   (reinterpret_cast<HWND>(INVALID_HANDLE_VALUE))

namespace MSVideoControl {

typedef CComQIPtr<IMSVidRect, &__uuidof(IMSVidRect)> PQVidRect;


class ATL_NO_VTABLE __declspec(uuid("CB4276E6-7D5F-4cf1-9727-629C5E6DB6AE")) CVidRectBase : 
    public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CVidRectBase, &__uuidof(CVidRectBase)>,
	public CScalingRect,
    public IObjectWithSiteImplSec<CVidRectBase>,
	public IDispatchImpl<IMSVidRect, &__uuidof(IMSVidRect)>,
    public IObjectSafetyImpl<CVidRectBase, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>,
	public IPersistPropertyBagImpl<CVidRectBase>
{
BEGIN_COM_MAP(CVidRectBase)
	COM_INTERFACE_ENTRY(IMSVidRect)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
END_COM_MAP()
DECLARE_PROTECT_FINAL_CONSTRUCT()
REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_VIDRECT_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CVidRectBase));

	BEGIN_CATEGORY_MAP(CMSVidBDATuner)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

    bool m_bRequiresSave;
    BEGIN_PROP_MAP(CVidRectBase)
        PROP_DATA_ENTRY("Top", top, VT_I4)
        PROP_DATA_ENTRY("Left", left, VT_I4)
        PROP_DATA_ENTRY("Right", right, VT_I4)
        PROP_DATA_ENTRY("Bottom", bottom, VT_I4)
    END_PROPERTY_MAP()

    CVidRectBase(const CRect& ri, HWND hwndi = INVALID_HWND_VALUE) {
		CScalingRect::CScalingRect(ri, hwndi);
	}
    CVidRectBase(const CScalingRect& ri, HWND hwndi = INVALID_HWND_VALUE) {
		CScalingRect::CScalingRect(ri, hwndi);
	}
	CVidRectBase(LONG l, LONG t, LONG r, LONG b, HWND hwndi = INVALID_HWND_VALUE) {
		CScalingRect::CScalingRect(l, t, r, b, hwndi);
	}
	CVidRectBase(const RECT& srcRect, HWND hwndi = INVALID_HWND_VALUE) {
		CScalingRect::CScalingRect(srcRect, hwndi);
	}
	CVidRectBase(LPCRECT lpSrcRect, HWND hwndi = INVALID_HWND_VALUE) {
		CScalingRect::CScalingRect(lpSrcRect, hwndi);
	}
	CVidRectBase(POINT point, SIZE size, HWND hwndi = INVALID_HWND_VALUE) {
		CScalingRect::CScalingRect(point, size, hwndi);
	}
	CVidRectBase(POINT topLeft, POINT bottomRight, HWND hwndi = INVALID_HWND_VALUE) {
		CScalingRect::CScalingRect(topLeft, bottomRight, hwndi);
	}
	CVidRectBase(const CVidRectBase& vri) {
		CScalingRect::CScalingRect(vri);
	}

	CVidRectBase& operator=(const CVidRectBase& srcRect) {
		if (&srcRect != this) {
			CScalingRect::operator=(srcRect);
		}
		return *this;
	}
    CVidRectBase(){}
    virtual ~CVidRectBase() {}

    STDMETHOD(get_Top)(/*[out, retval]*/ LONG* plTopVal) {
		try {
			if (!plTopVal) {
				return E_POINTER;
			}
			*plTopVal = top;
			return NOERROR;
		} catch(...) {
			return E_POINTER;
		}
	}
    STDMETHOD(put_Top)(/*[in]*/ LONG TopVal) {
		top = TopVal;
		m_bRequiresSave = true;
		return NOERROR;
	}
    STDMETHOD(get_Left)(/*[out, retval]*/ LONG* plLeftVal) {
		try {
			if (!plLeftVal) {
				return E_POINTER;
			}
			*plLeftVal = left;
			return NOERROR;
		} catch(...) {
			return E_POINTER;
		}
	}
    STDMETHOD(put_Left)(/*[in]*/ LONG LeftVal) {
		left = LeftVal;
		m_bRequiresSave = true;
		return NOERROR;
	}
    STDMETHOD(get_Width)(/*[out, retval]*/ LONG* plWidthVal) {
		try {
			if (!plWidthVal) {
				return E_POINTER;
			}
			*plWidthVal = Width();
			return NOERROR;
		} catch(...) {
			return E_POINTER;
		}
	}
    STDMETHOD(put_Width)(/*[in]*/ LONG WidthVal) {
		right = left + WidthVal;
		m_bRequiresSave = true;
		return NOERROR;
	}
    STDMETHOD(get_Height)(/*[out, retval]*/ LONG* plHeightVal) {
		try {
			if (!plHeightVal) {
				return E_POINTER;
			}
			*plHeightVal = Height();
			return NOERROR;
		} catch(...) {
			return E_POINTER;
		}
	}
    STDMETHOD(put_Height)(/*[in]*/ LONG HeightVal) {
		bottom = top + HeightVal;
		m_bRequiresSave = true;
		return NOERROR;
	}
    STDMETHOD(get_HWnd)(/*[out, retval]*/ HWND* plHWndVal) {
		try {
			if (!plHWndVal) {
				return E_POINTER;
			}
			*plHWndVal = Owner();
			return NOERROR;
		} catch(...) {
			return E_POINTER;
		}
	}
    STDMETHOD(put_HWnd)(/*[in]*/ HWND HWndVal) {
		try {
			Owner(HWndVal);
			return NOERROR;
		} catch(...) {
			return E_UNEXPECTED;
		}
	}
    STDMETHOD(put_Rect)(/*[in]*/ IMSVidRect* pVidRect) {
		try {
			if (!pVidRect) {
				return E_POINTER;
			}
			*this = *(static_cast<CVidRectBase*>(pVidRect));
			return NOERROR;
		} catch(...) {
			return E_POINTER;
		}
	}
};

/////////////////////////////////////////////////////////////////////////////
// CVidRect
class CVidRect : public CComObject<CVidRectBase>
{
public:
	// undone add ctors and op= for all permutations of RECTL, POINTL, SIZEL

    CVidRect(const CRect& ri, HWND hwndi = INVALID_HWND_VALUE) {
		CVidRectBase::CVidRectBase(ri, hwndi);
	}
	CVidRect(LONG l, LONG t, LONG r, LONG b, HWND hwndi = INVALID_HWND_VALUE) {
		CVidRectBase::CVidRectBase(l, t, r, b, hwndi);
	}
	CVidRect(const RECT& srcRect, HWND hwndi = INVALID_HWND_VALUE) {
		CVidRectBase::CVidRectBase(srcRect, hwndi);
	}
	CVidRect(LPCRECT lpSrcRect, HWND hwndi = INVALID_HWND_VALUE) {
		CVidRectBase::CVidRectBase(lpSrcRect, hwndi);
	}
	CVidRect(POINT point, SIZE size, HWND hwndi = INVALID_HWND_VALUE) {
		CVidRectBase::CVidRectBase(point, size, hwndi);
	}
	CVidRect(POINT topLeft, POINT bottomRight, HWND hwndi = INVALID_HWND_VALUE) {
		CVidRectBase::CVidRectBase(topLeft, bottomRight, hwndi);
	}
	CVidRect(const CVidRect& vri) {
		CVidRectBase::CVidRectBase(vri);
	}

	CVidRect& operator=(const CVidRect& srcRect) {
		if (&srcRect != this) {
			CVidRectBase::operator=(srcRect);
		}
		return *this;
	}


    virtual ~CVidRect() {}

	// IPersistPropertyBag

};

};
#endif
// end of file vidrect.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\webdvdimpl.h ===
//==========================================================================;
//
// webdvdimpl.h : additional infrastructure to support implementing IMSVidPlayback
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef WEBDVDIMPL_H
#define WEBDVDIMPL_H

#include "playbackimpl.h"

namespace MSVideoControl {

template<class T, LPCGUID LibID, LPCGUID KSCategory, class MostDerivedInterface = IMSVidWebDVD>
    class DECLSPEC_NOVTABLE IMSVidWebDVDImpl :         
    	public IMSVidPlaybackImpl<T, LibID, KSCategory, MostDerivedInterface> {
public:
    virtual ~IMSVidWebDVDImpl() {}
};
}; // namespace

#endif
// end of file - webdvdimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\vrsegimpl.h ===
//==========================================================================;
//
// vrsegimpl.h : additional infrastructure to support implementing IMSVidVRGraphSegment
// nicely from c++
// Copyright (c) Microsoft Corporation 1999-2000
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef VRSEGIMPL_H
#define VRSEGIMPL_H

#include "segimpl.h"
#include "devices.h"
#include <deviceeventimpl.h>

namespace MSVideoControl {
const int VIDCTL_NONMIXINGMODE = -1;
const int VIDCTL_MIXINGMODE = 0;
const int DEFAULT_MAX_STREAMS = 4;  // dvd needs 3(video, cc, subpic) plus we want a spare

#ifndef SPI_GETDROPSHADOW
#define SPI_GETDROPSHADOW                   0x1024
#endif

#ifndef SPI_SETDROPSHADOW
#define SPI_SETDROPSHADOW                   0x1025
#endif
#if 0
const COLORKEY DEFAULT_COLOR_KEY = { CK_RGB, 0, 0xff00ff, 0xff00ff};  // magenta
const AM_ASPECT_RATIO_MODE DEFAULT_ASPECT_RATIO_MODE = AM_ARMODE_STRETCHED;
#else
const OLE_COLOR DEFAULT_COLOR_KEY = 0xff00ff;  // magenta
const OLE_COLOR DEFAULT_BORDER_COLOR = 0x000000;  // black
#endif

typedef CComQIPtr<IVMRWindowlessControl> PQWindowlessControl;
typedef CComQIPtr<IPicture> PQIPic;
typedef CComQIPtr<IPictureDisp> PQIPicDisp;
typedef CComQIPtr<IVMRFilterConfig> PQVMRConfig;
typedef CComQIPtr<IVMRSurfaceAllocator> PQVMRSAlloc;
typedef CComQIPtr<IVMRImageCompositor> PQVMRImageComp;

template<class T, class MostDerivedClass = IMSVidVRGraphSegment>
    class DECLSPEC_NOVTABLE IMSVidVRGraphSegmentImpl :
        public IMSVidGraphSegmentImpl<T, MSVidSEG_DEST, &GUID_NULL,  MostDerivedClass>  {
protected:
        typedef IMSVidGraphSegmentImpl<T, MSVidSEG_DEST, &GUID_NULL,  MostDerivedClass> basetype;

        IMSVidVRGraphSegmentImpl() :
            m_hOwner(INVALID_HWND),
            m_fUseOverlay(false),
            m_fVisible(false),
            m_iVideoRenderer(-1),
            m_rectDest(0, 0, 0, 0),
            m_rectSrc(0, 0, 0, 0),
            m_ColorKey(DEFAULT_COLOR_KEY),
            m_BorderColor(DEFAULT_BORDER_COLOR),
            m_fMaintainAspectRatio(true),
            m_fHaveOriginalSystemEffects(false),
            m_bDropShadows(false),
            m_bSmoothing(false),
            m_vmrMixing(true),
            m_Decimate(false),
            m_vmRendererMode(VMRMode_Renderless),
            m_compositorGuid(GUID_NULL),
            m_APid(-1),
            m_vidSuppressEffects(true)
            {}

        PQVMRImageComp ImCompositor;
        GUID2 m_compositorGuid;
        HWND m_hOwner;
        bool m_fUseOverlay;
        bool m_fVisible;
        CRect m_rectSrc;
        CRect m_rectDest;
        PQVMRConfig m_pVMR;
        PQVMRWindowlessControl m_pVMRWC;
        int m_iVideoRenderer;
        OLE_COLOR m_ColorKey;
        OLE_COLOR m_BorderColor;
        BOOL m_bSmoothing;
        BOOL m_bDropShadows;
        bool m_fHaveOriginalSystemEffects;
        bool m_fMaintainAspectRatio;
        LONG m_vmRendererMode;
        bool m_vmrMixing;
        BOOL m_Decimate;
        PQVMRSAlloc qiSurfAlloc;
        long m_APid;
        bool m_vidSuppressEffects;

public:
    virtual ~IMSVidVRGraphSegmentImpl() {}
    void DisableAPM() {
        SetThreadExecutionState(ES_DISPLAY_REQUIRED | ES_CONTINUOUS);
    }

    void EnableAPM() {
        SetThreadExecutionState(ES_CONTINUOUS);
    }

    HRESULT Unload(void) {
        IMSVidGraphSegmentImpl<CMSVidVideoRenderer, MSVidSEG_DEST, &GUID_NULL>::Unload();
        m_iVideoRenderer = -1;
    }

    HRESULT UpdatePos() {
        if(!m_pVMRWC){
            return ImplReportError(__uuidof(T), IDS_E_NOTWNDLESS, __uuidof(IVMRFilterConfig), S_FALSE);
        }
        CRect s(m_rectSrc), d(m_rectDest);
        if (!s ||
            !m_fVisible ||
            m_hOwner == INVALID_HWND ||
            !::IsWindow(m_hOwner) ||
            !d.Width() ||
            !d.Height()) {
            d = CRect();
        }
        if (!d) {
            s = CRect();
        }
#if 0
            if (d && m_hOwner != INVALID_HWND) {
                ::MapWindowPoints(GetDesktopWindow(), m_hOwner, reinterpret_cast<LPPOINT>(&d), 2);
            }
#endif
            TRACELSM(TRACE_PAINT, (dbgDump << "VRSegimpl::UpdatePos() s = " << s << " d = " << d), "");
#if 0       
            PUnknown vidUnknown(m_pContainer);
            DWORD Temp_id = (DWORD_PTR)(vidUnknown.p);
            if(m_APid == Temp_id){
#endif
                return m_pVMRWC->SetVideoPosition(s, d);
#if 0
            }

            else{
            return NO_ERROR;
            }
#endif
    }

    virtual HRESULT SetVRConfig() {
        if (m_pVMR) {
            HRESULT hr;
            DWORD dwRenderPrefs = 0;

            if (m_fUseOverlay) {
                if(m_vidSuppressEffects){
                    if (!m_fHaveOriginalSystemEffects) {
                        if (!SystemParametersInfo(SPI_GETFONTSMOOTHING, 0, &m_bSmoothing, 0)) {
                            TRACELSM(TRACE_ERROR, (dbgDump << "VRSegimpl::SetVRConfig() can't get original drop shadows rc = " << GetLastError()), "");            
                        }
                        if (!SystemParametersInfo(SPI_GETDROPSHADOW, 0, &m_bDropShadows, 0)) {
                            TRACELSM(TRACE_ERROR, (dbgDump << "VRSegimpl::SetVRConfig() can't get original font smoothing rc = " << GetLastError()), "");            
                        }
                        m_fHaveOriginalSystemEffects = true;
                    }
                    BOOL val = FALSE;
                    if (!SystemParametersInfo(SPI_SETDROPSHADOW, 0, IntToPtr(FALSE), 0)) { // only send change notice once on the last one
                        TRACELSM(TRACE_ERROR, (dbgDump << "VRSegimpl::SetVRConfig() can't turn off font smoothing rc = " << GetLastError()), "");            
                    }
                    if (!SystemParametersInfo(SPI_SETFONTSMOOTHING, FALSE, NULL, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE)) {
                        TRACELSM(TRACE_ERROR, (dbgDump << "VRSegimpl::SetVRConfig() can't turn off font smoothing rc = " << GetLastError()), "");            
                    }
                }
                dwRenderPrefs = /*RenderPrefs_ForceOverlays |*/ RenderPrefs_DoNotRenderColorKeyAndBorder;
                TRACELM(TRACE_DETAIL, "IMSVidGraphSegmentImpl::SetVRConfig() forcing overlays");
            } else {
                TRACELSM(TRACE_DETAIL, (dbgDump << "IMSVidGraphSegmentImpl::SetVRConfig() border color = " << hexdump(m_BorderColor)), "");
                if(m_pVMRWC){
                    hr = m_pVMRWC->SetBorderColor(m_BorderColor);
                    if (FAILED(hr)) {
                        return hr;
                    }
                }
                dwRenderPrefs = RenderPrefs_ForceOffscreen; // no overlays allowed
            }
            TRACELSM(TRACE_DETAIL, (dbgDump << "IMSVidGraphSegmentImpl::SetVRConfig() rprefs = " << hexdump(dwRenderPrefs)), "");
            hr = m_pVMR->SetRenderingPrefs(dwRenderPrefs);
            if (FAILED(hr)) {
                TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::SetVRConfig() can't set vmr rendering prefs: hr = " << std::hex << hr), "");
                return E_UNEXPECTED;
            }

#if 0
                hr = m_pVMR->SetBorderColor(0x0101ff);
//                hr = m_pVMR->SetBorderColor(m_BorderColor);
                if (FAILED(hr)) {
                    TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::SetVRConfig() border hack failed hr = " << hexdump(hr)), "");
                }
#endif

            TRACELSM(TRACE_DETAIL, (dbgDump << "IMSVidGraphSegmentImpl::SetVRConfig() armode = " << (m_fMaintainAspectRatio ? "VMR_ARMODE_LETTER_BOX" : "VMR_ARMODE_NONE")), "");
            if(m_pVMRWC){
                if (m_fUseOverlay) {
                    // if we're doing the colorkey and all that then don't let the vmr
                    // do letterboxing because we get rounding errors which causes
                    // colorkey colored lines around the edges
                    hr = m_pVMRWC->SetAspectRatioMode(VMR_ARMODE_NONE);
                    if (FAILED(hr)) {
                        return hr;
                    }
                } else {
                    hr = m_pVMRWC->SetAspectRatioMode(m_fMaintainAspectRatio ? VMR_ARMODE_LETTER_BOX : VMR_ARMODE_NONE);
                    if (FAILED(hr)) {
                        return hr;
                    }
                }
            }
            // compositor should be set regardless of whether or not we're using overlays
            CComQIPtr<IVMRImageCompositor> IVMRICptr(ImCompositor);
            if(IVMRICptr){
                hr = m_pVMR->SetImageCompositor(IVMRICptr);
                if(FAILED(hr)){
                    TRACELSM(TRACE_ERROR, (dbgDump << "SetVRConfig() SetImageCompositor failed hr = " << hexdump(hr)), "");
                    return hr;
                }
            }
            if (!m_rectSrc) {
                CSize s, a;
                hr = get_NativeSize(&s, &a);
                if (FAILED(hr)) {
                    return hr;
                }
                m_rectSrc = CRect(CPoint(0, 0), s);
            }
            hr = UpdatePos();
            if (FAILED(hr)) {
                return hr;
            }
            // reminder: color key is set by override in video renderer derived class after we return to it
            if (m_hOwner != INVALID_HWND && ::IsWindow(m_hOwner)) {
                if(m_pVMRWC){
#if 0
                    // stop state race condition temp fix
                    PUnknown vidUnknown(m_pContainer);
                    DWORD Temp_id = (DWORD_PTR)(vidUnknown.p);
                    if(m_APid == Temp_id){
#endif
                        hr = m_pVMRWC->SetVideoClippingWindow(m_hOwner);
                        if (FAILED(hr)) {
                            TRACELSM(TRACE_ERROR, (dbgDump << "SetVRConfig() SetClipWnd failed hr = " << hexdump(hr)), "");
                            return hr;
                        }
#if 0
                    }
#endif
                }
            }

        }
        return NOERROR;
    }
    STDMETHOD(CheckVMRMode)(){
        try{
            PQVidCtl pqCtl;
            HRESULT hr = m_pContainer->QueryInterface(IID_IMSVidCtl, reinterpret_cast<void**>(&pqCtl));
            if(FAILED(hr)){
                return hr;
            }
            PQInputDevice pqIDev;
            hr = pqCtl->get_InputActive(&pqIDev);
            if(FAILED(hr)){
                return E_UNEXPECTED;
            }
            GUID2 inputID, classID;
            hr = pqIDev->get__ClassID(&inputID);
            if(FAILED(hr)){
                return hr;
            }
            if(inputID == CLSID_MSVidBDATunerDevice){
                PQFeatures pF;
                hr = pqCtl->get_FeaturesActive(&pF);
                if (FAILED(hr)) {
                    return hr;
                }

                CFeatures* pC = static_cast<CFeatures *>(pF.p);

                for (DeviceCollection::iterator i = pC->m_Devices.begin(); i != pC->m_Devices.end(); ++i) {
                    PQFeature f(*i);
                    hr = f->get__ClassID(&classID);
                    if (FAILED(hr)) {
                        //   TRACELM(TRACE_ERROR, "CTVProt::GetVidCtl() Can't get feature class id");
                        continue;
                    }
                    if (classID == CLSID_MSVidClosedCaptioning) {
                        break;
                    }
                }

                if(classID == CLSID_MSVidClosedCaptioning){
                    if(!m_vmrMixing){
                        hr = put__VMRendererMode(VIDCTL_MIXINGMODE);
                    }
                }
                else{
                    if(m_vmrMixing){
                        hr = put__VMRendererMode(VIDCTL_NONMIXINGMODE);
                    }
                }
                if(FAILED(hr)){
                    return E_UNEXPECTED;
                }
            }
            else{
                if(!m_vmrMixing){
                    hr = put__VMRendererMode(VIDCTL_MIXINGMODE);
                    if(FAILED(hr)){
                        return E_UNEXPECTED;
                    }
                }
            }
            return NOERROR;
        }
        catch(...){
            return E_UNEXPECTED;
        }
    }

    // IGraphSegment
    STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pCtl) {
        try {
            HRESULT hr = IMSVidGraphSegmentImpl<T, MSVidSEG_DEST, &GUID_NULL,  MostDerivedClass>::put_Container(pCtl);
            if (FAILED(hr)) {
                return hr;
            }
            if(pCtl){
                hr = CheckVMRMode();
                if(FAILED(hr)){
                    return hr;
                }
            }
           return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(CleanupVMR)(){
        try{
            HRESULT hr = S_OK;
            if(m_pVMR){
                if(m_pContainer){
                    CComQIPtr<IMSVidCtl> pq_vidCtl;
                    hr = m_pContainer->QueryInterface(IID_IMSVidCtl, reinterpret_cast<void**>(&pq_vidCtl));
                    if(FAILED(hr)){
                        return hr;
                    }
                    MSVidCtlStateList state;
                    hr = pq_vidCtl->get_State(&state);
                    if(FAILED(hr)){
                        return hr;
                    }
                    if(state != STATE_UNBUILT){
                        hr = pq_vidCtl->Stop();
                        if(FAILED(hr)){
                            return hr;
                        }
                        hr = pq_vidCtl->Decompose();
                        if(FAILED(hr)){
                            return hr;
                        }
                    }
                    DSFilter vr(m_pVMR);
                    m_pGraph->RemoveFilter(vr);
                    vr.Release();
                    m_Filters.clear();
                    m_iVideoRenderer = -1;
                }
                CComQIPtr<IVMRSurfaceAllocatorNotify>qiSan;
                qiSan = m_pVMR;
                if(!qiSan){
                    _ASSERT(false);
                    TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::CleanupVMR() can't qi for surface allocator notify: hr = " << std::hex << hr), "");
                }
                else{
                    hr = qiSan->AdviseSurfaceAllocator(m_APid, NULL);
                    if(FAILED(hr)){
                        _ASSERT(false);
                        TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::CleanupVMR() advise surface allocator (NULL) failed: hr = " << std::hex << hr), "");
                    }
                    qiSan.Release();
                    if (qiSurfAlloc) {
                        hr = qiSurfAlloc->AdviseNotify(NULL);
                    }
                }
                m_pVMRWC.Release();
                qiSurfAlloc.Release();
                m_pVMR.Release();

                _ASSERT(!m_pVMR);
            }
        }
        catch(...){
            return E_UNEXPECTED;
        }
        return S_OK;
    }
    STDMETHOD(Build)() {
        TRACELM(TRACE_DETAIL, "IMSVidVRGraphSegmentImpl::Build()");
        if (!m_fInit || !m_pGraph) {
            return ImplReportError(__uuidof(T), IDS_OBJ_NO_INIT, __uuidof(IMSVidVRGraphSegment), CO_E_NOTINITIALIZED);
        }
        try {
            CString csName;
            if (!m_pVMR) {
                HRESULT hr = m_pVMR.CoCreateInstance(CLSID_VideoMixingRenderer, NULL, CLSCTX_INPROC_SERVER);
                if (FAILED(hr)) {
                    TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::Build() can't load vmr: hr = " << std::hex << hr), "");
                    return ImplReportError(__uuidof(T), IDS_CANT_CREATE_FILTER, __uuidof(IVMRWindowlessControl), E_UNEXPECTED);
                }
                // Here is what is going on
                // We are not putting the vmr into renderless mode and passing in the default allocator/presenter
                // This is to support the use of custom allocator/presenters
                hr = m_pVMR->SetRenderingMode(m_vmRendererMode);
                if (FAILED(hr)) {
                    TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::Build() can't set vmr rendering mode: hr = " << std::hex << hr), "");
                    return ImplReportError(__uuidof(T), IDS_CANT_SET_VR_DEFAULTS, __uuidof(IVMRWindowlessControl), E_UNEXPECTED);
                }

                // If we are in mixing mode, do that which needs to be done
                if(m_vmrMixing){
                    hr = m_pVMR->SetNumberOfStreams(DEFAULT_MAX_STREAMS);
                    if (FAILED(hr)) {
                        TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::Build() can't set vmr stream count: hr = " << std::hex << hr), "");
                        return ImplReportError(__uuidof(T), IDS_CANT_SET_VR_DEFAULTS, __uuidof(IVMRWindowlessControl), E_UNEXPECTED);
                    }
                    DWORD curPrefs;
                    DWORD deci;
                    CComQIPtr<IVMRMixerControl>PQIVMRMixer(m_pVMR);
                    if(!PQIVMRMixer){
                        TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::Build() can't get vmr mixer control: hr = " << std::hex << hr), "");
                        return E_UNEXPECTED;
                    }
                    hr = PQIVMRMixer->GetMixingPrefs(&curPrefs);
                    if(FAILED(hr)){
                        TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::Build() can't get vmr mixer prefs: hr = " << std::hex << hr), "");
                        return hr;
                    }
                    deci = (m_Decimate?MixerPref_DecimateOutput:MixerPref_NoDecimation);
                    if(!(curPrefs&deci)){
                        curPrefs = (curPrefs&(~MixerPref_DecimateMask))|deci;
                        hr = PQIVMRMixer->SetMixingPrefs(curPrefs);
                        if(FAILED(hr)){
                            TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::Build() can't set vmr mixer prefs: hr = " << std::hex << hr), "");
                            return hr;
                        }
                    }

                }

                // Set up the allocator presenter
                if(!qiSurfAlloc){
                    hr = qiSurfAlloc.CoCreateInstance(CLSID_AllocPresenter, NULL, CLSCTX_INPROC_SERVER);
                    if(FAILED(hr)){
                        _ASSERT(false);
                        TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::Build() can't cocreate default surface allocator : hr = " << std::hex << hr), "");
                        return ImplReportError(__uuidof(T), IDS_CANT_CREATE_FILTER, __uuidof(IVMRWindowlessControl), E_UNEXPECTED);

                    }
                }
                CComQIPtr<IVMRSurfaceAllocatorNotify>qiSan;
                qiSan = m_pVMR;
                if(!qiSan){
                    _ASSERT(false);
                    TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::Build() can't qi for surface allocator notify: hr = " << std::hex << hr), "");
                    return ImplReportError(__uuidof(T), IDS_CANT_CREATE_FILTER, __uuidof(IVMRWindowlessControl), E_UNEXPECTED);
                }
                if(m_APid == -1){
                    PUnknown vidUnknown(m_pContainer);
                    m_APid = (DWORD_PTR)(vidUnknown.p);
                }
                hr = qiSan->AdviseSurfaceAllocator(m_APid, qiSurfAlloc);
                if(FAILED(hr)){
                    _ASSERT(false);
                    TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::Build() can't set surface allocator: hr = " << std::hex << hr), "");
                    return ImplReportError(__uuidof(T), IDS_CANT_CREATE_FILTER, __uuidof(IVMRWindowlessControl), E_UNEXPECTED);
                }
                hr = qiSurfAlloc->AdviseNotify(qiSan);
                if(FAILED(hr)){
                    _ASSERT(false);
                    TRACELSM(TRACE_ERROR, (dbgDump << "IMSVidGraphSegmentImpl::Build() can't advise notify: hr = " << std::hex << hr), "");
                    return ImplReportError(__uuidof(T), IDS_CANT_CREATE_FILTER, __uuidof(IVMRWindowlessControl), E_UNEXPECTED);
                }
                // Windowless control comes from alloc/presenter (vmr just proxys it through in the windowless case
                // so this should act exactly like being in windless mode
                m_pVMRWC = qiSurfAlloc;
            }
            DSFilter vr(m_pVMR);
            if (!vr) {
                ASSERT(false);
                return ImplReportError(__uuidof(T), IDS_CANT_CREATE_FILTER, __uuidof(IBaseFilter), E_UNEXPECTED);
            }
            if (m_iVideoRenderer == -1) {
                m_Filters.push_back(vr);
                csName = _T("Video Mixing Renderer");
                m_pGraph.AddFilter(vr, csName);
            }
            m_iVideoRenderer = 0;
            ASSERT(m_iVideoRenderer == 0);
            SetVRConfig();  // ignore errors, we'll try again at run time
            return NOERROR;
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(PreRun)() {
        try {
            if (!m_pVMR) {
                return HRESULT_FROM_WIN32(ERROR_INVALID_STATE);
            }
            m_rectDest = CRect(0, 0, 0, 0);
            m_rectSrc  = CRect(0, 0, 0, 0);

            if(m_vidSuppressEffects){
                DisableAPM();
            }
            HRESULT hr = UpdatePos();
            if (FAILED(hr)) {
                return hr;
            }
            return SetVRConfig();
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(PostStop)() {
        try {
            m_rectDest = CRect(0, 0, 0, 0);
            m_rectSrc  = CRect(0, 0, 0, 0);
            if (m_fHaveOriginalSystemEffects) {
                if (!SystemParametersInfo(SPI_SETDROPSHADOW, 0, &m_bDropShadows, 0)) { // only send change notice once on the last one
                    TRACELSM(TRACE_ERROR, (dbgDump << "VRSegimpl::SetVRConfig() can't turn off drop shadows rc = " << GetLastError()), "");            
                }
                if (!SystemParametersInfo(SPI_SETFONTSMOOTHING, m_bSmoothing, NULL, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE)) {
                    TRACELSM(TRACE_ERROR, (dbgDump << "VRSegimpl::PostStop() can't restore font smoothing rc = " << GetLastError()), "");            
                }
            }
            EnableAPM();
            return put_Visible(VARIANT_FALSE);
        } catch (...) {
            ASSERT(FALSE);
            return E_UNEXPECTED;
        }
    }
	
    // IMSVidVRGraphSegment
    STDMETHOD(put__VMRendererMode)(/*[in]*/ LONG dwMode){
        try{
            bool changed, mMode;
            changed = false;
            HRESULT  hr = S_OK;
            CString csName;
            if (dwMode == VIDCTL_NONMIXINGMODE || dwMode == VIDCTL_MIXINGMODE){
                mMode = (dwMode==VIDCTL_MIXINGMODE)?true:false;
                if(mMode != m_vmrMixing){
                    m_vmrMixing = mMode;
                    changed = true;
                }
            }
            else{
                return E_FAIL;
            }
            if(changed){
                hr = CleanupVMR();
                return hr;
            }
            else{
                return NOERROR;
            }
        }
        catch(HRESULT hres){
            return hres;
        }
        catch(...){
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(get_Owner)(/*[out, retval]*/ HWND* phWnd) {
        try {
            if (!phWnd) {
                return E_POINTER;
            }
            *phWnd = m_hOwner;
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(put_Owner)(/*[in]*/ HWND hWnd) {
       try {
            TRACELSM(TRACE_DETAIL, (dbgDump << "IMSVidVRGraphSegmentImpl<>::put_Owner() hWnd= " << hexdump(reinterpret_cast<ULONG_PTR>(hWnd))), "");
            if (m_hOwner == hWnd) {
                return NOERROR;
            }
            if (m_iVideoRenderer == -1 || !m_Filters[m_iVideoRenderer] || !m_pGraph || !m_pVMR) {
                return NOERROR;
            }
            m_hOwner = hWnd;
            if (m_hOwner != INVALID_HWND) {
                if(m_pVMRWC){
#if 0
                    // stop state race condition temp fix
                    PUnknown vidUnknown(m_pContainer);
                    DWORD Temp_id = (DWORD_PTR)(vidUnknown.p);
                    if(m_APid == Temp_id){
#endif
                        HRESULT hr = m_pVMRWC->SetVideoClippingWindow(m_hOwner);
                        if (FAILED(hr)) {
                            TRACELSM(TRACE_ERROR, (dbgDump << "put_Owner() SetClipWnd failed hr = " << hexdump(hr)), "");
                            return hr;
                        }
#if 0
                    }
#endif
                }
            }
            return UpdatePos(); // force a refresh if we're changing clip rects
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(get_UseOverlay)(/*[out, retval]*/ VARIANT_BOOL *fUseOverlay) {
        try {
            if (!fUseOverlay) {
                return E_POINTER;
            }
            *fUseOverlay = m_fUseOverlay ? VARIANT_TRUE : VARIANT_FALSE;
        } catch(...) {
            return E_POINTER;
        }
        return NOERROR;
    }
    STDMETHOD(put_UseOverlay)(/*[in]*/ VARIANT_BOOL fUseOverlayVal) {
        try {
            TRACELSM(TRACE_PAINT, (dbgDump << "VRSegimpl::put_UseOverlay() use_overlay = " << fUseOverlayVal), "");
            bool fUseOverlay = (fUseOverlayVal == VARIANT_TRUE);
            if (fUseOverlay == m_fUseOverlay) {
                return NOERROR;
            }
            m_fUseOverlay = fUseOverlay;
            if (!m_pVMR) {
                return NOERROR;
            }
            return SetVRConfig();
        } catch(...) {
            return E_POINTER;
        }
    }
    // from top-level control visibility state
    STDMETHOD(get_Visible)(/*[out, retval]*/ VARIANT_BOOL* fVisible) {
        try {
            if (!fVisible) {
                return E_POINTER;
            }
            *fVisible = m_fVisible ? VARIANT_TRUE : VARIANT_FALSE;
        } catch(...) {
            return E_POINTER;
        }
        return NOERROR;
    }
    STDMETHOD(put_Visible)(/*[in]*/ VARIANT_BOOL fVisibleVal) {
        try {
            TRACELSM(TRACE_DETAIL, (dbgDump << "IMSVidVRGraphSegmentImpl<>::put_Visible() fV = " << fVisibleVal), "");
            bool fVisible = (fVisibleVal == VARIANT_TRUE);
            if (fVisible == m_fVisible) {
                return NOERROR;
            }
            m_fVisible = fVisible;
            if (!m_pGraph || m_pGraph.GetState() == State_Stopped || m_iVideoRenderer == -1 || !m_pVMR) {
                return NOERROR;
            }
            HRESULT hr = UpdatePos();
            if (FAILED(hr)) {
                return hr;
            }
            if (!!m_pGraph && m_pGraph.IsPlaying()) {
                if (m_fVisible) {
                    if(m_vidSuppressEffects){
                        DisableAPM();
                    }
                } else {
                    EnableAPM();
                }
            }
            return NOERROR;
        } catch(ComException &e) {
            return e;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(get_Source)(/*[out, retval]*/ LPRECT pRect) {
        try {
            if (!pRect) {
                return E_POINTER;
            }
            *pRect = m_rectSrc;
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(put_Source)(/*[in]*/ RECT pRect) {
       try {
            TRACELSM(TRACE_DETAIL, (dbgDump << "IMSVidVRGraphSegmentImpl<>::put_Source() r = " << pRect), "");
            if (m_rectSrc == pRect) {
                return NOERROR;
            }
            if (m_iVideoRenderer == -1 || !m_Filters[m_iVideoRenderer] || !m_pGraph || !m_pVMR) {
                return NOERROR;
            }
            m_rectSrc = pRect;
            return UpdatePos();
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(get_Destination)(/*[out, retval]*/ LPRECT pRect) {
        try {
            if (!pRect) {
                return E_POINTER;
            }
            *pRect = m_rectDest;
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(put_Destination)(/*[in]*/ RECT pRect) {
       try {
            TRACELSM(TRACE_DETAIL, (dbgDump << "IMSVidVRGraphSegmentImpl<>::put_Dest() r = " << pRect), "");
            if (m_rectDest == pRect) {
                return NOERROR;
            }
            if (m_iVideoRenderer == -1 || !m_Filters[m_iVideoRenderer] || !m_pGraph || !m_pVMR) {
                return NOERROR;
            }

            TRACELM(TRACE_DETAIL, "IMSVidVRGraphSegmentImpl<>::put_Dest() setting");
            m_rectDest = pRect;
            return UpdatePos();
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(get_NativeSize)(/*[out]*/ LPSIZE pSize, LPSIZE pAR) {
        try {
            if (!pSize) {
                return E_POINTER;
            }

            if (m_iVideoRenderer == -1 || !m_Filters[m_iVideoRenderer] || !m_pGraph || !m_pVMR) {
                *pSize = CSize(0, 0);
                return NOERROR;
            }
            if(m_pVMRWC){
                HRESULT hr = m_pVMRWC->GetNativeVideoSize(&pSize->cx, &pSize->cy, &pAR->cx, &pAR->cy);
                if (FAILED(hr)) {
                    return hr;
                }
            }
            else{
                return ImplReportError(__uuidof(T), IDS_E_NOTWNDLESS, __uuidof(IVMRFilterConfig), S_FALSE);
            }
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    // from top-level control refresh method
    STDMETHOD(Refresh)() {
        try {
            if (!m_pVMR) {
                return NOERROR;
            }
            HRESULT hr = SetVRConfig();
            if (FAILED(hr)) {
                return hr;
            }
            hr = UpdatePos();
            if (FAILED(hr)) {
                return hr;
            }
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(DisplayChange)() {
        if (m_pVMR) {
            if(m_pVMRWC){
                return m_pVMRWC->DisplayModeChanged();
            }
        }
        return ImplReportError(__uuidof(T), IDS_E_NOTWNDLESS, __uuidof(IVMRFilterConfig), S_FALSE);
    }

    STDMETHOD(RePaint)(HDC hdc) {
        if (m_pVMR) {
            if(m_pVMRWC){
                return m_pVMRWC->RepaintVideo(m_hOwner, hdc);
            }
        }
        return ImplReportError(__uuidof(T), IDS_E_NOTWNDLESS, __uuidof(IVMRFilterConfig), S_FALSE);
    }

// IMSVidVRSegment
    STDMETHOD(get_ColorKey)(OLE_COLOR* pColorKey) {
        try {
            if (!pColorKey) {
                return E_POINTER;
            }
            *pColorKey = m_ColorKey;
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(put_ColorKey)(OLE_COLOR ColorKey) {
        try {
            if (m_ColorKey == ColorKey) {
                return NOERROR;
            }
            m_ColorKey = ColorKey;
            if (!m_pVMR) {
                return NOERROR;
            }
            if(m_pVMRWC){
                return m_pVMRWC->SetColorKey(m_ColorKey);
            }
            else{
                return ImplReportError(__uuidof(T), IDS_E_NOTWNDLESS, __uuidof(IVMRFilterConfig), S_FALSE);
            }
        } catch(...) {
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(get_BorderColor)(OLE_COLOR* pBorderColor) {
        try {
            if (!pBorderColor) {
                return E_POINTER;
            }
            *pBorderColor = m_BorderColor;
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(put_BorderColor)(OLE_COLOR BorderColor) {
        try {
            if (m_BorderColor == BorderColor) {
                return NOERROR;
            }
            m_BorderColor = BorderColor;
            if (!m_pVMR) {
                return NOERROR;
            }
            if(m_pVMRWC){
                return m_pVMRWC->SetBorderColor(m_BorderColor);
            }
            else{
                return ImplReportError(__uuidof(T), IDS_E_NOTWNDLESS, __uuidof(IVMRFilterConfig), S_FALSE);
            }
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(get_MaintainAspectRatio)(/*[out, retval]*/ VARIANT_BOOL* fMaintainAspectRatio) {
        try {
            if (!fMaintainAspectRatio) {
                return E_POINTER;
            }
            *fMaintainAspectRatio = m_fMaintainAspectRatio ? VARIANT_TRUE : VARIANT_FALSE;
        } catch(...) {
            return E_POINTER;
        }
        return NOERROR;
    }
    STDMETHOD(put_MaintainAspectRatio)(/*[in]*/ VARIANT_BOOL fMaintainAspectRatioVal) {
        try {
            TRACELSM(TRACE_DETAIL, (dbgDump << "IMSVidVRGraphSegmentImpl<>::put_MaintainAspectRatio() fV = " << fMaintainAspectRatioVal), "");
            bool fMaintainAspectRatio = (fMaintainAspectRatioVal == VARIANT_TRUE);
            if (fMaintainAspectRatio == m_fMaintainAspectRatio) {
                return NOERROR;
            }
            m_fMaintainAspectRatio = fMaintainAspectRatio;
            if (!m_pGraph || m_pGraph.GetState() == State_Stopped || m_iVideoRenderer == -1 || !m_pVMR) {
                return NOERROR;
            }
            HRESULT hr = SetVRConfig();
            if (FAILED(hr)) {
                return hr;
            }
            return NOERROR;
        } catch(ComException &e) {
            return e;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

};

template <class T, const IID* piid, class CDV = CComDynamicUnkArray>
class CProxy_VRSeg : public CProxy_DeviceEvent<T, piid, CDV>
{
public:
    VOID Fire_OverlayUnavailable()
    {
        Fire_VoidMethod(eventidOverlayUnavailable);
    }

};


typedef CComQIPtr<IMSVidVRGraphSegment> PQVRGraphSegment;

}; // namespace

#endif
// end of file - vrsegimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\w32extend.h ===
// w32extend.h - win32 helpers
// copyright (c) Microsoft Corp. 1998

#pragma once

#ifndef W32EXTEND_H
#define W32EXTEND_H

#include <guiddef.h>
#include <ocidl.h>
#include <urlmon.h>
#if defined(DEBUG) || defined(W32_OBJECT_STREAMING)
#include <atlconv.h>
#endif
using namespace ::ATL;
#include <atltmp.h>

#include <trace.h>
#include <throw.h>

// build a class to override the standard GUID in basetyps.h
// in order to put them into STL containers and dump them to debug
class GUID2 : public GUID {
private:
    void init(const LPCOLESTR guid) {
			OLECHAR temp[42];  // max guid string size
            HRESULT hr = StringCchCopyW(temp, SIZEOF_CH(temp), guid);
            if (FAILED(hr)) {
	            memset(this, 0, sizeof(GUID));
                THROWCOM(hr);
            }
            hr = CLSIDFromString(temp, this);
            if (FAILED(hr)) {
	            memset(this, 0, sizeof(GUID));
                THROWCOM(hr);
            }
    }

public:
    inline GUID2() : GUID(GUID_NULL) {}
    inline GUID2(const GUID2 &g) : GUID(g) {}
    inline GUID2(const struct _GUID &g) : GUID(g) {}
    inline GUID2(const struct _GUID *g) : GUID(*g) {}
    inline GUID2(const BSTR guid) {
        if (!guid || !SysStringLen(guid)) {
            memset(this, 0, sizeof(GUID));
        } else {
            init(guid);
        }
    }
    inline GUID2(const LPCOLESTR guid) {
        if (!guid || !ocslen(guid)) {
            memset(this, 0, sizeof(GUID));
        } else {
            init(guid);
        }
    }

    // operators
    GUID2 & operator=(const BSTR guid) {
        if (!guid || !SysStringLen(guid)) {
            memset(this, 0, sizeof(GUID));
        } else {
            init(guid);
        }
        return *this;
    }
    GUID2& operator=(const LPCOLESTR guid) {
        if (!guid || !ocslen(guid)) {
            memset(this, 0, sizeof(GUID));
        } else {
            init(guid);
        }
    }
    GUID2 & operator=(const GUID2 &g) {
        if (&g != this) {
            ASSERT(sizeof(*this) == sizeof(struct _GUID));
            memcpy(this, &g, sizeof(GUID2));
        }
        return *this;
    }
    GUID2 & operator=(const struct _GUID &g) {
        if (&g != this) {
            ASSERT(sizeof(*this) == sizeof(g));
            memcpy(this, &g, min(sizeof(GUID2), sizeof(GUID)));
        }
        return *this;
    }

    BSTR GetBSTR() const {
        OLECHAR guidstr[(((sizeof(_GUID) * 2/* bin to char*/) + 1/*str null term*/) * 2/*ansi to unicode*/)];
        int rc = StringFromGUID2(*this, guidstr, sizeof(guidstr)/sizeof(OLECHAR));
        ASSERT(rc);
        return SysAllocString(guidstr);
    }
#if defined(DEBUG) || defined(W32_OBJECT_STREAMING)
    void inline Dump(tostream &dc) const {
        BSTR guidstr(GetBSTR());
        USES_CONVERSION;
        dc << OLE2T(guidstr);
        ::SysFreeString(guidstr);
        return;
    }
#endif
    bool inline operator<(const GUID2 &op2) const {
        if (memcmp(this, &op2, sizeof(GUID2)) < 0) {
                return true;
        }
        return false;
    }
    bool inline operator>(const GUID2 &op2) const {
        if (memcmp(this, &op2, sizeof(GUID2)) > 0) {
                return true;
        }
        return false;
    }
    bool inline operator==(const GUID2 &op2) const {
        if (!memcmp(this, &op2, sizeof(GUID2))) {
                return true;
        }
        return false;
    }
    bool inline operator!=(const GUID2 &op2) const {
        if (memcmp(this, &op2, sizeof(GUID2))) {
                return true;
        }
        return false;
    }
    bool inline operator<(const GUID &op2) const {
        if (memcmp(this, &op2, sizeof(GUID)) < 0) {
                return true;
        }
        return false;
    }
    bool inline operator>(const GUID &op2) const {
        if (memcmp(this, &op2, sizeof(GUID)) > 0) {
                return true;
        }
        return false;
    }
    bool inline operator==(const GUID &op2) const {
        if (!memcmp(this, &op2, sizeof(GUID))) {
                return true;
        }
        return false;
    }
    bool inline operator!=(const GUID &op2) const {
        if (memcmp(this, &op2, sizeof(GUID))) {
                return true;
        }
        return false;
    }

};

typedef CComPtr<IUnknown> PUnknown;

#if defined(DEBUG) || defined(W32_OBJECT_STREAMING)
inline tostream &operator<<(tostream &dc, const GUID2 &g)
{
    g.Dump(dc);
    return dc;
}

inline tostream &operator<<(tostream &dc, const GUID &g)
{
    GUID2 g2(g);
    g2.Dump(dc);
    return dc;
}

inline tostream &operator<<(tostream &dc, const RECT& r)
{
    dc << "T(" << r.top << 
          ") L(" << r.left << 
          ") B(" << r.bottom << 
          ") R(" << r.right << 
          ") W(" << (r.right - r.left) << 
          ") H(" << (r.bottom - r.top) << ")";
    return dc;
}
inline tostream &operator<<(tostream &dc, const SIZE& s)
{
    dc << "X(" << s.cx << ") Y(" << s.cy << ")";
    return dc;
}
#if 0
inline tostream &operator<<(tostream &dc, ULONGLONG &ul) {
    TCHAR buf[128];
    _stprintf(buf, "%I64X", ul);
    dc << buf;
    return dc;
}
#endif

inline tostream &operator<<(tostream &dc, const VARIANT &v)
{
    USES_CONVERSION;
    switch (v.vt) {
    case VT_UI4:
        dc << _T("VT_UI4: ") << v.ulVal;
        break;
    case VT_UI8: {
        dc << _T("VT_UI8: ");
        TCHAR buf[128];
        _ui64tot(v.ullVal, buf, 16);
        dc << buf;
    } break;
    case VT_BSTR:
        dc << _T("VT_BSTR: ") << OLE2T(v.bstrVal);
        break;
    case VT_UNKNOWN:
        dc << _T("VT_UNKNOWN: ") << v.punkVal;
        break;
    case VT_DISPATCH:
        dc << _T("VT_DISPATCH: ") << v.pdispVal;
        break;
    case VT_UI1 | VT_ARRAY:
        dc << _T("VT_UI1 | VT_ARRAY: blob");
        break;
    default:
        dc << std::endl << "cant dump variant.  vt = " << v.vt << std::endl;
    }
    return dc;
}
#endif

inline bool operator!(const VARIANT &v) {
    return v.vt == VT_EMPTY || v.vt == VT_NULL;
}
// provide an operator form and work around the fact that VarCmp
// only supports unsigned ints of size 1
inline bool operator==(const VARIANT &lhs, const VARIANT &rhs) {
    HRESULT hrc = VarCmp(const_cast<VARIANT*>(&lhs), 
                         const_cast<VARIANT*>(&rhs), 
                         LOCALE_USER_DEFAULT, 
                         0);
    if (hrc == DISP_E_BADVARTYPE) {
        // check for types VarCmp doesn't support that we need to support
        // coerce unsigned to next largest signed if possible and then
        // fall back to VarCmp for lowest risk way to get most identical
        // behavior
        // for UI8 which is max compiler supports we'll do the compare
        // ourselves using the compiler support
        switch (lhs.vt) {
        case VT_UI2: {
            VARIANT v;
            VariantInit(&v);
            hrc = VariantChangeTypeEx(&v, const_cast<VARIANT *>(&lhs), LOCALE_USER_DEFAULT, 0, VT_I4);
            if (SUCCEEDED(hrc)) {
                return operator==(v, rhs);
            }
		} break;
        case VT_UI4: {
            VARIANT v;
            VariantInit(&v);
            hrc = VariantChangeTypeEx(&v, const_cast<VARIANT *>(&lhs), LOCALE_USER_DEFAULT, 0, VT_I8);
            if (SUCCEEDED(hrc)) {
                return operator==(v, rhs);
            }
        } break;
        case VT_UI8: {
            if (rhs.vt == VT_UI8) {
                return lhs.ullVal == rhs.ullVal;
            } 
            VARIANT v;
            VariantInit(&v);
            hrc = VariantChangeTypeEx(&v, const_cast<VARIANT *>(&rhs), LOCALE_USER_DEFAULT, 0, VT_UI8);
            if (SUCCEEDED(hrc)) {
                return operator==(lhs, v);
            }
        } break;
        default: {
            // the problem is either lhs of some type we can't help with
            // or its the rhs.  so we'll check the rhs...
            switch(rhs.vt) {
            case VT_UI2: {
                VARIANT v;
                VariantInit(&v);
                hrc = VariantChangeTypeEx(&v, const_cast<VARIANT *>(&rhs), LOCALE_USER_DEFAULT, 0, VT_I4);
                if (SUCCEEDED(hrc)) {
                    return operator==(lhs, v);
                }
            } break;
            case VT_UI4: {
                VARIANT v;
                VariantInit(&v);
                hrc = VariantChangeTypeEx(&v, const_cast<VARIANT *>(&rhs), LOCALE_USER_DEFAULT, 0, VT_I8);
                if (SUCCEEDED(hrc)) {
                    return operator==(lhs, v);
                }
            } break;
            case VT_UI8: {
                if (lhs.vt == VT_UI8) {
                    return lhs.ullVal == rhs.ullVal;
                } 
                VARIANT v;
                VariantInit(&v);
                hrc = VariantChangeTypeEx(&v, const_cast<VARIANT *>(&lhs), LOCALE_USER_DEFAULT, 0, VT_UI8);
                if (SUCCEEDED(hrc)) {
                    return operator==(v, rhs);
                }
            }}; //switch rhs
            // must be some other bad type we can't help with
        }}; //switch lhs
    }
    return (hrc == VARCMP_EQ);
}
inline bool operator!=(const VARIANT &lhs, const VARIANT &rhs) {
    return !operator==(lhs, rhs);
}
typedef CComQIPtr<IEnumVARIANT, &IID_IEnumVARIANT> PQEnumVARIANT;

typedef CComPtr<IUnknown> PUnknown;
typedef CComQIPtr<IPersist> PQPersist;
typedef CComQIPtr<IPropertyBag, &IID_IPropertyBag> PQPropertyBag;
typedef CComQIPtr<IPropertyBag2> PQPropertyBag2;
typedef CComQIPtr<IPersistPropertyBag> PQPersistPropertyBag;
typedef CComQIPtr<IPersistPropertyBag2> PQPersistPropertyBag2;
typedef CComQIPtr<IMoniker, &IID_IMoniker> PQMoniker;
typedef CComQIPtr<IBindCtx> PQBindCtx;
typedef CComQIPtr<IServiceProvider> PQServiceProvider;
typedef CComQIPtr<IGlobalInterfaceTable> PQGIT;
typedef CComQIPtr<IRunningObjectTable> PQROT;
typedef CComQIPtr<IOleWindow> PQOleWindow;
typedef CComQIPtr<IMalloc> PQMalloc;
typedef CComQIPtr<IObjectWithSite> PQObjectWithSite;
typedef CComQIPtr<IConnectionPoint> PQConnectionPoint;
typedef CComQIPtr<IInternetHostSecurityManager> PQSecurityManager;



class W32Moniker : public PQMoniker {
public:
    inline W32Moniker() {}
    inline W32Moniker(const PQMoniker &a) : PQMoniker(a) {}
    inline W32Moniker(IMoniker *p) : PQMoniker(p) {}
    inline W32Moniker(IUnknown *p) : PQMoniker(p) {}
    inline W32Moniker(const W32Moniker &a) : PQMoniker(a) {}

    PQPropertyBag GetPropertyBag() const {
        PQPropertyBag pPropBag;
        HRESULT hr = (*this)->BindToStorage(0, 0, IID_IPropertyBag, reinterpret_cast<LPVOID *>(&pPropBag));
        if (FAILED(hr)) {
            TRACELSM(TRACE_ERROR, (dbgDump << "W32Moniker::GetPropertyBag() can't bind to storage hr = " << hr), "");
            THROWCOM(hr);
        }
        return pPropBag;
    }
    PUnknown GetObject() const {
        PUnknown pObj;
        HRESULT hr = (*this)->BindToObject(0, 0, __uuidof(IUnknown), reinterpret_cast<LPVOID *>(&pObj));
        if (FAILED(hr)) {
            TRACELSM(TRACE_ERROR, (dbgDump << "W32Moniker::GetObject() can't bind to object.  hr = " << hr), "");
            THROWCOM(hr);
        }
        return pObj;
    }
	CString DisplayName() const {
		LPOLESTR lpszName;
		HRESULT hr = (*this)->GetDisplayName(NULL, NULL, &lpszName);
		if (FAILED(hr)) {
			return CString();
		}
		CString rc(lpszName);
		CoTaskMemFree(lpszName);
		return rc;
	}
};

inline HRESULT IsSafeZone(DWORD dwZone) {
    switch (dwZone) {
    case URLZONE_LOCAL_MACHINE:
    case URLZONE_INTRANET:
    case URLZONE_TRUSTED:
        // the fixed list of zones we trust
        return NOERROR;
    default:  
        // everything else is untrusted
        return E_FAIL;
    }
}
inline HRESULT IsSafeSite(IUnknown* pSite) {
    PQServiceProvider psp(pSite);
    if (!psp) {
        // no service provider interface on the site implies that we're not running in IE
        // so by defn running local and trusted thus we return OK
        return NOERROR;
    }
    PQSecurityManager pManager;
    HRESULT hr = psp->QueryService(SID_SInternetHostSecurityManager, IID_IInternetHostSecurityManager, (LPVOID *)&pManager);
    if (FAILED(hr)) {
        // no security manager interface on the site's service provider implies that we're not 
        // running in IE, so by defn running local and trusted thus we return OK
        return NOERROR;
    }
    const int MAXZONE = MAX_SIZE_SECURITY_ID+6/*scheme*/+4/*zone(dword)*/+1/*wildcard*/+1/*trailing null*/;
    char pbSecurityId[MAXZONE];
    DWORD pcbSecurityId = sizeof(pbSecurityId);
    ZeroMemory(pbSecurityId, sizeof(pbSecurityId));
    hr = pManager->GetSecurityId(reinterpret_cast<BYTE*>(pbSecurityId), &pcbSecurityId, NULL);
    if(FAILED(hr)){
        // security manager not working(unexpected). but, the site tried to provide one. thus we
        // must assume untrusted content and fail
        return E_FAIL;   
    }
    char *pbEnd = pbSecurityId + pcbSecurityId - 1;
    if (*pbEnd == '*') {  //ignore the optional wildcard flag
        pbEnd--;
    }
    pbEnd -= 3;  // point to beginning of little endian zone dword
    DWORD dwZone = *(reinterpret_cast<long *>(pbEnd));
    return IsSafeZone(dwZone);
}

typedef CComQIPtr<IDispatch, &IID_IDispatch> PQDispatch;

#endif // w32extend.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\xdsimpl.h ===
//==========================================================================;
//
// XDSimpl.h : additional infrastructure to support implementing IMSVidXDS
// nicely from c++
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#pragma once

#ifndef XDSIMPL_H
#define XDSIMPL_H

#include "featureimpl.h"

namespace MSVideoControl {

template<class T, LPCGUID LibID, LPCGUID KSCategory, class MostDerivedInterface = IMSVidXDS>
    class DECLSPEC_NOVTABLE IMSVidXDSImpl : public IMSVidFeatureImpl<T, LibID, KSCategory, MostDerivedInterface> {
public:
	    virtual ~IMSVidXDSImpl() {}
};

}; /// namespace

#endif
// end of file - XDSimpl.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\atl\atlcom.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.
#ifndef __ATLCOM_H__
#define __ATLCOM_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atlcom.h requires atlbase.h to be included first
#endif

#pragma pack(push, _ATL_PACKING)

EXTERN_C const IID IID_ITargetFrame;

namespace ATL
{

#define CComConnectionPointContainerImpl IConnectionPointContainerImpl
#define CComISupportErrorInfoImpl ISupportErrorInfoImpl
#define CComProvideClassInfo2Impl IProvideClassInfoImpl
#define CComDualImpl IDispatchImpl

#ifdef _ATL_DEBUG_QI
#ifndef _ATL_DEBUG
#define _ATL_DEBUG
#endif // _ATL_DEBUG
#endif // _ATL_DEBUG_QI

#ifdef _ATL_DEBUG_QI
#define _ATLDUMPIID(iid, name, hr) AtlDumpIID(iid, name, hr)
#else
#define _ATLDUMPIID(iid, name, hr) hr
#endif

#define _ATL_DEBUG_ADDREF_RELEASE_IMPL(className)\
	virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;\
	virtual ULONG STDMETHODCALLTYPE Release(void) = 0;

#define ATL_LOCK() \
	ObjectLock objlock(this);

#define ATL_LOCKT() \
	T *pT = static_cast<T*>(this); \
	T::ObjectLock objlock(pT);

#define ATL_ROOT_LOCK() \
	ROOT *pROOT = static_cast<ROOT*>(this); \
	ROOT::ObjectLock objlock(pROOT);

/////////////////////////////////////////////////////////////////////////////
// AtlReportError

inline HRESULT WINAPI AtlReportError(const CLSID& clsid, UINT nID, const IID& iid,
	HRESULT hRes, HINSTANCE hInst)
{
	return AtlSetErrorInfo(clsid, (LPCOLESTR)MAKEINTRESOURCE(nID), 0, NULL, iid, hRes, hInst);
}

inline HRESULT WINAPI AtlReportError(const CLSID& clsid, UINT nID, DWORD dwHelpID,
	LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes, HINSTANCE hInst)
{
	return AtlSetErrorInfo(clsid, (LPCOLESTR)MAKEINTRESOURCE(nID), dwHelpID,
		lpszHelpFile, iid, hRes, hInst);
}

#ifndef OLE2ANSI
inline HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCSTR lpszDesc,
	DWORD dwHelpID, LPCSTR lpszHelpFile, const IID& iid, HRESULT hRes)
{
	ATLASSERT(lpszDesc != NULL);
	USES_CONVERSION;
	return AtlSetErrorInfo(clsid, A2COLE(lpszDesc), dwHelpID, A2CW(lpszHelpFile),
		iid, hRes, NULL);
}

inline HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCSTR lpszDesc,
	const IID& iid, HRESULT hRes)
{
	ATLASSERT(lpszDesc != NULL);
	USES_CONVERSION;
	return AtlSetErrorInfo(clsid, A2COLE(lpszDesc), 0, NULL, iid, hRes, NULL);
}
#endif

inline HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCOLESTR lpszDesc,
	const IID& iid, HRESULT hRes)
{
	return AtlSetErrorInfo(clsid, lpszDesc, 0, NULL, iid, hRes, NULL);
}

inline HRESULT WINAPI AtlReportError(const CLSID& clsid, LPCOLESTR lpszDesc, DWORD dwHelpID,
	LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes)
{
	return AtlSetErrorInfo(clsid, lpszDesc, dwHelpID, lpszHelpFile, iid, hRes, NULL);
}

//////////////////////////////////////////////////////////////////////////////
// IPersistImpl
template <class T>
class ATL_NO_VTABLE IPersistImpl : public IPersist
{
public:
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistImpl::GetClassID\n"));
		if (pClassID == NULL)
			return E_FAIL;
		*pClassID = T::GetObjectCLSID();
		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// CComDispatchDriver / Specialization of CComQIPtr<IDispatch, IID_IDispatch>
class CComDispatchDriver
{
public:
	CComDispatchDriver()
	{
		p = NULL;
	}
	CComDispatchDriver(IDispatch* lp)
	{
		if ((p = lp) != NULL)
			p->AddRef();
	}
	CComDispatchDriver(IUnknown* lp)
	{
		p=NULL;
		if (lp != NULL)
			lp->QueryInterface(IID_IDispatch, (void **)&p);
	}
	~CComDispatchDriver() { if (p) p->Release(); }
	void Release() {if (p) p->Release(); p=NULL;}
	operator IDispatch*() {return p;}
	IDispatch& operator*() {ATLASSERT(p!=NULL); return *p; }
	IDispatch** operator&() {ATLASSERT(p==NULL); return &p; }
	IDispatch* operator->() {ATLASSERT(p!=NULL); return p; }
	IDispatch* operator=(IDispatch* lp){return (IDispatch*)AtlComPtrAssign((IUnknown**)&p, lp);}
	IDispatch* operator=(IUnknown* lp)
	{
		return (IDispatch*)AtlComQIPtrAssign((IUnknown**)&p, lp, IID_IDispatch);
	}
	BOOL operator!(){return (p == NULL) ? TRUE : FALSE;}

	HRESULT GetPropertyByName(LPCOLESTR lpsz, VARIANT* pVar)
	{
		ATLASSERT(p);
		ATLASSERT(pVar);
		DISPID dwDispID;
		HRESULT hr = GetIDOfName(lpsz, &dwDispID);
		if (SUCCEEDED(hr))
			hr = GetProperty(p, dwDispID, pVar);
		return hr;
	}
	HRESULT GetProperty(DISPID dwDispID, VARIANT* pVar)
	{
		ATLASSERT(p);
		return GetProperty(p, dwDispID, pVar);
	}
	HRESULT PutPropertyByName(LPCOLESTR lpsz, VARIANT* pVar)
	{
		ATLASSERT(p);
		ATLASSERT(pVar);
		DISPID dwDispID;
		HRESULT hr = GetIDOfName(lpsz, &dwDispID);
		if (SUCCEEDED(hr))
			hr = PutProperty(p, dwDispID, pVar);
		return hr;
	}
	HRESULT PutProperty(DISPID dwDispID, VARIANT* pVar)
	{
		ATLASSERT(p);
		return PutProperty(p, dwDispID, pVar);
	}
	HRESULT GetIDOfName(LPCOLESTR lpsz, DISPID* pdispid)
	{
		return p->GetIDsOfNames(IID_NULL, (LPOLESTR*)&lpsz, 1, LOCALE_USER_DEFAULT, pdispid);
	}
	// Invoke a method by DISPID with no parameters
	HRESULT Invoke0(DISPID dispid, VARIANT* pvarRet = NULL)
	{
		DISPPARAMS dispparams = { NULL, NULL, 0, 0};
		return p->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, pvarRet, NULL, NULL);
	}
	// Invoke a method by name with no parameters
	HRESULT Invoke0(LPCOLESTR lpszName, VARIANT* pvarRet = NULL)
	{
		HRESULT hr;
		DISPID dispid;
		hr = GetIDOfName(lpszName, &dispid);
		if (SUCCEEDED(hr))
			hr = Invoke0(dispid, pvarRet);
		return hr;
	}
	// Invoke a method by DISPID with a single parameter
	HRESULT Invoke1(DISPID dispid, VARIANT* pvarParam1, VARIANT* pvarRet = NULL)
	{
		DISPPARAMS dispparams = { pvarParam1, NULL, 1, 0};
		return p->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, pvarRet, NULL, NULL);
	}
	// Invoke a method by name with a single parameter
	HRESULT Invoke1(LPCOLESTR lpszName, VARIANT* pvarParam1, VARIANT* pvarRet = NULL)
	{
		HRESULT hr;
		DISPID dispid;
		hr = GetIDOfName(lpszName, &dispid);
		if (SUCCEEDED(hr))
			hr = Invoke1(dispid, pvarParam1, pvarRet);
		return hr;
	}
	// Invoke a method by DISPID with two parameters
	HRESULT Invoke2(DISPID dispid, VARIANT* pvarParam1, VARIANT* pvarParam2, VARIANT* pvarRet = NULL)
	{
        if(pvarParam1 == NULL || pvarParam2 == NULL)
                return E_INVALIDARG;
                        
		CComVariant varArgs[2] = { *pvarParam2, *pvarParam1 };
		DISPPARAMS dispparams = { &varArgs[0], NULL, 2, 0};
		return p->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, pvarRet, NULL, NULL);
	}
	// Invoke a method by name with two parameters
	HRESULT Invoke2(LPCOLESTR lpszName, VARIANT* pvarParam1, VARIANT* pvarParam2, VARIANT* pvarRet = NULL)
	{
		HRESULT hr;
		DISPID dispid;
		hr = GetIDOfName(lpszName, &dispid);
		if (SUCCEEDED(hr))
			hr = Invoke2(dispid, pvarParam1, pvarParam2, pvarRet);
		return hr;
	}
	// Invoke a method by DISPID with N parameters
	HRESULT InvokeN(DISPID dispid, VARIANT* pvarParams, int nParams, VARIANT* pvarRet = NULL)
	{
		DISPPARAMS dispparams = { pvarParams, NULL, nParams, 0};
		return p->Invoke(dispid, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dispparams, pvarRet, NULL, NULL);
	}
	// Invoke a method by name with Nparameters
	HRESULT InvokeN(LPCOLESTR lpszName, VARIANT* pvarParams, int nParams, VARIANT* pvarRet = NULL)
	{
		HRESULT hr;
		DISPID dispid;
		hr = GetIDOfName(lpszName, &dispid);
		if (SUCCEEDED(hr))
			hr = InvokeN(dispid, pvarParams, nParams, pvarRet);
		return hr;
	}
	static HRESULT GetProperty(IDispatch* pDisp, DISPID dwDispID,
		VARIANT* pVar)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("CPropertyHelper::GetProperty\n"));
        ATLASSERT(pVar != NULL);
        if (pVar == NULL)
                return E_POINTER;
        
        if(pDisp == NULL)
                return E_INVALIDARG;
                        
		DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
		return pDisp->Invoke(dwDispID, IID_NULL,
				LOCALE_USER_DEFAULT, DISPATCH_PROPERTYGET,
				&dispparamsNoArgs, pVar, NULL, NULL);
	}

	static HRESULT PutProperty(IDispatch* pDisp, DISPID dwDispID,
		VARIANT* pVar)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("CPropertyHelper::PutProperty\n"));
        ATLASSERT(pVar != NULL);
        if (pVar == NULL)
                return E_POINTER;

        if(pDisp == NULL)
                return E_INVALIDARG;
                        
		DISPPARAMS dispparams = {NULL, NULL, 1, 1};
		dispparams.rgvarg = pVar;
		DISPID dispidPut = DISPID_PROPERTYPUT;
		dispparams.rgdispidNamedArgs = &dispidPut;

		if (pVar->vt == VT_UNKNOWN || pVar->vt == VT_DISPATCH || 
			(pVar->vt & VT_ARRAY) || (pVar->vt & VT_BYREF))
		{
			HRESULT hr = pDisp->Invoke(dwDispID, IID_NULL,
				LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUTREF,
				&dispparams, NULL, NULL, NULL);
			if (SUCCEEDED(hr))
				return hr;
		}

		return pDisp->Invoke(dwDispID, IID_NULL,
				LOCALE_USER_DEFAULT, DISPATCH_PROPERTYPUT,
				&dispparams, NULL, NULL, NULL);
	}

	IDispatch* p;
};

//////////////////////////////////////////////////////////////////////////////
// CFakeFirePropNotifyEvent
class CFakeFirePropNotifyEvent
{
public:
	static HRESULT FireOnRequestEdit(IUnknown* /*pUnk*/, DISPID /*dispID*/)
	{
		return S_OK;
	}
	static HRESULT FireOnChanged(IUnknown* /*pUnk*/, DISPID /*dispID*/)
	{
		return S_OK;
	}
};
typedef CFakeFirePropNotifyEvent _ATL_PROP_NOTIFY_EVENT_CLASS;

//////////////////////////////////////////////////////////////////////////////
// ATL Persistence

struct ATL_PROPMAP_ENTRY
{
	LPCOLESTR szDesc;
	DISPID dispid;
	const CLSID* pclsidPropPage;
	const IID* piidDispatch;
	size_t dwOffsetData;
	DWORD dwSizeData;
	VARTYPE vt;
	const IID* piidUnknown;
};

// This one is DEPRECATED and is used for ATL 2.X controls
// it includes an implicit m_sizeExtent
#define BEGIN_PROPERTY_MAP(theClass) \
	typedef _ATL_PROP_NOTIFY_EVENT_CLASS __ATL_PROP_NOTIFY_EVENT_CLASS; \
	typedef theClass _PropMapClass; \
	static ATL_PROPMAP_ENTRY* GetPropertyMap()\
	{\
		static ATL_PROPMAP_ENTRY pPropMap[] = \
		{ \
			{OLESTR("_cx"), 0, &CLSID_NULL, NULL, offsetof(_PropMapClass, m_sizeExtent.cx), sizeof(long), VT_UI4, &IID_NULL}, \
			{OLESTR("_cy"), 0, &CLSID_NULL, NULL, offsetof(_PropMapClass, m_sizeExtent.cy), sizeof(long), VT_UI4, &IID_NULL},

class __declspec(uuid("2A6E293D-2595-11d3-B64C-00C04F79498E")) IChainPropMapFlagDummy {};

// This one can be used on any type of object, but does not
// include the implicit m_sizeExtent
#define BEGIN_PROP_MAP(theClass) \
	typedef _ATL_PROP_NOTIFY_EVENT_CLASS __ATL_PROP_NOTIFY_EVENT_CLASS; \
	typedef theClass _PropMapClass; \
	static ATL_PROPMAP_ENTRY* GetPropertyMap()\
	{\
		static ATL_PROPMAP_ENTRY pPropMap[] = \
		{

#define PROP_ENTRY(szDesc, dispid, clsid) \
		{OLESTR(szDesc), dispid, &clsid, &IID_IDispatch, 0, 0, 0, &IID_NULL},

#define PROP_ENTRY_EX(szDesc, dispid, clsid, iidDispatch) \
		{OLESTR(szDesc), dispid, &clsid, &iidDispatch, 0, 0, 0, &IID_NULL},

#define PROP_PAGE(clsid) \
		{NULL, NULL, &clsid, &IID_NULL, 0, 0, 0, &IID_NULL},

#define CHAIN_PROP_MAP(theChainClass) \
        {NULL, 0, reinterpret_cast<CLSID*>(&theChainClass::GetPropertyMap), \
            &__uuidof(IChainPropMapFlagDummy), offsetofclass(theChainClass, _PropMapClass), 0, VT_NULL, &IID_NULL},

#define PROP_DATA_ENTRY(szDesc, member, vt) \
		{OLESTR(szDesc), 0, &CLSID_NULL, NULL, offsetof(_PropMapClass, member), sizeof(((_PropMapClass*)0)->member), vt, &IID_NULL},

#define PROP_DATA_QI_ENTRY(szDesc, member, iid) \
		{OLESTR(szDesc), 0, &CLSID_NULL, NULL, offsetof(_PropMapClass, member), sizeof(((_PropMapClass*)0)->member), VT_UNKNOWN, &iid},

#define END_PROPERTY_MAP() \
			{NULL, 0, NULL, &IID_NULL, 0, 0, 0, &IID_NULL} \
		}; \
		return pPropMap; \
	}

#define END_PROP_MAP() \
			{NULL, 0, NULL, &IID_NULL, 0, 0, 0, &IID_NULL} \
		}; \
		return pPropMap; \
	}

#define MARK_DIRTY(T) \
	static_cast<T*>(this)->m_bRequiresSave = true;

#define CLEAR_DIRTY() \
	static_cast<T*>(this)->m_bRequiresSave = false;

#define IS_DIRTY(T) \
	(static_cast<T*>(this)->m_bRequiresSave)

#ifdef _ATL_DLL
ATLAPI AtlIPersistStreamInit_Load(LPSTREAM pStm, ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk);
#else
ATLINLINE ATLAPI AtlIPersistStreamInit_Load(LPSTREAM pStm, ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk)
{
	ATLASSERT(pMap != NULL);
    if (pStm == NULL || pMap == NULL || pThis == NULL || pUnk == NULL)
        return E_INVALIDARG;

	HRESULT hr = S_OK;
	DWORD dwVer;
	hr = pStm->Read(&dwVer, sizeof(DWORD), NULL);
	if (FAILED(hr))
		return hr;
	if (dwVer > _ATL_VER)
		return E_FAIL;

	CComPtr<IDispatch> pDispatch;
	const IID* piidOld = NULL;
	for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	{
		if (pMap[i].szDesc == NULL)
			continue;

		// check if raw data entry
		if (pMap[i].dwSizeData != 0)
		{
			void* pData = (void*) (pMap[i].dwOffsetData + (DWORD_PTR)pThis);
			hr = pStm->Read(pData, pMap[i].dwSizeData, NULL);
			if (FAILED(hr))
				return hr;
			continue;
		}

		CComVariant var;

		hr = var.ReadFromStream(pStm);
		if (FAILED(hr))
			break;

		if (pMap[i].piidDispatch != piidOld)
		{
			pDispatch.Release();
			if (FAILED(pUnk->QueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			{
				ATLTRACE2(atlTraceCOM, 0, _T("Failed to get a dispatch pointer for property #%i\n"), i);
				hr = E_FAIL;
				break;
			}
			piidOld = pMap[i].piidDispatch;
		}

		if (FAILED(CComDispatchDriver::PutProperty(pDispatch, pMap[i].dispid, &var)))
		{
			ATLTRACE2(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			hr = E_FAIL;
			break;
		}
	}
	return hr;
}
#endif //_ATL_DLL

#ifdef _ATL_DLL
ATLAPI AtlIPersistStreamInit_Save(LPSTREAM pStm, BOOL fClearDirty, ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk);
#else
ATLINLINE ATLAPI AtlIPersistStreamInit_Save(LPSTREAM pStm,
	BOOL /* fClearDirty */, ATL_PROPMAP_ENTRY* pMap,
	void* pThis, IUnknown* pUnk)
{
	ATLASSERT(pMap != NULL);
    if (pStm == NULL || pMap == NULL || pThis == NULL || pUnk == NULL)
            return E_INVALIDARG;
	DWORD dw = _ATL_VER;
	HRESULT hr = pStm->Write(&dw, sizeof(DWORD), NULL);
	if (FAILED(hr))
		return hr;

	CComPtr<IDispatch> pDispatch;
	const IID* piidOld = NULL;
	for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	{
		if (pMap[i].szDesc == NULL)
			continue;

		// check if raw data entry
		if (pMap[i].dwSizeData != 0)
		{
			void* pData = (void*) (pMap[i].dwOffsetData + (DWORD_PTR)pThis);
			hr = pStm->Write(pData, pMap[i].dwSizeData, NULL);
			if (FAILED(hr))
				return hr;
			continue;
		}

		CComVariant var;
		if (pMap[i].piidDispatch != piidOld)
		{
			pDispatch.Release();
			if (FAILED(pUnk->QueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			{
				ATLTRACE2(atlTraceCOM, 0, _T("Failed to get a dispatch pointer for property #%i\n"), i);
				hr = E_FAIL;
				break;
			}
			piidOld = pMap[i].piidDispatch;
		}

		if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &var)))
		{
			ATLTRACE2(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			hr = E_FAIL;
			break;
		}

		hr = var.WriteToStream(pStm);
		if (FAILED(hr))
			break;
	}
	return hr;
}
#endif //_ATL_DLL


#ifdef _ATL_DLL
ATLAPI AtlIPersistPropertyBag_Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk);
#else
ATLINLINE ATLAPI AtlIPersistPropertyBag_Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk)
{
    if (pPropBag == NULL || pMap == NULL || pThis == NULL || pUnk == NULL)
            return E_INVALIDARG;

	USES_CONVERSION;
	CComPtr<IDispatch> pDispatch;
	const IID* piidOld = NULL;
	for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	{
        // disable for map chaining
		//if (pMap[i].szDesc == NULL)
		//	continue;

		CComVariant var;

		// If raw entry skip it - we don't handle it for property bags just yet
        HRESULT hr;
		if (pMap[i].dwSizeData != 0)
		{
			void* pData = (void*) (pMap[i].dwOffsetData + (DWORD_PTR)pThis);
            var.vt = pMap[i].vt;
			hr = pPropBag->Read(pMap[i].szDesc, &var, pErrorLog);
            // undone: this code assumes that var.vt is the same after the read
            // as it was when it got passed in. i.e it assumes that the bag won't
            // ever change the type which is an unsafe assumption.
            // we need to do something if pmap[i].vt != var.vt
			if (SUCCEEDED(hr))
			{
				// check the type - we only deal with limited set
				switch (pMap[i].vt)
				{
				case VT_UI1:
				case VT_I1:
					*((BYTE*)pData) = var.bVal;
					break;
				case VT_BOOL:
					*((VARIANT_BOOL*)pData) = var.boolVal;
					break;
                case VT_I2:
				case VT_UI2:
					*((short*)pData) = var.iVal;
					break;
                case VT_I4:
				case VT_UI4:
				case VT_INT:
				case VT_UINT:
					*((long*)pData) = var.lVal;
					break;
			    case VT_UNKNOWN:
					if (var.punkVal != NULL)
						var.punkVal->QueryInterface(*(pMap[i].piidUnknown), (void **) pData);
					else
						*((BYTE*)pData) = NULL;
					break;
			    case VT_DISPATCH:
					if (var.punkVal != NULL)
						var.punkVal->QueryInterface(__uuidof(IDispatch), (void **) pData);
					else
						*((BYTE*)pData) = NULL;
					break;
				case VT_VECTOR | VT_UI1:
					*(reinterpret_cast<SAFEARRAY **>(pData)) = var.parray;
					break;
                case VT_BSTR:
				case VT_BSTR_BLOB: {
					*(reinterpret_cast<BSTR*>(pData)) = var.bstrVal;
                    var.bstrVal = NULL;
					break;
				}
                case VT_CLSID:
                    if (var.vt == VT_BSTR) {
                        HRESULT hr = CLSIDFromString(var.bstrVal, reinterpret_cast<CLSID *>(pData));
                        if (FAILED(hr)) {
                            _ASSERT(false);
                            memset(pData, 0, sizeof(CLSID));
                        }
                    } else {
                        memset(pData, 0, sizeof(CLSID));
                    }
                    break;
				}
			}
			continue;
		}

        if (*pMap[i].piidDispatch == __uuidof(IChainPropMapFlagDummy)) {
            ATL_PROPMAP_ENTRY* (*pGetFunc)() = 
                    reinterpret_cast<ATL_PROPMAP_ENTRY*(*)()>(pMap[i].pclsidPropPage);
            ATL_PROPMAP_ENTRY *p = (*pGetFunc)();
            if (!p) {
                return E_FAIL;
            }
            hr = AtlIPersistPropertyBag_Load(pPropBag, pErrorLog, p, 
				reinterpret_cast<void*>(pMap[i].dwOffsetData + (DWORD_PTR)pThis), pUnk);
            if (FAILED(hr)) {
				ATLTRACE2(atlTraceCOM, 0, _T("Failed to Chain Property Bag idx = %d\n"), i);
                return hr;
            }
            continue;
        }
		if (pMap[i].piidDispatch != piidOld)
		{
			pDispatch.Release();
			if (FAILED(pUnk->QueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			{
				ATLTRACE2(atlTraceCOM, 0, _T("Failed to get a dispatch pointer for property #%i\n"), i);
				return E_FAIL;
			}
			piidOld = pMap[i].piidDispatch;
		}

		if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &var)))
		{
			ATLTRACE2(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			return E_FAIL;
		}

		hr = pPropBag->Read(pMap[i].szDesc, &var, pErrorLog);
		if (FAILED(hr))
		{
			if (hr == E_INVALIDARG)
			{
                USES_CONVERSION;
                LPCTSTR lp = OLE2CT(pMap[i].szDesc);
                if(lp == NULL)
                        ATLTRACE2(atlTraceCOM, 0, _T("Property not in Bag\n"));
                else
                        ATLTRACE2(atlTraceCOM, 0, _T("Property %s not in Bag\n"), lp);
			}
			else
			{
				// Many containers return different ERROR values for Member not found
                USES_CONVERSION;
                LPCTSTR lp = OLE2CT(pMap[i].szDesc);
                if(lp == NULL)
                        ATLTRACE2(atlTraceCOM, 0, _T("Error attempting to read Property from PropertyBag \n"));
                else
                        ATLTRACE2(atlTraceCOM, 0, _T("Error attempting to read Property %s from PropertyBag \n"), lp);
			}
			continue;
		}

		if (FAILED(CComDispatchDriver::PutProperty(pDispatch, pMap[i].dispid, &var)))
		{
			ATLTRACE2(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			return E_FAIL;
		}
	}
	return S_OK;
}
#endif //_ATL_DLL

#ifdef _ATL_DLL
ATLAPI AtlIPersistPropertyBag_Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties, ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk);
#else
ATLINLINE ATLAPI AtlIPersistPropertyBag_Save(LPPROPERTYBAG pPropBag,
	BOOL fClearDirty, BOOL fSaveAllProperties,
	ATL_PROPMAP_ENTRY* pMap, void* pThis, IUnknown* pUnk)
{
	if (pPropBag == NULL)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("PropBag pointer passed in was invalid\n"));
		return E_POINTER;
	}
    if (pMap == NULL || pThis == NULL || pUnk == NULL)
            return E_INVALIDARG;
    
	CComPtr<IDispatch> pDispatch;
	const IID* piidOld = NULL;
    HRESULT hr;
	for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
	{
        // disable for map chaining
        //if (pMap[i].szDesc == NULL)
		//	continue;

		CComVariant var;

		// If raw entry skip it - we don't handle it for property bags just yet
		if (pMap[i].dwSizeData != 0)
		{
			void* pData = (void*) (pMap[i].dwOffsetData + (DWORD_PTR)pThis);
			// check the type - we only deal with limited set
			var.vt = pMap[i].vt;
			bool bTypeOK = false;
			switch (pMap[i].vt)
			{
			case VT_UI1:
			case VT_I1:
				var.bVal = *((BYTE*)pData);
				bTypeOK = true;
				break;
			case VT_BOOL:
				var.boolVal = *((VARIANT_BOOL*)pData);
				bTypeOK = true;
				break;
            case VT_I2:
			case VT_UI2:
				var.iVal = *((short*)pData);
				bTypeOK = true;
				break;
            case VT_I4:
			case VT_UI4:
			case VT_INT:
			case VT_UINT:
				var.lVal = *((long*)pData);
				bTypeOK = true;
				break;
			case VT_UNKNOWN:
                var.punkVal = *(reinterpret_cast<IUnknown **>(pData));
                if (var.punkVal) {
                    var.punkVal->AddRef();
                    bTypeOK = true;
                }
				break;
			case VT_DISPATCH:
                var.pdispVal = *(reinterpret_cast<IDispatch **>(pData));
                if (var.pdispVal) {
                    var.pdispVal->AddRef();
                    bTypeOK = true;
                }
				break;
			case VT_ARRAY | VT_UI1:
				var.parray = reinterpret_cast<SAFEARRAY *>(pData);
				bTypeOK = true;
				break;
            case VT_BSTR_BLOB:
			case VT_BSTR: {
				BSTR *pBS = reinterpret_cast<BSTR*>(pData);
				if (*pBS != NULL) {
					UINT len = ::SysStringLen(*pBS);
	                var.bstrVal = ::SysAllocStringLen(*pBS, len);
                    bTypeOK = true;
				} else {
					var.bstrVal = NULL;
				}
				break;
			}
            case VT_CLSID: {
                var.vt = VT_BSTR;
                CComBSTR b(*(reinterpret_cast<GUID *>(pData)));
                hr = b.CopyTo(&var.bstrVal);
                _ASSERT(SUCCEEDED(hr));
                bTypeOK = true;
                break;
            }
			}
			if (bTypeOK)
			{
				hr = pPropBag->Write(pMap[i].szDesc, &var);
				if (FAILED(hr))
					return hr;
			}
            if (var.vt == VT_BSTR_BLOB) {
                var.vt = VT_BSTR;
            }
			continue;
		}

        if (*pMap[i].piidDispatch == __uuidof(IChainPropMapFlagDummy)) {
            ATL_PROPMAP_ENTRY* (*pGetFunc)() = 
                    reinterpret_cast<ATL_PROPMAP_ENTRY*(*)()>(pMap[i].pclsidPropPage);
            ATL_PROPMAP_ENTRY *p = (*pGetFunc)();
            if (!p) {
                return E_FAIL;
            }
            hr = AtlIPersistPropertyBag_Save(pPropBag, fClearDirty, fSaveAllProperties,
                p, 
                reinterpret_cast<void*>(pMap[i].dwOffsetData + (DWORD_PTR)pThis), pUnk);
            if (FAILED(hr)) {
				ATLTRACE2(atlTraceCOM, 0, _T("Failed to Chain Property Bag idx = %d\n"), i);
                return hr;
            }
            continue;
        }

		if (pMap[i].piidDispatch != piidOld)
		{
			pDispatch.Release();
			if (FAILED(pUnk->QueryInterface(*pMap[i].piidDispatch, (void**)&pDispatch)))
			{
				ATLTRACE2(atlTraceCOM, 0, _T("Failed to get a dispatch pointer for property #%i\n"), i);
				return E_FAIL;
			}
			piidOld = pMap[i].piidDispatch;
		}

		if (FAILED(CComDispatchDriver::GetProperty(pDispatch, pMap[i].dispid, &var)))
		{
			ATLTRACE2(atlTraceCOM, 0, _T("Invoked failed on DISPID %x\n"), pMap[i].dispid);
			return E_FAIL;
		}

		if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
		{
			if (var.punkVal == NULL)
			{
				ATLTRACE2(atlTraceCOM, 0, _T("Warning skipping empty IUnknown in Save\n"));
				continue;
			}
		}

		HRESULT hr = pPropBag->Write(pMap[i].szDesc, &var);
		if (FAILED(hr))
			return hr;
	}
	return S_OK;
}
#endif //_ATL_DLL


//////////////////////////////////////////////////////////////////////////////
// IPersistStreamInitImpl
template <class T>
class ATL_NO_VTABLE IPersistStreamInitImpl : public IPersistStreamInit
{
public:
	// IPersist
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStreamInitImpl::GetClassID\n"));
        ATLASSERT(pClassID != NULL);
        if (pClassID == NULL)
                return E_POINTER;
		*pClassID = T::GetObjectCLSID();
		return S_OK;
	}

	// IPersistStream
	STDMETHOD(IsDirty)()
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStreamInitImpl::IsDirty\n"));
		T* pT = static_cast<T*>(this);
		return (pT->m_bRequiresSave) ? S_OK : S_FALSE;
	}
	STDMETHOD(Load)(LPSTREAM pStm)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStreamInitImpl::Load\n"));
		T* pT = static_cast<T*>(this);
		return pT->IPersistStreamInit_Load(pStm, T::GetPropertyMap());
	}
	STDMETHOD(Save)(LPSTREAM pStm, BOOL fClearDirty)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStreamInitImpl::Save\n"));
		return pT->IPersistStreamInit_Save(pStm, fClearDirty, T::GetPropertyMap());
	}
	STDMETHOD(GetSizeMax)(ULARGE_INTEGER FAR* /* pcbSize */)
	{
		ATLTRACENOTIMPL(_T("IPersistStreamInitImpl::GetSizeMax"));
	}

	// IPersistStreamInit
	STDMETHOD(InitNew)()
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStreamInitImpl::InitNew\n"));
		return S_OK;
	}

	HRESULT IPersistStreamInit_Load(LPSTREAM pStm, ATL_PROPMAP_ENTRY* pMap)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr = AtlIPersistStreamInit_Load(pStm, pMap, pT, pT->GetUnknown());
		if (SUCCEEDED(hr))
			pT->m_bRequiresSave = FALSE;
		return hr;

	}
	HRESULT IPersistStreamInit_Save(LPSTREAM pStm, BOOL fClearDirty, ATL_PROPMAP_ENTRY* pMap)
	{
		T* pT = static_cast<T*>(this);
		return AtlIPersistStreamInit_Save(pStm, fClearDirty, pMap, pT, pT->GetUnknown());
	}
};

//////////////////////////////////////////////////////////////////////////////
// IPersistStorageImpl
template <class T>
class ATL_NO_VTABLE IPersistStorageImpl : public IPersistStorage
{
public:
	// IPersist
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::GetClassID\n"));
        ATLASSERT(pClassID != NULL);
        if (pClassID == NULL)
                return E_POINTER;
		*pClassID = T::GetObjectCLSID();
		return S_OK;
	}

	// IPersistStorage
	STDMETHOD(IsDirty)(void)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::IsDirty\n"));
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		return (p != NULL) ? p->IsDirty() : E_FAIL;
	}
	STDMETHOD(InitNew)(IStorage*)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::InitNew\n"));
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		return (p != NULL) ? p->InitNew() : E_FAIL;
	}
	STDMETHOD(Load)(IStorage* pStorage)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::Load\n"));
        if (pStorage == NULL)
                return E_INVALIDARG;
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		HRESULT hr = E_FAIL;
		if (p != NULL)
		{
			CComPtr<IStream> spStream;
			hr = pStorage->OpenStream(OLESTR("Contents"), NULL,
				STGM_DIRECT | STGM_SHARE_EXCLUSIVE, 0, &spStream);
			if (SUCCEEDED(hr))
				hr = p->Load(spStream);
		}
		return hr;
	}
	STDMETHOD(Save)(IStorage* pStorage, BOOL fSameAsLoad)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::Save\n"));
        if (pStorage == NULL)
                return E_INVALIDARG;
		CComPtr<IPersistStreamInit> p;
		p.p = IPSI_GetIPersistStreamInit();
		HRESULT hr = E_FAIL;
		if (p != NULL)
		{
			CComPtr<IStream> spStream;
			static LPCOLESTR vszContents = OLESTR("Contents");
			hr = pStorage->CreateStream(vszContents,
				STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
				0, 0, &spStream);
			if (SUCCEEDED(hr))
				hr = p->Save(spStream, fSameAsLoad);
		}
		return hr;
	}
	STDMETHOD(SaveCompleted)(IStorage* /* pStorage */)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::SaveCompleted\n"));
		return S_OK;
	}
	STDMETHOD(HandsOffStorage)(void)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistStorageImpl::HandsOffStorage\n"));
		return S_OK;
	}
private:
	IPersistStreamInit* IPSI_GetIPersistStreamInit();
};

template <class T>
IPersistStreamInit* IPersistStorageImpl<T>::IPSI_GetIPersistStreamInit()
{
	T* pT = static_cast<T*>(this);
	IPersistStreamInit* p;
	if (FAILED(pT->GetUnknown()->QueryInterface(IID_IPersistStreamInit, (void**)&p)))
		pT->_InternalQueryInterface(IID_IPersistStreamInit, (void**)&p);
	return p;
}


//////////////////////////////////////////////////////////////////////////////
// IPersistPropertyBagImpl
template <class T>
class ATL_NO_VTABLE IPersistPropertyBagImpl : public IPersistPropertyBag
{
public:
	// IPersist
	STDMETHOD(GetClassID)(CLSID *pClassID)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistPropertyBagImpl::GetClassID\n"));
        ATLASSERT(pClassID != NULL);
        if (pClassID == NULL)
                return E_POINTER;
		*pClassID = T::GetObjectCLSID();
		return S_OK;
	}

	// IPersistPropertyBag
	//
	STDMETHOD(InitNew)()
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistPropertyBagImpl::InitNew\n"));
		return S_OK;
	}
	STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistPropertyBagImpl::Load\n"));
		T* pT = static_cast<T*>(this);
		ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		ATLASSERT(pMap != NULL);
		return pT->IPersistPropertyBag_Load(pPropBag, pErrorLog, pMap);
	}
	STDMETHOD(Save)(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IPersistPropertyBagImpl::Save\n"));
		T* pT = static_cast<T*>(this);
		ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		ATLASSERT(pMap != NULL);
		return pT->IPersistPropertyBag_Save(pPropBag, fClearDirty, fSaveAllProperties, pMap);
	}
	HRESULT IPersistPropertyBag_Load(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog, ATL_PROPMAP_ENTRY* pMap)
	{
		ATL_LOCKT();
		HRESULT hr = AtlIPersistPropertyBag_Load(pPropBag, pErrorLog, pMap, pT, pT->GetUnknown());
		if (SUCCEEDED(hr)) {
			pT->m_bRequiresSave = FALSE;
		}
		return hr;
	}
	HRESULT IPersistPropertyBag_Save(LPPROPERTYBAG pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties, ATL_PROPMAP_ENTRY* pMap)
	{
		ATL_LOCKT();
		HRESULT hr = AtlIPersistPropertyBag_Save(pPropBag, fClearDirty, fSaveAllProperties, pMap, pT, pT->GetUnknown());
		if (SUCCEEDED(hr) && fClearDirty) {
			pT->m_bRequiresSave = FALSE;
		}
		return hr;
	}
};

//////////////////////////////////////////////////////////////////////////////
// CSecurityDescriptor
class CSecurityDescriptor
{
public:
        CSecurityDescriptor();
        ~CSecurityDescriptor();

public:
        HRESULT Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD);
        HRESULT AttachObject(HANDLE hObject);
        HRESULT Initialize();
        HRESULT InitializeFromProcessToken(BOOL bDefaulted = FALSE);
        HRESULT InitializeFromThreadToken(BOOL bDefaulted = FALSE, BOOL bRevertToProcessToken = TRUE);
        HRESULT SetOwner(PSID pOwnerSid, BOOL bDefaulted = FALSE);
        HRESULT SetGroup(PSID pGroupSid, BOOL bDefaulted = FALSE);
        HRESULT Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask);
        HRESULT Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask);
        HRESULT Revoke(LPCTSTR pszPrincipal);

        // utility functions
        // Any PSID you get from these functions should be free()ed
        static HRESULT SetPrivilege(LPCTSTR Privilege, BOOL bEnable = TRUE, HANDLE hToken = NULL);
        static HRESULT GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid);
        static HRESULT GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid = NULL);
        static HRESULT GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid = NULL, BOOL bOpenAsSelf = FALSE);
        static HRESULT CopyACL(PACL pDest, PACL pSrc);
        static HRESULT GetCurrentUserSID(PSID *ppSid);
        static HRESULT GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid);
        static HRESULT AddAccessAllowedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask);
        static HRESULT AddAccessDeniedACEToACL(PACL *Acl, LPCTSTR pszPrincipal, DWORD dwAccessMask);
        static HRESULT RemovePrincipalFromACL(PACL Acl, LPCTSTR pszPrincipal);

        operator PSECURITY_DESCRIPTOR()
        {
                return m_pSD;
        }

public:
        PSECURITY_DESCRIPTOR m_pSD;
        PSID m_pOwner;
        PSID m_pGroup;
        PACL m_pDACL;
        PACL m_pSACL;
};

inline CSecurityDescriptor::CSecurityDescriptor()
{
        m_pSD = NULL;
        m_pOwner = NULL;
        m_pGroup = NULL;
        m_pDACL = NULL;
        m_pSACL= NULL;
}

inline CSecurityDescriptor::~CSecurityDescriptor()
{
        if (m_pSD)
                delete m_pSD;
        if (m_pOwner)
                free(m_pOwner);
        if (m_pGroup)
                free(m_pGroup);
        if (m_pDACL)
                free(m_pDACL);
        if (m_pSACL)
                free(m_pSACL);
}

inline HRESULT CSecurityDescriptor::Initialize()
{
        if (m_pSD)
        {
                delete m_pSD;
                m_pSD = NULL;
        }
        if (m_pOwner)
        {
                free(m_pOwner);
                m_pOwner = NULL;
        }
        if (m_pGroup)
        {
                free(m_pGroup);
                m_pGroup = NULL;
        }
        if (m_pDACL)
        {
                free(m_pDACL);
                m_pDACL = NULL;
        }
        if (m_pSACL)
        {
                free(m_pSACL);
                m_pSACL = NULL;
        }

        ATLTRY(m_pSD = new SECURITY_DESCRIPTOR);
        if (m_pSD == NULL)
                return E_OUTOFMEMORY;

        if (!InitializeSecurityDescriptor(m_pSD, SECURITY_DESCRIPTOR_REVISION))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                delete m_pSD;
                m_pSD = NULL;
                ATLASSERT(FALSE);
                return hr;
        }
        return S_OK;
}

inline HRESULT CSecurityDescriptor::InitializeFromProcessToken(BOOL bDefaulted)
{
        PSID pUserSid = NULL;
        PSID pGroupSid = NULL;
        
        HRESULT hr = Initialize();
        if (FAILED(hr))
                return hr;
        hr = GetProcessSids(&pUserSid, &pGroupSid);
        if (SUCCEEDED(hr))
        {
                hr = SetOwner(pUserSid, bDefaulted);
                if (SUCCEEDED(hr))
                        hr = SetGroup(pGroupSid, bDefaulted);
        }
        if (pUserSid != NULL)
                free(pUserSid);
        if (pGroupSid != NULL)
                free(pGroupSid);

        if (FAILED(hr))
        {
                delete m_pSD;
                m_pSD = NULL;
                
                free(m_pOwner);
                m_pOwner = NULL;
                
                ATLASSERT(FALSE);                
        }
        return hr;
}

inline HRESULT CSecurityDescriptor::InitializeFromThreadToken(BOOL bDefaulted, BOOL bRevertToProcessToken)
{
        PSID pUserSid = NULL;
        PSID pGroupSid = NULL;
        
        HRESULT hr = Initialize();
        if (FAILED(hr))
                return hr;
        
        hr = GetThreadSids(&pUserSid, &pGroupSid);
        if (HRESULT_CODE(hr) == ERROR_NO_TOKEN && bRevertToProcessToken)
                hr = GetProcessSids(&pUserSid, &pGroupSid);
        if (SUCCEEDED(hr))
        {
                hr = SetOwner(pUserSid, bDefaulted);
                if (SUCCEEDED(hr))
                        hr = SetGroup(pGroupSid, bDefaulted);
        }
        if (pUserSid != NULL)
                free(pUserSid);
        if (pGroupSid != NULL)
                free(pGroupSid);

        if (FAILED(hr))
        {
                delete m_pSD;
                m_pSD = NULL;
                
                free(m_pOwner);
                m_pOwner = NULL;
                
                ATLASSERT(FALSE);                
        }
        return hr;
}

inline HRESULT CSecurityDescriptor::SetOwner(PSID pOwnerSid, BOOL bDefaulted)
{
        ATLASSERT(m_pSD);

        // Mark the SD as having no owner
        if (!SetSecurityDescriptorOwner(m_pSD, NULL, bDefaulted))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                return hr;
        }

        if (m_pOwner)
        {
                free(m_pOwner);
                m_pOwner = NULL;
        }

        // If they asked for no owner don't do the copy
        if (pOwnerSid == NULL)
                return S_OK;

        if (!IsValidSid(pOwnerSid))
        {
                return E_INVALIDARG;
        }
        
        // Make a copy of the Sid for the return value
        DWORD dwSize = GetLengthSid(pOwnerSid);

        m_pOwner = (PSID) malloc(dwSize);
        if (m_pOwner == NULL)
                return E_OUTOFMEMORY;
        if (!CopySid(dwSize, m_pOwner, pOwnerSid))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                free(m_pOwner);
                m_pOwner = NULL;
                return hr;
        }

        ATLASSERT(IsValidSid(m_pOwner));

        if (!SetSecurityDescriptorOwner(m_pSD, m_pOwner, bDefaulted))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                free(m_pOwner);
                m_pOwner = NULL;
                return hr;
        }

        return S_OK;
}

inline HRESULT CSecurityDescriptor::SetGroup(PSID pGroupSid, BOOL bDefaulted)
{
        ATLASSERT(m_pSD);

        // Mark the SD as having no Group
        if (!SetSecurityDescriptorGroup(m_pSD, NULL, bDefaulted))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                return hr;
        }

        if (m_pGroup)
        {
                free(m_pGroup);
                m_pGroup = NULL;
        }

        // If they asked for no Group don't do the copy
        if (pGroupSid == NULL)
                return S_OK;

        if (!IsValidSid(pGroupSid))
        {
                return E_INVALIDARG;
        }
        
        // Make a copy of the Sid for the return value
        DWORD dwSize = GetLengthSid(pGroupSid);

        m_pGroup = (PSID) malloc(dwSize);
        if (m_pGroup == NULL)
                return E_OUTOFMEMORY;
        if (!CopySid(dwSize, m_pGroup, pGroupSid))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                free(m_pGroup);
                m_pGroup = NULL;
                return hr;
        }

        ATLASSERT(IsValidSid(m_pGroup));

        if (!SetSecurityDescriptorGroup(m_pSD, m_pGroup, bDefaulted))
        {
                HRESULT hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                free(m_pGroup);
                m_pGroup = NULL;
                return hr;
        }

        return S_OK;
}

inline HRESULT CSecurityDescriptor::Allow(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
        HRESULT hr = AddAccessAllowedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
        if (SUCCEEDED(hr))
        {
                if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
                {
                        hr = AtlHresultFromLastError();
                }
        }
        return hr;
}

inline HRESULT CSecurityDescriptor::Deny(LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
        HRESULT hr = AddAccessDeniedACEToACL(&m_pDACL, pszPrincipal, dwAccessMask);
        if (SUCCEEDED(hr))
        {
                if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
                {
                        hr = AtlHresultFromLastError();
                }
        }
        return hr;
}

inline HRESULT CSecurityDescriptor::Revoke(LPCTSTR pszPrincipal)
{
        HRESULT hr = RemovePrincipalFromACL(m_pDACL, pszPrincipal);
        if (SUCCEEDED(hr))
        {
                if (!SetSecurityDescriptorDacl(m_pSD, TRUE, m_pDACL, FALSE))
                {
                        hr = AtlHresultFromLastError();
                }
        }
        return hr;
}

inline HRESULT CSecurityDescriptor::GetProcessSids(PSID* ppUserSid, PSID* ppGroupSid)
{
        BOOL bRes;
        HRESULT hr;
        HANDLE hToken = NULL;
        if (ppUserSid)
                *ppUserSid = NULL;
        if (ppGroupSid)
                *ppGroupSid = NULL;
        bRes = OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken);
        if (!bRes)
        {
                // Couldn't open process token
                hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                return hr;
        }
        hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
        CloseHandle(hToken);
        return hr;
}

inline HRESULT CSecurityDescriptor::GetThreadSids(PSID* ppUserSid, PSID* ppGroupSid, BOOL bOpenAsSelf)
{
        BOOL bRes;
        HRESULT hr;
        HANDLE hToken = NULL;
        if (ppUserSid)
                *ppUserSid = NULL;
        if (ppGroupSid)
                *ppGroupSid = NULL;
        bRes = OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, bOpenAsSelf, &hToken);
        if (!bRes)
        {
                // Couldn't open thread token
                hr = HRESULT_FROM_WIN32(GetLastError());
                return hr;
        }
        hr = GetTokenSids(hToken, ppUserSid, ppGroupSid);
        CloseHandle(hToken);
        return hr;
}

inline HRESULT CSecurityDescriptor::GetTokenSids(HANDLE hToken, PSID* ppUserSid, PSID* ppGroupSid)
{
        DWORD dwSize = 0;
        HRESULT hr = E_FAIL;
        DWORD dwErr;
        PTOKEN_USER ptkUser = NULL;
        PTOKEN_PRIMARY_GROUP ptkGroup = NULL;

        if (ppUserSid)
                *ppUserSid = NULL;
        if (ppGroupSid)
                *ppGroupSid = NULL;

        if (ppUserSid)
        {
                // Get length required for TokenUser by specifying buffer length of 0
                GetTokenInformation(hToken, TokenUser, NULL, 0, &dwSize);
                dwErr = GetLastError();
                if (dwErr != ERROR_INSUFFICIENT_BUFFER)
                {
                        // Expected ERROR_INSUFFICIENT_BUFFER
                        ATLASSERT(FALSE);
                        hr = AtlHresultFromWin32(dwErr);
                        goto failed;
                }

                ptkUser = (TOKEN_USER*) malloc(dwSize);
                if (ptkUser == NULL)
                {
                        hr = E_OUTOFMEMORY;
                        goto failed;
                }
                // Get Sid of process token.
                if (!GetTokenInformation(hToken, TokenUser, ptkUser, dwSize, &dwSize))
                {
                        // Couldn't get user info
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        ATLASSERT(FALSE);
                        goto failed;
                }

                // Make a copy of the Sid for the return value
                dwSize = GetLengthSid(ptkUser->User.Sid);

                PSID pSid;
                pSid = (PSID) malloc(dwSize);
                if (pSid == NULL)
                {
                        hr = E_OUTOFMEMORY;
                        goto failed;
                }
                if (!CopySid(dwSize, pSid, ptkUser->User.Sid))
                {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        free(pSid);
                        ATLASSERT(FALSE);
                        goto failed;
                }

                ATLASSERT(IsValidSid(pSid));
                *ppUserSid = pSid;
                free(ptkUser);
                ptkUser = NULL;
        }
        if (ppGroupSid)
        {
                // Get length required for TokenPrimaryGroup by specifying buffer length of 0
                GetTokenInformation(hToken, TokenPrimaryGroup, NULL, 0, &dwSize);
                dwErr = GetLastError();
                if (dwErr != ERROR_INSUFFICIENT_BUFFER)
                {
                        // Expected ERROR_INSUFFICIENT_BUFFER
                        ATLASSERT(FALSE);
                        hr = AtlHresultFromWin32(dwErr);
                        goto failed;
                }

                ptkGroup = (TOKEN_PRIMARY_GROUP*) malloc(dwSize);
                if (ptkGroup == NULL)
                {
                        hr = E_OUTOFMEMORY;
                        goto failed;
                }
                // Get Sid of process token.
                if (!GetTokenInformation(hToken, TokenPrimaryGroup, ptkGroup, dwSize, &dwSize))
                {
                        // Couldn't get user info
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        ATLASSERT(FALSE);
                        goto failed;
                }

                // Make a copy of the Sid for the return value
                dwSize = GetLengthSid(ptkGroup->PrimaryGroup);

                PSID pSid;
                pSid = (PSID) malloc(dwSize);
                if (pSid == NULL)
                {
                        hr = E_OUTOFMEMORY;
                        goto failed;
                }
                if (!CopySid(dwSize, pSid, ptkGroup->PrimaryGroup))
                {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        free(pSid);
                        ATLASSERT(FALSE);
                        goto failed;
                }

                ATLASSERT(IsValidSid(pSid));

                *ppGroupSid = pSid;
                free(ptkGroup);
                ptkGroup = NULL;
        }

        return S_OK;

failed:
        if (ptkUser)
                free(ptkUser);
        if (ptkGroup)
                free (ptkGroup);
        return hr;
}


inline HRESULT CSecurityDescriptor::GetCurrentUserSID(PSID *ppSid)
{
        HANDLE tkHandle;
        
        if (ppSid == NULL)
        {
                return E_POINTER;
        }

        if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &tkHandle))
        {
                TOKEN_USER *tkUser;
                DWORD tkSize;
                DWORD sidLength;

                // Call to get size information for alloc
                GetTokenInformation(tkHandle, TokenUser, NULL, 0, &tkSize);
                DWORD dwErr = GetLastError();
                if (dwErr != ERROR_INSUFFICIENT_BUFFER)
                {
                        // Expected ERROR_INSUFFICIENT_BUFFER
                        HRESULT hr = AtlHresultFromWin32(dwErr);
                        ATLASSERT(FALSE);                        
                        CloseHandle(tkHandle);
                        return hr;
                }                
                tkUser = (TOKEN_USER *) malloc(tkSize);
                if (tkUser == NULL)
                {
                        CloseHandle(tkHandle);
                        return E_OUTOFMEMORY;
                }

                // Now make the real call
                if (GetTokenInformation(tkHandle, TokenUser, tkUser, tkSize, &tkSize))
                {
                        sidLength = GetLengthSid(tkUser->User.Sid);
                        *ppSid = (PSID) malloc(sidLength);
                        if (*ppSid == NULL)
                        {
                                CloseHandle(tkHandle);
                                free(tkUser);                                
                                return E_OUTOFMEMORY;
                        }
                        if (!CopySid(sidLength, *ppSid, tkUser->User.Sid))
                        {
                                HRESULT hr = AtlHresultFromWin32(dwErr);
                                CloseHandle(tkHandle);
                                free(tkUser);
                                free(*ppSid);
                                *ppSid = NULL;
                                return hr;
                        }

                        CloseHandle(tkHandle);
                        free(tkUser);
                        return S_OK;
                }
                else
                {
                        HRESULT hr = AtlHresultFromLastError();                
                        CloseHandle(tkHandle);
                        free(tkUser);
                        return hr;
                }
        }
        return HRESULT_FROM_WIN32(GetLastError());
}


inline HRESULT CSecurityDescriptor::GetPrincipalSID(LPCTSTR pszPrincipal, PSID *ppSid)
{
        LPTSTR pszRefDomain = NULL;
        DWORD dwDomainSize = 0;
        DWORD dwSidSize = 0;
        SID_NAME_USE snu;
        
        if (ppSid == NULL)
        {
                return E_POINTER;
        }
        if (pszPrincipal == NULL)
        {
                return E_INVALIDARG;
        }

        // Call to get size info for alloc
        LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu);

        DWORD dwErr = GetLastError();
        if (dwErr != ERROR_INSUFFICIENT_BUFFER)
                return HRESULT_FROM_WIN32(dwErr);

        ATLTRY(pszRefDomain = new TCHAR[dwDomainSize]);
        if (pszRefDomain == NULL)
                return E_OUTOFMEMORY;

        *ppSid = (PSID) malloc(dwSidSize);
        if (*ppSid != NULL)
        {
                if (!LookupAccountName(NULL, pszPrincipal, *ppSid, &dwSidSize, pszRefDomain, &dwDomainSize, &snu))
                {
                        HRESULT hr = AtlHresultFromLastError();                
                        free(*ppSid);
                        *ppSid = NULL;
                        delete[] pszRefDomain;
                        return hr;
                }
                delete[] pszRefDomain;
                return S_OK;
        }
        delete[] pszRefDomain;
        return E_OUTOFMEMORY;
}


inline HRESULT CSecurityDescriptor::Attach(PSECURITY_DESCRIPTOR pSelfRelativeSD)
{
        PACL    pDACL = NULL;
        PACL    pSACL = NULL;
        BOOL    bDACLPresent, bSACLPresent;
        BOOL    bDefaulted;
        PSID    pUserSid;
        PSID    pGroupSid;
        
        if (pSelfRelativeSD == NULL ||!IsValidSecurityDescriptor(pSelfRelativeSD))
                return E_INVALIDARG;

        HRESULT hr = Initialize();
        if(FAILED(hr))
                return hr;

        // get the existing DACL.
        if (!GetSecurityDescriptorDacl(pSelfRelativeSD, &bDACLPresent, &pDACL, &bDefaulted))
                goto failed;

        if (bDACLPresent)
        {
                if (pDACL)
                {
                        // allocate new DACL.
                        m_pDACL = (PACL) malloc(pDACL->AclSize);
                        if (m_pDACL == NULL)
                        {
                                hr = E_OUTOFMEMORY;
                                goto failedMemory;
                        }

                        // initialize the DACL
                        if (!InitializeAcl(m_pDACL, pDACL->AclSize, ACL_REVISION))
                                goto failed;

                        // copy the ACES
                        hr = CopyACL(m_pDACL, pDACL);
                        if (FAILED(hr))
                                goto failedMemory;

                        if (!IsValidAcl(m_pDACL))
                                goto failed;
                }

                // set the DACL
                if (!SetSecurityDescriptorDacl(m_pSD, m_pDACL ? TRUE : FALSE, m_pDACL, bDefaulted))
                        goto failed;
        }

        // get the existing SACL.
        if (!GetSecurityDescriptorSacl(pSelfRelativeSD, &bSACLPresent, &pSACL, &bDefaulted))
                goto failed;

        if (bSACLPresent)
        {
                if (pSACL)
                {
                        // allocate new SACL.
                        m_pSACL = (PACL) malloc(pSACL->AclSize);
                        if (m_pSACL == NULL)
                        {
                                hr = E_OUTOFMEMORY;
                                goto failedMemory;
                        }

                        // initialize the SACL
                        if (!InitializeAcl(m_pSACL, pSACL->AclSize, ACL_REVISION))
                                goto failed;

                        // copy the ACES
                        hr = CopyACL(m_pSACL, pSACL);
                        if (FAILED(hr))
                                goto failedMemory;

                        if (!IsValidAcl(m_pSACL))
                                goto failed;
                }

                // set the SACL
                if (!SetSecurityDescriptorSacl(m_pSD, m_pSACL ? TRUE : FALSE, m_pSACL, bDefaulted))
                        goto failed;
        }

        if (!GetSecurityDescriptorOwner(pSelfRelativeSD, &pUserSid, &bDefaulted))
                goto failed;

        if (FAILED(SetOwner(pUserSid, bDefaulted)))
                goto failed;

        if (!GetSecurityDescriptorGroup(pSelfRelativeSD, &pGroupSid, &bDefaulted))
                goto failed;

        if (FAILED(SetGroup(pGroupSid, bDefaulted)))
                goto failed;

        if (!IsValidSecurityDescriptor(m_pSD))
        {
                hr = E_FAIL;
                goto failedMemory;
        }

        return S_OK;

failed:
        hr = AtlHresultFromLastError();

failedMemory:
        if (m_pDACL)
        {
                free(m_pDACL);
                m_pDACL = NULL;
        }
        if (m_pSACL)
        {
                free(m_pSACL);
                m_pSACL = NULL;
        }
        if (m_pSD)
        {
                free(m_pSD);
                m_pSD = NULL;
        }
        return hr;
}

inline HRESULT CSecurityDescriptor::AttachObject(HANDLE hObject)
{
        HRESULT hr;
        DWORD dwSize = 0;
        PSECURITY_DESCRIPTOR pSD = NULL;

        GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                DACL_SECURITY_INFORMATION, pSD, 0, &dwSize);

        DWORD dwErr = GetLastError();
        if (dwErr != ERROR_INSUFFICIENT_BUFFER)
                return HRESULT_FROM_WIN32(dwErr);

        pSD = (PSECURITY_DESCRIPTOR) malloc(dwSize);
        if (pSD == NULL)
                return E_OUTOFMEMORY;

        if (!GetKernelObjectSecurity(hObject, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION |
                DACL_SECURITY_INFORMATION, pSD, dwSize, &dwSize))
        {
                hr = HRESULT_FROM_WIN32(GetLastError());
                free(pSD);
                return hr;
        }

        hr = Attach(pSD);
        free(pSD);
        return hr;
}


inline HRESULT CSecurityDescriptor::CopyACL(PACL pDest, PACL pSrc)
{
        ACL_SIZE_INFORMATION aclSizeInfo;
        LPVOID pAce;
        ACE_HEADER *aceHeader;

        if (pDest == NULL)
                return E_POINTER;
        if (pSrc == NULL)
                return S_OK;
        
        if (!GetAclInformation(pSrc, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
                return HRESULT_FROM_WIN32(GetLastError());
        
        // Copy all of the ACEs to the new ACL
        for (UINT i = 0; i < aclSizeInfo.AceCount; i++)
        {
                if (!GetAce(pSrc, i, &pAce))
                        return HRESULT_FROM_WIN32(GetLastError());

                aceHeader = (ACE_HEADER *) pAce;

                if (!AddAce(pDest, ACL_REVISION, 0xffffffff, pAce, aceHeader->AceSize))
                        return HRESULT_FROM_WIN32(GetLastError());
        }

        return S_OK;
}

inline HRESULT CSecurityDescriptor::AddAccessDeniedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
        ACL_SIZE_INFORMATION aclSizeInfo;
        int aclSize;
        PSID principalSID;
        PACL oldACL, newACL = NULL;
        
        if (ppAcl == NULL)
                return E_POINTER;
                
        if (pszPrincipal == NULL)
                return E_INVALIDARG;

        oldACL = *ppAcl;

        HRESULT hr = GetPrincipalSID(pszPrincipal, &principalSID);
        if (FAILED(hr))
                return hr;

        aclSizeInfo.AclBytesInUse = 0;
        if (*ppAcl != NULL && 
                !GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
        {
                free(principalSID);        
                return AtlHresultFromLastError();
        }

        aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) +        // size of original ACL
                sizeof(ACCESS_DENIED_ACE) +                                         // size of ACE
                GetLengthSid(principalSID) -                                         // Actual size of SID
                sizeof(DWORD);                                                                        // subtract size of placeholder variable 
                                                                                                                // for SID in ACCESS_*_ACE structure

        newACL = (PACL) malloc(aclSize);
        if (newACL == NULL)
        {
                free(principalSID);        
                return E_OUTOFMEMORY;
        }

        if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
        {
                hr = AtlHresultFromLastError();
                free(newACL);
                free(principalSID);
                return hr;
        }

        if (!AddAccessDeniedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
        {
                hr = AtlHresultFromLastError();
                free(newACL);
                free(principalSID);
                return hr;
        }

        hr = CopyACL(newACL, oldACL);
        if (FAILED(hr))
        {
                free(newACL);
                free(principalSID);
                return hr;
        }

        *ppAcl = newACL;

        if (oldACL != NULL)
                free(oldACL);
        free(principalSID);
        return S_OK;
}


inline HRESULT CSecurityDescriptor::AddAccessAllowedACEToACL(PACL *ppAcl, LPCTSTR pszPrincipal, DWORD dwAccessMask)
{
        ACL_SIZE_INFORMATION aclSizeInfo;
        int aclSize;
        PSID principalSID;
        PACL oldACL, newACL = NULL;
        
        if (ppAcl == NULL)
                return E_POINTER;
                
        if (pszPrincipal == NULL)
                return E_INVALIDARG;

        oldACL = *ppAcl;

        HRESULT hr = GetPrincipalSID(pszPrincipal, &principalSID);
        if (FAILED(hr))
                return hr;

        aclSizeInfo.AclBytesInUse = 0;
        if (*ppAcl != NULL && 
                !GetAclInformation(oldACL, (LPVOID) &aclSizeInfo, sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
                return AtlHresultFromLastError();

        aclSize = aclSizeInfo.AclBytesInUse + sizeof(ACL) + // size of original ACL
                sizeof(ACCESS_ALLOWED_ACE) +                                         // size of ACE
                GetLengthSid(principalSID) -                                         // Actual size of SID
                sizeof(DWORD);                                                                        // subtract size of placeholder variable 
                                                                                                                // for SID in ACCESS_*_ACE structure

        newACL = (PACL) malloc(aclSize);
        if (newACL == NULL)
        {
                free(principalSID);        
                return E_OUTOFMEMORY;
        }

        if (!InitializeAcl(newACL, aclSize, ACL_REVISION))
        {
                hr = AtlHresultFromLastError();
                free(newACL);
                free(principalSID);
                return hr;
        }

        if (!AddAccessAllowedAce(newACL, ACL_REVISION2, dwAccessMask, principalSID))
        {
                hr = AtlHresultFromLastError();
                free(newACL);
                free(principalSID);
                return hr;
        }

        hr = CopyACL(newACL, oldACL);
        if (FAILED(hr))
        {
                free(newACL);
                free(principalSID);
                return hr;
        }

        *ppAcl = newACL;

        if (oldACL != NULL)
                free(oldACL);
        free(principalSID);
        return S_OK;
}

inline HRESULT CSecurityDescriptor::RemovePrincipalFromACL(PACL pAcl, LPCTSTR pszPrincipal)
{
        if (pAcl == NULL || pszPrincipal == NULL)
                return E_INVALIDARG;

        PSID principalSID;
        HRESULT hr = GetPrincipalSID(pszPrincipal, &principalSID);
        if (FAILED(hr))
                return hr;

        ACL_SIZE_INFORMATION aclSizeInfo;
        if (!GetAclInformation(pAcl, (LPVOID) &aclSizeInfo, (DWORD) sizeof(ACL_SIZE_INFORMATION), AclSizeInformation))
        {
                hr = AtlHresultFromLastError();
                aclSizeInfo.AceCount = 0;
        }
                
        for (ULONG i = aclSizeInfo.AceCount; i > 0; i--)
        {
                ULONG uIndex = i - 1;
                LPVOID ace;        
                if (!GetAce(pAcl, uIndex, &ace))
                {
                        hr = AtlHresultFromLastError();
                        break;
                }

                ACE_HEADER *aceHeader = (ACE_HEADER *) ace;

                if (aceHeader->AceType == ACCESS_ALLOWED_ACE_TYPE)
                {
                        ACCESS_ALLOWED_ACE *accessAllowedAce = (ACCESS_ALLOWED_ACE *) ace;
                        if (EqualSid(principalSID, (PSID) &accessAllowedAce->SidStart))
                        {
                                DeleteAce(pAcl, uIndex);
                        }
                } 
                else if (aceHeader->AceType == ACCESS_DENIED_ACE_TYPE)
                {
                        ACCESS_DENIED_ACE *accessDeniedAce = (ACCESS_DENIED_ACE *) ace;
                        if (EqualSid(principalSID, (PSID) &accessDeniedAce->SidStart))
                        {
                                DeleteAce(pAcl, uIndex);
                        }
                } 
                else if (aceHeader->AceType == SYSTEM_AUDIT_ACE_TYPE)
                {
                        SYSTEM_AUDIT_ACE *systemAuditAce = (SYSTEM_AUDIT_ACE *) ace;
                        if (EqualSid(principalSID, (PSID) &systemAuditAce->SidStart))
                        {
                                DeleteAce(pAcl, uIndex);
                        }
                }
        }
        free(principalSID);
        return hr;
}

inline HRESULT CSecurityDescriptor::SetPrivilege(LPCTSTR privilege, BOOL bEnable, HANDLE hToken)
{
        HRESULT hr;
        TOKEN_PRIVILEGES tpPrevious;
        TOKEN_PRIVILEGES tp;
        DWORD  cbPrevious = sizeof(TOKEN_PRIVILEGES);
        LUID   luid;
        HANDLE hTokenUsed;

        // if no token specified open process token
        if (hToken == 0)
        {
                if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hTokenUsed))
                {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        ATLASSERT(FALSE);
                        return hr;
                }
        }
        else
                hTokenUsed = hToken;

        if (!LookupPrivilegeValue(NULL, privilege, &luid ))
        {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                if (hToken == 0)
                        CloseHandle(hTokenUsed);
                return hr;
        }

        tp.PrivilegeCount = 1;
        tp.Privileges[0].Luid = luid;
        tp.Privileges[0].Attributes = 0;

        if (!AdjustTokenPrivileges(hTokenUsed, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), &tpPrevious, &cbPrevious))
        {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                if (hToken == 0)
                        CloseHandle(hTokenUsed);
                return hr;
        }

        tpPrevious.PrivilegeCount = 1;
        tpPrevious.Privileges[0].Luid = luid;

        if (bEnable)
                tpPrevious.Privileges[0].Attributes |= (SE_PRIVILEGE_ENABLED);
        else
                tpPrevious.Privileges[0].Attributes ^= (SE_PRIVILEGE_ENABLED & tpPrevious.Privileges[0].Attributes);

        if (!AdjustTokenPrivileges(hTokenUsed, FALSE, &tpPrevious, cbPrevious, NULL, NULL))
        {
                hr = HRESULT_FROM_WIN32(GetLastError());
                ATLASSERT(FALSE);
                if (hToken == 0)
                        CloseHandle(hTokenUsed);
                return hr;
        }
        return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// COM Objects

#define DECLARE_PROTECT_FINAL_CONSTRUCT()\
	void InternalFinalConstructAddRef() {InternalAddRef();}\
	void InternalFinalConstructRelease() {InternalRelease();}

template <class T1>
class CComCreator
{
public:
	static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv)
	{
        _ATL_VALIDATE_OUT_POINTER(ppv);
		HRESULT hRes = E_OUTOFMEMORY;
		T1* p = NULL;
		ATLTRY(p = new T1(pv))
		if (p != NULL)
		{
			p->SetVoid(pv);
			p->InternalFinalConstructAddRef();
			hRes = p->FinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes == S_OK)
				hRes = p->QueryInterface(riid, ppv);
			if (hRes != S_OK)
				delete p;
		}
		return hRes;
	}
};

template <class T1>
class CComInternalCreator
{
public:
	static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv)
	{
        _ATL_VALIDATE_OUT_POINTER(ppv);
		HRESULT hRes = E_OUTOFMEMORY;
		T1* p = NULL;
		ATLTRY(p = new T1(pv))
		if (p != NULL)
		{
			p->SetVoid(pv);
			p->InternalFinalConstructAddRef();
			hRes = p->FinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes == S_OK)
				hRes = p->_InternalQueryInterface(riid, ppv);
			if (hRes != S_OK)
				delete p;
		}
		return hRes;
	}
};

template <HRESULT hr>
class CComFailCreator
{
public:
        static HRESULT WINAPI CreateInstance(void*, REFIID, LPVOID* ppv)
        {
                _ATL_VALIDATE_OUT_POINTER(ppv);
                return hr;
        }
};

template <class T1, class T2>
class CComCreator2
{
public:
        static HRESULT WINAPI CreateInstance(void* pv, REFIID riid, LPVOID* ppv)
        {
                // Assert Only. Validation done in functions called from here
                ATLASSERT(ppv != NULL && *ppv == NULL);
                return (pv == NULL) ? 
                        T1::CreateInstance(NULL, riid, ppv) : 
                        T2::CreateInstance(pv, riid, ppv);
        }
};

#define DECLARE_NOT_AGGREGATABLE(x) public:\
	typedef CComCreator2< CComCreator< CComObject< x > >, CComFailCreator<CLASS_E_NOAGGREGATION> > _CreatorClass;
#define DECLARE_AGGREGATABLE(x) public:\
	typedef CComCreator2< CComCreator< CComObject< x > >, CComCreator< CComAggObject< x > > > _CreatorClass;
#define DECLARE_ONLY_AGGREGATABLE(x) public:\
	typedef CComCreator2< CComFailCreator<E_FAIL>, CComCreator< CComAggObject< x > > > _CreatorClass;
#define DECLARE_POLY_AGGREGATABLE(x) public:\
	typedef CComCreator< CComPolyObject< x > > _CreatorClass;

struct _ATL_CREATORDATA
{
	_ATL_CREATORFUNC* pFunc;
};

template <class Creator>
class _CComCreatorData
{
public:
	static _ATL_CREATORDATA data;
};

template <class Creator>
_ATL_CREATORDATA _CComCreatorData<Creator>::data = {Creator::CreateInstance};

struct _ATL_CACHEDATA
{
	DWORD dwOffsetVar;
	_ATL_CREATORFUNC* pFunc;
};

template <class Creator, DWORD dwVar>
class _CComCacheData
{
public:
	static _ATL_CACHEDATA data;
};

template <class Creator, DWORD dwVar>
_ATL_CACHEDATA _CComCacheData<Creator, dwVar>::data = {dwVar, Creator::CreateInstance};

struct _ATL_CHAINDATA
{
	DWORD_PTR dwOffset;
	const _ATL_INTMAP_ENTRY* (WINAPI *pFunc)();
};

template <class base, class derived>
class _CComChainData
{
public:
	static _ATL_CHAINDATA data;
};

template <class base, class derived>
_ATL_CHAINDATA _CComChainData<base, derived>::data =
	{offsetofclass(base, derived), base::_GetEntries};

template <class T, const CLSID* pclsid>
class CComAggregateCreator
{
public:
        static HRESULT WINAPI CreateInstance(void* pv, REFIID/*riid*/, LPVOID* ppv)
        {
                // Real check will be made in the call to CoCreateInstance
                ATLASSERT(ppv != NULL && *ppv == NULL);

                ATLASSERT(pv != NULL);
                if (pv == NULL)
                        return E_INVALIDARG;
                
                T* p = (T*) pv;
                // Add the following line to your object if you get a message about
                // GetControllingUnknown() being undefined
                // DECLARE_GET_CONTROLLING_UNKNOWN()
                return CoCreateInstance(*pclsid, p->GetControllingUnknown(), CLSCTX_INPROC, IID_IUnknown, ppv);
        }
};

// this enables on-demand creation of ftm via autoaggregate macro
template <class T>
class CComFTMCreator
{
public:
	static HRESULT WINAPI CreateInstance(void* pv, REFIID/*riid*/, LPVOID* ppv)
	{
		ATLASSERT(*ppv == NULL);
		ATLASSERT(pv != NULL);
		T* p = (T*) pv;
		// Add the following line to your object if you get a message about
		// GetControllingUnknown() being undefined
		// DECLARE_GET_CONTROLLING_UNKNOWN()
		return CoCreateFreeThreadedMarshaler(p->GetControllingUnknown(), reinterpret_cast<LPUNKNOWN *>(ppv));
	}
};

#ifdef _ATL_DEBUG
#define DEBUG_QI_ENTRY(x) \
		{NULL, \
		(DWORD_PTR)_T(#x), \
		(_ATL_CREATORARGFUNC*)0},
#else
#define DEBUG_QI_ENTRY(x)
#endif //_ATL_DEBUG

#ifdef _ATL_DEBUG_INTERFACES
#define _ATL_DECLARE_GET_UNKNOWN(x)\
	IUnknown* GetUnknown() \
	{ \
		IUnknown* p; \
		_Module.AddNonAddRefThunk(_GetRawUnknown(), _T(#x), &p); \
		return p; \
	}
#else
#define _ATL_DECLARE_GET_UNKNOWN(x) IUnknown* GetUnknown() {return _GetRawUnknown();}
#endif

//If you get a message that FinalConstruct is ambiguous then you need to
// override it in your class and call each base class' version of this
#define BEGIN_COM_MAP(x) public: \
	typedef x _ComMapClass; \
	static HRESULT WINAPI _Cache(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)\
	{\
		_ComMapClass* p = (_ComMapClass*)pv;\
		p->Lock();\
		HRESULT hRes = CComObjectRootBase::_Cache(pv, iid, ppvObject, dw);\
		p->Unlock();\
		return hRes;\
	}\
	IUnknown* _GetRawUnknown() \
	{ ATLASSERT(_GetEntries()[0].pFunc == _ATL_SIMPLEMAPENTRY); return (IUnknown*)((DWORD_PTR)this+_GetEntries()->dw); } \
	_ATL_DECLARE_GET_UNKNOWN(x)\
	HRESULT _InternalQueryInterface(REFIID iid, void** ppvObject) \
	{ return InternalQueryInterface(this, _GetEntries(), iid, ppvObject); } \
	const static _ATL_INTMAP_ENTRY* WINAPI _GetEntries() { \
	static const _ATL_INTMAP_ENTRY _entries[] = { DEBUG_QI_ENTRY(x)

#define DECLARE_GET_CONTROLLING_UNKNOWN() public:\
	virtual IUnknown* GetControllingUnknown() {return GetUnknown();}

#if !defined(_ATL_NO_UUIDOF)
#define _ATL_IIDOF(x) __uuidof(x)
#else
#define _ATL_IIDOF(x) IID_##x
#endif

#define COM_INTERFACE_ENTRY_BREAK(x)\
	{&_ATL_IIDOF(x), \
	NULL, \
	_Break},

#define COM_INTERFACE_ENTRY_NOINTERFACE(x)\
	{&_ATL_IIDOF(x), \
	NULL, \
	_NoInterface},

#define COM_INTERFACE_ENTRY(x)\
	{&_ATL_IIDOF(x), \
	offsetofclass(x, _ComMapClass), \
	_ATL_SIMPLEMAPENTRY},

#define COM_INTERFACE_ENTRY_IID(iid, x)\
	{&iid,\
	offsetofclass(x, _ComMapClass),\
	_ATL_SIMPLEMAPENTRY},

// The impl macros are now obsolete
#define COM_INTERFACE_ENTRY_IMPL(x)\
	COM_INTERFACE_ENTRY_IID(_ATL_IIDOF(x), x##Impl<_ComMapClass>)

#define COM_INTERFACE_ENTRY_IMPL_IID(iid, x)\
	COM_INTERFACE_ENTRY_IID(iid, x##Impl<_ComMapClass>)
//

#define COM_INTERFACE_ENTRY2(x, x2)\
	{&_ATL_IIDOF(x),\
	(DWORD_PTR)((x*)(x2*)((_ComMapClass*)8))-8,\
	_ATL_SIMPLEMAPENTRY},

#define COM_INTERFACE_ENTRY2_IID(iid, x, x2)\
	{&iid,\
	(DWORD_PTR)((x*)(x2*)((_ComMapClass*)8))-8,\
	_ATL_SIMPLEMAPENTRY},

#define COM_INTERFACE_ENTRY_FUNC(iid, dw, func)\
	{&iid, \
	dw, \
	func},

#define COM_INTERFACE_ENTRY_FUNC_BLIND(dw, func)\
	{NULL, \
	dw, \
	func},

#define COM_INTERFACE_ENTRY_TEAR_OFF(iid, x)\
	{&iid,\
	(DWORD_PTR)&_CComCreatorData<\
		CComInternalCreator< CComTearOffObject< x > >\
		>::data,\
	_Creator},

#define COM_INTERFACE_ENTRY_CACHED_TEAR_OFF(iid, x, punk)\
	{&iid,\
	(DWORD_PTR)&_CComCacheData<\
		CComCreator< CComCachedTearOffObject< x > >,\
		 offsetof(_ComMapClass, punk)\
		>::data,\
	_Cache},

#define COM_INTERFACE_ENTRY_AGGREGATE(iid, punk)\
	{&iid,\
	 offsetof(_ComMapClass, punk),\
	_Delegate},

#define COM_INTERFACE_ENTRY_AGGREGATE_BLIND(punk)\
	{NULL,\
	 offsetof(_ComMapClass, punk),\
	_Delegate},

#define COM_INTERFACE_ENTRY_AUTOAGGREGATE(iid, punk, clsid)\
	{&iid,\
	(DWORD_PTR)&_CComCacheData<\
		CComAggregateCreator<_ComMapClass, &clsid>,\
		offsetof(_ComMapClass, punk)\
		>::data,\
	_Cache},

#define COM_INTERFACE_ENTRY_AUTOAGGREGATE_BLIND(punk, clsid)\
	{NULL,\
	(DWORD_PTR)&_CComCacheData<\
		CComAggregateCreator<_ComMapClass, &clsid>,\
		offsetof(_ComMapClass, punk)\
		>::data,\
	_Cache},

#define COM_INTERFACE_ENTRY_CHAIN(classname)\
	{NULL,\
	(DWORD_PTR)&_CComChainData<classname, _ComMapClass>::data,\
	_Chain},

#define COM_INTERFACE_ENTRY_AUTOAGGREGATE_FTM(punk) \
	{&IID_IMarshal,\
	(DWORD_PTR)&_CComCacheData<CComFTMCreator<_ComMapClass>, offsetof(_ComMapClass, punk)>::data,\
	_Cache},

#ifdef _ATL_DEBUG
#define END_COM_MAP() {NULL, 0, 0}}; return &_entries[1];} \
	virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0; \
	virtual ULONG STDMETHODCALLTYPE Release( void) = 0; \
	STDMETHOD(QueryInterface)(REFIID, void**) = 0;
#else
#define END_COM_MAP() {NULL, 0, 0}}; return _entries;} \
	virtual ULONG STDMETHODCALLTYPE AddRef( void) = 0; \
	virtual ULONG STDMETHODCALLTYPE Release( void) = 0; \
	STDMETHOD(QueryInterface)(REFIID, void**) = 0;
#endif // _ATL_DEBUG

#define END_COM_MAP_WITH_FTM() \
	COM_INTERFACE_ENTRY_AUTOAGGREGATE_FTM(punkFTM.p) \
	END_COM_MAP(); \
	CComPtr<IUnknown> punkFTM; \
	DECLARE_GET_CONTROLLING_UNKNOWN()	

#define BEGIN_CATEGORY_MAP(x)\
   static const struct _ATL_CATMAP_ENTRY* GetCategoryMap() {\
   static const struct _ATL_CATMAP_ENTRY pMap[] = {
#define IMPLEMENTED_CATEGORY( catid ) { _ATL_CATMAP_ENTRY_IMPLEMENTED, &catid },
#define REQUIRED_CATEGORY( catid ) { _ATL_CATMAP_ENTRY_REQUIRED, &catid },
#define END_CATEGORY_MAP()\
   { _ATL_CATMAP_ENTRY_END, NULL } };\
   return( pMap ); }

#define BEGIN_OBJECT_MAP(x) static _ATL_OBJMAP_ENTRY x[] = {
#define END_OBJECT_MAP()   {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}};
#define OBJECT_ENTRY(clsid, class) {&clsid, class::UpdateRegistry, class::_ClassFactoryCreatorClass::CreateInstance, class::_CreatorClass::CreateInstance, NULL, 0, class::GetObjectDescription, class::GetCategoryMap, class::ObjectMain },
#define OBJECT_ENTRY_NON_CREATEABLE(class) {&CLSID_NULL, class::UpdateRegistry, NULL, NULL, NULL, 0, NULL, class::GetCategoryMap, class::ObjectMain },

#define BEGIN_EXTERN_OBJECT_MAP(x) \
                            static _ATL_OBJMAP_ENTRY* x = NULL; \
                            static _ATL_OBJMAP_ENTRY NULL_OBJECT_ENTRY = {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL}; \
                            static _ATL_OBJMAP_ENTRY* _E##x [] = {
#define END_EXTERN_OBJECT_MAP()   &NULL_OBJECT_ENTRY }; 
#define DECLARE_EXTERN_OBJECT_ENTRY(classname) extern _ATL_OBJMAP_ENTRY classname##OBJMAP_ENTRY;
#define EXTERN_OBJECT_ENTRY(classname) &##classname##OBJMAP_ENTRY,
#define DEFINE_EXTERN_OBJECT_ENTRY(clsid, classname) \
   _ATL_OBJMAP_ENTRY classname##OBJMAP_ENTRY =    \
    {&clsid, classname::UpdateRegistry, classname::_ClassFactoryCreatorClass::CreateInstance, classname::_CreatorClass::CreateInstance, NULL, 0, classname::GetObjectDescription, classname::GetCategoryMap, classname::ObjectMain };

inline _ATL_OBJMAP_ENTRY* CreateObjectMapFromExternMap(_ATL_OBJMAP_ENTRY** p) {
    int i;
    for (i = 0; p[i]->pclsid != NULL; ++i);
    _ATL_OBJMAP_ENTRY* pRet = new _ATL_OBJMAP_ENTRY[i+1];
    for (i = 0; p[i]->pclsid != NULL; ++i) {
        memcpy(&pRet[i], p[i], sizeof(*pRet));
    }
    memcpy(&pRet[i], p[i], sizeof(*pRet));

    return pRet;
}

#define INTERNALIZE_OBJMAP(x) x = CreateObjectMapFromExternMap(_E##x);
#define DESTROY_OBJMAP(x) delete[] x;

#ifdef _ATL_DEBUG
extern HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr);
#endif // _ATL_DEBUG


// the functions in this class don't need to be virtual because
// they are called from CComObject
class CComObjectRootBase
{
public:
	CComObjectRootBase()
	{
		m_dwRef = 0L;
	}
	HRESULT FinalConstruct()
	{
		return S_OK;
	}
	// For library initialization only
	HRESULT _AtlFinalConstruct()
	{
		return S_OK;
	}
	void FinalRelease() {}
	void _AtlFinalRelease() {}

	//ObjectMain is called during Module::Init and Module::Term
	static void WINAPI ObjectMain(bool /* bStarting */) {}

	static HRESULT WINAPI InternalQueryInterface(void* pThis,
		const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject)
	{
		ATLASSERT(pThis != NULL);
		// First entry in the com map should be a simple map entry
		ATLASSERT(pEntries->pFunc == _ATL_SIMPLEMAPENTRY);
	#if defined(_ATL_DEBUG_INTERFACES) || defined(_ATL_DEBUG_QI)
		LPCTSTR pszClassName = (LPCTSTR) pEntries[-1].dw;
	#endif // _ATL_DEBUG_INTERFACES
		HRESULT hRes = AtlInternalQueryInterface(pThis, pEntries, iid, ppvObject);
	#ifdef _ATL_DEBUG_INTERFACES
		_Module.AddThunk((IUnknown**)ppvObject, pszClassName, iid);
	#endif // _ATL_DEBUG_INTERFACES
		return _ATLDUMPIID(iid, pszClassName, hRes);
	}

//Outer funcs
	ULONG OuterAddRef()
	{
		return m_pOuterUnknown->AddRef();
	}
	ULONG OuterRelease()
	{
		return m_pOuterUnknown->Release();
	}
	HRESULT OuterQueryInterface(REFIID iid, void ** ppvObject)
	{
		return m_pOuterUnknown->QueryInterface(iid, ppvObject);
	}

	void SetVoid(void*) {}
	void InternalFinalConstructAddRef() {}
	void InternalFinalConstructRelease()
	{
		ATLASSERT(m_dwRef == 0);
	}
	// If this assert occurs, your object has probably been deleted
	// Try using DECLARE_PROTECT_FINAL_CONSTRUCT()


	static HRESULT WINAPI _Break(void* /* pv */, REFIID iid, void** /* ppvObject */, DWORD_PTR /* dw */)
	{
		iid;
		_ATLDUMPIID(iid, _T("Break due to QI for interface "), S_OK);
		DebugBreak();
		return S_FALSE;
	}
	static HRESULT WINAPI _NoInterface(void* /* pv */, REFIID /* iid */, void** /* ppvObject */, DWORD_PTR /* dw */)
	{
		return E_NOINTERFACE;
	}
	static HRESULT WINAPI _Creator(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)
	{
		_ATL_CREATORDATA* pcd = (_ATL_CREATORDATA*)dw;
		return pcd->pFunc(pv, iid, ppvObject);
	}
	static HRESULT WINAPI _Delegate(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)
	{
		HRESULT hRes = E_NOINTERFACE;
		IUnknown* p = *(IUnknown**)((DWORD_PTR)pv + dw);
		if (p != NULL)
			hRes = p->QueryInterface(iid, ppvObject);
		return hRes;
	}

	static HRESULT WINAPI _Chain(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)
    {
		_ATL_CHAINDATA* pcd = (_ATL_CHAINDATA*)dw;
		void* p = (void*)((DWORD_PTR)pv + pcd->dwOffset);
		return InternalQueryInterface(p, pcd->pFunc(), iid, ppvObject);
    }

	static HRESULT WINAPI _Cache(void* pv, REFIID iid, void** ppvObject, DWORD_PTR dw)
	{
		HRESULT hRes = E_NOINTERFACE;
		_ATL_CACHEDATA* pcd = (_ATL_CACHEDATA*)dw;
		IUnknown** pp = (IUnknown**)((DWORD_PTR)pv + pcd->dwOffsetVar);
		if (*pp == NULL)
			hRes = pcd->pFunc(pv, IID_IUnknown, (void**)pp);
		if (*pp != NULL)
			hRes = (*pp)->QueryInterface(iid, ppvObject);
		return hRes;
	}

	union
	{
		long m_dwRef;
		IUnknown* m_pOuterUnknown;
	};
};

//foward declaration
template <class ThreadModel>
class CComObjectRootEx;

template <class ThreadModel>
class CComObjectLockT
{
public:
	CComObjectLockT(CComObjectRootEx<ThreadModel>* p)
	{
		if (p)
			p->Lock();
		m_p = p;
	}

	~CComObjectLockT()
	{
		if (m_p)
			m_p->Unlock();
	}
	CComObjectRootEx<ThreadModel>* m_p;
};

template <> class CComObjectLockT<CComSingleThreadModel>;

template <class ThreadModel>
class CComObjectRootEx : public CComObjectRootBase
{
public:
	typedef ThreadModel _ThreadModel;
	typedef _ThreadModel::AutoCriticalSection _CritSec;
	typedef CComObjectLockT<_ThreadModel> ObjectLock;

	ULONG InternalAddRef()
	{
		ATLASSERT(m_dwRef != -1L);
		return _ThreadModel::Increment(&m_dwRef);
	}
	ULONG InternalRelease()
	{
		ATLASSERT(m_dwRef > 0);
		return _ThreadModel::Decrement(&m_dwRef);
	}

	void Lock() {m_critsec.Lock();}
	void Unlock() {m_critsec.Unlock();}
private:
	_CritSec m_critsec;
};

template <>
class CComObjectRootEx<CComSingleThreadModel> : public CComObjectRootBase
{
public:
	typedef CComSingleThreadModel _ThreadModel;
	typedef _ThreadModel::AutoCriticalSection _CritSec;
	typedef CComObjectLockT<_ThreadModel> ObjectLock;

	ULONG InternalAddRef()
	{
		ATLASSERT(m_dwRef != -1L);
		return _ThreadModel::Increment(&m_dwRef);
	}
	ULONG InternalRelease()
	{
		return _ThreadModel::Decrement(&m_dwRef);
	}

	void Lock() {}
	void Unlock() {}
};

template <>
class CComObjectLockT<CComSingleThreadModel>
{
public:
	CComObjectLockT(CComObjectRootEx<CComSingleThreadModel>*) {}
	~CComObjectLockT() {}
};

typedef CComObjectRootEx<CComObjectThreadModel> CComObjectRoot;

#if defined(_WINDLL) | defined(_USRDLL)
#define DECLARE_CLASSFACTORY_EX(cf) typedef CComCreator< CComObjectCached< cf > > _ClassFactoryCreatorClass;
#else
// don't let class factory refcount influence lock count
#define DECLARE_CLASSFACTORY_EX(cf) typedef CComCreator< CComObjectNoLock< cf > > _ClassFactoryCreatorClass;
#endif
#define DECLARE_CLASSFACTORY() DECLARE_CLASSFACTORY_EX(CComClassFactory)
#define DECLARE_CLASSFACTORY2(lic) DECLARE_CLASSFACTORY_EX(CComClassFactory2<lic>)
#define DECLARE_CLASSFACTORY_AUTO_THREAD() DECLARE_CLASSFACTORY_EX(CComClassFactoryAutoThread)
#define DECLARE_CLASSFACTORY_SINGLETON(obj) DECLARE_CLASSFACTORY_EX(CComClassFactorySingleton<obj>)

#define DECLARE_OBJECT_DESCRIPTION(x)\
	static LPCTSTR WINAPI GetObjectDescription()\
	{\
		return _T(x);\
	}

#define DECLARE_NO_REGISTRY()\
	static HRESULT WINAPI UpdateRegistry(BOOL /*bRegister*/)\
	{return S_OK;}

#define DECLARE_REGISTRY(class, pid, vpid, nid, flags)\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
	{\
		return _Module.UpdateRegistryClass(GetObjectCLSID(), pid, vpid, nid,\
			flags, bRegister);\
	}

#define DECLARE_REGISTRY_RESOURCE(x)\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
	{\
	return _Module.UpdateRegistryFromResource(_T(#x), bRegister);\
	}

#define DECLARE_REGISTRY_RESOURCEID(x)\
	static HRESULT WINAPI UpdateRegistry(BOOL bRegister)\
	{\
	return _Module.UpdateRegistryFromResource(x, bRegister);\
	}

//DECLARE_STATIC_* provided for backward compatibility
#ifdef _ATL_STATIC_REGISTRY
#define DECLARE_STATIC_REGISTRY_RESOURCE(x) DECLARE_REGISTRY_RESOURCE(x)
#define DECLARE_STATIC_REGISTRY_RESOURCEID(x) DECLARE_REGISTRY_RESOURCEID(x)
#endif //_ATL_STATIC_REGISTRY

template<class Base> class CComObject; // fwd decl

template <class Owner, class ThreadModel = CComObjectThreadModel>
class CComTearOffObjectBase : public CComObjectRootEx<ThreadModel>
{
public:
	typedef Owner _OwnerClass;
	CComObject<Owner>* m_pOwner;
	CComTearOffObjectBase() {m_pOwner = NULL;}
};

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class Base>
class CComObject : public Base
{
public:
	typedef Base _BaseClass;
	CComObject(void* = NULL)
	{
		_Module.Lock();
	}
	// Set refcount to 1 to protect destruction
	~CComObject()
	{
		m_dwRef = 1L;
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
		_Module.Unlock();
	}
	//If InternalAddRef or InternalRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
	template <class Q>
	HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
	{
		return QueryInterface(__uuidof(Q), (void**)pp);
	}

	static HRESULT WINAPI CreateInstance(CComObject<Base>** pp);
};

template <class Base>
HRESULT WINAPI CComObject<Base>::CreateInstance(CComObject<Base>** pp)
{
    _ATL_VALIDATE_OUT_POINTER(pp);
        
	HRESULT hRes = E_OUTOFMEMORY;
	CComObject<Base>* p = NULL;
	ATLTRY(p = new CComObject<Base>())
	if (p != NULL)
	{
		p->SetVoid(NULL);
		p->InternalFinalConstructAddRef();
		hRes = p->FinalConstruct();
		p->InternalFinalConstructRelease();
		if (hRes != S_OK)
		{
			delete p;
			p = NULL;
		}
	}
	*pp = p;
	return hRes;
}

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
// CComObjectCached is used primarily for class factories in DLL's
// but it is useful anytime you want to cache an object
template <class Base>
class CComObjectCached : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectCached(void* = NULL){}
	// Set refcount to 1 to protect destruction
	~CComObjectCached()
	{
		m_dwRef = 1L;
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
	}
	//If InternalAddRef or InternalRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)()
	{
		m_csCached.Lock();
		ULONG l = InternalAddRef();
		if (m_dwRef == 2)
			_Module.Lock();
		m_csCached.Unlock();
		return l;
	}
	STDMETHOD_(ULONG, Release)()
	{
		m_csCached.Lock();
		InternalRelease();
		ULONG l = m_dwRef;
		m_csCached.Unlock();
		if (l == 0)
			delete this;
		else if (l == 1)
			_Module.Unlock();
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
	CComGlobalsThreadModel::AutoCriticalSection m_csCached;
};

//Base is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class Base>
class CComObjectNoLock : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectNoLock(void* = NULL){}
	// Set refcount to 1 to protect destruction
	~CComObjectNoLock()
	{
		m_dwRef = 1L;
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
	}

	//If InternalAddRef or InternalRelease is undefined then your class
	//doesn't derive from CComObjectRoot
	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	//if _InternalQueryInterface is undefined then you forgot BEGIN_COM_MAP
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
};

// It is possible for Base not to derive from CComObjectRoot
// However, you will need to provide FinalConstruct and InternalQueryInterface
template <class Base>
class CComObjectGlobal : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectGlobal(void* = NULL){m_hResFinalConstruct = FinalConstruct();}
	~CComObjectGlobal()
	{
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
	}

	STDMETHOD_(ULONG, AddRef)() {return _Module.Lock();}
	STDMETHOD_(ULONG, Release)(){return _Module.Unlock();}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{return _InternalQueryInterface(iid, ppvObject);}
	HRESULT m_hResFinalConstruct;
};

// It is possible for Base not to derive from CComObjectRoot
// However, you will need to provide FinalConstruct and InternalQueryInterface
template <class Base>
class CComObjectStack : public Base
{
public:
	typedef Base _BaseClass;
	CComObjectStack(void* = NULL){m_hResFinalConstruct = FinalConstruct();}
	~CComObjectStack()
	{
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
	}


	STDMETHOD_(ULONG, AddRef)() {ATLASSERT(FALSE);return 0;}
	STDMETHOD_(ULONG, Release)(){ATLASSERT(FALSE);return 0;}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{ATLASSERT(FALSE);return E_NOINTERFACE;}
	HRESULT m_hResFinalConstruct;
};

template <class Base> //Base must be derived from CComObjectRoot
class CComContainedObject : public Base
{
public:
	typedef Base _BaseClass;
	CComContainedObject(void* pv) {m_pOuterUnknown = (IUnknown*)pv;}
#ifdef _ATL_DEBUG_INTERFACES
	~CComContainedObject()
	{
		_Module.DeleteNonAddRefThunk(_GetRawUnknown());
		_Module.DeleteNonAddRefThunk(m_pOuterUnknown);
	}
#endif

	STDMETHOD_(ULONG, AddRef)() {return OuterAddRef();}
	STDMETHOD_(ULONG, Release)() {return OuterRelease();}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		HRESULT hr = OuterQueryInterface(iid, ppvObject);
		if (FAILED(hr) && _GetRawUnknown() != m_pOuterUnknown)
			hr = _InternalQueryInterface(iid, ppvObject);
		return hr;
	}
	template <class Q>
	HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
	{
		return QueryInterface(__uuidof(Q), (void**)pp);
	}
	//GetControllingUnknown may be virtual if the Base class has declared
	//DECLARE_GET_CONTROLLING_UNKNOWN()
	IUnknown* GetControllingUnknown()
	{
#ifdef _ATL_DEBUG_INTERFACES
		IUnknown* p;
		_Module.AddNonAddRefThunk(m_pOuterUnknown, _T("CComContainedObject"), &p);
		return p;
#else
		return m_pOuterUnknown;
#endif
	}
};

//contained is the user's class that derives from CComObjectRoot and whatever
//interfaces the user wants to support on the object
template <class contained>
class CComAggObject :
	public IUnknown,
	public CComObjectRootEx< contained::_ThreadModel::ThreadModelNoCS >
{
public:
	typedef contained _BaseClass;
	CComAggObject(void* pv) : m_contained(pv)
	{
		_Module.Lock();
	}
	//If you get a message that this call is ambiguous then you need to
	// override it in your class and call each base class' version of this
	HRESULT FinalConstruct()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
		return m_contained.FinalConstruct();
	}
	void FinalRelease()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
		m_contained.FinalRelease();
	}
	// Set refcount to 1 to protect destruction
	~CComAggObject()
	{
		m_dwRef = 1L;
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(this);
#endif
		_Module.Unlock();
	}

	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		HRESULT hRes = S_OK;
		if (InlineIsEqualUnknown(iid))
		{
			if (ppvObject == NULL)
				return E_POINTER;
			*ppvObject = (void*)(IUnknown*)this;
			AddRef();
#ifdef _ATL_DEBUG_INTERFACES
			_Module.AddThunk((IUnknown**)ppvObject, (LPCTSTR)contained::_GetEntries()[-1].dw, iid);
#endif // _ATL_DEBUG_INTERFACES
		}
		else
			hRes = m_contained._InternalQueryInterface(iid, ppvObject);
		return hRes;
	}
	template <class Q>
	HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
	{
		return QueryInterface(__uuidof(Q), (void**)pp);
	}
	static HRESULT WINAPI CreateInstance(LPUNKNOWN pUnkOuter, CComAggObject<contained>** pp)
	{
        _ATL_VALIDATE_OUT_POINTER(pp);
                        
		HRESULT hRes = E_OUTOFMEMORY;
		CComAggObject<contained>* p = NULL;
		ATLTRY(p = new CComAggObject<contained>(pUnkOuter))
		if (p != NULL)
		{
			p->SetVoid(NULL);
			p->InternalFinalConstructAddRef();
			hRes = p->FinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes != S_OK)
			{
				delete p;
				p = NULL;
			}
		}
		*pp = p;
		return hRes;
	}

	CComContainedObject<contained> m_contained;
};

///////////////////////////////////////////////////////////////////////////////
// CComPolyObject can be either aggregated or not aggregated

template <class contained>
class CComPolyObject :
	public IUnknown,
	public CComObjectRootEx< contained::_ThreadModel::ThreadModelNoCS >
{
public:
	typedef contained _BaseClass;
	CComPolyObject(void* pv) : m_contained(pv ? pv : this)
	{
		_Module.Lock();
	}
	//If you get a message that this call is ambiguous then you need to
	// override it in your class and call each base class' version of this
	HRESULT FinalConstruct()
	{
		InternalAddRef();
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
		HRESULT hr = m_contained.FinalConstruct();
		InternalRelease();
		return hr;
	}
	void FinalRelease()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
		m_contained.FinalRelease();
	}
	// Set refcount to 1 to protect destruction
	~CComPolyObject()
	{
		m_dwRef = 1L;
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(this);
#endif
		_Module.Unlock();
	}

	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
        STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
        {
                if (ppvObject == NULL)
                    return E_POINTER;
                *ppvObject = NULL;

                HRESULT hRes = S_OK;
                if (InlineIsEqualUnknown(iid))
                {
                        *ppvObject = (void*)(IUnknown*)this;
                        AddRef();
#ifdef _ATL_DEBUG_INTERFACES
                        _Module.AddThunk((IUnknown**)ppvObject, (LPCTSTR)contained::_GetEntries()[-1].dw, iid);
#endif // _ATL_DEBUG_INTERFACES
                }
                else
                        hRes = m_contained._InternalQueryInterface(iid, ppvObject);
                return hRes;
        }
	template <class Q>
	HRESULT STDMETHODCALLTYPE QueryInterface(Q** pp)
	{
		return QueryInterface(__uuidof(Q), (void**)pp);
	}
	static HRESULT WINAPI CreateInstance(LPUNKNOWN pUnkOuter, CComPolyObject<contained>** pp)
	{
        _ATL_VALIDATE_OUT_POINTER(pp);

		HRESULT hRes = E_OUTOFMEMORY;
		CComPolyObject<contained>* p = NULL;
		ATLTRY(p = new CComPolyObject<contained>(pUnkOuter))
		if (p != NULL)
		{
			p->SetVoid(NULL);
			p->InternalFinalConstructAddRef();
			hRes = p->FinalConstruct();
			p->InternalFinalConstructRelease();
			if (hRes != S_OK)
			{
				delete p;
				p = NULL;
			}
		}
		*pp = p;
		return hRes;
	}

	CComContainedObject<contained> m_contained;
};

template <class Base>
class CComTearOffObject : public Base
{
public:
	CComTearOffObject(void* pv)
	{
		ATLASSERT(m_pOwner == NULL);
		m_pOwner = reinterpret_cast<CComObject<Base::_OwnerClass>*>(pv);
		m_pOwner->AddRef();
	}
	// Set refcount to 1 to protect destruction
	~CComTearOffObject()
	{
		m_dwRef = 1L;
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(_GetRawUnknown());
#endif
		m_pOwner->Release();
	}

	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		return m_pOwner->QueryInterface(iid, ppvObject);
	}
};

template <class contained>
class CComCachedTearOffObject :
	public IUnknown,
	public CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>
{
public:
	typedef contained _BaseClass;
	CComCachedTearOffObject(void* pv) :
		m_contained(((contained::_OwnerClass*)pv)->GetControllingUnknown())
	{
		ATLASSERT(m_contained.m_pOwner == NULL);
		m_contained.m_pOwner = reinterpret_cast<CComObject<contained::_OwnerClass>*>(pv);
	}
	//If you get a message that this call is ambiguous then you need to
	// override it in your class and call each base class' version of this
	HRESULT FinalConstruct()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalConstruct();
		return m_contained.FinalConstruct();
	}
	void FinalRelease()
	{
		CComObjectRootEx<contained::_ThreadModel::ThreadModelNoCS>::FinalRelease();
		m_contained.FinalRelease();
	}
	// Set refcount to 1 to protect destruction
	~CComCachedTearOffObject()
	{
		m_dwRef = 1L;
		FinalRelease();
#ifdef _ATL_DEBUG_INTERFACES
		_Module.DeleteNonAddRefThunk(this);
#endif
	}


	STDMETHOD_(ULONG, AddRef)() {return InternalAddRef();}
	STDMETHOD_(ULONG, Release)()
	{
		ULONG l = InternalRelease();
		if (l == 0)
			delete this;
		return l;
	}
	STDMETHOD(QueryInterface)(REFIID iid, void ** ppvObject)
	{
		HRESULT hRes = S_OK;
		if (InlineIsEqualUnknown(iid))
		{
			if (ppvObject == NULL)
				return E_POINTER;
			*ppvObject = (void*)(IUnknown*)this;
			AddRef();
#ifdef _ATL_DEBUG_INTERFACES
			_Module.AddThunk((IUnknown**)ppvObject, (LPCTSTR)contained::_GetEntries()[-1].dw, iid);
#endif // _ATL_DEBUG_INTERFACES
		}
		else
			hRes = m_contained._InternalQueryInterface(iid, ppvObject);
		return hRes;
	}
	CComContainedObject<contained> m_contained;
};

class CComClassFactory :
	public IClassFactory,
	public CComObjectRootEx<CComGlobalsThreadModel>
{
public:
	BEGIN_COM_MAP(CComClassFactory)
		COM_INTERFACE_ENTRY(IClassFactory)
	END_COM_MAP()

	// IClassFactory
	STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj)
	{
		ATLASSERT(m_pfnCreateInstance != NULL);
		HRESULT hRes = E_POINTER;
		if (ppvObj != NULL)
		{
			*ppvObj = NULL;
			// can't ask for anything other than IUnknown when aggregating
			
			if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			{
				ATLTRACE2(atlTraceCOM, 0, _T("CComClassFactory: asked for non IUnknown interface while creating an aggregated object"));
				hRes = CLASS_E_NOAGGREGATION;
			}
			else
				hRes = m_pfnCreateInstance(pUnkOuter, riid, ppvObj);
		}
		return hRes;
	}

	STDMETHOD(LockServer)(BOOL fLock)
	{
		if (fLock)
			_Module.Lock();
		else
			_Module.Unlock();
		return S_OK;
	}
	// helper
	void SetVoid(void* pv)
	{
		m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;
	}
	_ATL_CREATORFUNC* m_pfnCreateInstance;
};

template <class license>
class CComClassFactory2 : 
	public IClassFactory2,
	public CComObjectRootEx<CComGlobalsThreadModel>,
	public license
{
public:
	typedef license _LicenseClass;
	typedef CComClassFactory2<license> _ComMapClass;
BEGIN_COM_MAP(CComClassFactory2<license>)
	COM_INTERFACE_ENTRY(IClassFactory)
	COM_INTERFACE_ENTRY(IClassFactory2)
END_COM_MAP()
	// IClassFactory
	STDMETHOD(LockServer)(BOOL fLock)
	{
		if (fLock)
			_Module.Lock();
		else
			_Module.Unlock();
		return S_OK;
	}
	STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter,
		REFIID riid, void** ppvObj)
	{
		ATLASSERT(m_pfnCreateInstance != NULL);
		if (ppvObj == NULL)
			return E_POINTER;
		*ppvObj = NULL;
		if (!IsLicenseValid())
			return CLASS_E_NOTLICENSED;

		if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			return CLASS_E_NOAGGREGATION;
		else
			return m_pfnCreateInstance(pUnkOuter, riid, ppvObj);
	}
	// IClassFactory2
	STDMETHOD(CreateInstanceLic)(IUnknown* pUnkOuter, IUnknown* pUnkReserved,
				REFIID riid, BSTR bstrKey, void** ppvObject)
	{
		ATLASSERT(m_pfnCreateInstance != NULL);
		if (ppvObject == NULL)
			return E_POINTER;
		*ppvObject = NULL;
		if ( ((bstrKey != NULL) && !VerifyLicenseKey(bstrKey)) ||
			 ((bstrKey == NULL) && !IsLicenseValid()) )
			return CLASS_E_NOTLICENSED;
		if ((pUnkOuter != NULL) && !InlineIsEqualUnknown(riid))
			return CLASS_E_NOAGGREGATION;
		else
			return m_pfnCreateInstance(pUnkOuter, riid, ppvObject);
	}
	STDMETHOD(RequestLicKey)(DWORD dwReserved, BSTR* pbstrKey)
	{
		if (pbstrKey == NULL)
			return E_POINTER;
		*pbstrKey = NULL;

		if (!IsLicenseValid())
			return CLASS_E_NOTLICENSED;
		return GetLicenseKey(dwReserved,pbstrKey) ? S_OK : E_FAIL;
	}
	STDMETHOD(GetLicInfo)(LICINFO* pLicInfo)
	{
		if (pLicInfo == NULL)
			return E_POINTER;
		pLicInfo->cbLicInfo = sizeof(LICINFO);
		pLicInfo->fLicVerified = IsLicenseValid();
		BSTR bstr = NULL;
		pLicInfo->fRuntimeKeyAvail = GetLicenseKey(0,&bstr);
		::SysFreeString(bstr);
		return S_OK;
	}
	void SetVoid(void* pv)
	{
		m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;
	}
	_ATL_CREATORFUNC* m_pfnCreateInstance;
};

/////////////////////////////////////////////////////////////////////////////////////////////
// Thread Pooling class factory

class CComClassFactoryAutoThread :
	public IClassFactory,
	public CComObjectRootEx<CComGlobalsThreadModel>
{
public:
	BEGIN_COM_MAP(CComClassFactoryAutoThread)
		COM_INTERFACE_ENTRY(IClassFactory)
	END_COM_MAP()

	// helper
	void SetVoid(void* pv)
	{
		m_pfnCreateInstance = (_ATL_CREATORFUNC*)pv;
	}
	STDMETHODIMP CreateInstance(LPUNKNOWN pUnkOuter,
		REFIID riid, void** ppvObj)
	{
		ATLASSERT(m_pfnCreateInstance != NULL);
		HRESULT hRes = E_POINTER;
		if (ppvObj != NULL)
		{
			*ppvObj = NULL;
			// cannot aggregate across apartments
			ATLASSERT(pUnkOuter == NULL);
			if (pUnkOuter != NULL)
				hRes = CLASS_E_NOAGGREGATION;
			else
				hRes = _Module.CreateInstance(m_pfnCreateInstance, riid, ppvObj);
		}
		return hRes;
	}
	STDMETHODIMP LockServer(BOOL fLock)
	{
		if (fLock)
			_Module.Lock();
		else
			_Module.Unlock();
		return S_OK;
	}
	_ATL_CREATORFUNC* m_pfnCreateInstance;
};

/////////////////////////////////////////////////////////////////////////////////////////////
// Singleton Class Factory
template <class T>
class CComClassFactorySingleton : public CComClassFactory
{
public:
	void FinalRelease()
	{
		CoDisconnectObject(m_Obj.GetUnknown(), 0);
	}

	// IClassFactory
	STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj)
	{
		HRESULT hRes = E_POINTER;
		if (ppvObj != NULL)
		{
			*ppvObj = NULL;
			// aggregation is not supported in Singletons
			ATLASSERT(pUnkOuter == NULL);
			if (pUnkOuter != NULL)
				hRes = CLASS_E_NOAGGREGATION;
			else
			{
				if (m_Obj.m_hResFinalConstruct != S_OK)
					hRes = m_Obj.m_hResFinalConstruct;
				else
					hRes = m_Obj.QueryInterface(riid, ppvObj);
			}
		}
		return hRes;
	}
	CComObjectGlobal<T> m_Obj;
};

template <class T, const CLSID* pclsid = &CLSID_NULL>
class CComCoClass
{
public:
	DECLARE_CLASSFACTORY()
	DECLARE_AGGREGATABLE(T)
	typedef T _CoClass;
	static const CLSID& WINAPI GetObjectCLSID() {return *pclsid;}
	static LPCTSTR WINAPI GetObjectDescription() {return NULL;}
	static const struct _ATL_CATMAP_ENTRY* GetCategoryMap() {return NULL;};
	static HRESULT WINAPI Error(LPCOLESTR lpszDesc,
		const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{
		return AtlReportError(GetObjectCLSID(), lpszDesc, iid, hRes);
	}
	static HRESULT WINAPI Error(LPCOLESTR lpszDesc, DWORD dwHelpID,
		LPCOLESTR lpszHelpFile, const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{
		return AtlReportError(GetObjectCLSID(), lpszDesc, dwHelpID, lpszHelpFile,
			iid, hRes);
	}
	static HRESULT WINAPI Error(UINT nID, const IID& iid = GUID_NULL,
		HRESULT hRes = 0, HINSTANCE hInst = _Module.GetResourceInstance())
	{
		return AtlReportError(GetObjectCLSID(), nID, iid, hRes, hInst);
	}


    //
    	static HRESULT WINAPI Error(DWORD nID, const IID& iid,
		HRESULT hRes, ...)
	{
        HINSTANCE hInst = _Module.GetResourceInstance();
        va_list arguments;
        va_start(arguments, hRes);
        return AtlSetErrorInfo(GetObjectCLSID(), nID, iid, hRes, hInst, &arguments);
	}
    	static HRESULT WINAPI Error(DWORD nID, const IID& iid,
		HRESULT hRes, HINSTANCE hInst, ...)
	{ 
        va_list arguments;
        va_start(arguments, hInst);
        return AtlSetErrorInfo(GetObjectCLSID(), nID, iid, hRes, hInst, &arguments);
	}

    //


	static HRESULT WINAPI Error(UINT nID, DWORD dwHelpID,
		LPCOLESTR lpszHelpFile, const IID& iid = GUID_NULL,
		HRESULT hRes = 0, HINSTANCE hInst = _Module.GetResourceInstance())
	{
		return AtlReportError(GetObjectCLSID(), nID, dwHelpID, lpszHelpFile,
			iid, hRes, hInst);
	}
#ifndef OLE2ANSI
	static HRESULT WINAPI Error(LPCSTR lpszDesc,
		const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{
		return AtlReportError(GetObjectCLSID(), lpszDesc, iid, hRes);
	}
	static HRESULT WINAPI Error(LPCSTR lpszDesc, DWORD dwHelpID,
		LPCSTR lpszHelpFile, const IID& iid = GUID_NULL, HRESULT hRes = 0)
	{
		return AtlReportError(GetObjectCLSID(), lpszDesc, dwHelpID,
			lpszHelpFile, iid, hRes);
	}
#endif
	template <class Q>
	static HRESULT CreateInstance(IUnknown* punkOuter, Q** pp)
	{
		return T::_CreatorClass::CreateInstance(punkOuter, __uuidof(Q), (void**) pp);
	}
	template <class Q>
	static HRESULT CreateInstance(Q** pp)
	{
		return T::_CreatorClass::CreateInstance(NULL, __uuidof(Q), (void**) pp);
	}
};

// ATL doesn't support multiple LCID's at the same time
// Whatever LCID is queried for first is the one that is used.
class CComTypeInfoHolder
{
// Should be 'protected' but can cause compiler to generate fat code.
public:
	const GUID* m_pguid;
	const GUID* m_plibid;
	WORD m_wMajor;
	WORD m_wMinor;

	ITypeInfo* m_pInfo;
	long m_dwRef;
	struct stringdispid
	{
		CComBSTR bstr;
		int nLen;
		DISPID id;
        stringdispid() : nLen(0), id(DISPID_UNKNOWN){}
    };
	stringdispid* m_pMap;
	int m_nCount;

public:
	HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
	{
        _ATL_VALIDATE_OUT_POINTER(ppInfo);
                
		HRESULT hr = S_OK;
		if (m_pInfo == NULL)
			hr = GetTI(lcid);
		*ppInfo = m_pInfo;
		if (m_pInfo != NULL)
		{
			m_pInfo->AddRef();
			hr = S_OK;
		}
		return hr;
	}
        HRESULT GetTI(LCID lcid);
        HRESULT EnsureTI(LCID lcid)
        {
                HRESULT hr = S_OK;
                if (m_pInfo == NULL || m_pMap == NULL)
                        hr = GetTI(lcid);
                return hr;
        }

        // This function is called by the module on exit
        // It is registered through _Module.AddTermFunc()
        static void __stdcall Cleanup(DWORD_PTR dw)
        {
                ATLASSERT(dw != 0);
                if (dw == 0)
                        return;
                        
                CComTypeInfoHolder* p = (CComTypeInfoHolder*) dw;
                if (p->m_pInfo != NULL)
                        p->m_pInfo->Release();
                p->m_pInfo = NULL;
                delete [] p->m_pMap;
                p->m_pMap = NULL;
        }

        HRESULT GetTypeInfo(UINT /* itinfo */, LCID lcid, ITypeInfo** pptinfo)
        {
                return GetTI(lcid, pptinfo);
        }
        HRESULT GetIDsOfNames(REFIID /* riid */, LPOLESTR* rgszNames, UINT cNames,
                LCID lcid, DISPID* rgdispid)
        {
                HRESULT hRes = EnsureTI(lcid);
                if (m_pInfo != NULL)
                {
                        if (m_pMap != NULL)
                        {
                                for (int i=0; i<(int)cNames; i++)
                                {
                                        int n = ocslen(rgszNames[i]);
                                        int j;
                                        for (j=m_nCount-1; j>=0; j--)
                                        {
                                                if ((n == m_pMap[j].nLen) &&
                                                        (memcmp(m_pMap[j].bstr, rgszNames[i], m_pMap[j].nLen * sizeof(OLECHAR)) == 0))
                                                {
                                                        rgdispid[i] = m_pMap[j].id;
                                                        break;
                                                }
                                        }
                                        if (j < 0)
                                        {
                                                hRes = m_pInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
                                                // got IDs for ALL the requested names or FAILED
                                                break;
                                        }
                                }
                        }
                        else
                        {
                                hRes = m_pInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
                        }
                }
                return hRes;
        }

        HRESULT Invoke(IDispatch* p, DISPID dispidMember, REFIID /* riid */,
                LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                EXCEPINFO* pexcepinfo, UINT* puArgErr)
        {
                HRESULT hRes = EnsureTI(lcid);
                if (m_pInfo != NULL)
                        hRes = m_pInfo->Invoke(p, dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
                return hRes;
        }

        HRESULT LoadNameCache(ITypeInfo* pTypeInfo)
        {
                ATLASSERT(m_pMap == NULL);
                TYPEATTR* pta;
                HRESULT hr = pTypeInfo->GetTypeAttr(&pta);
                if (SUCCEEDED(hr))
                {
                        m_nCount = pta->cFuncs;
                        
                        stringdispid* pMap = NULL;
                        if (m_nCount != 0)
                                ATLTRY(pMap = new stringdispid[m_nCount]);
                        if (m_nCount != 0 && pMap == NULL)
                        {
                                m_nCount = 0;
                                return E_OUTOFMEMORY;
                        }
                        for (int i=0; i<m_nCount; i++)
                        {
                                FUNCDESC* pfd;
                                hr = pTypeInfo->GetFuncDesc(i, &pfd);
                                if (SUCCEEDED(hr))
                                {
                                        CComBSTR bstrName;
                                        hr = pTypeInfo->GetDocumentation(pfd->memid, &bstrName, NULL, NULL, NULL);
                                        if (SUCCEEDED(hr))
                                        {
                                                pMap[i].bstr.Attach(bstrName.Detach());
                                                pMap[i].nLen = SysStringLen(pMap[i].bstr);
                                                pMap[i].id = pfd->memid;
                                        }
                                        else
                                        {
                                                delete [] m_pMap;
                                                m_pMap = NULL;
                                                m_nCount = 0;
                                                pTypeInfo->ReleaseFuncDesc(pfd);
                                                break;
                                        }
                                        pTypeInfo->ReleaseFuncDesc(pfd);
                                }
                                else
                                {
                                        delete [] m_pMap;
                                        m_pMap = NULL;
                                        m_nCount = 0;
                                        break;
                                }
                        }
                        m_pMap = pMap;                        
                        pTypeInfo->ReleaseTypeAttr(pta);
                }
                return hr;
        }
};

inline HRESULT CComTypeInfoHolder::GetTI(LCID lcid)
{
        //If this assert occurs then most likely didn't initialize properly
        ATLASSERT(m_plibid != NULL && m_pguid != NULL);
        ATLASSERT(!InlineIsEqualGUID(*m_plibid, GUID_NULL) && "Did you forget to pass the LIBID to CComModule::Init?");

        if (m_pInfo != NULL && m_pMap != NULL)
                return S_OK;
        HRESULT hRes = S_OK;
        EnterCriticalSection(&_Module.m_csTypeInfoHolder);
        if (m_pInfo == NULL)
        {
                ITypeLib* pTypeLib;
                hRes = LoadRegTypeLib(*m_plibid, m_wMajor, m_wMinor, lcid, &pTypeLib);
                if (SUCCEEDED(hRes))
                {
                        CComPtr<ITypeInfo> spTypeInfo;
                        hRes = pTypeLib->GetTypeInfoOfGuid(*m_pguid, &spTypeInfo);
                        if (SUCCEEDED(hRes))
                        {
                                CComPtr<ITypeInfo> spInfo(spTypeInfo);
                                CComPtr<ITypeInfo2> spTypeInfo2;
                                if (SUCCEEDED(spTypeInfo->QueryInterface(&spTypeInfo2)))
                                        spInfo = spTypeInfo2;

                                m_pInfo = spInfo.Detach();
                                _Module.AddTermFunc(Cleanup, (DWORD_PTR)this);
                        }
                        pTypeLib->Release();
                }
        }
        if (m_pInfo != NULL && m_pMap == NULL)
        {
                LoadNameCache(m_pInfo);
        }
        LeaveCriticalSection(&_Module.m_csTypeInfoHolder);
        return hRes;
}

//////////////////////////////////////////////////////////////////////////////
// IObjectWithSite
//
template <class T>
class ATL_NO_VTABLE IObjectWithSiteImpl : public IObjectWithSite
{
public:
	STDMETHOD(SetSite)(IUnknown *pUnkSite)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IObjectWithSiteImpl::SetSite\n"));
		T* pT = static_cast<T*>(this);
		pT->m_spUnkSite = pUnkSite;
		return S_OK;
	}
	STDMETHOD(GetSite)(REFIID riid, void **ppvSite)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IObjectWithSiteImpl::GetSite\n"));
		T* pT = static_cast<T*>(this);
		ATLASSERT(ppvSite);
		HRESULT hRes = E_POINTER;
		if (ppvSite != NULL)
		{
			if (pT->m_spUnkSite)
				hRes = pT->m_spUnkSite->QueryInterface(riid, ppvSite);
			else
			{
				*ppvSite = NULL;
				hRes = E_FAIL;
			}
		}
		return hRes;
	}

	HRESULT SetChildSite(IUnknown* punkChild)
	{
		if (punkChild == NULL)
			return E_POINTER;

		HRESULT hr;
		CComPtr<IObjectWithSite> spChildSite;
		hr = punkChild->QueryInterface(IID_IObjectWithSite, (void**)&spChildSite);
		if (SUCCEEDED(hr))
			hr = spChildSite->SetSite((IUnknown*)this);

		return hr;
	}

	static HRESULT SetChildSite(IUnknown* punkChild, IUnknown* punkParent)
	{
		return AtlSetChildSite(punkChild, punkParent);
	}

	CComPtr<IUnknown> m_spUnkSite;
};

//////////////////////////////////////////////////////////////////////////////
// IServiceProvider
//
template <class T>
class ATL_NO_VTABLE IServiceProviderImpl : public IServiceProvider
{
public:
	STDMETHOD(QueryService)(REFGUID guidService, REFIID riid, void** ppvObject)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("IServiceProviderImpl::QueryService\n"));
        _ATL_VALIDATE_OUT_POINTER(ppvObject);
		T* pT = static_cast<T*>(this);
		return pT->_InternalQueryService(guidService, riid, ppvObject);
	}
};

#define BEGIN_SERVICE_MAP(x) public: \
	HRESULT _InternalQueryService(REFGUID guidService, REFIID riid, void** ppvObject) \
	{

#define SERVICE_ENTRY(x) \
		if (InlineIsEqualGUID(guidService, x)) \
			return QueryInterface(riid, ppvObject);

#define SERVICE_ENTRY_CHAIN(x) \
		CComQIPtr<IServiceProvider, &IID_IServiceProvider> spProvider(x); \
		if (spProvider != NULL) \
			return spProvider->QueryService(guidService, riid, ppvObject);

#define END_SERVICE_MAP() \
		return E_NOINTERFACE; \
	}


/////////////////////////////////////////////////////////////////////////////
// IDispEventImpl

#ifdef _ATL_DLL
ATLAPI AtlGetObjectSourceInterface(IUnknown* punkObj, GUID* plibid, IID* piid, unsigned short* pdwMajor, unsigned short* pdwMinor);
#else
ATLINLINE ATLAPI AtlGetObjectSourceInterface(IUnknown* punkObj, GUID* plibid, IID* piid, unsigned short* pdwMajor, unsigned short* pdwMinor)
{
    if (plibid == NULL || piid == NULL || pdwMajor == NULL || pdwMinor == NULL)
            return E_POINTER;
            
    *plibid = GUID_NULL;
    *piid = IID_NULL;
    *pdwMajor = 0;
    *pdwMinor = 0;
    
	HRESULT hr = E_FAIL;
	if (punkObj != NULL)
	{
		CComPtr<IDispatch> spDispatch;
		hr = punkObj->QueryInterface(IID_IDispatch, (void**)&spDispatch);
		if (SUCCEEDED(hr))
		{
			CComPtr<ITypeInfo> spTypeInfo;
			hr = spDispatch->GetTypeInfo(0, 0, &spTypeInfo);
			if (SUCCEEDED(hr))
			{
				CComPtr<ITypeLib> spTypeLib;
				hr = spTypeInfo->GetContainingTypeLib(&spTypeLib, 0);
				if (SUCCEEDED(hr))
				{
					TLIBATTR* plibAttr;
					hr = spTypeLib->GetLibAttr(&plibAttr);
					if (SUCCEEDED(hr))
					{
						memcpy(plibid, &plibAttr->guid, sizeof(GUID));
						*pdwMajor = plibAttr->wMajorVerNum;
						*pdwMinor = plibAttr->wMinorVerNum;
						spTypeLib->ReleaseTLibAttr(plibAttr);
						// First see if the object is willing to tell us about the
						// default source interface via IProvideClassInfo2
						CComPtr<IProvideClassInfo2> spInfo;
						hr = punkObj->QueryInterface(IID_IProvideClassInfo2, (void**)&spInfo);
						if (SUCCEEDED(hr) && spInfo != NULL)
							hr = spInfo->GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID, piid);
						else
						{
							// No, we have to go hunt for it
							CComPtr<ITypeInfo> spInfoCoClass;
							// If we have a clsid, use that
							// Otherwise, try to locate the clsid from IPersist
							CComPtr<IPersist> spPersist;
							CLSID clsid;
							hr = punkObj->QueryInterface(IID_IPersist, (void**)&spPersist);
							if (SUCCEEDED(hr))
							{
								hr = spPersist->GetClassID(&clsid);
								if (SUCCEEDED(hr))
								{
									hr = spTypeLib->GetTypeInfoOfGuid(clsid, &spInfoCoClass);
									if (SUCCEEDED(hr))
									{
										TYPEATTR* pAttr=NULL;
										spInfoCoClass->GetTypeAttr(&pAttr);
										if (pAttr != NULL)
										{
											HREFTYPE hRef;
											for (int i = 0; i < pAttr->cImplTypes; i++)
											{
												int nType;
												hr = spInfoCoClass->GetImplTypeFlags(i, &nType);
												if (SUCCEEDED(hr))
												{
													if (nType == (IMPLTYPEFLAG_FDEFAULT | IMPLTYPEFLAG_FSOURCE))
													{
														// we found it
														hr = spInfoCoClass->GetRefTypeOfImplType(i, &hRef);
														if (SUCCEEDED(hr))
														{
															CComPtr<ITypeInfo> spInfo;
															hr = spInfoCoClass->GetRefTypeInfo(hRef, &spInfo);
															if (SUCCEEDED(hr))
															{
																TYPEATTR* pAttrIF;
																spInfo->GetTypeAttr(&pAttrIF);
																if (pAttrIF != NULL)
																{
																	memcpy(piid, &pAttrIF->guid, sizeof(GUID));
															        spInfo->ReleaseTypeAttr(pAttrIF);
																}
															}
														}
														break;
													}
												}
											}
											spInfoCoClass->ReleaseTypeAttr(pAttr);
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return hr;
}
#endif // _ATL_DLL

#if defined(_M_IA64)
template <class T>
class CComStdCallThunk
{
public:
        typedef void (__stdcall T::*TMFP)();
        void* pVtable;
        void* pFunc;
        _stdcallthunk thunk;
        void Init(TMFP dw, void* pThis)
        {
                pVtable = &pFunc;
                pFunc = &thunk;         
                union {
                        DWORD_PTR dwFunc;
                        TMFP pfn;
                } pfn;
                pfn.pfn = dw;
                thunk.Init(pfn.dwFunc, pThis);
        }
};
#elif defined(_M_AMD64) || defined(_M_IX86)
template <class T>
class CComStdCallThunk
{
public:
        typedef void (__stdcall T::*TMFP)();
        void *pVTable;
        void *pThis;
        TMFP pfn;
        void (__stdcall *pfnHelper)();

        
        void Init(TMFP pf, void *p);
};

#if defined(_M_AMD64)
#pragma comment(lib, "atlamd64.lib")
extern "C" void CComStdCallThunkHelper(void);
#else

inline void __declspec(naked) __stdcall CComStdCallThunkHelper()
{
        __asm
        {
                mov eax, [esp+4];       // get pThunk
                mov edx, [eax+4];       // get the pThunk->pThis
                mov [esp+4], edx;       // replace pThunk with pThis
                mov eax, [eax+8];       // get pThunk->pfn
                jmp eax;                // jump pfn
        };
}
#endif

template <class T>
void CComStdCallThunk<T>::Init(TMFP pf, void *p)
{
        pfnHelper = CComStdCallThunkHelper;
        pVTable = &pfnHelper;
        pThis = p;
        pfn = pf;
}

#else
#error "No Target Architecture"
#endif // _M_IX86

#ifndef _ATL_MAX_VARTYPES
#define _ATL_MAX_VARTYPES 8
#endif

struct _ATL_FUNC_INFO
{
	CALLCONV cc;
	VARTYPE vtReturn;
	SHORT nParams;
	VARTYPE pVarTypes[_ATL_MAX_VARTYPES];
};

class ATL_NO_VTABLE _IDispEvent
{
public:
	_IDispEvent() {m_dwEventCookie = 0xFEFEFEFE;}
	//this method needs a different name than QueryInterface
	STDMETHOD(_LocDEQueryInterface)(REFIID riid, void ** ppvObject) = 0;
	virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;
	virtual ULONG STDMETHODCALLTYPE Release(void) = 0;
	GUID m_libid; // used for dynamic case
	IID m_iid; // used for dynamic case
    unsigned short m_wMajorVerNum;    // Major version number. used for dynamic case
    unsigned short m_wMinorVerNum;    // Minor version number. used for dynamic case
	DWORD m_dwEventCookie;
	HRESULT DispEventAdvise(IUnknown* pUnk, const IID* piid)
	{
		ATLASSERT(m_dwEventCookie == 0xFEFEFEFE);
		return AtlAdvise(pUnk, (IUnknown*)this, *piid, &m_dwEventCookie);
	}
	HRESULT DispEventUnadvise(IUnknown* pUnk, const IID* piid)
	{
		HRESULT hr = AtlUnadvise(pUnk, *piid, m_dwEventCookie);
		m_dwEventCookie = 0xFEFEFEFE;
		return hr;
	}
};

template <UINT nID, const IID* piid>
class ATL_NO_VTABLE _IDispEventLocator : public _IDispEvent
{
public:
};

template <UINT nID, class T, const IID* pdiid>
class ATL_NO_VTABLE IDispEventSimpleImpl : public _IDispEventLocator<nID, pdiid>
{
public:
        STDMETHOD(_LocDEQueryInterface)(REFIID riid, void ** ppvObject)
        {
                _ATL_VALIDATE_OUT_POINTER(ppvObject);
                
                if (InlineIsEqualGUID(riid, *pdiid) || 
                        InlineIsEqualUnknown(riid) ||
                        InlineIsEqualGUID(riid, IID_IDispatch) ||
                        InlineIsEqualGUID(riid, m_iid))
                {
                        *ppvObject = this;
                        AddRef();
#ifdef _ATL_DEBUG_INTERFACES
                        _Module.AddThunk((IUnknown**)ppvObject, _T("IDispEventImpl"), riid);
#endif // _ATL_DEBUG_INTERFACES
                        return S_OK;
                }
                else
                        return E_NOINTERFACE;
        }

	// These are here only to support use in non-COM objects	
	virtual ULONG STDMETHODCALLTYPE AddRef()
	{
		return 1;
	}
	virtual ULONG STDMETHODCALLTYPE Release()
	{
		return 1;
	}

	STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
	{return E_NOTIMPL;}

	STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{return E_NOTIMPL;}

	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid)
	{return E_NOTIMPL;}

        STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
                LCID lcid, WORD /*wFlags*/, DISPPARAMS* pdispparams, VARIANT* pvarResult,
                EXCEPINFO* /*pexcepinfo*/, UINT* /*puArgErr*/)
        {
                T* pT = static_cast<T*>(this);
                const _ATL_EVENT_ENTRY<T>* pMap = T::_GetSinkMap();
                const _ATL_EVENT_ENTRY<T>* pFound = NULL;
                void (__stdcall T::*pEvent)() = NULL;
                while (pMap->piid != NULL)
                {
                        if ((pMap->nControlID == nID) && (pMap->dispid == dispidMember) &&
                                (pMap->piid == pdiid)) //comparing pointers here should be adequate
                        {
                                pFound = pMap;
                                break;
                        }
                        pMap++;
                }
                if (pFound == NULL)
                        return S_OK;
                
                _ATL_FUNC_INFO info;
                _ATL_FUNC_INFO* pInfo;
                if (pFound->pInfo != NULL)
                        pInfo = pFound->pInfo;
                else
                {
                        pInfo = &info;
                        HRESULT hr = GetFuncInfoFromId(*pdiid, dispidMember, lcid, info);
                        if (FAILED(hr))
                                return S_OK;
                }
                return InvokeFromFuncInfo(pFound->pfn, *pInfo, pdispparams, pvarResult);
        }

        //Helper for invoking the event
        HRESULT InvokeFromFuncInfo(void (__stdcall T::*pEvent)(), _ATL_FUNC_INFO& info, DISPPARAMS* pdispparams, VARIANT* pvarResult)
        {
                T* pT = static_cast<T*>(this);
                // If this assert occurs, then add a #define _ATL_MAX_VARTYPES nnnn
                // before including atlcom.h
                ATLASSERT(info.nParams <= _ATL_MAX_VARTYPES);
                if (info.nParams > _ATL_MAX_VARTYPES)
                {
                        return E_FAIL;
                }
                VARIANTARG* rgVarArgs[_ATL_MAX_VARTYPES];
                VARIANTARG** pVarArgs = info.nParams ? rgVarArgs : 0;

                for (int i=0; i<info.nParams; i++)
                        pVarArgs[i] = &pdispparams->rgvarg[info.nParams - i - 1];

                CComStdCallThunk<T> thunk;
                thunk.Init(pEvent, pT);
                CComVariant tmpResult;
                if (pvarResult == NULL)
                        pvarResult = &tmpResult;

                HRESULT hr = DispCallFunc(
                        &thunk,
                        0,
                        info.cc,
                        info.vtReturn,
                        info.nParams,
                        info.pVarTypes,
                        pVarArgs,
                        pvarResult);
                ATLASSERT(SUCCEEDED(hr));
                return hr;
        }

	//Helper for finding the function index for a DISPID
	virtual HRESULT GetFuncInfoFromId(const IID& iid, DISPID dispidMember, LCID lcid, _ATL_FUNC_INFO& info)
	{
		return E_NOTIMPL;
	}
    //Helpers for sinking events on random IUnknown*
    HRESULT DispEventAdvise(IUnknown* pUnk, const IID* piid)
    {
            ATLASSERT(m_dwEventCookie == 0xFEFEFEFE);
            if (m_dwEventCookie != 0xFEFEFEFE)
                    return E_UNEXPECTED;
            return AtlAdvise(pUnk, (IUnknown*)this, *piid, &m_dwEventCookie);
    }
	HRESULT DispEventUnadvise(IUnknown* pUnk, const IID* piid)
	{
		HRESULT hr = AtlUnadvise(pUnk, *piid, m_dwEventCookie);
		m_dwEventCookie = 0xFEFEFEFE;
		return hr;
	}
	HRESULT DispEventAdvise(IUnknown* pUnk)
	{
		return _IDispEvent::DispEventAdvise(pUnk, pdiid);
	}
	HRESULT DispEventUnadvise(IUnknown* pUnk)
	{
		return _IDispEvent::DispEventUnadvise(pUnk, pdiid);
	}
};

//Helper for advising connections points from a sink map
template <class T>
inline HRESULT AtlAdviseSinkMap(T* pT, bool bAdvise)
{
	ATLASSERT(::IsWindow(pT->m_hWnd));
	const _ATL_EVENT_ENTRY<T>* pEntries = T::_GetSinkMap();
	if (pEntries == NULL)
		return S_OK;
	HRESULT hr = S_OK;
	while (pEntries->piid != NULL)
	{
        _IDispEvent* pDE = (_IDispEvent*)((DWORD_PTR)pT+pEntries->nOffset);
		bool bNotAdvised = pDE->m_dwEventCookie == 0xFEFEFEFE;
		if (bAdvise ^ bNotAdvised)
		{
			pEntries++;
			continue;
		}
		hr = E_FAIL;
		HWND h = pT->GetDlgItem(pEntries->nControlID);
		ATLASSERT(h != NULL);
		if (h != NULL)
		{
			CComPtr<IUnknown> spUnk;
			AtlAxGetControl(h, &spUnk);
			ATLASSERT(spUnk != NULL);
			if (spUnk != NULL)
			{
				if (bAdvise)
				{
					if (!InlineIsEqualGUID(IID_NULL, *pEntries->piid))
						hr = pDE->DispEventAdvise(spUnk, pEntries->piid);
					else
					{
						AtlGetObjectSourceInterface(spUnk, &pDE->m_libid, &pDE->m_iid, &pDE->m_wMajorVerNum, &pDE->m_wMinorVerNum);
						hr = pDE->DispEventAdvise(spUnk, &pDE->m_iid);
					}
				}
				else
				{
					if (!InlineIsEqualGUID(IID_NULL, *pEntries->piid))
						hr = pDE->DispEventUnadvise(spUnk, pEntries->piid);
					else
						hr = pDE->DispEventUnadvise(spUnk, &pDE->m_iid);
				}
				ATLASSERT(hr == S_OK);
			}
		}
		if (FAILED(hr))
			break;
		pEntries++;
	}
	return hr;
}

template <UINT nID, class T, const IID* pdiid = &IID_NULL, const GUID* plibid = &GUID_NULL, 
	WORD wMajor = 0, WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IDispEventImpl : public IDispEventSimpleImpl<nID, T, pdiid>
{
public:
	typedef tihclass _tihclass;

	IDispEventImpl()
	{
		m_libid = *plibid;
		m_iid = *pdiid;
		m_wMajorVerNum = wMajor;
		m_wMinorVerNum = wMinor;
	}

    STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
    {if( pctinfo == NULL ) return E_INVALIDARG; *pctinfo = 1; return S_OK;}

	STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{return _tih.GetTypeInfo(itinfo, lcid, pptinfo);}

	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid)
	{return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);}

	//Helper for finding the function index for a DISPID
	HRESULT GetFuncInfoFromId(const IID& /*iid*/, DISPID dispidMember, LCID lcid, _ATL_FUNC_INFO& info)
	{
		CComPtr<ITypeInfo> spTypeInfo;
		if (InlineIsEqualGUID(*_tih.m_plibid, GUID_NULL))
		{
			_tih.m_plibid = &m_libid;
			_tih.m_pguid = &m_iid;
			_tih.m_wMajor = m_wMajorVerNum;
			_tih.m_wMinor = m_wMinorVerNum;
		}
		HRESULT hr = _tih.GetTI(lcid, &spTypeInfo);
		if (FAILED(hr))
			return hr;
		CComQIPtr<ITypeInfo2, &IID_ITypeInfo2> spTypeInfo2 = spTypeInfo;
		FUNCDESC* pFuncDesc = NULL;
		if (spTypeInfo2 != NULL)
		{
			UINT nIndex;
			hr = spTypeInfo2->GetFuncIndexOfMemId(dispidMember, INVOKE_FUNC, &nIndex);
			if (FAILED(hr))
				return hr;
			hr = spTypeInfo->GetFuncDesc(nIndex, &pFuncDesc);
			if (FAILED(hr))
				return hr;
		}
		else // search for funcdesc
		{
			TYPEATTR* pAttr;
			hr = spTypeInfo->GetTypeAttr(&pAttr);
			if (FAILED(hr))
				return hr;
			for (int i=0;i<pAttr->cFuncs;i++)
			{
				hr = spTypeInfo->GetFuncDesc(i, &pFuncDesc);
				if (FAILED(hr))
					return hr;
				if (pFuncDesc->memid == dispidMember)
					break;
				spTypeInfo->ReleaseFuncDesc(pFuncDesc);
				pFuncDesc = NULL;
			}
			spTypeInfo->ReleaseTypeAttr(pAttr);
			if (pFuncDesc == NULL)
				return E_FAIL;
		}

		// If this assert occurs, then add a #define _ATL_MAX_VARTYPES nnnn
		// before including atlcom.h
		ATLASSERT(pFuncDesc->cParams <= _ATL_MAX_VARTYPES);
		if (pFuncDesc->cParams > _ATL_MAX_VARTYPES)
			return E_FAIL;

		for (int i=0; i<pFuncDesc->cParams; i++)
		{
            info.pVarTypes[i] = pFuncDesc->lprgelemdescParam[i].tdesc.vt;
            if (info.pVarTypes[i] == VT_PTR)
                    info.pVarTypes[i] = pFuncDesc->lprgelemdescParam[i].tdesc.lptdesc->vt | VT_BYREF;
            if (info.pVarTypes[i] == VT_USERDEFINED)
                    info.pVarTypes[i] = GetUserDefinedType(spTypeInfo,pFuncDesc->lprgelemdescParam[i].tdesc.hreftype);
		}

		VARTYPE vtReturn = pFuncDesc->elemdescFunc.tdesc.vt;
		switch(vtReturn)
		{
		case VT_INT:
			vtReturn = VT_I4;
			break;
		case VT_UINT:
			vtReturn = VT_UI4;
			break;
		case VT_VOID:
			vtReturn = VT_EMPTY; // this is how DispCallFunc() represents void
			break;
		case VT_HRESULT:
			vtReturn = VT_ERROR;
			break;
		}
		info.vtReturn = vtReturn;
		info.cc = pFuncDesc->callconv;
		info.nParams = pFuncDesc->cParams;
		spTypeInfo->ReleaseFuncDesc(pFuncDesc);
		return S_OK;
	}
	VARTYPE GetUserDefinedType(ITypeInfo *pTI, HREFTYPE hrt)
	{
		CComPtr<ITypeInfo> spTypeInfo;
		VARTYPE vt = VT_USERDEFINED;
		HRESULT hr = E_FAIL;
		hr = pTI->GetRefTypeInfo(hrt, &spTypeInfo);
		if(FAILED(hr))
			return vt;
		TYPEATTR *pta=NULL;

		spTypeInfo->GetTypeAttr(&pta);
		if(pta && pta->typekind == TKIND_ALIAS)
		{
			if (pta->tdescAlias.vt == VT_USERDEFINED)
				GetUserDefinedType(spTypeInfo,pta->tdescAlias.hreftype);
			else
				vt = pta->tdescAlias.vt;
		}
	
		if(pta)
			spTypeInfo->ReleaseTypeAttr(pta);
		return vt;

	}
protected:
	static _tihclass _tih;
	static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
	{return _tih.GetTI(lcid, ppInfo);}
};


template <UINT nID, class T, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
IDispEventImpl<nID, T, piid, plibid, wMajor, wMinor, tihclass>::_tihclass
IDispEventImpl<nID, T, piid, plibid, wMajor, wMinor, tihclass>::_tih =
	{piid, plibid, wMajor, wMinor, NULL, 0, NULL, 0};

template <class T>
struct _ATL_EVENT_ENTRY
{
	UINT nControlID;			//ID identifying object instance
	const IID* piid;			//dispinterface IID
	INT_PTR nOffset;				//offset of dispinterface from this pointer
	DISPID dispid;				//DISPID of method/property
	void (__stdcall T::*pfn)();	//method to invoke
	_ATL_FUNC_INFO* pInfo;
};



//Sink map is used to set up event handling
#define BEGIN_SINK_MAP(_class)\
	static const _ATL_EVENT_ENTRY<_class>* _GetSinkMap()\
	{\
		typedef _class _atl_event_classtype;\
		static const _ATL_EVENT_ENTRY<_class> map[] = {


#define SINK_ENTRY_INFO(id, iid, dispid, fn, info) {id, &iid, (INT_PTR)(static_cast<_IDispEventLocator<id, &iid>*>((_atl_event_classtype*)8))-8, dispid, (void (__stdcall _atl_event_classtype::*)())fn, info},
#define SINK_ENTRY_EX(id, iid, dispid, fn) SINK_ENTRY_INFO(id, iid, dispid, fn, NULL)
#define SINK_ENTRY(id, dispid, fn) SINK_ENTRY_EX(id, IID_NULL, dispid, fn)
#define END_SINK_MAP() {0, NULL, 0, 0, NULL, NULL} }; return map;}

/////////////////////////////////////////////////////////////////////////////
// IDispatchImpl

template <class T, const IID* piid, const GUID* plibid = &CComModule::m_libid, WORD wMajor = 1,
WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IDispatchImpl : public T
{
public:
	typedef tihclass _tihclass;
// IDispatch
	STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
	{
        if( pctinfo == NULL ) 
                return E_INVALIDARG; 
		*pctinfo = 1;
		return S_OK;
	}
	STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{
		return _tih.GetTypeInfo(itinfo, lcid, pptinfo);
	}
	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid)
	{
		return _tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
	}
	STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
		LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* pexcepinfo, UINT* puArgErr)
	{
		return _tih.Invoke((IDispatch*)this, dispidMember, riid, lcid,
		wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
	}
protected:
	static _tihclass _tih;
	static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
	{
		return _tih.GetTI(lcid, ppInfo);
	}
};

template <class T, const IID* piid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
IDispatchImpl<T, piid, plibid, wMajor, wMinor, tihclass>::_tihclass
IDispatchImpl<T, piid, plibid, wMajor, wMinor, tihclass>::_tih =
{piid, plibid, wMajor, wMinor, NULL, 0, NULL, 0};


/////////////////////////////////////////////////////////////////////////////
// IProvideClassInfoImpl
template <const CLSID* pcoclsid, const GUID* plibid = &CComModule::m_libid,
WORD wMajor = 1, WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IProvideClassInfoImpl : public IProvideClassInfo
{
public:
	typedef tihclass _tihclass;

	STDMETHOD(GetClassInfo)(ITypeInfo** pptinfo)
	{
		return _tih.GetTypeInfo(0, LANG_NEUTRAL, pptinfo);
	}

protected:
	static _tihclass _tih;
};

template <const CLSID* pcoclsid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
IProvideClassInfoImpl<pcoclsid, plibid, wMajor, wMinor, tihclass>::_tihclass
IProvideClassInfoImpl<pcoclsid, plibid, wMajor, wMinor, tihclass>::_tih =
{pcoclsid,plibid, wMajor, wMinor, NULL, 0, NULL, 0};

/////////////////////////////////////////////////////////////////////////////
// IProvideClassInfo2Impl
template <const CLSID* pcoclsid, const IID* psrcid, const GUID* plibid = &CComModule::m_libid,
WORD wMajor = 1, WORD wMinor = 0, class tihclass = CComTypeInfoHolder>
class ATL_NO_VTABLE IProvideClassInfo2Impl : public IProvideClassInfo2
{
public:
	typedef tihclass _tihclass;

	STDMETHOD(GetClassInfo)(ITypeInfo** pptinfo)
	{
		return _tih.GetTypeInfo(0, LANG_NEUTRAL, pptinfo);
	}
	STDMETHOD(GetGUID)(DWORD dwGuidKind, GUID* pGUID)
	{
		if (pGUID == NULL)
			return E_POINTER;

		if (dwGuidKind == GUIDKIND_DEFAULT_SOURCE_DISP_IID && psrcid)
		{
			*pGUID = *psrcid;
			return S_OK;
		}
		*pGUID = GUID_NULL;
		return E_FAIL;
	}

protected:
	static _tihclass _tih;
};


template <const CLSID* pcoclsid, const IID* psrcid, const GUID* plibid, WORD wMajor, WORD wMinor, class tihclass>
IProvideClassInfo2Impl<pcoclsid, psrcid, plibid, wMajor, wMinor, tihclass>::_tihclass
IProvideClassInfo2Impl<pcoclsid, psrcid, plibid, wMajor, wMinor, tihclass>::_tih =
{pcoclsid,plibid, wMajor, wMinor, NULL, 0, NULL, 0};


/////////////////////////////////////////////////////////////////////////////
// ISupportErrorInfoImpl

template <const IID* piid>
class ATL_NO_VTABLE ISupportErrorInfoImpl : public ISupportErrorInfo
{
public:
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid)
	{
		return (InlineIsEqualGUID(riid,*piid)) ? S_OK : S_FALSE;
	}
};


/////////////////////////////////////////////////////////////////////////////
// CComEnumImpl

// These _CopyXXX classes are used with enumerators in order to control
// how enumerated items are initialized, copied, and deleted

// Default is shallow copy with no special init or cleanup
template <class T>
class _Copy
{
public:
	static HRESULT copy(T* p1, T* p2) {memcpy(p1, p2, sizeof(T)); return S_OK;}
	static void init(T*) {}
	static void destroy(T*) {}
};

template<>
class _Copy<VARIANT>
{
public:
	static HRESULT copy(VARIANT* p1, VARIANT* p2) {return VariantCopy(p1, p2);}
	static void init(VARIANT* p) {p->vt = VT_EMPTY;}
	static void destroy(VARIANT* p) {VariantClear(p);}
};

template<>
class _Copy<LPOLESTR>
{
public:
	static HRESULT copy(LPOLESTR* p1, LPOLESTR* p2)
	{
		HRESULT hr = S_OK;
		(*p1) = (LPOLESTR)CoTaskMemAlloc(sizeof(OLECHAR)*(ocslen(*p2)+1));
		if (*p1 == NULL)
			hr = E_OUTOFMEMORY;
		else
			ocscpy(*p1,*p2);
		return hr;
	}
	static void init(LPOLESTR* p) {*p = NULL;}
	static void destroy(LPOLESTR* p) { CoTaskMemFree(*p);}
};

template<>
class _Copy<OLEVERB>
{
public:
	static HRESULT copy(OLEVERB* p1, OLEVERB* p2)
	{
		HRESULT hr = S_OK;
		*p1 = *p2;
		if (p2->lpszVerbName == NULL)
			return S_OK;
		p1->lpszVerbName = (LPOLESTR)CoTaskMemAlloc(sizeof(OLECHAR)*(ocslen(p2->lpszVerbName)+1));
		if (p1->lpszVerbName == NULL)
			hr = E_OUTOFMEMORY;
		else
			ocscpy(p1->lpszVerbName,p2->lpszVerbName);
		return hr;
	}
	static void init(OLEVERB* p) { p->lpszVerbName = NULL;}
	static void destroy(OLEVERB* p) { if (p->lpszVerbName) CoTaskMemFree(p->lpszVerbName);}
};

template<>
class _Copy<CONNECTDATA>
{
public:
	static HRESULT copy(CONNECTDATA* p1, CONNECTDATA* p2)
	{
		*p1 = *p2;
		if (p1->pUnk)
			p1->pUnk->AddRef();
		return S_OK;
	}
	static void init(CONNECTDATA* ) {}
	static void destroy(CONNECTDATA* p) {if (p->pUnk) p->pUnk->Release();}
};

template <class T>
class _CopyInterface
{
public:
	static HRESULT copy(T** p1, T** p2)
	{
		*p1 = *p2;
		if (*p1)
			(*p1)->AddRef();
		return S_OK;
	}
	static void init(T** ) {}
	static void destroy(T** p) {if (*p) (*p)->Release();}
};

template<class T>
class ATL_NO_VTABLE CComIEnum : public IUnknown
{
public:
	STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched) = 0;
	STDMETHOD(Skip)(ULONG celt) = 0;
	STDMETHOD(Reset)(void) = 0;
	STDMETHOD(Clone)(CComIEnum<T>** ppEnum) = 0;
};


enum CComEnumFlags
{
	//see FlagBits in CComEnumImpl
	AtlFlagNoCopy = 0,
	AtlFlagTakeOwnership = 2,
	AtlFlagCopy = 3 // copy implies ownership
};

template <class Base, const IID* piid, class T, class Copy, class ROOT>
class ATL_NO_VTABLE CComEnumImpl : public Base
{
public:
	CComEnumImpl() {m_begin = m_end = m_iter = NULL; m_dwFlags = 0;}
	~CComEnumImpl();
	STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched);
	STDMETHOD(Skip)(ULONG celt);
	STDMETHOD(Reset)(void){ATL_ROOT_LOCK(); m_iter = m_begin;return S_OK;}
	STDMETHOD(Clone)(Base** ppEnum);
	HRESULT Init(T* begin, T* end, IUnknown* pUnk,
		CComEnumFlags flags = AtlFlagNoCopy);
	CComPtr<IUnknown> m_spUnk;
	T* m_begin;
	T* m_end;
	T* m_iter;
	DWORD m_dwFlags;
protected:
	enum FlagBits
	{
		BitCopy=1,
		BitOwn=2
	};
};

template <class Base, const IID* piid, class T, class Copy, class ROOT>
CComEnumImpl<Base, piid, T, Copy, ROOT>::~CComEnumImpl()
{
	if (m_dwFlags & BitOwn)
	{
		for (T* p = m_begin; p != m_end; p++)
			Copy::destroy(p);
		delete [] m_begin;
	}
}

template <class Base, const IID* piid, class T, class Copy, class ROOT>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy, ROOT>::Next(ULONG celt, T* rgelt,
	ULONG* pceltFetched)
{
	ATL_ROOT_LOCK();
    if ((celt == 0) && (rgelt == NULL) && (NULL != pceltFetched))
    {
        // Return the number of remaining elements
        *pceltFetched = (ULONG)(m_end - m_iter);
        return S_OK;
    }
	if (rgelt == NULL || (celt != 1 && pceltFetched == NULL))
		return E_POINTER;
	if (m_begin == NULL || m_end == NULL || m_iter == NULL)
		return E_FAIL;
	ULONG nRem = (ULONG)(m_end - m_iter);
	HRESULT hRes = S_OK;
	if (nRem < celt)
		hRes = S_FALSE;
	ULONG nMin = min(celt, nRem);
	if (pceltFetched != NULL)
		*pceltFetched = nMin;
	T* pelt = rgelt;
	while(nMin--)
	{
		HRESULT hr = Copy::copy(pelt, m_iter);
		if (FAILED(hr))
		{
			while (rgelt < pelt)
				Copy::destroy(rgelt++);
			if (pceltFetched != NULL)
				*pceltFetched = 0;
			return hr;
		}
		pelt++;
		m_iter++;
	}
	return hRes;
}

template <class Base, const IID* piid, class T, class Copy, class ROOT>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy, ROOT>::Skip(ULONG celt)
{
	ATL_ROOT_LOCK();
    m_iter += celt;
    if (m_iter >= m_end)
	{
        m_iter = m_end;
        return S_FALSE;
    }
    if (m_iter < m_begin)
	{	
        m_iter = m_begin;
        return S_FALSE;
    }
    return S_OK;
}

template <class Base, const IID* piid, class T, class Copy, class ROOT>
STDMETHODIMP CComEnumImpl<Base, piid, T, Copy, ROOT>::Clone(Base** ppEnum)
{
	ATL_ROOT_LOCK();
	typedef CComObject<CComEnum<Base, piid, T, Copy> > _class;
	HRESULT hRes = E_POINTER;
	if (ppEnum != NULL)
	{
		*ppEnum = NULL;
		_class* p;
		hRes = _class::CreateInstance(&p);
		if (SUCCEEDED(hRes))
		{
			// If the data is a copy then we need to keep "this" object around
			hRes = p->Init(m_begin, m_end, (m_dwFlags & BitCopy) ? this : m_spUnk);
			if (SUCCEEDED(hRes))
			{
				p->m_iter = m_iter;
				hRes = p->_InternalQueryInterface(*piid, (void**)ppEnum);
			}
			if (FAILED(hRes))
				delete p;
		}
	}
	return hRes;
}

template <class Base, const IID* piid, class T, class Copy, class ROOT>
HRESULT CComEnumImpl<Base, piid, T, Copy, ROOT>::Init(T* begin, T* end, IUnknown* pUnk,
	CComEnumFlags flags)
{
	ATL_ROOT_LOCK();
	if (flags == AtlFlagCopy)
	{
		ATLASSERT(m_begin == NULL); //Init called twice?
		ATLTRY(m_begin = new T[ULONG(end-begin)])
		m_iter = m_begin;
		if (m_begin == NULL)
			return E_OUTOFMEMORY;
		for (T* i=begin; i != end; i++)
		{
			Copy::init(m_iter);
			HRESULT hr = Copy::copy(m_iter, i);
			if (FAILED(hr))
			{
				T* p = m_begin;
				while (p < m_iter)
					Copy::destroy(p++);
				delete [] m_begin;
				m_begin = m_end = m_iter = NULL;
				return hr;
			}
			m_iter++;
		}
		m_end = m_begin + (end-begin);
	}
	else
	{
		m_begin = begin;
		m_end = end;
	}
	m_spUnk = pUnk;
	m_iter = m_begin;
	m_dwFlags = flags;
	return S_OK;
}

template <class Base, const IID* piid, class T, class Copy, class ThreadModel = CComObjectThreadModel>
class ATL_NO_VTABLE CComEnum :
	public CComEnumImpl<Base, piid, T, Copy, CComEnum<Base, piid, T, Copy, ThreadModel> >,
	public CComObjectRootEx< ThreadModel >
{
public:
	typedef CComEnum<Base, piid, T, Copy, ThreadModel > _CComEnum;
	typedef CComEnumImpl<Base, piid, T, Copy, _CComEnum > _CComEnumBase;
	BEGIN_COM_MAP(_CComEnum)
		COM_INTERFACE_ENTRY_IID(*piid, _CComEnumBase)
	END_COM_MAP()
};

template <class Base, const IID* piid, class T, class Copy, class CollType, class ROOT>
class ATL_NO_VTABLE IEnumOnSTLImpl : public Base
{
public:
	HRESULT Init(IUnknown *pUnkForRelease, CollType& collection)
	{
		ATL_ROOT_LOCK();
		m_spUnk = pUnkForRelease;
		m_pcollection = &collection;
		m_iter = m_pcollection->begin();
		return S_OK;
	}
	STDMETHOD(Next)(ULONG celt, T* rgelt, ULONG* pceltFetched);
	STDMETHOD(Skip)(ULONG celt);
	STDMETHOD(Reset)(void)
	{
		ATL_ROOT_LOCK();
		if (m_pcollection == NULL)
			return E_FAIL;
		m_iter = m_pcollection->begin();
		return S_OK;
	}
	STDMETHOD(Clone)(Base** ppEnum);
//Data
	CComPtr<IUnknown> m_spUnk;
	CollType* m_pcollection;
	CollType::iterator m_iter;
};

template <class Base, const IID* piid, class T, class Copy, class CollType, class ROOT>
STDMETHODIMP IEnumOnSTLImpl<Base, piid, T, Copy, CollType, ROOT>::Next(ULONG celt, T* rgelt,
	ULONG* pceltFetched)
{
	if (rgelt == NULL || (celt != 1 && pceltFetched == NULL))
		return E_POINTER;
    if (pceltFetched != NULL)
            *pceltFetched = 0;
	ATL_ROOT_LOCK();
	if (m_pcollection == NULL)
		return E_FAIL;

	ULONG nActual = 0;
	HRESULT hr = S_OK;
	T* pelt = rgelt;
	while (SUCCEEDED(hr) && m_iter != m_pcollection->end() && nActual < celt)
	{
		hr = Copy::copy(pelt, &*m_iter);
		if (FAILED(hr))
		{
			while (rgelt < pelt)
				Copy::destroy(rgelt++);
			nActual = 0;
		}
		else
		{
			pelt++;
			m_iter++;
			nActual++;
		}
	}
    if (SUCCEEDED(hr))
    {
            if (pceltFetched)
                    *pceltFetched = nActual;
            if (nActual < celt)
                    hr = S_FALSE;
    }                        
	return hr;
}

template <class Base, const IID* piid, class T, class Copy, class CollType, class ROOT>
STDMETHODIMP IEnumOnSTLImpl<Base, piid, T, Copy, CollType, ROOT>::Skip(ULONG celt)
{
	HRESULT hr = S_OK;
	ATL_ROOT_LOCK();
	while (celt--)
	{
		if (m_iter != m_pcollection->end())
			m_iter++;
		else
		{
			hr = S_FALSE;
			break;
		}
	}
	return hr;
}

template <class Base, const IID* piid, class T, class Copy, class CollType, class ROOT>
STDMETHODIMP IEnumOnSTLImpl<Base, piid, T, Copy, CollType, ROOT>::Clone(Base** ppEnum)
{
	typedef CComObject<ROOT> _class;
	HRESULT hRes = E_POINTER;
	if (ppEnum != NULL)
	{
		*ppEnum = NULL;
		_class* p;
		hRes = _class::CreateInstance(&p);
		if (SUCCEEDED(hRes))
		{
			hRes = p->Init(m_spUnk, *m_pcollection);
			if (SUCCEEDED(hRes))
			{
				ATL_ROOT_LOCK();
				p->m_iter = m_iter;
				hRes = p->_InternalQueryInterface(*piid, (void**)ppEnum);
			}
			if (FAILED(hRes))
				delete p;
		}
	}
	return hRes;
}

template <class Base, const IID* piid, class T, class Copy, class CollType, class ThreadModel = CComObjectThreadModel>
class ATL_NO_VTABLE CComEnumOnSTL :
	public IEnumOnSTLImpl<Base, piid, T, Copy, CollType, CComEnumOnSTL<Base, piid, T, Copy, CollType, ThreadModel> >,
	public CComObjectRootEx< ThreadModel >
{
public:
	typedef CComEnumOnSTL<Base, piid, T, Copy, CollType, ThreadModel > _CComEnum;
	typedef IEnumOnSTLImpl<Base, piid, T, Copy, CollType, _CComEnum > _CComEnumBase;
	BEGIN_COM_MAP(_CComEnum)
		COM_INTERFACE_ENTRY_IID(*piid, _CComEnumBase)
	END_COM_MAP()
};

template <class T, class CollType, class ItemType, class CopyItem, class EnumType>
class ICollectionOnSTLImpl : public T
{
public:
	STDMETHOD(get_Count)(long* pcount)
	{
		if (pcount == NULL)
			return E_POINTER;
		ATL_LOCK();
		*pcount = m_coll.size();
		return S_OK;
	}
	STDMETHOD(get_Item)(long Index, ItemType* pvar)
	{
		//Index is 1-based
		if (pvar == NULL)
			return E_POINTER;
        if (Index < 1)
                return E_INVALIDARG;                        
		HRESULT hr = E_FAIL;
		Index--;
		ATL_LOCK();
		CollType::iterator iter = m_coll.begin();
		while (iter != m_coll.end() && Index > 0)
		{
			iter++;
			Index--;
		}
		if (iter != m_coll.end())
			hr = CopyItem::copy(pvar, &*iter);
		return hr;
	}
	STDMETHOD(get__NewEnum)(IUnknown** ppUnk)
	{
		if (ppUnk == NULL)
			return E_POINTER;
		*ppUnk = NULL;
		HRESULT hRes = S_OK;
		CComObject<EnumType>* p;
		hRes = CComObject<EnumType>::CreateInstance(&p);
		if (SUCCEEDED(hRes))
		{
			ATL_LOCK();
			hRes = p->Init(this, m_coll);
			if (hRes == S_OK)
				hRes = p->QueryInterface(IID_IUnknown, (void**)ppUnk);
		}
		if (hRes != S_OK)
			delete p;
		return hRes;
	}
	CollType m_coll;
};

//////////////////////////////////////////////////////////////////////////////
// ISpecifyPropertyPagesImpl
template <class T>
class ATL_NO_VTABLE ISpecifyPropertyPagesImpl : public ISpecifyPropertyPages
{
public:
	// ISpecifyPropertyPages
	//
	STDMETHOD(GetPages)(CAUUID* pPages)
	{
		ATLTRACE2(atlTraceCOM, 0, _T("ISpecifyPropertyPagesImpl::GetPages\n"));
		ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		return GetPagesHelper(pPages, pMap);
	}
protected:
        HRESULT GetPagesHelper(CAUUID* pPages, ATL_PROPMAP_ENTRY* pMap)
        {
                if (pPages == NULL)
                        return E_POINTER;

                ATLASSERT(pMap != NULL);
                if (pMap == NULL)
                        return E_POINTER;

                int nCnt = 0;
                int i;
                // Get count of unique pages to alloc the array
                for (i = 0; pMap[i].pclsidPropPage != NULL; i++)
                {
                        // only allow non data entry types
                        if (pMap[i].vt == 0)
                        {
                                // Does this property have a page?  CLSID_NULL means it does not
                                if (!InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL))
                                        nCnt++;
                        }
                }
                pPages->pElems = (GUID*) CoTaskMemAlloc(sizeof(CLSID)*nCnt);
                if (pPages->pElems == NULL)
                        return E_OUTOFMEMORY;
                // reset count of items we have added to the array
                nCnt = 0;
                for (i = 0; pMap[i].pclsidPropPage != NULL; i++)
                {
                        // only allow non data entry types
                        if (pMap[i].vt == 0)
                        {
                                // Does this property have a page?  CLSID_NULL means it does not
                                if (!InlineIsEqualGUID(*pMap[i].pclsidPropPage, CLSID_NULL))
                                {
                                        BOOL bFound = FALSE;
                                        // Search through array we are building up to see
                                        // if it is already in there
                                        for (int j=0; j<nCnt; j++)
                                        {
                                                if (InlineIsEqualGUID(*(pMap[i].pclsidPropPage), pPages->pElems[j]))
                                                {
                                                        // It's already there, so no need to add it again
                                                        bFound = TRUE;
                                                        break;
                                                }
                                        }
                                        // If we didn't find it in there then add it
                                        if (!bFound)
                                                pPages->pElems[nCnt++] = *pMap[i].pclsidPropPage;
                                }
                        }
                }
                pPages->cElems = nCnt;
                return S_OK;
        }

};

#ifndef _ATL_NO_CONNECTION_POINTS
/////////////////////////////////////////////////////////////////////////////
// Connection Points

struct _ATL_CONNMAP_ENTRY
{
	DWORD_PTR dwOffset;
};


// We want the offset of the connection point relative to the connection
// point container base class
#define BEGIN_CONNECTION_POINT_MAP(x)\
	typedef x _atl_conn_classtype;\
	static const _ATL_CONNMAP_ENTRY* GetConnMap(int* pnEntries) {\
	static const _ATL_CONNMAP_ENTRY _entries[] = {
// CONNECTION_POINT_ENTRY computes the offset of the connection point to the
// IConnectionPointContainer interface
#define CONNECTION_POINT_ENTRY(iid){offsetofclass(_ICPLocator<&iid>, _atl_conn_classtype)-\
	offsetofclass(IConnectionPointContainerImpl<_atl_conn_classtype>, _atl_conn_classtype)},
#define END_CONNECTION_POINT_MAP() {(DWORD_PTR)-1} }; \
	if (pnEntries) *pnEntries = sizeof(_entries)/sizeof(_ATL_CONNMAP_ENTRY) - 1; \
	return _entries;}


#ifndef _DEFAULT_VECTORLENGTH
#define _DEFAULT_VECTORLENGTH 4
#endif

template <unsigned int nMaxSize>
class CComUnkArray
{
public:
	CComUnkArray()
	{
		memset(m_arr, 0, sizeof(IUnknown*)*nMaxSize);
	}
	DWORD Add(IUnknown* pUnk);
	BOOL Remove(DWORD dwCookie);
	DWORD WINAPI GetCookie(IUnknown** pp)
	{
		ULONG iIndex;

		iIndex = ULONG(pp-begin());
		return( iIndex+1 );
	}
	IUnknown* WINAPI GetUnknown(DWORD dwCookie)
	{
		if( dwCookie == 0 )
		{
			return NULL;
		}
		
		ULONG iIndex;
		iIndex = dwCookie-1;
		return( begin()[iIndex] );
	}
	IUnknown** begin()
	{
		return &m_arr[0];
	}
	IUnknown** end()
	{
		return &m_arr[nMaxSize];
	}
protected:
	IUnknown* m_arr[nMaxSize];
};

template <unsigned int nMaxSize>
inline DWORD CComUnkArray<nMaxSize>::Add(IUnknown* pUnk)
{
	for (IUnknown** pp = begin();pp<end();pp++)
	{
		if (*pp == NULL)
		{
			*pp = pUnk;
			return (DWORD)((pp-begin())+1); // return cookie
		}
	}
	// If this fires then you need a larger array
	ATLASSERT(0);
	return 0;
}

template <unsigned int nMaxSize>
inline BOOL CComUnkArray<nMaxSize>::Remove(DWORD dwCookie)
{
	ULONG iIndex;

	iIndex = dwCookie-1;
	if (iIndex >= nMaxSize)
	{
		return FALSE;
	}

	begin()[iIndex] = NULL;

	return TRUE;
}

template<>
class CComUnkArray<1>
{
public:
	CComUnkArray()
	{
		m_arr[0] = NULL;
	}
	DWORD Add(IUnknown* pUnk)
	{
		if (m_arr[0] != NULL)
		{
			// If this fires then you need a larger array
			ATLASSERT(0);
			return 0;
		}
		m_arr[0] = pUnk;
		return 1;
	}
	BOOL Remove(DWORD dwCookie)
	{
		if (dwCookie != 1)
			return FALSE;
		m_arr[0] = NULL;
		return TRUE;
	}
	DWORD WINAPI GetCookie(IUnknown** /*pp*/)
	{
		return 1;
	}
	IUnknown* WINAPI GetUnknown(DWORD dwCookie)
	{
		if (dwCookie != 1)
		{
			return NULL;
		}

		return *begin();
	}
	IUnknown** begin()
	{
		return &m_arr[0];
	}
	IUnknown** end()
	{
		return (&m_arr[0])+1;
	}
protected:
	IUnknown* m_arr[1];
};

class CComDynamicUnkArray
{
public:
	CComDynamicUnkArray()
	{
		m_nSize = 0;
		m_ppUnk = NULL;
	}

	~CComDynamicUnkArray()
	{
		if (m_nSize > 1)
			free(m_ppUnk);
	}
	DWORD Add(IUnknown* pUnk);
	BOOL Remove(DWORD dwCookie);
	DWORD WINAPI GetCookie(IUnknown** pp)
	{
		ULONG iIndex;
		iIndex = ULONG(pp-begin());
		return iIndex+1;
	}
	IUnknown* WINAPI GetUnknown(DWORD dwCookie)
	{
		ULONG iIndex;

		if (dwCookie == 0)
			return NULL;

		iIndex = dwCookie-1;
		return begin()[iIndex];
	}
	IUnknown** begin()
	{
		return (m_nSize < 2) ? &m_pUnk : m_ppUnk;
	}
	IUnknown** end()
	{
		return (m_nSize < 2) ? (&m_pUnk)+m_nSize : &m_ppUnk[m_nSize];
	}

	IUnknown* GetAt(int nIndex)
	{
		if (nIndex < 0 || nIndex >= m_nSize)
			return NULL;

		return (m_nSize < 2) ? m_pUnk : m_ppUnk[nIndex];
	}
	int GetSize() const
	{
		return m_nSize;
	}

	void clear()
	{
		if (m_nSize > 1)
			free(m_ppUnk);
		m_nSize = 0;
	}
protected:
	union
	{
		IUnknown** m_ppUnk;
		IUnknown* m_pUnk;
	};
	int m_nSize;
};

inline DWORD CComDynamicUnkArray::Add(IUnknown* pUnk)
{
	ULONG iIndex;

	IUnknown** pp = NULL;
	if (m_nSize == 0) // no connections
	{
		m_pUnk = pUnk;
		m_nSize = 1;
		return 1;
	}
	else if (m_nSize == 1)
	{
		//create array
		pp = (IUnknown**)malloc(sizeof(IUnknown*)*_DEFAULT_VECTORLENGTH);
		if (pp == NULL)
			return 0;
		memset(pp, 0, sizeof(IUnknown*)*_DEFAULT_VECTORLENGTH);
		*pp = m_pUnk;
		m_ppUnk = pp;
		m_nSize = _DEFAULT_VECTORLENGTH;
	}
	for (pp = begin();pp<end();pp++)
	{
		if (*pp == NULL)
		{
			*pp = pUnk;
			iIndex = ULONG(pp-begin());
			return iIndex+1;
		}
	}
	int nAlloc = m_nSize*2;
	pp = (IUnknown**)realloc(m_ppUnk, sizeof(IUnknown*)*nAlloc);
	if (pp == NULL)
		return 0;
	m_ppUnk = pp;
	memset(&m_ppUnk[m_nSize], 0, sizeof(IUnknown*)*m_nSize);
	m_ppUnk[m_nSize] = pUnk;
	iIndex = m_nSize;
	m_nSize = nAlloc;
	return iIndex+1;
}

inline BOOL CComDynamicUnkArray::Remove(DWORD dwCookie)
{
	ULONG iIndex;
	if (dwCookie == NULL)
		return FALSE;
	if (m_nSize == 0)
		return FALSE;
	iIndex = dwCookie-1;
	if (iIndex >= (ULONG)m_nSize)
		return FALSE;
	if (m_nSize == 1)
	{
		m_nSize = 0;
		return TRUE;
	}
	begin()[iIndex] = NULL;

	return TRUE;
}


template <const IID* piid>
class ATL_NO_VTABLE _ICPLocator
{
public:
	//this method needs a different name than QueryInterface
	STDMETHOD(_LocCPQueryInterface)(REFIID riid, void ** ppvObject) = 0;
	virtual ULONG STDMETHODCALLTYPE AddRef(void) = 0;\
	virtual ULONG STDMETHODCALLTYPE Release(void) = 0;
};

template <class T, const IID* piid, class CDV = CComDynamicUnkArray >
class ATL_NO_VTABLE IConnectionPointImpl : public _ICPLocator<piid>
{
public:
	typedef CComEnum<IEnumConnections, &IID_IEnumConnections, CONNECTDATA,
		_Copy<CONNECTDATA> > CComEnumConnections;
	typedef CDV _CDV;
	~IConnectionPointImpl();
        STDMETHOD(_LocCPQueryInterface)(REFIID riid, void ** ppvObject)
        {
                _ATL_VALIDATE_OUT_POINTER(ppvObject);
                
                if (InlineIsEqualGUID(riid, IID_IConnectionPoint) || InlineIsEqualUnknown(riid))
                {
                        *ppvObject = this;
                        AddRef();
#ifdef _ATL_DEBUG_INTERFACES
                        _Module.AddThunk((IUnknown**)ppvObject, _T("IConnectionPointImpl"), riid);
#endif // _ATL_DEBUG_INTERFACES
                        return S_OK;
                }
                else
                        return E_NOINTERFACE;
        }

	STDMETHOD(GetConnectionInterface)(IID* piid2)
	{
		if (piid2 == NULL)
			return E_POINTER;
		*piid2 = *piid;
		return S_OK;
	}
	STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer** ppCPC)
	{
		T* pT = static_cast<T*>(this);
		// No need to check ppCPC for NULL since QI will do that for us
		return pT->QueryInterface(IID_IConnectionPointContainer, (void**)ppCPC);
	}
	STDMETHOD(Advise)(IUnknown* pUnkSink, DWORD* pdwCookie);
	STDMETHOD(Unadvise)(DWORD dwCookie);
	STDMETHOD(EnumConnections)(IEnumConnections** ppEnum);
	CDV m_vec;
};

template <class T, const IID* piid, class CDV>
IConnectionPointImpl<T, piid, CDV>::~IConnectionPointImpl()
{
	IUnknown** pp = m_vec.begin();
	while (pp < m_vec.end())
	{
		if (*pp != NULL)
			(*pp)->Release();
		pp++;
	}
}

template <class T, const IID* piid, class CDV>
STDMETHODIMP IConnectionPointImpl<T, piid, CDV>::Advise(IUnknown* pUnkSink,
	DWORD* pdwCookie)
{
	T* pT = static_cast<T*>(this);
	IUnknown* p;
	HRESULT hRes = S_OK;
	if (pUnkSink == NULL || pdwCookie == NULL)
		return E_POINTER;
    *pdwCookie = 0;
	IID iid;
	GetConnectionInterface(&iid);
	hRes = pUnkSink->QueryInterface(iid, (void**)&p);
	if (SUCCEEDED(hRes))
	{
		pT->Lock();
		*pdwCookie = m_vec.Add(p);
		hRes = (*pdwCookie != NULL) ? S_OK : CONNECT_E_ADVISELIMIT;
		pT->Unlock();
		if (hRes != S_OK)
			p->Release();
	}
	else if (hRes == E_NOINTERFACE)
		hRes = CONNECT_E_CANNOTCONNECT;
	if (FAILED(hRes))
		*pdwCookie = 0;
	return hRes;
}

template <class T, const IID* piid, class CDV>
STDMETHODIMP IConnectionPointImpl<T, piid, CDV>::Unadvise(DWORD dwCookie)
{
	T* pT = static_cast<T*>(this);
	pT->Lock();
	IUnknown* p = m_vec.GetUnknown(dwCookie);
	HRESULT hRes = m_vec.Remove(dwCookie) ? S_OK : CONNECT_E_NOCONNECTION;
	pT->Unlock();
	if (hRes == S_OK && p != NULL)
		p->Release();
	return hRes;
}

template <class T, const IID* piid, class CDV>
STDMETHODIMP IConnectionPointImpl<T, piid, CDV>::EnumConnections(
	IEnumConnections** ppEnum)
{
	if (ppEnum == NULL)
		return E_POINTER;
	*ppEnum = NULL;
	CComObject<CComEnumConnections>* pEnum = NULL;
	ATLTRY(pEnum = new CComObject<CComEnumConnections>)
	if (pEnum == NULL)
		return E_OUTOFMEMORY;
	T* pT = static_cast<T*>(this);
	pT->Lock();
	CONNECTDATA* pcd = NULL;
	ATLTRY(pcd = new CONNECTDATA[ULONG(m_vec.end()-m_vec.begin())])
	if (pcd == NULL)
	{
		delete pEnum;
		pT->Unlock();
		return E_OUTOFMEMORY;
	}
	CONNECTDATA* pend = pcd;
	// Copy the valid CONNECTDATA's
	for (IUnknown** pp = m_vec.begin();pp<m_vec.end();pp++)
	{
		if (*pp != NULL)
		{
			(*pp)->AddRef();
			pend->pUnk = *pp;
			pend->dwCookie = m_vec.GetCookie(pp);
			pend++;
		}
	}
	// don't copy the data, but transfer ownership to it
	pEnum->Init(pcd, pend, NULL, AtlFlagTakeOwnership);
	pT->Unlock();
	HRESULT hRes = pEnum->_InternalQueryInterface(IID_IEnumConnections, (void**)ppEnum);
	if (FAILED(hRes))
		delete pEnum;
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// IConnectionPointContainerImpl

template <class T>
class ATL_NO_VTABLE IConnectionPointContainerImpl : public IConnectionPointContainer
{
	typedef CComEnum<IEnumConnectionPoints,
		&IID_IEnumConnectionPoints, IConnectionPoint*,
		_CopyInterface<IConnectionPoint> >
		CComEnumConnectionPoints;
public:
	STDMETHOD(EnumConnectionPoints)(IEnumConnectionPoints** ppEnum)
	{
		if (ppEnum == NULL)
			return E_POINTER;
		*ppEnum = NULL;
		CComEnumConnectionPoints* pEnum = NULL;
		ATLTRY(pEnum = new CComObject<CComEnumConnectionPoints>)
		if (pEnum == NULL)
			return E_OUTOFMEMORY;

		int nCPCount;
		const _ATL_CONNMAP_ENTRY* pEntry = T::GetConnMap(&nCPCount);

		// allocate an initialize a vector of connection point object pointers
		IConnectionPoint** ppCP = (IConnectionPoint**)alloca(sizeof(IConnectionPoint*)*nCPCount);

		int i = 0;
		while (pEntry->dwOffset != (DWORD_PTR)-1)
		{
			ppCP[i++] = (IConnectionPoint*)((INT_PTR)this+pEntry->dwOffset);
			pEntry++;
		}

		// copy the pointers: they will AddRef this object
		HRESULT hRes = pEnum->Init((IConnectionPoint**)&ppCP[0],
			(IConnectionPoint**)&ppCP[nCPCount],
			reinterpret_cast<IConnectionPointContainer*>(this), AtlFlagCopy);
		if (FAILED(hRes))
		{
			delete pEnum;
			return hRes;
		}
		hRes = pEnum->QueryInterface(IID_IEnumConnectionPoints, (void**)ppEnum);
		if (FAILED(hRes))
			delete pEnum;
		return hRes;
	}
	STDMETHOD(FindConnectionPoint)(REFIID riid, IConnectionPoint** ppCP)
	{
		if (ppCP == NULL)
			return E_POINTER;
		*ppCP = NULL;
		HRESULT hRes = CONNECT_E_NOCONNECTION;
		const _ATL_CONNMAP_ENTRY* pEntry = T::GetConnMap(NULL);
		IID iid;
		while (pEntry->dwOffset != (DWORD_PTR)-1)
		{
			IConnectionPoint* pCP =
				(IConnectionPoint*)((INT_PTR)this+pEntry->dwOffset);
			if (SUCCEEDED(pCP->GetConnectionInterface(&iid)) &&
				InlineIsEqualGUID(riid, iid))
			{
				*ppCP = pCP;
				pCP->AddRef();
				hRes = S_OK;
				break;
			}
			pEntry++;
		}
		return hRes;
	}
};


#endif //!_ATL_NO_CONNECTION_POINTS

#pragma pack(pop)

/////////////////////////////////////////////////////////////////////////////
// CComAutoThreadModule

template <class ThreadAllocator>
inline HRESULT CComAutoThreadModule<ThreadAllocator>::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, const GUID* plibid, int nThreads)
{
	m_nThreads = nThreads;
	m_pApartments = NULL;
	ATLTRY(m_pApartments = new CComApartment[m_nThreads]);
	ATLASSERT(m_pApartments != NULL);
	if(m_pApartments == NULL)
		return E_OUTOFMEMORY;
    for (int i = 0; i < nThreads; i++)
    {
            m_pApartments[i].m_hThread = CreateThread(NULL, 0, CComApartment::_Apartment, (void*)&m_pApartments[i], 0, &m_pApartments[i].m_dwThreadID);
            if(m_pApartments[i].m_hThread == NULL)
                    return AtlHresultFromLastError();
    }
	CComApartment::ATL_CREATE_OBJECT = RegisterWindowMessage(_T("ATL_CREATE_OBJECT"));
	return CComModule::Init(p, h, plibid);
}

template <class ThreadAllocator>
inline LONG CComAutoThreadModule<ThreadAllocator>::Lock()
{
	LONG l = CComModule::Lock();
	DWORD dwThreadID = GetCurrentThreadId();
	for (int i=0; i < m_nThreads; i++)
	{
		if (m_pApartments[i].m_dwThreadID == dwThreadID)
		{
			m_pApartments[i].Lock();
			break;
		}
	}
	return l;
}

template <class ThreadAllocator>
inline LONG CComAutoThreadModule<ThreadAllocator>::Unlock()
{
	LONG l = CComModule::Unlock();
	DWORD dwThreadID = GetCurrentThreadId();
	for (int i=0; i < m_nThreads; i++)
	{
		if (m_pApartments[i].m_dwThreadID == dwThreadID)
		{
			m_pApartments[i].Unlock();
			break;
		}
	}
	return l;
}

template <class ThreadAllocator>
HRESULT CComAutoThreadModule<ThreadAllocator>::CreateInstance(void* pfnCreateInstance, REFIID riid, void** ppvObj)
{
        _ATL_CREATORFUNC* pFunc = (_ATL_CREATORFUNC*) pfnCreateInstance;
        _AtlAptCreateObjData data;
        data.pfnCreateInstance = pFunc;
        data.piid = &riid;
        data.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        data.hRes = S_OK;
        int nThread = m_Allocator.GetThread(m_pApartments, m_nThreads);
        
        int nIterations = 0;
        while(::PostThreadMessage(m_pApartments[nThread].m_dwThreadID, CComApartment::ATL_CREATE_OBJECT, 0, (LPARAM)&data) == 0
                        && ++ nIterations < 100)
        {
                Sleep(100);
        }
        
        if (nIterations < 100)
        {
                AtlWaitWithMessageLoop(data.hEvent);
        }
        else
        {
                data.hRes = AtlHresultFromLastError();
        }
        
        CloseHandle(data.hEvent);
        if (SUCCEEDED(data.hRes))
                data.hRes = CoGetInterfaceAndReleaseStream(data.pStream, riid, ppvObj);
        return data.hRes;
}

template <class ThreadAllocator>
CComAutoThreadModule<ThreadAllocator>::~CComAutoThreadModule()
{
	for (int i=0; i < m_nThreads; i++)
	{
		::PostThreadMessage(m_pApartments[i].m_dwThreadID, WM_QUIT, 0, 0);
		::WaitForSingleObject(m_pApartments[i].m_hThread, INFINITE);
        ::CloseHandle(m_pApartments[i].m_hThread);
	}
	delete[] m_pApartments;
}

}; //namespace ATL

#endif // __ATLCOM_H__
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\atl\atlconv.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-2001 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.


// seanmcd -- this is a cut down version of atl7's atlconv.h used to replace the atl3
// version in order to get prefast to shut up about use of _alloca
// since it now throws on out of memory conditions in the ctor i've modified it to use my
// exception hierarchy so i don't have to change any of my catches.

#ifndef __ATLCONV_H__
#define __ATLCONV_H__

#pragma once

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (push)
#pragma warning(disable: 4127) // unreachable code
#endif //!_ATL_NO_PRAGMA_WARNINGS

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#if defined(OLE2ANSI)
    #error this version of the atl conversion functions doesn't support OLE2ANSI
#endif

#include <atldef.h>
#include <stddef.h>

#ifndef NO_CUSTOM_THROW
#include "..\throw.h"
#else
#define THROWCOM(x) throw x;
#endif

#ifndef __wtypes_h__

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_IX86)
#define _X86_
#endif

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_AMD64)
#define _AMD64_
#endif

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_M68K)
#define _68K_
#endif

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_IA64_) && !defined(_AMD64_) && defined(_M_MPPC)
#define _MPPC_
#endif

#if !defined(_68K_) && !defined(_MPPC_) && !defined(_X86_) && !defined(_M_IX86) && !defined(_AMD64_) && defined(_M_IA64)
#if !defined(_IA64_)
#define _IA64_
#endif // !_IA64_
#endif

#include <stdarg.h>
#include <windef.h>
#include <winbase.h>
#include <winnls.h>

#if defined(_WIN32)

typedef WCHAR OLECHAR;
typedef OLECHAR  *LPOLESTR;
typedef const OLECHAR  *LPCOLESTR;
#define OLESTR(str) L##str

#else
#error only _WIN32 supported by this version
#endif // _WIN32

#endif	// __wtypes_h__

#ifndef _OLEAUTO_H_
typedef LPWSTR BSTR;// must (semantically) match typedef in oleauto.h

extern "C"
{
__declspec(dllimport) BSTR __stdcall SysAllocString(const OLECHAR *);
__declspec(dllimport) BSTR __stdcall SysAllocStringLen(const OLECHAR *, UINT);
__declspec(dllimport) INT  __stdcall SysReAllocStringLen(BSTR *, const OLECHAR *, UINT);
}
#endif

// we use our own implementation of InterlockedExchangePointer because of problems with the one in system headers
#ifdef _M_IX86
#undef InterlockedExchangePointer
inline void* WINAPI InterlockedExchangePointer(void** pp, void* pNew) throw()
{
	return( reinterpret_cast<void*>(static_cast<LONG_PTR>(::InterlockedExchange(reinterpret_cast<LONG*>(pp), static_cast<LONG>(reinterpret_cast<LONG_PTR>(pNew))))) );
}
#endif
namespace ATL
{
#ifndef _CONVERSION_DONT_USE_THREAD_LOCALE
typedef UINT (WINAPI *ATLGETTHREADACP)();

inline UINT WINAPI _AtlGetThreadACPFake() throw()
{
	UINT nACP = 0;

	LCID lcidThread = ::GetThreadLocale();

	char szACP[7];
	// GetLocaleInfoA will fail for a Unicode-only LCID, but those are only supported on 
	// Windows 2000.  Since Windows 2000 supports CP_THREAD_ACP, this code path is never
	// executed on Windows 2000.
	if (::GetLocaleInfoA(lcidThread, LOCALE_IDEFAULTANSICODEPAGE, szACP, 7) != 0)
	{
		char* pch = szACP;
		while (*pch != '\0')
		{
			nACP *= 10;
			nACP += *pch++ - '0';
		}
	}
	// Use the Default ANSI Code Page if we were unable to get the thread ACP or if one does not exist.
	if (nACP == 0)
		nACP = ::GetACP();

	return nACP;
}

inline UINT WINAPI _AtlGetThreadACPReal() throw()
{
	return( CP_THREAD_ACP );
}

extern ATLGETTHREADACP g_pfnGetThreadACP;

inline UINT WINAPI _AtlGetThreadACPThunk() throw()
{
	OSVERSIONINFO ver;
	ATLGETTHREADACP pfnGetThreadACP;

	ver.dwOSVersionInfoSize = sizeof( ver );
	::GetVersionEx( &ver );
	if( (ver.dwPlatformId == VER_PLATFORM_WIN32_NT) && (ver.dwMajorVersion >= 5) )
	{
		// On Win2K, CP_THREAD_ACP is supported
		pfnGetThreadACP = _AtlGetThreadACPReal;
	}
	else
	{
		pfnGetThreadACP = _AtlGetThreadACPFake;
	}
	InterlockedExchangePointer( reinterpret_cast< void** >(&g_pfnGetThreadACP), pfnGetThreadACP );

	return( g_pfnGetThreadACP() );
}

__declspec( selectany ) ATLGETTHREADACP g_pfnGetThreadACP = _AtlGetThreadACPThunk;

inline UINT WINAPI _AtlGetConversionACP() throw()
{
	return( g_pfnGetThreadACP() );
}

#else

inline UINT WINAPI _AtlGetConversionACP() throw()
{
	return( CP_ACP );
}

#endif  // _CONVERSION_DONT_USE_THREAD_LOCALE

template< int t_nBufferLength = 128 >
class CW2WEX
{
public:
	CW2WEX( LPCWSTR psz ) throw(...) :
		m_psz( m_szBuffer )
	{
		Init( psz );
	}
	CW2WEX( LPCWSTR psz, UINT nCodePage ) throw(...) :
		m_psz( m_szBuffer )
	{
		(void)nCodePage;  // Code page doesn't matter

		Init( psz );
	}
	~CW2WEX() throw()
	{
		if( m_psz != m_szBuffer )
		{
			delete[] m_psz;
		}
	}

	operator LPWSTR() const throw()
	{
		return( m_psz );
	}

private:
	void Init( LPCWSTR psz ) throw(...)
	{
		if (psz == NULL)
		{
			m_psz = NULL;
			return;
		}
		int nLength = lstrlenW( psz )+1;
		if( nLength > t_nBufferLength )
		{
			m_psz = new WCHAR[nLength];
			if( m_psz == NULL )
			{
				THROWCOM(E_OUTOFMEMORY);
			}
		}
		memcpy( m_psz, psz, nLength*sizeof( wchar_t ) );
	}

public:
	LPWSTR m_psz;
	wchar_t m_szBuffer[t_nBufferLength];

private:
	CW2WEX( const CW2WEX& ) throw();
	CW2WEX& operator=( const CW2WEX& ) throw();
};
typedef CW2WEX<> CW2W;

template< int t_nBufferLength = 128 >
class CA2AEX
{
public:
	CA2AEX( LPCSTR psz ) throw(...) :
		m_psz( m_szBuffer )
	{
		Init( psz );
	}
	CA2AEX( LPCSTR psz, UINT nCodePage ) throw(...) :
		m_psz( m_szBuffer )
	{
		(void)nCodePage;  // Code page doesn't matter

		Init( psz );
	}
	~CA2AEX() throw()
	{
		if( m_psz != m_szBuffer )
		{
			delete[] m_psz;
		}
	}

	operator LPSTR() const throw()
	{
		return( m_psz );
	}

private:
	void Init( LPCSTR psz ) throw(...)
	{
		if (psz == NULL)
		{
			m_psz = NULL;
			return;
		}
		int nLength = lstrlenA( psz )+1;
		if( nLength > t_nBufferLength )
		{
			m_psz = new char[nLength]
			if( m_psz == NULL )
			{
				THROWCOM(E_OUTOFMEMORY);
			}
		}
		memcpy( m_psz, psz, nLength*sizeof( char ) );
	}

public:
	LPSTR m_psz;
	char m_szBuffer[t_nBufferLength];

private:
	CA2AEX( const CA2AEX& ) throw();
	CA2AEX& operator=( const CA2AEX& ) throw();
};
typedef CA2AEX<> CA2A;

template< int t_nBufferLength = 128 >
class CA2CAEX
{
public:
	CA2CAEX( LPCSTR psz ) throw(...) :
		m_psz( psz )
	{
	}
	CA2CAEX( LPCSTR psz, UINT nCodePage ) throw(...) :
		m_psz( psz )
	{
		(void)nCodePage;
	}
	~CA2CAEX() throw()
	{
	}

	operator LPCSTR() const throw()
	{
		return( m_psz );
	}

public:
	LPCSTR m_psz;

private:
	CA2CAEX( const CA2CAEX& ) throw();
	CA2CAEX& operator=( const CA2CAEX& ) throw();
};
typedef CA2CAEX<> CA2CA;

template< int t_nBufferLength = 128 >
class CW2CWEX
{
public:
	CW2CWEX( LPCWSTR psz ) throw(...) :
		m_psz( psz )
	{
	}
	CW2CWEX( LPCWSTR psz, UINT nCodePage ) throw(...) :
		m_psz( psz )
	{
		(void)nCodePage;
	}
	~CW2CWEX() throw()
	{
	}

	operator LPCWSTR() const throw()
	{
		return( m_psz );
	}

public:
	LPCWSTR m_psz;

private:
	CW2CWEX( const CW2CWEX& ) throw();
	CW2CWEX& operator=( const CW2CWEX& ) throw();
};
typedef CW2CWEX<> CW2CW;

template< int t_nBufferLength = 128 >
class CA2WEX
{
public:
	CA2WEX( LPCSTR psz ) throw(...) :
		m_psz( m_szBuffer )
	{
		Init( psz, _AtlGetConversionACP() );
	}
	CA2WEX( LPCSTR psz, UINT nCodePage ) throw(...) :
		m_psz( m_szBuffer )
	{
		Init( psz, nCodePage );
	}
	~CA2WEX() throw()
	{
		if( m_psz != m_szBuffer )
		{
			delete[] m_psz;
		}
	}

	operator LPWSTR() const throw()
	{
		return( m_psz );
	}

private:
	void Init( LPCSTR psz, UINT nCodePage ) throw(...)
	{
		if (psz == NULL)
		{
			m_psz = NULL;
			return;
		}
		int nLengthA = lstrlenA( psz )+1;
		int nLengthW = nLengthA;

		if( nLengthW > t_nBufferLength )
		{
			m_psz = new WCHAR[nLengthW];
			if (m_psz == NULL)
			{
				THROWCOM(E_OUTOFMEMORY);
			}
		}

		::MultiByteToWideChar( nCodePage, 0, psz, nLengthA, m_psz, nLengthW );
	}

public:
	LPWSTR m_psz;
	wchar_t m_szBuffer[t_nBufferLength];

private:
	CA2WEX( const CA2WEX& ) throw();
	CA2WEX& operator=( const CA2WEX& ) throw();
};
typedef CA2WEX<> CA2W;

template< int t_nBufferLength = 128 >
class CW2AEX
{
public:
	CW2AEX( LPCWSTR psz ) throw(...) :
		m_psz( m_szBuffer )
	{
		Init( psz, _AtlGetConversionACP() );
	}
	CW2AEX( LPCWSTR psz, UINT nCodePage ) throw(...) :
		m_psz( m_szBuffer )
	{
		Init( psz, nCodePage );
	}
	~CW2AEX() throw()
	{
		if( m_psz != m_szBuffer )
		{
			delete[] m_psz;
		}
	}

	operator LPSTR() const throw()
	{
		return( m_psz );
	}

private:
	void Init( LPCWSTR psz, UINT nCodePage ) throw(...)
	{
		if (psz == NULL)
		{
			m_psz = NULL;
			return;
		}
		int nLengthW = lstrlenW( psz )+1;
		int nLengthA = nLengthW*2;

		if( nLengthA > t_nBufferLength )
		{
			m_psz = new char[nLengthA];
			if (m_psz == NULL)
			{
				THROWCOM(E_OUTOFMEMORY);
			}
		}

		::WideCharToMultiByte( nCodePage, 0, psz, nLengthW, m_psz, nLengthA, NULL, NULL );
	}

public:
	LPSTR m_psz;
	char m_szBuffer[t_nBufferLength];

private:
	CW2AEX( const CW2AEX& ) throw();
	CW2AEX& operator=( const CW2AEX& ) throw();
};
typedef CW2AEX<> CW2A;

#ifdef _UNICODE

	#define W2T CW2W
	#define CW2TEX CW2WEX
	#define W2CT CW2CW
	#define CW2CTEX CW2CWEX
	#define T2W CW2W
	#define CT2WEX CW2WEX
	#define T2CW CW2CW
	#define CT2CWEX CW2CWEX

	#define A2T CA2W
	#define CA2TEX CA2WEX
	#define A2CT CA2W
	#define CA2CTEX CA2WEX
	#define T2A CW2A
	#define CT2AEX CW2AEX
	#define T2CA CW2A
	#define CT2CAEX CW2AEX

#else  // !_UNICODE

	#define CW2T CW2A
	#define CW2TEX CW2AEX
	#define CW2CT CW2A
	#define CW2CTEX CW2AEX
	#define CT2W CA2W
	#define CT2WEX CA2WEX
	#define CT2CW CA2W
	#define CT2CWEX CA2WEX

	#define CA2T CA2A
	#define CA2TEX CA2AEX
	#define CA2CT CA2CA
	#define CA2CTEX CA2CAEX
	#define CT2A CA2A
	#define CT2AEX CA2AEX
	#define CT2CA CA2CA
	#define CT2CAEX CA2CAEX

#endif  // !_UNICODE

#define OLE2T CW2T
#define COLE2TEX CW2TEX
#define OLE2CT CW2CT
#define COLE2CTEX CW2CTEX
#define T2OLE CT2W
#define CT2OLEEX CT2WEX
#define T2COLE CT2CW
#define CT2COLEEX CT2CWEX

};  // namespace ATL


#define USES_CONVERSION

#define A2W CA2W
#define W2A CW2A
#define A2CW(x) CW2CW(CA2W(x))
#define W2CA(x) CA2CA(CW2A(x))


#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline int ocslen(LPCOLESTR x) throw() { return lstrlenW(x); }
	inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) throw() { return lstrcpyW(dest, src); }
	inline OLECHAR* ocscat(LPOLESTR dest, LPCOLESTR src) throw() { return lstrcatW(dest, src); }
	inline LPCOLESTR T2COLE(LPCTSTR lp) { return lp; }
	inline LPCTSTR OLE2CT(LPCOLESTR lp) { return lp; }
	inline LPOLESTR T2OLE(LPTSTR lp) { return lp; }
	inline LPTSTR OLE2T(LPOLESTR lp) { return lp; }
	inline LPOLESTR CharNextO(LPCOLESTR lp) throw() {return CharNextW(lp);}
#else
	inline int ocslen(LPCOLESTR x) throw() { return lstrlenW(x); }
	//lstrcpyW doesn't work on Win95, so we do this
	inline OLECHAR* ocscpy(LPOLESTR dest, LPCOLESTR src) throw()
	{return (LPOLESTR) memcpy(dest, src, (lstrlenW(src)+1)*sizeof(WCHAR));}
	inline OLECHAR* ocscat(LPOLESTR dest, LPCOLESTR src) throw() { return ocscpy(dest+ocslen(dest), src); }
	//CharNextW doesn't work on Win95 so we use this
	#define T2COLE(lpa) A2CW(lpa)
	#define T2OLE(lpa) A2W(lpa)
	#define OLE2CT(lpo) W2CA(lpo)
	#define OLE2T(lpo) W2A(lpo)
	inline LPOLESTR CharNextO(LPCOLESTR lp) throw() {return (LPOLESTR) ((*lp) ? (lp+1) : lp);}
#endif

	inline LPOLESTR W2OLE(LPWSTR lp) { return lp; }
	inline LPWSTR OLE2W(LPOLESTR lp) { return lp; }
	#define A2OLE A2W
	#define OLE2A W2A
	inline LPCOLESTR W2COLE(LPCWSTR lp) { return lp; }
	inline LPCWSTR OLE2CW(LPCOLESTR lp) { return lp; }
	#define A2COLE A2CW
	#define OLE2CA W2CA

inline BSTR A2WBSTR(LPCSTR lp, int nLen = -1)
{
	if (lp == NULL || nLen == 0)
		return NULL;
    UINT _acp = ATL::_AtlGetConversionACP();
    BSTR str = NULL;
	int nConvertedLen = MultiByteToWideChar(_acp, 0, lp,
		nLen, NULL, NULL);
	int nAllocLen = nConvertedLen;
	if (nLen == -1)
		nAllocLen -= 1;  // Don't allocate terminating '\0'
	str = ::SysAllocStringLen(NULL, nAllocLen);
	if (str != NULL)
	{
		int nResult;
		nResult = MultiByteToWideChar(_acp, 0, lp, nLen, str, nConvertedLen);
		ATLASSERT(nResult == nConvertedLen);
	}
	return str;
}

inline BSTR OLE2BSTR(LPCOLESTR lp) {return ::SysAllocString(lp);}
#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline BSTR T2BSTR(LPCTSTR lp) {return ::SysAllocString(lp);}
	inline BSTR A2BSTR(LPCSTR lp) {return A2WBSTR(lp);}
	inline BSTR W2BSTR(LPCWSTR lp) {return ::SysAllocString(lp);}
#else
	inline BSTR T2BSTR(LPCTSTR lp) {return A2WBSTR(lp);}
	inline BSTR A2BSTR(LPCSTR lp) {return A2WBSTR(lp);}
	inline BSTR W2BSTR(LPCWSTR lp) {return ::SysAllocString(lp);}
#endif


#ifdef _WINGDI_
/////////////////////////////////////////////////////////////////////////////
// Global UNICODE<>ANSI translation helpers

inline LPWSTR WINAPI AtlA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars, UINT acp) throw()
{
	ATLASSERT(lpa != NULL);
	ATLASSERT(lpw != NULL);
	if (lpw == NULL)
		return NULL;
	// verify that no illegal character present
	// since lpw was allocated based on the size of lpa
	// don't worry about the number of chars
	lpw[0] = '\0';
	MultiByteToWideChar(acp, 0, lpa, -1, lpw, nChars);
	return lpw;
}

inline LPDEVMODEW AtlDevModeA2W(LPDEVMODEW lpDevModeW, const DEVMODEA* lpDevModeA)
{
    UINT _acp = ATL::_AtlGetConversionACP();
	if (lpDevModeA == NULL)
		return NULL;
	ATLASSERT(lpDevModeW != NULL);
	AtlA2WHelper(lpDevModeW->dmDeviceName, (LPCSTR)lpDevModeA->dmDeviceName, 32*sizeof(WCHAR), _acp);
	memcpy(&lpDevModeW->dmSpecVersion, &lpDevModeA->dmSpecVersion,
		offsetof(DEVMODEW, dmFormName) - offsetof(DEVMODEW, dmSpecVersion));
	AtlA2WHelper(lpDevModeW->dmFormName, (LPCSTR)lpDevModeA->dmFormName, 32*sizeof(WCHAR), _acp);
	memcpy(&lpDevModeW->dmLogPixels, &lpDevModeA->dmLogPixels,
		sizeof(DEVMODEW) - offsetof(DEVMODEW, dmLogPixels));
	if (lpDevModeA->dmDriverExtra != 0)
		memcpy(lpDevModeW+1, lpDevModeA+1, lpDevModeA->dmDriverExtra);
	lpDevModeW->dmSize = sizeof(DEVMODEW);
	return lpDevModeW;
}

inline LPTEXTMETRICW AtlTextMetricA2W(LPTEXTMETRICW lptmW, LPTEXTMETRICA lptmA)
{
    UINT _acp = ATL::_AtlGetConversionACP();
	if (lptmA == NULL)
		return NULL;
	ATLASSERT(lptmW != NULL);
	memcpy(lptmW, lptmA, sizeof(LONG) * 11);
	memcpy(&lptmW->tmItalic, &lptmA->tmItalic, sizeof(BYTE) * 5);
	MultiByteToWideChar(_acp, 0, (LPCSTR)&lptmA->tmFirstChar, 1, &lptmW->tmFirstChar, 1);
	MultiByteToWideChar(_acp, 0, (LPCSTR)&lptmA->tmLastChar, 1, &lptmW->tmLastChar, 1);
	MultiByteToWideChar(_acp, 0, (LPCSTR)&lptmA->tmDefaultChar, 1, &lptmW->tmDefaultChar, 1);
	MultiByteToWideChar(_acp, 0, (LPCSTR)&lptmA->tmBreakChar, 1, &lptmW->tmBreakChar, 1);
	return lptmW;
}

inline LPTEXTMETRICA AtlTextMetricW2A(LPTEXTMETRICA lptmA, LPTEXTMETRICW lptmW)
{
    UINT _acp = ATL::_AtlGetConversionACP();
	if (lptmW == NULL)
		return NULL;
	ATLASSERT(lptmA != NULL);
	memcpy(lptmA, lptmW, sizeof(LONG) * 11);
	memcpy(&lptmA->tmItalic, &lptmW->tmItalic, sizeof(BYTE) * 5);
	WideCharToMultiByte(_acp, 0, &lptmW->tmFirstChar, 1, (LPSTR)&lptmA->tmFirstChar, 1, NULL, NULL);
	WideCharToMultiByte(_acp, 0, &lptmW->tmLastChar, 1, (LPSTR)&lptmA->tmLastChar, 1, NULL, NULL);
	WideCharToMultiByte(_acp, 0, &lptmW->tmDefaultChar, 1, (LPSTR)&lptmA->tmDefaultChar, 1, NULL, NULL);
	WideCharToMultiByte(_acp, 0, &lptmW->tmBreakChar, 1, (LPSTR)&lptmA->tmBreakChar, 1, NULL, NULL);
	return lptmA;
}

#ifndef ATLDEVMODEA2W
#define ATLDEVMODEA2W AtlDevModeA2W
#define ATLDEVMODEW2A AtlDevModeW2A
#define ATLTEXTMETRICA2W AtlTextMetricA2W
#define ATLTEXTMETRICW2A AtlTextMetricW2A
#endif

#define DEVMODEW2A(lpw)\
	((lpw == NULL) ? NULL : ATLDEVMODEW2A((LPDEVMODEA)alloca(sizeof(DEVMODEA)+lpw->dmDriverExtra), lpw))
#define DEVMODEA2W(lpa)\
	((lpa == NULL) ? NULL : ATLDEVMODEA2W((LPDEVMODEW)alloca(sizeof(DEVMODEW)+lpa->dmDriverExtra), lpa))
#define TEXTMETRICW2A(lptmw)\
	((lptmw == NULL) ? NULL : ATLTEXTMETRICW2A((LPTEXTMETRICA)alloca(sizeof(TEXTMETRICA)), lptmw))
#define TEXTMETRICA2W(lptma)\
	((lptma == NULL) ? NULL : ATLTEXTMETRICA2W((LPTEXTMETRICW)alloca(sizeof(TEXTMETRICW)), lptma))

#define DEVMODEOLE DEVMODEW
#define LPDEVMODEOLE LPDEVMODEW
#define TEXTMETRICOLE TEXTMETRICW
#define LPTEXTMETRICOLE LPTEXTMETRICW

#if defined(_UNICODE)
// in these cases the default (TCHAR) is the same as OLECHAR
	inline LPDEVMODEW DEVMODEOLE2T(LPDEVMODEOLE lp) { return lp; }
	inline LPDEVMODEOLE DEVMODET2OLE(LPDEVMODEW lp) { return lp; }
	inline LPTEXTMETRICW TEXTMETRICOLE2T(LPTEXTMETRICOLE lp) { return lp; }
	inline LPTEXTMETRICOLE TEXTMETRICT2OLE(LPTEXTMETRICW lp) { return lp; }
#else
	#define DEVMODEOLE2T(lpo) DEVMODEW2A(lpo)
	#define DEVMODET2OLE(lpa) DEVMODEA2W(lpa)
	#define TEXTMETRICOLE2T(lptmw) TEXTMETRICW2A(lptmw)
	#define TEXTMETRICT2OLE(lptma) TEXTMETRICA2W(lptma)
#endif

#endif //_WINGDI_


#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning (pop)
#endif //!_ATL_NO_PRAGMA_WARNINGS

#endif // __ATLCONV_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\atl\atlbase.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLBASE_H__
#define __ATLBASE_H__

#ifndef __cplusplus
        #error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning(disable: 4201) // nameless unions are part of C++
#pragma warning(disable: 4127) // constant expression
#pragma warning(disable: 4505) // unreferenced local function has been removed
#pragma warning(disable: 4512) // can't generate assignment operator (so what?)
#pragma warning(disable: 4514) // unreferenced inlines are common
#pragma warning(disable: 4103) // pragma pack
#pragma warning(disable: 4702) // unreachable code
#pragma warning(disable: 4237) // bool
#pragma warning(disable: 4710) // function couldn't be inlined
#pragma warning(disable: 4355) // 'this' : used in base member initializer list
#pragma warning(disable: 4097) // typedef name used as synonym for class-name
#pragma warning(disable: 4786) // identifier was truncated in the debug information
#pragma warning(disable: 4268) // const static/global data initialized to zeros
#pragma warning(disable: 4291) // allow placement new
#endif //!_ATL_NO_PRAGMA_WARNINGS

#include <atldef.h>

#include <windows.h>
#include <winnls.h>
#include <ole2.h>

#include <comcat.h>
#include <stddef.h>

#ifdef new
#pragma push_macro("new")
#define _ATL_REDEF_NEW
#undef new
#endif

#include <tchar.h>
#include <malloc.h>

#ifndef _ATL_NO_DEBUG_CRT
// Warning: if you define the above symbol, you will have
// to provide your own definition of the ATLASSERT(x) macro
// in order to compile ATL
        #include <crtdbg.h>
#endif

#include <olectl.h>
#include <winreg.h>
#include <atliface.h>

#ifdef _DEBUG
#include <stdio.h>
#include <stdarg.h>
#endif

#include <atlconv.h>

#include <shlwapi.h>

#pragma pack(push, _ATL_PACKING)

#if defined(_ATL_DLL)
        #pragma comment(lib, "atl.lib")
#endif

extern "C" const __declspec(selectany) GUID LIBID_ATLLib = {0x44EC0535,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
extern "C" const __declspec(selectany) CLSID CLSID_Registrar = {0x44EC053A,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
extern "C" const __declspec(selectany) IID IID_IRegistrar = {0x44EC053B,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
extern "C" const __declspec(selectany) IID IID_IAxWinHostWindow = {0xb6ea2050,0x48a,0x11d1,{0x82,0xb9,0x0,0xc0,0x4f,0xb9,0x94,0x2e}};
extern "C" const __declspec(selectany) IID IID_IAxWinAmbientDispatch = {0xb6ea2051,0x48a,0x11d1,{0x82,0xb9,0x0,0xc0,0x4f,0xb9,0x94,0x2e}};
extern "C" const __declspec(selectany) IID IID_IInternalConnection = {0x72AD0770,0x6A9F,0x11d1,{0xBC,0xEC,0x00,0x60,0x08,0x8F,0x44,0x4E}};
extern "C" const __declspec(selectany) IID IID_IDocHostUIHandlerDispatch = {0x425B5AF0,0x65F1,0x11d1,{0x96,0x11,0x00,0x00,0xF8,0x1E,0x0D,0x0D}};

#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif

struct _ATL_CATMAP_ENTRY
{
   int iType;
   const CATID* pcatid;
};

#define _ATL_CATMAP_ENTRY_END 0
#define _ATL_CATMAP_ENTRY_IMPLEMENTED 1
#define _ATL_CATMAP_ENTRY_REQUIRED 2

typedef HRESULT (WINAPI _ATL_CREATORFUNC)(void* pv, REFIID riid, LPVOID* ppv);
typedef HRESULT (WINAPI _ATL_CREATORARGFUNC)(void* pv, REFIID riid, LPVOID* ppv, DWORD_PTR dw);
typedef HRESULT (WINAPI _ATL_MODULEFUNC)(DWORD_PTR dw);
typedef LPCTSTR (WINAPI _ATL_DESCRIPTIONFUNC)();
typedef const struct _ATL_CATMAP_ENTRY* (_ATL_CATMAPFUNC)();
typedef void (__stdcall _ATL_TERMFUNC)(DWORD_PTR dw);

struct _ATL_TERMFUNC_ELEM
{
        _ATL_TERMFUNC* pFunc;
        DWORD_PTR dw;
        _ATL_TERMFUNC_ELEM* pNext;
};

struct _ATL_OBJMAP_ENTRY
{
        const CLSID* pclsid;
        HRESULT (WINAPI *pfnUpdateRegistry)(BOOL bRegister);
        _ATL_CREATORFUNC* pfnGetClassObject;
        _ATL_CREATORFUNC* pfnCreateInstance;
        IUnknown* pCF;
        DWORD dwRegister;
        _ATL_DESCRIPTIONFUNC* pfnGetObjectDescription;
        _ATL_CATMAPFUNC* pfnGetCategoryMap;
        HRESULT WINAPI RevokeClassObject()
        {
                return CoRevokeClassObject(dwRegister);
        }
        HRESULT WINAPI RegisterClassObject(DWORD dwClsContext, DWORD dwFlags)
        {
                IUnknown* p = NULL;
                if (pfnGetClassObject == NULL)
                        return S_OK;
                HRESULT hRes = pfnGetClassObject(pfnCreateInstance, IID_IUnknown, (LPVOID*) &p);
                if (SUCCEEDED(hRes))
                        hRes = CoRegisterClassObject(*pclsid, p, dwClsContext, dwFlags, &dwRegister);
                if (p != NULL)
                        p->Release();
                return hRes;
        }
// Added in ATL 3.0
        void (WINAPI *pfnObjectMain)(bool bStarting);
};

struct _ATL_REGMAP_ENTRY
{
        LPCOLESTR     szKey;
        LPCOLESTR     szData;
};

struct _AtlCreateWndData
{
        void* m_pThis;
        DWORD m_dwThreadID;
        _AtlCreateWndData* m_pNext;
};

struct _ATL_MODULE_21
{
// Attributes
public:
	UINT cbSize;
	HINSTANCE m_hInst;
	HINSTANCE m_hInstResource;
	HINSTANCE m_hInstTypeLib;
	_ATL_OBJMAP_ENTRY* m_pObjMap;
	LONG m_nLockCnt;
	HANDLE m_hHeap;
	union
	{
		CRITICAL_SECTION m_csTypeInfoHolder;
		CRITICAL_SECTION m_csStaticDataInit;
	};
	CRITICAL_SECTION m_csWindowCreate;
	CRITICAL_SECTION m_csObjMap;
};

struct _ATL_MODULE_30
{
// Attributes
public:
	UINT cbSize;
	HINSTANCE m_hInst;
	HINSTANCE m_hInstResource;
	HINSTANCE m_hInstTypeLib;
	_ATL_OBJMAP_ENTRY* m_pObjMap;
	LONG m_nLockCnt;
	HANDLE m_hHeap;
	union
	{
		CRITICAL_SECTION m_csTypeInfoHolder;
		CRITICAL_SECTION m_csStaticDataInit;
	};
	CRITICAL_SECTION m_csWindowCreate;
	CRITICAL_SECTION m_csObjMap;
// Original Size = 100
// Stuff added in ATL 3.0
	DWORD dwAtlBuildVer;
	_AtlCreateWndData* m_pCreateWndList;
	bool m_bDestroyHeap;
	GUID* pguidVer;
	DWORD m_dwHeaps;    // Number of heaps we have (-1)
	HANDLE* m_phHeaps;
	int m_nHeap;        // Which heap to choose from
	_ATL_TERMFUNC_ELEM* m_pTermFuncs;
};

struct _ATL_MODULE
{
// Attributes
public:
        UINT cbSize;
        HINSTANCE m_hInst;
        HINSTANCE m_hInstResource;
        HINSTANCE m_hInstTypeLib;
        _ATL_OBJMAP_ENTRY* m_pObjMap;
        LONG m_nLockCnt;
        HANDLE m_hHeap;
        union
        {
                CRITICAL_SECTION m_csTypeInfoHolder;
                CRITICAL_SECTION m_csStaticDataInit;
        };
        CRITICAL_SECTION m_csWindowCreate;
        CRITICAL_SECTION m_csObjMap;
// Original Size = 100
// Stuff added in ATL 3.0
        DWORD dwAtlBuildVer;
        _AtlCreateWndData* m_pCreateWndList;
        bool m_bDestroyHeap;
        GUID* pguidVer;
        DWORD m_dwHeaps;    // Number of heaps we have (-1)
        HANDLE* m_phHeaps;
        int m_nHeap;        // Which heap to choose from
        _ATL_TERMFUNC_ELEM* m_pTermFuncs;
// Stuff added in ATL 6.1
	LONG m_nNextWindowID;
};

const int _nAtlModuleVer21Size = sizeof( _ATL_MODULE_21 );
const int _nAtlModuleVer30Size = sizeof( _ATL_MODULE_30 );


//This define makes debugging asserts easier.
#define _ATL_SIMPLEMAPENTRY ((_ATL_CREATORARGFUNC*)1)

struct _ATL_INTMAP_ENTRY
{
        const IID* piid;       // the interface id (IID)
		DWORD_PTR dw;
        _ATL_CREATORARGFUNC* pFunc; //NULL:end, 1:offset, n:ptr
};

/////////////////////////////////////////////////////////////////////////////
// Thunks for __stdcall member functions


#if defined(_M_IX86)
#pragma pack(push,1)
struct _stdcallthunk
{
        DWORD   m_mov;          // mov dword ptr [esp+0x4], pThis (esp+0x4 is hWnd)
        DWORD   m_this;         //
        BYTE    m_jmp;          // jmp WndProc
        DWORD   m_relproc;      // relative jmp
        void Init(DWORD_PTR proc, void* pThis)
        {
                m_mov = 0x042444C7;  //C7 44 24 0C
                m_this = PtrToUlong(pThis);
                m_jmp = 0xe9;
                m_relproc = DWORD((INT_PTR)proc - ((INT_PTR)this+sizeof(_stdcallthunk)));
                // write block from data cache and
                //  flush from instruction cache
                FlushInstructionCache(GetCurrentProcess(), this, sizeof(_stdcallthunk));
        }
};
#pragma pack(pop)
#elif defined (_M_AMD64)
#pragma pack(push,2)
struct _stdcallthunk
{
    USHORT  RcxMov;         // mov rcx, pThis
    ULONG64 RcxImm;         // 
    USHORT  RaxMov;         // mov rax, target
    ULONG64 RaxImm;         //
    USHORT  RaxJmp;         // jmp target
    void Init(DWORD_PTR proc, void *pThis)
    {
        RcxMov = 0xb948;          // mov rcx, pThis
        RcxImm = (ULONG64)pThis;  // 
        RaxMov = 0xb848;          // mov rax, target
        RaxImm = (ULONG64)proc;   //
        RaxJmp = 0xe0ff;          // jmp rax
        FlushInstructionCache(GetCurrentProcess(), this, sizeof(_stdcallthunk));
    }
};
#pragma pack(pop)
#elif defined(_M_IA64)
#pragma pack(push,8)
extern "C" LRESULT CALLBACK _WndProcThunkProc( HWND, UINT, WPARAM, LPARAM );
struct _FuncDesc
{
        void* pfn;
        void* gp;
};
struct _stdcallthunk
{
        _FuncDesc m_funcdesc;
        void* m_pFunc;
        void* m_pThis;
        void Init(DWORD_PTR proc, void* pThis)
        {
                const _FuncDesc* pThunkProc;

                pThunkProc = reinterpret_cast< const _FuncDesc* >( _WndProcThunkProc );
                m_funcdesc.pfn = pThunkProc->pfn;
                m_funcdesc.gp = &m_pFunc;
                m_pFunc = reinterpret_cast< void* >( proc );
                m_pThis = pThis;
                ::FlushInstructionCache( GetCurrentProcess(), this, sizeof( _stdcallthunk ) );
        }
};
#pragma pack(pop)
#else
#error Only AMD64, IA64, and X86 supported
#endif

class CDynamicStdCallThunk
{
public:
        _stdcallthunk *pThunk;

        CDynamicStdCallThunk()
        {
                pThunk = NULL;
        }

        ~CDynamicStdCallThunk()
        {
                if (pThunk)
                        HeapFree(GetProcessHeap(), 0, pThunk);
        }

        void Init(DWORD_PTR proc, void *pThis)
        {
                ATLASSERT(!pThunk);
                pThunk = static_cast<_stdcallthunk *>(HeapAlloc(GetProcessHeap(), 
                        HEAP_GENERATE_EXCEPTIONS, sizeof(_stdcallthunk)));
                ATLASSERT(pThunk);
                pThunk->Init(proc, pThis);
        }
};
typedef CDynamicStdCallThunk CStdCallThunk;

/////////////////////////////////////////////////////////////////////////////
// QI Support

ATLAPI AtlInternalQueryInterface(void* pThis,
        const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject);

/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

ATLAPI_(IUnknown*) AtlComPtrAssign(IUnknown** pp, IUnknown* lp);
ATLAPI_(IUnknown*) AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid);

/////////////////////////////////////////////////////////////////////////////
// Inproc Marshaling helpers

ATLAPI AtlFreeMarshalStream(IStream* pStream);
ATLAPI AtlMarshalPtrInProc(IUnknown* pUnk, const IID& iid, IStream** ppStream);
ATLAPI AtlUnmarshalPtr(IStream* pStream, const IID& iid, IUnknown** ppUnk);

ATLAPI_(BOOL) AtlWaitWithMessageLoop(HANDLE hEvent);

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

ATLAPI AtlAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw);
ATLAPI AtlUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw);

/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

ATLAPI AtlSetErrorInfo(const CLSID& clsid, LPCOLESTR lpszDesc,
        DWORD dwHelpID, LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes,
        HINSTANCE hInst);

/////////////////////////////////////////////////////////////////////////////
// Module

ATLAPI AtlModuleRegisterClassObjects(_ATL_MODULE* pM, DWORD dwClsContext, DWORD dwFlags);
ATLAPI AtlModuleRevokeClassObjects(_ATL_MODULE* pM);
ATLAPI AtlModuleGetClassObject(_ATL_MODULE* pM, REFCLSID rclsid, REFIID riid, LPVOID* ppv);
ATLAPI AtlModuleRegisterServer(_ATL_MODULE* pM, BOOL bRegTypeLib, const CLSID* pCLSID = NULL);
ATLAPI AtlModuleUnregisterServer(_ATL_MODULE* pM, const CLSID* pCLSID = NULL);
ATLAPI AtlModuleUnregisterServerEx(_ATL_MODULE* pM, BOOL bUnRegTypeLib, const CLSID* pCLSID = NULL);
ATLAPI AtlModuleUpdateRegistryFromResourceD(_ATL_MODULE*pM, LPCOLESTR lpszRes,
        BOOL bRegister, struct _ATL_REGMAP_ENTRY* pMapEntries, IRegistrar* pReg = NULL);
ATLAPI AtlModuleRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex);
ATLAPI AtlModuleUnRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex);
ATLAPI AtlModuleLoadTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex, BSTR* pbstrPath, ITypeLib** ppTypeLib);

ATLAPI AtlModuleInit(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* p, HINSTANCE h);
ATLAPI AtlModuleTerm(_ATL_MODULE* pM);
ATLAPI_(DWORD) AtlGetVersion(void* pReserved);
ATLAPI_(void) AtlModuleAddCreateWndData(_ATL_MODULE* pM, _AtlCreateWndData* pData, void* pObject);
ATLAPI_(void*) AtlModuleExtractCreateWndData(_ATL_MODULE* pM);
ATLAPI AtlModuleAddTermFunc(_ATL_MODULE* pM, _ATL_TERMFUNC* pFunc, DWORD_PTR dw);

#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif

namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// Error to HRESULT helpers

inline HRESULT AtlHresultFromLastError()
{
        DWORD dwErr = ::GetLastError();
        return HRESULT_FROM_WIN32(dwErr);
}

inline HRESULT AtlHresultFromWin32(DWORD nError)
{
        return( HRESULT_FROM_WIN32( nError ) );
}

enum atlTraceFlags
{
        // Application defined categories
        atlTraceUser        = 0x00000001,
        atlTraceUser2       = 0x00000002,
        atlTraceUser3       = 0x00000004,
        atlTraceUser4       = 0x00000008,
        // ATL defined categories
        atlTraceGeneral     = 0x00000020,
        atlTraceCOM         = 0x00000040,
        atlTraceQI      = 0x00000080,
        atlTraceRegistrar   = 0x00000100,
        atlTraceRefcount    = 0x00000200,
        atlTraceWindowing   = 0x00000400,
        atlTraceControls    = 0x00000800,
        atlTraceHosting     = 0x00001000,
        atlTraceDBClient    = 0x00002000,
        atlTraceDBProvider  = 0x00004000,
        atlTraceSnapin      = 0x00008000,
        atlTraceNotImpl     = 0x00010000,
};

#ifndef ATL_TRACE_CATEGORY
#define ATL_TRACE_CATEGORY 0xFFFFFFFF
#endif

#ifdef _DEBUG

#ifndef ATL_TRACE_LEVEL
#define ATL_TRACE_LEVEL 0
#endif

inline void _cdecl AtlTrace(LPCSTR lpszFormat, ...)
{
        va_list args;
        va_start(args, lpszFormat);

        int nBuf;
        char szBuffer[512];

        nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
        ATLASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

        OutputDebugStringA(szBuffer);
        va_end(args);
}
inline void _cdecl AtlTrace2(DWORD category, UINT level, LPCSTR lpszFormat, ...)
{
        if (category & ATL_TRACE_CATEGORY && level <= ATL_TRACE_LEVEL)
        {
                va_list args;
                va_start(args, lpszFormat);

                int nBuf;
                char szBuffer[512];

                nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
                ATLASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

                OutputDebugStringA("ATL: ");
                OutputDebugStringA(szBuffer);
                va_end(args);
        }
}
#ifndef OLE2ANSI
inline void _cdecl AtlTrace(LPCWSTR lpszFormat, ...)
{
        va_list args;
        va_start(args, lpszFormat);

        int nBuf;
        WCHAR szBuffer[512];

        nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer) / sizeof(WCHAR), lpszFormat, args);
        ATLASSERT(nBuf < sizeof(szBuffer));//Output truncated as it was > sizeof(szBuffer)

        OutputDebugStringW(szBuffer);
        va_end(args);
}
inline void _cdecl AtlTrace2(DWORD category, UINT level, LPCWSTR lpszFormat, ...)
{
        if (category & ATL_TRACE_CATEGORY && level <= ATL_TRACE_LEVEL)
        {
                va_list args;
                va_start(args, lpszFormat);

                int nBuf;
                WCHAR szBuffer[512];

                nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer) / sizeof(WCHAR), lpszFormat, args);
                ATLASSERT(nBuf < sizeof(szBuffer));//Output truncated as it was > sizeof(szBuffer)

                OutputDebugStringW(L"ATL: ");
                OutputDebugStringW(szBuffer);
                va_end(args);
        }
}
#endif //!OLE2ANSI


#ifndef ATLTRACE
#define ATLTRACE            AtlTrace
#define ATLTRACE2           AtlTrace2
#endif
#define ATLTRACENOTIMPL(funcname)   ATLTRACE2(atlTraceNotImpl, 2, _T("ATL: %s not implemented.\n"), funcname); return E_NOTIMPL
#else // !DEBUG
inline void _cdecl AtlTrace(LPCSTR , ...){}
inline void _cdecl AtlTrace2(DWORD, UINT, LPCSTR , ...){}
#ifndef OLE2ANSI
inline void _cdecl AtlTrace(LPCWSTR , ...){}
inline void _cdecl AtlTrace2(DWORD, UINT, LPCWSTR , ...){}
#endif //OLE2ANSI
#ifndef ATLTRACE
#define ATLTRACE            1 ? (void)0 : AtlTrace
#define ATLTRACE2           1 ? (void)0 : AtlTrace2
#endif //ATLTRACE
#define ATLTRACENOTIMPL(funcname)   return E_NOTIMPL
#endif //_DEBUG

// Validation macro for OUT pointer
// Used in QI and CreateInstance
#define _ATL_VALIDATE_OUT_POINTER(x)        ATLASSERT(x != NULL);        \
        if (x == NULL)        \
                return E_POINTER;        \
        *x = NULL

/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#pragma comment(lib, "kernel32.lib")
#pragma comment(lib, "user32.lib")
#ifndef _WIN64
#pragma comment(lib, "olepro32.lib")
#endif
#pragma comment(lib, "advapi32.lib")
#pragma comment(lib, "ole32.lib")
#pragma comment(lib, "oleaut32.lib")
#pragma comment(lib, "uuid.lib")



template <class Ty> class stl_smart_ptr_allocator {
public:
                typedef size_t size_type;
                typedef ptrdiff_t difference_type;
                typedef Ty *pointer;
                typedef const Ty *const_pointer;
                typedef Ty & reference;
                typedef const Ty & const_reference;
                typedef Ty value_type;
                pointer address(reference _X) const
                                {return ((_X.address)()); }
                const_pointer address(const_reference _X) const
                                {return ((_X.const_address)()); }
                pointer allocate(ptrdiff_t _N, const void *)
                {if (_N < 0)
                                        _N = 0;
                        return ((pointer)operator new(
                                (size_type)_N * sizeof (Ty))); }
                char *_Charalloc(ptrdiff_t _N)
                {if (_N < 0)
                                        _N = 0;
                        return ((char *)operator new(
                                (size_type)_N * sizeof (char))); }
                void deallocate(void *_P, size_type)
                                {operator delete(_P); }
                void construct(pointer _P, const Ty& _V)
                        {new ((void *)_P) Ty(_V); }
                // note: there is an stl bug regarding allocators and the list container
                // (vc6 list line 222) the template takes the address of the object
                // which breaks for smart pointers because the & is overloaded.
                // the correct thing is for construct to be defined as a reference
                // and list not use & so that the allocator can use a private method
                // of obtaining the object address
                // i've gone ahead and defined the correct method here on the remote
                // chance that this will get fixed in the future
                void construct(reference R, const Ty& _V)
                        {new ((void *)R.address()) Ty(_V); }
                void destroy(pointer _P)
                                {_Destroy(_P); }
                size_type max_size() const
                                {size_type _N = (size_type)(-1) / sizeof (Ty);
                                return (0 < _N ? _N : 1); }
        inline void _Destroy(Ty *_P)
                        {(_P)->~Ty();}

        inline void _Destroy(char *_P)
                        {}
        inline void _Destroy(wchar_t *_P)
                        {}
};

static HRESULT AtlSetChildSite(IUnknown* punkChild, IUnknown* punkParent)
{
        if (punkChild == NULL)
                return E_POINTER;

        HRESULT hr;
        IObjectWithSite* pChildSite = NULL;
        hr = punkChild->QueryInterface(IID_IObjectWithSite, (void**)&pChildSite);
        if (SUCCEEDED(hr) && pChildSite != NULL)
        {
                hr = pChildSite->SetSite(punkParent);
                pChildSite->Release();
        }
        return hr;
}

template <class T>
class _NoAddRefReleaseOnCComPtr : public T
{
        private:
                STDMETHOD_(ULONG, AddRef)()=0;
                STDMETHOD_(ULONG, Release)()=0;
};

template <class T>
class CComPtr
{
public:
        typedef T _PtrClass;
        CComPtr()
        {
                p=NULL;
        }
        CComPtr(T* lp)
        {
                if ((p = lp) != NULL)
                        p->AddRef();
        }
        CComPtr(const CComPtr<T>& lp)
        {
                if ((p = lp.p) != NULL)
                        p->AddRef();
        }
        CComPtr(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
            : p(NULL)
        {
                ATLASSERT(p == NULL);
                HRESULT hr = ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
                if (FAILED(hr)) ATLASSERT(p == NULL);
        }
        CComPtr(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
            : p(NULL)
        {
                CLSID clsid;
                HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
                ATLASSERT(p == NULL);
                if (SUCCEEDED(hr))
                        hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
                if (FAILED(hr)) ATLASSERT(p == NULL);
        }
        ~CComPtr()
        {
                if (p)
                        p->Release();
        }
        void Release()
        {
                IUnknown* pTemp = p;
                if (pTemp)
                {
                        p = NULL;
                        pTemp->Release();
                }
        }
        operator T*() const
        {
                return (T*)p;
        }
        T& operator*() const
        {
                ATLASSERT(p!=NULL);
                return *p;
        }
        //The assert on operator& usually indicates a bug.  If this is really
        //what is needed, however, take the address of the p member explicitly.
        T** operator&()
        {
                ATLASSERT(p==NULL);
                return &p;
        }
        _NoAddRefReleaseOnCComPtr<T>* operator->() const
        {
                ATLASSERT(p!=NULL);
                return (_NoAddRefReleaseOnCComPtr<T>*)p;
        }
        T* operator=(T* lp)
        {
                return (T*)AtlComPtrAssign((IUnknown**)&p, lp);
        }
        T* operator=(const CComPtr<T>& lp)
        {
                return (T*)AtlComPtrAssign((IUnknown**)&p, lp.p);
        }
        bool operator!() const
        {
                return (p == NULL);
        }
        bool operator<(T* pT) const
        {
                return p < pT;
        }
        bool operator==(T* pT) const
        {
                return p == pT;
        }
        // Compare two objects for equivalence
        bool IsEqualObject(IUnknown* pOther)
        {
                if (p == NULL && pOther == NULL)
                        return true; // They are both NULL objects

                if (p == NULL || pOther == NULL)
                        return false; // One is NULL the other is not

                CComPtr<IUnknown> punk1;
                CComPtr<IUnknown> punk2;
                p->QueryInterface(IID_IUnknown, (void**)&punk1);
                pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
                return punk1 == punk2;
        }
        void Attach(T* p2)
        {
                if (p)
                        p->Release();
                p = p2;
        }
        T* Detach()
        {
                T* pt = p;
                p = NULL;
                return pt;
        }
#if 0
        HRESULT CopyTo(T** ppT)
        {
                // there should either be a runtime check or an assert(not both).  otherwise
                // we can't depend on the runtime check during unattended api tests and have to
                // place a redundant extra check outside the call to CopyTo to keep assert
                // dialogs from popping up
                // ATLASSERT(ppT != NULL);
                if (ppT == NULL)
                        return E_POINTER;
                *ppT = p;
                if (p)
                        p->AddRef();
                return S_OK;
        }
#else
        // we want to enable CopyTo to work correctly with bases of T
        // if INTERFACE isn't a base then we'll get a compile error
        template<class INTERFACE> HRESULT CopyTo(INTERFACE** ppT)
        {
                // there should either be a runtime check or an assert(not both).  otherwise
                // we can't depend on the runtime check during unattended api tests and have to
                // place a redundant extra check outside the call to CopyTo to keep assert
                // dialogs from popping up
                // ATLASSERT(ppT != NULL);
                if (ppT == NULL)
                        return E_POINTER;
                *ppT = p;
                if (p)
                        p->AddRef();
                return S_OK;
        }
#endif
        HRESULT SetSite(IUnknown* punkParent)
        {
                return AtlSetChildSite(p, punkParent);
        }
        HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
        {
                return AtlAdvise(p, pUnk, iid, pdw);
        }
        HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
        {
                ATLASSERT(p == NULL);
                return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
        }
        HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
        {
                CLSID clsid;
                HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
                ATLASSERT(p == NULL);
                if (SUCCEEDED(hr))
                        hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
                return hr;
        }
        template <class Q>
        HRESULT QueryInterface(Q** pp) const
        {
                ATLASSERT(pp != NULL && *pp == NULL);
                return p->QueryInterface(__uuidof(Q), (void**)pp);
        }
                // this allows direct use in stl containers
                // without using the CAdapt template which causes extra addrefs/releases
                //  usage:
                // std::vector<CComPtr<IMytype>, CComPtr<IMytype>::stl_allocator>
        CComPtr<T> * address(void) { return this; }
        const CComPtr<T> * const_address(void) const { return this; }
                typedef stl_smart_ptr_allocator<CComPtr<T> > stl_allocator;

        T* p;
};


template <class T, const IID* piid = &__uuidof(T)>
class CComQIPtr
{
public:
        typedef T _PtrClass;
        CComQIPtr()
        {
                p=NULL;
        }
        CComQIPtr(T* lp)
        {
                if ((p = lp) != NULL)
                        p->AddRef();
        }
        CComQIPtr(const CComQIPtr<T,piid>& lp)
        {
                if ((p = lp.p) != NULL)
                        p->AddRef();
        }
        CComQIPtr(IUnknown* lp)
        {
                p=NULL;
                if (lp != NULL)
                        lp->QueryInterface(*piid, (void **)&p);
        }
        CComQIPtr(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
            : p(NULL)
        {
                ATLASSERT(p == NULL);
                HRESULT hr = ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
                if (FAILED(hr)) ATLASSERT(p == NULL);
        }
        CComQIPtr(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
            : p(NULL)
        {
                CLSID clsid;
                HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
                ATLASSERT(p == NULL);
                if (SUCCEEDED(hr))
                        hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
                if (FAILED(hr)) ATLASSERT(p == NULL);
        }
        ~CComQIPtr()
        {
                if (p)
                        p->Release();
        }
        void Release()
        {
                IUnknown* pTemp = p;
                if (pTemp)
                {
                        p = NULL;
                        pTemp->Release();
                }
        }
        operator T*() const
        {
                return p;
        }
        T& operator*() const
        {
                ATLASSERT(p!=NULL); return *p;
        }
        //The assert on operator& usually indicates a bug.  If this is really
        //what is needed, however, take the address of the p member explicitly.

        T** operator&()
        {
// this is unavoidably triggered by legitimate access inside templates.  example:
// using a CComQIPtr in an stl container and then using IEnumonSTLImpl the ::Next
// method contains a Copy::copy operation that causes this problem.
//            ATLASSERT(p==NULL);
            return &p;
        }
        _NoAddRefReleaseOnCComPtr<T>* operator->() const
        {
                ATLASSERT(p!=NULL);
                return (_NoAddRefReleaseOnCComPtr<T>*)p;
        }
        T* operator=(T* lp)
        {
                return (T*)AtlComPtrAssign((IUnknown**)&p, lp);
        }
        T* operator=(const CComQIPtr<T,piid>& lp)
        {
                return (T*)AtlComPtrAssign((IUnknown**)&p, lp.p);
        }
        T* operator=(IUnknown* lp)
        {
                return (T*)AtlComQIPtrAssign((IUnknown**)&p, lp, *piid);
        }
        bool operator!() const
        {
                return (p == NULL);
        }
        bool operator<(T* pT) const
        {
                return p < pT;
        }
        bool operator==(T* pT) const
        {
                return p == pT;
        }
        // Compare two objects for equivalence
        bool IsEqualObject(IUnknown* pOther)
        {
                if (p == NULL && pOther == NULL)
                        return true; // They are both NULL objects

                if (p == NULL || pOther == NULL)
                        return false; // One is NULL the other is not

                CComPtr<IUnknown> punk1;
                CComPtr<IUnknown> punk2;
                p->QueryInterface(IID_IUnknown, (void**)&punk1);
                pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
                return punk1 == punk2;
        }
        void Attach(T* p2)
        {
                if (p)
                        p->Release();
                p = p2;
        }
        T* Detach()
        {
                T* pt = p;
                p = NULL;
                return pt;
        }
#if 0
        HRESULT CopyTo(T** ppT)
        {
                // there should either be a runtime check or an assert(not both).  otherwise
                // we can't depend on the runtime check during unattended api tests and have to
                // place a redundant extra check outside the call to CopyTo to keep assert
                // dialogs from popping up
                // ATLASSERT(ppT != NULL);
                if (ppT == NULL)
                        return E_POINTER;
                *ppT = p;
                if (p)
                        p->AddRef();
                return S_OK;
        }
#else
        // we want to enable CopyTo to work correctly with bases of T
        // if INTERFACE isn't a base then we'll get a compile error
        template<class INTERFACE> HRESULT CopyTo(INTERFACE** ppT)
        {
                // there should either be a runtime check or an assert(not both).  otherwise
                // we can't depend on the runtime check during unattended api tests and have to
                // place a redundant extra check outside the call to CopyTo to keep assert
                // dialogs from popping up
                // ATLASSERT(ppT != NULL);
                if (ppT == NULL)
                        return E_POINTER;
                *ppT = p;
                if (p)
                        p->AddRef();
                return S_OK;
        }
#endif


        HRESULT SetSite(IUnknown* punkParent)
        {
                return AtlSetChildSite(p, punkParent);
        }
        HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
        {
                return AtlAdvise(p, pUnk, iid, pdw);
        }
        HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
        {
                ATLASSERT(p == NULL);
                return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
        }
        HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
        {
                CLSID clsid;
                HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
                ATLASSERT(p == NULL);
                if (SUCCEEDED(hr))
                        hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
                return hr;
        }
        template <class Q>
        HRESULT QueryInterface(Q** pp)
        {
                ATLASSERT(pp != NULL && *pp == NULL);
                return p->QueryInterface(__uuidof(Q), (void**)pp);
        }
                // this allows direct use in stl containers
                // without using the CAdapt template which causes extra addrefs/releases
                //  usage:
                // std::vector<CComQIPtr<IMytype>, CComQIPtr<IMytype>::stl_allocator>
        CComQIPtr<T,piid> * address(void) { return this; }
        const CComQIPtr<T,piid> * const_address(void) const { return this; }
                typedef stl_smart_ptr_allocator<CComQIPtr<T, piid> > stl_allocator;

        T* p;
};

//Specialization to make it work
template<>
class CComQIPtr<IUnknown, &IID_IUnknown>
{
public:
        typedef IUnknown _PtrClass;
        CComQIPtr()
        {
                p=NULL;
        }
        CComQIPtr(IUnknown* lp)
        {
                //Actually do a QI to get identity
                p=NULL;
                if (lp != NULL)
                        lp->QueryInterface(IID_IUnknown, (void **)&p);
        }
        CComQIPtr(const CComQIPtr<IUnknown,&IID_IUnknown>& lp)
        {
                if ((p = lp.p) != NULL)
                        p->AddRef();
        }
        CComQIPtr(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
            : p(NULL)
        {
                ATLASSERT(p == NULL);
                HRESULT hr = ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(IUnknown), (void**)&p);
                if (FAILED(hr)) ATLASSERT(p == NULL);
        }
        CComQIPtr(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
            : p(NULL)
        {
                CLSID clsid;
                HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
                ATLASSERT(p == NULL);
                if (SUCCEEDED(hr))
                        hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(IUnknown), (void**)&p);
                if (FAILED(hr)) ATLASSERT(p == NULL);
        }
        ~CComQIPtr()
        {
                if (p)
                        p->Release();
        }
        void Release()
        {
                IUnknown* pTemp = p;
                if (pTemp)
                {
                        p = NULL;
                        pTemp->Release();
                }
        }
        operator IUnknown*() const
        {
                return p;
        }
        IUnknown& operator*() const
        {
                ATLASSERT(p!=NULL);
                return *p;
        }
        //The assert on operator& usually indicates a bug.  If this is really
        //what is needed, however, take the address of the p member explicitly.
        IUnknown** operator&()
        {
                ATLASSERT(p==NULL);
                return &p;
        }
        _NoAddRefReleaseOnCComPtr<IUnknown>* operator->() const
        {
                ATLASSERT(p!=NULL);
                return (_NoAddRefReleaseOnCComPtr<IUnknown>*)p;
        }
        IUnknown* operator=(IUnknown* lp)
        {
                //Actually do a QI to get identity
                return (IUnknown*)AtlComQIPtrAssign((IUnknown**)&p, lp, IID_IUnknown);
        }
        IUnknown* operator=(const CComQIPtr<IUnknown,&IID_IUnknown>& lp)
        {
                return (IUnknown*)AtlComPtrAssign((IUnknown**)&p, lp.p);
        }
        bool operator!() const
        {
                return (p == NULL);
        }
        bool operator<(IUnknown* pT) const
        {
                return p < pT;
        }
        bool operator==(IUnknown* pT) const
        {
                return p == pT;
        }
        // Compare two objects for equivalence
        bool IsEqualObject(IUnknown* pOther)
        {
                if (p == NULL && pOther == NULL)
                        return true; // They are both NULL objects

                if (p == NULL || pOther == NULL)
                        return false; // One is NULL the other is not

                CComPtr<IUnknown> punk1;
                CComPtr<IUnknown> punk2;
                p->QueryInterface(IID_IUnknown, (void**)&punk1);
                pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
                return punk1 == punk2;
        }
        IUnknown* Detach()
        {
                IUnknown* pt = p;
                p = NULL;
                return pt;
        }
        HRESULT CopyTo(IUnknown** ppT)
        {
                // there should either be a runtime check or an assert(not both).  otherwise
                // we can't depend on the runtime check during unattended api tests and have to
                // place a redundant extra check outside the call to CopyTo to keep assert
                // dialogs from popping up
                //ATLASSERT(ppT != NULL);
                if (ppT == NULL)
                        return E_POINTER;
                *ppT = p;
                if (p)
                        p->AddRef();
                return S_OK;
        }
        HRESULT SetSite(IUnknown* punkParent)
        {
                return AtlSetChildSite(p, punkParent);
        }
        HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
        {
                return AtlAdvise(p, pUnk, iid, pdw);
        }
        HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
        {
                ATLASSERT(p == NULL);
                return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(IUnknown), (void**)&p);
        }
        HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
        {
                CLSID clsid;
                HRESULT hr = CLSIDFromProgID(szProgID, &clsid);
                ATLASSERT(p == NULL);
                if (SUCCEEDED(hr))
                        hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(IUnknown), (void**)&p);
                return hr;
        }
        template <class Q>
        HRESULT QueryInterface(Q** pp)
        {
                ATLASSERT(pp != NULL && *pp == NULL);
                return p->QueryInterface(__uuidof(Q), (void**)pp);
        }
                // this allows direct use in stl containers
                // without using the CAdapt template which causes extra addrefs/releases
                //  usage:
                // std::vector<CComPtr<IMytype>, CComPtr<IMytype>::stl_allocator>
        CComQIPtr<IUnknown,  &IID_IUnknown> * address(void) { return this; }
        const CComQIPtr<IUnknown,  &IID_IUnknown> * const_address(void) const { return this; }
                typedef stl_smart_ptr_allocator<CComQIPtr<IUnknown,  &IID_IUnknown> > stl_allocator;

        IUnknown* p;
};

#define com_cast CComQIPtr

#if 0
/////////////////////////////////////////////////////////////
// Class to Adapt CComBSTR and CComPtr for use with STL containers
// the syntax to use it is
// std::vector< CAdapt <CComBSTR> > vect;

template <class T>
class CAdapt
{
public:
        CAdapt()
        {
        }
        CAdapt(const T& rSrc)
        {
                m_T = rSrc;
        }

        CAdapt(const CAdapt& rSrCA)
        {
                m_T = rSrCA.m_T;
        }

        CAdapt& operator=(const T& rSrc)
        {
                m_T = rSrc;
                return *this;
        }
        bool operator<(const T& rSrc) const
        {
                return m_T < rSrc;
        }
        bool operator==(const T& rSrc) const
        {
                return m_T == rSrc;
        }
        operator T&()
        {
                return m_T;
        }

        operator const T&() const
        {
                return m_T;
        }

        T m_T;
};
#endif

/////////////////////////////////////////////////////////////////////////////
// GUID comparison

#ifndef _SYS_GUID_OPERATORS_
inline BOOL InlineIsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
   return (
          ((PLONG) &rguid1)[0] == ((PLONG) &rguid2)[0] &&
          ((PLONG) &rguid1)[1] == ((PLONG) &rguid2)[1] &&
          ((PLONG) &rguid1)[2] == ((PLONG) &rguid2)[2] &&
          ((PLONG) &rguid1)[3] == ((PLONG) &rguid2)[3]);
}
#endif

inline BOOL InlineIsEqualUnknown(REFGUID rguid1)
{
   return (
          ((PLONG) &rguid1)[0] == 0 &&
          ((PLONG) &rguid1)[1] == 0 &&
#ifdef _ATL_BYTESWAP
          ((PLONG) &rguid1)[2] == 0xC0000000 &&
          ((PLONG) &rguid1)[3] == 0x00000046);
#else
          ((PLONG) &rguid1)[2] == 0x000000C0 &&
          ((PLONG) &rguid1)[3] == 0x46000000);
#endif
}

/////////////////////////////////////////////////////////////////////////////
// Threading Model Support

class CComCriticalSection
{
public:
        void Lock() {EnterCriticalSection(&m_sec);}
        void Unlock() {LeaveCriticalSection(&m_sec);}
        void Init() {InitializeCriticalSection(&m_sec);}
        void Term() {DeleteCriticalSection(&m_sec);}
        CRITICAL_SECTION m_sec;
};

class CComAutoCriticalSection
{
public:
        void Lock() {EnterCriticalSection(&m_sec);}
        void Unlock() {LeaveCriticalSection(&m_sec);}
        CComAutoCriticalSection() {InitializeCriticalSection(&m_sec);}
        ~CComAutoCriticalSection() {DeleteCriticalSection(&m_sec);}
        CRITICAL_SECTION m_sec;
};

class CComFakeCriticalSection
{
public:
        void Lock() {}
        void Unlock() {}
        void Init() {}
        void Term() {}
};

class CComMultiThreadModelNoCS
{
public:
        static ULONG WINAPI Increment(LPLONG p) {return InterlockedIncrement(p);}
        static ULONG WINAPI Decrement(LPLONG p) {return InterlockedDecrement(p);}
        typedef CComFakeCriticalSection AutoCriticalSection;
        typedef CComFakeCriticalSection CriticalSection;
        typedef CComMultiThreadModelNoCS ThreadModelNoCS;
};

class CComMultiThreadModel
{
public:
        static ULONG WINAPI Increment(LPLONG p) {return InterlockedIncrement(p);}
        static ULONG WINAPI Decrement(LPLONG p) {return InterlockedDecrement(p);}
        typedef CComAutoCriticalSection AutoCriticalSection;
        typedef CComCriticalSection CriticalSection;
        typedef CComMultiThreadModelNoCS ThreadModelNoCS;
};

class CComSingleThreadModel
{
public:
        static ULONG WINAPI Increment(LPLONG p) {return ++(*p);}
        static ULONG WINAPI Decrement(LPLONG p) {return --(*p);}
        typedef CComFakeCriticalSection AutoCriticalSection;
        typedef CComFakeCriticalSection CriticalSection;
        typedef CComSingleThreadModel ThreadModelNoCS;
};

#if defined(_ATL_SINGLE_THREADED)
        typedef CComSingleThreadModel CComObjectThreadModel;
        typedef CComSingleThreadModel CComGlobalsThreadModel;
#elif defined(_ATL_APARTMENT_THREADED)
        typedef CComSingleThreadModel CComObjectThreadModel;
        typedef CComMultiThreadModel CComGlobalsThreadModel;
#else
        typedef CComMultiThreadModel CComObjectThreadModel;
        typedef CComMultiThreadModel CComGlobalsThreadModel;
#endif

/////////////////////////////////////////////////////////////////////////////
// CComModule

#define THREADFLAGS_APARTMENT 0x1
#define THREADFLAGS_BOTH 0x2
#define AUTPRXFLAG 0x4

HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr);

#ifdef _ATL_DEBUG_INTERFACES
struct _QIThunk
{
        STDMETHOD(QueryInterface)(REFIID iid, void** pp)
        {
                ATLASSERT(m_dwRef >= 0);
                return pUnk->QueryInterface(iid, pp);
        }
        STDMETHOD_(ULONG, AddRef)()
        {
                if (bBreak)
                        DebugBreak();
                pUnk->AddRef();
                return InternalAddRef();
        }
        ULONG InternalAddRef()
        {
                if (bBreak)
                        DebugBreak();
                ATLASSERT(m_dwRef >= 0);
                long l = InterlockedIncrement(&m_dwRef);
				ATLTRACE(_T("%d> "), m_dwRef);
                AtlDumpIID(iid, lpszClassName, S_OK);
                if (l > m_dwMaxRef)
                        m_dwMaxRef = l;
                return l;
        }
        STDMETHOD_(ULONG, Release)();

        STDMETHOD(f3)();
        STDMETHOD(f4)();
        STDMETHOD(f5)();
        STDMETHOD(f6)();
        STDMETHOD(f7)();
        STDMETHOD(f8)();
        STDMETHOD(f9)();
        STDMETHOD(f10)();
        STDMETHOD(f11)();
        STDMETHOD(f12)();
        STDMETHOD(f13)();
        STDMETHOD(f14)();
        STDMETHOD(f15)();
        STDMETHOD(f16)();
        STDMETHOD(f17)();
        STDMETHOD(f18)();
        STDMETHOD(f19)();
        STDMETHOD(f20)();
        STDMETHOD(f21)();
        STDMETHOD(f22)();
        STDMETHOD(f23)();
        STDMETHOD(f24)();
        STDMETHOD(f25)();
        STDMETHOD(f26)();
        STDMETHOD(f27)();
        STDMETHOD(f28)();
        STDMETHOD(f29)();
        STDMETHOD(f30)();
        STDMETHOD(f31)();
        STDMETHOD(f32)();
        STDMETHOD(f33)();
        STDMETHOD(f34)();
        STDMETHOD(f35)();
        STDMETHOD(f36)();
        STDMETHOD(f37)();
        STDMETHOD(f38)();
        STDMETHOD(f39)();
        STDMETHOD(f40)();
        STDMETHOD(f41)();
        STDMETHOD(f42)();
        STDMETHOD(f43)();
        STDMETHOD(f44)();
        STDMETHOD(f45)();
        STDMETHOD(f46)();
        STDMETHOD(f47)();
        STDMETHOD(f48)();
        STDMETHOD(f49)();
        STDMETHOD(f50)();
        STDMETHOD(f51)();
        STDMETHOD(f52)();
        STDMETHOD(f53)();
        STDMETHOD(f54)();
        STDMETHOD(f55)();
        STDMETHOD(f56)();
        STDMETHOD(f57)();
        STDMETHOD(f58)();
        STDMETHOD(f59)();
        STDMETHOD(f60)();
        STDMETHOD(f61)();
        STDMETHOD(f62)();
        STDMETHOD(f63)();
        STDMETHOD(f64)();
        STDMETHOD(f65)();
        STDMETHOD(f66)();
        STDMETHOD(f67)();
        STDMETHOD(f68)();
        STDMETHOD(f69)();
        STDMETHOD(f70)();
        STDMETHOD(f71)();
        STDMETHOD(f72)();
        STDMETHOD(f73)();
        STDMETHOD(f74)();
        STDMETHOD(f75)();
        STDMETHOD(f76)();
        STDMETHOD(f77)();
        STDMETHOD(f78)();
        STDMETHOD(f79)();
        STDMETHOD(f80)();
        STDMETHOD(f81)();
        STDMETHOD(f82)();
        STDMETHOD(f83)();
        STDMETHOD(f84)();
        STDMETHOD(f85)();
        STDMETHOD(f86)();
        STDMETHOD(f87)();
        STDMETHOD(f88)();
        STDMETHOD(f89)();
        STDMETHOD(f90)();
        STDMETHOD(f91)();
        STDMETHOD(f92)();
        STDMETHOD(f93)();
        STDMETHOD(f94)();
        STDMETHOD(f95)();
        STDMETHOD(f96)();
        STDMETHOD(f97)();
        STDMETHOD(f98)();
        STDMETHOD(f99)();
        STDMETHOD(f100)();
        STDMETHOD(f101)();
        STDMETHOD(f102)();
        STDMETHOD(f103)();
        STDMETHOD(f104)();
        STDMETHOD(f105)();
        STDMETHOD(f106)();
        STDMETHOD(f107)();
        STDMETHOD(f108)();
        STDMETHOD(f109)();
        STDMETHOD(f110)();
        STDMETHOD(f111)();
        STDMETHOD(f112)();
        STDMETHOD(f113)();
        STDMETHOD(f114)();
        STDMETHOD(f115)();
        STDMETHOD(f116)();
        STDMETHOD(f117)();
        STDMETHOD(f118)();
        STDMETHOD(f119)();
        STDMETHOD(f120)();
        STDMETHOD(f121)();
        STDMETHOD(f122)();
        STDMETHOD(f123)();
        STDMETHOD(f124)();
        STDMETHOD(f125)();
        STDMETHOD(f126)();
        STDMETHOD(f127)();
        STDMETHOD(f128)();
        STDMETHOD(f129)();
        STDMETHOD(f130)();
        STDMETHOD(f131)();
        STDMETHOD(f132)();
        STDMETHOD(f133)();
        STDMETHOD(f134)();
        STDMETHOD(f135)();
        STDMETHOD(f136)();
        STDMETHOD(f137)();
        STDMETHOD(f138)();
        STDMETHOD(f139)();
        STDMETHOD(f140)();
        STDMETHOD(f141)();
        STDMETHOD(f142)();
        STDMETHOD(f143)();
        STDMETHOD(f144)();
        STDMETHOD(f145)();
        STDMETHOD(f146)();
        STDMETHOD(f147)();
        STDMETHOD(f148)();
        STDMETHOD(f149)();
        STDMETHOD(f150)();
        STDMETHOD(f151)();
        STDMETHOD(f152)();
        STDMETHOD(f153)();
        STDMETHOD(f154)();
        STDMETHOD(f155)();
        STDMETHOD(f156)();
        STDMETHOD(f157)();
        STDMETHOD(f158)();
        STDMETHOD(f159)();
        STDMETHOD(f160)();
        STDMETHOD(f161)();
        STDMETHOD(f162)();
        STDMETHOD(f163)();
        STDMETHOD(f164)();
        STDMETHOD(f165)();
        STDMETHOD(f166)();
        STDMETHOD(f167)();
        STDMETHOD(f168)();
        STDMETHOD(f169)();
        STDMETHOD(f170)();
        STDMETHOD(f171)();
        STDMETHOD(f172)();
        STDMETHOD(f173)();
        STDMETHOD(f174)();
        STDMETHOD(f175)();
        STDMETHOD(f176)();
        STDMETHOD(f177)();
        STDMETHOD(f178)();
        STDMETHOD(f179)();
        STDMETHOD(f180)();
        STDMETHOD(f181)();
        STDMETHOD(f182)();
        STDMETHOD(f183)();
        STDMETHOD(f184)();
        STDMETHOD(f185)();
        STDMETHOD(f186)();
        STDMETHOD(f187)();
        STDMETHOD(f188)();
        STDMETHOD(f189)();
        STDMETHOD(f190)();
        STDMETHOD(f191)();
        STDMETHOD(f192)();
        STDMETHOD(f193)();
        STDMETHOD(f194)();
        STDMETHOD(f195)();
        STDMETHOD(f196)();
        STDMETHOD(f197)();
        STDMETHOD(f198)();
        STDMETHOD(f199)();
        STDMETHOD(f200)();
        STDMETHOD(f201)();
        STDMETHOD(f202)();
        STDMETHOD(f203)();
        STDMETHOD(f204)();
        STDMETHOD(f205)();
        STDMETHOD(f206)();
        STDMETHOD(f207)();
        STDMETHOD(f208)();
        STDMETHOD(f209)();
        STDMETHOD(f210)();
        STDMETHOD(f211)();
        STDMETHOD(f212)();
        STDMETHOD(f213)();
        STDMETHOD(f214)();
        STDMETHOD(f215)();
        STDMETHOD(f216)();
        STDMETHOD(f217)();
        STDMETHOD(f218)();
        STDMETHOD(f219)();
        STDMETHOD(f220)();
        STDMETHOD(f221)();
        STDMETHOD(f222)();
        STDMETHOD(f223)();
        STDMETHOD(f224)();
        STDMETHOD(f225)();
        STDMETHOD(f226)();
        STDMETHOD(f227)();
        STDMETHOD(f228)();
        STDMETHOD(f229)();
        STDMETHOD(f230)();
        STDMETHOD(f231)();
        STDMETHOD(f232)();
        STDMETHOD(f233)();
        STDMETHOD(f234)();
        STDMETHOD(f235)();
        STDMETHOD(f236)();
        STDMETHOD(f237)();
        STDMETHOD(f238)();
        STDMETHOD(f239)();
        STDMETHOD(f240)();
        STDMETHOD(f241)();
        STDMETHOD(f242)();
        STDMETHOD(f243)();
        STDMETHOD(f244)();
        STDMETHOD(f245)();
        STDMETHOD(f246)();
        STDMETHOD(f247)();
        STDMETHOD(f248)();
        STDMETHOD(f249)();
        STDMETHOD(f250)();
        STDMETHOD(f251)();
        STDMETHOD(f252)();
        STDMETHOD(f253)();
        STDMETHOD(f254)();
        STDMETHOD(f255)();
        STDMETHOD(f256)();
        STDMETHOD(f257)();
        STDMETHOD(f258)();
        STDMETHOD(f259)();
        STDMETHOD(f260)();
        STDMETHOD(f261)();
        STDMETHOD(f262)();
        STDMETHOD(f263)();
        STDMETHOD(f264)();
        STDMETHOD(f265)();
        STDMETHOD(f266)();
        STDMETHOD(f267)();
        STDMETHOD(f268)();
        STDMETHOD(f269)();
        STDMETHOD(f270)();
        STDMETHOD(f271)();
        STDMETHOD(f272)();
        STDMETHOD(f273)();
        STDMETHOD(f274)();
        STDMETHOD(f275)();
        STDMETHOD(f276)();
        STDMETHOD(f277)();
        STDMETHOD(f278)();
        STDMETHOD(f279)();
        STDMETHOD(f280)();
        STDMETHOD(f281)();
        STDMETHOD(f282)();
        STDMETHOD(f283)();
        STDMETHOD(f284)();
        STDMETHOD(f285)();
        STDMETHOD(f286)();
        STDMETHOD(f287)();
        STDMETHOD(f288)();
        STDMETHOD(f289)();
        STDMETHOD(f290)();
        STDMETHOD(f291)();
        STDMETHOD(f292)();
        STDMETHOD(f293)();
        STDMETHOD(f294)();
        STDMETHOD(f295)();
        STDMETHOD(f296)();
        STDMETHOD(f297)();
        STDMETHOD(f298)();
        STDMETHOD(f299)();
        STDMETHOD(f300)();
        STDMETHOD(f301)();
        STDMETHOD(f302)();
        STDMETHOD(f303)();
        STDMETHOD(f304)();
        STDMETHOD(f305)();
        STDMETHOD(f306)();
        STDMETHOD(f307)();
        STDMETHOD(f308)();
        STDMETHOD(f309)();
        STDMETHOD(f310)();
        STDMETHOD(f311)();
        STDMETHOD(f312)();
        STDMETHOD(f313)();
        STDMETHOD(f314)();
        STDMETHOD(f315)();
        STDMETHOD(f316)();
        STDMETHOD(f317)();
        STDMETHOD(f318)();
        STDMETHOD(f319)();
        STDMETHOD(f320)();
        STDMETHOD(f321)();
        STDMETHOD(f322)();
        STDMETHOD(f323)();
        STDMETHOD(f324)();
        STDMETHOD(f325)();
        STDMETHOD(f326)();
        STDMETHOD(f327)();
        STDMETHOD(f328)();
        STDMETHOD(f329)();
        STDMETHOD(f330)();
        STDMETHOD(f331)();
        STDMETHOD(f332)();
        STDMETHOD(f333)();
        STDMETHOD(f334)();
        STDMETHOD(f335)();
        STDMETHOD(f336)();
        STDMETHOD(f337)();
        STDMETHOD(f338)();
        STDMETHOD(f339)();
        STDMETHOD(f340)();
        STDMETHOD(f341)();
        STDMETHOD(f342)();
        STDMETHOD(f343)();
        STDMETHOD(f344)();
        STDMETHOD(f345)();
        STDMETHOD(f346)();
        STDMETHOD(f347)();
        STDMETHOD(f348)();
        STDMETHOD(f349)();
        STDMETHOD(f350)();
        STDMETHOD(f351)();
        STDMETHOD(f352)();
        STDMETHOD(f353)();
        STDMETHOD(f354)();
        STDMETHOD(f355)();
        STDMETHOD(f356)();
        STDMETHOD(f357)();
        STDMETHOD(f358)();
        STDMETHOD(f359)();
        STDMETHOD(f360)();
        STDMETHOD(f361)();
        STDMETHOD(f362)();
        STDMETHOD(f363)();
        STDMETHOD(f364)();
        STDMETHOD(f365)();
        STDMETHOD(f366)();
        STDMETHOD(f367)();
        STDMETHOD(f368)();
        STDMETHOD(f369)();
        STDMETHOD(f370)();
        STDMETHOD(f371)();
        STDMETHOD(f372)();
        STDMETHOD(f373)();
        STDMETHOD(f374)();
        STDMETHOD(f375)();
        STDMETHOD(f376)();
        STDMETHOD(f377)();
        STDMETHOD(f378)();
        STDMETHOD(f379)();
        STDMETHOD(f380)();
        STDMETHOD(f381)();
        STDMETHOD(f382)();
        STDMETHOD(f383)();
        STDMETHOD(f384)();
        STDMETHOD(f385)();
        STDMETHOD(f386)();
        STDMETHOD(f387)();
        STDMETHOD(f388)();
        STDMETHOD(f389)();
        STDMETHOD(f390)();
        STDMETHOD(f391)();
        STDMETHOD(f392)();
        STDMETHOD(f393)();
        STDMETHOD(f394)();
        STDMETHOD(f395)();
        STDMETHOD(f396)();
        STDMETHOD(f397)();
        STDMETHOD(f398)();
        STDMETHOD(f399)();
        STDMETHOD(f400)();
        STDMETHOD(f401)();
        STDMETHOD(f402)();
        STDMETHOD(f403)();
        STDMETHOD(f404)();
        STDMETHOD(f405)();
        STDMETHOD(f406)();
        STDMETHOD(f407)();
        STDMETHOD(f408)();
        STDMETHOD(f409)();
        STDMETHOD(f410)();
        STDMETHOD(f411)();
        STDMETHOD(f412)();
        STDMETHOD(f413)();
        STDMETHOD(f414)();
        STDMETHOD(f415)();
        STDMETHOD(f416)();
        STDMETHOD(f417)();
        STDMETHOD(f418)();
        STDMETHOD(f419)();
        STDMETHOD(f420)();
        STDMETHOD(f421)();
        STDMETHOD(f422)();
        STDMETHOD(f423)();
        STDMETHOD(f424)();
        STDMETHOD(f425)();
        STDMETHOD(f426)();
        STDMETHOD(f427)();
        STDMETHOD(f428)();
        STDMETHOD(f429)();
        STDMETHOD(f430)();
        STDMETHOD(f431)();
        STDMETHOD(f432)();
        STDMETHOD(f433)();
        STDMETHOD(f434)();
        STDMETHOD(f435)();
        STDMETHOD(f436)();
        STDMETHOD(f437)();
        STDMETHOD(f438)();
        STDMETHOD(f439)();
        STDMETHOD(f440)();
        STDMETHOD(f441)();
        STDMETHOD(f442)();
        STDMETHOD(f443)();
        STDMETHOD(f444)();
        STDMETHOD(f445)();
        STDMETHOD(f446)();
        STDMETHOD(f447)();
        STDMETHOD(f448)();
        STDMETHOD(f449)();
        STDMETHOD(f450)();
        STDMETHOD(f451)();
        STDMETHOD(f452)();
        STDMETHOD(f453)();
        STDMETHOD(f454)();
        STDMETHOD(f455)();
        STDMETHOD(f456)();
        STDMETHOD(f457)();
        STDMETHOD(f458)();
        STDMETHOD(f459)();
        STDMETHOD(f460)();
        STDMETHOD(f461)();
        STDMETHOD(f462)();
        STDMETHOD(f463)();
        STDMETHOD(f464)();
        STDMETHOD(f465)();
        STDMETHOD(f466)();
        STDMETHOD(f467)();
        STDMETHOD(f468)();
        STDMETHOD(f469)();
        STDMETHOD(f470)();
        STDMETHOD(f471)();
        STDMETHOD(f472)();
        STDMETHOD(f473)();
        STDMETHOD(f474)();
        STDMETHOD(f475)();
        STDMETHOD(f476)();
        STDMETHOD(f477)();
        STDMETHOD(f478)();
        STDMETHOD(f479)();
        STDMETHOD(f480)();
        STDMETHOD(f481)();
        STDMETHOD(f482)();
        STDMETHOD(f483)();
        STDMETHOD(f484)();
        STDMETHOD(f485)();
        STDMETHOD(f486)();
        STDMETHOD(f487)();
        STDMETHOD(f488)();
        STDMETHOD(f489)();
        STDMETHOD(f490)();
        STDMETHOD(f491)();
        STDMETHOD(f492)();
        STDMETHOD(f493)();
        STDMETHOD(f494)();
        STDMETHOD(f495)();
        STDMETHOD(f496)();
        STDMETHOD(f497)();
        STDMETHOD(f498)();
        STDMETHOD(f499)();
        STDMETHOD(f500)();
        STDMETHOD(f501)();
        STDMETHOD(f502)();
        STDMETHOD(f503)();
        STDMETHOD(f504)();
        STDMETHOD(f505)();
        STDMETHOD(f506)();
        STDMETHOD(f507)();
        STDMETHOD(f508)();
        STDMETHOD(f509)();
        STDMETHOD(f510)();
        STDMETHOD(f511)();
        STDMETHOD(f512)();
        STDMETHOD(f513)();
        STDMETHOD(f514)();
        STDMETHOD(f515)();
        STDMETHOD(f516)();
        STDMETHOD(f517)();
        STDMETHOD(f518)();
        STDMETHOD(f519)();
        STDMETHOD(f520)();
        STDMETHOD(f521)();
        STDMETHOD(f522)();
        STDMETHOD(f523)();
        STDMETHOD(f524)();
        STDMETHOD(f525)();
        STDMETHOD(f526)();
        STDMETHOD(f527)();
        STDMETHOD(f528)();
        STDMETHOD(f529)();
        STDMETHOD(f530)();
        STDMETHOD(f531)();
        STDMETHOD(f532)();
        STDMETHOD(f533)();
        STDMETHOD(f534)();
        STDMETHOD(f535)();
        STDMETHOD(f536)();
        STDMETHOD(f537)();
        STDMETHOD(f538)();
        STDMETHOD(f539)();
        STDMETHOD(f540)();
        STDMETHOD(f541)();
        STDMETHOD(f542)();
        STDMETHOD(f543)();
        STDMETHOD(f544)();
        STDMETHOD(f545)();
        STDMETHOD(f546)();
        STDMETHOD(f547)();
        STDMETHOD(f548)();
        STDMETHOD(f549)();
        STDMETHOD(f550)();
        STDMETHOD(f551)();
        STDMETHOD(f552)();
        STDMETHOD(f553)();
        STDMETHOD(f554)();
        STDMETHOD(f555)();
        STDMETHOD(f556)();
        STDMETHOD(f557)();
        STDMETHOD(f558)();
        STDMETHOD(f559)();
        STDMETHOD(f560)();
        STDMETHOD(f561)();
        STDMETHOD(f562)();
        STDMETHOD(f563)();
        STDMETHOD(f564)();
        STDMETHOD(f565)();
        STDMETHOD(f566)();
        STDMETHOD(f567)();
        STDMETHOD(f568)();
        STDMETHOD(f569)();
        STDMETHOD(f570)();
        STDMETHOD(f571)();
        STDMETHOD(f572)();
        STDMETHOD(f573)();
        STDMETHOD(f574)();
        STDMETHOD(f575)();
        STDMETHOD(f576)();
        STDMETHOD(f577)();
        STDMETHOD(f578)();
        STDMETHOD(f579)();
        STDMETHOD(f580)();
        STDMETHOD(f581)();
        STDMETHOD(f582)();
        STDMETHOD(f583)();
        STDMETHOD(f584)();
        STDMETHOD(f585)();
        STDMETHOD(f586)();
        STDMETHOD(f587)();
        STDMETHOD(f588)();
        STDMETHOD(f589)();
        STDMETHOD(f590)();
        STDMETHOD(f591)();
        STDMETHOD(f592)();
        STDMETHOD(f593)();
        STDMETHOD(f594)();
        STDMETHOD(f595)();
        STDMETHOD(f596)();
        STDMETHOD(f597)();
        STDMETHOD(f598)();
        STDMETHOD(f599)();
        STDMETHOD(f600)();
        STDMETHOD(f601)();
        STDMETHOD(f602)();
        STDMETHOD(f603)();
        STDMETHOD(f604)();
        STDMETHOD(f605)();
        STDMETHOD(f606)();
        STDMETHOD(f607)();
        STDMETHOD(f608)();
        STDMETHOD(f609)();
        STDMETHOD(f610)();
        STDMETHOD(f611)();
        STDMETHOD(f612)();
        STDMETHOD(f613)();
        STDMETHOD(f614)();
        STDMETHOD(f615)();
        STDMETHOD(f616)();
        STDMETHOD(f617)();
        STDMETHOD(f618)();
        STDMETHOD(f619)();
        STDMETHOD(f620)();
        STDMETHOD(f621)();
        STDMETHOD(f622)();
        STDMETHOD(f623)();
        STDMETHOD(f624)();
        STDMETHOD(f625)();
        STDMETHOD(f626)();
        STDMETHOD(f627)();
        STDMETHOD(f628)();
        STDMETHOD(f629)();
        STDMETHOD(f630)();
        STDMETHOD(f631)();
        STDMETHOD(f632)();
        STDMETHOD(f633)();
        STDMETHOD(f634)();
        STDMETHOD(f635)();
        STDMETHOD(f636)();
        STDMETHOD(f637)();
        STDMETHOD(f638)();
        STDMETHOD(f639)();
        STDMETHOD(f640)();
        STDMETHOD(f641)();
        STDMETHOD(f642)();
        STDMETHOD(f643)();
        STDMETHOD(f644)();
        STDMETHOD(f645)();
        STDMETHOD(f646)();
        STDMETHOD(f647)();
        STDMETHOD(f648)();
        STDMETHOD(f649)();
        STDMETHOD(f650)();
        STDMETHOD(f651)();
        STDMETHOD(f652)();
        STDMETHOD(f653)();
        STDMETHOD(f654)();
        STDMETHOD(f655)();
        STDMETHOD(f656)();
        STDMETHOD(f657)();
        STDMETHOD(f658)();
        STDMETHOD(f659)();
        STDMETHOD(f660)();
        STDMETHOD(f661)();
        STDMETHOD(f662)();
        STDMETHOD(f663)();
        STDMETHOD(f664)();
        STDMETHOD(f665)();
        STDMETHOD(f666)();
        STDMETHOD(f667)();
        STDMETHOD(f668)();
        STDMETHOD(f669)();
        STDMETHOD(f670)();
        STDMETHOD(f671)();
        STDMETHOD(f672)();
        STDMETHOD(f673)();
        STDMETHOD(f674)();
        STDMETHOD(f675)();
        STDMETHOD(f676)();
        STDMETHOD(f677)();
        STDMETHOD(f678)();
        STDMETHOD(f679)();
        STDMETHOD(f680)();
        STDMETHOD(f681)();
        STDMETHOD(f682)();
        STDMETHOD(f683)();
        STDMETHOD(f684)();
        STDMETHOD(f685)();
        STDMETHOD(f686)();
        STDMETHOD(f687)();
        STDMETHOD(f688)();
        STDMETHOD(f689)();
        STDMETHOD(f690)();
        STDMETHOD(f691)();
        STDMETHOD(f692)();
        STDMETHOD(f693)();
        STDMETHOD(f694)();
        STDMETHOD(f695)();
        STDMETHOD(f696)();
        STDMETHOD(f697)();
        STDMETHOD(f698)();
        STDMETHOD(f699)();
        STDMETHOD(f700)();
        STDMETHOD(f701)();
        STDMETHOD(f702)();
        STDMETHOD(f703)();
        STDMETHOD(f704)();
        STDMETHOD(f705)();
        STDMETHOD(f706)();
        STDMETHOD(f707)();
        STDMETHOD(f708)();
        STDMETHOD(f709)();
        STDMETHOD(f710)();
        STDMETHOD(f711)();
        STDMETHOD(f712)();
        STDMETHOD(f713)();
        STDMETHOD(f714)();
        STDMETHOD(f715)();
        STDMETHOD(f716)();
        STDMETHOD(f717)();
        STDMETHOD(f718)();
        STDMETHOD(f719)();
        STDMETHOD(f720)();
        STDMETHOD(f721)();
        STDMETHOD(f722)();
        STDMETHOD(f723)();
        STDMETHOD(f724)();
        STDMETHOD(f725)();
        STDMETHOD(f726)();
        STDMETHOD(f727)();
        STDMETHOD(f728)();
        STDMETHOD(f729)();
        STDMETHOD(f730)();
        STDMETHOD(f731)();
        STDMETHOD(f732)();
        STDMETHOD(f733)();
        STDMETHOD(f734)();
        STDMETHOD(f735)();
        STDMETHOD(f736)();
        STDMETHOD(f737)();
        STDMETHOD(f738)();
        STDMETHOD(f739)();
        STDMETHOD(f740)();
        STDMETHOD(f741)();
        STDMETHOD(f742)();
        STDMETHOD(f743)();
        STDMETHOD(f744)();
        STDMETHOD(f745)();
        STDMETHOD(f746)();
        STDMETHOD(f747)();
        STDMETHOD(f748)();
        STDMETHOD(f749)();
        STDMETHOD(f750)();
        STDMETHOD(f751)();
        STDMETHOD(f752)();
        STDMETHOD(f753)();
        STDMETHOD(f754)();
        STDMETHOD(f755)();
        STDMETHOD(f756)();
        STDMETHOD(f757)();
        STDMETHOD(f758)();
        STDMETHOD(f759)();
        STDMETHOD(f760)();
        STDMETHOD(f761)();
        STDMETHOD(f762)();
        STDMETHOD(f763)();
        STDMETHOD(f764)();
        STDMETHOD(f765)();
        STDMETHOD(f766)();
        STDMETHOD(f767)();
        STDMETHOD(f768)();
        STDMETHOD(f769)();
        STDMETHOD(f770)();
        STDMETHOD(f771)();
        STDMETHOD(f772)();
        STDMETHOD(f773)();
        STDMETHOD(f774)();
        STDMETHOD(f775)();
        STDMETHOD(f776)();
        STDMETHOD(f777)();
        STDMETHOD(f778)();
        STDMETHOD(f779)();
        STDMETHOD(f780)();
        STDMETHOD(f781)();
        STDMETHOD(f782)();
        STDMETHOD(f783)();
        STDMETHOD(f784)();
        STDMETHOD(f785)();
        STDMETHOD(f786)();
        STDMETHOD(f787)();
        STDMETHOD(f788)();
        STDMETHOD(f789)();
        STDMETHOD(f790)();
        STDMETHOD(f791)();
        STDMETHOD(f792)();
        STDMETHOD(f793)();
        STDMETHOD(f794)();
        STDMETHOD(f795)();
        STDMETHOD(f796)();
        STDMETHOD(f797)();
        STDMETHOD(f798)();
        STDMETHOD(f799)();
        STDMETHOD(f800)();
        STDMETHOD(f801)();
        STDMETHOD(f802)();
        STDMETHOD(f803)();
        STDMETHOD(f804)();
        STDMETHOD(f805)();
        STDMETHOD(f806)();
        STDMETHOD(f807)();
        STDMETHOD(f808)();
        STDMETHOD(f809)();
        STDMETHOD(f810)();
        STDMETHOD(f811)();
        STDMETHOD(f812)();
        STDMETHOD(f813)();
        STDMETHOD(f814)();
        STDMETHOD(f815)();
        STDMETHOD(f816)();
        STDMETHOD(f817)();
        STDMETHOD(f818)();
        STDMETHOD(f819)();
        STDMETHOD(f820)();
        STDMETHOD(f821)();
        STDMETHOD(f822)();
        STDMETHOD(f823)();
        STDMETHOD(f824)();
        STDMETHOD(f825)();
        STDMETHOD(f826)();
        STDMETHOD(f827)();
        STDMETHOD(f828)();
        STDMETHOD(f829)();
        STDMETHOD(f830)();
        STDMETHOD(f831)();
        STDMETHOD(f832)();
        STDMETHOD(f833)();
        STDMETHOD(f834)();
        STDMETHOD(f835)();
        STDMETHOD(f836)();
        STDMETHOD(f837)();
        STDMETHOD(f838)();
        STDMETHOD(f839)();
        STDMETHOD(f840)();
        STDMETHOD(f841)();
        STDMETHOD(f842)();
        STDMETHOD(f843)();
        STDMETHOD(f844)();
        STDMETHOD(f845)();
        STDMETHOD(f846)();
        STDMETHOD(f847)();
        STDMETHOD(f848)();
        STDMETHOD(f849)();
        STDMETHOD(f850)();
        STDMETHOD(f851)();
        STDMETHOD(f852)();
        STDMETHOD(f853)();
        STDMETHOD(f854)();
        STDMETHOD(f855)();
        STDMETHOD(f856)();
        STDMETHOD(f857)();
        STDMETHOD(f858)();
        STDMETHOD(f859)();
        STDMETHOD(f860)();
        STDMETHOD(f861)();
        STDMETHOD(f862)();
        STDMETHOD(f863)();
        STDMETHOD(f864)();
        STDMETHOD(f865)();
        STDMETHOD(f866)();
        STDMETHOD(f867)();
        STDMETHOD(f868)();
        STDMETHOD(f869)();
        STDMETHOD(f870)();
        STDMETHOD(f871)();
        STDMETHOD(f872)();
        STDMETHOD(f873)();
        STDMETHOD(f874)();
        STDMETHOD(f875)();
        STDMETHOD(f876)();
        STDMETHOD(f877)();
        STDMETHOD(f878)();
        STDMETHOD(f879)();
        STDMETHOD(f880)();
        STDMETHOD(f881)();
        STDMETHOD(f882)();
        STDMETHOD(f883)();
        STDMETHOD(f884)();
        STDMETHOD(f885)();
        STDMETHOD(f886)();
        STDMETHOD(f887)();
        STDMETHOD(f888)();
        STDMETHOD(f889)();
        STDMETHOD(f890)();
        STDMETHOD(f891)();
        STDMETHOD(f892)();
        STDMETHOD(f893)();
        STDMETHOD(f894)();
        STDMETHOD(f895)();
        STDMETHOD(f896)();
        STDMETHOD(f897)();
        STDMETHOD(f898)();
        STDMETHOD(f899)();
        STDMETHOD(f900)();
        STDMETHOD(f901)();
        STDMETHOD(f902)();
        STDMETHOD(f903)();
        STDMETHOD(f904)();
        STDMETHOD(f905)();
        STDMETHOD(f906)();
        STDMETHOD(f907)();
        STDMETHOD(f908)();
        STDMETHOD(f909)();
        STDMETHOD(f910)();
        STDMETHOD(f911)();
        STDMETHOD(f912)();
        STDMETHOD(f913)();
        STDMETHOD(f914)();
        STDMETHOD(f915)();
        STDMETHOD(f916)();
        STDMETHOD(f917)();
        STDMETHOD(f918)();
        STDMETHOD(f919)();
        STDMETHOD(f920)();
        STDMETHOD(f921)();
        STDMETHOD(f922)();
        STDMETHOD(f923)();
        STDMETHOD(f924)();
        STDMETHOD(f925)();
        STDMETHOD(f926)();
        STDMETHOD(f927)();
        STDMETHOD(f928)();
        STDMETHOD(f929)();
        STDMETHOD(f930)();
        STDMETHOD(f931)();
        STDMETHOD(f932)();
        STDMETHOD(f933)();
        STDMETHOD(f934)();
        STDMETHOD(f935)();
        STDMETHOD(f936)();
        STDMETHOD(f937)();
        STDMETHOD(f938)();
        STDMETHOD(f939)();
        STDMETHOD(f940)();
        STDMETHOD(f941)();
        STDMETHOD(f942)();
        STDMETHOD(f943)();
        STDMETHOD(f944)();
        STDMETHOD(f945)();
        STDMETHOD(f946)();
        STDMETHOD(f947)();
        STDMETHOD(f948)();
        STDMETHOD(f949)();
        STDMETHOD(f950)();
        STDMETHOD(f951)();
        STDMETHOD(f952)();
        STDMETHOD(f953)();
        STDMETHOD(f954)();
        STDMETHOD(f955)();
        STDMETHOD(f956)();
        STDMETHOD(f957)();
        STDMETHOD(f958)();
        STDMETHOD(f959)();
        STDMETHOD(f960)();
        STDMETHOD(f961)();
        STDMETHOD(f962)();
        STDMETHOD(f963)();
        STDMETHOD(f964)();
        STDMETHOD(f965)();
        STDMETHOD(f966)();
        STDMETHOD(f967)();
        STDMETHOD(f968)();
        STDMETHOD(f969)();
        STDMETHOD(f970)();
        STDMETHOD(f971)();
        STDMETHOD(f972)();
        STDMETHOD(f973)();
        STDMETHOD(f974)();
        STDMETHOD(f975)();
        STDMETHOD(f976)();
        STDMETHOD(f977)();
        STDMETHOD(f978)();
        STDMETHOD(f979)();
        STDMETHOD(f980)();
        STDMETHOD(f981)();
        STDMETHOD(f982)();
        STDMETHOD(f983)();
        STDMETHOD(f984)();
        STDMETHOD(f985)();
        STDMETHOD(f986)();
        STDMETHOD(f987)();
        STDMETHOD(f988)();
        STDMETHOD(f989)();
        STDMETHOD(f990)();
        STDMETHOD(f991)();
        STDMETHOD(f992)();
        STDMETHOD(f993)();
        STDMETHOD(f994)();
        STDMETHOD(f995)();
        STDMETHOD(f996)();
        STDMETHOD(f997)();
        STDMETHOD(f998)();
        STDMETHOD(f999)();
        STDMETHOD(f1000)();
        STDMETHOD(f1001)();
        STDMETHOD(f1002)();
        STDMETHOD(f1003)();
        STDMETHOD(f1004)();
        STDMETHOD(f1005)();
        STDMETHOD(f1006)();
        STDMETHOD(f1007)();
        STDMETHOD(f1008)();
        STDMETHOD(f1009)();
        STDMETHOD(f1010)();
        STDMETHOD(f1011)();
        STDMETHOD(f1012)();
        STDMETHOD(f1013)();
        STDMETHOD(f1014)();
        STDMETHOD(f1015)();
        STDMETHOD(f1016)();
        STDMETHOD(f1017)();
        STDMETHOD(f1018)();
        STDMETHOD(f1019)();
        STDMETHOD(f1020)();
        STDMETHOD(f1021)();
        STDMETHOD(f1022)();
        STDMETHOD(f1023)();
        STDMETHOD(f1024)();
        _QIThunk(IUnknown* pOrig, LPCTSTR p, const IID& i, UINT n, bool b)
        {
                lpszClassName = p;
                iid = i;
                nIndex = n;
                m_dwRef = 0;
                m_dwMaxRef = 0;
                pUnk = pOrig;
                bBreak = b;
                bNonAddRefThunk = false;
        }
        IUnknown* pUnk;
        long m_dwRef;
        long m_dwMaxRef;
        LPCTSTR lpszClassName;
        IID iid;
        UINT nIndex;
        bool bBreak;
        bool bNonAddRefThunk;
        void Dump()
        {
                TCHAR buf[256];
                if (m_dwRef != 0)
                {
                        wsprintf(buf, _T("INTERFACE LEAK: RefCount = %d, MaxRefCount = %d, {Allocation = %d} "), m_dwRef, m_dwMaxRef, nIndex);
                        OutputDebugString(buf);
                        AtlDumpIID(iid, lpszClassName, S_OK);
                }
                else
                {
                        wsprintf(buf, _T("NonAddRef Thunk LEAK: {Allocation = %d}\n"), nIndex);
                        OutputDebugString(buf);
                }
        }
};

#endif


/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CSimpleArray & CSimpleMap

template <class T>
class CSimpleArray
{
public:
        T* m_aT;
        int m_nSize;
        int m_nAllocSize;

// Construction/destruction
        CSimpleArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
        { }

        ~CSimpleArray()
        {
                RemoveAll();
        }

// Operations
        int GetSize() const
        {
                return m_nSize;
        }
        BOOL Add(T& t)
        {
                if(m_nSize == m_nAllocSize)
                {
                        T* aT;
                        int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
                        aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
                        if(aT == NULL)
                                return FALSE;
                        m_nAllocSize = nNewAllocSize;
                        m_aT = aT;
                }
                m_nSize++;
                SetAtIndex(m_nSize - 1, t);
                return TRUE;
        }
        BOOL Remove(T& t)
        {
                int nIndex = Find(t);
                if(nIndex == -1)
                        return FALSE;
                return RemoveAt(nIndex);
        }
        BOOL RemoveAt(int nIndex)
        {
                if(nIndex != (m_nSize - 1))
                {
#if _MSC_VER >= 1200
					m_aT[nIndex].~T();
#else
		            T* MyT;
		            MyT = &m_aT[nIndex];
		            MyT->~T();
#endif
                    memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(T));
                }
                m_nSize--;
                return TRUE;
        }
        void RemoveAll()
        {
                if(m_aT != NULL)
                {
					for(int i = 0; i < m_nSize; i++) {
#if _MSC_VER >= 1200
						m_aT[i].~T();
#else
		                T* MyT;
		                MyT = &m_aT[i];
		                MyT->~T();
#endif
		            }
                    free(m_aT);
                    m_aT = NULL;
                }
                m_nSize = 0;
                m_nAllocSize = 0;
        }
        T& operator[] (int nIndex) const
        {
                ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
                return m_aT[nIndex];
        }
        T* GetData() const
        {
                return m_aT;
        }

// Implementation
        class Wrapper
        {
        public:
                Wrapper(T& _t) : t(_t)
                {
                }
                template <class _Ty>
                void *operator new(size_t, _Ty* p)
                {
                        return p;
                }
                T t;
        };
        void SetAtIndex(int nIndex, T& t)
        {
                ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
				new(m_aT + nIndex) Wrapper(t);
        }
        int Find(T& t) const
        {
                for(int i = 0; i < m_nSize; i++)
                {
                        if(m_aT[i] == t)
                                return i;
                }
                return -1;  // not found
        }
};

// for arrays of simple types
template <class T>
class CSimpleValArray : public CSimpleArray< T >
{
public:
        BOOL Add(T t)
        {
                return CSimpleArray< T >::Add(t);
        }
        BOOL Remove(T t)
        {
                return CSimpleArray< T >::Remove(t);
        }
        T operator[] (int nIndex) const
        {
                return CSimpleArray< T >::operator[](nIndex);
        }
};


// intended for small number of simple types or pointers
template <class TKey, class TVal>
class CSimpleMap
{
public:
        TKey* m_aKey;
        TVal* m_aVal;
        int m_nSize;

// Construction/destruction
        CSimpleMap() : m_aKey(NULL), m_aVal(NULL), m_nSize(0)
        { }

        ~CSimpleMap()
        {
                RemoveAll();
        }

// Operations
        int GetSize() const
        {
                return m_nSize;
        }
        BOOL Add(TKey key, TVal val)
        {
                TKey* pKey;
                pKey = (TKey*)realloc(m_aKey, (m_nSize + 1) * sizeof(TKey));
                if(pKey == NULL)
                        return FALSE;
                m_aKey = pKey;
                TVal* pVal;
                pVal = (TVal*)realloc(m_aVal, (m_nSize + 1) * sizeof(TVal));
                if(pVal == NULL)
                        return FALSE;
                m_aVal = pVal;
                m_nSize++;
                SetAtIndex(m_nSize - 1, key, val);
                return TRUE;
        }
        BOOL Remove(TKey key)
        {
                int nIndex = FindKey(key);
                if(nIndex == -1)
                        return FALSE;
                if(nIndex != (m_nSize - 1))
                {
                        m_aKey[nIndex].~TKey();
                        m_aVal[nIndex].~TVal();
                        memmove((void*)&m_aKey[nIndex], (void*)&m_aKey[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TKey));
                        memmove((void*)&m_aVal[nIndex], (void*)&m_aVal[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TVal));
                }
                TKey* pKey;
                pKey = (TKey*)realloc(m_aKey, (m_nSize - 1) * sizeof(TKey));
                if(pKey != NULL || m_nSize == 1)
                        m_aKey = pKey;
                TVal* pVal;
                pVal = (TVal*)realloc(m_aVal, (m_nSize - 1) * sizeof(TVal));
                if(pVal != NULL || m_nSize == 1)
                        m_aVal = pVal;
                m_nSize--;
                return TRUE;
        }
        void RemoveAll()
        {
                if(m_aKey != NULL)
                {
                        for(int i = 0; i < m_nSize; i++)
                        {
                                m_aKey[i].~TKey();
                                m_aVal[i].~TVal();
                        }
                        free(m_aKey);
                        m_aKey = NULL;
                }
                if(m_aVal != NULL)
                {
                        free(m_aVal);
                        m_aVal = NULL;
                }

                m_nSize = 0;
        }
        BOOL SetAt(TKey key, TVal val)
        {
                int nIndex = FindKey(key);
                if(nIndex == -1)
                        return FALSE;
                SetAtIndex(nIndex, key, val);
                return TRUE;
        }
        TVal Lookup(TKey key) const
        {
                int nIndex = FindKey(key);
                if(nIndex == -1)
                        return NULL;    // must be able to convert
                return GetValueAt(nIndex);
        }
        TKey ReverseLookup(TVal val) const
        {
                int nIndex = FindVal(val);
                if(nIndex == -1)
                        return NULL;    // must be able to convert
                return GetKeyAt(nIndex);
        }
        TKey& GetKeyAt(int nIndex) const
        {
                ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
                return m_aKey[nIndex];
        }
        TVal& GetValueAt(int nIndex) const
        {
                ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
                return m_aVal[nIndex];
        }

// Implementation

        template <typename T>
        class Wrapper
        {
        public:
                Wrapper(T& _t) : t(_t)
                {
                }
                template <typename _Ty>
                void *operator new(size_t, _Ty* p)
                {
                        return p;
                }
                T t;
        };
        void SetAtIndex(int nIndex, TKey& key, TVal& val)
        {
                ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
                new(m_aKey + nIndex) Wrapper<TKey>(key);
                new(m_aVal + nIndex) Wrapper<TVal>(val);
        }
        int FindKey(TKey& key) const
        {
                for(int i = 0; i < m_nSize; i++)
                {
                        if(m_aKey[i] == key)
                                return i;
                }
                return -1;  // not found
        }
        int FindVal(TVal& val) const
        {
                for(int i = 0; i < m_nSize; i++)
                {
                        if(m_aVal[i] == val)
                                return i;
                }
                return -1;  // not found
        }
};


class CComModule;
__declspec(selectany) CComModule* _pModule=NULL;

// {B62F5910-6528-11d1-9611-0000F81E0D0D}
_declspec(selectany) GUID GUID_ATLVer30 = { 0xb62f5910, 0x6528, 0x11d1, { 0x96, 0x11, 0x0, 0x0, 0xf8, 0x1e, 0xd, 0xd } };

class CComModule : public _ATL_MODULE
{
// Operations
public:
        static GUID m_libid;
#ifdef _ATL_DEBUG_INTERFACES
        UINT m_nIndexQI;
        UINT m_nIndexBreakAt;
        CSimpleArray<_QIThunk*>* m_paThunks;
#endif // _ATL_DEBUG_INTERFACES

        void AddCreateWndData(_AtlCreateWndData* pData, void* pObject)
        {
                AtlModuleAddCreateWndData(this, pData, pObject);
        }
        void* ExtractCreateWndData()
        {
                return AtlModuleExtractCreateWndData(this);
        }

		LONG GetNextWindowID()
		{
			LONG nID;

			nID = InterlockedIncrement(&m_nNextWindowID);

			return nID;
		}

        HRESULT Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, const GUID* plibid = NULL)
        {
                pguidVer = &GUID_ATLVer30;
                _pModule = this;
                cbSize = sizeof(_ATL_MODULE);
                dwAtlBuildVer = _ATL_VER;
                AtlModuleInit(this, p, h);
                if (plibid != NULL)
                        memcpy((void*)&m_libid, plibid, sizeof(GUID));
				m_nNextWindowID = 1;
#ifdef _ATL_MIN_CRT
                // Create a base heap
                m_hHeap = HeapCreate(0, 0, 0);

#ifndef _ATL_NO_MP_HEAP
				SYSTEM_INFO si;
				GetSystemInfo(&si);
				if (si.dwNumberOfProcessors > 1) 
				{
                        DWORD dwHeaps = si.dwNumberOfProcessors * 2;
                        m_dwHeaps = 0xFFFFFFFF;
                        for (int bits = 0; bits < 32; bits++)
                        {
                                if (dwHeaps & 0x80000000)
                                        break;
                                dwHeaps <<= 1;
                                m_dwHeaps >>= 1;
                        }
                        m_dwHeaps >>= 1;

                        // Allocate more heaps for each processor
                        m_phHeaps = (HANDLE*) HeapAlloc(m_hHeap, _ATL_HEAPFLAGS, sizeof(HANDLE) * (m_dwHeaps + 1));
                        for (DWORD i = 0; i <= m_dwHeaps; i++)
                                m_phHeaps[i] = HeapCreate(0, 0, 0);
                }
                else
#endif
                {
                        m_phHeaps = NULL;
                        m_dwHeaps = 0;
                }
#endif
#ifdef _ATL_DEBUG_INTERFACES
                m_nIndexQI = 0;
                m_nIndexBreakAt = 0;
                m_paThunks = NULL;
                ATLTRY(m_paThunks = new CSimpleArray<_QIThunk*>);
                if (m_paThunks == NULL)
                        return E_OUTOFMEMORY;
#endif // _ATL_DEBUG_INTERFACES
                return S_OK;
        }
#ifdef _ATL_DEBUG_INTERFACES
        HRESULT AddThunk(IUnknown** pp, LPCTSTR lpsz, REFIID iid)
        {
                if ((pp == NULL) || (*pp == NULL))
                        return E_POINTER;
                IUnknown* p = *pp;
                _QIThunk* pThunk = NULL;
                EnterCriticalSection(&m_csObjMap);
                // Check if exists already for identity
                if (InlineIsEqualUnknown(iid))
                {
                        for (int i = 0; i < m_paThunks->GetSize(); i++)
                        {
                                if (m_paThunks->operator[](i)->pUnk == p)
                                {
                                        m_paThunks->operator[](i)->InternalAddRef();
                                        pThunk = m_paThunks->operator[](i);
                                        break;
                                }
                        }
                }
                if (pThunk == NULL)
                {
                        ++m_nIndexQI;
                        if (m_nIndexBreakAt == m_nIndexQI)
                                DebugBreak();
                        ATLTRY(pThunk = new _QIThunk(p, lpsz, iid, m_nIndexQI, (m_nIndexBreakAt == m_nIndexQI)));
                        if (pThunk == NULL)
                                return E_OUTOFMEMORY;
                        pThunk->InternalAddRef();
                        m_paThunks->Add(pThunk);
                }
                LeaveCriticalSection(&m_csObjMap);
                *pp = (IUnknown*)pThunk;
                return S_OK;
        }
        HRESULT AddNonAddRefThunk(IUnknown* p, LPCTSTR lpsz, IUnknown** ppThunkRet)
        {
                _QIThunk* pThunk = NULL;
                EnterCriticalSection(&m_csObjMap);
                // Check if exists already for identity
                for (int i = 0; i < m_paThunks->GetSize(); i++)
                {
                        if (m_paThunks->operator[](i)->pUnk == p)
                        {
                                m_paThunks->operator[](i)->bNonAddRefThunk = true;
                                pThunk = m_paThunks->operator[](i);
                                break;
                        }
                }
                if (pThunk == NULL)
                {
                        ++m_nIndexQI;
                        if (m_nIndexBreakAt == m_nIndexQI)
                                DebugBreak();
                        ATLTRY(pThunk = new _QIThunk(p, lpsz, IID_IUnknown, m_nIndexQI, (m_nIndexBreakAt == m_nIndexQI)));
                        if (pThunk == NULL)
                        {
                                *ppThunkRet = NULL;
                                return E_OUTOFMEMORY;
                        }
                        pThunk->bNonAddRefThunk = true;
                        m_paThunks->Add(pThunk);
                }
                LeaveCriticalSection(&m_csObjMap);
                *ppThunkRet = (IUnknown*)pThunk;
                return S_OK;;
        }
        void DeleteNonAddRefThunk(IUnknown* pUnk)
        {
                EnterCriticalSection(&m_csObjMap);
                for (int i = 0; i < m_paThunks->GetSize(); i++)
                {
                        if (m_paThunks->operator[](i)->pUnk == pUnk)
                        {
                                delete m_paThunks->operator[](i);
                                m_paThunks->RemoveAt(i);
                                break;
                        }
                }
                LeaveCriticalSection(&m_csObjMap);
        }
        void DeleteThunk(_QIThunk* p)
        {
                EnterCriticalSection(&m_csObjMap);
                int nIndex = m_paThunks->Find(p);
                if (nIndex != -1)
                {
                        delete m_paThunks->operator[](nIndex);
                        m_paThunks->RemoveAt(nIndex);
                }
                LeaveCriticalSection(&m_csObjMap);
        }
        bool DumpLeakedThunks()
        {
                bool b = false;
                for (int i = 0; i < m_paThunks->GetSize(); i++)
                {
                        b = true;
                        m_paThunks->operator[](i)->Dump();
                        delete m_paThunks->operator[](i);
                }
                m_paThunks->RemoveAll();
                return b;
        }
#endif // _ATL_DEBUG_INTERFACES
        void Term()
        {
#ifdef _ATL_DEBUG_INTERFACES
                m_bDestroyHeap = false; // prevent heap from going away
                AtlModuleTerm(this);
                DumpLeakedThunks();
                delete m_paThunks;
#ifndef _ATL_NO_MP_HEAP
                if (m_phHeaps != NULL)
                {
                        for (DWORD i = 0; i <= m_dwHeaps; i++)
                                HeapDestroy(m_phHeaps[i]);
                }
#endif
                if (m_hHeap != NULL)
                        HeapDestroy(m_hHeap);
#else
                AtlModuleTerm(this);
#endif // _ATL_DEBUG_INTERFACES
        }

        HRESULT AddTermFunc(_ATL_TERMFUNC* pFunc, DWORD_PTR dw)
        {
                return AtlModuleAddTermFunc(this, pFunc, dw);
        }

        LONG Lock()
        {
                return CComGlobalsThreadModel::Increment(&m_nLockCnt);
        }
        LONG Unlock()
        {
                return CComGlobalsThreadModel::Decrement(&m_nLockCnt);
        }
        LONG GetLockCount()
        {
                return m_nLockCnt;
        }

        HINSTANCE GetModuleInstance() {return m_hInst;}
        HINSTANCE GetResourceInstance() {return m_hInstResource;}
        HINSTANCE GetTypeLibInstance() {return m_hInstTypeLib;}

        // Registry support (helpers)
        HRESULT RegisterTypeLib()
        {
                return AtlModuleRegisterTypeLib(this, NULL);
        }
        HRESULT RegisterTypeLib(LPCTSTR lpszIndex)
        {
                USES_CONVERSION;
                return AtlModuleRegisterTypeLib(this, T2COLE(lpszIndex));
        }
        HRESULT UnRegisterTypeLib()
        {
                return AtlModuleUnRegisterTypeLib(this, NULL);
        }
        HRESULT UnRegisterTypeLib(LPCTSTR lpszIndex)
        {
                USES_CONVERSION;
                return AtlModuleUnRegisterTypeLib(this, T2COLE(lpszIndex));
        }
        HRESULT RegisterServer(BOOL bRegTypeLib = FALSE, const CLSID* pCLSID = NULL)
        {
                return AtlModuleRegisterServer(this, bRegTypeLib, pCLSID);
        }

        HRESULT UnregisterServer(const CLSID* pCLSID = NULL)
        {
                return AtlModuleUnregisterServer(this, pCLSID);
        }
        HRESULT UnregisterServer(BOOL bUnRegTypeLib, const CLSID* pCLSID = NULL)
        {
                return AtlModuleUnregisterServerEx(this, bUnRegTypeLib, pCLSID);
        }

        // Resource-based Registration
        HRESULT WINAPI UpdateRegistryFromResourceD(LPCTSTR lpszRes, BOOL bRegister,
                struct _ATL_REGMAP_ENTRY* pMapEntries = NULL)
        {
                USES_CONVERSION;
                return AtlModuleUpdateRegistryFromResourceD(this, T2COLE(lpszRes), bRegister,
                        pMapEntries);
        }
        HRESULT WINAPI UpdateRegistryFromResourceD(UINT nResID, BOOL bRegister,
                struct _ATL_REGMAP_ENTRY* pMapEntries = NULL)
        {
                return AtlModuleUpdateRegistryFromResourceD(this,
                        (LPCOLESTR)MAKEINTRESOURCE(nResID), bRegister, pMapEntries);
        }

#ifdef _ATL_STATIC_REGISTRY
        // Statically linking to Registry Ponent
        HRESULT WINAPI UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
                struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);
        HRESULT WINAPI UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
                struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);
#endif

        // Standard Registration
        HRESULT WINAPI UpdateRegistryClass(const CLSID& clsid, LPCTSTR lpszProgID,
                LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags, BOOL bRegister);
        HRESULT WINAPI RegisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
                LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags);
        HRESULT WINAPI UnregisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
                LPCTSTR lpszVerIndProgID);

        // Register/Revoke All Class Factories with the OS (EXE only)
        HRESULT RegisterClassObjects(DWORD dwClsContext, DWORD dwFlags)
        {
                return AtlModuleRegisterClassObjects(this, dwClsContext, dwFlags);
        }
        HRESULT RevokeClassObjects()
        {
                return AtlModuleRevokeClassObjects(this);
        }

        // Obtain a Class Factory (DLL only)
        HRESULT GetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
        {
                return AtlModuleGetClassObject(this, rclsid, riid, ppv);
        }

        // Only used in CComAutoThreadModule
        HRESULT CreateInstance(void* /*pfnCreateInstance*/, REFIID /*riid*/, void** /*ppvObj*/)
        {
                ATLASSERT(FALSE);
                return E_NOTIMPL;
        }
        static HRESULT RegisterProgID(LPCTSTR lpszCLSID, LPCTSTR lpszProgID, LPCTSTR lpszUserDesc);

        static void ReplaceSingleQuote(LPOLESTR lpDest, LPCOLESTR lp)
        {
                while (*lp)
                {
                        *lpDest++ = *lp;
                        if (*lp == OLESTR('\''))
                                *lpDest++ = *lp;
                        lp++;
                }
                *lpDest = NULL;
        }
};

#ifdef _ATL_DEBUG_INTERFACES
inline ULONG _QIThunk::Release()
{
	if (bBreak)
		DebugBreak();
	ATLASSERT(m_dwRef > 0);
	ULONG l = InterlockedDecrement(&m_dwRef);
	ATLTRACE(_T("%d< "), m_dwRef);
	AtlDumpIID(iid, lpszClassName, S_OK);
	pUnk->Release();
	if (l == 0 && !bNonAddRefThunk)
		_pModule->DeleteThunk(this);
	return l;
}

inline static void atlBadThunkCall()
{
        ATLASSERT(FALSE && "Call through deleted thunk");
}

#ifdef _M_IX86
#define IMPL_THUNK(n)\
__declspec(naked) inline HRESULT _QIThunk::f##n()\
{\
	__asm mov eax, [esp+4]\
	__asm cmp dword ptr [eax+8], 0\
	__asm jg goodref\
	__asm call atlBadThunkCall\
	__asm goodref:\
	__asm mov eax, [esp+4]\
	__asm mov eax, dword ptr [eax+4]\
	__asm mov [esp+4], eax\
	__asm mov eax, dword ptr [eax]\
	__asm mov eax, dword ptr [eax+4*n]\
	__asm jmp eax\
}

#else
#define IMPL_THUNK(x)
#endif

IMPL_THUNK(3)
IMPL_THUNK(4)
IMPL_THUNK(5)
IMPL_THUNK(6)
IMPL_THUNK(7)
IMPL_THUNK(8)
IMPL_THUNK(9)
IMPL_THUNK(10)
IMPL_THUNK(11)
IMPL_THUNK(12)
IMPL_THUNK(13)
IMPL_THUNK(14)
IMPL_THUNK(15)
IMPL_THUNK(16)
IMPL_THUNK(17)
IMPL_THUNK(18)
IMPL_THUNK(19)
IMPL_THUNK(20)
IMPL_THUNK(21)
IMPL_THUNK(22)
IMPL_THUNK(23)
IMPL_THUNK(24)
IMPL_THUNK(25)
IMPL_THUNK(26)
IMPL_THUNK(27)
IMPL_THUNK(28)
IMPL_THUNK(29)
IMPL_THUNK(30)
IMPL_THUNK(31)
IMPL_THUNK(32)
IMPL_THUNK(33)
IMPL_THUNK(34)
IMPL_THUNK(35)
IMPL_THUNK(36)
IMPL_THUNK(37)
IMPL_THUNK(38)
IMPL_THUNK(39)
IMPL_THUNK(40)
IMPL_THUNK(41)
IMPL_THUNK(42)
IMPL_THUNK(43)
IMPL_THUNK(44)
IMPL_THUNK(45)
IMPL_THUNK(46)
IMPL_THUNK(47)
IMPL_THUNK(48)
IMPL_THUNK(49)
IMPL_THUNK(50)
IMPL_THUNK(51)
IMPL_THUNK(52)
IMPL_THUNK(53)
IMPL_THUNK(54)
IMPL_THUNK(55)
IMPL_THUNK(56)
IMPL_THUNK(57)
IMPL_THUNK(58)
IMPL_THUNK(59)
IMPL_THUNK(60)
IMPL_THUNK(61)
IMPL_THUNK(62)
IMPL_THUNK(63)
IMPL_THUNK(64)
IMPL_THUNK(65)
IMPL_THUNK(66)
IMPL_THUNK(67)
IMPL_THUNK(68)
IMPL_THUNK(69)
IMPL_THUNK(70)
IMPL_THUNK(71)
IMPL_THUNK(72)
IMPL_THUNK(73)
IMPL_THUNK(74)
IMPL_THUNK(75)
IMPL_THUNK(76)
IMPL_THUNK(77)
IMPL_THUNK(78)
IMPL_THUNK(79)
IMPL_THUNK(80)
IMPL_THUNK(81)
IMPL_THUNK(82)
IMPL_THUNK(83)
IMPL_THUNK(84)
IMPL_THUNK(85)
IMPL_THUNK(86)
IMPL_THUNK(87)
IMPL_THUNK(88)
IMPL_THUNK(89)
IMPL_THUNK(90)
IMPL_THUNK(91)
IMPL_THUNK(92)
IMPL_THUNK(93)
IMPL_THUNK(94)
IMPL_THUNK(95)
IMPL_THUNK(96)
IMPL_THUNK(97)
IMPL_THUNK(98)
IMPL_THUNK(99)
IMPL_THUNK(100)
IMPL_THUNK(101)
IMPL_THUNK(102)
IMPL_THUNK(103)
IMPL_THUNK(104)
IMPL_THUNK(105)
IMPL_THUNK(106)
IMPL_THUNK(107)
IMPL_THUNK(108)
IMPL_THUNK(109)
IMPL_THUNK(110)
IMPL_THUNK(111)
IMPL_THUNK(112)
IMPL_THUNK(113)
IMPL_THUNK(114)
IMPL_THUNK(115)
IMPL_THUNK(116)
IMPL_THUNK(117)
IMPL_THUNK(118)
IMPL_THUNK(119)
IMPL_THUNK(120)
IMPL_THUNK(121)
IMPL_THUNK(122)
IMPL_THUNK(123)
IMPL_THUNK(124)
IMPL_THUNK(125)
IMPL_THUNK(126)
IMPL_THUNK(127)
IMPL_THUNK(128)
IMPL_THUNK(129)
IMPL_THUNK(130)
IMPL_THUNK(131)
IMPL_THUNK(132)
IMPL_THUNK(133)
IMPL_THUNK(134)
IMPL_THUNK(135)
IMPL_THUNK(136)
IMPL_THUNK(137)
IMPL_THUNK(138)
IMPL_THUNK(139)
IMPL_THUNK(140)
IMPL_THUNK(141)
IMPL_THUNK(142)
IMPL_THUNK(143)
IMPL_THUNK(144)
IMPL_THUNK(145)
IMPL_THUNK(146)
IMPL_THUNK(147)
IMPL_THUNK(148)
IMPL_THUNK(149)
IMPL_THUNK(150)
IMPL_THUNK(151)
IMPL_THUNK(152)
IMPL_THUNK(153)
IMPL_THUNK(154)
IMPL_THUNK(155)
IMPL_THUNK(156)
IMPL_THUNK(157)
IMPL_THUNK(158)
IMPL_THUNK(159)
IMPL_THUNK(160)
IMPL_THUNK(161)
IMPL_THUNK(162)
IMPL_THUNK(163)
IMPL_THUNK(164)
IMPL_THUNK(165)
IMPL_THUNK(166)
IMPL_THUNK(167)
IMPL_THUNK(168)
IMPL_THUNK(169)
IMPL_THUNK(170)
IMPL_THUNK(171)
IMPL_THUNK(172)
IMPL_THUNK(173)
IMPL_THUNK(174)
IMPL_THUNK(175)
IMPL_THUNK(176)
IMPL_THUNK(177)
IMPL_THUNK(178)
IMPL_THUNK(179)
IMPL_THUNK(180)
IMPL_THUNK(181)
IMPL_THUNK(182)
IMPL_THUNK(183)
IMPL_THUNK(184)
IMPL_THUNK(185)
IMPL_THUNK(186)
IMPL_THUNK(187)
IMPL_THUNK(188)
IMPL_THUNK(189)
IMPL_THUNK(190)
IMPL_THUNK(191)
IMPL_THUNK(192)
IMPL_THUNK(193)
IMPL_THUNK(194)
IMPL_THUNK(195)
IMPL_THUNK(196)
IMPL_THUNK(197)
IMPL_THUNK(198)
IMPL_THUNK(199)
IMPL_THUNK(200)
IMPL_THUNK(201)
IMPL_THUNK(202)
IMPL_THUNK(203)
IMPL_THUNK(204)
IMPL_THUNK(205)
IMPL_THUNK(206)
IMPL_THUNK(207)
IMPL_THUNK(208)
IMPL_THUNK(209)
IMPL_THUNK(210)
IMPL_THUNK(211)
IMPL_THUNK(212)
IMPL_THUNK(213)
IMPL_THUNK(214)
IMPL_THUNK(215)
IMPL_THUNK(216)
IMPL_THUNK(217)
IMPL_THUNK(218)
IMPL_THUNK(219)
IMPL_THUNK(220)
IMPL_THUNK(221)
IMPL_THUNK(222)
IMPL_THUNK(223)
IMPL_THUNK(224)
IMPL_THUNK(225)
IMPL_THUNK(226)
IMPL_THUNK(227)
IMPL_THUNK(228)
IMPL_THUNK(229)
IMPL_THUNK(230)
IMPL_THUNK(231)
IMPL_THUNK(232)
IMPL_THUNK(233)
IMPL_THUNK(234)
IMPL_THUNK(235)
IMPL_THUNK(236)
IMPL_THUNK(237)
IMPL_THUNK(238)
IMPL_THUNK(239)
IMPL_THUNK(240)
IMPL_THUNK(241)
IMPL_THUNK(242)
IMPL_THUNK(243)
IMPL_THUNK(244)
IMPL_THUNK(245)
IMPL_THUNK(246)
IMPL_THUNK(247)
IMPL_THUNK(248)
IMPL_THUNK(249)
IMPL_THUNK(250)
IMPL_THUNK(251)
IMPL_THUNK(252)
IMPL_THUNK(253)
IMPL_THUNK(254)
IMPL_THUNK(255)
IMPL_THUNK(256)
IMPL_THUNK(257)
IMPL_THUNK(258)
IMPL_THUNK(259)
IMPL_THUNK(260)
IMPL_THUNK(261)
IMPL_THUNK(262)
IMPL_THUNK(263)
IMPL_THUNK(264)
IMPL_THUNK(265)
IMPL_THUNK(266)
IMPL_THUNK(267)
IMPL_THUNK(268)
IMPL_THUNK(269)
IMPL_THUNK(270)
IMPL_THUNK(271)
IMPL_THUNK(272)
IMPL_THUNK(273)
IMPL_THUNK(274)
IMPL_THUNK(275)
IMPL_THUNK(276)
IMPL_THUNK(277)
IMPL_THUNK(278)
IMPL_THUNK(279)
IMPL_THUNK(280)
IMPL_THUNK(281)
IMPL_THUNK(282)
IMPL_THUNK(283)
IMPL_THUNK(284)
IMPL_THUNK(285)
IMPL_THUNK(286)
IMPL_THUNK(287)
IMPL_THUNK(288)
IMPL_THUNK(289)
IMPL_THUNK(290)
IMPL_THUNK(291)
IMPL_THUNK(292)
IMPL_THUNK(293)
IMPL_THUNK(294)
IMPL_THUNK(295)
IMPL_THUNK(296)
IMPL_THUNK(297)
IMPL_THUNK(298)
IMPL_THUNK(299)
IMPL_THUNK(300)
IMPL_THUNK(301)
IMPL_THUNK(302)
IMPL_THUNK(303)
IMPL_THUNK(304)
IMPL_THUNK(305)
IMPL_THUNK(306)
IMPL_THUNK(307)
IMPL_THUNK(308)
IMPL_THUNK(309)
IMPL_THUNK(310)
IMPL_THUNK(311)
IMPL_THUNK(312)
IMPL_THUNK(313)
IMPL_THUNK(314)
IMPL_THUNK(315)
IMPL_THUNK(316)
IMPL_THUNK(317)
IMPL_THUNK(318)
IMPL_THUNK(319)
IMPL_THUNK(320)
IMPL_THUNK(321)
IMPL_THUNK(322)
IMPL_THUNK(323)
IMPL_THUNK(324)
IMPL_THUNK(325)
IMPL_THUNK(326)
IMPL_THUNK(327)
IMPL_THUNK(328)
IMPL_THUNK(329)
IMPL_THUNK(330)
IMPL_THUNK(331)
IMPL_THUNK(332)
IMPL_THUNK(333)
IMPL_THUNK(334)
IMPL_THUNK(335)
IMPL_THUNK(336)
IMPL_THUNK(337)
IMPL_THUNK(338)
IMPL_THUNK(339)
IMPL_THUNK(340)
IMPL_THUNK(341)
IMPL_THUNK(342)
IMPL_THUNK(343)
IMPL_THUNK(344)
IMPL_THUNK(345)
IMPL_THUNK(346)
IMPL_THUNK(347)
IMPL_THUNK(348)
IMPL_THUNK(349)
IMPL_THUNK(350)
IMPL_THUNK(351)
IMPL_THUNK(352)
IMPL_THUNK(353)
IMPL_THUNK(354)
IMPL_THUNK(355)
IMPL_THUNK(356)
IMPL_THUNK(357)
IMPL_THUNK(358)
IMPL_THUNK(359)
IMPL_THUNK(360)
IMPL_THUNK(361)
IMPL_THUNK(362)
IMPL_THUNK(363)
IMPL_THUNK(364)
IMPL_THUNK(365)
IMPL_THUNK(366)
IMPL_THUNK(367)
IMPL_THUNK(368)
IMPL_THUNK(369)
IMPL_THUNK(370)
IMPL_THUNK(371)
IMPL_THUNK(372)
IMPL_THUNK(373)
IMPL_THUNK(374)
IMPL_THUNK(375)
IMPL_THUNK(376)
IMPL_THUNK(377)
IMPL_THUNK(378)
IMPL_THUNK(379)
IMPL_THUNK(380)
IMPL_THUNK(381)
IMPL_THUNK(382)
IMPL_THUNK(383)
IMPL_THUNK(384)
IMPL_THUNK(385)
IMPL_THUNK(386)
IMPL_THUNK(387)
IMPL_THUNK(388)
IMPL_THUNK(389)
IMPL_THUNK(390)
IMPL_THUNK(391)
IMPL_THUNK(392)
IMPL_THUNK(393)
IMPL_THUNK(394)
IMPL_THUNK(395)
IMPL_THUNK(396)
IMPL_THUNK(397)
IMPL_THUNK(398)
IMPL_THUNK(399)
IMPL_THUNK(400)
IMPL_THUNK(401)
IMPL_THUNK(402)
IMPL_THUNK(403)
IMPL_THUNK(404)
IMPL_THUNK(405)
IMPL_THUNK(406)
IMPL_THUNK(407)
IMPL_THUNK(408)
IMPL_THUNK(409)
IMPL_THUNK(410)
IMPL_THUNK(411)
IMPL_THUNK(412)
IMPL_THUNK(413)
IMPL_THUNK(414)
IMPL_THUNK(415)
IMPL_THUNK(416)
IMPL_THUNK(417)
IMPL_THUNK(418)
IMPL_THUNK(419)
IMPL_THUNK(420)
IMPL_THUNK(421)
IMPL_THUNK(422)
IMPL_THUNK(423)
IMPL_THUNK(424)
IMPL_THUNK(425)
IMPL_THUNK(426)
IMPL_THUNK(427)
IMPL_THUNK(428)
IMPL_THUNK(429)
IMPL_THUNK(430)
IMPL_THUNK(431)
IMPL_THUNK(432)
IMPL_THUNK(433)
IMPL_THUNK(434)
IMPL_THUNK(435)
IMPL_THUNK(436)
IMPL_THUNK(437)
IMPL_THUNK(438)
IMPL_THUNK(439)
IMPL_THUNK(440)
IMPL_THUNK(441)
IMPL_THUNK(442)
IMPL_THUNK(443)
IMPL_THUNK(444)
IMPL_THUNK(445)
IMPL_THUNK(446)
IMPL_THUNK(447)
IMPL_THUNK(448)
IMPL_THUNK(449)
IMPL_THUNK(450)
IMPL_THUNK(451)
IMPL_THUNK(452)
IMPL_THUNK(453)
IMPL_THUNK(454)
IMPL_THUNK(455)
IMPL_THUNK(456)
IMPL_THUNK(457)
IMPL_THUNK(458)
IMPL_THUNK(459)
IMPL_THUNK(460)
IMPL_THUNK(461)
IMPL_THUNK(462)
IMPL_THUNK(463)
IMPL_THUNK(464)
IMPL_THUNK(465)
IMPL_THUNK(466)
IMPL_THUNK(467)
IMPL_THUNK(468)
IMPL_THUNK(469)
IMPL_THUNK(470)
IMPL_THUNK(471)
IMPL_THUNK(472)
IMPL_THUNK(473)
IMPL_THUNK(474)
IMPL_THUNK(475)
IMPL_THUNK(476)
IMPL_THUNK(477)
IMPL_THUNK(478)
IMPL_THUNK(479)
IMPL_THUNK(480)
IMPL_THUNK(481)
IMPL_THUNK(482)
IMPL_THUNK(483)
IMPL_THUNK(484)
IMPL_THUNK(485)
IMPL_THUNK(486)
IMPL_THUNK(487)
IMPL_THUNK(488)
IMPL_THUNK(489)
IMPL_THUNK(490)
IMPL_THUNK(491)
IMPL_THUNK(492)
IMPL_THUNK(493)
IMPL_THUNK(494)
IMPL_THUNK(495)
IMPL_THUNK(496)
IMPL_THUNK(497)
IMPL_THUNK(498)
IMPL_THUNK(499)
IMPL_THUNK(500)
IMPL_THUNK(501)
IMPL_THUNK(502)
IMPL_THUNK(503)
IMPL_THUNK(504)
IMPL_THUNK(505)
IMPL_THUNK(506)
IMPL_THUNK(507)
IMPL_THUNK(508)
IMPL_THUNK(509)
IMPL_THUNK(510)
IMPL_THUNK(511)
IMPL_THUNK(512)
IMPL_THUNK(513)
IMPL_THUNK(514)
IMPL_THUNK(515)
IMPL_THUNK(516)
IMPL_THUNK(517)
IMPL_THUNK(518)
IMPL_THUNK(519)
IMPL_THUNK(520)
IMPL_THUNK(521)
IMPL_THUNK(522)
IMPL_THUNK(523)
IMPL_THUNK(524)
IMPL_THUNK(525)
IMPL_THUNK(526)
IMPL_THUNK(527)
IMPL_THUNK(528)
IMPL_THUNK(529)
IMPL_THUNK(530)
IMPL_THUNK(531)
IMPL_THUNK(532)
IMPL_THUNK(533)
IMPL_THUNK(534)
IMPL_THUNK(535)
IMPL_THUNK(536)
IMPL_THUNK(537)
IMPL_THUNK(538)
IMPL_THUNK(539)
IMPL_THUNK(540)
IMPL_THUNK(541)
IMPL_THUNK(542)
IMPL_THUNK(543)
IMPL_THUNK(544)
IMPL_THUNK(545)
IMPL_THUNK(546)
IMPL_THUNK(547)
IMPL_THUNK(548)
IMPL_THUNK(549)
IMPL_THUNK(550)
IMPL_THUNK(551)
IMPL_THUNK(552)
IMPL_THUNK(553)
IMPL_THUNK(554)
IMPL_THUNK(555)
IMPL_THUNK(556)
IMPL_THUNK(557)
IMPL_THUNK(558)
IMPL_THUNK(559)
IMPL_THUNK(560)
IMPL_THUNK(561)
IMPL_THUNK(562)
IMPL_THUNK(563)
IMPL_THUNK(564)
IMPL_THUNK(565)
IMPL_THUNK(566)
IMPL_THUNK(567)
IMPL_THUNK(568)
IMPL_THUNK(569)
IMPL_THUNK(570)
IMPL_THUNK(571)
IMPL_THUNK(572)
IMPL_THUNK(573)
IMPL_THUNK(574)
IMPL_THUNK(575)
IMPL_THUNK(576)
IMPL_THUNK(577)
IMPL_THUNK(578)
IMPL_THUNK(579)
IMPL_THUNK(580)
IMPL_THUNK(581)
IMPL_THUNK(582)
IMPL_THUNK(583)
IMPL_THUNK(584)
IMPL_THUNK(585)
IMPL_THUNK(586)
IMPL_THUNK(587)
IMPL_THUNK(588)
IMPL_THUNK(589)
IMPL_THUNK(590)
IMPL_THUNK(591)
IMPL_THUNK(592)
IMPL_THUNK(593)
IMPL_THUNK(594)
IMPL_THUNK(595)
IMPL_THUNK(596)
IMPL_THUNK(597)
IMPL_THUNK(598)
IMPL_THUNK(599)
IMPL_THUNK(600)
IMPL_THUNK(601)
IMPL_THUNK(602)
IMPL_THUNK(603)
IMPL_THUNK(604)
IMPL_THUNK(605)
IMPL_THUNK(606)
IMPL_THUNK(607)
IMPL_THUNK(608)
IMPL_THUNK(609)
IMPL_THUNK(610)
IMPL_THUNK(611)
IMPL_THUNK(612)
IMPL_THUNK(613)
IMPL_THUNK(614)
IMPL_THUNK(615)
IMPL_THUNK(616)
IMPL_THUNK(617)
IMPL_THUNK(618)
IMPL_THUNK(619)
IMPL_THUNK(620)
IMPL_THUNK(621)
IMPL_THUNK(622)
IMPL_THUNK(623)
IMPL_THUNK(624)
IMPL_THUNK(625)
IMPL_THUNK(626)
IMPL_THUNK(627)
IMPL_THUNK(628)
IMPL_THUNK(629)
IMPL_THUNK(630)
IMPL_THUNK(631)
IMPL_THUNK(632)
IMPL_THUNK(633)
IMPL_THUNK(634)
IMPL_THUNK(635)
IMPL_THUNK(636)
IMPL_THUNK(637)
IMPL_THUNK(638)
IMPL_THUNK(639)
IMPL_THUNK(640)
IMPL_THUNK(641)
IMPL_THUNK(642)
IMPL_THUNK(643)
IMPL_THUNK(644)
IMPL_THUNK(645)
IMPL_THUNK(646)
IMPL_THUNK(647)
IMPL_THUNK(648)
IMPL_THUNK(649)
IMPL_THUNK(650)
IMPL_THUNK(651)
IMPL_THUNK(652)
IMPL_THUNK(653)
IMPL_THUNK(654)
IMPL_THUNK(655)
IMPL_THUNK(656)
IMPL_THUNK(657)
IMPL_THUNK(658)
IMPL_THUNK(659)
IMPL_THUNK(660)
IMPL_THUNK(661)
IMPL_THUNK(662)
IMPL_THUNK(663)
IMPL_THUNK(664)
IMPL_THUNK(665)
IMPL_THUNK(666)
IMPL_THUNK(667)
IMPL_THUNK(668)
IMPL_THUNK(669)
IMPL_THUNK(670)
IMPL_THUNK(671)
IMPL_THUNK(672)
IMPL_THUNK(673)
IMPL_THUNK(674)
IMPL_THUNK(675)
IMPL_THUNK(676)
IMPL_THUNK(677)
IMPL_THUNK(678)
IMPL_THUNK(679)
IMPL_THUNK(680)
IMPL_THUNK(681)
IMPL_THUNK(682)
IMPL_THUNK(683)
IMPL_THUNK(684)
IMPL_THUNK(685)
IMPL_THUNK(686)
IMPL_THUNK(687)
IMPL_THUNK(688)
IMPL_THUNK(689)
IMPL_THUNK(690)
IMPL_THUNK(691)
IMPL_THUNK(692)
IMPL_THUNK(693)
IMPL_THUNK(694)
IMPL_THUNK(695)
IMPL_THUNK(696)
IMPL_THUNK(697)
IMPL_THUNK(698)
IMPL_THUNK(699)
IMPL_THUNK(700)
IMPL_THUNK(701)
IMPL_THUNK(702)
IMPL_THUNK(703)
IMPL_THUNK(704)
IMPL_THUNK(705)
IMPL_THUNK(706)
IMPL_THUNK(707)
IMPL_THUNK(708)
IMPL_THUNK(709)
IMPL_THUNK(710)
IMPL_THUNK(711)
IMPL_THUNK(712)
IMPL_THUNK(713)
IMPL_THUNK(714)
IMPL_THUNK(715)
IMPL_THUNK(716)
IMPL_THUNK(717)
IMPL_THUNK(718)
IMPL_THUNK(719)
IMPL_THUNK(720)
IMPL_THUNK(721)
IMPL_THUNK(722)
IMPL_THUNK(723)
IMPL_THUNK(724)
IMPL_THUNK(725)
IMPL_THUNK(726)
IMPL_THUNK(727)
IMPL_THUNK(728)
IMPL_THUNK(729)
IMPL_THUNK(730)
IMPL_THUNK(731)
IMPL_THUNK(732)
IMPL_THUNK(733)
IMPL_THUNK(734)
IMPL_THUNK(735)
IMPL_THUNK(736)
IMPL_THUNK(737)
IMPL_THUNK(738)
IMPL_THUNK(739)
IMPL_THUNK(740)
IMPL_THUNK(741)
IMPL_THUNK(742)
IMPL_THUNK(743)
IMPL_THUNK(744)
IMPL_THUNK(745)
IMPL_THUNK(746)
IMPL_THUNK(747)
IMPL_THUNK(748)
IMPL_THUNK(749)
IMPL_THUNK(750)
IMPL_THUNK(751)
IMPL_THUNK(752)
IMPL_THUNK(753)
IMPL_THUNK(754)
IMPL_THUNK(755)
IMPL_THUNK(756)
IMPL_THUNK(757)
IMPL_THUNK(758)
IMPL_THUNK(759)
IMPL_THUNK(760)
IMPL_THUNK(761)
IMPL_THUNK(762)
IMPL_THUNK(763)
IMPL_THUNK(764)
IMPL_THUNK(765)
IMPL_THUNK(766)
IMPL_THUNK(767)
IMPL_THUNK(768)
IMPL_THUNK(769)
IMPL_THUNK(770)
IMPL_THUNK(771)
IMPL_THUNK(772)
IMPL_THUNK(773)
IMPL_THUNK(774)
IMPL_THUNK(775)
IMPL_THUNK(776)
IMPL_THUNK(777)
IMPL_THUNK(778)
IMPL_THUNK(779)
IMPL_THUNK(780)
IMPL_THUNK(781)
IMPL_THUNK(782)
IMPL_THUNK(783)
IMPL_THUNK(784)
IMPL_THUNK(785)
IMPL_THUNK(786)
IMPL_THUNK(787)
IMPL_THUNK(788)
IMPL_THUNK(789)
IMPL_THUNK(790)
IMPL_THUNK(791)
IMPL_THUNK(792)
IMPL_THUNK(793)
IMPL_THUNK(794)
IMPL_THUNK(795)
IMPL_THUNK(796)
IMPL_THUNK(797)
IMPL_THUNK(798)
IMPL_THUNK(799)
IMPL_THUNK(800)
IMPL_THUNK(801)
IMPL_THUNK(802)
IMPL_THUNK(803)
IMPL_THUNK(804)
IMPL_THUNK(805)
IMPL_THUNK(806)
IMPL_THUNK(807)
IMPL_THUNK(808)
IMPL_THUNK(809)
IMPL_THUNK(810)
IMPL_THUNK(811)
IMPL_THUNK(812)
IMPL_THUNK(813)
IMPL_THUNK(814)
IMPL_THUNK(815)
IMPL_THUNK(816)
IMPL_THUNK(817)
IMPL_THUNK(818)
IMPL_THUNK(819)
IMPL_THUNK(820)
IMPL_THUNK(821)
IMPL_THUNK(822)
IMPL_THUNK(823)
IMPL_THUNK(824)
IMPL_THUNK(825)
IMPL_THUNK(826)
IMPL_THUNK(827)
IMPL_THUNK(828)
IMPL_THUNK(829)
IMPL_THUNK(830)
IMPL_THUNK(831)
IMPL_THUNK(832)
IMPL_THUNK(833)
IMPL_THUNK(834)
IMPL_THUNK(835)
IMPL_THUNK(836)
IMPL_THUNK(837)
IMPL_THUNK(838)
IMPL_THUNK(839)
IMPL_THUNK(840)
IMPL_THUNK(841)
IMPL_THUNK(842)
IMPL_THUNK(843)
IMPL_THUNK(844)
IMPL_THUNK(845)
IMPL_THUNK(846)
IMPL_THUNK(847)
IMPL_THUNK(848)
IMPL_THUNK(849)
IMPL_THUNK(850)
IMPL_THUNK(851)
IMPL_THUNK(852)
IMPL_THUNK(853)
IMPL_THUNK(854)
IMPL_THUNK(855)
IMPL_THUNK(856)
IMPL_THUNK(857)
IMPL_THUNK(858)
IMPL_THUNK(859)
IMPL_THUNK(860)
IMPL_THUNK(861)
IMPL_THUNK(862)
IMPL_THUNK(863)
IMPL_THUNK(864)
IMPL_THUNK(865)
IMPL_THUNK(866)
IMPL_THUNK(867)
IMPL_THUNK(868)
IMPL_THUNK(869)
IMPL_THUNK(870)
IMPL_THUNK(871)
IMPL_THUNK(872)
IMPL_THUNK(873)
IMPL_THUNK(874)
IMPL_THUNK(875)
IMPL_THUNK(876)
IMPL_THUNK(877)
IMPL_THUNK(878)
IMPL_THUNK(879)
IMPL_THUNK(880)
IMPL_THUNK(881)
IMPL_THUNK(882)
IMPL_THUNK(883)
IMPL_THUNK(884)
IMPL_THUNK(885)
IMPL_THUNK(886)
IMPL_THUNK(887)
IMPL_THUNK(888)
IMPL_THUNK(889)
IMPL_THUNK(890)
IMPL_THUNK(891)
IMPL_THUNK(892)
IMPL_THUNK(893)
IMPL_THUNK(894)
IMPL_THUNK(895)
IMPL_THUNK(896)
IMPL_THUNK(897)
IMPL_THUNK(898)
IMPL_THUNK(899)
IMPL_THUNK(900)
IMPL_THUNK(901)
IMPL_THUNK(902)
IMPL_THUNK(903)
IMPL_THUNK(904)
IMPL_THUNK(905)
IMPL_THUNK(906)
IMPL_THUNK(907)
IMPL_THUNK(908)
IMPL_THUNK(909)
IMPL_THUNK(910)
IMPL_THUNK(911)
IMPL_THUNK(912)
IMPL_THUNK(913)
IMPL_THUNK(914)
IMPL_THUNK(915)
IMPL_THUNK(916)
IMPL_THUNK(917)
IMPL_THUNK(918)
IMPL_THUNK(919)
IMPL_THUNK(920)
IMPL_THUNK(921)
IMPL_THUNK(922)
IMPL_THUNK(923)
IMPL_THUNK(924)
IMPL_THUNK(925)
IMPL_THUNK(926)
IMPL_THUNK(927)
IMPL_THUNK(928)
IMPL_THUNK(929)
IMPL_THUNK(930)
IMPL_THUNK(931)
IMPL_THUNK(932)
IMPL_THUNK(933)
IMPL_THUNK(934)
IMPL_THUNK(935)
IMPL_THUNK(936)
IMPL_THUNK(937)
IMPL_THUNK(938)
IMPL_THUNK(939)
IMPL_THUNK(940)
IMPL_THUNK(941)
IMPL_THUNK(942)
IMPL_THUNK(943)
IMPL_THUNK(944)
IMPL_THUNK(945)
IMPL_THUNK(946)
IMPL_THUNK(947)
IMPL_THUNK(948)
IMPL_THUNK(949)
IMPL_THUNK(950)
IMPL_THUNK(951)
IMPL_THUNK(952)
IMPL_THUNK(953)
IMPL_THUNK(954)
IMPL_THUNK(955)
IMPL_THUNK(956)
IMPL_THUNK(957)
IMPL_THUNK(958)
IMPL_THUNK(959)
IMPL_THUNK(960)
IMPL_THUNK(961)
IMPL_THUNK(962)
IMPL_THUNK(963)
IMPL_THUNK(964)
IMPL_THUNK(965)
IMPL_THUNK(966)
IMPL_THUNK(967)
IMPL_THUNK(968)
IMPL_THUNK(969)
IMPL_THUNK(970)
IMPL_THUNK(971)
IMPL_THUNK(972)
IMPL_THUNK(973)
IMPL_THUNK(974)
IMPL_THUNK(975)
IMPL_THUNK(976)
IMPL_THUNK(977)
IMPL_THUNK(978)
IMPL_THUNK(979)
IMPL_THUNK(980)
IMPL_THUNK(981)
IMPL_THUNK(982)
IMPL_THUNK(983)
IMPL_THUNK(984)
IMPL_THUNK(985)
IMPL_THUNK(986)
IMPL_THUNK(987)
IMPL_THUNK(988)
IMPL_THUNK(989)
IMPL_THUNK(990)
IMPL_THUNK(991)
IMPL_THUNK(992)
IMPL_THUNK(993)
IMPL_THUNK(994)
IMPL_THUNK(995)
IMPL_THUNK(996)
IMPL_THUNK(997)
IMPL_THUNK(998)
IMPL_THUNK(999)
IMPL_THUNK(1000)
IMPL_THUNK(1001)
IMPL_THUNK(1002)
IMPL_THUNK(1003)
IMPL_THUNK(1004)
IMPL_THUNK(1005)
IMPL_THUNK(1006)
IMPL_THUNK(1007)
IMPL_THUNK(1008)
IMPL_THUNK(1009)
IMPL_THUNK(1010)
IMPL_THUNK(1011)
IMPL_THUNK(1012)
IMPL_THUNK(1013)
IMPL_THUNK(1014)
IMPL_THUNK(1015)
IMPL_THUNK(1016)
IMPL_THUNK(1017)
IMPL_THUNK(1018)
IMPL_THUNK(1019)
IMPL_THUNK(1020)
IMPL_THUNK(1021)
IMPL_THUNK(1022)
IMPL_THUNK(1023)
IMPL_THUNK(1024)

#endif

__declspec(selectany) GUID CComModule::m_libid = {0x0,0x0,0x0,{0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0}};

#ifdef _ATL_STATIC_REGISTRY
#define UpdateRegistryFromResource UpdateRegistryFromResourceS
#else
#define UpdateRegistryFromResource UpdateRegistryFromResourceD
#endif

/////////////////////////////////////////////////////////////////////////////////////////////
// Thread Pooling classes

class _AtlAptCreateObjData
{
public:
        _ATL_CREATORFUNC* pfnCreateInstance;
        const IID* piid;
        HANDLE hEvent;
        LPSTREAM pStream;
        HRESULT hRes;
};

class CComApartment
{
public:
        CComApartment()
        {
                m_nLockCnt = 0;
        }
        static UINT ATL_CREATE_OBJECT;
        static DWORD WINAPI _Apartment(void* pv)
        {
                return ((CComApartment*)pv)->Apartment();
        }
        DWORD Apartment()
        {
                CoInitialize(NULL);
                MSG msg;
                while(GetMessage(&msg, 0, 0, 0))
                {
                        if (msg.message == ATL_CREATE_OBJECT)
                        {
                                _AtlAptCreateObjData* pdata = (_AtlAptCreateObjData*)msg.lParam;
                                IUnknown* pUnk = NULL;
                                pdata->hRes = pdata->pfnCreateInstance(NULL, IID_IUnknown, (void**)&pUnk);
                                if (SUCCEEDED(pdata->hRes))
                                        pdata->hRes = CoMarshalInterThreadInterfaceInStream(*pdata->piid, pUnk, &pdata->pStream);
                                if (SUCCEEDED(pdata->hRes))
                                {
                                        pUnk->Release();
                                        ATLTRACE2(atlTraceCOM, 2, _T("Object created on thread = %d\n"), GetCurrentThreadId());
                                }
                                SetEvent(pdata->hEvent);
                        }
                        DispatchMessage(&msg);
                }
                CoUninitialize();
                return 0;
        }
        LONG Lock() {return CComGlobalsThreadModel::Increment(&m_nLockCnt);}
        LONG Unlock(){return CComGlobalsThreadModel::Decrement(&m_nLockCnt);
        }
        LONG GetLockCount() {return m_nLockCnt;}

        DWORD m_dwThreadID;
        HANDLE m_hThread;
        LONG m_nLockCnt;
};

__declspec(selectany) UINT CComApartment::ATL_CREATE_OBJECT = 0;

class CComSimpleThreadAllocator
{
public:
        CComSimpleThreadAllocator()
        {
                m_nThread = 0;
        }
        int GetThread(CComApartment* /*pApt*/, int nThreads)
        {
                if (++m_nThread == nThreads)
                        m_nThread = 0;
                return m_nThread;
        }
        int m_nThread;
};

template <class ThreadAllocator = CComSimpleThreadAllocator>
class CComAutoThreadModule : public CComModule
{
public:
        HRESULT Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, const GUID* plibid = NULL, int nThreads = GetDefaultThreads());
        ~CComAutoThreadModule();
        HRESULT CreateInstance(void* pfnCreateInstance, REFIID riid, void** ppvObj);
        LONG Lock();
        LONG Unlock();
        DWORD dwThreadID;
        int m_nThreads;
        CComApartment* m_pApartments;
        ThreadAllocator m_Allocator;
        static int GetDefaultThreads()
        {
                SYSTEM_INFO si;
                GetSystemInfo(&si);
                return si.dwNumberOfProcessors * 4;
        }
};

/////////////////////////////////////////////////////////////////////////////
// CComBSTR

class CComBSTR
{
public:
        BSTR m_str;
        CComBSTR()
        {
                m_str = NULL;
        }
        /*explicit*/ CComBSTR(int nSize)
        {
                m_str = ::SysAllocStringLen(NULL, nSize);
        }
        /*explicit*/ CComBSTR(int nSize, LPCOLESTR sz)
        {
                m_str = ::SysAllocStringLen(sz, nSize);
        }
        /*explicit*/ CComBSTR(LPCOLESTR pSrc)
        {
                m_str = ::SysAllocString(pSrc);
        }
        /*explicit*/ CComBSTR(const CComBSTR& src)
        {
                m_str = src.Copy();
        }
        /*explicit*/ CComBSTR(const BSTR* psrc)
        {
            if (!psrc) {
                m_str = NULL;
            } else {
			    m_str = ::SysAllocStringByteLen(reinterpret_cast<LPCSTR>(*psrc), ::SysStringByteLen(*psrc));
            }
        }
        /*explicit*/ CComBSTR(REFGUID src)
        {
                LPOLESTR szGuid;
                StringFromCLSID(src, &szGuid);
                m_str = ::SysAllocString(szGuid);
                CoTaskMemFree(szGuid);
        }
        CComBSTR& operator=(const CComBSTR& src)
        {
                if (m_str != src.m_str)
                {
                        if (m_str)
                                ::SysFreeString(m_str);
                        m_str = src.Copy();
                }
                return *this;
        }
        CComBSTR& operator=(const BSTR* psrc)
        {
            if (!psrc) {
                if (m_str)
                        ::SysFreeString(m_str);
                m_str = NULL;
            } else if (*psrc != m_str) {
                if (m_str)
                        ::SysFreeString(m_str);
			    m_str = ::SysAllocStringByteLen(reinterpret_cast<LPCSTR>(*psrc), ::SysStringByteLen(*psrc));
            }
			return *this;
        }

        CComBSTR& operator=(LPCOLESTR pSrc)
        {
                ::SysFreeString(m_str);
                m_str = ::SysAllocString(pSrc);
                return *this;
        }

        ~CComBSTR()
        {
                ::SysFreeString(m_str);
        }
        unsigned int Length() const
        {
                return (m_str == NULL)? 0 : SysStringLen(m_str);
        }
        operator BSTR() const
        {
                return m_str;
        }
        BSTR* operator&()
        {
                return &m_str;
        }
        BSTR Copy() const
        {
                return ::SysAllocStringLen(m_str, ::SysStringLen(m_str));
        }
        HRESULT CopyTo(BSTR* pbstr)
        {
                // there should either be a runtime check or an assert(not both).  otherwise
                // we can't depend on the runtime check during unattended api tests and have to
                // place a redundant extra check outside the call to CopyTo to keep assert
                // dialogs from popping up
                // ATLASSERT(pbstr != NULL);
                if (pbstr == NULL)
                        return E_POINTER;
                *pbstr = ::SysAllocStringLen(m_str, ::SysStringLen(m_str));
                if (*pbstr == NULL)
                        return E_OUTOFMEMORY;
                return S_OK;
        }
        void Attach(BSTR src)
        {
                ATLASSERT(m_str == NULL);
                m_str = src;
        }
        BSTR Detach()
        {
                BSTR s = m_str;
                m_str = NULL;
                return s;
        }
        void Empty()
        {
                ::SysFreeString(m_str);
                m_str = NULL;
        }
        bool operator!() const
        {
                return (m_str == NULL);
        }
        HRESULT Append(const CComBSTR& bstrSrc)
        {
                return Append(bstrSrc.m_str, SysStringLen(bstrSrc.m_str));
        }
        HRESULT Append(LPCOLESTR lpsz)
        {
                return Append(lpsz, ocslen(lpsz));
        }
        // a BSTR is just a LPCOLESTR so we need a special version to signify
        // that we are appending a BSTR
        HRESULT AppendBSTR(BSTR p)
        {
                return Append(p, SysStringLen(p));
        }
        HRESULT Append(LPCOLESTR lpsz, int nLen)
        {
                int n1 = Length();
                BSTR b;
                b = ::SysAllocStringLen(NULL, n1+nLen);
                if (b == NULL)
                        return E_OUTOFMEMORY;
                memcpy(b, m_str, n1*sizeof(OLECHAR));
                memcpy(b+n1, lpsz, nLen*sizeof(OLECHAR));
                b[n1+nLen] = NULL;
                SysFreeString(m_str);
                m_str = b;
                return S_OK;
        }
        HRESULT ToLower()
        {
                USES_CONVERSION;
                if (m_str != NULL)
                {
                        LPTSTR psz = CharLower(OLE2T(m_str));
                        if (psz == NULL)
                                return E_OUTOFMEMORY;
                        BSTR b = T2BSTR(psz);
                        if (psz == NULL)
                                return E_OUTOFMEMORY;
                        SysFreeString(m_str);
                        m_str = b;
                }
                return S_OK;
        }
        HRESULT ToUpper()
        {
                USES_CONVERSION;
                if (m_str != NULL)
                {
                        LPTSTR psz = CharUpper(OLE2T(m_str));
                        if (psz == NULL)
                                return E_OUTOFMEMORY;
                        BSTR b = T2BSTR(psz);
                        if (psz == NULL)
                                return E_OUTOFMEMORY;
                        SysFreeString(m_str);
                        m_str = b;
                }
                return S_OK;
        }
        bool LoadString(HINSTANCE hInst, UINT nID)
        {
                USES_CONVERSION;
                TCHAR sz[512];
                UINT nLen = ::LoadString(hInst, nID, sz, 512);
                ATLASSERT(nLen < 511);
                SysFreeString(m_str);
                m_str = (nLen != 0) ? SysAllocString(T2OLE(sz)) : NULL;
                return (nLen != 0);
        }
        bool LoadString(UINT nID)
        {
                return LoadString(_pModule->m_hInstResource, nID);
        }

        CComBSTR& operator+=(const CComBSTR& bstrSrc)
        {
                AppendBSTR(bstrSrc.m_str);
                return *this;
        }
        bool operator<(BSTR bstrSrc) const
        {
                if (bstrSrc == NULL && m_str == NULL)
                        return false;
                if (bstrSrc != NULL && m_str != NULL)
                        return wcscmp(m_str, bstrSrc) < 0;
                return m_str == NULL;
        }
        bool operator==(BSTR bstrSrc) const
        {
                if (bstrSrc == NULL && m_str == NULL)
                        return true;
                if (bstrSrc != NULL && m_str != NULL)
                        return wcscmp(m_str, bstrSrc) == 0;
                return false;
        }
        bool operator<(LPCSTR pszSrc) const
        {
                if (pszSrc == NULL && m_str == NULL)
                        return false;
                USES_CONVERSION;
                if (pszSrc != NULL && m_str != NULL)
                        return wcscmp(m_str, A2W(pszSrc)) < 0;
                return m_str == NULL;
        }
        bool operator==(LPCSTR pszSrc) const
        {
                if (pszSrc == NULL && m_str == NULL)
                        return true;
                USES_CONVERSION;
                if (pszSrc != NULL && m_str != NULL)
                        return wcscmp(m_str, A2W(pszSrc)) == 0;
                return false;
        }
#ifndef OLE2ANSI
        CComBSTR(LPCSTR pSrc)
        {
                m_str = A2WBSTR(pSrc);
        }

        CComBSTR(int nSize, LPCSTR sz)
        {
                m_str = A2WBSTR(sz, nSize);
        }

        void Append(LPCSTR lpsz)
        {
                USES_CONVERSION;
                LPCOLESTR lpo = A2COLE(lpsz);
                Append(lpo, ocslen(lpo));
        }

        CComBSTR& operator=(LPCSTR pSrc)
        {
                ::SysFreeString(m_str);
                m_str = A2WBSTR(pSrc);
                return *this;
        }
#endif
        HRESULT WriteToStream(IStream* pStream)
        {
                ATLASSERT(pStream != NULL);
                ULONG cb;
                ULONG cbStrLen = m_str ? SysStringByteLen(m_str)+sizeof(OLECHAR) : 0;
                HRESULT hr = pStream->Write((void*) &cbStrLen, sizeof(cbStrLen), &cb);
                if (FAILED(hr))
                        return hr;
                return cbStrLen ? pStream->Write((void*) m_str, cbStrLen, &cb) : S_OK;
        }
        HRESULT ReadFromStream(IStream* pStream)
        {
                ATLASSERT(pStream != NULL);
                ATLASSERT(m_str == NULL); // should be empty
                ULONG cbStrLen = 0;
                HRESULT hr = pStream->Read((void*) &cbStrLen, sizeof(cbStrLen), NULL);
                if ((hr == S_OK) && (cbStrLen != 0))
                {
                        //subtract size for terminating NULL which we wrote out
                        //since SysAllocStringByteLen overallocates for the NULL
                        m_str = SysAllocStringByteLen(NULL, cbStrLen-sizeof(OLECHAR));
                        if (m_str == NULL)
                                hr = E_OUTOFMEMORY;
                        else
                                hr = pStream->Read((void*) m_str, cbStrLen, NULL);
                }
                if (hr == S_FALSE)
                        hr = E_FAIL;
                return hr;
        }
                // this allows direct use in stl containers
                // without using the CAdapt template which causes extra addrefs/releases
                //  usage:
                // std::vector<CComBSTR, CComBSTR::stl_allocator>
        CComBSTR * address(void) { return this; }
        const CComBSTR * const_address(void) const { return this; }
                typedef stl_smart_ptr_allocator<CComBSTR> stl_allocator;
};

/////////////////////////////////////////////////////////////////////////////
// CComVariant

class CComVariant : public tagVARIANT
{
// Constructors
public:
        CComVariant()
        {
            // ideally, we'd use ::VariantInit() here.  but, it doesn't do anything but
            // set the tag to VT_EMPTY.  we must zero out the struct, otherwise there
            // are cases where we set the tag to something non-empty in order to specify the
            // right type to read from a property bag and if there's an error we autodestruct
            // going out of scope and end up calling ::VariantClear with garbage which causes
            // random crashes
            memset(this, 0, sizeof(*this));  // safe since we're a pods
            vt = VT_EMPTY;
        }
        ~CComVariant()
        {
                Clear();
        }

        CComVariant(const VARIANT& varSrc)
        {
                vt = VT_EMPTY;
                InternalCopy(&varSrc);
        }

        CComVariant(const CComVariant& varSrc)
        {
                vt = VT_EMPTY;
                InternalCopy(&varSrc);
        }

        CComVariant(BSTR bstrSrc)
        {
                vt = VT_EMPTY;
                *this = bstrSrc;
        }
        CComVariant(LPCOLESTR lpszSrc)
        {
                vt = VT_EMPTY;
                *this = lpszSrc;
        }

#ifndef OLE2ANSI
        CComVariant(LPCSTR lpszSrc)
        {
                vt = VT_EMPTY;
                *this = lpszSrc;
        }
#endif

        CComVariant(bool bSrc)
        {
                vt = VT_BOOL;
#pragma warning(disable: 4310) // cast truncates constant value
                boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
        }

        CComVariant(int nSrc)
        {
                vt = VT_I4;
                lVal = nSrc;
        }
        CComVariant(BYTE nSrc)
        {
                vt = VT_UI1;
                bVal = nSrc;
        }
        CComVariant(short nSrc)
        {
                vt = VT_I2;
                iVal = nSrc;
        }
        CComVariant(long nSrc, VARTYPE vtSrc = VT_I4)
        {
                ATLASSERT(vtSrc == VT_I4 || vtSrc == VT_ERROR);
                vt = vtSrc;
                lVal = nSrc;
        }
        CComVariant(float fltSrc)
        {
                vt = VT_R4;
                fltVal = fltSrc;
        }
        CComVariant(double dblSrc)
        {
                vt = VT_R8;
                dblVal = dblSrc;
        }
        CComVariant(CY cySrc)
        {
                vt = VT_CY;
                cyVal.Hi = cySrc.Hi;
                cyVal.Lo = cySrc.Lo;
        }
        CComVariant(IDispatch* pSrc)
        {
                vt = VT_DISPATCH;
                pdispVal = pSrc;
                // Need to AddRef as VariantClear will Release
                if (pdispVal != NULL)
                        pdispVal->AddRef();
        }
        CComVariant(IUnknown* pSrc)
        {
                vt = VT_UNKNOWN;
                punkVal = pSrc;
                // Need to AddRef as VariantClear will Release
                if (punkVal != NULL)
                        punkVal->AddRef();
        }

        CComVariant(SHORT* pSrc)
        {
                vt = VT_I2 | VT_BYREF;
                piVal = pSrc;
        }

// Assignment Operators
public:
        CComVariant& operator=(const CComVariant& varSrc)
        {
                InternalCopy(&varSrc);
                return *this;
        }
        CComVariant& operator=(const VARIANT& varSrc)
        {
                InternalCopy(&varSrc);
                return *this;
        }

        CComVariant& operator=(BSTR bstrSrc)
        {
                InternalClear();
                vt = VT_BSTR;
                bstrVal = ::SysAllocString(bstrSrc);
                if (bstrVal == NULL && bstrSrc != NULL)
                {
                        vt = VT_ERROR;
                        scode = E_OUTOFMEMORY;
                }
                return *this;
        }

        CComVariant& operator=(LPCOLESTR lpszSrc)
        {
                InternalClear();
                vt = VT_BSTR;
                bstrVal = ::SysAllocString(lpszSrc);

                if (bstrVal == NULL && lpszSrc != NULL)
                {
                        vt = VT_ERROR;
                        scode = E_OUTOFMEMORY;
                }
                return *this;
        }

        #ifndef OLE2ANSI
        CComVariant& operator=(LPCSTR lpszSrc)
        {
                USES_CONVERSION;
                InternalClear();
                vt = VT_BSTR;
                bstrVal = ::SysAllocString(A2COLE(lpszSrc));

                if (bstrVal == NULL && lpszSrc != NULL)
                {
                        vt = VT_ERROR;
                        scode = E_OUTOFMEMORY;
                }
                return *this;
        }
        #endif

        CComVariant& operator=(bool bSrc)
        {
                if (vt != VT_BOOL)
                {
                        InternalClear();
                        vt = VT_BOOL;
                }
        #pragma warning(disable: 4310) // cast truncates constant value
                boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;
        #pragma warning(default: 4310) // cast truncates constant value
                return *this;
        }

        CComVariant& operator=(int nSrc)
        {
                if (vt != VT_I4)
                {
                        InternalClear();
                        vt = VT_I4;
                }
                lVal = nSrc;

                return *this;
        }

        CComVariant& operator=(BYTE nSrc)
        {
                if (vt != VT_UI1)
                {
                        InternalClear();
                        vt = VT_UI1;
                }
                bVal = nSrc;
                return *this;
        }

        CComVariant& operator=(short nSrc)
        {
                if (vt != VT_I2)
                {
                        InternalClear();
                        vt = VT_I2;
                }
                iVal = nSrc;
                return *this;
        }

        CComVariant& operator=(long nSrc)
        {
                if (vt != VT_I4)
                {
                        InternalClear();
                        vt = VT_I4;
                }
                lVal = nSrc;
                return *this;
        }

        CComVariant& operator=(float fltSrc)
        {
                if (vt != VT_R4)
                {
                        InternalClear();
                        vt = VT_R4;
                }
                fltVal = fltSrc;
                return *this;
        }

        CComVariant& operator=(double dblSrc)
        {
                if (vt != VT_R8)
                {
                        InternalClear();
                        vt = VT_R8;
                }
                dblVal = dblSrc;
                return *this;
        }

        CComVariant& operator=(CY cySrc)
        {
                if (vt != VT_CY)
                {
                        InternalClear();
                        vt = VT_CY;
                }
                cyVal.Hi = cySrc.Hi;
                cyVal.Lo = cySrc.Lo;
                return *this;
        }

        CComVariant& operator=(IDispatch* pSrc)
        {
                InternalClear();
                vt = VT_DISPATCH;
                pdispVal = pSrc;
                // Need to AddRef as VariantClear will Release
                if (pdispVal != NULL)
                        pdispVal->AddRef();
                return *this;
        }

        CComVariant& operator=(IUnknown* pSrc)
        {
                InternalClear();
                vt = VT_UNKNOWN;
                punkVal = pSrc;

                // Need to AddRef as VariantClear will Release
                if (punkVal != NULL)
                        punkVal->AddRef();
                return *this;
        }

        CComVariant& operator=(SHORT* pSrc)
        {
                vt = VT_I2 | VT_BYREF;
                piVal = pSrc;
				return *this;
        }

// Comparison Operators
public:
        bool operator==(const VARIANT& varSrc) const
        {
                if (this == &varSrc)
                        return true;

                // Variants not equal if types don't match
                if (vt != varSrc.vt)
                        return false;

                // Check type specific values
                switch (vt)
                {
                        case VT_EMPTY:
                        case VT_NULL:
                                return true;

                        case VT_BOOL:
                                return boolVal == varSrc.boolVal;

                        case VT_UI1:
                                return bVal == varSrc.bVal;

                        case VT_I2:
                                return iVal == varSrc.iVal;

                        case VT_I4:
                                return lVal == varSrc.lVal;

                        case VT_R4:
                                return fltVal == varSrc.fltVal;

                        case VT_R8:
                                return dblVal == varSrc.dblVal;

                        case VT_BSTR:
                                return (::SysStringByteLen(bstrVal) == ::SysStringByteLen(varSrc.bstrVal)) &&
                                                (::memcmp(bstrVal, varSrc.bstrVal, ::SysStringByteLen(bstrVal)) == 0);

                        case VT_ERROR:
                                return scode == varSrc.scode;

                        case VT_DISPATCH:
                                return pdispVal == varSrc.pdispVal;

                        case VT_UNKNOWN:
                                return punkVal == varSrc.punkVal;

                        default:
                                ATLASSERT(false);
                                // fall through
                }

                return false;
        }
        bool operator!=(const VARIANT& varSrc) const {return !operator==(varSrc);}
        bool operator<(const VARIANT& varSrc) const {return VarCmp((VARIANT*)this, (VARIANT*)&varSrc, LOCALE_USER_DEFAULT, 0)==VARCMP_LT;}
        bool operator>(const VARIANT& varSrc) const {return VarCmp((VARIANT*)this, (VARIANT*)&varSrc, LOCALE_USER_DEFAULT, 0)==VARCMP_GT;}
        bool operator!() const {
            switch (vt)
            {
                case VT_EMPTY:
                case VT_NULL:
                    return true;
                case VT_BOOL:
                    return !boolVal;
                case VT_UI1:
                    return !bVal;
                case VT_I2:
                    return !iVal;
                case VT_I4:
                    return !lVal;
                case VT_R4:
                    return !fltVal;
                case VT_R8:
                    return !dblVal;
                case VT_BSTR:
                    return (bstrVal ? !::SysStringByteLen(bstrVal) : true);
                case VT_ERROR:
                    return scode != S_OK;
                case VT_DISPATCH:
                    return !pdispVal;
                case VT_UNKNOWN:
                    return !punkVal;
                default:
                    ATLASSERT(false);
                    // fall through
                    return true;
            }
        }

// Operations
public:
        HRESULT Clear() { return ::VariantClear(this); }
        HRESULT Copy(const VARIANT* pSrc) { return ::VariantCopy(this, const_cast<VARIANT*>(pSrc)); }
        HRESULT CopyTo(VARIANT* pDest) { return ::VariantCopy(pDest, this); }
        HRESULT Attach(VARIANT* pSrc)
        {
                // Clear out the variant
                HRESULT hr = Clear();
                if (!FAILED(hr))
                {
                        // Copy the contents and give control to CComVariant
                        memcpy(this, pSrc, sizeof(VARIANT));
                        pSrc->vt = VT_EMPTY;
                        hr = S_OK;
                }
                return hr;
        }

        HRESULT Detach(VARIANT* pDest)
        {
                // Clear out the variant
                HRESULT hr = ::VariantClear(pDest);
                if (!FAILED(hr))
                {
                        // Copy the contents and remove control from CComVariant
                        memcpy(pDest, this, sizeof(VARIANT));
                        vt = VT_EMPTY;
                        hr = S_OK;
                }
                return hr;
        }

        HRESULT ChangeType(VARTYPE vtNew, const VARIANT* pSrc = NULL)
        {
                VARIANT* pVar = const_cast<VARIANT*>(pSrc);
                // Convert in place if pSrc is NULL
                if (pVar == NULL)
                        pVar = this;
                // Do nothing if doing in place convert and vts not different
                return ::VariantChangeType(this, pVar, 0, vtNew);
        }

        HRESULT WriteToStream(IStream* pStream);
        HRESULT ReadFromStream(IStream* pStream);

// Implementation
public:
        HRESULT InternalClear()
        {
                HRESULT hr = Clear();
                ATLASSERT(SUCCEEDED(hr));
                if (FAILED(hr))
                {
                        vt = VT_ERROR;
                        scode = hr;
                }
                return hr;
        }

        void InternalCopy(const VARIANT* pSrc)
        {
                HRESULT hr = Copy(pSrc);
                if (FAILED(hr))
                {
                        vt = VT_ERROR;
                        scode = hr;
                }
        }

                // this allows direct use in stl containers
                // without using the CAdapt template which causes extra addrefs/releases
                //  usage:
                // std::vector<CComVariant, CComVariant::stl_allocator>
        CComVariant * address(void) { return this; }
        const CComVariant * const_address(void) const { return this; }
                typedef stl_smart_ptr_allocator<CComVariant> stl_allocator;

};

inline HRESULT CComVariant::WriteToStream(IStream* pStream)
{
        HRESULT hr = pStream->Write(&vt, sizeof(VARTYPE), NULL);
        if (FAILED(hr))
                return hr;

        int cbWrite = 0;
        switch (vt)
        {
        case VT_UNKNOWN:
        case VT_DISPATCH:
                {
                        CComPtr<IPersistStream> spStream;
                        if (punkVal != NULL)
                        {
                                hr = punkVal->QueryInterface(IID_IPersistStream, (void**)&spStream);
                                if (FAILED(hr))
                                        return hr;
                        }
                        if (spStream != NULL)
                                return OleSaveToStream(spStream, pStream);
                        else
                                return WriteClassStm(pStream, CLSID_NULL);
                }
        case VT_UI1:
        case VT_I1:
                cbWrite = sizeof(BYTE);
                break;
        case VT_I2:
        case VT_UI2:
        case VT_BOOL:
                cbWrite = sizeof(short);
                break;
        case VT_I4:
        case VT_UI4:
        case VT_R4:
        case VT_INT:
        case VT_UINT:
        case VT_ERROR:
                cbWrite = sizeof(long);
                break;
        case VT_R8:
        case VT_CY:
        case VT_DATE:
                cbWrite = sizeof(double);
                break;
        default:
                break;
        }
        if (cbWrite != 0)
                return pStream->Write((void*) &bVal, cbWrite, NULL);

        CComBSTR bstrWrite;
        CComVariant varBSTR;
        if (vt != VT_BSTR)
        {
                hr = VariantChangeType(&varBSTR, this, VARIANT_NOVALUEPROP, VT_BSTR);
                if (FAILED(hr))
                        return hr;
                bstrWrite = varBSTR.bstrVal;
        }
        else
                bstrWrite = bstrVal;

        return bstrWrite.WriteToStream(pStream);
}

inline HRESULT CComVariant::ReadFromStream(IStream* pStream)
{
        ATLASSERT(pStream != NULL);
        HRESULT hr;
        hr = VariantClear(this);
        if (FAILED(hr))
                return hr;
        VARTYPE vtRead;
        hr = pStream->Read(&vtRead, sizeof(VARTYPE), NULL);
        if (hr == S_FALSE)
                hr = E_FAIL;
        if (FAILED(hr))
                return hr;

        vt = vtRead;
        int cbRead = 0;
        switch (vtRead)
        {
        case VT_UNKNOWN:
        case VT_DISPATCH:
                {
                        punkVal = NULL;
                        hr = OleLoadFromStream(pStream,
                                (vtRead == VT_UNKNOWN) ? IID_IUnknown : IID_IDispatch,
                                (void**)&punkVal);
                        if (hr == REGDB_E_CLASSNOTREG)
                                hr = S_OK;
                        return S_OK;
                }
        case VT_UI1:
        case VT_I1:
                cbRead = sizeof(BYTE);
                break;
        case VT_I2:
        case VT_UI2:
        case VT_BOOL:
                cbRead = sizeof(short);
                break;
        case VT_I4:
        case VT_UI4:
        case VT_R4:
        case VT_INT:
        case VT_UINT:
        case VT_ERROR:
                cbRead = sizeof(long);
                break;
        case VT_R8:
        case VT_CY:
        case VT_DATE:
                cbRead = sizeof(double);
                break;
        default:
                break;
        }
        if (cbRead != 0)
        {
                hr = pStream->Read((void*) &bVal, cbRead, NULL);
                if (hr == S_FALSE)
                        hr = E_FAIL;
                return hr;
        }
        CComBSTR bstrRead;

        hr = bstrRead.ReadFromStream(pStream);
        if (FAILED(hr))
                return hr;
        vt = VT_BSTR;
        bstrVal = bstrRead.Detach();
        if (vtRead != VT_BSTR)
                hr = ChangeType(vtRead);
        return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CRegKey

class CRegKey
{
public:
        CRegKey();
        ~CRegKey();

// Attributes
public:
        operator HKEY() const;
        HKEY m_hKey;

// Operations
public:
        LONG SetValue(DWORD dwValue, LPCTSTR lpszValueName);
        LONG QueryValue(DWORD& dwValue, LPCTSTR lpszValueName);
        LONG QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount);
        LONG SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

        LONG SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);
        static LONG WINAPI SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName,
                LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

        LONG Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
                LPTSTR lpszClass = REG_NONE, DWORD dwOptions = REG_OPTION_NON_VOLATILE,
                REGSAM samDesired = KEY_ALL_ACCESS,
                LPSECURITY_ATTRIBUTES lpSecAttr = NULL,
                LPDWORD lpdwDisposition = NULL);
        LONG Open(HKEY hKeyParent, LPCTSTR lpszKeyName,
                REGSAM samDesired = KEY_ALL_ACCESS, DWORD ulOptions = 0);
        LONG Close();
        HKEY Detach();
        void Attach(HKEY hKey);
        LONG DeleteSubKey(LPCTSTR lpszSubKey);
        LONG RecurseDeleteKey(LPCTSTR lpszKey);
        LONG DeleteValue(LPCTSTR lpszValue);
};

inline CRegKey::CRegKey()
{m_hKey = NULL;}

inline CRegKey::~CRegKey()
{Close();}

inline CRegKey::operator HKEY() const
{return m_hKey;}

inline HKEY CRegKey::Detach()
{
        HKEY hKey = m_hKey;
        m_hKey = NULL;
        return hKey;
}

inline void CRegKey::Attach(HKEY hKey)
{
        ATLASSERT(m_hKey == NULL);
        m_hKey = hKey;
}

inline LONG CRegKey::DeleteSubKey(LPCTSTR lpszSubKey)
{
        ATLASSERT(m_hKey != NULL);
        return RegDeleteKey(m_hKey, lpszSubKey);
}

inline LONG CRegKey::DeleteValue(LPCTSTR lpszValue)
{
        ATLASSERT(m_hKey != NULL);
        return RegDeleteValue(m_hKey, (LPTSTR)lpszValue);
}

inline LONG CRegKey::Close()
{
        LONG lRes = ERROR_SUCCESS;
        if (m_hKey != NULL)
        {
                lRes = RegCloseKey(m_hKey);
                m_hKey = NULL;
        }
        return lRes;
}

inline LONG CRegKey::Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
        LPTSTR lpszClass, DWORD dwOptions, REGSAM samDesired,
        LPSECURITY_ATTRIBUTES lpSecAttr, LPDWORD lpdwDisposition)
{
        ATLASSERT(hKeyParent != NULL);
        DWORD dw;
        HKEY hKey = NULL;
        LONG lRes = RegCreateKeyEx(hKeyParent, lpszKeyName, 0,
                lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
        if (lpdwDisposition != NULL)
                *lpdwDisposition = dw;
        if (lRes == ERROR_SUCCESS)
        {
                lRes = Close();
                m_hKey = hKey;
        }
        return lRes;
}

inline LONG CRegKey::Open(HKEY hKeyParent, LPCTSTR lpszKeyName, REGSAM samDesired, DWORD ulOptions)
{
        ATLASSERT(hKeyParent != NULL);
        HKEY hKey = NULL;
        LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyName, ulOptions, samDesired, &hKey);
        if (lRes == ERROR_SUCCESS)
        {
                lRes = Close();
                ATLASSERT(lRes == ERROR_SUCCESS);
                m_hKey = hKey;
        }
        return lRes;
}

inline LONG CRegKey::QueryValue(DWORD& dwValue, LPCTSTR lpszValueName)
{
        DWORD dwType = NULL;
        DWORD dwCount = sizeof(DWORD);
        LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
                (LPBYTE)&dwValue, &dwCount);
        ATLASSERT((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
        ATLASSERT((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD)));
        return lRes;
}

inline LONG CRegKey::QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount)
{
        ATLASSERT(pdwCount != NULL);
        DWORD dwType = NULL;
        LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
                (LPBYTE)szValue, pdwCount);
        ATLASSERT((lRes!=ERROR_SUCCESS) || (dwType == REG_SZ) ||
                         (dwType == REG_MULTI_SZ) || (dwType == REG_EXPAND_SZ));
        return lRes;
}

inline LONG WINAPI CRegKey::SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
        ATLASSERT(lpszValue != NULL);
        CRegKey key;
        LONG lRes = key.Create(hKeyParent, lpszKeyName);
        if (lRes == ERROR_SUCCESS)
                lRes = key.SetValue(lpszValue, lpszValueName);
        return lRes;
}

inline LONG CRegKey::SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
        ATLASSERT(lpszValue != NULL);
        CRegKey key;
        LONG lRes = key.Create(m_hKey, lpszKeyName);
        if (lRes == ERROR_SUCCESS)
                lRes = key.SetValue(lpszValue, lpszValueName);
        return lRes;
}

inline LONG CRegKey::SetValue(DWORD dwValue, LPCTSTR lpszValueName)
{
        ATLASSERT(m_hKey != NULL);
        return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_DWORD,
                (BYTE * const)&dwValue, sizeof(DWORD));
}

inline LONG CRegKey::SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
        ATLASSERT(lpszValue != NULL);
        ATLASSERT(m_hKey != NULL);
        return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_SZ,
                (BYTE * const)lpszValue, (lstrlen(lpszValue)+1)*sizeof(TCHAR));
}

inline LONG CRegKey::RecurseDeleteKey(LPCTSTR lpszKey)
{
        CRegKey key;
        LONG lRes = key.Open(m_hKey, lpszKey, KEY_READ | KEY_WRITE);
        if (lRes != ERROR_SUCCESS)
                return lRes;
        FILETIME time;
        DWORD dwSize = 256;
        TCHAR szBuffer[256];
        while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
                &time)==ERROR_SUCCESS)
        {
                lRes = key.RecurseDeleteKey(szBuffer);
                if (lRes != ERROR_SUCCESS)
                        return lRes;
                dwSize = 256;
        }
        key.Close();
        return DeleteSubKey(lpszKey);
}

inline HRESULT CComModule::RegisterProgID(LPCTSTR lpszCLSID, LPCTSTR lpszProgID, LPCTSTR lpszUserDesc)
{
        CRegKey keyProgID;
        LONG lRes = keyProgID.Create(HKEY_CLASSES_ROOT, lpszProgID, REG_NONE, REG_OPTION_NON_VOLATILE,  KEY_SET_VALUE);
        if (lRes == ERROR_SUCCESS)
        {
                keyProgID.SetValue(lpszUserDesc);
                keyProgID.SetKeyValue(_T("CLSID"), lpszCLSID);
                return S_OK;
        }
        return HRESULT_FROM_WIN32(lRes);
}

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>

// Statically linking to Registry Ponent
inline HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
        struct _ATL_REGMAP_ENTRY* pMapEntries)
{
        USES_CONVERSION;
        ATL::CRegObject ro;
        TCHAR szModule[_MAX_PATH];
        GetModuleFileName(_pModule->GetModuleInstance(), szModule, _MAX_PATH);

		LPOLESTR pszModule;
		if ((m_hInst == NULL) || (m_hInst == GetModuleHandle(NULL))) // register as EXE
		{
			// Convert to short path to work around bug in NT4's CreateProcess
			TCHAR szModuleShort[_MAX_PATH];
			int cbShortName = GetShortPathName(szModule, szModuleShort, _MAX_PATH);

			if (cbShortName == _MAX_PATH)
				return E_OUTOFMEMORY;

			pszModule = (cbShortName == 0 || cbShortName == ERROR_INVALID_PARAMETER) ? T2OLE(szModule) : T2OLE(szModuleShort);
		}
		else
			pszModule = T2OLE(szModule);

        int nLen = ocslen(pszModule);
        LPOLESTR pszModuleQuote = (LPOLESTR)alloca((nLen*2+1)*sizeof(OLECHAR));
        ReplaceSingleQuote(pszModuleQuote, pszModule);
        ro.AddReplacement(OLESTR("Module"), pszModuleQuote);
        if (NULL != pMapEntries)
        {
                while (NULL != pMapEntries->szKey)
                {
                        ATLASSERT(NULL != pMapEntries->szData);
                        ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);
                        pMapEntries++;
                }
        }

        LPCOLESTR szType = OLESTR("REGISTRY");
        return (bRegister) ? ro.ResourceRegister(pszModule, nResID, szType) :
                        ro.ResourceUnregister(pszModule, nResID, szType);
}

inline HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
        struct _ATL_REGMAP_ENTRY* pMapEntries)
{
        USES_CONVERSION;
        ATL::CRegObject ro;
        TCHAR szModule[_MAX_PATH];
        GetModuleFileName(_pModule->GetModuleInstance(), szModule, _MAX_PATH);

		LPOLESTR pszModule;
		if ((m_hInst == NULL) || (m_hInst == GetModuleHandle(NULL))) // register as EXE
		{
			// Convert to short path to work around bug in NT4's CreateProcess
			TCHAR szModuleShort[_MAX_PATH];
			int cbShortName = GetShortPathName(szModule, szModuleShort, _MAX_PATH);

			if (cbShortName == _MAX_PATH)
				return E_OUTOFMEMORY;

			pszModule = (cbShortName == 0 || cbShortName == ERROR_INVALID_PARAMETER) ? T2OLE(szModule) : T2OLE(szModuleShort);
		}
		else
			pszModule = T2OLE(szModule);

        int nLen = ocslen(pszModule);
        LPOLESTR pszModuleQuote = (LPOLESTR)alloca((nLen*2+1)*sizeof(OLECHAR));
        ReplaceSingleQuote(pszModuleQuote, pszModule);
        ro.AddReplacement(OLESTR("Module"), pszModuleQuote);
        if (NULL != pMapEntries)
        {
                while (NULL != pMapEntries->szKey)
                {
                        ATLASSERT(NULL != pMapEntries->szData);
                        ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);
                        pMapEntries++;
                }
        }

        LPCOLESTR szType = OLESTR("REGISTRY");
        LPCOLESTR pszRes = T2COLE(lpszRes);
        return (bRegister) ? ro.ResourceRegisterSz(pszModule, pszRes, szType) :
                        ro.ResourceUnregisterSz(pszModule, pszRes, szType);
}
#endif //_ATL_STATIC_REGISTRY

inline HRESULT WINAPI CComModule::UpdateRegistryClass(const CLSID& clsid, LPCTSTR lpszProgID,
        LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags, BOOL bRegister)
{
        if (bRegister)
        {
                return RegisterClassHelper(clsid, lpszProgID, lpszVerIndProgID, nDescID,
                        dwFlags);
        }
        else
                return UnregisterClassHelper(clsid, lpszProgID, lpszVerIndProgID);
}

inline HRESULT WINAPI CComModule::RegisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
        LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags)
{
        static const TCHAR szProgID[] = _T("ProgID");
        static const TCHAR szVIProgID[] = _T("VersionIndependentProgID");
        static const TCHAR szLS32[] = _T("LocalServer32");
        static const TCHAR szIPS32[] = _T("InprocServer32");
        static const TCHAR szThreadingModel[] = _T("ThreadingModel");
        static const TCHAR szAUTPRX32[] = _T("AUTPRX32.DLL");
        static const TCHAR szApartment[] = _T("Apartment");
        static const TCHAR szBoth[] = _T("both");
        USES_CONVERSION;
        HRESULT hRes = S_OK;
        TCHAR szDesc[256];
        LoadString(m_hInst, nDescID, szDesc, 256);
        TCHAR szModule[_MAX_PATH];
        GetModuleFileName(m_hInst, szModule, _MAX_PATH);

        LPOLESTR lpOleStr;
        StringFromCLSID(clsid, &lpOleStr);
        LPTSTR lpsz = OLE2T(lpOleStr);

        hRes = RegisterProgID(lpsz, lpszProgID, szDesc);
        if (hRes == S_OK)
                hRes = RegisterProgID(lpsz, lpszVerIndProgID, szDesc);
        LONG lRes = ERROR_SUCCESS;
        if (hRes == S_OK)
        {
			CRegKey key;
			lRes = key.Open(HKEY_CLASSES_ROOT, _T("CLSID"), KEY_READ | KEY_WRITE);
			if (lRes == ERROR_SUCCESS)
			{
				lRes = key.Create(key, lpsz, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE);
				if (lRes == ERROR_SUCCESS)
				{
					key.SetValue(szDesc);
					key.SetKeyValue(szProgID, lpszProgID);
					key.SetKeyValue(szVIProgID, lpszVerIndProgID);

					if ((m_hInst == NULL) || (m_hInst == GetModuleHandle(NULL))) // register as EXE
					{
						// Convert to short path to work around bug in NT4's CreateProcess
						TCHAR szModuleShort[_MAX_PATH];
						int cbShortName = GetShortPathName(szModule, szModuleShort, _MAX_PATH);
						TCHAR* pszModule;

						if (cbShortName == _MAX_PATH)
							return E_OUTOFMEMORY;

						pszModule = (cbShortName == 0 || cbShortName == ERROR_INVALID_PARAMETER) ? szModule : szModuleShort;

						key.SetKeyValue(szLS32, pszModule);
					}
					else
					{
						key.SetKeyValue(szIPS32, (dwFlags & AUTPRXFLAG) ? szAUTPRX32 : szModule);
						LPCTSTR lpszModel = (dwFlags & THREADFLAGS_BOTH) ? szBoth :
							(dwFlags & THREADFLAGS_APARTMENT) ? szApartment : NULL;
						if (lpszModel != NULL)
							key.SetKeyValue(szIPS32, lpszModel, szThreadingModel);
					}
				}
			}
        }
        CoTaskMemFree(lpOleStr);
        if (lRes != ERROR_SUCCESS)
                hRes = HRESULT_FROM_WIN32(lRes);
        return hRes;
}

inline HRESULT WINAPI CComModule::UnregisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
        LPCTSTR lpszVerIndProgID)
{
        USES_CONVERSION;
        CRegKey key;

        key.Attach(HKEY_CLASSES_ROOT);
        if (lpszProgID != NULL && lstrcmpi(lpszProgID, _T("")))
                key.RecurseDeleteKey(lpszProgID);
        if (lpszVerIndProgID != NULL && lstrcmpi(lpszVerIndProgID, _T("")))
                key.RecurseDeleteKey(lpszVerIndProgID);
        LPOLESTR lpOleStr;
        StringFromCLSID(clsid, &lpOleStr);
        LPTSTR lpsz = OLE2T(lpOleStr);
		if (key.Open(key, _T("CLSID"), KEY_READ | KEY_WRITE) == ERROR_SUCCESS)
                key.RecurseDeleteKey(lpsz);
        CoTaskMemFree(lpOleStr);
        return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Large Block Allocation Helper - CVBufHelper & CVirtualBuffer


template <class T>
class CVBufHelper
{
public:
        virtual T* operator()(T* pCurrent) {return pCurrent;}
};

template <class T>
class CVirtualBuffer
{
protected:
        CVirtualBuffer() {}
        T* m_pBase;
        T* m_pCurrent;
        T* m_pTop;
        int m_nMaxElements;
public:
        CVirtualBuffer(int nMaxElements)
        {
                m_nMaxElements = nMaxElements;
                m_pBase = (T*) VirtualAlloc(NULL, sizeof(T) * nMaxElements,
                        MEM_RESERVE, PAGE_READWRITE);
                m_pTop = m_pCurrent = m_pBase;
                // Commit first page - chances are this is all that will be used
                VirtualAlloc(m_pBase, sizeof(T), MEM_COMMIT, PAGE_READWRITE);
        }
        ~CVirtualBuffer()
        {
                VirtualFree(m_pBase, 0, MEM_RELEASE);
        }
        int Except(LPEXCEPTION_POINTERS lpEP)
        {
                EXCEPTION_RECORD* pExcept = lpEP->ExceptionRecord;
                if (pExcept->ExceptionCode != EXCEPTION_ACCESS_VIOLATION)
                        return EXCEPTION_CONTINUE_SEARCH;
                BYTE* pAddress = (LPBYTE) pExcept->ExceptionInformation[1];
				VirtualAlloc(pAddress, ((BYTE*)m_pTop - (BYTE*)m_pBase), MEM_COMMIT, PAGE_READWRITE);
                return EXCEPTION_CONTINUE_EXECUTION;
        }
        void Seek(int nElement)
        {
                m_pCurrent = &m_pBase[nElement];
        }
        void SetAt(int nElement, const T& Element)
        {
                __try
                {
                        T* p = &m_pBase[nElement]
                        *p = Element;
                        m_pTop = p > m_pTop ? p : m_pTop;
                }
                __except(Except(GetExceptionInformation()))
                {
                }

        }
        template <class Q>
        void WriteBulk(Q& helper)
        {
                __try
                {
                        m_pCurrent = helper(m_pBase);
                        m_pTop = m_pCurrent > m_pTop ? m_pCurrent : m_pTop;
                }
                __except(Except(GetExceptionInformation()))
                {
                }
        }
        void Write(const T& Element)
        {
                __try
                {
                        *m_pCurrent = Element;
                        m_pCurrent++;
                        m_pTop = m_pCurrent > m_pTop ? m_pCurrent : m_pTop;
                }
                __except(Except(GetExceptionInformation()))
                {
                }
        }
        T& Read()
        {
                return *m_pCurrent;
        }
        operator BSTR()
        {
                BSTR bstrTemp;
                __try
                {
                        bstrTemp = SysAllocStringByteLen((char*) m_pBase,
                                (UINT) ((BYTE*)m_pTop - (BYTE*)m_pBase));
                }
                __except(Except(GetExceptionInformation()))
                {
                }
                return bstrTemp;
        }
        const T& operator[](int nElement) const
        {
                return m_pBase[nElement];
        }
        operator T*()
        {
                return m_pBase;
        }
};

typedef CVirtualBuffer<BYTE> CVirtualBytes;


inline HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr)
{
        if (atlTraceQI & ATL_TRACE_CATEGORY)
        {
                USES_CONVERSION;
                CRegKey key;
                TCHAR szName[100];
                DWORD dwType,dw = sizeof(szName);

                LPOLESTR pszGUID = NULL;
                StringFromCLSID(iid, &pszGUID);
                OutputDebugString(pszClassName);
                OutputDebugString(_T(" - "));

                // Attempt to find it in the interfaces section
                key.Open(HKEY_CLASSES_ROOT, _T("Interface"), KEY_READ);
                if (key.Open(key, OLE2T(pszGUID), KEY_READ) == S_OK)
                {
                        *szName = 0;
                        RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw);
                        OutputDebugString(szName);
                        goto cleanup;
                }
                // Attempt to find it in the clsid section
                key.Open(HKEY_CLASSES_ROOT, _T("CLSID"), KEY_READ);
                if (key.Open(key, OLE2T(pszGUID), KEY_READ) == S_OK)
                {
                        *szName = 0;
                        RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw);
                        OutputDebugString(_T("(CLSID\?\?\?) "));
                        OutputDebugString(szName);
                        goto cleanup;
                }
                OutputDebugString(OLE2T(pszGUID));
        cleanup:
                if (hr != S_OK)
                        OutputDebugString(_T(" - failed"));
                OutputDebugString(_T("\n"));
                CoTaskMemFree(pszGUID);
        }
        return hr;
}

#pragma pack(pop)

// WM_FORWARDMSG - used to forward a message to another window for processing
// WPARAM - DWORD dwUserData - defined by user
// LPARAM - LPMSG pMsg - a pointer to the MSG structure
// return value - 0 if the message was not processed, nonzero if it was
#define WM_FORWARDMSG       0x037F

}; //namespace ATL
using namespace ATL;

//only pull in definition if static linking
#ifndef _ATL_DLL_IMPL
#ifndef _ATL_DLL
#define _ATLBASE_IMPL
#endif
#endif

#ifdef _ATL_REDEF_NEW
#pragma pop_macro("new")
#undef _ATL_REDEF_NEW
#endif

#endif // __ATLBASE_H__

//All exports go here
#ifdef _ATLBASE_IMPL

#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif

/////////////////////////////////////////////////////////////////////////////
// statics

static UINT WINAPI AtlGetDirLen(LPCOLESTR lpszPathName)
{
        ATLASSERT(lpszPathName != NULL);

        // always capture the complete file name including extension (if present)
        LPCOLESTR lpszTemp = lpszPathName;
        for (LPCOLESTR lpsz = lpszPathName; *lpsz != NULL; )
        {
                LPCOLESTR lp = CharNextO(lpsz);
                // remember last directory/drive separator
                if (*lpsz == OLESTR('\\') || *lpsz == OLESTR('/') || *lpsz == OLESTR(':'))
                        lpszTemp = lp;
                lpsz = lp;
        }

		return UINT(lpszTemp-lpszPathName);
}

/////////////////////////////////////////////////////////////////////////////
// QI support

ATLINLINE ATLAPI AtlInternalQueryInterface(void* pThis,
        const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject)
{
        ATLASSERT(pThis != NULL);
        // First entry in the com map should be a simple map entry
        ATLASSERT(pEntries->pFunc == _ATL_SIMPLEMAPENTRY);
        if (ppvObject == NULL)
                return E_POINTER;
        *ppvObject = NULL;
        if (InlineIsEqualUnknown(iid)) // use first interface
        {
						IUnknown* pUnk = (IUnknown*)((DWORD_PTR)pThis+pEntries->dw);
                        pUnk->AddRef();
                        *ppvObject = pUnk;
                        return S_OK;
        }
        while (pEntries->pFunc != NULL)
        {
                BOOL bBlind = (pEntries->piid == NULL);
                if (bBlind || InlineIsEqualGUID(*(pEntries->piid), iid))
                {
                        if (pEntries->pFunc == _ATL_SIMPLEMAPENTRY) //offset
                        {
                                ATLASSERT(!bBlind);
								IUnknown* pUnk = (IUnknown*)((DWORD_PTR)pThis+pEntries->dw);
                                pUnk->AddRef();
                                *ppvObject = pUnk;
                                return S_OK;
                        }
                        else //actual function call
                        {
                                HRESULT hRes = pEntries->pFunc(pThis,
                                        iid, ppvObject, pEntries->dw);
                                if (hRes == S_OK || (!bBlind && FAILED(hRes)))
                                        return hRes;
                        }
                }
                pEntries++;
        }
        return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

ATLINLINE ATLAPI_(IUnknown*) AtlComPtrAssign(IUnknown** pp, IUnknown* lp)
{
        if (lp != NULL)
                lp->AddRef();
        if (*pp)
                (*pp)->Release();
        *pp = lp;
        return lp;
}

ATLINLINE ATLAPI_(IUnknown*) AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid)
{
        IUnknown* pTemp = *pp;
        *pp = NULL;
        if (lp != NULL)
                lp->QueryInterface(riid, (void**)pp);
        if (pTemp)
                pTemp->Release();
        return *pp;
}

/////////////////////////////////////////////////////////////////////////////
// Inproc Marshaling helpers

//This API should be called from the same thread that called
//AtlMarshalPtrInProc
ATLINLINE ATLAPI AtlFreeMarshalStream(IStream* pStream)
{
        if (pStream != NULL)
        {
                LARGE_INTEGER l;
                l.QuadPart = 0;
                pStream->Seek(l, STREAM_SEEK_SET, NULL);
                CoReleaseMarshalData(pStream);
                pStream->Release();
        }
        return S_OK;
}

ATLINLINE ATLAPI AtlMarshalPtrInProc(IUnknown* pUnk, const IID& iid, IStream** ppStream)
{
        HRESULT hRes = CreateStreamOnHGlobal(NULL, TRUE, ppStream);
        if (SUCCEEDED(hRes))
        {
                hRes = CoMarshalInterface(*ppStream, iid,
                        pUnk, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLESTRONG);
                if (FAILED(hRes))
                {
                        (*ppStream)->Release();
                        *ppStream = NULL;
                }
        }
        return hRes;
}

ATLINLINE ATLAPI AtlUnmarshalPtr(IStream* pStream, const IID& iid, IUnknown** ppUnk)
{
        *ppUnk = NULL;
        HRESULT hRes = E_INVALIDARG;
        if (pStream != NULL)
        {
                LARGE_INTEGER l;
                l.QuadPart = 0;
                pStream->Seek(l, STREAM_SEEK_SET, NULL);
                hRes = CoUnmarshalInterface(pStream, iid, (void**)ppUnk);
        }
        return hRes;
}

ATLINLINE ATLAPI_(BOOL) AtlWaitWithMessageLoop(HANDLE hEvent)
{
        DWORD dwRet;
        MSG msg;

        while(1)
        {
                dwRet = MsgWaitForMultipleObjects(1, &hEvent, FALSE, INFINITE, QS_ALLINPUT);

                if (dwRet == WAIT_OBJECT_0)
                        return TRUE;    // The event was signaled

                if (dwRet != WAIT_OBJECT_0 + 1)
                        break;          // Something else happened

                // There is one or more window message available. Dispatch them
                while(PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
                {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                        if (WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
                                return TRUE; // Event is now signaled.
                }
        }
        return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

ATLINLINE ATLAPI AtlAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw)
{
        CComPtr<IConnectionPointContainer> pCPC;
        CComPtr<IConnectionPoint> pCP;
        HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
        if (SUCCEEDED(hRes))
                hRes = pCPC->FindConnectionPoint(iid, &pCP);
        if (SUCCEEDED(hRes))
                hRes = pCP->Advise(pUnk, pdw);
        return hRes;
}

ATLINLINE ATLAPI AtlUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw)
{
        CComPtr<IConnectionPointContainer> pCPC;
        CComPtr<IConnectionPoint> pCP;
        HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
        if (SUCCEEDED(hRes))
                hRes = pCPC->FindConnectionPoint(iid, &pCP);
        if (SUCCEEDED(hRes))
                hRes = pCP->Unadvise(dw);
        return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

ATLINLINE ATLAPI AtlSetErrorInfo(const CLSID& clsid, LPCOLESTR lpszDesc, DWORD dwHelpID,
        LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes, HINSTANCE hInst)
{
        USES_CONVERSION;
        TCHAR szDesc[1024];
        szDesc[0] = NULL;
        // For a valid HRESULT the id should be in the range [0x0200, 0xffff]
		if (IS_INTRESOURCE(lpszDesc)) //id
        {
				UINT nID = LOWORD((DWORD_PTR)lpszDesc);
                ATLASSERT((nID >= 0x0200 && nID <= 0xffff) || hRes != 0);
                if (LoadString(hInst, nID, szDesc, 1024) == 0)
                {
                    ATLASSERT(FALSE);
                    lstrcpy(szDesc, _T("Unknown Error"));
                    
           
                }
                lpszDesc = T2OLE(szDesc);
                if (hRes == 0)
                        hRes = MAKE_HRESULT(3, FACILITY_ITF, nID);
        }

        CComPtr<ICreateErrorInfo> pICEI;
        if (SUCCEEDED(CreateErrorInfo(&pICEI)))
        {
                CComPtr<IErrorInfo> pErrorInfo;
                pICEI->SetGUID(iid);
                LPOLESTR lpsz;
                ProgIDFromCLSID(clsid, &lpsz);
                if (lpsz != NULL)
                        pICEI->SetSource(lpsz);
                if (dwHelpID != 0 && lpszHelpFile != NULL)
                {
                        pICEI->SetHelpContext(dwHelpID);
                        pICEI->SetHelpFile(const_cast<LPOLESTR>(lpszHelpFile));
                }
                CoTaskMemFree(lpsz);
                pICEI->SetDescription((LPOLESTR)lpszDesc);
                if (SUCCEEDED(pICEI->QueryInterface(IID_IErrorInfo, (void**)&pErrorInfo)))
                        SetErrorInfo(0, pErrorInfo);
        }
        return (hRes == 0) ? DISP_E_EXCEPTION : hRes;
}

ATLINLINE ATLAPI AtlSetErrorInfo(const CLSID& clsid, HRESULT hr, const IID& iid, HRESULT hRes, HINSTANCE hInst, va_list *Arguments)
{
    // Mostly the same as the default AtlSetErrorInfo but this one loads strings from the module and allows arguments 
    // Arguments argument also allows for no ambiguity
        USES_CONVERSION;
        TCHAR szDesc[1024];
        szDesc[0] = NULL;
        // Attempt to load string from system
        if (LoadString(hInst, hr, szDesc, 1024) == 0){
            // If it is a no go try to load from the module
			if(FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, hInst, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR) szDesc, 1023, Arguments) == 0){
				ATLASSERT(FALSE);
				lstrcpy(szDesc, _T("Unknown Error"));
            }
        }
        LPCOLESTR lpszDesc = T2OLE(szDesc);
        if (hRes == 0){
            hRes = hr;
        }

        CComPtr<ICreateErrorInfo> pICEI;
        if (SUCCEEDED(CreateErrorInfo(&pICEI)))
        {
                CComPtr<IErrorInfo> pErrorInfo;
                pICEI->SetGUID(iid);
                LPOLESTR lpsz;
                ProgIDFromCLSID(clsid, &lpsz);
                if (lpsz != NULL)
                        pICEI->SetSource(lpsz);
                CoTaskMemFree(lpsz);
                pICEI->SetDescription((LPOLESTR)lpszDesc);
                if (SUCCEEDED(pICEI->QueryInterface(IID_IErrorInfo, (void**)&pErrorInfo)))
                        SetErrorInfo(0, pErrorInfo);
        }
        return (hRes == 0) ? DISP_E_EXCEPTION : hRes;
}
/////////////////////////////////////////////////////////////////////////////
// Module

struct _ATL_MODULE20
{
// Attributes
public:
        UINT cbSize;
        HINSTANCE m_hInst;
        HINSTANCE m_hInstResource;
        HINSTANCE m_hInstTypeLib;
        _ATL_OBJMAP_ENTRY* m_pObjMap;
        LONG m_nLockCnt;
        HANDLE m_hHeap;
        CRITICAL_SECTION m_csTypeInfoHolder;
        CRITICAL_SECTION m_csWindowCreate;
        CRITICAL_SECTION m_csObjMap;
};

typedef _ATL_MODULE _ATL_MODULE30;

struct _ATL_OBJMAP_ENTRY20
{
        const CLSID* pclsid;
        HRESULT (WINAPI *pfnUpdateRegistry)(BOOL bRegister);
        _ATL_CREATORFUNC* pfnGetClassObject;
        _ATL_CREATORFUNC* pfnCreateInstance;
        IUnknown* pCF;
        DWORD dwRegister;
        _ATL_DESCRIPTIONFUNC* pfnGetObjectDescription;
};

typedef _ATL_OBJMAP_ENTRY _ATL_OBJMAP_ENTRY30;

inline _ATL_OBJMAP_ENTRY* _NextObjectMapEntry(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* pEntry)
{
        if (pM->cbSize == sizeof(_ATL_MODULE20))
                return (_ATL_OBJMAP_ENTRY*)(((BYTE*)pEntry) + sizeof(_ATL_OBJMAP_ENTRY20));
        return pEntry+1;
}

//Although these functions are big, they are only used once in a module
//so we should make them inline.

ATLINLINE ATLAPI AtlModuleInit(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* p, HINSTANCE h)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
#ifdef _ATL_DLL_IMPL
	if ((pM->cbSize != _nAtlModuleVer21Size) && (pM->cbSize != _nAtlModuleVer30Size) &&
		(pM->cbSize != sizeof(_ATL_MODULE)))
		return E_INVALIDARG;
#else
        ATLASSERT(pM->cbSize == sizeof(_ATL_MODULE));
#endif
        pM->m_pObjMap = p;
        pM->m_hInst = pM->m_hInstTypeLib = pM->m_hInstResource = h;
        pM->m_nLockCnt=0L;
        pM->m_hHeap = NULL;
        InitializeCriticalSection(&pM->m_csTypeInfoHolder);
        InitializeCriticalSection(&pM->m_csWindowCreate);
        InitializeCriticalSection(&pM->m_csObjMap);
#ifdef _ATL_DLL_IMPL
	if (pM->cbSize > _nAtlModuleVer21Size)
#endif
        {
            pM->m_pCreateWndList = NULL;
            pM->m_bDestroyHeap = true;
            pM->m_dwHeaps = 0;
            pM->m_nHeap = 0;
            pM->m_phHeaps = NULL;
            pM->m_pTermFuncs = NULL;
            if (pM->m_pObjMap != NULL)
            {
                    _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
                    while (pEntry->pclsid != NULL)
                    {
                            pEntry->pfnObjectMain(true); //initialize class resources
                            pEntry = _NextObjectMapEntry(pM, pEntry);
                    }
            }
        }

#ifdef _ATL_DLL_IMPL
	if (pM->cbSize > _nAtlModuleVer30Size)
#endif
	{
		pM->m_nNextWindowID = 1;
	}

        return S_OK;
}

ATLINLINE ATLAPI AtlModuleRegisterClassObjects(_ATL_MODULE* pM, DWORD dwClsContext, DWORD dwFlags)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
        ATLASSERT(pM->m_pObjMap != NULL);
        _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
        HRESULT hRes = S_OK;
        while (pEntry->pclsid != NULL && hRes == S_OK)
        {
                hRes = pEntry->RegisterClassObject(dwClsContext, dwFlags);
                pEntry = _NextObjectMapEntry(pM, pEntry);
        }
        return hRes;
}

ATLINLINE ATLAPI AtlModuleRevokeClassObjects(_ATL_MODULE* pM)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
        ATLASSERT(pM->m_pObjMap != NULL);
        _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
        HRESULT hRes = S_OK;
        while (pEntry->pclsid != NULL && hRes == S_OK)
        {
                hRes = pEntry->RevokeClassObject();
                pEntry = _NextObjectMapEntry(pM, pEntry);
        }
        return hRes;
}

ATLINLINE ATLAPI AtlModuleGetClassObject(_ATL_MODULE* pM, REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
        ATLASSERT(pM->m_pObjMap != NULL);
        _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
        HRESULT hRes = S_OK;
        if (ppv == NULL)
                return E_POINTER;
        *ppv = NULL;
        while (pEntry->pclsid != NULL)
        {
                if ((pEntry->pfnGetClassObject != NULL) && InlineIsEqualGUID(rclsid, *pEntry->pclsid))
                {
                        if (pEntry->pCF == NULL)
                        {
                                EnterCriticalSection(&pM->m_csObjMap);
                                if (pEntry->pCF == NULL)
                                        hRes = pEntry->pfnGetClassObject(pEntry->pfnCreateInstance, IID_IUnknown, (LPVOID*)&pEntry->pCF);
                                LeaveCriticalSection(&pM->m_csObjMap);
                        }
                        if (pEntry->pCF != NULL)
                                hRes = pEntry->pCF->QueryInterface(riid, ppv);
                        break;
                }
                pEntry = _NextObjectMapEntry(pM, pEntry);
        }
        if (*ppv == NULL && hRes == S_OK)
                hRes = CLASS_E_CLASSNOTAVAILABLE;
        return hRes;
}

ATLINLINE ATLAPI AtlModuleTerm(_ATL_MODULE* pM)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
        ATLASSERT(pM->m_hInst != NULL);
        if (pM->m_pObjMap != NULL)
        {
                _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
                while (pEntry->pclsid != NULL)
                {
                        if (pEntry->pCF != NULL)
                                pEntry->pCF->Release();
                        pEntry->pCF = NULL;
#ifdef _ATL_DLL_IMPL
					if (pM->cbSize > _nAtlModuleVer21Size)
#endif
                                pEntry->pfnObjectMain(false); //cleanup class resources
                        pEntry = _NextObjectMapEntry(pM, pEntry);
                }
        }
        DeleteCriticalSection(&pM->m_csTypeInfoHolder);
        DeleteCriticalSection(&pM->m_csWindowCreate);
        DeleteCriticalSection(&pM->m_csObjMap);

#ifdef _ATL_DLL_IMPL
		if (pM->cbSize > _nAtlModuleVer21Size)
#endif
        {
                _ATL_TERMFUNC_ELEM* pElem = pM->m_pTermFuncs;
                _ATL_TERMFUNC_ELEM* pNext = NULL;
                while (pElem != NULL)
                {
                        pElem->pFunc(pElem->dw);
                        pNext = pElem->pNext;
                        delete pElem;
                        pElem = pNext;
                }
                if (pM->m_hHeap != NULL && pM->m_bDestroyHeap)
                {
#ifndef _ATL_NO_MP_HEAP
                        if (pM->m_phHeaps != NULL)
                        {
                                for (DWORD i = 0; i <= pM->m_dwHeaps; i++)
                                        HeapDestroy(pM->m_phHeaps[i]);
                        }
#endif
                        HeapDestroy(pM->m_hHeap);
                }
        }
        return S_OK;
}

ATLINLINE ATLAPI AtlModuleAddTermFunc(_ATL_MODULE* pM, _ATL_TERMFUNC* pFunc, DWORD_PTR dw)
{
        HRESULT hr = S_OK;
        _ATL_TERMFUNC_ELEM* pNew = NULL;
        ATLTRY(pNew = new _ATL_TERMFUNC_ELEM);
        if (pNew == NULL)
                hr = E_OUTOFMEMORY;
        else
        {
                pNew->pFunc = pFunc;
                pNew->dw = dw;
                EnterCriticalSection(&pM->m_csStaticDataInit);
                pNew->pNext = pM->m_pTermFuncs;
                pM->m_pTermFuncs = pNew;
                LeaveCriticalSection(&pM->m_csStaticDataInit);
        }
        return hr;
}

ATLINLINE ATLAPI AtlRegisterClassCategoriesHelper( REFCLSID clsid,
   const struct _ATL_CATMAP_ENTRY* pCatMap, BOOL bRegister )
{
   CComPtr< ICatRegister > pCatRegister;
   HRESULT hResult;
   const struct _ATL_CATMAP_ENTRY* pEntry;
   CATID catid;

   if( pCatMap == NULL )
   {
          return( S_OK );
   }

   hResult = CoCreateInstance( CLSID_StdComponentCategoriesMgr, NULL,
          CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pCatRegister );
   if( FAILED( hResult ) )
   {
          // Since not all systems have the category manager installed, we'll allow
          // the registration to succeed even though we didn't register our
          // categories.  If you really want to register categories on a system
          // without the category manager, you can either manually add the
          // appropriate entries to your registry script (.rgs), or you can
          // redistribute comcat.dll.
          return( S_OK );
   }

   hResult = S_OK;
   pEntry = pCatMap;
   while( pEntry->iType != _ATL_CATMAP_ENTRY_END )
   {
          catid = *pEntry->pcatid;
          if( bRegister )
          {
                 if( pEntry->iType == _ATL_CATMAP_ENTRY_IMPLEMENTED )
                 {
                        hResult = pCatRegister->RegisterClassImplCategories( clsid, 1,
                           &catid );
                 }
                 else
                 {
                        ATLASSERT( pEntry->iType == _ATL_CATMAP_ENTRY_REQUIRED );
                        hResult = pCatRegister->RegisterClassReqCategories( clsid, 1,
                           &catid );
                 }
                 if( FAILED( hResult ) )
                 {
                        return( hResult );
                 }
          }
          else
          {
                 if( pEntry->iType == _ATL_CATMAP_ENTRY_IMPLEMENTED )
                 {
                        pCatRegister->UnRegisterClassImplCategories( clsid, 1, &catid );
                 }
                 else
                 {
                        ATLASSERT( pEntry->iType == _ATL_CATMAP_ENTRY_REQUIRED );
                        pCatRegister->UnRegisterClassReqCategories( clsid, 1, &catid );
                 }
          }
          pEntry++;
   }

   return( S_OK );
}

ATLINLINE ATLAPI AtlModuleRegisterServer(_ATL_MODULE* pM, BOOL bRegTypeLib, const CLSID* pCLSID)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
        ATLASSERT(pM->m_hInst != NULL);
        ATLASSERT(pM->m_pObjMap != NULL);
        _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
        HRESULT hRes = S_OK;
        for (;pEntry->pclsid != NULL; pEntry = _NextObjectMapEntry(pM, pEntry))
        {
                if (pCLSID == NULL)
                {
                        if (pEntry->pfnGetObjectDescription != NULL &&
                                pEntry->pfnGetObjectDescription() != NULL)
                                        continue;
                }
                else
                {
                        if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
                                continue;
                }
                hRes = pEntry->pfnUpdateRegistry(TRUE);
                if (FAILED(hRes))
                        break;
                if (pM->cbSize == sizeof(_ATL_MODULE))
                {
                        hRes = AtlRegisterClassCategoriesHelper( *pEntry->pclsid,
                                pEntry->pfnGetCategoryMap(), TRUE );
                        if (FAILED(hRes))
                                break;
                }
        }
        if (SUCCEEDED(hRes) && bRegTypeLib)
                hRes = AtlModuleRegisterTypeLib(pM, 0);
        return hRes;
}

ATLINLINE ATLAPI AtlModuleUnregisterServerEx(_ATL_MODULE* pM, BOOL bUnRegTypeLib, const CLSID* pCLSID)
{
        ATLASSERT(pM != NULL);
        if (pM == NULL)
                return E_INVALIDARG;
        ATLASSERT(pM->m_hInst != NULL);
        ATLASSERT(pM->m_pObjMap != NULL);
        _ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
        for (;pEntry->pclsid != NULL; pEntry = _NextObjectMapEntry(pM, pEntry))
        {
                if (pCLSID == NULL)
                {
                        if (pEntry->pfnGetObjectDescription != NULL
                                && pEntry->pfnGetObjectDescription() != NULL)
                                continue;
                }
                else
                {
                        if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
                                continue;
                }
                pEntry->pfnUpdateRegistry(FALSE); //unregister
				if (pM->cbSize == sizeof(_ATL_MODULE) && pEntry->pfnGetCategoryMap != NULL)
					AtlRegisterClassCategoriesHelper( *pEntry->pclsid,
							pEntry->pfnGetCategoryMap(), FALSE );
        }
        if (bUnRegTypeLib)
                AtlModuleUnRegisterTypeLib(pM, 0);
        return S_OK;
}

ATLINLINE ATLAPI AtlModuleUnregisterServer(_ATL_MODULE* pM, const CLSID* pCLSID)
{
        return AtlModuleUnregisterServerEx(pM, FALSE, pCLSID);
}

ATLINLINE ATLAPI AtlModuleUpdateRegistryFromResourceD(_ATL_MODULE* pM, LPCOLESTR lpszRes,
        BOOL bRegister, struct _ATL_REGMAP_ENTRY* pMapEntries, IRegistrar* pReg)
{
        USES_CONVERSION;
        ATLASSERT(pM != NULL);
        HRESULT hRes = S_OK;
        CComPtr<IRegistrar> p;
        if (pReg != NULL)
                p = pReg;
        else
        {
                hRes = CoCreateInstance(CLSID_Registrar, NULL,
                        CLSCTX_INPROC_SERVER, IID_IRegistrar, (void**)&p);
        }
        if (SUCCEEDED(hRes))
        {
                TCHAR szModule[_MAX_PATH];
                GetModuleFileName(pM->m_hInst, szModule, _MAX_PATH);

				LPOLESTR pszModule;
				if ((pM->m_hInst == NULL) || (pM->m_hInst == GetModuleHandle(NULL))) // register as EXE
				{
					// Convert to short path to work around bug in NT4's CreateProcess
					TCHAR szModuleShort[_MAX_PATH];
					int cbShortName = GetShortPathName(szModule, szModuleShort, _MAX_PATH);

					if (cbShortName == _MAX_PATH)
						return E_OUTOFMEMORY;

					pszModule = (cbShortName == 0 || cbShortName == ERROR_INVALID_PARAMETER) ? T2OLE(szModule) : T2OLE(szModuleShort);
				}
				else
					pszModule = T2OLE(szModule);


                int nLen = ocslen(pszModule);
                LPOLESTR pszModuleQuote = (LPOLESTR)alloca((nLen*2+1)*sizeof(OLECHAR));
                CComModule::ReplaceSingleQuote(pszModuleQuote, pszModule);
                p->AddReplacement(OLESTR("Module"), pszModuleQuote);

                if (NULL != pMapEntries)
                {
                        while (NULL != pMapEntries->szKey)
                        {
                                ATLASSERT(NULL != pMapEntries->szData);
                                p->AddReplacement((LPOLESTR)pMapEntries->szKey, (LPOLESTR)pMapEntries->szData);
                                pMapEntries++;
                        }
                }
                LPCOLESTR szType = OLESTR("REGISTRY");
				if (DWORD_PTR(lpszRes)<=0xffff)
				{
					if (bRegister)
						hRes = p->ResourceRegister(pszModule, ((UINT)LOWORD((DWORD_PTR)lpszRes)), szType);
					else
						hRes = p->ResourceUnregister(pszModule, ((UINT)LOWORD((DWORD_PTR)lpszRes)), szType);
				}
                else
                {
                        if (bRegister)
                                hRes = p->ResourceRegisterSz(pszModule, lpszRes, szType);
                        else
                                hRes = p->ResourceUnregisterSz(pszModule, lpszRes, szType);
                }

        }
        return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// TypeLib Support

ATLINLINE ATLAPI AtlModuleLoadTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex, BSTR* pbstrPath, ITypeLib** ppTypeLib)
{
        *pbstrPath = NULL;
        *ppTypeLib = NULL;
        ATLASSERT(pM != NULL);
        USES_CONVERSION;
        ATLASSERT(pM->m_hInstTypeLib != NULL);
        TCHAR szModule[_MAX_PATH+10];
        GetModuleFileName(pM->m_hInstTypeLib, szModule, _MAX_PATH);
        if (lpszIndex != NULL)
                lstrcat(szModule, OLE2CT(lpszIndex));
        LPOLESTR lpszModule = T2OLE(szModule);
        HRESULT hr = LoadTypeLib(lpszModule, ppTypeLib);
        if (!SUCCEEDED(hr))
        {
                // typelib not in module, try <module>.tlb instead
                LPTSTR lpszExt = NULL;
                LPTSTR lpsz;
                for (lpsz = szModule; *lpsz != NULL; lpsz = CharNext(lpsz))
                {
                        if (*lpsz == _T('.'))
                                lpszExt = lpsz;
                }
                if (lpszExt == NULL)
                        lpszExt = lpsz;
                lstrcpy(lpszExt, _T(".tlb"));
                lpszModule = T2OLE(szModule);
                hr = LoadTypeLib(lpszModule, ppTypeLib);
        }
        if (SUCCEEDED(hr))
                *pbstrPath = OLE2BSTR(lpszModule);
        return hr;
}

ATLINLINE ATLAPI AtlModuleUnRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex)
{
        typedef HRESULT (WINAPI *PFNRTL)(REFGUID, WORD, WORD, LCID, SYSKIND);
        CComBSTR bstrPath;
        CComPtr<ITypeLib> pTypeLib;
        HRESULT hr = AtlModuleLoadTypeLib(pM, lpszIndex, &bstrPath, &pTypeLib);
        if (SUCCEEDED(hr))
        {
                TLIBATTR* ptla;
                HRESULT hr = pTypeLib->GetLibAttr(&ptla);
                if (SUCCEEDED(hr))
                {
                        HINSTANCE h = LoadLibrary(_T("oleaut32.dll"));
                        if (h != NULL)
                        {
                                PFNRTL pfn = (PFNRTL) GetProcAddress(h, "UnRegisterTypeLib");
                                if (pfn != NULL)
                                        hr = pfn(ptla->guid, ptla->wMajorVerNum, ptla->wMinorVerNum, ptla->lcid, ptla->syskind);
                                FreeLibrary(h);
                        }
                        pTypeLib->ReleaseTLibAttr(ptla);
                }
        }
        return hr;
}

ATLINLINE ATLAPI AtlModuleRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex)
{
        CComBSTR bstrPath;
        CComPtr<ITypeLib> pTypeLib;
        HRESULT hr = AtlModuleLoadTypeLib(pM, lpszIndex, &bstrPath, &pTypeLib);
        if (SUCCEEDED(hr))
        {
                OLECHAR szDir[_MAX_PATH];
                ocscpy(szDir, bstrPath);
                szDir[AtlGetDirLen(szDir)] = 0;
                hr = ::RegisterTypeLib(pTypeLib, bstrPath, szDir);
        }
        return hr;
}

ATLINLINE ATLAPI_(DWORD) AtlGetVersion(void* /* pReserved */)
{
        return _ATL_VER;
}

ATLINLINE ATLAPI_(void) AtlModuleAddCreateWndData(_ATL_MODULE* pM, _AtlCreateWndData* pData, void* pObject)
{
        pData->m_pThis = pObject;
        pData->m_dwThreadID = ::GetCurrentThreadId();
        ::EnterCriticalSection(&pM->m_csWindowCreate);
        pData->m_pNext = pM->m_pCreateWndList;
        pM->m_pCreateWndList = pData;
        ::LeaveCriticalSection(&pM->m_csWindowCreate);
}

ATLINLINE ATLAPI_(void*) AtlModuleExtractCreateWndData(_ATL_MODULE* pM)
{
        void* pv = NULL;
        ::EnterCriticalSection(&pM->m_csWindowCreate);
        _AtlCreateWndData* pEntry = pM->m_pCreateWndList;
        if(pEntry != NULL)
        {
                DWORD dwThreadID = ::GetCurrentThreadId();
                _AtlCreateWndData* pPrev = NULL;
                while(pEntry != NULL)
                {
                        if(pEntry->m_dwThreadID == dwThreadID)
                        {
                                if(pPrev == NULL)
                                        pM->m_pCreateWndList = pEntry->m_pNext;
                                else
                                        pPrev->m_pNext = pEntry->m_pNext;
                                pv = pEntry->m_pThis;
                                break;
                        }
                        pPrev = pEntry;
                        pEntry = pEntry->m_pNext;
                }
        }
        ::LeaveCriticalSection(&pM->m_csWindowCreate);
        return pv;
}

/////////////////////////////////////////////////////////////////////////////
// General DLL Version Helpers

inline HRESULT AtlGetDllVersion(HINSTANCE hInstDLL, DLLVERSIONINFO* pDllVersionInfo)
{
        ATLASSERT(pDllVersionInfo != NULL);
        if(::IsBadWritePtr(pDllVersionInfo, sizeof(DWORD)))
                return E_INVALIDARG;

        // We must get this function explicitly because some DLLs don't implement it.
        DLLGETVERSIONPROC pfnDllGetVersion = (DLLGETVERSIONPROC)::GetProcAddress(hInstDLL, "DllGetVersion");
        if(pfnDllGetVersion == NULL)
                return E_NOTIMPL;

        return (*pfnDllGetVersion)(pDllVersionInfo);
}

inline HRESULT AtlGetDllVersion(LPCTSTR lpstrDllName, DLLVERSIONINFO* pDllVersionInfo)
{
        HINSTANCE hInstDLL = ::LoadLibrary(lpstrDllName);
        if(hInstDLL == NULL)
                return E_FAIL;
        HRESULT hRet = AtlGetDllVersion(hInstDLL, pDllVersionInfo);
        ::FreeLibrary(hInstDLL);
        return hRet;
}

// Common Control Versions:
//   Win95/WinNT 4.0    maj=4 min=00
//   IE 3.x     maj=4 min=70
//   IE 4.0     maj=4 min=71
inline HRESULT AtlGetCommCtrlVersion(LPDWORD pdwMajor, LPDWORD pdwMinor)
{
        ATLASSERT(pdwMajor != NULL && pdwMinor != NULL);
        if(::IsBadWritePtr(pdwMajor, sizeof(DWORD)) || ::IsBadWritePtr(pdwMinor, sizeof(DWORD)))
                return E_INVALIDARG;

        DLLVERSIONINFO dvi;
        ::ZeroMemory(&dvi, sizeof(dvi));
        dvi.cbSize = sizeof(dvi);
        HRESULT hRet = AtlGetDllVersion(_T("comctl32.dll"), &dvi);

        if(SUCCEEDED(hRet))
        {
                *pdwMajor = dvi.dwMajorVersion;
                *pdwMinor = dvi.dwMinorVersion;
        }
        else if(hRet == E_NOTIMPL)
        {
                // If DllGetVersion is not there, then the DLL is a version
                // previous to the one shipped with IE 3.x
                *pdwMajor = 4;
                *pdwMinor = 0;
                hRet = S_OK;
        }

        return hRet;
}

// Shell Versions:
//   Win95/WinNT 4.0                    maj=4 min=00
//   IE 3.x, IE 4.0 without Web Integrated Desktop  maj=4 min=00
//   IE 4.0 with Web Integrated Desktop         maj=4 min=71
//   IE 4.01 with Web Integrated Desktop        maj=4 min=72
inline HRESULT AtlGetShellVersion(LPDWORD pdwMajor, LPDWORD pdwMinor)
{
        ATLASSERT(pdwMajor != NULL && pdwMinor != NULL);
        if(::IsBadWritePtr(pdwMajor, sizeof(DWORD)) || ::IsBadWritePtr(pdwMinor, sizeof(DWORD)))
                return E_INVALIDARG;

        DLLVERSIONINFO dvi;
        ::ZeroMemory(&dvi, sizeof(dvi));
        dvi.cbSize = sizeof(dvi);
        HRESULT hRet = AtlGetDllVersion(_T("shell32.dll"), &dvi);

        if(SUCCEEDED(hRet))
        {
                *pdwMajor = dvi.dwMajorVersion;
                *pdwMinor = dvi.dwMinorVersion;
        }
        else if(hRet == E_NOTIMPL)
        {
                // If DllGetVersion is not there, then the DLL is a version
                // previous to the one shipped with IE 4.x
                *pdwMajor = 4;
                *pdwMinor = 0;
                hRet = S_OK;
        }

        return hRet;
}

#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif

//Prevent pulling in second time
#undef _ATLBASE_IMPL

#endif // _ATLBASE_IMPL

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\atl\atlctl.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLCTL_H__
#define __ATLCTL_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#include <atlwin.h>

#include <objsafe.h>
#include <urlmon.h>

#pragma comment(lib, "gdi32.lib")
#pragma comment(lib, "urlmon.lib")


#define DECLARE_VIEW_STATUS(statusFlags) \
	DWORD _GetViewStatus() \
	{ \
		return statusFlags; \
	}

// Include GUIDs for the new stock property dialogs contained in the dll MSStkProp.DLL
#include "msstkppg.h"
#include "atliface.h"
#define CLSID_MSStockFont CLSID_StockFontPage
#define CLSID_MSStockColor CLSID_StockColorPage
#define CLSID_MSStockPicture CLSID_StockPicturePage

struct ATL_DRAWINFO
{
	UINT cbSize;
	DWORD dwDrawAspect;
	LONG lindex;
	DVTARGETDEVICE* ptd;
	HDC hicTargetDev;
	HDC hdcDraw;
	LPCRECTL prcBounds; //Rectangle in which to draw
	LPCRECTL prcWBounds; //WindowOrg and Ext if metafile
	BOOL bOptimize;
	BOOL bZoomed;
	BOOL bRectInHimetric;
	SIZEL ZoomNum;      //ZoomX = ZoomNum.cx/ZoomNum.cy
	SIZEL ZoomDen;
};

namespace ATL
{

#pragma pack(push, _ATL_PACKING)

// Forward declarations
//
class ATL_NO_VTABLE CComControlBase;
template <class T, class WinBase> class CComControl;

//////////////////////////////////////////////////////////////////////////////
// CFirePropNotifyEvent


// Helper functions for safely communicating with objects who sink IPropertyNotifySink
class CFirePropNotifyEvent
{
public:
	// Ask any objects sinking the IPropertyNotifySink notification if it is ok to edit a specified property
	static HRESULT FireOnRequestEdit(IUnknown* pUnk, DISPID dispID)
	{
		CComQIPtr<IConnectionPointContainer, &IID_IConnectionPointContainer> pCPC(pUnk);
		if (!pCPC)
			return S_OK;
		CComPtr<IConnectionPoint> pCP;
		pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP);
		if (!pCP)
			return S_OK;
		CComPtr<IEnumConnections> pEnum;

		if (FAILED(pCP->EnumConnections(&pEnum)))
			return S_OK;
		CONNECTDATA cd;
		while (pEnum->Next(1, &cd, NULL) == S_OK)
		{
			if (cd.pUnk)
			{
				HRESULT hr = S_OK;
				CComQIPtr<IPropertyNotifySink, &IID_IPropertyNotifySink> pSink(cd.pUnk);
				if (pSink)
					hr = pSink->OnRequestEdit(dispID);
				cd.pUnk->Release();
				if (hr == S_FALSE)
					return S_FALSE;
			}
		}
		return S_OK;
	}
	// Notify any objects sinking the IPropertyNotifySink notification that a property has changed
	static HRESULT FireOnChanged(IUnknown* pUnk, DISPID dispID)
	{
		CComQIPtr<IConnectionPointContainer, &IID_IConnectionPointContainer> pCPC(pUnk);
		if (!pCPC)
			return S_OK;
		CComPtr<IConnectionPoint> pCP;
		pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP);
		if (!pCP)
			return S_OK;
		CComPtr<IEnumConnections> pEnum;

		if (FAILED(pCP->EnumConnections(&pEnum)))
			return S_OK;
		CONNECTDATA cd;
		while (pEnum->Next(1, &cd, NULL) == S_OK)
		{
			if (cd.pUnk)
			{
				CComQIPtr<IPropertyNotifySink, &IID_IPropertyNotifySink> pSink(cd.pUnk);
				if (pSink)
					pSink->OnChanged(dispID);
				cd.pUnk->Release();
			}
		}
		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// CComControlBase

// Holds the essential data members for an ActiveX control and useful helper functions
class ATL_NO_VTABLE CComControlBase
{
public:
	CComControlBase(HWND& h) : m_hWndCD(h)
	{
		memset(this, 0, sizeof(CComControlBase));
		m_phWndCD = &h;
		m_sizeExtent.cx = 2*2540;
		m_sizeExtent.cy = 2*2540;
		m_sizeNatural = m_sizeExtent;
	}
	~CComControlBase()
	{
		if (m_hWndCD != NULL)
			::DestroyWindow(m_hWndCD);
		ATLTRACE2(atlTraceControls,2,_T("Control Destroyed\n"));
	}

// methods
public:
	// Control helper functions can go here non-virtuals only please

	// Mark the control 'dirty' so the container will save it
	void SetDirty(BOOL bDirty)
	{
		m_bRequiresSave = bDirty;
	}
	// Obtain the dirty state for the control 
	BOOL GetDirty()
	{
		return m_bRequiresSave ? TRUE : FALSE;
	}
	// Get the zoom factor (numerator & denominator) which is factor of the natural extent
	void GetZoomInfo(ATL_DRAWINFO& di);
	// Sends a notification that the moniker for the control has changed
	HRESULT SendOnRename(IMoniker *pmk)
	{
		HRESULT hRes = S_OK;
		if (m_spOleAdviseHolder)
			hRes = m_spOleAdviseHolder->SendOnRename(pmk);
		return hRes;
	}
	// Sends a notification that the control has just saved its data
	HRESULT SendOnSave()
	{
		HRESULT hRes = S_OK;
		if (m_spOleAdviseHolder)
			hRes = m_spOleAdviseHolder->SendOnSave();
		return hRes;
	}
	// Sends a notification that the control has closed its advisory sinks
	HRESULT SendOnClose()
	{
		HRESULT hRes = S_OK;
		if (m_spOleAdviseHolder)
			hRes = m_spOleAdviseHolder->SendOnClose();
		return hRes;
	}
	// Sends a notification that the control's data has changed
	HRESULT SendOnDataChange(DWORD advf = 0);
	// Sends a notification that the control's representation has changed
	HRESULT SendOnViewChange(DWORD dwAspect, LONG lindex = -1)
	{
		if (m_spAdviseSink)
			m_spAdviseSink->OnViewChange(dwAspect, lindex);
		return S_OK;
	}
	// Sends a notification to the container that the control has received focus
	LRESULT OnSetFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		if (m_bInPlaceActive)
		{
			CComPtr<IOleObject> pOleObject;
			ControlQueryInterface(IID_IOleObject, (void**)&pOleObject);
			if (pOleObject != NULL)
				pOleObject->DoVerb(OLEIVERB_UIACTIVATE, NULL, m_spClientSite, 0, m_hWndCD, &m_rcPos);
			CComQIPtr<IOleControlSite, &IID_IOleControlSite> spSite(m_spClientSite);
			if (m_bInPlaceActive && spSite != NULL)
				spSite->OnFocus(TRUE);
		}
		bHandled = FALSE;
		return 1;
	}
	LRESULT OnKillFocus(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		CComQIPtr<IOleControlSite, &IID_IOleControlSite> spSite(m_spClientSite);
		if (m_bInPlaceActive && spSite != NULL && !::IsChild(m_hWndCD, ::GetFocus()))
			spSite->OnFocus(FALSE);
		bHandled = FALSE;
		return 1;
	}
	LRESULT OnMouseActivate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& bHandled)
	{
		BOOL bUserMode = TRUE;
		HRESULT hRet = GetAmbientUserMode(bUserMode);
		// UI activate if in user mode only
		// allow activation if we can't determine mode
		if (FAILED(hRet) || bUserMode)
		{
			CComPtr<IOleObject> pOleObject;
			ControlQueryInterface(IID_IOleObject, (void**)&pOleObject);
			if (pOleObject != NULL)
				pOleObject->DoVerb(OLEIVERB_UIACTIVATE, NULL, m_spClientSite, 0, m_hWndCD, &m_rcPos);
		}
		bHandled = FALSE;
		return 1;
	}
	BOOL PreTranslateAccelerator(LPMSG /*pMsg*/, HRESULT& /*hRet*/)
	{
		return FALSE;
	}

	HRESULT GetAmbientProperty(DISPID dispid, VARIANT& var)
	{
		HRESULT hRes = E_FAIL;
		if (m_spAmbientDispatch.p != NULL)
			hRes = m_spAmbientDispatch.GetProperty(dispid, &var);
		return hRes;
	}
	HRESULT GetAmbientAppearance(short& nAppearance)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_APPEARANCE, var);
		ATLASSERT(var.vt == VT_I2 || var.vt == VT_UI2 || var.vt == VT_I4 || var.vt == VT_UI4 || FAILED(hRes));
		nAppearance = var.iVal;
		return hRes;
	}
	HRESULT GetAmbientBackColor(OLE_COLOR& BackColor)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_BACKCOLOR, var);
		ATLASSERT(var.vt == VT_I4 || var.vt == VT_UI4 || FAILED(hRes));
		BackColor = var.lVal;
		return hRes;
	}
	HRESULT GetAmbientDisplayName(BSTR& bstrDisplayName)
	{
		CComVariant var;
		if (bstrDisplayName)
		{
			SysFreeString(bstrDisplayName);
			bstrDisplayName = NULL;
		}
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_DISPLAYNAME, var);
		if (SUCCEEDED(hRes))
		{
			if (var.vt != VT_BSTR)
				return E_FAIL;
			bstrDisplayName = var.bstrVal;
			var.vt = VT_EMPTY;
			var.bstrVal = NULL;
		}
		return hRes;
	}
	HRESULT GetAmbientFont(IFont** ppFont)
	{
		// caller MUST Release the font!
		if (ppFont == NULL)
			return E_POINTER;
		*ppFont = NULL;
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_FONT, var);
		ATLASSERT((var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH) || FAILED(hRes));
		if (SUCCEEDED(hRes) && var.pdispVal)
		{
			if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
				hRes = var.pdispVal->QueryInterface(IID_IFont, (void**)ppFont);
			else
				hRes = DISP_E_BADVARTYPE;
		}
		return hRes;
	}
	HRESULT GetAmbientFontDisp(IFontDisp** ppFont)
	{
		// caller MUST Release the font!
		if (ppFont == NULL)
			return E_POINTER;
		*ppFont = NULL;
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_FONT, var);
		ATLASSERT((var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH) || FAILED(hRes));
		if (SUCCEEDED(hRes) && var.pdispVal)
		{
			if (var.vt == VT_UNKNOWN || var.vt == VT_DISPATCH)
				hRes = var.pdispVal->QueryInterface(IID_IFontDisp, (void**)ppFont);
			else
				hRes = DISP_E_BADVARTYPE;
		}
		return hRes;
	}
	HRESULT GetAmbientForeColor(OLE_COLOR& ForeColor)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_FORECOLOR, var);
		ATLASSERT(var.vt == VT_I4 || var.vt == VT_UI4 || FAILED(hRes));
		ForeColor = var.lVal;
		return hRes;
	}
	HRESULT GetAmbientLocaleID(LCID& lcid)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_LOCALEID, var);
		ATLASSERT((var.vt == VT_UI4 || var.vt == VT_I4) || FAILED(hRes));
		lcid = var.lVal;
		return hRes;
	}
	HRESULT GetAmbientScaleUnits(BSTR& bstrScaleUnits)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SCALEUNITS, var);
		ATLASSERT(var.vt == VT_BSTR || FAILED(hRes));
		bstrScaleUnits = var.bstrVal;
		return hRes;
	}
	HRESULT GetAmbientTextAlign(short& nTextAlign)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_TEXTALIGN, var);
		ATLASSERT(var.vt == VT_I2 || FAILED(hRes));
		nTextAlign = var.iVal;
		return hRes;
	}
	HRESULT GetAmbientUserMode(BOOL& bUserMode)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_USERMODE, var);
		ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
		bUserMode = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientUIDead(BOOL& bUIDead)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_UIDEAD, var);
		ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
		bUIDead = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientShowGrabHandles(BOOL& bShowGrabHandles)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SHOWGRABHANDLES, var);
		ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
		bShowGrabHandles = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientShowHatching(BOOL& bShowHatching)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SHOWHATCHING, var);
		ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
		bShowHatching = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientMessageReflect(BOOL& bMessageReflect)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_MESSAGEREFLECT, var);
		ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
		bMessageReflect = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientAutoClip(BOOL& bAutoClip)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_AUTOCLIP, var);
		ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
		bAutoClip = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientDisplayAsDefault(BOOL& bDisplaysDefault)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_DISPLAYASDEFAULT, var);
		ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
		bDisplaysDefault = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientSupportsMnemonics(BOOL& bSupportMnemonics)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_SUPPORTSMNEMONICS, var);
		ATLASSERT(var.vt == VT_BOOL || FAILED(hRes));
		bSupportMnemonics = var.boolVal;
		return hRes;
	}
	HRESULT GetAmbientPalette(HPALETTE& hPalette)
	{
		CComVariant var;
		HRESULT hRes = GetAmbientProperty(DISPID_AMBIENT_PALETTE, var);
#ifdef _WIN64
		ATLASSERT(var.vt == VT_I8 || var.vt == VT_UI8 || FAILED(hRes));
		hPalette = *(HPALETTE*)&var.dblVal;
#else
		ATLASSERT(var.vt == VT_I4 || var.vt == VT_UI4 || FAILED(hRes));
		hPalette = reinterpret_cast<HPALETTE>(var.lVal);
#endif
		return hRes;
	}

	HRESULT InternalGetSite(REFIID riid, void** ppUnkSite)
	{
		ATLASSERT(ppUnkSite != NULL);
		if (ppUnkSite == NULL)
			return E_POINTER;
		if (m_spClientSite == NULL)
		{
			*ppUnkSite = NULL;
			return S_OK;
		}
		return m_spClientSite->QueryInterface(riid, ppUnkSite);
	}

	BOOL DoesVerbUIActivate(LONG iVerb)
	{
		BOOL b = FALSE;
		switch (iVerb)
		{
			case OLEIVERB_UIACTIVATE:
			case OLEIVERB_PRIMARY:
				b = TRUE;
				break;
		}
		// if no ambient dispatch then in old style OLE container
		if (DoesVerbActivate(iVerb) && m_spAmbientDispatch.p == NULL)
			b = TRUE;
		return b;
	}

	BOOL DoesVerbActivate(LONG iVerb)
	{
		BOOL b = FALSE;
		switch (iVerb)
		{
			case OLEIVERB_UIACTIVATE:
			case OLEIVERB_PRIMARY:
			case OLEIVERB_SHOW:
			case OLEIVERB_INPLACEACTIVATE:
				b = TRUE;
				break;
		}
		return b;
	}

	BOOL SetControlFocus(BOOL bGrab);
	HRESULT IQuickActivate_QuickActivate(QACONTAINER *pQACont,
		QACONTROL *pQACtrl);
	HRESULT DoVerbProperties(LPCRECT /* prcPosRect */, HWND hwndParent);
	HRESULT InPlaceActivate(LONG iVerb, const RECT* prcPosRect = NULL);

	HRESULT IOleObject_SetClientSite(IOleClientSite *pClientSite);
	HRESULT IOleObject_GetClientSite(IOleClientSite **ppClientSite);
	HRESULT IOleObject_Advise(IAdviseSink *pAdvSink, DWORD *pdwConnection);
	HRESULT IOleObject_Close(DWORD dwSaveOption);
	HRESULT IOleObject_SetExtent(DWORD dwDrawAspect, SIZEL *psizel);
	HRESULT IOleInPlaceObject_InPlaceDeactivate(void);
	HRESULT IOleInPlaceObject_UIDeactivate(void);
	HRESULT IOleInPlaceObject_SetObjectRects(LPCRECT prcPos,LPCRECT prcClip);
	HRESULT IViewObject_Draw(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
		DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw,
		LPCRECTL prcBounds, LPCRECTL prcWBounds);
	HRESULT IDataObject_GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);

	HRESULT FireViewChange();
	LRESULT OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& lResult);

	virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos) = 0;
	virtual HRESULT ControlQueryInterface(const IID& iid, void** ppv) = 0;
	virtual HRESULT OnDrawAdvanced(ATL_DRAWINFO& di);
	virtual HRESULT OnDraw(ATL_DRAWINFO& /*di*/)
	{
		return S_OK;
	}


// Attributes
public:
	CComPtr<IOleInPlaceSiteWindowless> m_spInPlaceSite;
	CComPtr<IDataAdviseHolder> m_spDataAdviseHolder;
	CComPtr<IOleAdviseHolder> m_spOleAdviseHolder;
	CComPtr<IOleClientSite> m_spClientSite;
	CComPtr<IAdviseSink> m_spAdviseSink;
	CComDispatchDriver m_spAmbientDispatch;

	SIZE m_sizeNatural; //unscaled size in himetric
	SIZE m_sizeExtent;  //current extents in himetric
	RECT m_rcPos; // position in pixels
#pragma warning(disable: 4510 4610) // unnamed union
	union
	{
		HWND& m_hWndCD;
		HWND* m_phWndCD;
	};
#pragma warning(default: 4510 4610)
	union
	{
		// m_nFreezeEvents is the only one actually used
		int m_nFreezeEvents; // count of freezes versus thaws

		// These are here to make stock properties work
		IPictureDisp* m_pMouseIcon;
		IPictureDisp* m_pPicture;
		IFontDisp* m_pFont;
		OLE_COLOR m_clrBackColor;
		OLE_COLOR m_clrBorderColor;
		OLE_COLOR m_clrFillColor;
		OLE_COLOR m_clrForeColor;
		BSTR m_bstrText;
		BSTR m_bstrCaption;
		BOOL m_bValid;
		BOOL m_bTabStop;
		BOOL m_bBorderVisible;
		BOOL m_bEnabled;
		LONG m_nBackStyle;
		LONG m_nBorderStyle;
		LONG m_nBorderWidth;
		LONG m_nDrawMode;
		LONG m_nDrawStyle;
		LONG m_nDrawWidth;
		LONG m_nFillStyle;
		SHORT m_nAppearance;
		LONG m_nMousePointer;
		LONG m_nReadyState;
	};

	unsigned m_bNegotiatedWnd:1;
	unsigned m_bWndLess:1;
	unsigned m_bInPlaceActive:1;
	unsigned m_bUIActive:1;
	unsigned m_bUsingWindowRgn:1;
	unsigned m_bInPlaceSiteEx:1;
	unsigned m_bWindowOnly:1;
	unsigned m_bRequiresSave:1;
	unsigned m_bWasOnceWindowless:1;
	unsigned m_bAutoSize:1; //SetExtent fails if size doesn't match existing
	unsigned m_bRecomposeOnResize:1; //implies OLEMISC_RECOMPOSEONRESIZE
	unsigned m_bResizeNatural:1;  //resize natural extent on SetExtent
	unsigned m_bDrawFromNatural:1; //instead of m_sizeExtent
	unsigned m_bDrawGetDataInHimetric:1; //instead of pixels

	DECLARE_VIEW_STATUS(VIEWSTATUS_OPAQUE)
};

inline HRESULT CComControlBase::IQuickActivate_QuickActivate(QACONTAINER *pQACont,
	QACONTROL *pQACtrl)
{
	ATLASSERT(pQACont != NULL);
	ATLASSERT(pQACtrl != NULL);
	if (!pQACont || !pQACtrl)
		return E_POINTER;

	HRESULT hRes;
	ULONG uCB = pQACtrl->cbSize;
	memset(pQACtrl, 0, uCB);
	pQACtrl->cbSize = uCB;

	// get all interfaces we are going to need
	CComPtr<IOleObject> pOO;
	ControlQueryInterface(IID_IOleObject, (void**)&pOO);
	CComPtr<IViewObjectEx> pVOEX;
	ControlQueryInterface(IID_IViewObjectEx, (void**)&pVOEX);
	CComPtr<IPointerInactive> pPI;
	ControlQueryInterface(IID_IPointerInactive, (void**)&pPI);
	CComPtr<IProvideClassInfo2> pPCI;
	ControlQueryInterface(IID_IProvideClassInfo2, (void**)&pPCI);

	if (pOO == NULL || pVOEX == NULL)
		return E_FAIL;

	hRes = pOO->SetClientSite(pQACont->pClientSite);
    if (FAILED(hRes)) {
        return hRes;
    }

	if (pQACont->pAdviseSink != NULL)
	{
		ATLTRACE2(atlTraceControls,2,_T("Setting up IOleObject Advise\n"));
		pVOEX->SetAdvise(DVASPECT_CONTENT, 0, pQACont->pAdviseSink);
	}

	CComPtr<IConnectionPointContainer> pCPC;
	ControlQueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);

	if (pQACont->pPropertyNotifySink)
	{
		ATLTRACE2(atlTraceControls,2,_T("Setting up PropNotify CP\n"));
		CComPtr<IConnectionPoint> pCP;
		if (pCPC != NULL)
		{
			hRes = pCPC->FindConnectionPoint(IID_IPropertyNotifySink, &pCP);
			if (SUCCEEDED(hRes))
				pCP->Advise(pQACont->pPropertyNotifySink, &pQACtrl->dwPropNotifyCookie);
		}
	}

	if (pPCI)
	{
		GUID iidDefaultSrc;
		if (SUCCEEDED(pPCI->GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID,
			&iidDefaultSrc)))
		{
			if (pQACont->pUnkEventSink)
			{
				ATLTRACE2(atlTraceControls,2,_T("Setting up Default Out Going Interface\n"));
				CComPtr<IConnectionPoint> pCP;
				if (pCPC != NULL)
				{
					hRes = pCPC->FindConnectionPoint(iidDefaultSrc, &pCP);
					if (SUCCEEDED(hRes))
						pCP->Advise(pQACont->pUnkEventSink, &pQACtrl->dwEventCookie);
				}
			}
		}
	}
	// give information to container
	if (pOO != NULL)
		pOO->GetMiscStatus(DVASPECT_CONTENT, &pQACtrl->dwMiscStatus);

	if (pVOEX != NULL)
		pVOEX->GetViewStatus(&pQACtrl->dwViewStatus);

	if (pPI != NULL)
		pPI->GetActivationPolicy(&pQACtrl->dwPointerActivationPolicy);
	return S_OK;
}

inline BOOL CComControlBase::SetControlFocus(BOOL bGrab)
{
	if (m_bWndLess)
	{
		if (!m_bUIActive && bGrab)
			if (FAILED(InPlaceActivate(OLEIVERB_UIACTIVATE)))
				return FALSE;

		return (m_spInPlaceSite->SetFocus(bGrab) == S_OK);
	}
	else
	{
		// we've got a window.
		//
		if (m_bInPlaceActive)
		{
			HWND hwnd = (bGrab) ? m_hWndCD : ::GetParent(m_hWndCD);
			if (!m_bUIActive && bGrab)
				return SUCCEEDED(InPlaceActivate(OLEIVERB_UIACTIVATE));
			else
			{
				if (!::IsChild(hwnd, ::GetFocus()))
					::SetFocus(hwnd);
				return TRUE;
			}
		}
	}
	return FALSE;
}

inline HRESULT CComControlBase::DoVerbProperties(LPCRECT /* prcPosRect */, HWND hwndParent)
{
	HRESULT hr = S_OK;
	CComQIPtr <ISpecifyPropertyPages, &IID_ISpecifyPropertyPages> spPages;
	CComQIPtr <IOleObject, &IID_IOleObject> spObj;
	CComQIPtr <IOleControlSite, &IID_IOleControlSite> spSite(m_spClientSite);

	if (spSite)
	{
		hr = spSite->ShowPropertyFrame();
		if (SUCCEEDED(hr))
			return hr;
	}

	CComPtr<IUnknown> pUnk;
	ControlQueryInterface(IID_IUnknown, (void**)&pUnk);
	ATLASSERT(pUnk != NULL);
	CAUUID pages;
	spPages = pUnk;
	if (spPages)
	{
		hr = spPages->GetPages(&pages);
		if (SUCCEEDED(hr))
		{
			spObj = pUnk;
			if (spObj)
			{
				LPOLESTR szTitle = NULL;

				spObj->GetUserType(USERCLASSTYPE_SHORT, &szTitle);

				LCID lcid;
				if (FAILED(GetAmbientLocaleID(lcid)))
					lcid = LOCALE_USER_DEFAULT;

				hr = OleCreatePropertyFrame(hwndParent, m_rcPos.top, m_rcPos.left, szTitle,
					1, &pUnk.p, pages.cElems, pages.pElems, lcid, 0, 0);

				CoTaskMemFree(szTitle);
			}
			else
			{
				hr = OLEOBJ_S_CANNOT_DOVERB_NOW;
			}
			CoTaskMemFree(pages.pElems);
		}
	}
	else
	{
		hr = OLEOBJ_S_CANNOT_DOVERB_NOW;
	}

	return hr;
}

inline HRESULT CComControlBase::InPlaceActivate(LONG iVerb, const RECT* /*prcPosRect*/)
{
	HRESULT hr;

	if (m_spClientSite == NULL)
		return S_OK;

	CComPtr<IOleInPlaceObject> pIPO;
	ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
	ATLASSERT(pIPO != NULL);

	if (!m_bNegotiatedWnd)
	{
		if (!m_bWindowOnly)
			// Try for windowless site
			hr = m_spClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&m_spInPlaceSite);

		if (m_spInPlaceSite)
		{
			m_bInPlaceSiteEx = TRUE;
			// CanWindowlessActivate returns S_OK or S_FALSE
			if ( m_spInPlaceSite->CanWindowlessActivate() == S_OK )
			{
				m_bWndLess = TRUE;
				m_bWasOnceWindowless = TRUE;
			}
			else
			{
				m_bWndLess = FALSE;
			}
		}
		else
		{
			m_spClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void **)&m_spInPlaceSite);
			if (m_spInPlaceSite)
				m_bInPlaceSiteEx = TRUE;
			else
				hr = m_spClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_spInPlaceSite);
		}
	}

	ATLASSERT(m_spInPlaceSite);
	if (!m_spInPlaceSite)
		return E_FAIL;

	m_bNegotiatedWnd = TRUE;

	if (!m_bInPlaceActive)
	{

		BOOL bNoRedraw = FALSE;
		if (m_bWndLess)
			m_spInPlaceSite->OnInPlaceActivateEx(&bNoRedraw, ACTIVATE_WINDOWLESS);
		else
		{
			if (m_bInPlaceSiteEx)
				m_spInPlaceSite->OnInPlaceActivateEx(&bNoRedraw, 0);
			else
			{
				hr = m_spInPlaceSite->CanInPlaceActivate();
				// CanInPlaceActivate returns S_FALSE or S_OK
				if (FAILED(hr))
					return hr;
				if ( hr != S_OK )
				{
				   // CanInPlaceActivate returned S_FALSE.
				   return( E_FAIL );
				}
				m_spInPlaceSite->OnInPlaceActivate();
			}
		}
	}

	m_bInPlaceActive = TRUE;

	// get location in the parent window,
	// as well as some information about the parent
	//
	OLEINPLACEFRAMEINFO frameInfo;
	RECT rcPos, rcClip;
	CComPtr<IOleInPlaceFrame> spInPlaceFrame;
	CComPtr<IOleInPlaceUIWindow> spInPlaceUIWindow;
	frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
	HWND hwndParent;
	if (m_spInPlaceSite->GetWindow(&hwndParent) == S_OK)
	{
		m_spInPlaceSite->GetWindowContext(&spInPlaceFrame,
			&spInPlaceUIWindow, &rcPos, &rcClip, &frameInfo);

		if (!m_bWndLess)
		{
			if (m_hWndCD)
			{
				ShowWindow(m_hWndCD, SW_SHOW);
				if (!::IsChild(m_hWndCD, ::GetFocus()))
					::SetFocus(m_hWndCD);
			}
			else
			{
				HWND h = CreateControlWindow(hwndParent, rcPos);
				ATLASSERT(h != NULL);	// will assert if creation failed
				ATLASSERT(h == m_hWndCD);
				h;	// avoid unused warning
			}
		}

		pIPO->SetObjectRects(&rcPos, &rcClip);
	}

	CComPtr<IOleInPlaceActiveObject> spActiveObject;
	ControlQueryInterface(IID_IOleInPlaceActiveObject, (void**)&spActiveObject);

	// Gone active by now, take care of UIACTIVATE
	if (DoesVerbUIActivate(iVerb))
	{
		if (!m_bUIActive)
		{
			m_bUIActive = TRUE;
			hr = m_spInPlaceSite->OnUIActivate();
			if (FAILED(hr))
				return hr;

			SetControlFocus(TRUE);
			// set ourselves up in the host.
			//
			if (spActiveObject)
			{
				if (spInPlaceFrame)
					spInPlaceFrame->SetActiveObject(spActiveObject, NULL);
				if (spInPlaceUIWindow)
					spInPlaceUIWindow->SetActiveObject(spActiveObject, NULL);
			}

			if (spInPlaceFrame)
				spInPlaceFrame->SetBorderSpace(NULL);
			if (spInPlaceUIWindow)
				spInPlaceUIWindow->SetBorderSpace(NULL);
		}
	}

	m_spClientSite->ShowObject();

	return S_OK;
}

inline HRESULT CComControlBase::SendOnDataChange(DWORD advf)
{
	HRESULT hRes = S_OK;
	if (m_spDataAdviseHolder)
	{
		CComPtr<IDataObject> pdo;
		if (SUCCEEDED(ControlQueryInterface(IID_IDataObject, (void**)&pdo)))
			hRes = m_spDataAdviseHolder->SendOnDataChange(pdo, 0, advf);
	}
	return hRes;
}

inline HRESULT CComControlBase::IOleObject_SetClientSite(IOleClientSite *pClientSite)
{
	ATLASSERT(pClientSite == NULL || m_spClientSite == NULL);
	m_spClientSite = pClientSite;
	m_spAmbientDispatch.Release();
	if (m_spClientSite != NULL)
	{
		m_spClientSite->QueryInterface(IID_IDispatch,
			(void**) &m_spAmbientDispatch.p);
	}
	return S_OK;
}

inline HRESULT CComControlBase::IOleObject_GetClientSite(IOleClientSite **ppClientSite)
{
	ATLASSERT(ppClientSite);
	if (ppClientSite == NULL)
		return E_POINTER;

	*ppClientSite = m_spClientSite;
	if (m_spClientSite != NULL)
		m_spClientSite.p->AddRef();
	return S_OK;
}

inline HRESULT CComControlBase::IOleObject_Advise(IAdviseSink *pAdvSink,
	DWORD *pdwConnection)
{
	HRESULT hr = S_OK;
	if (m_spOleAdviseHolder == NULL)
		hr = CreateOleAdviseHolder(&m_spOleAdviseHolder);
	if (SUCCEEDED(hr))
		hr = m_spOleAdviseHolder->Advise(pAdvSink, pdwConnection);
	return hr;
}

inline HRESULT CComControlBase::IOleObject_Close(DWORD dwSaveOption)
{
	CComPtr<IOleInPlaceObject> pIPO;
	ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
	ATLASSERT(pIPO != NULL);
	if (m_hWndCD)
	{
		if (m_spClientSite)
			m_spClientSite->OnShowWindow(FALSE);
	}

	if (m_bInPlaceActive)
	{
		HRESULT hr = pIPO->InPlaceDeactivate();
		if (FAILED(hr))
			return hr;
		ATLASSERT(!m_bInPlaceActive);
	}
	if (m_hWndCD)
	{
		ATLTRACE2(atlTraceControls,2,_T("Destroying Window\n"));
		if (::IsWindow(m_hWndCD))
			DestroyWindow(m_hWndCD);
		m_hWndCD = NULL;
	}

	// handle the save flag.
	//
	if ((dwSaveOption == OLECLOSE_SAVEIFDIRTY ||
		dwSaveOption == OLECLOSE_PROMPTSAVE) && m_bRequiresSave)
	{
		if (m_spClientSite)
			m_spClientSite->SaveObject();
		SendOnSave();
	}

	m_spInPlaceSite.Release();
	m_bNegotiatedWnd = FALSE;
	m_bWndLess = FALSE;
	m_bInPlaceSiteEx = FALSE;
	m_spAdviseSink.Release();
	return S_OK;
}

inline HRESULT CComControlBase::IOleInPlaceObject_InPlaceDeactivate(void)
{
	CComPtr<IOleInPlaceObject> pIPO;
	ControlQueryInterface(IID_IOleInPlaceObject, (void**)&pIPO);
	ATLASSERT(pIPO != NULL);

	if (!m_bInPlaceActive)
		return S_OK;
	pIPO->UIDeactivate();

	m_bInPlaceActive = FALSE;

	// if we have a window, tell it to go away.
	//
	if (m_hWndCD)
	{
		ATLTRACE2(atlTraceControls,2,_T("Destroying Window\n"));
		if (::IsWindow(m_hWndCD))
			DestroyWindow(m_hWndCD);
		m_hWndCD = NULL;
	}

	if (m_spInPlaceSite)
		m_spInPlaceSite->OnInPlaceDeactivate();

	return S_OK;
}

inline HRESULT CComControlBase::IOleInPlaceObject_UIDeactivate(void)
{
	// if we're not UIActive, not much to do.
	//
	if (!m_bUIActive)
		return S_OK;

	m_bUIActive = FALSE;

	// notify frame windows, if appropriate, that we're no longer ui-active.
	//
	CComPtr<IOleInPlaceFrame> spInPlaceFrame;
	CComPtr<IOleInPlaceUIWindow> spInPlaceUIWindow;
	OLEINPLACEFRAMEINFO frameInfo;
	frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
	RECT rcPos, rcClip;

	HWND hwndParent; 
	// This call to GetWindow is a fix for Delphi
	if (m_spInPlaceSite->GetWindow(&hwndParent) == S_OK)
	{
		m_spInPlaceSite->GetWindowContext(&spInPlaceFrame,
			&spInPlaceUIWindow, &rcPos, &rcClip, &frameInfo);
		if (spInPlaceUIWindow)
			spInPlaceUIWindow->SetActiveObject(NULL, NULL);
		if (spInPlaceFrame)
			spInPlaceFrame->SetActiveObject(NULL, NULL);
	}
	// we don't need to explicitly release the focus here since somebody
	// else grabbing the focus is what is likely to cause us to get lose it
	//
	m_spInPlaceSite->OnUIDeactivate(FALSE);

	return S_OK;
}

inline HRESULT CComControlBase::IOleInPlaceObject_SetObjectRects(LPCRECT prcPos,LPCRECT prcClip)
{
	if (prcPos == NULL || prcClip == NULL)
		return E_POINTER;

	m_rcPos = *prcPos;
	if (m_hWndCD)
	{
		// the container wants us to clip, so figure out if we really
		// need to
		//
		RECT rcIXect;
		BOOL b = IntersectRect(&rcIXect, prcPos, prcClip);
		HRGN tempRgn = NULL;
		if (b && !EqualRect(&rcIXect, prcPos))
		{
			OffsetRect(&rcIXect, -(prcPos->left), -(prcPos->top));
			tempRgn = CreateRectRgnIndirect(&rcIXect);
		}

		SetWindowRgn(m_hWndCD, tempRgn, TRUE);

		// set our control's location, but don't change it's size at all
		// [people for whom zooming is important should set that up here]
		//
		SIZEL size = {prcPos->right - prcPos->left, prcPos->bottom - prcPos->top};
		SetWindowPos(m_hWndCD, NULL, prcPos->left,
					 prcPos->top, size.cx, size.cy, SWP_NOZORDER | SWP_NOACTIVATE);
	}

	return S_OK;
}

inline HRESULT CComControlBase::IOleObject_SetExtent(DWORD dwDrawAspect, SIZEL *psizel)
{
	if (dwDrawAspect != DVASPECT_CONTENT)
		return DV_E_DVASPECT;
	if (psizel == NULL)
		return E_POINTER;

	BOOL bSizeMatchesNatural =
		memcmp(psizel, &m_sizeNatural, sizeof(SIZE)) == 0;

	if (m_bAutoSize) //object can't do any other size
		return (bSizeMatchesNatural) ? S_OK : E_FAIL;

	BOOL bResized = FALSE;
	if (memcmp(psizel, &m_sizeExtent, sizeof(SIZE)) != 0)
	{
		m_sizeExtent = *psizel;
		bResized = TRUE;
	}
	if (m_bResizeNatural && !bSizeMatchesNatural)
	{
		m_sizeNatural = *psizel;
		bResized = TRUE;
	}

	if (m_bRecomposeOnResize && bResized)
	{
		SendOnDataChange();
		FireViewChange();
	}
	return S_OK;
}

inline HRESULT CComControlBase::IViewObject_Draw(DWORD dwDrawAspect, LONG lindex,
	void *pvAspect, DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw,
	LPCRECTL prcBounds, LPCRECTL prcWBounds)
{
	ATLTRACE2(atlTraceControls,2,_T("Draw dwDrawAspect=%x lindex=%d ptd=%x hic=%x hdc=%x\n"),
		dwDrawAspect, lindex, ptd, hicTargetDev, hdcDraw);
#ifdef _DEBUG
	if (prcBounds == NULL)
		ATLTRACE2(atlTraceControls,2,_T("\tprcBounds=NULL\n"));
	else
		ATLTRACE2(atlTraceControls,2,_T("\tprcBounds=%d,%d,%d,%d\n"), prcBounds->left,
			prcBounds->top, prcBounds->right, prcBounds->bottom);
	if (prcWBounds == NULL)
		ATLTRACE2(atlTraceControls,2,_T("\tprcWBounds=NULL\n"));
	else
		ATLTRACE2(atlTraceControls,2,_T("\tprcWBounds=%d,%d,%d,%d\n"), prcWBounds->left,
			prcWBounds->top, prcWBounds->right, prcWBounds->bottom);
#endif

	if (prcBounds == NULL)
	{
		if (!m_bWndLess)
			return E_INVALIDARG;
		prcBounds = (RECTL*)&m_rcPos;
	}

	// support the aspects required for multi-pass drawing
	switch (dwDrawAspect)
	{
		case DVASPECT_CONTENT:
		case DVASPECT_OPAQUE:
		case DVASPECT_TRANSPARENT:
			break;
		default:
			ATLASSERT(FALSE);
			return DV_E_DVASPECT;
			break;
	}

	// make sure nobody forgets to do this
	if (ptd == NULL)
		hicTargetDev = NULL;

	BOOL bOptimize = FALSE;
	if (pvAspect && ((DVASPECTINFO *)pvAspect)->cb >= sizeof(DVASPECTINFO))
		bOptimize = (((DVASPECTINFO *)pvAspect)->dwFlags & DVASPECTINFOFLAG_CANOPTIMIZE);

	ATL_DRAWINFO di;
	memset(&di, 0, sizeof(di));
	di.cbSize = sizeof(di);
	di.dwDrawAspect = dwDrawAspect;
	di.lindex = lindex;
	di.ptd = ptd;
	di.hicTargetDev = hicTargetDev;
	di.hdcDraw = hdcDraw;
	di.prcBounds = prcBounds;
	di.prcWBounds = prcWBounds;
	di.bOptimize = bOptimize;
	return OnDrawAdvanced(di);
}

inline HRESULT CComControlBase::IDataObject_GetData(FORMATETC *pformatetcIn,
	STGMEDIUM *pmedium)
{
	if (pmedium == NULL)
		return E_POINTER;
	memset(pmedium, 0, sizeof(STGMEDIUM));
	ATLTRACE2(atlTraceControls,2,_T("Format = %x\n"), pformatetcIn->cfFormat);
	ATLTRACE2(atlTraceControls,2,_T("TYMED = %x\n"), pformatetcIn->tymed);

	if ((pformatetcIn->tymed & TYMED_MFPICT) == 0)
		return DATA_E_FORMATETC;

	SIZEL sizeMetric, size;
	if (m_bDrawFromNatural)
		sizeMetric = m_sizeNatural;
	else
		sizeMetric = m_sizeExtent;
	if (!m_bDrawGetDataInHimetric)
		AtlHiMetricToPixel(&sizeMetric, &size);
	else
		size = sizeMetric;
	RECTL rectl = {0 ,0, size.cx, size.cy};

	ATL_DRAWINFO di;
	memset(&di, 0, sizeof(di));
	di.cbSize = sizeof(di);
	di.dwDrawAspect = DVASPECT_CONTENT;
	di.lindex = -1;
	di.ptd = NULL;
	di.hicTargetDev = NULL;
	di.prcBounds = &rectl;
	di.prcWBounds = &rectl;
	di.bOptimize = TRUE; //we do a SaveDC/RestoreDC
	di.bRectInHimetric = m_bDrawGetDataInHimetric;
	// create appropriate memory metafile DC
	di.hdcDraw = CreateMetaFile(NULL);

	// create attribute DC according to pformatetcIn->ptd

	SaveDC(di.hdcDraw);
	SetWindowOrgEx(di.hdcDraw, 0, 0, NULL);
	SetWindowExtEx(di.hdcDraw, rectl.right, rectl.bottom, NULL);
	OnDrawAdvanced(di);
	RestoreDC(di.hdcDraw, -1);

	HMETAFILE hMF = CloseMetaFile(di.hdcDraw);
	if (hMF == NULL)
		return E_UNEXPECTED;

	HGLOBAL hMem=GlobalAlloc(GMEM_SHARE | GMEM_MOVEABLE, sizeof(METAFILEPICT));

	if (NULL==hMem)
	{
		DeleteMetaFile(hMF);
		return ResultFromScode(STG_E_MEDIUMFULL);
	}

	LPMETAFILEPICT pMF=(LPMETAFILEPICT)GlobalLock(hMem);
	pMF->hMF=hMF;
	pMF->mm=MM_ANISOTROPIC;
	pMF->xExt=sizeMetric.cx;
	pMF->yExt=sizeMetric.cy;
	GlobalUnlock(hMem);

	pmedium->tymed = TYMED_MFPICT;
	pmedium->hGlobal = hMem;
	pmedium->pUnkForRelease = NULL;

	return S_OK;
}

inline HRESULT CComControlBase::FireViewChange()
{
	if (m_bInPlaceActive)
	{
		// Active
		if (m_hWndCD != NULL)
			::InvalidateRect(m_hWndCD, NULL, TRUE); // Window based
		else if (m_spInPlaceSite != NULL)
			m_spInPlaceSite->InvalidateRect(NULL, TRUE); // Windowless
	}
	else // Inactive
		SendOnViewChange(DVASPECT_CONTENT);
	return S_OK;
}

inline void CComControlBase::GetZoomInfo(ATL_DRAWINFO& di)
{
	const RECTL& rcPos = *di.prcBounds;
	SIZEL sizeDen;
	if (m_bDrawFromNatural)
		sizeDen = m_sizeNatural;
	else
		sizeDen = m_sizeExtent;
	if (!di.bRectInHimetric)
		AtlHiMetricToPixel(&sizeDen, &sizeDen);
	SIZEL sizeNum = {rcPos.right-rcPos.left, rcPos.bottom-rcPos.top};
	di.ZoomNum.cx = sizeNum.cx;
	di.ZoomNum.cy = sizeNum.cy;
	di.ZoomDen.cx = sizeDen.cx;
	di.ZoomDen.cy = sizeDen.cy;
	if (sizeDen.cx == 0 || sizeDen.cy == 0 ||
		sizeNum.cx == 0 || sizeNum.cy == 0)
	{
		di.ZoomNum.cx = di.ZoomNum.cy = di.ZoomDen.cx = di.ZoomDen.cy = 1;
		di.bZoomed = FALSE;
	}
	else if (sizeNum.cx != sizeDen.cx || sizeNum.cy != sizeDen.cy)
		di.bZoomed = TRUE;
	else
		di.bZoomed = FALSE;
}

inline HRESULT CComControlBase::OnDrawAdvanced(ATL_DRAWINFO& di)
{
	BOOL bDeleteDC = FALSE;
	if (di.hicTargetDev == NULL)
	{
		di.hicTargetDev = AtlCreateTargetDC(di.hdcDraw, di.ptd);
		bDeleteDC = (di.hicTargetDev != di.hdcDraw);
	}
	RECTL rectBoundsDP = *di.prcBounds;
	BOOL bMetafile = GetDeviceCaps(di.hdcDraw, TECHNOLOGY) == DT_METAFILE;
	if (!bMetafile)
	{
		::LPtoDP(di.hicTargetDev, (LPPOINT)&rectBoundsDP, 2);
		SaveDC(di.hdcDraw);
		SetMapMode(di.hdcDraw, MM_TEXT);
		SetWindowOrgEx(di.hdcDraw, 0, 0, NULL);
		SetViewportOrgEx(di.hdcDraw, 0, 0, NULL);
		di.bOptimize = TRUE; //since we save the DC we can do this
	}
	di.prcBounds = &rectBoundsDP;
	GetZoomInfo(di);

	HRESULT hRes = OnDraw(di);
	if (bDeleteDC)
		::DeleteDC(di.hicTargetDev);
	if (!bMetafile)
		RestoreDC(di.hdcDraw, -1);
	return hRes;
}

inline LRESULT CComControlBase::OnPaint(UINT /* uMsg */, WPARAM wParam,
	LPARAM /* lParam */, BOOL& /* lResult */)
{
	RECT rc;
	PAINTSTRUCT ps;

	HDC hdc = (wParam != NULL) ? (HDC)wParam : ::BeginPaint(m_hWndCD, &ps);
	if (hdc == NULL)
		return 0;
	::GetClientRect(m_hWndCD, &rc);

	ATL_DRAWINFO di;
	memset(&di, 0, sizeof(di));
	di.cbSize = sizeof(di);
	di.dwDrawAspect = DVASPECT_CONTENT;
	di.lindex = -1;
	di.hdcDraw = hdc;
	di.prcBounds = (LPCRECTL)&rc;

	OnDrawAdvanced(di);
	if (wParam == NULL)
		::EndPaint(m_hWndCD, &ps);
	return 0;
}

template <class T, class WinBase =  CWindowImpl< T > >
class ATL_NO_VTABLE CComControl :  public CComControlBase, public WinBase
{
public:
	CComControl() : CComControlBase(m_hWnd) {}
	HRESULT FireOnRequestEdit(DISPID dispID)
	{
		T* pT = static_cast<T*>(this);
		return T::__ATL_PROP_NOTIFY_EVENT_CLASS::FireOnRequestEdit(pT->GetUnknown(), dispID);
	}
	HRESULT FireOnChanged(DISPID dispID)
	{
		T* pT = static_cast<T*>(this);
		return T::__ATL_PROP_NOTIFY_EVENT_CLASS::FireOnChanged(pT->GetUnknown(), dispID);
	}
	virtual HRESULT ControlQueryInterface(const IID& iid, void** ppv)
	{
		T* pT = static_cast<T*>(this);
		return pT->_InternalQueryInterface(iid, ppv);
	}
	virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos)
	{
		T* pT = static_cast<T*>(this);
		return pT->Create(hWndParent, rcPos);
	}

	typedef CComControl< T, WinBase >	thisClass;
	BEGIN_MSG_MAP(thisClass)
		MESSAGE_HANDLER(WM_PAINT, CComControlBase::OnPaint)
		MESSAGE_HANDLER(WM_SETFOCUS, CComControlBase::OnSetFocus)
		MESSAGE_HANDLER(WM_KILLFOCUS, CComControlBase::OnKillFocus)
		MESSAGE_HANDLER(WM_MOUSEACTIVATE, CComControlBase::OnMouseActivate)
	END_MSG_MAP()
};

//////////////////////////////////////////////////////////////////////////////
// CComCompositeControl

#ifndef _ATL_NO_HOSTING
template <class T>
class CComCompositeControl : public CComControl< T, CAxDialogImpl< T > >
{
public:
	CComCompositeControl()
	{
		m_hbrBackground = NULL;
	}
	~CComCompositeControl()
	{
		DeleteObject(m_hbrBackground);
	}
	HRESULT AdviseSinkMap(bool bAdvise)
	{
		if(!bAdvise && m_hWnd == NULL)
		{
			// window is gone, controls are already unadvised
			ATLTRACE2(atlTraceControls, 1, _T("CComCompositeControl::AdviseSinkMap called after the window was destroyed\n"));
			return S_OK;
		}
		T* pT = static_cast<T*>(this);
		return AtlAdviseSinkMap(pT, bAdvise);
	}
	HBRUSH m_hbrBackground;
	HRESULT SetBackgroundColorFromAmbient()
	{
		if (m_hbrBackground != NULL)
		{
			DeleteObject(m_hbrBackground);
			m_hbrBackground = NULL;
		}
		OLE_COLOR clr;
		HRESULT hr = GetAmbientBackColor(clr);
		if (SUCCEEDED(hr))
		{
			COLORREF rgb;
			::OleTranslateColor(clr, NULL, &rgb);
			m_hbrBackground = ::CreateSolidBrush(rgb);
			EnumChildWindows(m_hWnd, (WNDENUMPROC)BackgroundColorEnumProc, (LPARAM) clr);
		}
		return hr;
	}
	static BOOL CALLBACK BackgroundColorEnumProc(HWND hwnd, LPARAM l)
	{
		CAxWindow wnd(hwnd);
		CComPtr<IAxWinAmbientDispatch> spDispatch;
		wnd.QueryHost(&spDispatch);
		if (spDispatch != NULL)
			spDispatch->put_BackColor((OLE_COLOR)l);
		return TRUE;
	}
	LRESULT OnDialogColor(UINT, WPARAM w, LPARAM, BOOL&)
	{
		HDC dc = (HDC) w;
		LOGBRUSH lb;
		::GetObject(m_hbrBackground, sizeof(lb), (void*)&lb);
		::SetBkColor(dc, lb.lbColor);
		return (LRESULT)m_hbrBackground;
	}
	HWND Create(HWND hWndParent, RECT& /*rcPos*/, LPARAM dwInitParam = NULL)
	{
		CComControl< T, CAxDialogImpl< T > >::Create(hWndParent, dwInitParam);
		SetBackgroundColorFromAmbient();
		if (m_hWnd != NULL)
			ShowWindow(SW_SHOWNOACTIVATE);
		return m_hWnd;
	}
	BOOL CalcExtent(SIZE& size)
	{
		HINSTANCE hInstance = _Module.GetResourceInstance();
		LPCTSTR lpTemplateName = MAKEINTRESOURCE(T::IDD);
		HRSRC hDlgTempl = FindResource(hInstance, lpTemplateName, RT_DIALOG);
		if (hDlgTempl == NULL)
			return FALSE;
		HGLOBAL hResource = LoadResource(hInstance, hDlgTempl);
		DLGTEMPLATE* pDlgTempl = (DLGTEMPLATE*)LockResource(hResource);
		if (pDlgTempl == NULL)
			return FALSE;
		AtlGetDialogSize(pDlgTempl, &size);
		AtlPixelToHiMetric(&size, &size);
		return TRUE;
	}
//Implementation
	BOOL PreTranslateAccelerator(LPMSG pMsg, HRESULT& hRet)
	{
		hRet = S_OK;
		if ((pMsg->message < WM_KEYFIRST || pMsg->message > WM_KEYLAST) &&
		   (pMsg->message < WM_MOUSEFIRST || pMsg->message > WM_MOUSELAST))
			return FALSE;
		// find a direct child of the dialog from the window that has focus
		HWND hWndCtl = ::GetFocus();
		if (IsChild(hWndCtl) && ::GetParent(hWndCtl) != m_hWnd)
		{
			do
			{
				hWndCtl = ::GetParent(hWndCtl);
			}
			while (::GetParent(hWndCtl) != m_hWnd);
		}
		// give controls a chance to translate this message
		if (::SendMessage(hWndCtl, WM_FORWARDMSG, 0, (LPARAM)pMsg) == 1)
			return TRUE;

		// special handling for keyboard messages
		DWORD_PTR dwDlgCode = ::SendMessage(pMsg->hwnd, WM_GETDLGCODE, 0, 0L);
		switch(pMsg->message)
		{
		case WM_CHAR:
			if(dwDlgCode == 0)	// no dlgcode, possibly an ActiveX control
				return FALSE;	// let the container process this
			break;
		case WM_KEYDOWN:
			switch(LOWORD(pMsg->wParam))
			{
			case VK_TAB:
				// prevent tab from looping inside of our dialog
				if((dwDlgCode & DLGC_WANTTAB) == 0)
				{
					HWND hWndFirstOrLast = ::GetWindow(m_hWnd, GW_CHILD);
					if (::GetKeyState(VK_SHIFT) >= 0)  // not pressed
						hWndFirstOrLast = GetNextDlgTabItem(hWndFirstOrLast, TRUE);
					if (hWndFirstOrLast == hWndCtl)
						return FALSE;
				}
				break;
			case VK_LEFT:
			case VK_UP:
			case VK_RIGHT:
			case VK_DOWN:
				// prevent arrows from looping inside of our dialog
				if((dwDlgCode & DLGC_WANTARROWS) == 0)
				{
					HWND hWndFirstOrLast = ::GetWindow(m_hWnd, GW_CHILD);
					if (pMsg->wParam == VK_RIGHT || pMsg->wParam == VK_DOWN)	// going forward
						hWndFirstOrLast = GetNextDlgTabItem(hWndFirstOrLast, TRUE);
					if (hWndFirstOrLast == hWndCtl)
						return FALSE;
				}
				break;
			case VK_EXECUTE:
			case VK_RETURN:
			case VK_ESCAPE:
			case VK_CANCEL:
				// we don't want to handle these, let the container do it
				return FALSE;
			}
			break;
		}

		return IsDialogMessage(pMsg);
	}
	HRESULT IOleInPlaceObject_InPlaceDeactivate(void)
	{
		AdviseSinkMap(false); //unadvise
		return CComControl<T, CAxDialogImpl<T> >::IOleInPlaceObject_InPlaceDeactivate();
	}
	virtual HWND CreateControlWindow(HWND hWndParent, RECT& rcPos)
	{
		T* pT = static_cast<T*>(this);
		HWND h = pT->Create(hWndParent, rcPos);
		if (h != NULL)
			AdviseSinkMap(true);
		return h;
	}
	virtual HRESULT OnDraw(ATL_DRAWINFO& di)
	{
		if(!m_bInPlaceActive)
		{
			HPEN hPen = (HPEN)::GetStockObject(BLACK_PEN);
			HBRUSH hBrush = (HBRUSH)::GetStockObject(GRAY_BRUSH);
			::SelectObject(di.hdcDraw, hPen);
			::SelectObject(di.hdcDraw, hBrush);
			::Rectangle(di.hdcDraw, di.prcBounds->left, di.prcBounds->top, di.prcBounds->right, di.prcBounds->bottom);
			::SetTextColor(di.hdcDraw, ::GetSysColor(COLOR_WINDOWTEXT));
			::SetBkMode(di.hdcDraw, TRANSPARENT);
			::DrawText(di.hdcDraw, _T("ATL Composite Control"), -1, (LPRECT)di.prcBounds, DT_CENTER | DT_SINGLELINE | DT_VCENTER);
		}
		return S_OK;
	}
	typedef CComControl< T, CAxDialogImpl< T > >	baseClass;
	BEGIN_MSG_MAP(CComCompositeControl< T >)
		MESSAGE_HANDLER(WM_CTLCOLORDLG, OnDialogColor)
		MESSAGE_HANDLER(WM_CTLCOLORSTATIC, OnDialogColor)
		MESSAGE_HANDLER(WM_SETFOCUS, baseClass::OnSetFocus)
		MESSAGE_HANDLER(WM_KILLFOCUS, baseClass::OnKillFocus)
		MESSAGE_HANDLER(WM_MOUSEACTIVATE, baseClass::OnMouseActivate)
	END_MSG_MAP()

	BEGIN_SINK_MAP(T)
	END_SINK_MAP()
};
#endif //_ATL_NO_HOSTING

// Forward declarations
//
template <class T> class IPersistStorageImpl;
template <class T> class IPersistPropertyBagImpl;

template <class T> class IOleControlImpl;
template <class T> class IRunnableObjectImpl;
template <class T> class IQuickActivateImpl;
template <class T> class IOleObjectImpl;
template <class T> class IPropertyPageImpl;
template <class T> class IPropertyPage2Impl;
template <class T> class IPerPropertyBrowsingImpl;
template <class T> class IViewObjectExImpl;
template <class T> class IOleWindowImpl;
template <class T> class IPointerInactiveImpl;
template <class T, class CDV> class IPropertyNotifySinkCP;
template <class T> class IBindStatusCallbackImpl;
template <class T> class CBindStatusCallback;


//////////////////////////////////////////////////////////////////////////////
// IOleControlImpl
template <class T>
class ATL_NO_VTABLE IOleControlImpl : public IOleControl
{
public:
	STDMETHOD(GetControlInfo)(LPCONTROLINFO /* pCI */)
	{
		ATLTRACENOTIMPL(_T("IOleControlImpl::GetControlInfo"));
	}
	STDMETHOD(OnMnemonic)(LPMSG /* pMsg */)
	{
		ATLTRACENOTIMPL(_T("IOleControlImpl::OnMnemonic"));
	}
	STDMETHOD(OnAmbientPropertyChange)(DISPID dispid)
	{
		dispid;
		ATLTRACE2(atlTraceControls,2,_T("IOleControlImpl::OnAmbientPropertyChange\n"));
		ATLTRACE2(atlTraceControls,2,_T(" -- DISPID = %d (%d)\n"), dispid);
		return S_OK;
	}
	STDMETHOD(FreezeEvents)(BOOL bFreeze)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleControlImpl::FreezeEvents\n"));
		if (bFreeze)
			pT->m_nFreezeEvents++;
		else
			pT->m_nFreezeEvents--;
		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// IQuickActivateImpl
template <class T>
class ATL_NO_VTABLE IQuickActivateImpl : public IQuickActivate
{
public:
	STDMETHOD(QuickActivate)(QACONTAINER *pQACont, QACONTROL *pQACtrl)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IQuickActivateImpl::QuickActivate\n"));
		return pT->IQuickActivate_QuickActivate(pQACont, pQACtrl);
	}
	STDMETHOD(SetContentExtent)(LPSIZEL pSize)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IQuickActivateImpl::SetContentExtent\n"));
		return pT->IOleObjectImpl<T>::SetExtent(DVASPECT_CONTENT, pSize);
	}
	STDMETHOD(GetContentExtent)(LPSIZEL pSize)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IQuickActivateImpl::GetContentExtent\n"));
		return pT->IOleObjectImpl<T>::GetExtent(DVASPECT_CONTENT, pSize);
	}
};


//////////////////////////////////////////////////////////////////////////////
// IOleObjectImpl
template <class T>
class ATL_NO_VTABLE IOleObjectImpl : public IOleObject
{
public:
	STDMETHOD(SetClientSite)(IOleClientSite *pClientSite)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::SetClientSite\n"));
		return pT->IOleObject_SetClientSite(pClientSite);
	}
	STDMETHOD(GetClientSite)(IOleClientSite **ppClientSite)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::GetClientSite\n"));
		return pT->IOleObject_GetClientSite(ppClientSite);
	}
	STDMETHOD(SetHostNames)(LPCOLESTR /* szContainerApp */, LPCOLESTR /* szContainerObj */)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::SetHostNames\n"));
		return S_OK;
	}
	STDMETHOD(Close)(DWORD dwSaveOption)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::Close\n"));
		return pT->IOleObject_Close(dwSaveOption);
	}
	STDMETHOD(SetMoniker)(DWORD /* dwWhichMoniker */, IMoniker* /* pmk */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::SetMoniker"));
	}
	STDMETHOD(GetMoniker)(DWORD /* dwAssign */, DWORD /* dwWhichMoniker */, IMoniker** /* ppmk */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::GetMoniker"));
	}
	STDMETHOD(InitFromData)(IDataObject* /* pDataObject */, BOOL /* fCreation */, DWORD /* dwReserved */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::InitFromData"));
	}
	STDMETHOD(GetClipboardData)(DWORD /* dwReserved */, IDataObject** /* ppDataObject */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::GetClipboardData"));
	}

	// Helpers for DoVerb - Over-rideable in user class
	HRESULT DoVerbPrimary(LPCRECT prcPosRect, HWND hwndParent)
	{
		T* pT = static_cast<T*>(this);
		BOOL bDesignMode = FALSE;
		CComVariant var;
		// if container doesn't support this property
		// don't allow design mode
		HRESULT hRes = pT->GetAmbientProperty(DISPID_AMBIENT_USERMODE, var);
		if (SUCCEEDED(hRes) && var.vt == VT_BOOL && !var.boolVal)
			bDesignMode = TRUE;
		if (bDesignMode)
			return pT->DoVerbProperties(prcPosRect, hwndParent);
		else
			return pT->DoVerbInPlaceActivate(prcPosRect, hwndParent);
	}
	HRESULT DoVerbShow(LPCRECT prcPosRect, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr;
		hr = pT->OnPreVerbShow();
		if (SUCCEEDED(hr))
		{
			hr = pT->InPlaceActivate(OLEIVERB_SHOW, prcPosRect);
			if (SUCCEEDED(hr))
				hr = pT->OnPostVerbShow();
		}
		return hr;
	}
	HRESULT DoVerbInPlaceActivate(LPCRECT prcPosRect, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr;
		hr = pT->OnPreVerbInPlaceActivate();
		if (SUCCEEDED(hr))
		{
			hr = pT->InPlaceActivate(OLEIVERB_INPLACEACTIVATE, prcPosRect);
			if (SUCCEEDED(hr))
				hr = pT->OnPostVerbInPlaceActivate();
			if (SUCCEEDED(hr))
				pT->FireViewChange();
		}
		return hr;
	}
	HRESULT DoVerbUIActivate(LPCRECT prcPosRect, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr = S_OK;
		if (!pT->m_bUIActive)
		{
			hr = pT->OnPreVerbUIActivate();
			if (SUCCEEDED(hr))
			{
				hr = pT->InPlaceActivate(OLEIVERB_UIACTIVATE, prcPosRect);
				if (SUCCEEDED(hr))
					hr = pT->OnPostVerbUIActivate();
			}
		}
		return hr;
	}
	HRESULT DoVerbHide(LPCRECT /* prcPosRect */, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr;
		hr = pT->OnPreVerbHide();
		if (SUCCEEDED(hr))
		{
			pT->UIDeactivate();
			if (pT->m_hWnd)
				pT->ShowWindow(SW_HIDE);
			hr = pT->OnPostVerbHide();
		}
		return hr;
	}
	HRESULT DoVerbOpen(LPCRECT /* prcPosRect */, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr;
		hr = pT->OnPreVerbOpen();
		if (SUCCEEDED(hr))
			hr = pT->OnPostVerbOpen();
		return hr;
	}
	HRESULT DoVerbDiscardUndo(LPCRECT /* prcPosRect */, HWND /* hwndParent */)
	{
		T* pT = static_cast<T*>(this);
		HRESULT hr;
		hr = pT->OnPreVerbDiscardUndo();
		if (SUCCEEDED(hr))
			hr = pT->OnPostVerbDiscardUndo();
		return hr;
	}
	STDMETHOD(DoVerb)(LONG iVerb, LPMSG /* pMsg */, IOleClientSite* /* pActiveSite */, LONG /* lindex */,
									 HWND hwndParent, LPCRECT lprcPosRect)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::DoVerb(%d)\n"), iVerb);
		ATLASSERT(pT->m_spClientSite);

		HRESULT hr = E_NOTIMPL;
		switch (iVerb)
		{
		case OLEIVERB_PRIMARY:
			hr = pT->DoVerbPrimary(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_SHOW:
			hr = pT->DoVerbShow(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_INPLACEACTIVATE:
			hr = pT->DoVerbInPlaceActivate(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_UIACTIVATE:
			hr = pT->DoVerbUIActivate(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_HIDE:
			hr = pT->DoVerbHide(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_OPEN:
			hr = pT->DoVerbOpen(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_DISCARDUNDOSTATE:
			hr = pT->DoVerbDiscardUndo(lprcPosRect, hwndParent);
			break;
		case OLEIVERB_PROPERTIES:
			hr = pT->DoVerbProperties(lprcPosRect, hwndParent);
		}
		return hr;
	}
	STDMETHOD(EnumVerbs)(IEnumOLEVERB **ppEnumOleVerb)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::EnumVerbs\n"));
		ATLASSERT(ppEnumOleVerb);
		if (!ppEnumOleVerb)
			return E_POINTER;
		return OleRegEnumVerbs(T::GetObjectCLSID(), ppEnumOleVerb);
	}
	STDMETHOD(Update)(void)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::Update\n"));
		return S_OK;
	}
	STDMETHOD(IsUpToDate)(void)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::IsUpToDate\n"));
		return S_OK;
	}
	STDMETHOD(GetUserClassID)(CLSID *pClsid)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::GetUserClassID\n"));
		ATLASSERT(pClsid);
		if (!pClsid)
			return E_POINTER;
		*pClsid = T::GetObjectCLSID();
		return S_OK;
	}
	STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR *pszUserType)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::GetUserType\n"));
		return OleRegGetUserType(T::GetObjectCLSID(), dwFormOfType, pszUserType);
	}
	STDMETHOD(SetExtent)(DWORD dwDrawAspect, SIZEL *psizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::SetExtent\n"));
		return pT->IOleObject_SetExtent(dwDrawAspect, psizel);
	}
	STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL *psizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::GetExtent\n"));
		if (dwDrawAspect != DVASPECT_CONTENT)
			return E_FAIL;
		if (psizel == NULL)
			return E_POINTER;
		*psizel = pT->m_sizeExtent;
		return S_OK;
	}
	STDMETHOD(Advise)(IAdviseSink *pAdvSink, DWORD *pdwConnection)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::Advise\n"));
		return pT->IOleObject_Advise(pAdvSink, pdwConnection);
	}
	STDMETHOD(Unadvise)(DWORD dwConnection)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::Unadvise\n"));
		HRESULT hRes = E_FAIL;
		if (pT->m_spOleAdviseHolder != NULL)
			hRes = pT->m_spOleAdviseHolder->Unadvise(dwConnection);
		return hRes;
	}
	STDMETHOD(EnumAdvise)(IEnumSTATDATA **ppenumAdvise)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::EnumAdvise\n"));
		HRESULT hRes = E_FAIL;
		if (pT->m_spOleAdviseHolder != NULL)
			hRes = pT->m_spOleAdviseHolder->EnumAdvise(ppenumAdvise);
		return hRes;
	}
	STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD *pdwStatus)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleObjectImpl::GetMiscStatus\n"));
		return OleRegGetMiscStatus(T::GetObjectCLSID(), dwAspect, pdwStatus);
	}
	STDMETHOD(SetColorScheme)(LOGPALETTE* /* pLogpal */)
	{
		ATLTRACENOTIMPL(_T("IOleObjectImpl::SetColorScheme"));
	}
// Implementation
public:
	HRESULT OnPreVerbShow() { return S_OK; }
	HRESULT OnPostVerbShow() { return S_OK; }
	HRESULT OnPreVerbInPlaceActivate() { return S_OK; }
	HRESULT OnPostVerbInPlaceActivate() { return S_OK; }
	HRESULT OnPreVerbUIActivate() { return S_OK; }
	HRESULT OnPostVerbUIActivate() { return S_OK; }
	HRESULT OnPreVerbHide() { return S_OK; }
	HRESULT OnPostVerbHide() { return S_OK; }
	HRESULT OnPreVerbOpen() { return S_OK; }
	HRESULT OnPostVerbOpen() { return S_OK; }
	HRESULT OnPreVerbDiscardUndo() { return S_OK; }
	HRESULT OnPostVerbDiscardUndo() { return S_OK; }
};

//local struct used for implementation
#pragma pack(push, 1)
struct _ATL_DLGTEMPLATEEX
{
	WORD dlgVer;
	WORD signature;
	DWORD helpID;
	DWORD exStyle;
	DWORD style;
	WORD cDlgItems;
	short x;
	short y;
	short cx;
	short cy;
};
#pragma pack(pop)

//////////////////////////////////////////////////////////////////////////////
// IPropertyPageImpl
template <class T>
class ATL_NO_VTABLE IPropertyPageImpl : public IPropertyPage
{

public:
	void SetDirty(BOOL bDirty)
	{
		T* pT = static_cast<T*>(this);
		if (pT->m_bDirty != bDirty)
		{
			pT->m_bDirty = bDirty;
			pT->m_pPageSite->OnStatusChange(bDirty ? PROPPAGESTATUS_DIRTY | PROPPAGESTATUS_VALIDATE : 0);
		}
	}

	IPropertyPageImpl()
	{
		T* pT = static_cast<T*>(this);
		pT->m_pPageSite = NULL;
		pT->m_size.cx = 0;
		pT->m_size.cy = 0;
		pT->m_dwTitleID = 0;
		pT->m_dwHelpFileID = 0;
		pT->m_dwDocStringID = 0;
		pT->m_dwHelpContext = 0;
		pT->m_ppUnk = NULL;
		pT->m_nObjects = 0;
		pT->m_bDirty = FALSE;
		pT->m_hWnd = NULL;
	}

	~IPropertyPageImpl()
	{
		T* pT = static_cast<T*>(this);
		if (pT->m_pPageSite != NULL)
			pT->m_pPageSite->Release();

		for (UINT i = 0; i < m_nObjects; i++)
			pT->m_ppUnk[i]->Release();

		delete[] pT->m_ppUnk;
	}

	// IPropertyPage
	//
	STDMETHOD(SetPageSite)(IPropertyPageSite *pPageSite)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::SetPageSite\n"));

		if (!pPageSite && pT->m_pPageSite)
		{
			pT->m_pPageSite->Release();
			pT->m_pPageSite = NULL;
			return S_OK;
		}

		if (!pPageSite && !pT->m_pPageSite)
			return S_OK;

		if (pPageSite && pT->m_pPageSite)
		{
			ATLTRACE2(atlTraceControls,2,_T("Error : setting page site again with non NULL value\n"));
			return E_UNEXPECTED;
		}

		pT->m_pPageSite = pPageSite;
		pT->m_pPageSite->AddRef();
		return S_OK;
	}
	STDMETHOD(Activate)(HWND hWndParent, LPCRECT pRect, BOOL /* bModal */)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Activate\n"));

		if (pRect == NULL)
		{
			ATLTRACE2(atlTraceControls,2,_T("Error : Passed a NULL rect\n"));
			return E_POINTER;
		}

		pT->m_hWnd = pT->Create(hWndParent);
		Move(pRect);

		m_size.cx = pRect->right - pRect->left;
		m_size.cy = pRect->bottom - pRect->top;

		return S_OK;

	}
	STDMETHOD(Deactivate)( void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Deactivate\n"));

		if (pT->m_hWnd)
		{
			ATLTRACE2(atlTraceControls,2,_T("Destroying Dialog\n"));
			if (::IsWindow(pT->m_hWnd))
				pT->DestroyWindow();
			pT->m_hWnd = NULL;
		}

		return S_OK;

	}
	STDMETHOD(GetPageInfo)(PROPPAGEINFO *pPageInfo)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::GetPageInfo\n"));

		if (pPageInfo == NULL)
		{
			ATLTRACE2(atlTraceControls,2,_T("Error : PROPPAGEINFO passed == NULL\n"));
			return E_POINTER;
		}

		HRSRC hRsrc = FindResource(_Module.GetResourceInstance(),
								   MAKEINTRESOURCE(T::IDD), RT_DIALOG);
		if (hRsrc == NULL)
		{
			ATLTRACE2(atlTraceControls,2,_T("Could not find resource template\n"));
			return E_UNEXPECTED;
		}

		HGLOBAL hGlob = LoadResource(_Module.GetResourceInstance(), hRsrc);
		DLGTEMPLATE* pDlgTempl = (DLGTEMPLATE*)LockResource(hGlob);
		if (pDlgTempl == NULL)
		{
			ATLTRACE2(atlTraceControls,2,_T("Could not load resource template\n"));
			return E_UNEXPECTED;
		}
		AtlGetDialogSize(pDlgTempl, &m_size);

		pPageInfo->cb = sizeof(PROPPAGEINFO);
		pPageInfo->pszTitle = LoadStringHelper(pT->m_dwTitleID);
		pPageInfo->size = m_size;
		pPageInfo->pszHelpFile = LoadStringHelper(pT->m_dwHelpFileID);
		pPageInfo->pszDocString = LoadStringHelper(pT->m_dwDocStringID);
		pPageInfo->dwHelpContext = pT->m_dwHelpContext;

		return S_OK;
	}

	STDMETHOD(SetObjects)(ULONG nObjects, IUnknown **ppUnk)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::SetObjects\n"));

		if (ppUnk == NULL)
			return E_POINTER;

		if (pT->m_ppUnk != NULL && pT->m_nObjects > 0)
		{
			for (UINT iObj = 0; iObj < pT->m_nObjects; iObj++)
				pT->m_ppUnk[iObj]->Release();

			delete [] pT->m_ppUnk;
		}

		pT->m_ppUnk = NULL;
		ATLTRY(pT->m_ppUnk = new IUnknown*[nObjects]);

		if (pT->m_ppUnk == NULL)
			return E_OUTOFMEMORY;

		for (UINT i = 0; i < nObjects; i++)
		{
			ppUnk[i]->AddRef();
			pT->m_ppUnk[i] = ppUnk[i];
		}

		pT->m_nObjects = nObjects;

		return S_OK;
	}
	STDMETHOD(Show)(UINT nCmdShow)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Show\n"));

		if (pT->m_hWnd == NULL)
			return E_UNEXPECTED;

		ShowWindow(pT->m_hWnd, nCmdShow);
		return S_OK;
	}
	STDMETHOD(Move)(LPCRECT pRect)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Move\n"));

		if (pT->m_hWnd == NULL)
			return E_UNEXPECTED;

		if (pRect == NULL)
			return E_POINTER;

		MoveWindow(pT->m_hWnd, pRect->left, pRect->top, pRect->right - pRect->left,
				 pRect->bottom - pRect->top, TRUE);

		return S_OK;

	}
	STDMETHOD(IsPageDirty)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::IsPageDirty\n"));
		return pT->m_bDirty ? S_OK : S_FALSE;
	}
	STDMETHOD(Apply)(void)
	{
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Apply\n"));
		return S_OK;
	}
	STDMETHOD(Help)(LPCOLESTR pszHelpDir)
	{
		T* pT = static_cast<T*>(this);
		USES_CONVERSION;

		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::Help\n"));
		CComBSTR szFullFileName(pszHelpDir);
		LPOLESTR szFileName = LoadStringHelper(pT->m_dwHelpFileID);
		szFullFileName.Append(OLESTR("\\"));
		szFullFileName.Append(szFileName);
		CoTaskMemFree(szFileName);
		WinHelp(pT->m_hWnd, OLE2CT(szFullFileName), HELP_CONTEXTPOPUP, NULL);
		return S_OK;
	}
	STDMETHOD(TranslateAccelerator)(MSG *pMsg)
	{
		ATLTRACE2(atlTraceControls,2,_T("IPropertyPageImpl::TranslateAccelerator\n"));
		T* pT = static_cast<T*>(this);
		if ((pMsg->message < WM_KEYFIRST || pMsg->message > WM_KEYLAST) &&
			(pMsg->message < WM_MOUSEFIRST || pMsg->message > WM_MOUSELAST))
			return S_FALSE;

		return (IsDialogMessage(pT->m_hWnd, pMsg)) ? S_OK : S_FALSE;
	}

	IPropertyPageSite* m_pPageSite;
	IUnknown** m_ppUnk;
	ULONG m_nObjects;
	SIZE m_size;
	UINT m_dwTitleID;
	UINT m_dwHelpFileID;
	UINT m_dwDocStringID;
	DWORD m_dwHelpContext;
	BOOL m_bDirty;

//methods
public:

	BEGIN_MSG_MAP(IPropertyPageImpl<T>)
		MESSAGE_HANDLER(WM_STYLECHANGING, OnStyleChange)
	END_MSG_MAP()

	LRESULT OnStyleChange(UINT, WPARAM wParam, LPARAM lParam, BOOL&)
	{
		if (wParam == GWL_EXSTYLE)
		{
			LPSTYLESTRUCT lpss = (LPSTYLESTRUCT) lParam;
			lpss->styleNew |= WS_EX_CONTROLPARENT;
			return 0;
		}
		return 1;
	}

	LPOLESTR LoadStringHelper(UINT idRes)
	{
		USES_CONVERSION;

		TCHAR szTemp[_MAX_PATH];
		LPOLESTR sz;
		sz = (LPOLESTR)CoTaskMemAlloc(_MAX_PATH*sizeof(OLECHAR));
		if (sz == NULL)
			return NULL;
		sz[0] = NULL;

		if (LoadString(_Module.GetResourceInstance(), idRes, szTemp, _MAX_PATH))
			ocscpy(sz, T2OLE(szTemp));
		else
		{
			ATLTRACE2(atlTraceControls,2,_T("Error : Failed to load string from res\n"));
		}

		return sz;
	}
};


//////////////////////////////////////////////////////////////////////////////
// IPropertyPage2Impl
template <class T>
class ATL_NO_VTABLE IPropertyPage2Impl : public IPropertyPageImpl<T>
{
public:

	STDMETHOD(EditProperty)(DISPID dispID)
	{
		ATLTRACENOTIMPL(_T("IPropertyPage2Impl::EditProperty\n"));
	}
};



//////////////////////////////////////////////////////////////////////////////
// IPerPropertyBrowsingImpl
template <class T>
class ATL_NO_VTABLE IPerPropertyBrowsingImpl : public IPerPropertyBrowsing
{
public:
	STDMETHOD(GetDisplayString)(DISPID dispID,BSTR *pBstr)
	{
		ATLTRACE2(atlTraceControls,2,_T("IPerPropertyBrowsingImpl::GetDisplayString\n"));
		T* pT = static_cast<T*>(this);
		*pBstr = NULL;
		CComVariant var;
		if (FAILED(CComDispatchDriver::GetProperty(pT, dispID, &var)))
			return S_FALSE;

		BSTR bstrTemp = var.bstrVal;
		if (var.vt != VT_BSTR)
		{
			CComVariant varDest;
			if (FAILED(::VariantChangeType(&varDest, &var, VARIANT_NOVALUEPROP, VT_BSTR)))
				return S_FALSE;
			bstrTemp = varDest.bstrVal;
		}
		*pBstr = SysAllocString(bstrTemp);
		if (*pBstr == NULL)
			return E_OUTOFMEMORY;
		return S_OK;
	}

	STDMETHOD(MapPropertyToPage)(DISPID dispID, CLSID *pClsid)
	{
		ATLTRACE2(atlTraceControls,2,_T("IPerPropertyBrowsingImpl::MapPropertyToPage\n"));
		ATL_PROPMAP_ENTRY* pMap = T::GetPropertyMap();
		ATLASSERT(pMap != NULL);
		for (int i = 0; pMap[i].pclsidPropPage != NULL; i++)
		{
			if (pMap[i].szDesc == NULL)
				continue;

			// reject data entry types
			if (pMap[i].dwSizeData != 0)
				continue;

			if (pMap[i].dispid == dispID)
			{
				ATLASSERT(pMap[i].pclsidPropPage != NULL);
				*pClsid = *(pMap[i].pclsidPropPage);
				return S_OK;
			}
		}
		*pClsid = CLSID_NULL;
		return E_INVALIDARG;
	}
	STDMETHOD(GetPredefinedStrings)(DISPID dispID, CALPOLESTR *pCaStringsOut,CADWORD *pCaCookiesOut)
	{
		dispID;
		ATLTRACE2(atlTraceControls,2,_T("IPerPropertyBrowsingImpl::GetPredefinedStrings\n"));
		if (pCaStringsOut == NULL || pCaCookiesOut == NULL)
			return E_POINTER;

		pCaStringsOut->cElems = 0;
		pCaStringsOut->pElems = NULL;
		pCaCookiesOut->cElems = 0;
		pCaCookiesOut->pElems = NULL;
		return S_OK;
	}
	STDMETHOD(GetPredefinedValue)(DISPID /*dispID*/, DWORD /*dwCookie*/, VARIANT* /*pVarOut*/)
	{
		ATLTRACENOTIMPL(_T("IPerPropertyBrowsingImpl::GetPredefinedValue"));
	}
};

//////////////////////////////////////////////////////////////////////////////
// IViewObjectExImpl
template <class T>
class ATL_NO_VTABLE IViewObjectExImpl : public IViewObjectEx
{
public:
	STDMETHOD(Draw)(DWORD dwDrawAspect, LONG lindex, void *pvAspect,
					DVTARGETDEVICE *ptd, HDC hicTargetDev, HDC hdcDraw,
					LPCRECTL prcBounds, LPCRECTL prcWBounds,
					BOOL (__stdcall * /*pfnContinue*/)(DWORD_PTR dwContinue),
					DWORD_PTR /*dwContinue*/)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::Draw\n"));
		return pT->IViewObject_Draw(dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev, hdcDraw,
			prcBounds, prcWBounds);
	}

	STDMETHOD(GetColorSet)(DWORD /* dwDrawAspect */,LONG /* lindex */, void* /* pvAspect */, DVTARGETDEVICE* /* ptd */, HDC /* hicTargetDev */, LOGPALETTE** /* ppColorSet */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::GetColorSet"));
	}
	STDMETHOD(Freeze)(DWORD /* dwDrawAspect */, LONG /* lindex */, void* /* pvAspect */,DWORD* /* pdwFreeze */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::Freeze"));
	}
	STDMETHOD(Unfreeze)(DWORD /* dwFreeze */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::Unfreeze"));
	}
	STDMETHOD(SetAdvise)(DWORD /* aspects */, DWORD /* advf */, IAdviseSink* pAdvSink)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::SetAdvise\n"));
		pT->m_spAdviseSink = pAdvSink;
		return S_OK;
	}
	STDMETHOD(GetAdvise)(DWORD* /* pAspects */, DWORD* /* pAdvf */, IAdviseSink** ppAdvSink)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::GetAdvise\n"));
		if (ppAdvSink != NULL)
		{
			*ppAdvSink = pT->m_spAdviseSink;
			if (pT->m_spAdviseSink)
				pT->m_spAdviseSink.p->AddRef();
		}
		return S_OK;
	}

	// IViewObject2
	//
	STDMETHOD(GetExtent)(DWORD /* dwDrawAspect */, LONG /* lindex */, DVTARGETDEVICE* /* ptd */, LPSIZEL lpsizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::GetExtent\n"));
		*lpsizel = pT->m_sizeExtent;
		return S_OK;
	}

	// IViewObjectEx
	//
	STDMETHOD(GetRect)(DWORD /* dwAspect */, LPRECTL /* pRect */)
	{
		ATLTRACENOTIMPL(_T("IViewObjectExImpl::GetRect"));
	}

	STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::GetViewStatus\n"));
		*pdwStatus = pT->_GetViewStatus();
		return S_OK;
	}
	STDMETHOD(QueryHitPoint)(DWORD dwAspect, LPCRECT pRectBounds, POINT ptlLoc, LONG /* lCloseHint */, DWORD *pHitResult)
	{
		ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::QueryHitPoint\n"));
		if (dwAspect == DVASPECT_CONTENT)
		{
			*pHitResult = PtInRect(pRectBounds, ptlLoc) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
			return S_OK;
		}
		ATLTRACE2(atlTraceControls,2,_T("Wrong DVASPECT\n"));
		return E_FAIL;
	}
	STDMETHOD(QueryHitRect)(DWORD dwAspect, LPCRECT pRectBounds, LPCRECT prcLoc, LONG /* lCloseHint */, DWORD* pHitResult)
	{
		ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::QueryHitRect\n"));
		if (dwAspect == DVASPECT_CONTENT)
		{
			RECT rc;
			*pHitResult = UnionRect(&rc, pRectBounds, prcLoc) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
			return S_OK;
		}
		ATLTRACE2(atlTraceControls,2,_T("Wrong DVASPECT\n"));
		return E_FAIL;
	}
	STDMETHOD(GetNaturalExtent)(DWORD dwAspect, LONG /* lindex */, DVTARGETDEVICE* /* ptd */, HDC /* hicTargetDev */, DVEXTENTINFO* pExtentInfo , LPSIZEL psizel)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IViewObjectExImpl::GetNaturalExtent\n"));
		HRESULT hRes = E_FAIL;
		if (pExtentInfo == NULL || psizel == NULL)
			hRes = E_POINTER;
		else if (dwAspect == DVASPECT_CONTENT)
		{
			if (pExtentInfo->dwExtentMode == DVEXTENT_CONTENT)
			{
				*psizel = pT->m_sizeNatural;
				hRes = S_OK;
			}
		}
		return hRes;
	}

public:
};

//////////////////////////////////////////////////////////////////////////////
// IOleInPlaceObjectWindowlessImpl
//
template <class T>
class ATL_NO_VTABLE IOleInPlaceObjectWindowlessImpl : public IOleInPlaceObjectWindowless
{
public:
	// IOleWindow
	//

	// Change IOleInPlaceActiveObject::GetWindow as well
	STDMETHOD(GetWindow)(HWND* phwnd)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::GetWindow\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hRes = E_POINTER;

		if (pT->m_bWasOnceWindowless)
			return E_FAIL;

		if (phwnd != NULL)
		{
			*phwnd = pT->m_hWnd;
			hRes = (*phwnd == NULL) ? E_UNEXPECTED : S_OK;
		}
		return hRes;
	}
	STDMETHOD(ContextSensitiveHelp)(BOOL /* fEnterMode */)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::ContextSensitiveHelp"));
	}

	// IOleInPlaceObject
	//
	STDMETHOD(InPlaceDeactivate)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::InPlaceDeactivate\n"));
		return pT->IOleInPlaceObject_InPlaceDeactivate();
	}
	STDMETHOD(UIDeactivate)(void)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::UIDeactivate\n"));
		return pT->IOleInPlaceObject_UIDeactivate();
	}
	STDMETHOD(SetObjectRects)(LPCRECT prcPos,LPCRECT prcClip)
	{
		T* pT = static_cast<T*>(this);
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::SetObjectRects\n"));
		return pT->IOleInPlaceObject_SetObjectRects(prcPos, prcClip);
	}
	STDMETHOD(ReactivateAndUndo)(void)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::ReactivateAndUndo"));
	}

	// IOleInPlaceObjectWindowless
	//
	STDMETHOD(OnWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceObjectWindowlessImpl::OnWindowMessage\n"));
		T* pT = static_cast<T*>(this);
		BOOL b = pT->ProcessWindowMessage(pT->m_hWnd, msg, wParam, lParam, *plResult);
		return b ? S_OK : S_FALSE;
	}

	STDMETHOD(GetDropTarget)(IDropTarget** /* ppDropTarget */)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceObjectWindowlessImpl::GetDropTarget"));
	}
};


//////////////////////////////////////////////////////////////////////////////
// IOleInPlaceActiveObjectImpl
//
template <class T>
class ATL_NO_VTABLE IOleInPlaceActiveObjectImpl : public IOleInPlaceActiveObject
{
public:
	// IOleWindow
	//

	// Change IOleInPlaceObjectWindowless::GetWindow as well
	STDMETHOD(GetWindow)(HWND *phwnd)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::GetWindow\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hRes = E_POINTER;

		if (pT->m_bWasOnceWindowless)
			return E_FAIL;

		if (phwnd != NULL)
		{
			*phwnd = pT->m_hWnd;
			hRes = (*phwnd == NULL) ? E_UNEXPECTED : S_OK;
		}
		return hRes;
	}
	STDMETHOD(ContextSensitiveHelp)(BOOL /* fEnterMode */)
	{
		ATLTRACENOTIMPL(_T("IOleInPlaceActiveObjectImpl::ContextSensitiveHelp"));
	}

	// IOleInPlaceActiveObject
	//
	STDMETHOD(TranslateAccelerator)(LPMSG pMsg)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::TranslateAccelerator\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hRet = S_OK;
		if (pT->PreTranslateAccelerator(pMsg, hRet))
			return hRet;
		CComPtr<IOleControlSite> spCtlSite;
		hRet = pT->InternalGetSite(IID_IOleControlSite, (void**)&spCtlSite);
		if (SUCCEEDED(hRet))
		{
			if (spCtlSite != NULL)
			{
				DWORD dwKeyMod = 0;
				if (::GetKeyState(VK_SHIFT) < 0)
					dwKeyMod += 1;	// KEYMOD_SHIFT
				if (::GetKeyState(VK_CONTROL) < 0)
					dwKeyMod += 2;	// KEYMOD_CONTROL
				if (::GetKeyState(VK_MENU) < 0)
					dwKeyMod += 4;	// KEYMOD_ALT
				hRet = spCtlSite->TranslateAccelerator(pMsg, dwKeyMod);
			}
			else
				hRet = S_FALSE;
		}
		return (hRet == S_OK) ? S_OK : S_FALSE;
	}
	STDMETHOD(OnFrameWindowActivate)(BOOL /* fActivate */)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::OnFrameWindowActivate\n"));
		return S_OK;
	}
	STDMETHOD(OnDocWindowActivate)(BOOL fActivate)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::OnDocWindowActivate\n"));
		T* pT = static_cast<T*>(this);
		if (fActivate == FALSE)
			pT->IOleInPlaceObject_UIDeactivate();
		return S_OK;
	}
	STDMETHOD(ResizeBorder)(LPCRECT /* prcBorder */, IOleInPlaceUIWindow* /* pUIWindow */, BOOL /* fFrameWindow */)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::ResizeBorder\n"));
		return S_OK;
	}
	STDMETHOD(EnableModeless)(BOOL /* fEnable */)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleInPlaceActiveObjectImpl::EnableModeless\n"));
		return S_OK;
	}
};

//////////////////////////////////////////////////////////////////////////////
// IPointerInactiveImpl
template <class T>
class ATL_NO_VTABLE IPointerInactiveImpl : public IPointerInactive
{
public:
	// IPointerInactive
	//
	STDMETHOD(GetActivationPolicy)(DWORD *pdwPolicy)
	{
		ATLTRACENOTIMPL(_T("IPointerInactiveImpl::GetActivationPolicy"));
	}
	STDMETHOD(OnInactiveMouseMove)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg)
	{
		ATLTRACENOTIMPL(_T("IPointerInactiveImpl::OnInactiveMouseMove"));
	}
	STDMETHOD(OnInactiveSetCursor)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg, BOOL fSetAlways)
	{
		ATLTRACENOTIMPL(_T("IPointerInactiveImpl::OnInactiveSetCursor"));
	}
};

//////////////////////////////////////////////////////////////////////////////
// IRunnableObjectImpl
template <class T>
class ATL_NO_VTABLE IRunnableObjectImpl : public IRunnableObject
{
public:
	// IRunnableObject
	//
	STDMETHOD(GetRunningClass)(LPCLSID lpClsid)
	{
		ATLTRACE2(atlTraceControls,2,_T("IRunnableObjectImpl::GetRunningClass\n"));
		*lpClsid = GUID_NULL;
		return E_UNEXPECTED;
	}
	STDMETHOD(Run)(LPBINDCTX)
	{
		ATLTRACE2(atlTraceControls,2,_T("IRunnableObjectImpl::Run\n"));
		return S_OK;
	}
	virtual BOOL STDMETHODCALLTYPE IsRunning()
	{
		ATLTRACE2(atlTraceControls,2,_T("IRunnableObjectImpl::IsRunning\n"));
		return TRUE;
	}
	STDMETHOD(LockRunning)(BOOL /*fLock*/, BOOL /*fLastUnlockCloses*/)
	{
		ATLTRACE2(atlTraceControls,2,_T("IRunnableObjectImpl::LockRunning\n"));
		return S_OK;
	}
	STDMETHOD(SetContainedObject)(BOOL /*fContained*/)
	{
		ATLTRACE2(atlTraceControls,2,_T("IRunnableObjectImpl::SetContainedObject\n"));
		return S_OK;
	}
};


//////////////////////////////////////////////////////////////////////////////
// IDataObjectImpl
template <class T>
class ATL_NO_VTABLE IDataObjectImpl : public IDataObject
{
public:
	STDMETHOD(GetData)(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
	{
		ATLTRACE2(atlTraceControls,2,_T("IDataObjectImpl::GetData\n"));
		T* pT = (T*) this;
		return pT->IDataObject_GetData(pformatetcIn, pmedium);
	}
	STDMETHOD(GetDataHere)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::GetDataHere"));
	}
	STDMETHOD(QueryGetData)(FORMATETC* /* pformatetc */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::QueryGetData"));
	}
	STDMETHOD(GetCanonicalFormatEtc)(FORMATETC* /* pformatectIn */,FORMATETC* /* pformatetcOut */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::GetCanonicalFormatEtc"));
	}
	STDMETHOD(SetData)(FORMATETC* /* pformatetc */, STGMEDIUM* /* pmedium */, BOOL /* fRelease */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::SetData"));
	}
	STDMETHOD(EnumFormatEtc)(DWORD /* dwDirection */, IEnumFORMATETC** /* ppenumFormatEtc */)
	{
		ATLTRACENOTIMPL(_T("IDataObjectImpl::EnumFormatEtc"));
	}
	STDMETHOD(DAdvise)(FORMATETC *pformatetc, DWORD advf, IAdviseSink *pAdvSink,
		DWORD *pdwConnection)
	{
		ATLTRACE2(atlTraceControls,2,_T("IDataObjectImpl::DAdvise\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hr = S_OK;
		if (pT->m_spDataAdviseHolder == NULL)
			hr = CreateDataAdviseHolder(&pT->m_spDataAdviseHolder);

		if (hr == S_OK)
			hr = pT->m_spDataAdviseHolder->Advise((IDataObject*)this, pformatetc, advf, pAdvSink, pdwConnection);

		return hr;
	}
	STDMETHOD(DUnadvise)(DWORD dwConnection)
	{
		ATLTRACE2(atlTraceControls,2,_T("IDataObjectImpl::DUnadvise\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hr = S_OK;
		if (pT->m_spDataAdviseHolder == NULL)
			hr = OLE_E_NOCONNECTION;
		else
			hr = pT->m_spDataAdviseHolder->Unadvise(dwConnection);
		return hr;
	}
	STDMETHOD(EnumDAdvise)(IEnumSTATDATA **ppenumAdvise)
	{
		ATLTRACE2(atlTraceControls,2,_T("IDataObjectImpl::EnumDAdvise\n"));
		T* pT = static_cast<T*>(this);
		HRESULT hr = E_FAIL;
		if (pT->m_spDataAdviseHolder != NULL)
			hr = pT->m_spDataAdviseHolder->EnumAdvise(ppenumAdvise);
		return hr;
	}
};

//////////////////////////////////////////////////////////////////////////////
// IPropertyNotifySinkCP
template <class T, class CDV = CComDynamicUnkArray >
class ATL_NO_VTABLE IPropertyNotifySinkCP :
	public IConnectionPointImpl<T, &IID_IPropertyNotifySink, CDV>
{
public:
	typedef CFirePropNotifyEvent _ATL_PROP_NOTIFY_EVENT_CLASS;
};


//////////////////////////////////////////////////////////////////////////////
// IObjectSafety
//
// 2nd template parameter is the supported safety e.g.
// INTERFACESAFE_FOR_UNTRUSTED_CALLER - safe for scripting
// INTERFACESAFE_FOR_UNTRUSTED_DATA   - safe for initialization from data

template <class T, DWORD dwSupportedSafety>
class ATL_NO_VTABLE IObjectSafetyImpl : public IObjectSafety
{
public:
	IObjectSafetyImpl()
	{
		m_dwCurrentSafety = 0;
	}

	STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions)
	{
		ATLTRACE2(atlTraceControls,2,_T("IObjectSafetyImpl2::GetInterfaceSafetyOptions\n"));
		T* pT = static_cast<T*>(this);
		if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
			return E_POINTER;
		
		HRESULT hr;
		IUnknown* pUnk;
		// Check if we support this interface
		hr = pT->GetUnknown()->QueryInterface(riid, (void**)&pUnk);
		if (SUCCEEDED(hr))
		{
			// We support this interface so set the safety options accordingly
			pUnk->Release();	// Release the interface we just acquired
			*pdwSupportedOptions = dwSupportedSafety;
			*pdwEnabledOptions   = m_dwCurrentSafety;
		}
		else
		{
			// We don't support this interface
			*pdwSupportedOptions = 0;
			*pdwEnabledOptions   = 0;
		}
		return hr;
	}
	STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions)
	{
		ATLTRACE2(atlTraceControls,2,_T("IObjectSafetyImpl2::SetInterfaceSafetyOptions\n"));
		T* pT = static_cast<T*>(this);
		IUnknown* pUnk;
		
		// Check if we support the interface and return E_NOINTEFACE if we don't
		if (FAILED(pT->GetUnknown()->QueryInterface(riid, (void**)&pUnk)))
			return E_NOINTERFACE;
		pUnk->Release();	// Release the interface we just acquired
		
		// If we are asked to set options we don't support then fail
		if (dwOptionSetMask & ~dwSupportedSafety)
			return E_FAIL;

		// Set the safety options we have been asked to
		m_dwCurrentSafety = m_dwCurrentSafety  & ~dwOptionSetMask | dwEnabledOptions;
		return S_OK;
	}
	DWORD m_dwCurrentSafety;
};

template <class T>
class ATL_NO_VTABLE IOleLinkImpl : public IOleLink
{
	STDMETHOD(SetUpdateOptions)(DWORD /* dwUpdateOpt */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::SetUpdateOptions"));
	}

	STDMETHOD(GetUpdateOptions)(DWORD* /* pdwUpdateOpt */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::GetUpdateOptions"));
	}

	STDMETHOD(SetSourceMoniker)(IMoniker* /* pmk */, REFCLSID /* rclsid */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::SetSourceMoniker"));
	}

	STDMETHOD(GetSourceMoniker)(IMoniker** /* ppmk */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::GetSourceMoniker"));
	};

	STDMETHOD(SetSourceDisplayName)(LPCOLESTR /* pszStatusText */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::SetSourceDisplayName"));
	}

	STDMETHOD(GetSourceDisplayName)(LPOLESTR *ppszDisplayName)
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleLink::GetSourceDisplayName\n"));
		*ppszDisplayName = NULL;
		return E_FAIL;
	}

	STDMETHOD(BindToSource)(DWORD /* bindflags */, IBindCtx* /* pbc */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::BindToSource\n"));
	};

	STDMETHOD(BindIfRunning)()
	{
		ATLTRACE2(atlTraceControls,2,_T("IOleLinkImpl::BindIfRunning\n"));
		return S_OK;
	};

	STDMETHOD(GetBoundSource)(IUnknown** /* ppunk */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::GetBoundSource"));
	};

	STDMETHOD(UnbindSource)()
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::UnbindSource"));
	};

	STDMETHOD(Update)(IBindCtx* /* pbc */)
	{
		ATLTRACENOTIMPL(_T("IOleLinkImpl::Update"));
	};
};

template <class T>
class ATL_NO_VTABLE CBindStatusCallback :
	public CComObjectRootEx<T::_ThreadModel::ThreadModelNoCS>,
	public IBindStatusCallback
{
	typedef void (T::*ATL_PDATAAVAILABLE)(CBindStatusCallback<T>* pbsc, BYTE* pBytes, DWORD dwSize);

public:

BEGIN_COM_MAP(CBindStatusCallback<T>)
	COM_INTERFACE_ENTRY(IBindStatusCallback)
END_COM_MAP()

	CBindStatusCallback()
	{
		m_pT = NULL;
		m_pFunc = NULL;
	}
	~CBindStatusCallback()
	{
		ATLTRACE2(atlTraceControls,2,_T("~CBindStatusCallback\n"));
	}

	STDMETHOD(OnStartBinding)(DWORD dwReserved, IBinding *pBinding)
	{
		ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::OnStartBinding\n"));
		m_spBinding = pBinding;
		return S_OK;
	}

	STDMETHOD(GetPriority)(LONG *pnPriority)
	{
		ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::GetPriority"));
		HRESULT hr = S_OK;
		if (pnPriority)
			*pnPriority = THREAD_PRIORITY_NORMAL;
		else
			hr = E_INVALIDARG;
		return S_OK;
	}

	STDMETHOD(OnLowResource)(DWORD reserved)
	{
		ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::OnLowResource"));
		return S_OK;
	}

	STDMETHOD(OnProgress)(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText)
	{
		ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::OnProgress"));
		return S_OK;
	}

	STDMETHOD(OnStopBinding)(HRESULT hresult, LPCWSTR szError)
	{
		ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::OnStopBinding\n"));
		(m_pT->*m_pFunc)(this, NULL, 0);
		m_spBinding.Release();
		m_spBindCtx.Release();
		m_spMoniker.Release();
		return S_OK;
	}

	STDMETHOD(GetBindInfo)(DWORD *pgrfBINDF, BINDINFO *pbindInfo)
	{
		ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::GetBindInfo\n"));

		if (pbindInfo==NULL || pbindInfo->cbSize==0 || pgrfBINDF==NULL)
			return E_INVALIDARG;

		*pgrfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE |
			BINDF_GETNEWESTVERSION | BINDF_NOWRITECACHE;

		ULONG cbSize = pbindInfo->cbSize;		// remember incoming cbSize
		memset(pbindInfo, 0, cbSize);			// zero out structure
		pbindInfo->cbSize = cbSize;				// restore cbSize
		pbindInfo->dwBindVerb = BINDVERB_GET;	// set verb
		return S_OK;
	}

	STDMETHOD(OnDataAvailable)(DWORD grfBSCF, DWORD dwSize, FORMATETC *pformatetc, STGMEDIUM *pstgmed)
	{
		ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::OnDataAvailable\n"));
		HRESULT hr = S_OK;

		// Get the Stream passed
		if (BSCF_FIRSTDATANOTIFICATION & grfBSCF)
		{
			if (!m_spStream && pstgmed->tymed == TYMED_ISTREAM)
				m_spStream = pstgmed->pstm;
		}

		DWORD dwRead = dwSize - m_dwTotalRead; // Minimum amount available that hasn't been read
		DWORD dwActuallyRead = 0;            // Placeholder for amount read during this pull

		// If there is some data to be read then go ahead and read them
		if (m_spStream)
		{
			if (dwRead > 0)
			{
				BYTE* pBytes = NULL;
				ATLTRY(pBytes = new BYTE[dwRead + 1]);
				if (pBytes == NULL)
					return E_OUTOFMEMORY;
				hr = m_spStream->Read(pBytes, dwRead, &dwActuallyRead);
				if (SUCCEEDED(hr))
				{
					pBytes[dwActuallyRead] = 0;
					if (dwActuallyRead>0)
					{
						(m_pT->*m_pFunc)(this, pBytes, dwActuallyRead);
						m_dwTotalRead += dwActuallyRead;
					}
				}
				delete[] pBytes;
			}
		}

		if (BSCF_LASTDATANOTIFICATION & grfBSCF)
			m_spStream.Release();
		return hr;
	}

	STDMETHOD(OnObjectAvailable)(REFIID riid, IUnknown *punk)
	{
		ATLTRACE2(atlTraceControls,2,_T("CBindStatusCallback::OnObjectAvailable"));
		return S_OK;
	}

	HRESULT _StartAsyncDownload(BSTR bstrURL, IUnknown* pUnkContainer, BOOL bRelative)
	{
		m_dwTotalRead = 0;
		m_dwAvailableToRead = 0;
		HRESULT hr = S_OK;
		CComQIPtr<IServiceProvider, &IID_IServiceProvider> spServiceProvider(pUnkContainer);
		CComPtr<IBindHost>	spBindHost;
		CComPtr<IStream>	spStream;
		if (spServiceProvider)
			spServiceProvider->QueryService(SID_IBindHost, IID_IBindHost, (void**)&spBindHost);

		if (spBindHost == NULL)
		{
			if (bRelative)
				return E_NOINTERFACE;  // relative asked for, but no IBindHost
			hr = CreateURLMoniker(NULL, bstrURL, &m_spMoniker);
			if (SUCCEEDED(hr))
				hr = CreateBindCtx(0, &m_spBindCtx);

			if (SUCCEEDED(hr))
				hr = RegisterBindStatusCallback(m_spBindCtx, static_cast<IBindStatusCallback*>(this), 0, 0L);
			else
				m_spMoniker.Release();

			if (SUCCEEDED(hr))
				hr = m_spMoniker->BindToStorage(m_spBindCtx, 0, IID_IStream, (void**)&spStream);
		}
		else
		{
			hr = CreateBindCtx(0, &m_spBindCtx);
			if (SUCCEEDED(hr))
				hr = RegisterBindStatusCallback(m_spBindCtx, static_cast<IBindStatusCallback*>(this), 0, 0L);

			if (SUCCEEDED(hr))
			{
				if (bRelative)
					hr = spBindHost->CreateMoniker(bstrURL, m_spBindCtx, &m_spMoniker, 0);
				else
					hr = CreateURLMoniker(NULL, bstrURL, &m_spMoniker);
			}

			if (SUCCEEDED(hr))
			{
				hr = spBindHost->MonikerBindToStorage(m_spMoniker, m_spBindCtx, static_cast<IBindStatusCallback*>(this), IID_IStream, (void**)&spStream);
				ATLTRACE2(atlTraceControls,2,_T("Bound"));
			}
		}
		return hr;
	}

	HRESULT StartAsyncDownload(T* pT, ATL_PDATAAVAILABLE pFunc, BSTR bstrURL, IUnknown* pUnkContainer = NULL, BOOL bRelative = FALSE)
	{
		m_pT = pT;
		m_pFunc = pFunc;
		return  _StartAsyncDownload(bstrURL, pUnkContainer, bRelative);
	}

	static HRESULT Download(T* pT, ATL_PDATAAVAILABLE pFunc, BSTR bstrURL, IUnknown* pUnkContainer = NULL, BOOL bRelative = FALSE)
	{
		CComObject<CBindStatusCallback<T> > *pbsc;
		HRESULT hRes = CComObject<CBindStatusCallback<T> >::CreateInstance(&pbsc);
		if (FAILED(hRes))
			return hRes;
		return pbsc->StartAsyncDownload(pT, pFunc, bstrURL, pUnkContainer, bRelative);
	}

	CComPtr<IMoniker> m_spMoniker;
	CComPtr<IBindCtx> m_spBindCtx;
	CComPtr<IBinding> m_spBinding;
	CComPtr<IStream> m_spStream;
	T* m_pT;
	ATL_PDATAAVAILABLE m_pFunc;
	DWORD m_dwTotalRead;
	DWORD m_dwAvailableToRead;
};

#define IMPLEMENT_STOCKPROP(type, fname, pname, dispid) \
	HRESULT STDMETHODCALLTYPE put_##fname(type pname) \
	{ \
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_%s\n"), #fname); \
		T* pT = (T*) this; \
		if (pT->FireOnRequestEdit(dispid) == S_FALSE) \
			return S_FALSE; \
		pT->m_##pname = pname; \
		pT->m_bRequiresSave = TRUE; \
		pT->FireOnChanged(dispid); \
		pT->FireViewChange(); \
		pT->SendOnDataChange(NULL); \
		return S_OK; \
	} \
	HRESULT STDMETHODCALLTYPE get_##fname(type* p##pname) \
	{ \
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_%s\n"), #fname); \
        if (!p##pname) return E_POINTER; \
		T* pT = (T*) this; \
		*p##pname = pT->m_##pname; \
		return S_OK; \
	}

#define IMPLEMENT_BOOL_STOCKPROP(fname, pname, dispid) \
	HRESULT STDMETHODCALLTYPE put_##fname(VARIANT_BOOL pname) \
	{ \
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_%s\n"), #fname); \
		T* pT = (T*) this; \
		if (pT->FireOnRequestEdit(dispid) == S_FALSE) \
			return S_FALSE; \
		pT->m_##pname = pname; \
		pT->m_bRequiresSave = TRUE; \
		pT->FireOnChanged(dispid); \
		pT->FireViewChange(); \
		pT->SendOnDataChange(NULL); \
		return S_OK; \
	} \
	HRESULT STDMETHODCALLTYPE get_##fname(VARIANT_BOOL* p##pname) \
	{ \
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_%s\n"), #fname); \
        if (!p##pname) return E_POINTER; \
		T* pT = (T*) this; \
		*p##pname = pT->m_##pname ? VARIANT_TRUE : VARIANT_FALSE; \
		return S_OK; \
	}

#define IMPLEMENT_BSTR_STOCKPROP(fname, pname, dispid) \
	HRESULT STDMETHODCALLTYPE put_##fname(BSTR pname) \
	{ \
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_%s\n"), #fname); \
		T* pT = (T*) this; \
		if (pT->FireOnRequestEdit(dispid) == S_FALSE) \
			return S_FALSE; \
		if (*(&(pT->m_##pname)) != NULL) \
			SysFreeString(*(&(pT->m_##pname))); \
		*(&(pT->m_##pname)) = SysAllocString(pname); \
		pT->m_bRequiresSave = TRUE; \
		pT->FireOnChanged(dispid); \
		pT->FireViewChange(); \
		pT->SendOnDataChange(NULL); \
		return S_OK; \
	} \
	HRESULT STDMETHODCALLTYPE get_##fname(BSTR* p##pname) \
	{ \
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_%s\n"), #fname); \
        if (!p##pname) return E_POINTER; \
		T* pT = (T*) this; \
		*p##pname = SysAllocString(pT->m_##pname); \
		return S_OK; \
	}


template < class T, class InterfaceName, const IID* piid, const GUID* plibid>
class ATL_NO_VTABLE CStockPropImpl : public IDispatchImpl< InterfaceName, piid, plibid >
{
public:
	// Font
	HRESULT STDMETHODCALLTYPE put_Font(IFontDisp* pFont)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_Font\n"));
        if (!ppFont) return E_POINTER;
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_FONT) == S_FALSE)
			return S_FALSE;
		pT->m_pFont = 0;
		if (pFont)
		{
			CComQIPtr<IFont, &IID_IFont> p(pFont);
			if (p)
			{
				CComPtr<IFont> pFont;
				p->Clone(&pFont);
				if (pFont)
					pFont->QueryInterface(IID_IFontDisp, (void**) &pT->m_pFont);
			}
		}
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_FONT);
		pT->FireViewChange();
		pT->SendOnDataChange(NULL);
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE putref_Font(IFontDisp* pFont)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::putref_Font\n"));
        if (!pFont) return E_POINTER;
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_FONT) == S_FALSE)
			return S_FALSE;
		pT->m_pFont = pFont;
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_FONT);
		pT->FireViewChange();
		pT->SendOnDataChange(NULL);
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE get_Font(IFontDisp** ppFont)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_Font\n"));
        if (!ppFont) return E_POINTER;
		T* pT = (T*) this;
		*ppFont = pT->m_pFont;
		if (*ppFont != NULL)
			(*ppFont)->AddRef();
		return S_OK;
	}
	// Picture
	HRESULT STDMETHODCALLTYPE put_Picture(IPictureDisp* pPicture)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_Picture\n"));
        if (!pPicture) return E_POINTER;
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_PICTURE) == S_FALSE)
			return S_FALSE;
		pT->m_pPicture = 0;
		if (pPicture)
		{
			CComQIPtr<IPersistStream, &IID_IPersistStream> p(pPicture);
			if (p)
			{
				ULARGE_INTEGER l;
				p->GetSizeMax(&l);
				HGLOBAL hGlob = GlobalAlloc(GHND, l.LowPart);
				if (hGlob)
				{
					CComPtr<IStream> spStream;
					CreateStreamOnHGlobal(hGlob, TRUE, &spStream);
					if (spStream)
					{
						if (SUCCEEDED(p->Save(spStream, FALSE)))
						{
							LARGE_INTEGER l;
							l.QuadPart = 0;
							spStream->Seek(l, STREAM_SEEK_SET, NULL);
							OleLoadPicture(spStream, l.LowPart, FALSE, IID_IPictureDisp, (void**)&pT->m_pPicture);
						}
						spStream.Release();
					}
					GlobalFree(hGlob);
				}
			}
		}
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_PICTURE);
		pT->FireViewChange();
		pT->SendOnDataChange(NULL);
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE putref_Picture(IPictureDisp* pPicture)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::putref_Picture\n"));
        if (!pPicture) return E_POINTER;
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_PICTURE) == S_FALSE)
			return S_FALSE;
		pT->m_pPicture = pPicture;
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_PICTURE);
		pT->FireViewChange();
		pT->SendOnDataChange(NULL);
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE get_Picture(IPictureDisp** ppPicture)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_Picture\n"));
        if (!ppPicture) return E_POINTER;
		T* pT = (T*) this;
		*ppPicture = pT->m_pPicture;
		if (*ppPicture != NULL)
			(*ppPicture)->AddRef();
		return S_OK;
	}
	// MouseIcon
	HRESULT STDMETHODCALLTYPE put_MouseIcon(IPictureDisp* pPicture)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_MouseIcon\n"));
        if (!pPicture) return E_POINTER;
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_MOUSEICON) == S_FALSE)
			return S_FALSE;
		pT->m_pMouseIcon = 0;
		if (pPicture)
		{
			CComQIPtr<IPersistStream, &IID_IPersistStream> p(pPicture);
			if (p)
			{
				ULARGE_INTEGER l;
				p->GetSizeMax(&l);
				HGLOBAL hGlob = GlobalAlloc(GHND, l.LowPart);
				if (hGlob)
				{
					CComPtr<IStream> spStream;
					CreateStreamOnHGlobal(hGlob, TRUE, &spStream);
					if (spStream)
					{
						if (SUCCEEDED(p->Save(spStream, FALSE)))
						{
							LARGE_INTEGER l;
							l.QuadPart = 0;
							spStream->Seek(l, STREAM_SEEK_SET, NULL);
							OleLoadPicture(spStream, l.LowPart, FALSE, IID_IPictureDisp, (void**)&pT->m_pMouseIcon);
						}
						spStream.Release();
					}
					GlobalFree(hGlob);
				}
			}
		}
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_MOUSEICON);
		pT->FireViewChange();
		pT->SendOnDataChange(NULL);
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE putref_MouseIcon(IPictureDisp* pPicture)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::putref_MouseIcon\n"));
        if (!pPicture) return E_POINTER;
		T* pT = (T*) this;
		if (pT->FireOnRequestEdit(DISPID_MOUSEICON) == S_FALSE)
			return S_FALSE;
		pT->m_pMouseIcon = pPicture;
		pT->m_bRequiresSave = TRUE;
		pT->FireOnChanged(DISPID_MOUSEICON);
		pT->FireViewChange();
		pT->SendOnDataChange(NULL);
		return S_OK;
	}
	HRESULT STDMETHODCALLTYPE get_MouseIcon(IPictureDisp** ppPicture)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_MouseIcon\n"));
        if (!ppPicture) return E_POINTER;
		T* pT = (T*) this;
		*ppPicture = pT->m_pMouseIcon;
		if (*ppPicture != NULL)
			(*ppPicture)->AddRef();
		return S_OK;
	}
	IMPLEMENT_STOCKPROP(OLE_COLOR, BackColor, clrBackColor, DISPID_BACKCOLOR)
	IMPLEMENT_STOCKPROP(OLE_COLOR, BorderColor, clrBorderColor, DISPID_BORDERCOLOR)
	IMPLEMENT_STOCKPROP(OLE_COLOR, FillColor, clrFillColor, DISPID_FILLCOLOR)
	IMPLEMENT_STOCKPROP(OLE_COLOR, ForeColor, clrForeColor, DISPID_FORECOLOR)
	IMPLEMENT_BOOL_STOCKPROP(AutoSize, bAutoSize, DISPID_AUTOSIZE)
	IMPLEMENT_BOOL_STOCKPROP(Valid, bValid, DISPID_VALID)
	IMPLEMENT_BOOL_STOCKPROP(Enabled, bEnabled, DISPID_ENABLED)
	IMPLEMENT_BOOL_STOCKPROP(TabStop, bTabStop, DISPID_TABSTOP)
	IMPLEMENT_BOOL_STOCKPROP(BorderVisible, bBorderVisible, DISPID_BORDERVISIBLE)
	IMPLEMENT_BSTR_STOCKPROP(Text, bstrText, DISPID_TEXT)
	IMPLEMENT_BSTR_STOCKPROP(Caption, bstrCaption, DISPID_CAPTION)
	HRESULT STDMETHODCALLTYPE put_Window(long /*hWnd*/)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::put_Window\n"));
		return E_FAIL;
	}
	HRESULT STDMETHODCALLTYPE get_Window(HWND* phWnd)
	{
		ATLTRACE2(atlTraceControls,2,_T("CStockPropImpl::get_Window\n"));
        if (!phWnd) return E_POINTER;
		T* pT = (T*) this;
		*phWnd = pT->m_hWnd;
		return S_OK;
	}
	IMPLEMENT_STOCKPROP(LONG, BackStyle, nBackStyle, DISPID_BACKSTYLE)
	IMPLEMENT_STOCKPROP(LONG, BorderStyle, nBorderStyle, DISPID_BORDERSTYLE)
	IMPLEMENT_STOCKPROP(LONG, BorderWidth, nBorderWidth, DISPID_BORDERWIDTH)
	IMPLEMENT_STOCKPROP(LONG, DrawMode, nDrawMode, DISPID_DRAWMODE)
	IMPLEMENT_STOCKPROP(LONG, DrawStyle, nDrawStyle, DISPID_DRAWSTYLE)
	IMPLEMENT_STOCKPROP(LONG, DrawWidth, nDrawWidth, DISPID_DRAWWIDTH)
	IMPLEMENT_STOCKPROP(LONG, FillStyle, nFillStyle, DISPID_FILLSTYLE)
	IMPLEMENT_STOCKPROP(SHORT, Appearance, nAppearance, DISPID_APPEARANCE)
	IMPLEMENT_STOCKPROP(LONG, MousePointer, nMousePointer, DISPID_MOUSEPOINTER)
	IMPLEMENT_STOCKPROP(LONG, ReadyState, nReadyState, DISPID_READYSTATE)
};

#pragma pack(pop)

}; //namespace ATL

#ifndef _ATL_DLL_IMPL
#ifndef _ATL_DLL
#define _ATLCTL_IMPL
#endif
#endif

#endif // __ATLCTL_H__

#ifdef _ATLCTL_IMPL

#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif


//All exports go here


#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif

//Prevent pulling in second time 
#undef _ATLCTL_IMPL

#endif // _ATLCTL_IMPL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\atl\atltmp.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

// atltmp.h - temporary location for these classes

#ifndef __ATLTMP_H__
#define __ATLTMP_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atltmp.h requires atlbase.h to be included first
#endif


#pragma once

#ifndef _ATL_TMP_NO_CSTRING
#include <limits.h>
#include <stdio.h>
#endif //!_ATL_TMP_NO_CSTRING

namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

class CSize;
class CPoint;
class CRect;
#ifndef _ATL_TMP_NO_CSTRING
class CString;
#endif //!_ATL_TMP_NO_CSTRING

/////////////////////////////////////////////////////////////////////////////
// CSize - An extent, similar to Windows SIZE structure.

class CSize : public tagSIZE
{
public:
// Constructors
	CSize();
	CSize(int initCX, int initCY);
	CSize(SIZE initSize);
	CSize(POINT initPt);
	CSize(DWORD dwSize);

// Operations
	BOOL operator==(SIZE size) const;
	BOOL operator!=(SIZE size) const;
	void operator+=(SIZE size);
	void operator-=(SIZE size);
    bool operator!() { return !cx && !cy; }


// Operators returning CSize values
	CSize operator+(SIZE size) const;
	CSize operator-(SIZE size) const;
	CSize operator-() const;

// Operators returning CPoint values
	CPoint operator+(POINT point) const;
	CPoint operator-(POINT point) const;

// Operators returning CRect values
	CRect operator+(const RECT* lpRect) const;
	CRect operator-(const RECT* lpRect) const;
};

/////////////////////////////////////////////////////////////////////////////
// CPoint - A 2-D point, similar to Windows POINT structure.

class CPoint : public tagPOINT
{
public:
// Constructors
    CPoint() {
        x = 0;
        y = 0;
    }
	CPoint(int initX, int initY);
	CPoint(POINT initPt);
	CPoint(SIZE initSize);
	CPoint(DWORD dwPoint);

// Operations
	void Offset(int xOffset, int yOffset);
	void Offset(POINT point);
	void Offset(SIZE size);
	BOOL operator==(POINT point) const;
	BOOL operator!=(POINT point) const;
	void operator+=(SIZE size);
	void operator-=(SIZE size);
	void operator+=(POINT point);
	void operator-=(POINT point);
    bool operator!() { return !x && !y; }

// Operators returning CPoint values
	CPoint operator+(SIZE size) const;
	CPoint operator-(SIZE size) const;
	CPoint operator-() const;
	CPoint operator+(POINT point) const;

// Operators returning CSize values
	CSize operator-(POINT point) const;

// Operators returning CRect values
	CRect operator+(const RECT* lpRect) const;
	CRect operator-(const RECT* lpRect) const;
};

/////////////////////////////////////////////////////////////////////////////
// CRect - A 2-D rectangle, similar to Windows RECT structure.

//typedef const RECT* LPCRECT;    // pointer to read/only RECT

class CRect : public tagRECT
{
public:
// Constructors
    CRect() {
        left = 0;
        top = 0;
        right = 0;
        bottom = 0;
    }
	CRect(int l, int t, int r, int b);
	CRect(const RECT& srcRect);
	CRect(LPCRECT lpSrcRect);
	CRect(POINT point, SIZE size);
	CRect(POINT topLeft, POINT bottomRight);

// Attributes (in addition to RECT members)
	int Width() const;
	int Height() const;
	CSize Size() const;
	CPoint& TopLeft();
	CPoint& BottomRight();
	const CPoint& TopLeft() const;
	const CPoint& BottomRight() const;
	CPoint CenterPoint() const;

	// convert between CRect and LPRECT/LPCRECT (no need for &)
	operator LPRECT();
	operator LPCRECT() const;

	BOOL IsRectEmpty() const;
	BOOL IsRectNull() const;
	BOOL PtInRect(POINT point) const;

// Operations
	void SetRect(int x1, int y1, int x2, int y2);
	void SetRect(POINT topLeft, POINT bottomRight);
	void SetRectEmpty();
	void CopyRect(LPCRECT lpSrcRect);
	BOOL EqualRect(LPCRECT lpRect) const;

	void InflateRect(int x, int y);
	void InflateRect(SIZE size);
	void InflateRect(LPCRECT lpRect);
	void InflateRect(int l, int t, int r, int b);
	void DeflateRect(int x, int y);
	void DeflateRect(SIZE size);
	void DeflateRect(LPCRECT lpRect);
	void DeflateRect(int l, int t, int r, int b);

	void OffsetRect(int x, int y);
	void OffsetRect(SIZE size);
	void OffsetRect(POINT point);
	void NormalizeRect();

	// operations that fill '*this' with result
	BOOL IntersectRect(LPCRECT lpRect1, LPCRECT lpRect2);
	BOOL IntersectRect(LPCRECT lpRect2);  // use this for rect1
	BOOL UnionRect(LPCRECT lpRect1, LPCRECT lpRect2);
	BOOL SubtractRect(LPCRECT lpRectSrc1, LPCRECT lpRectSrc2);

// Additional Operations
	void operator=(const RECT& srcRect);
	BOOL operator==(const RECT& rect) const;
	BOOL operator!=(const RECT& rect) const;
    bool operator!() { return !left && !top && !right && !bottom; }
	void operator+=(POINT point);
	void operator+=(SIZE size);
	void operator+=(LPCRECT lpRect);
	void operator-=(POINT point);
	void operator-=(SIZE size);
	void operator-=(LPCRECT lpRect);
	void operator&=(const RECT& rect);
	void operator|=(const RECT& rect);

// Operators returning CRect values
	CRect operator+(POINT point) const;
	CRect operator-(POINT point) const;
	CRect operator+(LPCRECT lpRect) const;
	CRect operator+(SIZE size) const;
	CRect operator-(SIZE size) const;
	CRect operator-(LPCRECT lpRect) const;
	CRect operator&(const RECT& rect2) const;
	CRect operator|(const RECT& rect2) const;
	CRect MulDiv(int nMultiplier, int nDivisor) const;
};

/////////////////////////////////////////////////////////////////////////////
// Strings

#ifndef _ATL_TMP_NO_CSTRING

#ifndef _OLEAUTO_H_
#ifdef OLE2ANSI
	typedef LPSTR BSTR;
#else
	typedef LPWSTR BSTR; // must (semantically) match typedef in oleauto.h
#endif
#endif

int __stdcall AfxLoadString(UINT nID, LPTSTR lpszBuf, UINT nMaxBuf);

struct CStringData
{
	long nRefs;     // reference count
	int nDataLength;
	int nAllocLength;
	// TCHAR data[nAllocLength]

	TCHAR* data()
		{ return (TCHAR*)(this+1); }
};

class CString
{
public:
// Constructors
	CString();
	CString(const CString& stringSrc);
	CString(TCHAR ch, int nRepeat = 1);
	CString(LPCSTR lpsz);
	CString(LPCWSTR lpsz);
	CString(LPCTSTR lpch, int nLength);
	CString(const unsigned char* psz);

// Attributes & Operations
	// as an array of characters
	int GetLength() const;
	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	TCHAR GetAt(int nIndex) const;      // 0 based
	TCHAR operator[](int nIndex) const; // same as GetAt
	void SetAt(int nIndex, TCHAR ch);
	operator LPCTSTR() const;           // as a C string

	// overloaded assignment
	const CString& operator=(const CString& stringSrc);
	const CString& operator=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator=(char ch);
#endif
	const CString& operator=(LPCSTR lpsz);
	const CString& operator=(LPCWSTR lpsz);
	const CString& operator=(const unsigned char* psz);

	// string concatenation
	const CString& operator+=(const CString& string);
	const CString& operator+=(TCHAR ch);
#ifdef _UNICODE
	const CString& operator+=(char ch);
#endif
	const CString& operator+=(LPCTSTR lpsz);

	friend CString __stdcall operator+(const CString& string1, const CString& string2);
	friend CString __stdcall operator+(const CString& string, TCHAR ch);
	friend CString __stdcall operator+(TCHAR ch, const CString& string);
#ifdef _UNICODE
	friend CString __stdcall operator+(const CString& string, char ch);
	friend CString __stdcall operator+(char ch, const CString& string);
#endif
	friend CString __stdcall operator+(const CString& string, LPCTSTR lpsz);
	friend CString __stdcall operator+(LPCTSTR lpsz, const CString& string);

	// string comparison
	int Compare(LPCTSTR lpsz) const;         // straight character
	int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
	int Collate(LPCTSTR lpsz) const;         // NLS aware

	// simple sub-string extraction
	CString Mid(int nFirst, int nCount) const;
	CString Mid(int nFirst) const;
	CString Left(int nCount) const;
	CString Right(int nCount) const;

	CString SpanIncluding(LPCTSTR lpszCharSet) const;
	CString SpanExcluding(LPCTSTR lpszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(TCHAR ch) const;               // like "C" strchr
	int ReverseFind(TCHAR ch) const;
	int FindOneOf(LPCTSTR lpszCharSet) const;

	// look for a specific sub-string
	int Find(LPCTSTR lpszSub) const;        // like "C" strstr

	// simple formatting
	void __cdecl Format(LPCTSTR lpszFormat, ...);
	void __cdecl Format(UINT nFormatID, ...);

	// formatting for localization (uses FormatMessage API)
	BOOL __cdecl FormatMessage(LPCTSTR lpszFormat, ...);
	BOOL __cdecl FormatMessage(UINT nFormatID, ...);

	// Windows support
	BOOL LoadString(UINT nID);          // load from string resource
										// 255 chars max
#ifndef _UNICODE
	// ANSI <-> OEM support (convert string in place)
	void AnsiToOem();
	void OemToAnsi();
#endif

#ifndef _ATL_NO_COM
	// OLE BSTR support (use for OLE automation)
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;
#endif //!_ATL_NO_COM

	// Access to string implementation buffer as "C" character array
	LPTSTR GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	LPTSTR GetBufferSetLength(int nNewLength);
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off
	LPTSTR LockBuffer();
	void UnlockBuffer();

// Implementation
public:
	~CString();
	int GetAllocLength() const;

protected:
	LPTSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CStringData* GetData() const;
	void Init();
	void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	BOOL AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void FormatV(LPCTSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	BOOL AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CStringData* pData);
	static int PASCAL SafeStrlen(LPCTSTR lpsz);
};

// Compare helpers
bool __stdcall operator==(const CString& s1, const CString& s2);
bool __stdcall operator==(const CString& s1, LPCTSTR s2);
bool __stdcall operator==(LPCTSTR s1, const CString& s2);
bool __stdcall operator!=(const CString& s1, const CString& s2);
bool __stdcall operator!=(const CString& s1, LPCTSTR s2);
bool __stdcall operator!=(LPCTSTR s1, const CString& s2);
bool __stdcall operator<(const CString& s1, const CString& s2);
bool __stdcall operator<(const CString& s1, LPCTSTR s2);
bool __stdcall operator<(LPCTSTR s1, const CString& s2);
bool __stdcall operator>(const CString& s1, const CString& s2);
bool __stdcall operator>(const CString& s1, LPCTSTR s2);
bool __stdcall operator>(LPCTSTR s1, const CString& s2);
bool __stdcall operator<=(const CString& s1, const CString& s2);
bool __stdcall operator<=(const CString& s1, LPCTSTR s2);
bool __stdcall operator<=(LPCTSTR s1, const CString& s2);
bool __stdcall operator>=(const CString& s1, const CString& s2);
bool __stdcall operator>=(const CString& s1, LPCTSTR s2);
bool __stdcall operator>=(LPCTSTR s1, const CString& s2);

// conversion helpers
int __cdecl _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int __cdecl _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Globals

// afxChNil is left for backward compatibility
_declspec(selectany) TCHAR afxChNil = '\0';

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)
_declspec(selectany) int rgInitData[] = { -1, 0, 0, 0 };
_declspec(selectany) CStringData* afxDataNil = (CStringData*)&rgInitData;
_declspec(selectany) LPCTSTR afxPchNil = (LPCTSTR)(((BYTE*)&rgInitData)+sizeof(CStringData));

inline const CString& __stdcall AfxGetEmptyString()
	{ return *(CString*)&afxPchNil; }
#define afxEmptyString AfxGetEmptyString()

#endif //!_ATL_TMP_NO_CSTRING

/////////////////////////////////////////////////////////////////////////////
// Implementation

// CSize
inline CSize::CSize() {
    cx = 0;
    cy = 0;
}
inline CSize::CSize(int initCX, int initCY)
	{ cx = initCX; cy = initCY; }
inline CSize::CSize(SIZE initSize)
	{ *(SIZE*)this = initSize; }
inline CSize::CSize(POINT initPt)
	{ *(POINT*)this = initPt; }
inline CSize::CSize(DWORD dwSize)
	{
		cx = (short)LOWORD(dwSize);
		cy = (short)HIWORD(dwSize);
	}
inline BOOL CSize::operator==(SIZE size) const
	{ return (cx == size.cx && cy == size.cy); }
inline BOOL CSize::operator!=(SIZE size) const
	{ return (cx != size.cx || cy != size.cy); }
inline void CSize::operator+=(SIZE size)
	{ cx += size.cx; cy += size.cy; }
inline void CSize::operator-=(SIZE size)
	{ cx -= size.cx; cy -= size.cy; }
inline CSize CSize::operator+(SIZE size) const
	{ return CSize(cx + size.cx, cy + size.cy); }
inline CSize CSize::operator-(SIZE size) const
	{ return CSize(cx - size.cx, cy - size.cy); }
inline CSize CSize::operator-() const
	{ return CSize(-cx, -cy); }
inline CPoint CSize::operator+(POINT point) const
	{ return CPoint(cx + point.x, cy + point.y); }
inline CPoint CSize::operator-(POINT point) const
	{ return CPoint(cx - point.x, cy - point.y); }
inline CRect CSize::operator+(const RECT* lpRect) const
	{ return CRect(lpRect) + *this; }
inline CRect CSize::operator-(const RECT* lpRect) const
	{ return CRect(lpRect) - *this; }

// CPoint
inline CPoint::CPoint(int initX, int initY)
	{ x = initX; y = initY; }
inline CPoint::CPoint(POINT initPt)
	{ *(POINT*)this = initPt; }
inline CPoint::CPoint(SIZE initSize)
	{ *(SIZE*)this = initSize; }
inline CPoint::CPoint(DWORD dwPoint)
	{
		x = (short)LOWORD(dwPoint);
		y = (short)HIWORD(dwPoint);
	}
inline void CPoint::Offset(int xOffset, int yOffset)
	{ x += xOffset; y += yOffset; }
inline void CPoint::Offset(POINT point)
	{ x += point.x; y += point.y; }
inline void CPoint::Offset(SIZE size)
	{ x += size.cx; y += size.cy; }
inline BOOL CPoint::operator==(POINT point) const
	{ return (x == point.x && y == point.y); }
inline BOOL CPoint::operator!=(POINT point) const
	{ return (x != point.x || y != point.y); }
inline void CPoint::operator+=(SIZE size)
	{ x += size.cx; y += size.cy; }
inline void CPoint::operator-=(SIZE size)
	{ x -= size.cx; y -= size.cy; }
inline void CPoint::operator+=(POINT point)
	{ x += point.x; y += point.y; }
inline void CPoint::operator-=(POINT point)
	{ x -= point.x; y -= point.y; }
inline CPoint CPoint::operator+(SIZE size) const
	{ return CPoint(x + size.cx, y + size.cy); }
inline CPoint CPoint::operator-(SIZE size) const
	{ return CPoint(x - size.cx, y - size.cy); }
inline CPoint CPoint::operator-() const
	{ return CPoint(-x, -y); }
inline CPoint CPoint::operator+(POINT point) const
	{ return CPoint(x + point.x, y + point.y); }
inline CSize CPoint::operator-(POINT point) const
	{ return CSize(x - point.x, y - point.y); }
inline CRect CPoint::operator+(const RECT* lpRect) const
	{ return CRect(lpRect) + *this; }
inline CRect CPoint::operator-(const RECT* lpRect) const
	{ return CRect(lpRect) - *this; }

// CRect
inline CRect::CRect(int l, int t, int r, int b)
	{ left = l; top = t; right = r; bottom = b; }
inline CRect::CRect(const RECT& srcRect)
	{ ::CopyRect(this, &srcRect); }
inline CRect::CRect(LPCRECT lpSrcRect)
	{ ::CopyRect(this, lpSrcRect); }
inline CRect::CRect(POINT point, SIZE size)
	{ right = (left = point.x) + size.cx; bottom = (top = point.y) + size.cy; }
inline CRect::CRect(POINT topLeft, POINT bottomRight)
	{ left = topLeft.x; top = topLeft.y;
		right = bottomRight.x; bottom = bottomRight.y; }
inline int CRect::Width() const
	{ return right - left; }
inline int CRect::Height() const
	{ return bottom - top; }
inline CSize CRect::Size() const
	{ return CSize(right - left, bottom - top); }
inline CPoint& CRect::TopLeft()
	{ return *((CPoint*)this); }
inline CPoint& CRect::BottomRight()
	{ return *((CPoint*)this+1); }
inline const CPoint& CRect::TopLeft() const
	{ return *((CPoint*)this); }
inline const CPoint& CRect::BottomRight() const
	{ return *((CPoint*)this+1); }
inline CPoint CRect::CenterPoint() const
	{ return CPoint((left+right)/2, (top+bottom)/2); }
inline CRect::operator LPRECT()
	{ return this; }
inline CRect::operator LPCRECT() const
	{ return this; }
inline BOOL CRect::IsRectEmpty() const
	{ return ::IsRectEmpty(this); }
inline BOOL CRect::IsRectNull() const
	{ return (left == 0 && right == 0 && top == 0 && bottom == 0); }
inline BOOL CRect::PtInRect(POINT point) const
	{ return ::PtInRect(this, point); }
inline void CRect::SetRect(int x1, int y1, int x2, int y2)
	{ ::SetRect(this, x1, y1, x2, y2); }
inline void CRect::SetRect(POINT topLeft, POINT bottomRight)
	{ ::SetRect(this, topLeft.x, topLeft.y, bottomRight.x, bottomRight.y); }
inline void CRect::SetRectEmpty()
	{ ::SetRectEmpty(this); }
inline void CRect::CopyRect(LPCRECT lpSrcRect)
	{ ::CopyRect(this, lpSrcRect); }
inline BOOL CRect::EqualRect(LPCRECT lpRect) const
	{ return ::EqualRect(this, lpRect); }
inline void CRect::InflateRect(int x, int y)
	{ ::InflateRect(this, x, y); }
inline void CRect::InflateRect(SIZE size)
	{ ::InflateRect(this, size.cx, size.cy); }
inline void CRect::DeflateRect(int x, int y)
	{ ::InflateRect(this, -x, -y); }
inline void CRect::DeflateRect(SIZE size)
	{ ::InflateRect(this, -size.cx, -size.cy); }
inline void CRect::OffsetRect(int x, int y)
	{ ::OffsetRect(this, x, y); }
inline void CRect::OffsetRect(POINT point)
	{ ::OffsetRect(this, point.x, point.y); }
inline void CRect::OffsetRect(SIZE size)
	{ ::OffsetRect(this, size.cx, size.cy); }
inline BOOL CRect::IntersectRect(LPCRECT lpRect1, LPCRECT lpRect2)
	{ return ::IntersectRect(this, lpRect1, lpRect2);}
inline BOOL CRect::IntersectRect(LPCRECT lpRect2)
	{ return ::IntersectRect(this, this, lpRect2);}
inline BOOL CRect::UnionRect(LPCRECT lpRect1, LPCRECT lpRect2)
	{ return ::UnionRect(this, lpRect1, lpRect2); }
inline void CRect::operator=(const RECT& srcRect)
	{ ::CopyRect(this, &srcRect); }
inline BOOL CRect::operator==(const RECT& rect) const
	{ return ::EqualRect(this, &rect); }
inline BOOL CRect::operator!=(const RECT& rect) const
	{ return !::EqualRect(this, &rect); }
inline void CRect::operator+=(POINT point)
	{ ::OffsetRect(this, point.x, point.y); }
inline void CRect::operator+=(SIZE size)
	{ ::OffsetRect(this, size.cx, size.cy); }
inline void CRect::operator+=(LPCRECT lpRect)
	{ InflateRect(lpRect); }
inline void CRect::operator-=(POINT point)
	{ ::OffsetRect(this, -point.x, -point.y); }
inline void CRect::operator-=(SIZE size)
	{ ::OffsetRect(this, -size.cx, -size.cy); }
inline void CRect::operator-=(LPCRECT lpRect)
	{ DeflateRect(lpRect); }
inline void CRect::operator&=(const RECT& rect)
	{ ::IntersectRect(this, this, &rect); }
inline void CRect::operator|=(const RECT& rect)
	{ ::UnionRect(this, this, &rect); }
inline CRect CRect::operator+(POINT pt) const
	{ CRect rect(*this); ::OffsetRect(&rect, pt.x, pt.y); return rect; }
inline CRect CRect::operator-(POINT pt) const
	{ CRect rect(*this); ::OffsetRect(&rect, -pt.x, -pt.y); return rect; }
inline CRect CRect::operator+(SIZE size) const
	{ CRect rect(*this); ::OffsetRect(&rect, size.cx, size.cy); return rect; }
inline CRect CRect::operator-(SIZE size) const
	{ CRect rect(*this); ::OffsetRect(&rect, -size.cx, -size.cy); return rect; }
inline CRect CRect::operator+(LPCRECT lpRect) const
	{ CRect rect(this); rect.InflateRect(lpRect); return rect; }
inline CRect CRect::operator-(LPCRECT lpRect) const
	{ CRect rect(this); rect.DeflateRect(lpRect); return rect; }
inline CRect CRect::operator&(const RECT& rect2) const
	{ CRect rect; ::IntersectRect(&rect, this, &rect2);
		return rect; }
inline CRect CRect::operator|(const RECT& rect2) const
	{ CRect rect; ::UnionRect(&rect, this, &rect2);
		return rect; }
inline BOOL CRect::SubtractRect(LPCRECT lpRectSrc1, LPCRECT lpRectSrc2)
	{ return ::SubtractRect(this, lpRectSrc1, lpRectSrc2); }

inline void CRect::NormalizeRect()
{
	int nTemp;
	if (left > right)
	{
		nTemp = left;
		left = right;
		right = nTemp;
	}
	if (top > bottom)
	{
		nTemp = top;
		top = bottom;
		bottom = nTemp;
	}
}

inline void CRect::InflateRect(LPCRECT lpRect)
{
	left -= lpRect->left;
	top -= lpRect->top;
	right += lpRect->right;
	bottom += lpRect->bottom;
}

inline void CRect::InflateRect(int l, int t, int r, int b)
{
	left -= l;
	top -= t;
	right += r;
	bottom += b;
}

inline void CRect::DeflateRect(LPCRECT lpRect)
{
	left += lpRect->left;
	top += lpRect->top;
	right -= lpRect->right;
	bottom -= lpRect->bottom;
}

inline void CRect::DeflateRect(int l, int t, int r, int b)
{
	left += l;
	top += t;
	right -= r;
	bottom -= b;
}

inline CRect CRect::MulDiv(int nMultiplier, int nDivisor) const
{
	return CRect(
		::MulDiv(left, nMultiplier, nDivisor),
		::MulDiv(top, nMultiplier, nDivisor),
		::MulDiv(right, nMultiplier, nDivisor),
		::MulDiv(bottom, nMultiplier, nDivisor));
}


#ifndef _ATL_TMP_NO_CSTRING

// CString
inline CStringData* CString::GetData() const
	{ ATLASSERT(m_pchData != NULL); return ((CStringData*)m_pchData)-1; }
inline void CString::Init()
	{ m_pchData = afxEmptyString.m_pchData; }
inline CString::CString(const unsigned char* lpsz)
	{ Init(); *this = (LPCSTR)lpsz; }
inline const CString& CString::operator=(const unsigned char* lpsz)
	{ *this = (LPCSTR)lpsz; return *this; }
#ifdef _UNICODE
inline const CString& CString::operator+=(char ch)
	{ *this += (TCHAR)ch; return *this; }
inline const CString& CString::operator=(char ch)
	{ *this = (TCHAR)ch; return *this; }
inline CString __stdcall operator+(const CString& string, char ch)
	{ return string + (TCHAR)ch; }
inline CString __stdcall operator+(char ch, const CString& string)
	{ return (TCHAR)ch + string; }
#endif

inline int CString::GetLength() const
	{ return GetData()->nDataLength; }
inline int CString::GetAllocLength() const
	{ return GetData()->nAllocLength; }
inline BOOL CString::IsEmpty() const
	{ return GetData()->nDataLength == 0; }
inline CString::operator LPCTSTR() const
	{ return m_pchData; }
inline int PASCAL CString::SafeStrlen(LPCTSTR lpsz)
	{ return (lpsz == NULL) ? 0 : lstrlen(lpsz); }

// CString support (windows specific)
inline int CString::Compare(LPCTSTR lpsz) const
	{ return _tcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
inline int CString::CompareNoCase(LPCTSTR lpsz) const
	{ return _tcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CString::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
inline int CString::Collate(LPCTSTR lpsz) const
	{ return _tcscoll(m_pchData, lpsz); }   // locale sensitive

inline TCHAR CString::GetAt(int nIndex) const
{
	ATLASSERT(nIndex >= 0);
	ATLASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
inline TCHAR CString::operator[](int nIndex) const
{
	// same as GetAt
	ATLASSERT(nIndex >= 0);
	ATLASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
inline bool __stdcall operator==(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) == 0; }
inline bool __stdcall operator==(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) == 0; }
inline bool __stdcall operator==(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) == 0; }
inline bool __stdcall operator!=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) != 0; }
inline bool __stdcall operator!=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) != 0; }
inline bool __stdcall operator!=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) != 0; }
inline bool __stdcall operator<(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) < 0; }
inline bool __stdcall operator<(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) < 0; }
inline bool __stdcall operator<(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) > 0; }
inline bool __stdcall operator>(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) > 0; }
inline bool __stdcall operator>(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) > 0; }
inline bool __stdcall operator>(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) < 0; }
inline bool __stdcall operator<=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) <= 0; }
inline bool __stdcall operator<=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) <= 0; }
inline bool __stdcall operator<=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) >= 0; }
inline bool __stdcall operator>=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) >= 0; }
inline bool __stdcall operator>=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) >= 0; }
inline bool __stdcall operator>=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) <= 0; }

inline BOOL __stdcall AfxIsValidString(LPCWSTR lpsz, int nLength)
{
	if(lpsz == NULL)
		return FALSE;
	return !::IsBadStringPtrW(lpsz, nLength);
}

inline BOOL __stdcall AfxIsValidString(LPCSTR lpsz, int nLength)
{
	if(lpsz == NULL)
		return FALSE;
	return !::IsBadStringPtrA(lpsz, nLength);
}

inline BOOL __stdcall AfxIsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite = TRUE)
{
	// simple version using Win-32 APIs for pointer validation.
	return (lp != NULL && !IsBadReadPtr(lp, nBytes) &&
		(!bReadWrite || !IsBadWritePtr((LPVOID)lp, nBytes)));
}

inline CString::CString()
{
	Init();
}

inline CString::CString(const CString& stringSrc)
{
	ATLASSERT(stringSrc.GetData()->nRefs != 0);
	if (stringSrc.GetData()->nRefs >= 0)
	{
		ATLASSERT(stringSrc.GetData() != afxDataNil);
		m_pchData = stringSrc.m_pchData;
		InterlockedIncrement(&GetData()->nRefs);
	}
	else
	{
		Init();
		*this = stringSrc.m_pchData;
	}
}

inline BOOL CString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
	ATLASSERT(nLen >= 0);
	ATLASSERT(nLen <= INT_MAX-1);    // max size (enough room for 1 extra)

	if (nLen == 0)
		Init();
	else
	{
		CStringData* pData = NULL;
		ATLTRY(pData = (CStringData*)new BYTE[sizeof(CStringData) + (nLen+1)*sizeof(TCHAR)]);
		if(pData == NULL)
			return FALSE;

		pData->nRefs = 1;
		pData->data()[nLen] = '\0';
		pData->nDataLength = nLen;
		pData->nAllocLength = nLen;
		m_pchData = pData->data();
	}

	return TRUE;
}

inline void CString::Release()
{
	if (GetData() != afxDataNil)
	{
		ATLASSERT(GetData()->nRefs != 0);
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
		Init();
	}
}

inline void PASCAL CString::Release(CStringData* pData)
{
	if (pData != afxDataNil)
	{
		ATLASSERT(pData->nRefs != 0);
		if (InterlockedDecrement(&pData->nRefs) <= 0)
			delete[] (BYTE*)pData;
	}
}

inline void CString::Empty()
{
	if (GetData()->nDataLength == 0)
		return;
	if (GetData()->nRefs >= 0)
		Release();
	else
		*this = &afxChNil;
	ATLASSERT(GetData()->nDataLength == 0);
	ATLASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);
}

inline void CString::CopyBeforeWrite()
{
	if (GetData()->nRefs > 1)
	{
		CStringData* pData = GetData();
		Release();
		if(AllocBuffer(pData->nDataLength))
			memcpy(m_pchData, pData->data(), (pData->nDataLength+1)*sizeof(TCHAR));
	}
	ATLASSERT(GetData()->nRefs <= 1);
}

inline BOOL CString::AllocBeforeWrite(int nLen)
{
	BOOL bRet = TRUE;
	if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
	{
		Release();
		bRet = AllocBuffer(nLen);
	}
	ATLASSERT(GetData()->nRefs <= 1);
	return bRet;
}

inline CString::~CString()
//  free any attached data
{
	if (GetData() != afxDataNil)
	{
		if (InterlockedDecrement(&GetData()->nRefs) <= 0)
			delete[] (BYTE*)GetData();
	}
}

inline void CString::AllocCopy(CString& dest, int nCopyLen, int nCopyIndex,
	 int nExtraLen) const
{
	// will clone the data attached to this string
	// allocating 'nExtraLen' characters
	// Places results in uninitialized string 'dest'
	// Will copy the part or all of original data to start of new string

	int nNewLen = nCopyLen + nExtraLen;
	if (nNewLen == 0)
	{
		dest.Init();
	}
	else
	{
		if(dest.AllocBuffer(nNewLen))
			memcpy(dest.m_pchData, m_pchData+nCopyIndex, nCopyLen*sizeof(TCHAR));
	}
}

inline CString::CString(LPCTSTR lpsz)
{
	Init();
	if (lpsz != NULL && HIWORD(lpsz) == NULL)
	{
		UINT nID = LOWORD((DWORD_PTR)lpsz);
		if (!LoadString(nID))
#if (_ATL_VER >= 0x0300)
			ATLTRACE2(atlTraceGeneral, 0, _T("Warning: implicit LoadString(%u) in CString failed\n"), nID);
#else
			ATLTRACE2(atlTraceGeneral, 0, _T("Warning: implicit LoadString in CString failed\n"));
#endif //(_ATL_VER >= 0x0300)
	}
	else
	{
		int nLen = SafeStrlen(lpsz);
		if (nLen != 0)
		{
			if(AllocBuffer(nLen))
				memcpy(m_pchData, lpsz, nLen*sizeof(TCHAR));
		}
	}
}

#ifdef _UNICODE
inline CString::CString(LPCSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if (nSrcLen != 0)
	{
		if(AllocBuffer(nSrcLen))
		{
			_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
			ReleaseBuffer();
		}
	}
}
#else //_UNICODE
inline CString::CString(LPCWSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	if (nSrcLen != 0)
	{
		if(AllocBuffer(nSrcLen*2))
		{
			_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
			ReleaseBuffer();
		}
	}
}
#endif //!_UNICODE

// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

inline void CString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
	if(AllocBeforeWrite(nSrcLen))
	{
		memcpy(m_pchData, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength = nSrcLen;
		m_pchData[nSrcLen] = '\0';
	}
}

inline const CString& CString::operator=(const CString& stringSrc)
{
	if (m_pchData != stringSrc.m_pchData)
	{
		if ((GetData()->nRefs < 0 && GetData() != afxDataNil) ||
			stringSrc.GetData()->nRefs < 0)
		{
			// actual copy necessary since one of the strings is locked
			AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
		}
		else
		{
			// can just copy references around
			Release();
			ATLASSERT(stringSrc.GetData() != afxDataNil);
			m_pchData = stringSrc.m_pchData;
			InterlockedIncrement(&GetData()->nRefs);
		}
	}
	return *this;
}

inline const CString& CString::operator=(LPCTSTR lpsz)
{
	ATLASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	AssignCopy(SafeStrlen(lpsz), lpsz);
	return *this;
}

#ifdef _UNICODE
inline const CString& CString::operator=(LPCSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if(AllocBeforeWrite(nSrcLen))
	{
		_mbstowcsz(m_pchData, lpsz, nSrcLen+1);
		ReleaseBuffer();
	}
	return *this;
}
#else //!_UNICODE
inline const CString& CString::operator=(LPCWSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? wcslen(lpsz) : 0;
	if(AllocBeforeWrite(nSrcLen*2))
	{
		_wcstombsz(m_pchData, lpsz, (nSrcLen*2)+1);
		ReleaseBuffer();
	}
	return *this;
}
#endif  //!_UNICODE

// Concatenation
// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CString + CString
// and for ? = TCHAR, LPCTSTR
//          CString + ?
//          ? + CString

inline void CString::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
	int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CString object

	int nNewLen = nSrc1Len + nSrc2Len;
	if (nNewLen != 0)
	{
		if(AllocBuffer(nNewLen))
		{
			memcpy(m_pchData, lpszSrc1Data, nSrc1Len*sizeof(TCHAR));
			memcpy(m_pchData+nSrc1Len, lpszSrc2Data, nSrc2Len*sizeof(TCHAR));
		}
	}
}

inline CString __stdcall operator+(const CString& string1, const CString& string2)
{
	CString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData,
		string2.GetData()->nDataLength, string2.m_pchData);
	return s;
}

inline CString __stdcall operator+(const CString& string, LPCTSTR lpsz)
{
	ATLASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	CString s;
	s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData,
		CString::SafeStrlen(lpsz), lpsz);
	return s;
}

inline CString __stdcall operator+(LPCTSTR lpsz, const CString& string)
{
	ATLASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	CString s;
	s.ConcatCopy(CString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength,
		string.m_pchData);
	return s;
}

inline void CString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
	//  -- the main routine for += operators

	// concatenating an empty string is a no-op!
	if (nSrcLen == 0)
		return;

	// if the buffer is too small, or we have a width mis-match, just
	//   allocate a new buffer (slow but sure)
	if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
	{
		// we have to grow the buffer, use the ConcatCopy routine
		CStringData* pOldData = GetData();
		ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData);
		ATLASSERT(pOldData != NULL);
		CString::Release(pOldData);
	}
	else
	{
		// fast concatenation when buffer big enough
		memcpy(m_pchData+GetData()->nDataLength, lpszSrcData, nSrcLen*sizeof(TCHAR));
		GetData()->nDataLength += nSrcLen;
		ATLASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
		m_pchData[GetData()->nDataLength] = '\0';
	}
}

inline const CString& CString::operator+=(LPCTSTR lpsz)
{
	ATLASSERT(lpsz == NULL || AfxIsValidString(lpsz, FALSE));
	ConcatInPlace(SafeStrlen(lpsz), lpsz);
	return *this;
}

inline const CString& CString::operator+=(TCHAR ch)
{
	ConcatInPlace(1, &ch);
	return *this;
}

inline const CString& CString::operator+=(const CString& string)
{
	ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
	return *this;
}

inline LPTSTR CString::GetBuffer(int nMinBufLength)
{
	ATLASSERT(nMinBufLength >= 0);

	if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
	{
		// we have to grow the buffer
		CStringData* pOldData = GetData();
		int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
		if (nMinBufLength < nOldLen)
			nMinBufLength = nOldLen;
		if(AllocBuffer(nMinBufLength))
		{
			memcpy(m_pchData, pOldData->data(), (nOldLen+1)*sizeof(TCHAR));
			GetData()->nDataLength = nOldLen;
			CString::Release(pOldData);
		}
	}
	ATLASSERT(GetData()->nRefs <= 1);

	// return a pointer to the character storage for this string
	ATLASSERT(m_pchData != NULL);
	return m_pchData;
}

inline void CString::ReleaseBuffer(int nNewLength)
{
	CopyBeforeWrite();  // just in case GetBuffer was not called

	if (nNewLength == -1)
		nNewLength = lstrlen(m_pchData); // zero terminated

	ATLASSERT(nNewLength <= GetData()->nAllocLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
}

inline LPTSTR CString::GetBufferSetLength(int nNewLength)
{
	ATLASSERT(nNewLength >= 0);

	GetBuffer(nNewLength);
	GetData()->nDataLength = nNewLength;
	m_pchData[nNewLength] = '\0';
	return m_pchData;
}

inline void CString::FreeExtra()
{
	ATLASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
	if (GetData()->nDataLength != GetData()->nAllocLength)
	{
		CStringData* pOldData = GetData();
		if(AllocBuffer(GetData()->nDataLength))
		{
			memcpy(m_pchData, pOldData->data(), pOldData->nDataLength*sizeof(TCHAR));
			ATLASSERT(m_pchData[GetData()->nDataLength] == '\0');
			CString::Release(pOldData);
		}
	}
	ATLASSERT(GetData() != NULL);
}

inline LPTSTR CString::LockBuffer()
{
	LPTSTR lpsz = GetBuffer(0);
	GetData()->nRefs = -1;
	return lpsz;
}

inline void CString::UnlockBuffer()
{
	ATLASSERT(GetData()->nRefs == -1);
	if (GetData() != afxDataNil)
		GetData()->nRefs = 1;
}

inline int CString::Find(TCHAR ch) const
{
	// find first single character
	LPTSTR lpsz = _tcschr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found and index otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

inline int CString::FindOneOf(LPCTSTR lpszCharSet) const
{
	ATLASSERT(AfxIsValidString(lpszCharSet, FALSE));
	LPTSTR lpsz = _tcspbrk(m_pchData, lpszCharSet);
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

inline void CString::MakeUpper()
{
	CopyBeforeWrite();
	_tcsupr(m_pchData);
}

inline void CString::MakeLower()
{
	CopyBeforeWrite();
	_tcslwr(m_pchData);
}

inline void CString::MakeReverse()
{
	CopyBeforeWrite();
	_tcsrev(m_pchData);
}

inline void CString::SetAt(int nIndex, TCHAR ch)
{
	ATLASSERT(nIndex >= 0);
	ATLASSERT(nIndex < GetData()->nDataLength);

	CopyBeforeWrite();
	m_pchData[nIndex] = ch;
}

#ifndef _UNICODE
inline void CString::AnsiToOem()
{
	CopyBeforeWrite();
	::AnsiToOem(m_pchData, m_pchData);
}
inline void CString::OemToAnsi()
{
	CopyBeforeWrite();
	::OemToAnsi(m_pchData, m_pchData);
}
#endif

// CString conversion helpers (these use the current system locale)

inline int __cdecl _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
{
	if (count == 0 && mbstr != NULL)
		return 0;

	int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1,
		mbstr, count, NULL, NULL);
	ATLASSERT(mbstr == NULL || result <= (int)count);
	if (result > 0)
		mbstr[result-1] = 0;
	return result;
}

inline int __cdecl _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
{
	if (count == 0 && wcstr != NULL)
		return 0;

	int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1,
		wcstr, count);
	ATLASSERT(wcstr == NULL || result <= (int)count);
	if (result > 0)
		wcstr[result-1] = 0;
	return result;
}

inline CString::CString(TCHAR ch, int nLength)
{
	ATLASSERT(!_istlead(ch));    // can't create a lead byte string
	Init();
	if (nLength >= 1)
	{
		if(AllocBuffer(nLength))
		{
#ifdef _UNICODE
			for (int i = 0; i < nLength; i++)
				m_pchData[i] = ch;
#else
			memset(m_pchData, ch, nLength);
#endif
		}
	}
}

inline CString::CString(LPCTSTR lpch, int nLength)
{
	Init();
	if (nLength != 0)
	{
		ATLASSERT(AfxIsValidAddress(lpch, nLength, FALSE));
		if(AllocBuffer(nLength))
			memcpy(m_pchData, lpch, nLength*sizeof(TCHAR));
	}
}

inline const CString& CString::operator=(TCHAR ch)
{
	ATLASSERT(!_istlead(ch));    // can't set single lead byte
	AssignCopy(1, &ch);
	return *this;
}

inline CString __stdcall operator+(const CString& string1, TCHAR ch)
{
	CString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
	return s;
}

inline CString __stdcall operator+(TCHAR ch, const CString& string)
{
	CString s;
	s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
	return s;
}

inline CString CString::Mid(int nFirst) const
{
	return Mid(nFirst, GetData()->nDataLength - nFirst);
}

inline CString CString::Mid(int nFirst, int nCount) const
{
	// out-of-bounds requests return sensible things
	if (nFirst < 0)
		nFirst = 0;
	if (nCount < 0)
		nCount = 0;

	if (nFirst + nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength - nFirst;
	if (nFirst > GetData()->nDataLength)
		nCount = 0;

	CString dest;
	AllocCopy(dest, nCount, nFirst, 0);
	return dest;
}

inline CString CString::Right(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	else if (nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength;

	CString dest;
	AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
	return dest;
}

inline CString CString::Left(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	else if (nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength;

	CString dest;
	AllocCopy(dest, nCount, 0, 0);
	return dest;
}

// strspn equivalent
inline CString CString::SpanIncluding(LPCTSTR lpszCharSet) const
{
	ATLASSERT(AfxIsValidString(lpszCharSet, FALSE));
	return Left(_tcsspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
inline CString CString::SpanExcluding(LPCTSTR lpszCharSet) const
{
	ATLASSERT(AfxIsValidString(lpszCharSet, FALSE));
	return Left(_tcscspn(m_pchData, lpszCharSet));
}

inline int CString::ReverseFind(TCHAR ch) const
{
	// find last single character
	LPTSTR lpsz = _tcsrchr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
inline int CString::Find(LPCTSTR lpszSub) const
{
	ATLASSERT(AfxIsValidString(lpszSub, FALSE));

	// find first matching substring
	LPTSTR lpsz = _tcsstr(m_pchData, lpszSub);

	// return -1 for not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

#define TCHAR_ARG   TCHAR
#define WCHAR_ARG   WCHAR
#define CHAR_ARG    char

struct _AFX_DOUBLE  { BYTE doubleBits[sizeof(double)]; };

#if defined(_X86_)
	#define DOUBLE_ARG  _AFX_DOUBLE
#else
	#define DOUBLE_ARG  double
#endif

#define FORCE_ANSI      0x10000
#define FORCE_UNICODE   0x20000

inline void CString::FormatV(LPCTSTR lpszFormat, va_list argList)
{
	ATLASSERT(AfxIsValidString(lpszFormat, FALSE));

	va_list argListSave = argList;

	// make a guess at the maximum length of the resulting string
	int nMaxLen = 0;
	for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
	{
		// handle '%' character, but watch out for '%%'
		if (*lpsz != '%' || *(lpsz = _tcsinc(lpsz)) == '%')
		{
			nMaxLen += _tclen(lpsz);
			continue;
		}

		int nItemLen = 0;

		// handle '%' character with format
		int nWidth = 0;
		for (; *lpsz != '\0'; lpsz = _tcsinc(lpsz))
		{
			// check for valid flags
			if (*lpsz == '#')
				nMaxLen += 2;   // for '0x'
			else if (*lpsz == '*')
				nWidth = va_arg(argList, int);
			else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' ||
				*lpsz == ' ')
				;
			else // hit non-flag character
				break;
		}
		// get width and skip it
		if (nWidth == 0)
		{
			// width indicated by
			nWidth = _ttoi(lpsz);
			for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
				;
		}
		ATLASSERT(nWidth >= 0);

		int nPrecision = 0;
		if (*lpsz == '.')
		{
			// skip past '.' separator (width.precision)
			lpsz = _tcsinc(lpsz);

			// get precision and skip it
			if (*lpsz == '*')
			{
				nPrecision = va_arg(argList, int);
				lpsz = _tcsinc(lpsz);
			}
			else
			{
				nPrecision = _ttoi(lpsz);
				for (; *lpsz != '\0' && _istdigit(*lpsz); lpsz = _tcsinc(lpsz))
					;
			}
			ATLASSERT(nPrecision >= 0);
		}

		// should be on type modifier or specifier
		int nModifier = 0;
		switch (*lpsz)
		{
		// modifiers that affect size
		case 'h':
			nModifier = FORCE_ANSI;
			lpsz = _tcsinc(lpsz);
			break;
		case 'l':
			nModifier = FORCE_UNICODE;
			lpsz = _tcsinc(lpsz);
			break;

		// modifiers that do not affect size
		case 'F':
		case 'N':
		case 'L':
			lpsz = _tcsinc(lpsz);
			break;
		}

		// now should be on specifier
		switch (*lpsz | nModifier)
		{
		// single characters
		case 'c':
		case 'C':
			nItemLen = 2;
			va_arg(argList, TCHAR_ARG);
			break;
		case 'c'|FORCE_ANSI:
		case 'C'|FORCE_ANSI:
			nItemLen = 2;
			va_arg(argList, CHAR_ARG);
			break;
		case 'c'|FORCE_UNICODE:
		case 'C'|FORCE_UNICODE:
			nItemLen = 2;
			va_arg(argList, WCHAR_ARG);
			break;

		// strings
		case 's':
		{
			LPCTSTR pstrNextArg = va_arg(argList, LPCTSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6;  // "(null)"
			else
			{
			   nItemLen = lstrlen(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
			break;
		}

		case 'S':
		{
#ifndef _UNICODE
			LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6;  // "(null)"
			else
			{
			   nItemLen = wcslen(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
#else
			LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6; // "(null)"
			else
			{
			   nItemLen = lstrlenA(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
#endif
			break;
		}

		case 's'|FORCE_ANSI:
		case 'S'|FORCE_ANSI:
		{
			LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6; // "(null)"
			else
			{
			   nItemLen = lstrlenA(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
			break;
		}

		case 's'|FORCE_UNICODE:
		case 'S'|FORCE_UNICODE:
		{
			LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
			if (pstrNextArg == NULL)
			   nItemLen = 6; // "(null)"
			else
			{
			   nItemLen = wcslen(pstrNextArg);
			   nItemLen = max(1, nItemLen);
			}
			break;
		}
		}

		// adjust nItemLen for strings
		if (nItemLen != 0)
		{
			nItemLen = max(nItemLen, nWidth);
			if (nPrecision != 0)
				nItemLen = min(nItemLen, nPrecision);
		}
		else
		{
			switch (*lpsz)
			{
			// integers
			case 'd':
			case 'i':
			case 'u':
			case 'x':
			case 'X':
			case 'o':
				va_arg(argList, int);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			case 'e':
			case 'f':
			case 'g':
			case 'G':
				va_arg(argList, DOUBLE_ARG);
				nItemLen = 128;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			case 'p':
				va_arg(argList, void*);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth+nPrecision);
				break;

			// no output
			case 'n':
				va_arg(argList, int*);
				break;

			default:
				ATLASSERT(FALSE);  // unknown formatting option
			}
		}

		// adjust nMaxLen for output nItemLen
		nMaxLen += nItemLen;
	}

	GetBuffer(nMaxLen);
	int nRet = _vstprintf(m_pchData, lpszFormat, argListSave);
	nRet;	// ref
	ATLASSERT(nRet <= GetAllocLength());
	ReleaseBuffer();

	va_end(argListSave);
}

// formatting (using wsprintf style formatting)
inline void __cdecl CString::Format(LPCTSTR lpszFormat, ...)
{
	ATLASSERT(AfxIsValidString(lpszFormat, FALSE));

	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
}

inline void __cdecl CString::Format(UINT nFormatID, ...)
{
	CString strFormat;
	BOOL bRet = strFormat.LoadString(nFormatID);
	bRet;	// ref
	ATLASSERT(bRet != 0);

	va_list argList;
	va_start(argList, nFormatID);
	FormatV(strFormat, argList);
	va_end(argList);
}

// formatting (using FormatMessage style formatting)
inline BOOL __cdecl CString::FormatMessage(LPCTSTR lpszFormat, ...)
{
	// format message into temporary buffer lpszTemp
	va_list argList;
	va_start(argList, lpszFormat);
	LPTSTR lpszTemp;
	BOOL bRet = TRUE;

	if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
		lpszFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 ||
		lpszTemp == NULL)
		bRet = FALSE;

	// assign lpszTemp into the resulting string and free the temporary
	*this = lpszTemp;
	LocalFree(lpszTemp);
	va_end(argList);
	return bRet;
}

inline BOOL __cdecl CString::FormatMessage(UINT nFormatID, ...)
{
	// get format string from string table
	CString strFormat;
	BOOL bRetTmp = strFormat.LoadString(nFormatID);
	bRetTmp;	// ref
	ATLASSERT(bRetTmp != 0);

	// format message into temporary buffer lpszTemp
	va_list argList;
	va_start(argList, nFormatID);
	LPTSTR lpszTemp;
	BOOL bRet = TRUE;

	if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ALLOCATE_BUFFER,
		strFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 ||
		lpszTemp == NULL)
		bRet = FALSE;

	// assign lpszTemp into the resulting string and free lpszTemp
	*this = lpszTemp;
	LocalFree(lpszTemp);
	va_end(argList);
	return bRet;
}

inline void CString::TrimRight()
{
	CopyBeforeWrite();

	// find beginning of trailing spaces by starting at beginning (DBCS aware)
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;
	while (*lpsz != '\0')
	{
		if (_istspace(*lpsz))
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
			lpszLast = NULL;
		lpsz = _tcsinc(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at trailing space start
		*lpszLast = '\0';
		GetData()->nDataLength = (int)(DWORD_PTR)(lpszLast - m_pchData);
	}
}

inline void CString::TrimLeft()
{
	CopyBeforeWrite();

	// find first non-space character
	LPCTSTR lpsz = m_pchData;
	while (_istspace(*lpsz))
		lpsz = _tcsinc(lpsz);

	// fix up data and length
	int nDataLength = GetData()->nDataLength - (int)(DWORD_PTR)(lpsz - m_pchData);
	memmove(m_pchData, lpsz, (nDataLength+1)*sizeof(TCHAR));
	GetData()->nDataLength = nDataLength;
}

#ifdef _UNICODE
#define CHAR_FUDGE 1    // one TCHAR unused is good enough
#else
#define CHAR_FUDGE 2    // two BYTES unused for case of DBC last char
#endif

inline BOOL CString::LoadString(UINT nID)
{
	// try fixed buffer first (to avoid wasting space in the heap)
	TCHAR szTemp[256];
	int nCount =  sizeof(szTemp) / sizeof(szTemp[0]);
	int nLen = AfxLoadString(nID, szTemp, nCount);
	if (nCount - nLen > CHAR_FUDGE)
	{
		*this = szTemp;
		return nLen > 0;
	}

	// try buffer size of 512, then larger size until entire string is retrieved
	int nSize = 256;
	do
	{
		nSize += 256;
		nLen = AfxLoadString(nID, GetBuffer(nSize-1), nSize);
	} while (nSize - nLen <= CHAR_FUDGE);
	ReleaseBuffer();

	return nLen > 0;
}

inline int __stdcall AfxLoadString(UINT nID, LPTSTR lpszBuf, UINT nMaxBuf)
{
	ATLASSERT(AfxIsValidAddress(lpszBuf, nMaxBuf*sizeof(TCHAR)));
#ifdef _DEBUG
	// LoadString without annoying warning from the Debug kernel if the
	//  segment containing the string is not present
	if (::FindResource(_Module.GetResourceInstance(),
	   MAKEINTRESOURCE((nID>>4)+1), RT_STRING) == NULL)
	{
		lpszBuf[0] = '\0';
		return 0; // not found
	}
#endif //_DEBUG
	int nLen = ::LoadString(_Module.GetResourceInstance(), nID, lpszBuf, nMaxBuf);
	if (nLen == 0)
		lpszBuf[0] = '\0';
	return nLen;
}

#ifndef _ATL_NO_COM
inline BSTR CString::AllocSysString() const
{
#if defined(_UNICODE) || defined(OLE2ANSI)
	BSTR bstr = ::SysAllocStringLen(m_pchData, GetData()->nDataLength);
#else
	int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
		GetData()->nDataLength, NULL, NULL);
	BSTR bstr = ::SysAllocStringLen(NULL, nLen);
	if(bstr != NULL)
		MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength, bstr, nLen);
#endif
	return bstr;
}

inline BSTR CString::SetSysString(BSTR* pbstr) const
{
	ATLASSERT(AfxIsValidAddress(pbstr, sizeof(BSTR)));

#if defined(_UNICODE) || defined(OLE2ANSI)
	::SysReAllocStringLen(pbstr, m_pchData, GetData()->nDataLength);
#else
	int nLen = MultiByteToWideChar(CP_ACP, 0, m_pchData,
		GetData()->nDataLength, NULL, NULL);
	if(::SysReAllocStringLen(pbstr, NULL, nLen))
		MultiByteToWideChar(CP_ACP, 0, m_pchData, GetData()->nDataLength, *pbstr, nLen);
#endif
	ATLASSERT(*pbstr != NULL);
	return *pbstr;
}
#endif //!_ATL_NO_COM

#endif //!_ATL_TMP_NO_CSTRING

}; //namespace ATL

#endif // __ATLTMP_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\atl\atlgdi.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLGDI_H__
#define __ATLGDI_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLBASE_H__
	#error atlgdi.h requires atlbase.h to be included first
#endif

#include <commctrl.h>


#ifdef UNDER_CE

#ifdef TrackPopupMenu
#undef TrackPopupMenu
#endif //TrackPopupMenu

//REVIEW
BOOL IsMenu(HMENU hMenu)
{
	return (hMenu != NULL);
}

#endif //UNDER_CE


namespace ATL
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

class CDC;
class CPaintDC;
class CClientDC;
class CWindowDC;
class CMenu;
class CPen;
class CBrush;
class CFont;
class CBitmap;
class CPalette;
class CRgn;

/////////////////////////////////////////////////////////////////////////////
// CDC - The device context class

class CDC
{
public:

// Attributes
	HDC m_hDC;

	BOOL m_bAutoRestore;

	HPEN m_hOriginalPen;
	HBRUSH m_hOriginalBrush;
//	HPALETTE m_hOriginalPalette;
	HFONT m_hOriginalFont;
	HBITMAP m_hOriginalBitmap;

	void RestoreAllObjects()
	{
		if(m_hOriginalPen != NULL)
		{
#ifndef UNDER_CE
			ATLASSERT(::GetObjectType(m_hOriginalPen) == OBJ_PEN || ::GetObjectType(m_hOriginalPen) == OBJ_EXTPEN);
#else // CE specific
			ATLASSERT(::GetObjectType(m_hOriginalPen) == OBJ_PEN);
#endif //!UNDER_CE
			::SelectObject(m_hDC, m_hOriginalPen);
			m_hOriginalPen = NULL;
		}
		if(m_hOriginalBrush != NULL)
		{
			ATLASSERT(::GetObjectType(m_hOriginalBrush) == OBJ_BRUSH);
			::SelectObject(m_hDC, m_hOriginalBrush);
			m_hOriginalBrush = NULL;
		}
//		if(m_hOriginalPalette != NULL)
//		{
//			ATLASSERT(::GetObjectType(m_hOriginalPalette) == OBJ_PAL);
//			::SelectPalette(m_hDC, m_hOriginalPalette, FALSE);
//			m_hOriginalPalette = NULL;
//		}
		if(m_hOriginalFont != NULL)
		{
			ATLASSERT(::GetObjectType(m_hOriginalFont) == OBJ_FONT);
			::SelectObject(m_hDC, m_hOriginalFont);
			m_hOriginalFont = NULL;
		}
		if(m_hOriginalBitmap != NULL)
		{
			ATLASSERT(::GetObjectType(m_hOriginalBitmap) == OBJ_BITMAP);
			::SelectObject(m_hDC, m_hOriginalBitmap);
			m_hOriginalBitmap = NULL;
		}
	}

	CDC(HDC hDC = NULL, BOOL bAutoRestore = TRUE) : m_hDC(hDC), m_bAutoRestore(bAutoRestore),
		m_hOriginalPen(NULL), m_hOriginalBrush(NULL), m_hOriginalFont(NULL), m_hOriginalBitmap(NULL)
	{
	}

	~CDC()
	{
		if(m_hDC != NULL)
		{
			if(m_bAutoRestore)
				RestoreAllObjects();
			::DeleteDC(Detach());
		}
	}

	CDC& operator=(HDC hDC)
	{
		m_hDC = hDC;
		return *this;
	}

	void Attach(HDC hDC)
	{
		m_hDC = hDC;
	}

	HDC Detach()
	{
		HDC hDC = m_hDC;
		m_hDC = NULL;
		return hDC;
	}

	operator HDC() const { return m_hDC; }

#ifndef UNDER_CE
	HWND WindowFromDC() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::WindowFromDC(m_hDC);
	}
#endif //!UNDER_CE

	HPEN GetCurrentPen() const
	{
		ATLASSERT(m_hDC != NULL);
		return (HPEN)::GetCurrentObject(m_hDC, OBJ_PEN);
	}
	HBRUSH GetCurrentBrush() const
	{
		ATLASSERT(m_hDC != NULL);
		return (HBRUSH)::GetCurrentObject(m_hDC, OBJ_BRUSH);
	}
	HPALETTE GetCurrentPalette() const
	{
		ATLASSERT(m_hDC != NULL);
		return (HPALETTE)::GetCurrentObject(m_hDC, OBJ_PAL);
	}
	HFONT GetCurrentFont() const
	{
		ATLASSERT(m_hDC != NULL);
		return (HFONT)::GetCurrentObject(m_hDC, OBJ_FONT);
	}
	HBITMAP GetCurrentBitmap() const
	{
		ATLASSERT(m_hDC != NULL);
		return (HBITMAP)::GetCurrentObject(m_hDC, OBJ_BITMAP);
	}

	HDC CreateDC(LPCTSTR lpszDriverName, LPCTSTR lpszDeviceName,
		LPCTSTR lpszOutput, const DEVMODE* lpInitData)
	{
		ATLASSERT(m_hDC == NULL);
		m_hDC = ::CreateDC(lpszDriverName, lpszDeviceName, lpszOutput, lpInitData);
		return m_hDC;
	}

	HDC CreateCompatibleDC(HDC hDC = NULL)
	{
		ATLASSERT(m_hDC == NULL);
		m_hDC = ::CreateCompatibleDC(hDC);
		return m_hDC;
	}

	BOOL DeleteDC()
	{
		if(m_hDC == NULL)
			return FALSE;

		if(m_bAutoRestore)
			RestoreAllObjects();

		return ::DeleteDC(Detach());
	}

// Device-Context Functions
	int SaveDC()
	{
		ATLASSERT(m_hDC != NULL);
		return ::SaveDC(m_hDC);
	}

	BOOL RestoreDC(int nSavedDC)
	{
		ATLASSERT(m_hDC != NULL);
		return ::RestoreDC(m_hDC, nSavedDC);
	}

	int GetDeviceCaps(int nIndex) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetDeviceCaps(m_hDC, nIndex);
	}
#ifndef UNDER_CE
	UINT SetBoundsRect(LPCRECT lpRectBounds, UINT flags)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetBoundsRect(m_hDC, lpRectBounds, flags);
	}
	UINT GetBoundsRect(LPRECT lpRectBounds, UINT flags)
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetBoundsRect(m_hDC, lpRectBounds, flags);
	}
	BOOL ResetDC(const DEVMODE* lpDevMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ResetDC(m_hDC, lpDevMode) != NULL;
	}
#endif //!UNDER_CE

// Drawing-Tool Functions
#ifndef UNDER_CE
	BOOL GetBrushOrg(LPPOINT lpPoint) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetBrushOrgEx(m_hDC, lpPoint);
	}
#endif //!UNDER_CE
	BOOL SetBrushOrg(int x, int y, LPPOINT lpPoint = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetBrushOrgEx(m_hDC, x, y, lpPoint);
	}
	BOOL SetBrushOrg(POINT point, LPPOINT lpPointRet = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetBrushOrgEx(m_hDC, point.x, point.y, lpPointRet);
	}
#ifndef UNDER_CE
	int EnumObjects(int nObjectType, int (CALLBACK* lpfn)(LPVOID, LPARAM), LPARAM lpData)
	{
		ATLASSERT(m_hDC != NULL);
#ifdef STRICT
		return ::EnumObjects(m_hDC, nObjectType, (GOBJENUMPROC)lpfn, lpData);
#else
		return ::EnumObjects(m_hDC, nObjectType, (GOBJENUMPROC)lpfn, (LPVOID)lpData);
#endif
	}
#endif //!UNDER_CE

// Type-safe selection helpers
	HPEN SelectPen(HPEN hPen)
	{
		ATLASSERT(m_hDC != NULL);
#ifndef UNDER_CE
		ATLASSERT(::GetObjectType(hPen) == OBJ_PEN || ::GetObjectType(hPen) == OBJ_EXTPEN);
#else // CE specific
		ATLASSERT(::GetObjectType(hPen) == OBJ_PEN);
#endif //!UNDER_CE
		HPEN hOldPen = (HPEN)::SelectObject(m_hDC, hPen);
		if(m_hOriginalPen == NULL)
			m_hOriginalPen = hOldPen;
		return hOldPen;
	}
	HBRUSH SelectBrush(HBRUSH hBrush)
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(::GetObjectType(hBrush) == OBJ_BRUSH);
		HBRUSH hOldBrush = (HBRUSH)::SelectObject(m_hDC, hBrush);
		if(m_hOriginalBrush == NULL)
			m_hOriginalBrush = hOldBrush;
		return hOldBrush;
	}
	HFONT SelectFont(HFONT hFont)
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(::GetObjectType(hFont) == OBJ_FONT);
		HFONT hOldFont = (HFONT)::SelectObject(m_hDC, hFont);
		if(m_hOriginalFont == NULL)
			m_hOriginalFont = hOldFont;
		return hOldFont;
	}
	HBITMAP SelectBitmap(HBITMAP hBitmap)
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(::GetObjectType(hBitmap) == OBJ_BITMAP);
		HBITMAP hOldBitmap = (HBITMAP)::SelectObject(m_hDC, hBitmap);
		if(m_hOriginalBitmap == NULL)
			m_hOriginalBitmap = hOldBitmap;
		return hOldBitmap;
	}
	HGDIOBJ SelectRgn(HRGN hRgn)       // special return for regions
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(::GetObjectType(hRgn) == OBJ_REGION);
		return ::SelectObject(m_hDC, hRgn);
	}

	HGDIOBJ SelectStockObject(int nIndex)
	{
		ATLASSERT(m_hDC != NULL);
		HGDIOBJ hObject = ::GetStockObject(nIndex);
		ATLASSERT(hObject != NULL);
		switch(::GetObjectType(hObject))
		{
		case OBJ_PEN:
#ifndef UNDER_CE
/*?*/		case OBJ_EXTPEN:
#endif //!UNDER_CE
			return SelectPen((HPEN)hObject);
		case OBJ_BRUSH:
			return SelectBrush((HBRUSH)hObject);
		case OBJ_FONT:
			return SelectFont((HFONT)hObject);
		default:
			return NULL;
		}
	}

// Color and Color Palette Functions
	COLORREF GetNearestColor(COLORREF crColor) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetNearestColor(m_hDC, crColor);
	}
	HPALETTE SelectPalette(HPALETTE hPalette, BOOL bForceBackground)
	{
		ATLASSERT(m_hDC != NULL);

		HPALETTE hOldPal = ::SelectPalette(m_hDC, hPalette, bForceBackground);
//		if(/*m_bAutoRestore && */m_hOriginalPal == NULL)
//			m_hOriginalPal = hOldPal;
		return hOldPal;
	}
	UINT RealizePalette()
	{
		ATLASSERT(m_hDC != NULL);
		return ::RealizePalette(m_hDC);
	}
#ifndef UNDER_CE
	void UpdateColors()
	{
		ATLASSERT(m_hDC != NULL);
		::UpdateColors(m_hDC);
	}
#endif //!UNDER_CE

// Drawing-Attribute Functions
	COLORREF GetBkColor() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetBkColor(m_hDC);
	}
	int GetBkMode() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetBkMode(m_hDC);
	}
#ifndef UNDER_CE
	int GetPolyFillMode() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetPolyFillMode(m_hDC);
	}
	int GetROP2() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetROP2(m_hDC);
	}
	int GetStretchBltMode() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetStretchBltMode(m_hDC);
	}
#endif //!UNDER_CE
	COLORREF GetTextColor() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextColor(m_hDC);
	}

	COLORREF SetBkColor(COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetBkColor(m_hDC, crColor);
	}
	int SetBkMode(int nBkMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetBkMode(m_hDC, nBkMode);
	}
#ifndef UNDER_CE
	int SetPolyFillMode(int nPolyFillMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetPolyFillMode(m_hDC, nPolyFillMode);
	}
#endif //!UNDER_CE
	int SetROP2(int nDrawMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetROP2(m_hDC, nDrawMode);
	}
#ifndef UNDER_CE
	int SetStretchBltMode(int nStretchMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetStretchBltMode(m_hDC, nStretchMode);
	}
#endif //!UNDER_CE
	COLORREF SetTextColor(COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetTextColor(m_hDC, crColor);
	}

#ifndef UNDER_CE
	BOOL GetColorAdjustment(LPCOLORADJUSTMENT lpColorAdjust) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetColorAdjustment(m_hDC, lpColorAdjust);
	}
	BOOL SetColorAdjustment(const COLORADJUSTMENT* lpColorAdjust)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetColorAdjustment(m_hDC, lpColorAdjust);
	}
#endif //!UNDER_CE

// Mapping Functions
#ifndef UNDER_CE
	int GetMapMode() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetMapMode(m_hDC);
	}
	BOOL GetViewportOrg(LPPOINT lpPoint) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetViewportOrgEx(m_hDC, lpPoint);
	}
	int SetMapMode(int nMapMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetMapMode(m_hDC, nMapMode);
	}
	// Viewport Origin
	BOOL SetViewportOrg(int x, int y, LPPOINT lpPoint = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetViewportOrgEx(m_hDC, x, y, lpPoint);
	}
	BOOL SetViewportOrg(POINT point, LPPOINT lpPointRet = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return SetViewportOrg(point.x, point.y, lpPointRet);
	}
	BOOL OffsetViewportOrg(int nWidth, int nHeight, LPPOINT lpPoint = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::OffsetViewportOrgEx(m_hDC, nWidth, nHeight, lpPoint);
	}

	// Viewport Extent
	BOOL GetViewportExt(LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetViewportExtEx(m_hDC, lpSize);
	}
	BOOL SetViewportExt(int x, int y, LPSIZE lpSize = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetViewportExtEx(m_hDC, x, y, lpSize);
	}
	BOOL SetViewportExt(SIZE size, LPSIZE lpSizeRet = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return SetViewportExt(size.cx, size.cy, lpSizeRet);
	}
	BOOL ScaleViewportExt(int xNum, int xDenom, int yNum, int yDenom, LPSIZE lpSize = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ScaleViewportExtEx(m_hDC, xNum, xDenom, yNum, yDenom, lpSize);
	}

	// Window Origin
	BOOL GetWindowOrg(LPPOINT lpPoint) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetWindowOrgEx(m_hDC, lpPoint);
	}
	BOOL SetWindowOrg(int x, int y, LPPOINT lpPoint = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetWindowOrgEx(m_hDC, x, y, lpPoint);
	}
	BOOL SetWindowOrg(POINT point, LPPOINT lpPointRet = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return SetWindowOrg(point.x, point.y, lpPointRet);
	}
	BOOL OffsetWindowOrg(int nWidth, int nHeight, LPPOINT lpPoint = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::OffsetWindowOrgEx(m_hDC, nWidth, nHeight, lpPoint);
	}

	// Window extent
	BOOL GetWindowExt(LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetWindowExtEx(m_hDC, lpSize);
	}
	BOOL SetWindowExt(int x, int y, LPSIZE lpSize = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetWindowExtEx(m_hDC, x, y, lpSize);
	}
	BOOL SetWindowExt(SIZE size, LPSIZE lpSizeRet)
	{
		ATLASSERT(m_hDC != NULL);
		return SetWindowExt(size.cx, size.cy, lpSizeRet);
	}
	BOOL ScaleWindowExt(int xNum, int xDenom, int yNum, int yDenom, LPSIZE lpSize = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ScaleWindowExtEx(m_hDC, xNum, xDenom, yNum, yDenom, lpSize);
	}

// Coordinate Functions
	BOOL DPtoLP(LPPOINT lpPoints, int nCount = 1) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::DPtoLP(m_hDC, lpPoints, nCount);
	}
	BOOL DPtoLP(LPRECT lpRect) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::DPtoLP(m_hDC, (LPPOINT)lpRect, 2);
	}
	BOOL DPtoLP(LPSIZE lpSize) const
	{
		SIZE sizeWinExt;
		if(!GetWindowExt(&sizeWinExt))
			return FALSE;
		SIZE sizeVpExt;
		if(!GetViewportExt(&sizeVpExt))
			return FALSE;
		lpSize->cx = MulDiv(lpSize->cx, abs(sizeWinExt.cx), abs(sizeVpExt.cx));
		lpSize->cy = MulDiv(lpSize->cy, abs(sizeWinExt.cy), abs(sizeVpExt.cy));
		return TRUE;
	}
	BOOL LPtoDP(LPPOINT lpPoints, int nCount = 1) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::LPtoDP(m_hDC, lpPoints, nCount);
	}
	BOOL LPtoDP(LPRECT lpRect) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::LPtoDP(m_hDC, (LPPOINT)lpRect, 2);
	}
	BOOL LPtoDP(LPSIZE lpSize) const
	{
		SIZE sizeWinExt;
		if(!GetWindowExt(&sizeWinExt))
			return FALSE;
		SIZE sizeVpExt;
		if(!GetViewportExt(&sizeVpExt))
			return FALSE;
		lpSize->cx = MulDiv(lpSize->cx, abs(sizeVpExt.cx), abs(sizeWinExt.cx));
		lpSize->cy = MulDiv(lpSize->cy, abs(sizeVpExt.cy), abs(sizeWinExt.cy));
		return TRUE;
	}

// Special Coordinate Functions (useful for dealing with metafiles and OLE)
	#define HIMETRIC_INCH   2540    // HIMETRIC units per inch

	void DPtoHIMETRIC(LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		int nMapMode;
		if((nMapMode = GetMapMode()) < MM_ISOTROPIC && nMapMode != MM_TEXT)
		{
			// when using a constrained map mode, map against physical inch
			((CDC*)this)->SetMapMode(MM_HIMETRIC);
			DPtoLP(lpSize);
			((CDC*)this)->SetMapMode(nMapMode);
		}
		else
		{
			// map against logical inch for non-constrained mapping modes
			int cxPerInch = GetDeviceCaps(LOGPIXELSX);
			int cyPerInch = GetDeviceCaps(LOGPIXELSY);
			ATLASSERT(cxPerInch != 0 && cyPerInch != 0);
			lpSize->cx = MulDiv(lpSize->cx, HIMETRIC_INCH, cxPerInch);
			lpSize->cy = MulDiv(lpSize->cy, HIMETRIC_INCH, cyPerInch);
		}
	}

	void HIMETRICtoDP(LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		int nMapMode;
		if((nMapMode = GetMapMode()) < MM_ISOTROPIC && nMapMode != MM_TEXT)
		{
			// when using a constrained map mode, map against physical inch
			((CDC*)this)->SetMapMode(MM_HIMETRIC);
			LPtoDP(lpSize);
			((CDC*)this)->SetMapMode(nMapMode);
		}
		else
		{
			// map against logical inch for non-constrained mapping modes
			int cxPerInch = GetDeviceCaps(LOGPIXELSX);
			int cyPerInch = GetDeviceCaps(LOGPIXELSY);
			ATLASSERT(cxPerInch != 0 && cyPerInch != 0);
			lpSize->cx = MulDiv(lpSize->cx, cxPerInch, HIMETRIC_INCH);
			lpSize->cy = MulDiv(lpSize->cy, cyPerInch, HIMETRIC_INCH);
		}
	}

	void LPtoHIMETRIC(LPSIZE lpSize) const
	{
		LPtoDP(lpSize);
		DPtoHIMETRIC(lpSize);
	}

	void HIMETRICtoLP(LPSIZE lpSize) const
	{
		HIMETRICtoDP(lpSize);
		DPtoLP(lpSize);
	}
#endif //!UNDER_CE

// Region Functions
	BOOL FillRgn(HRGN hRgn, HBRUSH hBrush)
	{
		ATLASSERT(m_hDC != NULL);
		return ::FillRgn(m_hDC, hRgn, hBrush);
	}
#ifndef UNDER_CE
	BOOL FrameRgn(HRGN hRgn, HBRUSH hBrush, int nWidth, int nHeight)
	{
		ATLASSERT(m_hDC != NULL);
		return ::FrameRgn(m_hDC, hRgn, hBrush, nWidth, nHeight);
	}
	BOOL InvertRgn(HRGN hRgn)
	{
		ATLASSERT(m_hDC != NULL);
		return ::InvertRgn(m_hDC, hRgn);
	}
	BOOL PaintRgn(HRGN hRgn)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PaintRgn(m_hDC, hRgn);
	}
#endif //!UNDER_CE

// Clipping Functions
	int GetClipBox(LPRECT lpRect) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetClipBox(m_hDC, lpRect);
	}
#ifndef UNDER_CE
	BOOL PtVisible(int x, int y) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::PtVisible(m_hDC, x, y);
	}
	BOOL PtVisible(POINT point) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::PtVisible(m_hDC, point.x, point.y);
	}
#endif //!UNDER_CE
	BOOL RectVisible(LPCRECT lpRect) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::RectVisible(m_hDC, lpRect);
	}
	int SelectClipRgn(HRGN hRgn)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SelectClipRgn(m_hDC, (HRGN)hRgn);
	}
	int ExcludeClipRect(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ExcludeClipRect(m_hDC, x1, y1, x2, y2);
	}
	int ExcludeClipRect(LPCRECT lpRect)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ExcludeClipRect(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
	}
#ifndef UNDER_CE
	int ExcludeUpdateRgn(HWND hWnd)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ExcludeUpdateRgn(m_hDC, hWnd);
	}
#endif //!UNDER_CE
	int IntersectClipRect(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hDC != NULL);
		return ::IntersectClipRect(m_hDC, x1, y1, x2, y2);
	}
	int IntersectClipRect(LPCRECT lpRect)
	{
		ATLASSERT(m_hDC != NULL);
		return ::IntersectClipRect(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
	}
#ifndef UNDER_CE
	int OffsetClipRgn(int x, int y)
	{
		ATLASSERT(m_hDC != NULL);
		return ::OffsetClipRgn(m_hDC, x, y);
	}
	int OffsetClipRgn(SIZE size)
	{
		ATLASSERT(m_hDC != NULL);
		return ::OffsetClipRgn(m_hDC, size.cx, size.cy);
	}
	int SelectClipRgn(HRGN hRgn, int nMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ExtSelectClipRgn(m_hDC, hRgn, nMode);
	}
#endif //!UNDER_CE

// Line-Output Functions
#ifndef UNDER_CE
//REVIEW
	BOOL GetCurrentPosition(LPPOINT lpPoint) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCurrentPositionEx(m_hDC, lpPoint);
	}
	BOOL MoveTo(int x, int y, LPPOINT lpPoint = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::MoveToEx(m_hDC, x, y, lpPoint);
	}
	BOOL MoveTo(POINT point, LPPOINT lpPointRet = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return MoveTo(point.x, point.y, lpPointRet);
	}
	BOOL LineTo(int x, int y)
	{
		ATLASSERT(m_hDC != NULL);
		return ::LineTo(m_hDC, x, y);
	}
	BOOL LineTo(POINT point)
	{
		ATLASSERT(m_hDC != NULL);
		return LineTo(point.x, point.y);
	}
	BOOL Arc(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Arc(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
	}
	BOOL Arc(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Arc(m_hDC, lpRect->left, lpRect->top,
			lpRect->right, lpRect->bottom, ptStart.x, ptStart.y,
			ptEnd.x, ptEnd.y);
	}
#endif //!UNDER_CE
	BOOL Polyline(LPPOINT lpPoints, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Polyline(m_hDC, lpPoints, nCount);
	}

#ifndef UNDER_CE
	BOOL AngleArc(int x, int y, int nRadius, float fStartAngle, float fSweepAngle)
	{
		ATLASSERT(m_hDC != NULL);
		return ::AngleArc(m_hDC, x, y, nRadius, fStartAngle, fSweepAngle);
	}
	BOOL ArcTo(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ArcTo(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
	}
	BOOL ArcTo(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{
		ATLASSERT(m_hDC != NULL);
		return ArcTo(lpRect->left, lpRect->top, lpRect->right,
		lpRect->bottom, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y);
	}
	int GetArcDirection() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetArcDirection(m_hDC);
	}
	int SetArcDirection(int nArcDirection)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetArcDirection(m_hDC, nArcDirection);
	}

	BOOL PolyDraw(const POINT* lpPoints, const BYTE* lpTypes, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PolyDraw(m_hDC, lpPoints, lpTypes, nCount);
	}
	BOOL PolylineTo(const POINT* lpPoints, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PolylineTo(m_hDC, lpPoints, nCount);
	}
	BOOL PolyPolyline(const POINT* lpPoints,
		const DWORD* lpPolyPoints, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PolyPolyline(m_hDC, lpPoints, lpPolyPoints, nCount);
	}

	BOOL PolyBezier(const POINT* lpPoints, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PolyBezier(m_hDC, lpPoints, nCount);
	}
	BOOL PolyBezierTo(const POINT* lpPoints, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PolyBezierTo(m_hDC, lpPoints, nCount);
	}
#endif //!UNDER_CE

// Simple Drawing Functions
	BOOL FillRect(LPCRECT lpRect, HBRUSH hBrush)
	{
		ATLASSERT(m_hDC != NULL);
		return ::FillRect(m_hDC, lpRect, hBrush);
	}
#ifndef UNDER_CE
	BOOL FrameRect(LPCRECT lpRect, HBRUSH hBrush)
	{
		ATLASSERT(m_hDC != NULL);
		return ::FrameRect(m_hDC, lpRect, hBrush);
	}
	BOOL InvertRect(LPCRECT lpRect)
	{
		ATLASSERT(m_hDC != NULL);
		return ::InvertRect(m_hDC, lpRect);
	}
	BOOL DrawIcon(int x, int y, HICON hIcon)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawIcon(m_hDC, x, y, hIcon);
	}
	BOOL DrawIcon(POINT point, HICON hIcon)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawIcon(m_hDC, point.x, point.y, hIcon);
	}

	BOOL DrawState(POINT pt, SIZE size, HBITMAP hBitmap, UINT nFlags, HBRUSH hBrush = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawState(m_hDC, hBrush, NULL, (LPARAM)hBitmap, 0, pt.x, pt.y, size.cx, size.cy, nFlags | DST_BITMAP);
	}
	BOOL DrawState(POINT pt, SIZE size, LPCTSTR lpszText, UINT nFlags,
		BOOL bPrefixText = TRUE, int nTextLen = 0, HBRUSH hBrush = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawState(m_hDC, hBrush, NULL, (LPARAM)lpszText, (WPARAM)nTextLen, pt.x, pt.y, size.cx, size.cy, nFlags | (bPrefixText ? DST_PREFIXTEXT : DST_TEXT));
	}
	BOOL DrawState(POINT pt, SIZE size, DRAWSTATEPROC lpDrawProc,
		LPARAM lData, UINT nFlags, HBRUSH hBrush = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawState(m_hDC, hBrush, lpDrawProc, lData, 0, pt.x, pt.y, size.cx, size.cy, nFlags | DST_COMPLEX);
	}
#endif //!UNDER_CE

// Ellipse and Polygon Functions
#ifndef UNDER_CE
	BOOL Chord(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Chord(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
	}
	BOOL Chord(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Chord(m_hDC, lpRect->left, lpRect->top,
			lpRect->right, lpRect->bottom, ptStart.x, ptStart.y,
			ptEnd.x, ptEnd.y);
	}
#endif //!UNDER_CE
	void DrawFocusRect(LPCRECT lpRect)
	{
		ATLASSERT(m_hDC != NULL);
		::DrawFocusRect(m_hDC, lpRect);
	}
	BOOL Ellipse(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Ellipse(m_hDC, x1, y1, x2, y2);
	}
	BOOL Ellipse(LPCRECT lpRect)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Ellipse(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
	}
#ifndef UNDER_CE
	BOOL Pie(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Pie(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4);
	}
	BOOL Pie(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Pie(m_hDC, lpRect->left, lpRect->top,
			lpRect->right, lpRect->bottom, ptStart.x, ptStart.y,
			ptEnd.x, ptEnd.y);
	}
#endif //!UNDER_CE
	BOOL Polygon(LPPOINT lpPoints, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Polygon(m_hDC, lpPoints, nCount);
	}
#ifndef UNDER_CE
	BOOL PolyPolygon(LPPOINT lpPoints, LPINT lpPolyCounts, int nCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PolyPolygon(m_hDC, lpPoints, lpPolyCounts, nCount);
	}
#endif //!UNDER_CE
	BOOL Rectangle(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Rectangle(m_hDC, x1, y1, x2, y2);
	}
	BOOL Rectangle(LPCRECT lpRect)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Rectangle(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
	}
	BOOL RoundRect(int x1, int y1, int x2, int y2, int x3, int y3)
	{
		ATLASSERT(m_hDC != NULL);
		return ::RoundRect(m_hDC, x1, y1, x2, y2, x3, y3);
	}
	BOOL RoundRect(LPCRECT lpRect, POINT point)
	{
		ATLASSERT(m_hDC != NULL);
		return ::RoundRect(m_hDC, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom, point.x, point.y);
	}

// Bitmap Functions
	BOOL PatBlt(int x, int y, int nWidth, int nHeight, DWORD dwRop)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PatBlt(m_hDC, x, y, nWidth, nHeight, dwRop);
	}
	BOOL BitBlt(int x, int y, int nWidth, int nHeight, HDC hSrcDC,
		int xSrc, int ySrc, DWORD dwRop)
	{
		ATLASSERT(m_hDC != NULL);
		return ::BitBlt(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, dwRop);
	}
	BOOL StretchBlt(int x, int y, int nWidth, int nHeight, HDC hSrcDC,
		int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, DWORD dwRop)
	{
		ATLASSERT(m_hDC != NULL);
		return ::StretchBlt(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, nSrcWidth, nSrcHeight, dwRop);
	}
	COLORREF GetPixel(int x, int y) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetPixel(m_hDC, x, y);
	}
	COLORREF GetPixel(POINT point) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetPixel(m_hDC, point.x, point.y);
	}
	COLORREF SetPixel(int x, int y, COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetPixel(m_hDC, x, y, crColor);
	}
	COLORREF SetPixel(POINT point, COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetPixel(m_hDC, point.x, point.y, crColor);
	}
#ifndef UNDER_CE
	BOOL FloodFill(int x, int y, COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::FloodFill(m_hDC, x, y, crColor);
	}
	BOOL ExtFloodFill(int x, int y, COLORREF crColor, UINT nFillType)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ExtFloodFill(m_hDC, x, y, crColor, nFillType);
	}
#endif //!UNDER_CE
	BOOL MaskBlt(int x, int y, int nWidth, int nHeight, HDC hSrcDC,
		int xSrc, int ySrc, HBITMAP hMaskBitmap, int xMask, int yMask,
		DWORD dwRop)
	{
		ATLASSERT(m_hDC != NULL);
		return ::MaskBlt(m_hDC, x, y, nWidth, nHeight, hSrcDC, xSrc, ySrc, hMaskBitmap, xMask, yMask, dwRop);
	}
#ifndef UNDER_CE
	BOOL PlgBlt(LPPOINT lpPoint, HDC hSrcDC, int xSrc, int ySrc,
		int nWidth, int nHeight, HBITMAP hMaskBitmap, int xMask, int yMask)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PlgBlt(m_hDC, lpPoint, hSrcDC, xSrc, ySrc, nWidth, nHeight, hMaskBitmap, xMask, yMask);
	}
	BOOL SetPixelV(int x, int y, COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetPixelV(m_hDC, x, y, crColor);
	}
	BOOL SetPixelV(POINT point, COLORREF crColor)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetPixelV(m_hDC, point.x, point.y, crColor);
	}
#endif //!UNDER_CE

// Text Functions
#ifndef UNDER_CE
	BOOL TextOut(int x, int y, LPCTSTR lpszString, int nCount = -1)
	{
		ATLASSERT(m_hDC != NULL);
		if(nCount == -1)
			nCount = lstrlen(lpszString);
		return ::TextOut(m_hDC, x, y, lpszString, nCount);
	}
#endif //!UNDER_CE
	BOOL ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
				LPCTSTR lpszString, UINT nCount = -1, LPINT lpDxWidths = NULL)
	{
		ATLASSERT(m_hDC != NULL);
		if(nCount == -1)
			nCount = lstrlen(lpszString);
		return ::ExtTextOut(m_hDC, x, y, nOptions, lpRect, lpszString, nCount, lpDxWidths);
	}
#ifndef UNDER_CE
	SIZE TabbedTextOut(int x, int y, LPCTSTR lpszString, int nCount = -1,
			int nTabPositions = 0, LPINT lpnTabStopPositions = NULL, int nTabOrigin = 0)
	{
		ATLASSERT(m_hDC != NULL);
		if(nCount == -1)
			nCount = lstrlen(lpszString);
		SIZE size;
		LONG lRes = ::TabbedTextOut(m_hDC, x, y, lpszString, nCount, nTabPositions, lpnTabStopPositions, nTabOrigin);
		size.cx = LOWORD(lRes);
		size.cy = HIWORD(lRes);
		return size;
	}
#endif //!UNDER_CE
	int DrawText(LPCTSTR lpszString, int nCount, LPRECT lpRect, UINT nFormat)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawText(m_hDC, lpszString, nCount, lpRect, nFormat);
	}
	BOOL GetTextExtent(LPCTSTR lpszString, int nCount, LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		if(nCount == -1)
			nCount = lstrlen(lpszString);
		return ::GetTextExtentPoint32(m_hDC, lpszString, nCount, lpSize);
	}
#ifndef UNDER_CE
	BOOL GetTabbedTextExtent(LPCTSTR lpszString, int nCount,
		int nTabPositions, LPINT lpnTabStopPositions) const
	{
		ATLASSERT(m_hDC != NULL);
		if(nCount == -1)
			nCount = lstrlen(lpszString);
		return ::GetTabbedTextExtent(m_hDC, lpszString, nCount, nTabPositions, lpnTabStopPositions);
	}
	BOOL GrayString(HBRUSH hBrush,
		BOOL (CALLBACK* lpfnOutput)(HDC, LPARAM, int), LPARAM lpData,
			int nCount, int x, int y, int nWidth, int nHeight)
	{
		ATLASSERT(m_hDC != NULL);
		return ::GrayString(m_hDC, hBrush, (GRAYSTRINGPROC)lpfnOutput, lpData, nCount, x, y, nWidth, nHeight);
	}
	UINT GetTextAlign() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextAlign(m_hDC);
	}
	UINT SetTextAlign(UINT nFlags)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetTextAlign(m_hDC, nFlags);
	}
#endif //!UNDER_CE
	int GetTextFace(LPTSTR lpszFacename, int nCount) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextFace(m_hDC, nCount, lpszFacename);
	}
	int GetTextFaceLen() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextFace(m_hDC, 0, NULL);
	}
#ifndef _ATL_NO_COM
	BOOL GetTextFace(BSTR& bstrFace) const
	{
		USES_CONVERSION;
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(bstrFace == NULL);

		int nLen = GetTextFaceLen();
		if(nLen == 0)
			return FALSE;

		LPTSTR lpszText = (LPTSTR)_alloca(nLen * sizeof(TCHAR));

		if(!GetTextFace(lpszText, nLen))
			return FALSE;

		bstrFace = ::SysAllocString(T2OLE(lpszText));
		return (bstrFace != NULL) ? TRUE : FALSE;
	}
#endif //!_ATL_NO_COM
	BOOL GetTextMetrics(LPTEXTMETRIC lpMetrics) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextMetrics(m_hDC, lpMetrics);
	}
#ifndef UNDER_CE
	int SetTextJustification(int nBreakExtra, int nBreakCount)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetTextJustification(m_hDC, nBreakExtra, nBreakCount);
	}
	int GetTextCharacterExtra() const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetTextCharacterExtra(m_hDC);
	}
	int SetTextCharacterExtra(int nCharExtra)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetTextCharacterExtra(m_hDC, nCharExtra);
	}
#endif //!UNDER_CE

// Advanced Drawing
	BOOL DrawEdge(LPRECT lpRect, UINT nEdge, UINT nFlags)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawEdge(m_hDC, lpRect, nEdge, nFlags);
	}
	BOOL DrawFrameControl(LPRECT lpRect, UINT nType, UINT nState)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawFrameControl(m_hDC, lpRect, nType, nState);
	}

// Scrolling Functions
	BOOL ScrollDC(int dx, int dy, LPCRECT lpRectScroll, LPCRECT lpRectClip,
		HRGN hRgnUpdate, LPRECT lpRectUpdate)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ScrollDC(m_hDC, dx, dy, lpRectScroll, lpRectClip, hRgnUpdate, lpRectUpdate);
	}

// Font Functions
#ifndef UNDER_CE
	BOOL GetCharWidth(UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCharWidth(m_hDC, nFirstChar, nLastChar, lpBuffer);
	}
	DWORD SetMapperFlags(DWORD dwFlag)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetMapperFlags(m_hDC, dwFlag);
	}
	BOOL GetAspectRatioFilter(LPSIZE lpSize) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetAspectRatioFilterEx(m_hDC, lpSize);
	}

	BOOL GetCharABCWidths(UINT nFirstChar, UINT nLastChar, LPABC lpabc) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCharABCWidths(m_hDC, nFirstChar, nLastChar, lpabc);
	}
	DWORD GetFontData(DWORD dwTable, DWORD dwOffset, LPVOID lpData, DWORD cbData) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetFontData(m_hDC, dwTable, dwOffset, lpData, cbData);
	}
	int GetKerningPairs(int nPairs, LPKERNINGPAIR lpkrnpair) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetKerningPairs(m_hDC, nPairs, lpkrnpair);
	}
	UINT GetOutlineTextMetrics(UINT cbData, LPOUTLINETEXTMETRIC lpotm) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetOutlineTextMetrics(m_hDC, cbData, lpotm);
	}
	DWORD GetGlyphOutline(UINT nChar, UINT nFormat, LPGLYPHMETRICS lpgm,
		DWORD cbBuffer, LPVOID lpBuffer, const MAT2* lpmat2) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetGlyphOutline(m_hDC, nChar, nFormat, lpgm, cbBuffer, lpBuffer, lpmat2);
	}

	BOOL GetCharABCWidths(UINT nFirstChar, UINT nLastChar,
		LPABCFLOAT lpABCF) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCharABCWidthsFloat(m_hDC, nFirstChar, nLastChar, lpABCF);
	}
	BOOL GetCharWidth(UINT nFirstChar, UINT nLastChar,
		float* lpFloatBuffer) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetCharWidthFloat(m_hDC, nFirstChar, nLastChar, lpFloatBuffer);
	}
#endif //!UNDER_CE

// Printer/Device Escape Functions
#ifndef UNDER_CE
	int Escape(int nEscape, int nCount, LPCSTR lpszInData, LPVOID lpOutData)
	{
		ATLASSERT(m_hDC != NULL);
		return ::Escape(m_hDC, nEscape, nCount, lpszInData, lpOutData);
	}
	int Escape(int nEscape, int nInputSize, LPCSTR lpszInputData,
		int nOutputSize, LPSTR lpszOutputData)
	{
		ATLASSERT(m_hDC != NULL);
		return ::ExtEscape(m_hDC, nEscape, nInputSize, lpszInputData, nOutputSize, lpszOutputData);
	}
	int DrawEscape(int nEscape, int nInputSize, LPCSTR lpszInputData)
	{
		ATLASSERT(m_hDC != NULL);
		return ::DrawEscape(m_hDC, nEscape, nInputSize, lpszInputData);
	}
#endif //!UNDER_CE

	// Escape helpers
	int StartDoc(LPCTSTR lpszDocName)  // old Win3.0 version
	{
		DOCINFO di;
		memset(&di, 0, sizeof(DOCINFO));
		di.cbSize = sizeof(DOCINFO);
		di.lpszDocName = lpszDocName;
		return StartDoc(&di);
	}

	int StartDoc(LPDOCINFO lpDocInfo)
	{
		ATLASSERT(m_hDC != NULL);
		return ::StartDoc(m_hDC, lpDocInfo);
	}
	int StartPage()
	{
		ATLASSERT(m_hDC != NULL);
		return ::StartPage(m_hDC);
	}
	int EndPage()
	{
		ATLASSERT(m_hDC != NULL);
		return ::EndPage(m_hDC);
	}
	int SetAbortProc(BOOL (CALLBACK* lpfn)(HDC, int))
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetAbortProc(m_hDC, (ABORTPROC)lpfn);
	}
	int AbortDoc()
	{
		ATLASSERT(m_hDC != NULL);
		return ::AbortDoc(m_hDC);
	}
	int EndDoc()
	{
		ATLASSERT(m_hDC != NULL);
		return ::EndDoc(m_hDC);
	}

// MetaFile Functions
#ifndef UNDER_CE
	BOOL PlayMetaFile(HMETAFILE hMF)
	{
		ATLASSERT(m_hDC != NULL);
		if(::GetDeviceCaps(m_hDC, TECHNOLOGY) == DT_METAFILE)
		{
			// playing metafile in metafile, just use core windows API
			return ::PlayMetaFile(m_hDC, hMF);
		}

		// for special playback, lParam == pDC
		return ::EnumMetaFile(m_hDC, hMF, EnumMetaFileProc, (LPARAM)this);
	}
	BOOL PlayMetaFile(HENHMETAFILE hEnhMetaFile, LPCRECT lpBounds)
	{
		ATLASSERT(m_hDC != NULL);
		return ::PlayEnhMetaFile(m_hDC, hEnhMetaFile, lpBounds);
	}
	BOOL AddMetaFileComment(UINT nDataSize, const BYTE* pCommentData) // can be used for enhanced metafiles only
	{
		ATLASSERT(m_hDC != NULL);
		return ::GdiComment(m_hDC, nDataSize, pCommentData);
	}

	// Special handling for metafile playback
	static int CALLBACK EnumMetaFileProc(HDC hDC, HANDLETABLE* pHandleTable, METARECORD* pMetaRec, int nHandles, LPARAM lParam)
	{
		CDC* pDC = (CDC*)lParam;

		switch (pMetaRec->rdFunction)
		{
		case META_SETMAPMODE:
			pDC->SetMapMode((int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SETWINDOWEXT:
			pDC->SetWindowExt((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SETWINDOWORG:
			pDC->SetWindowOrg((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SETVIEWPORTEXT:
			pDC->SetViewportExt((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SETVIEWPORTORG:
			pDC->SetViewportOrg((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SCALEWINDOWEXT:
			pDC->ScaleWindowExt((int)(short)pMetaRec->rdParm[3], (int)(short)pMetaRec->rdParm[2], 
				(int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SCALEVIEWPORTEXT:
			pDC->ScaleViewportExt((int)(short)pMetaRec->rdParm[3], (int)(short)pMetaRec->rdParm[2],
				(int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_OFFSETVIEWPORTORG:
			pDC->OffsetViewportOrg((int)(short)pMetaRec->rdParm[1], (int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SAVEDC:
			pDC->SaveDC();
			break;
		case META_RESTOREDC:
			pDC->RestoreDC((int)(short)pMetaRec->rdParm[0]);
			break;
		case META_SETBKCOLOR:
			pDC->SetBkColor(*(UNALIGNED COLORREF*)&pMetaRec->rdParm[0]);
			break;
		case META_SETTEXTCOLOR:
			pDC->SetTextColor(*(UNALIGNED COLORREF*)&pMetaRec->rdParm[0]);
			break;

		// need to watch out for SelectObject(HFONT), for custom font mapping
		case META_SELECTOBJECT:
			{
				HGDIOBJ hObject = pHandleTable->objectHandle[pMetaRec->rdParm[0]];
				UINT nObjType = ::GetObjectType(hObject);
				if(nObjType == 0)
				{
					// object type is unknown, determine if it is a font
					HFONT hStockFont = (HFONT)::GetStockObject(SYSTEM_FONT);
/**/					HFONT hFontOld = (HFONT)::SelectObject(pDC->m_hDC, hStockFont);
/**/					HGDIOBJ hObjOld = ::SelectObject(pDC->m_hDC, hObject);
					if(hObjOld == hStockFont)
					{
						// got the stock object back, so must be selecting a font
						pDC->SelectFont((HFONT)hObject);
						break;  // don't play the default record
					}
					else
					{
						// didn't get the stock object back, so restore everything
/**/						::SelectObject(pDC->m_hDC, hFontOld);
/**/						::SelectObject(pDC->m_hDC, hObjOld);
					}
					// and fall through to PlayMetaFileRecord...
				}
				else if(nObjType == OBJ_FONT)
				{
					// play back as CDC::SelectFont(HFONT)
					pDC->SelectFont((HFONT)hObject);
					break;  // don't play the default record
				}
			}
			// fall through...

		default:
			::PlayMetaFileRecord(hDC, pHandleTable, pMetaRec, nHandles);
			break;
		}

		return 1;
	}
#endif //!UNDER_CE

// Path Functions
#ifndef UNDER_CE
	BOOL AbortPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::AbortPath(m_hDC);
	}
	BOOL BeginPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::BeginPath(m_hDC);
	}
	BOOL CloseFigure()
	{
		ATLASSERT(m_hDC != NULL);
		return ::CloseFigure(m_hDC);
	}
	BOOL EndPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::EndPath(m_hDC);
	}
	BOOL FillPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::FillPath(m_hDC);
	}
	BOOL FlattenPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::FlattenPath(m_hDC);
	}
	BOOL StrokeAndFillPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::StrokeAndFillPath(m_hDC);
	}
	BOOL StrokePath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::StrokePath(m_hDC);
	}
	BOOL WidenPath()
	{
		ATLASSERT(m_hDC != NULL);
		return ::WidenPath(m_hDC);
	}
	BOOL GetMiterLimit(PFLOAT pfMiterLimit) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetMiterLimit(m_hDC, pfMiterLimit);
	}
	BOOL SetMiterLimit(float fMiterLimit)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SetMiterLimit(m_hDC, fMiterLimit, NULL);
	}
	int GetPath(LPPOINT lpPoints, LPBYTE lpTypes, int nCount) const
	{
		ATLASSERT(m_hDC != NULL);
		return ::GetPath(m_hDC, lpPoints, lpTypes, nCount);
	}
	BOOL SelectClipPath(int nMode)
	{
		ATLASSERT(m_hDC != NULL);
		return ::SelectClipPath(m_hDC, nMode);
	}
#endif //!UNDER_CE

// Misc Helper Functions
	static HBRUSH PASCAL GetHalftoneBrush()
	{
		HBRUSH halftoneBrush;
		WORD grayPattern[8];
		for(int i = 0; i < 8; i++)
			grayPattern[i] = (WORD)(0x5555 << (i & 1));
		HBITMAP grayBitmap = CreateBitmap(8, 8, 1, 1, &grayPattern);
		if(grayBitmap != NULL)
		{
			halftoneBrush = ::CreatePatternBrush(grayBitmap);
			DeleteObject(grayBitmap);
		}
		return halftoneBrush;
	}
	void DrawDragRect(LPCRECT lpRect, SIZE size, LPCRECT lpRectLast, SIZE sizeLast, HBRUSH hBrush = NULL, HBRUSH hBrushLast = NULL)
	{
		// first, determine the update region and select it
		HRGN hRgnNew;
		HRGN hRgnOutside, hRgnInside;
		hRgnOutside = ::CreateRectRgnIndirect(lpRect);
		RECT rect = *lpRect;
		::InflateRect(&rect, -size.cx, -size.cy);
		::IntersectRect(&rect, &rect, lpRect);
		hRgnInside = ::CreateRectRgnIndirect(&rect);
		hRgnNew = ::CreateRectRgn(0, 0, 0, 0);
		::CombineRgn(hRgnNew, hRgnOutside, hRgnInside, RGN_XOR);

		HBRUSH hBrushOld = NULL;
		if(hBrush == NULL)
			hBrush = CDC::GetHalftoneBrush();
		if(hBrushLast == NULL)
			hBrushLast = hBrush;

		HRGN hRgnLast, hRgnUpdate;
		if(lpRectLast != NULL)
		{
			// find difference between new region and old region
			hRgnLast = ::CreateRectRgn(0, 0, 0, 0);
			::SetRectRgn(hRgnOutside, lpRectLast->left, lpRectLast->top, lpRectLast->right, lpRectLast->bottom);
			rect = *lpRectLast;
			::InflateRect(&rect, -sizeLast.cx, -sizeLast.cy);
			::IntersectRect(&rect, &rect, lpRectLast);
			::SetRectRgn(hRgnInside, rect.left, rect.top, rect.right, rect.bottom);
			::CombineRgn(hRgnLast, hRgnOutside, hRgnInside, RGN_XOR);

			// only diff them if brushes are the same
			if(hBrush == hBrushLast)
			{
				hRgnUpdate = ::CreateRectRgn(0, 0, 0, 0);
				::CombineRgn(hRgnUpdate, hRgnLast, hRgnNew, RGN_XOR);
			}
		}
		if(hBrush != hBrushLast && lpRectLast != NULL)
		{
			// brushes are different -- erase old region first
			SelectClipRgn(hRgnLast);
			GetClipBox(&rect);
			hBrushOld = SelectBrush(hBrushLast);
			PatBlt(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, PATINVERT);
			SelectBrush(hBrushOld);
			hBrushOld = NULL;
		}

		// draw into the update/new region
		SelectClipRgn(hRgnUpdate != NULL ? hRgnUpdate : hRgnNew);
		GetClipBox(&rect);
		hBrushOld = SelectBrush(hBrush);
		PatBlt(rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, PATINVERT);

		// cleanup DC
		if(hBrushOld != NULL)
			SelectBrush(hBrushOld);
		SelectClipRgn(NULL);
	}
	void FillSolidRect(LPCRECT lpRect, COLORREF clr)
	{
		ATLASSERT(m_hDC != NULL);

		::SetBkColor(m_hDC, clr);
		::ExtTextOut(m_hDC, 0, 0, ETO_OPAQUE, lpRect, NULL, 0, NULL);
	}
	void FillSolidRect(int x, int y, int cx, int cy, COLORREF clr)
	{
		ATLASSERT(m_hDC != NULL);

		::SetBkColor(m_hDC, clr);
		RECT rect = { x, y, x + cx, y + cy };
		::ExtTextOut(m_hDC, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);
	}
	void Draw3dRect(LPCRECT lpRect, COLORREF clrTopLeft, COLORREF clrBottomRight)
	{
		Draw3dRect(lpRect->left, lpRect->top, lpRect->right - lpRect->left,
			lpRect->bottom - lpRect->top, clrTopLeft, clrBottomRight);
	}
	void Draw3dRect(int x, int y, int cx, int cy, COLORREF clrTopLeft, COLORREF clrBottomRight)
	{
		FillSolidRect(x, y, cx - 1, 1, clrTopLeft);
		FillSolidRect(x, y, 1, cy - 1, clrTopLeft);
		FillSolidRect(x + cx, y, -1, cy, clrBottomRight);
		FillSolidRect(x, y + cy, cx, -1, clrBottomRight);
	}
};

/////////////////////////////////////////////////////////////////////////////
// CDC Helpers

class CPaintDC : public CDC
{
public:
	HWND m_hWnd;
	PAINTSTRUCT m_ps;

	CPaintDC(HWND hWnd, BOOL bAutoRestore = TRUE) : CDC(NULL, bAutoRestore)
	{
		ATLASSERT(::IsWindow(hWnd));
		m_hWnd = hWnd;
		m_hDC = ::BeginPaint(hWnd, &m_ps);
	}
	~CPaintDC()
	{
		ATLASSERT(m_hDC != NULL);
		ATLASSERT(::IsWindow(m_hWnd));

		if(m_bAutoRestore)
			RestoreAllObjects();

		::EndPaint(m_hWnd, &m_ps);
		Detach();
	}
};

class CClientDC : public CDC
{
public:
	HWND m_hWnd;

	CClientDC(HWND hWnd, BOOL bAutoRestore = TRUE) : CDC(NULL, bAutoRestore)
	{
		ATLASSERT(hWnd == NULL || ::IsWindow(hWnd));
		m_hWnd = hWnd;
		m_hDC = ::GetDC(hWnd);
	}
	~CClientDC()
	{
		ATLASSERT(m_hDC != NULL);

		if(m_bAutoRestore)
			RestoreAllObjects();

		::ReleaseDC(m_hWnd, Detach());
	}
};

class CWindowDC : public CDC
{
public:
	HWND m_hWnd;

	CWindowDC(HWND hWnd, BOOL bAutoRestore = TRUE) : CDC(NULL, bAutoRestore)
	{
		ATLASSERT(hWnd == NULL || ::IsWindow(hWnd));
		m_hWnd = hWnd;
		m_hDC = ::GetWindowDC(hWnd);
	}
	~CWindowDC()
	{
		ATLASSERT(m_hDC != NULL);

		if(m_bAutoRestore)
			RestoreAllObjects();

		::ReleaseDC(m_hWnd, Detach());
	}
};

/////////////////////////////////////////////////////////////////////////////
// CMenu

class CMenu
{
public:
	HMENU m_hMenu;

	CMenu(HMENU hMenu = NULL) : m_hMenu(hMenu) { }

	~CMenu()
	{
		if(m_hMenu != NULL)
			DestroyMenu();
	}

	CMenu& operator=(HMENU hMenu)
	{
		m_hMenu = hMenu;
		return *this;
	}

	void Attach(HMENU hMenuNew)
	{
		ATLASSERT(::IsMenu(hMenuNew));
		m_hMenu = hMenuNew;
	}

	HMENU Detach()
	{
		HMENU hMenu = m_hMenu;
		m_hMenu = NULL;
		return hMenu;
	}

	operator HMENU() const { return m_hMenu; }

	BOOL CreateMenu()
	{
		ATLASSERT(m_hMenu == NULL);
		m_hMenu = ::CreateMenu();
		return (m_hMenu != NULL) ? TRUE : FALSE;
	}
	BOOL CreatePopupMenu()
	{
		ATLASSERT(m_hMenu == NULL);
		m_hMenu = ::CreatePopupMenu();
		return (m_hMenu != NULL) ? TRUE : FALSE;
	}
	BOOL LoadMenu(LPCTSTR lpszResourceName)
	{
		ATLASSERT(m_hMenu == NULL);
		m_hMenu = ::LoadMenu(_Module.GetResourceInstance(), lpszResourceName);
		return (m_hMenu != NULL) ? TRUE : FALSE;
	}
	BOOL LoadMenu(UINT nIDResource)
	{
		ATLASSERT(m_hMenu == NULL);
		m_hMenu = ::LoadMenu(_Module.GetResourceInstance(), MAKEINTRESOURCE(nIDResource));
		return (m_hMenu != NULL) ? TRUE : FALSE;
	}
#ifndef UNDER_CE
	BOOL LoadMenuIndirect(const void* lpMenuTemplate)
	{
		ATLASSERT(m_hMenu == NULL);
		m_hMenu = ::LoadMenuIndirect(lpMenuTemplate);
		return (m_hMenu != NULL) ? TRUE : FALSE;
	}
#endif //!UNDER_CE
	BOOL DestroyMenu()
	{
		if (m_hMenu == NULL)
			return FALSE;
		return ::DestroyMenu(Detach());
	}

// Menu Operations
	BOOL DeleteMenu(UINT nPosition, UINT nFlags)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::DeleteMenu(m_hMenu, nPosition, nFlags);
	}
	BOOL TrackPopupMenu(UINT nFlags, int x, int y, HWND hWnd, LPCRECT lpRect = NULL)
	{
		ATLASSERT(::IsMenu(m_hMenu));
#ifndef UNDER_CE
		return ::TrackPopupMenu(m_hMenu, nFlags, x, y, 0, hWnd, lpRect);
#else // CE specific
		return ::TrackPopupMenuEx(m_hMenu, nFlags, x, y, hWnd, NULL);
#endif //!UNDER_CE
	}
	BOOL TrackPopupMenuEx(UINT uFlags, int x, int y, HWND hWnd, LPTPMPARAMS lptpm = NULL)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::TrackPopupMenuEx(m_hMenu, uFlags, x, y, hWnd, lptpm);
	}

// Menu Item Operations
	BOOL AppendMenu(UINT nFlags, UINT nIDNewItem = 0, LPCTSTR lpszNewItem = NULL)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::AppendMenu(m_hMenu, nFlags, nIDNewItem, lpszNewItem);
	}
#ifndef UNDER_CE
//REVIEW
	BOOL AppendMenu(UINT nFlags, UINT nIDNewItem, HBITMAP hBmp)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::AppendMenu(m_hMenu, nFlags | MF_BITMAP, nIDNewItem, (LPCTSTR)hBmp);
	}
#endif //!UNDER_CE
	UINT CheckMenuItem(UINT nIDCheckItem, UINT nCheck)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return (UINT)::CheckMenuItem(m_hMenu, nIDCheckItem, nCheck);
	}
	UINT EnableMenuItem(UINT nIDEnableItem, UINT nEnable)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::EnableMenuItem(m_hMenu, nIDEnableItem, nEnable);
	}
#ifndef UNDER_CE
	UINT GetMenuItemCount() const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuItemCount(m_hMenu);
	}
	UINT GetMenuItemID(int nPos) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuItemID(m_hMenu, nPos);
	}
	UINT GetMenuState(UINT nID, UINT nFlags) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuState(m_hMenu, nID, nFlags);
	}
	int GetMenuString(UINT nIDItem, LPTSTR lpString, int nMaxCount, UINT nFlags) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuString(m_hMenu, nIDItem, lpString, nMaxCount, nFlags);
	}
	int GetMenuStringLen(UINT nIDItem, UINT nFlags) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuString(m_hMenu, nIDItem, NULL, 0, nFlags);
	}
#ifndef _ATL_NO_COM
	BOOL GetMenuString(UINT nIDItem, BSTR& bstrText, UINT nFlags) const
	{
		USES_CONVERSION;
		ATLASSERT(::IsMenu(m_hMenu));
		ATLASSERT(bstrText == NULL);

		int nLen = GetMenuStringLen(nIDItem, nFlags);
		{
			bstrText = ::SysAllocString(OLESTR(""));
			return (bstrText != NULL) ? TRUE : FALSE;
		}

		LPTSTR lpszText = (LPTSTR)_alloca((nLen + 1) * sizeof(TCHAR));

		if(!GetMenuString(nIDItem, lpszText, nLen, nFlags))
			return FALSE;

		bstrText = ::SysAllocString(T2OLE(lpszText));
		return (bstrText != NULL) ? TRUE : FALSE;
	}
#endif //!_ATL_NO_COM
#endif //!UNDER_CE
	HMENU GetSubMenu(int nPos) const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetSubMenu(m_hMenu, nPos);
	}
#ifndef UNDER_CE
//REVIEW
	BOOL InsertMenu(UINT nPosition, UINT nFlags, UINT nIDNewItem = 0, LPCTSTR lpszNewItem = NULL)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::InsertMenu(m_hMenu, nPosition, nFlags, nIDNewItem, lpszNewItem);
	}
	BOOL InsertMenu(UINT nPosition, UINT nFlags, UINT nIDNewItem, HBITMAP hBmp)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::InsertMenu(m_hMenu, nPosition, nFlags | MF_BITMAP, nIDNewItem, (LPCTSTR)hBmp);
	}
#endif //!UNDER_CE
#ifndef UNDER_CE
	BOOL ModifyMenu(UINT nPosition, UINT nFlags, UINT nIDNewItem = 0, LPCTSTR lpszNewItem = NULL)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::ModifyMenu(m_hMenu, nPosition, nFlags, nIDNewItem, lpszNewItem);
	}
	BOOL ModifyMenu(UINT nPosition, UINT nFlags, UINT nIDNewItem, HBITMAP hBmp)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::ModifyMenu(m_hMenu, nPosition, nFlags | MF_BITMAP, nIDNewItem, (LPCTSTR)hBmp);
	}
#endif //!UNDER_CE
	BOOL RemoveMenu(UINT nPosition, UINT nFlags)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::RemoveMenu(m_hMenu, nPosition, nFlags);
	}
#ifndef UNDER_CE
	BOOL SetMenuItemBitmaps(UINT nPosition, UINT nFlags, HBITMAP hBmpUnchecked, HBITMAP hBmpChecked)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::SetMenuItemBitmaps(m_hMenu, nPosition, nFlags, hBmpUnchecked, hBmpChecked);
	}
#endif //!UNDER_CE
	BOOL CheckMenuRadioItem(UINT nIDFirst, UINT nIDLast, UINT nIDItem, UINT nFlags)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::CheckMenuRadioItem(m_hMenu, nIDFirst, nIDLast, nIDItem, nFlags);
	}

	BOOL GetMenuItemInfo(UINT uItem, BOOL bByPosition, LPMENUITEMINFO lpmii)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return (BOOL)::GetMenuItemInfo(m_hMenu, uItem, bByPosition, lpmii);
	}
	BOOL SetMenuItemInfo(UINT uItem, BOOL bByPosition, LPMENUITEMINFO lpmii)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return (BOOL)::SetMenuItemInfo(m_hMenu, uItem, bByPosition, lpmii);
	}
 
// Context Help Functions
#ifndef UNDER_CE
	BOOL SetMenuContextHelpId(DWORD dwContextHelpId)
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::SetMenuContextHelpId(m_hMenu, dwContextHelpId);
	}
	DWORD GetMenuContextHelpId() const
	{
		ATLASSERT(::IsMenu(m_hMenu));
		return ::GetMenuContextHelpId(m_hMenu);
	}
#endif //!UNDER_CE
};

/////////////////////////////////////////////////////////////////////////////
// CPen

class CPen
{
public:
	HPEN m_hPen;

	CPen(HPEN hPen = NULL) : m_hPen(hPen)
	{ }
	~CPen()
	{
		if(m_hPen != NULL)
			DeleteObject();
	}

	CPen& operator=(HPEN hPen)
	{
		m_hPen = hPen;
		return *this;
	}

	void Attach(HPEN hPen)
	{
		m_hPen = hPen;
	}
	HPEN Detach()
	{
		HPEN hPen = m_hPen;
		m_hPen = NULL;
		return hPen;
	}

	operator HPEN() const { return m_hPen; }

	HPEN CreatePen(int nPenStyle, int nWidth, COLORREF crColor)
	{
		ATLASSERT(m_hPen == NULL);
		m_hPen = ::CreatePen(nPenStyle, nWidth, crColor);
		return m_hPen;
	}
#ifndef UNDER_CE
	HPEN CreatePen(int nPenStyle, int nWidth, const LOGBRUSH* pLogBrush, int nStyleCount = 0, const DWORD* lpStyle = NULL)
	{
		ATLASSERT(m_hPen == NULL);
		m_hPen = ::ExtCreatePen(nPenStyle, nWidth, pLogBrush, nStyleCount, lpStyle);
		return m_hPen;
	}
#endif //!UNDER_CE
	HPEN CreatePenIndirect(LPLOGPEN lpLogPen)
	{
		ATLASSERT(m_hPen == NULL);
		m_hPen = ::CreatePenIndirect(lpLogPen);
		return m_hPen;
	}

	BOOL DeleteObject()
	{
		ATLASSERT(m_hPen != NULL);
		BOOL bRet = ::DeleteObject(m_hPen);
		if(bRet)
			m_hPen = NULL;
		return bRet;
	}

// Attributes
	int GetLogPen(LOGPEN* pLogPen)
	{
		ATLASSERT(m_hPen != NULL);
		return ::GetObject(m_hPen, sizeof(LOGPEN), pLogPen);
	}
#ifndef UNDER_CE
	int GetExtLogPen(EXTLOGPEN* pLogPen)
	{
		ATLASSERT(m_hPen != NULL);
		return ::GetObject(m_hPen, sizeof(EXTLOGPEN), pLogPen);
	}
#endif //!UNDER_CE
};

/////////////////////////////////////////////////////////////////////////////
// CBrush

class CBrush
{
public:
	HBRUSH m_hBrush;

	CBrush(HBRUSH hBrush = NULL) : m_hBrush(hBrush)
	{ }
	~CBrush()
	{
		if(m_hBrush != NULL)
			DeleteObject();
	}

	CBrush& operator=(HBRUSH hBrush)
	{
		m_hBrush = hBrush;
		return *this;
	}

	void Attach(HBRUSH hBrush)
	{
		m_hBrush = hBrush;
	}
	HBRUSH Detach()
	{
		HBRUSH hBrush = m_hBrush;
		m_hBrush = NULL;
		return hBrush;
	}

	operator HBRUSH() const { return m_hBrush; }

	HBRUSH CreateSolidBrush(COLORREF crColor)
	{
		ATLASSERT(m_hBrush == NULL);
		m_hBrush = ::CreateSolidBrush(crColor);
		return m_hBrush;
	}
#ifndef UNDER_CE
	HBRUSH CreateHatchBrush(int nIndex, COLORREF crColor)
	{
		ATLASSERT(m_hBrush == NULL);
		m_hBrush = ::CreateHatchBrush(nIndex, crColor);
		return m_hBrush;
	}
	HBRUSH CreateBrushIndirect(const LOGBRUSH* lpLogBrush)
	{
		ATLASSERT(m_hBrush == NULL);
		m_hBrush = ::CreateBrushIndirect(lpLogBrush);
		return m_hBrush;
	}
#endif //!UNDER_CE
	HBRUSH CreatePatternBrush(HBITMAP hBitmap)
	{
		ATLASSERT(m_hBrush == NULL);
		m_hBrush = ::CreatePatternBrush(hBitmap);
		return m_hBrush;
	}
#ifndef UNDER_CE
//REVIEW
	HBRUSH CreateDIBPatternBrush(HGLOBAL hPackedDIB, UINT nUsage)
	{
		ATLASSERT(hPackedDIB != NULL);
		const void* lpPackedDIB = ::GlobalLock(hPackedDIB);
		ATLASSERT(lpPackedDIB != NULL);
		m_hBrush = ::CreateDIBPatternBrushPt(lpPackedDIB, nUsage);
		::GlobalUnlock(hPackedDIB);
		return m_hBrush;
	}
#endif //!UNDER_CE
	HBRUSH CreateDIBPatternBrush(const void* lpPackedDIB, UINT nUsage)
	{
		ATLASSERT(m_hBrush == NULL);
		m_hBrush = ::CreateDIBPatternBrushPt(lpPackedDIB, nUsage);
		return m_hBrush;
	}
	HBRUSH CreateSysColorBrush(int nIndex)
	{
		ATLASSERT(m_hBrush == NULL);
		m_hBrush = ::GetSysColorBrush(nIndex);
		return m_hBrush;
	}

	BOOL DeleteObject()
	{
		ATLASSERT(m_hBrush != NULL);
		BOOL bRet = ::DeleteObject(m_hBrush);
		if(bRet)
			m_hBrush = NULL;
		return bRet;
	}

// Attributes
	int GetLogBrush(LOGBRUSH* pLogBrush)
	{
		ATLASSERT(m_hBrush != NULL);
		return ::GetObject(m_hBrush, sizeof(LOGBRUSH), pLogBrush);
	}
};

/////////////////////////////////////////////////////////////////////////////
// CFont

class CFont
{
public:
	HFONT m_hFont;

	CFont(HFONT hFont = NULL) : m_hFont(hFont)
	{ }
	~CFont()
	{
		if(m_hFont != NULL)
			DeleteObject();
	}

	CFont& operator=(HFONT hFont)
	{
		m_hFont = hFont;
		return *this;
	}

	void Attach(HFONT hFont)
	{
		m_hFont = hFont;
	}
	HFONT Detach()
	{
		HFONT hFont = m_hFont;
		m_hFont = NULL;
		return hFont;
	}

	operator HFONT() const { return m_hFont; }

	HFONT CreateFontIndirect(const LOGFONT* lpLogFont)
	{
		ATLASSERT(m_hFont == NULL);
		m_hFont = ::CreateFontIndirect(lpLogFont);
		return m_hFont;
	}
	HFONT CreateFont(int nHeight, int nWidth, int nEscapement,
			int nOrientation, int nWeight, BYTE bItalic, BYTE bUnderline,
			BYTE cStrikeOut, BYTE nCharSet, BYTE nOutPrecision,
			BYTE nClipPrecision, BYTE nQuality, BYTE nPitchAndFamily,
			LPCTSTR lpszFacename)
	{
		ATLASSERT(m_hFont == NULL);
#ifndef UNDER_CE
		m_hFont = ::CreateFont(nHeight, nWidth, nEscapement,
#else // CE specific
		m_hFont = CreateFont(nHeight, nWidth, nEscapement,
#endif //!UNDER_CE
			nOrientation, nWeight, bItalic, bUnderline, cStrikeOut,
			nCharSet, nOutPrecision, nClipPrecision, nQuality,
			nPitchAndFamily, lpszFacename);
		return m_hFont;
	}
#ifndef UNDER_CE
	HFONT CreatePointFont(int nPointSize, LPCTSTR lpszFaceName, HDC hDC = NULL)
	{
		LOGFONT logFont;
		memset(&logFont, 0, sizeof(LOGFONT));
		logFont.lfCharSet = DEFAULT_CHARSET;
		logFont.lfHeight = nPointSize;
		lstrcpyn(logFont.lfFaceName, lpszFaceName, sizeof(logFont.lfFaceName)/sizeof(TCHAR));
		return CreatePointFontIndirect(&logFont, hDC);
	}
	HFONT CreatePointFontIndirect(const LOGFONT* lpLogFont, HDC hDC = NULL)
	{
		HDC hDC1 = (hDC != NULL) ? hDC : (::GetDC(NULL));

		// convert nPointSize to logical units based on hDC
		LOGFONT logFont = *lpLogFont;
		POINT pt;
		pt.y = ::GetDeviceCaps(hDC1, LOGPIXELSY) * logFont.lfHeight;
		pt.y /= 720;    // 72 points/inch, 10 decipoints/point
		::DPtoLP(hDC1, &pt, 1);
		POINT ptOrg = { 0, 0 };
		::DPtoLP(hDC1, &ptOrg, 1);
		logFont.lfHeight = -abs(pt.y - ptOrg.y);

		if(hDC == NULL)
			::ReleaseDC(NULL, hDC1);

		return CreateFontIndirect(&logFont);
	}
#endif //!UNDER_CE

	BOOL DeleteObject()
	{
		ATLASSERT(m_hFont != NULL);
		BOOL bRet = ::DeleteObject(m_hFont);
		if(bRet)
			m_hFont = NULL;
		return bRet;
	}

// Attributes
	int GetLogFont(LOGFONT* pLogFont)
	{
		ATLASSERT(m_hFont != NULL);
		return ::GetObject(m_hFont, sizeof(LOGFONT), pLogFont);
	}
};

/////////////////////////////////////////////////////////////////////////////
// CBitmap

class CBitmap
{
public:
	HBITMAP m_hBitmap;

	CBitmap(HBITMAP hBitmap = NULL) : m_hBitmap(hBitmap)
	{ }
	~CBitmap()
	{
		if(m_hBitmap != NULL)
			DeleteObject();
	}

	CBitmap& operator=(HBITMAP hBitmap)
	{
		m_hBitmap = hBitmap;
		return *this;
	}

	void Attach(HBITMAP hBitmap)
	{
		m_hBitmap = hBitmap;
	}
	HBITMAP Detach()
	{
		HBITMAP hBitmap = m_hBitmap;
		m_hBitmap = NULL;
		return hBitmap;
	}

	operator HBITMAP() const { return m_hBitmap; }

	HBITMAP LoadBitmap(LPCTSTR lpszResourceName)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::LoadBitmap(_Module.GetResourceInstance(), lpszResourceName);
		return m_hBitmap;
	}
	HBITMAP LoadBitmap(UINT nIDResource)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::LoadBitmap(_Module.GetResourceInstance(), MAKEINTRESOURCE(nIDResource));
		return m_hBitmap;
	}
	HBITMAP LoadOEMBitmap(UINT nIDBitmap) // for OBM_/OCR_/OIC_
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::LoadBitmap(NULL, MAKEINTRESOURCE(nIDBitmap));
		return m_hBitmap;
	}
	HBITMAP LoadMappedBitmap(UINT nIDBitmap, UINT nFlags = 0, LPCOLORMAP lpColorMap = NULL, int nMapSize = 0)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateMappedBitmap(_Module.GetResourceInstance(), nIDBitmap, (WORD)nFlags, lpColorMap, nMapSize);
		return m_hBitmap;
	}
	HBITMAP CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitcount, const void* lpBits)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateBitmap(nWidth, nHeight, nPlanes, nBitcount, lpBits);
		return m_hBitmap;
	}
#ifndef UNDER_CE
	HBITMAP CreateBitmapIndirect(LPBITMAP lpBitmap)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateBitmapIndirect(lpBitmap);
		return m_hBitmap;
	}
#endif //!UNDER_CE
	HBITMAP CreateCompatibleBitmap(HDC hDC, int nWidth, int nHeight)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateCompatibleBitmap(hDC, nWidth, nHeight);
		return m_hBitmap;
	}
#ifndef UNDER_CE
	HBITMAP CreateDiscardableBitmap(HDC hDC, int nWidth, int nHeight)
	{
		ATLASSERT(m_hBitmap == NULL);
		m_hBitmap = ::CreateDiscardableBitmap(hDC, nWidth, nHeight);
		return m_hBitmap;
	}
#endif //!UNDER_CE

	BOOL DeleteObject()
	{
		ATLASSERT(m_hBitmap != NULL);
		BOOL bRet = ::DeleteObject(m_hBitmap);
		if(bRet)
			m_hBitmap = NULL;
		return bRet;
	}

// Attributes
	int GetBitmap(BITMAP* pBitMap)
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::GetObject(m_hBitmap, sizeof(BITMAP), pBitMap);
	}

// Operations
#ifndef UNDER_CE
//REVIEW
	DWORD SetBitmapBits(DWORD dwCount, const void* lpBits)
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::SetBitmapBits(m_hBitmap, dwCount, lpBits);
	}
	DWORD GetBitmapBits(DWORD dwCount, LPVOID lpBits) const
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::GetBitmapBits(m_hBitmap, dwCount, lpBits);
	}
	BOOL SetBitmapDimension(int nWidth, int nHeight, LPSIZE lpSize = NULL)
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::SetBitmapDimensionEx(m_hBitmap, nWidth, nHeight, lpSize);
	}
	BOOL GetBitmapDimension(LPSIZE lpSize) const
	{
		ATLASSERT(m_hBitmap != NULL);
		return ::GetBitmapDimensionEx(m_hBitmap, lpSize);
	}
#endif //!UNDER_CE
};

/////////////////////////////////////////////////////////////////////////////
// CPalette

class CPalette
{
public:
	HPALETTE m_hPalette;

	CPalette(HPALETTE hPalette = NULL) : m_hPalette(hPalette)
	{ }
	~CPalette()
	{
		if(m_hPalette != NULL)
			DeleteObject();
	}

	CPalette& operator=(HPALETTE hPalette)
	{
		m_hPalette = hPalette;
		return *this;
	}

	void Attach(HPALETTE hPalette)
	{
		m_hPalette = hPalette;
	}
	HPALETTE Detach()
	{
		HPALETTE hPalette = m_hPalette;
		m_hPalette = NULL;
		return hPalette;
	}

	operator HPALETTE() const { return m_hPalette; }

	HPALETTE CreatePalette(LPLOGPALETTE lpLogPalette)
	{
		ATLASSERT(m_hPalette == NULL);
		m_hPalette = ::CreatePalette(lpLogPalette);
		return m_hPalette;
	}
#ifndef UNDER_CE
	HPALETTE CreateHalftonePalette(HDC hDC)
	{
		ATLASSERT(m_hPalette == NULL);
		ATLASSERT(hDC != NULL);
		m_hPalette = ::CreateHalftonePalette(hDC);
		return m_hPalette;
	}
#endif //!UNDER_CE

	BOOL DeleteObject()
	{
		ATLASSERT(m_hPalette != NULL);
		BOOL bRet = ::DeleteObject(m_hPalette);
		if(bRet)
			m_hPalette = NULL;
		return bRet;
	}

// Attributes
	int GetEntryCount()
	{
		ATLASSERT(m_hPalette != NULL);
		WORD nEntries;
		::GetObject(m_hPalette, sizeof(WORD), &nEntries);
		return (int)nEntries;
	}
	UINT GetPaletteEntries(UINT nStartIndex, UINT nNumEntries, LPPALETTEENTRY lpPaletteColors) const
	{
		ATLASSERT(m_hPalette != NULL);
		return ::GetPaletteEntries(m_hPalette, nStartIndex, nNumEntries, lpPaletteColors);
	}
	UINT SetPaletteEntries(UINT nStartIndex, UINT nNumEntries, LPPALETTEENTRY lpPaletteColors)
	{
		ATLASSERT(m_hPalette != NULL);
		return ::SetPaletteEntries(m_hPalette, nStartIndex, nNumEntries, lpPaletteColors);
	}

// Operations
#ifndef UNDER_CE
	void AnimatePalette(UINT nStartIndex, UINT nNumEntries, LPPALETTEENTRY lpPaletteColors)
	{
		ATLASSERT(m_hPalette != NULL);
		::AnimatePalette(m_hPalette, nStartIndex, nNumEntries, lpPaletteColors);
	}
	BOOL ResizePalette(UINT nNumEntries)
	{
		ATLASSERT(m_hPalette != NULL);
		return ::ResizePalette(m_hPalette, nNumEntries);
	}
#endif //!UNDER_CE
	UINT GetNearestPaletteIndex(COLORREF crColor) const
	{
		ATLASSERT(m_hPalette != NULL);
		return ::GetNearestPaletteIndex(m_hPalette, crColor);
	}
};

/////////////////////////////////////////////////////////////////////////////
// CRgn

class CRgn
{
public:
	HRGN m_hRgn;
	CRgn(HRGN hRgn = NULL) : m_hRgn(hRgn)
	{ }
	~CRgn()
	{
		if(m_hRgn != NULL)
			DeleteObject();
	}

	CRgn& operator=(HRGN hRgn)
	{
		m_hRgn = hRgn;
		return *this;
	}

	void Attach(HRGN hRgn)
	{
		m_hRgn = hRgn;
	}
	HRGN Detach()
	{
		HRGN hRgn = m_hRgn;
		m_hRgn = NULL;
		return hRgn;
	}

	operator HRGN() const { return m_hRgn; }

	HRGN CreateRectRgn(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreateRectRgn(x1, y1, x2, y2);
		return m_hRgn;
	}
	HRGN CreateRectRgnIndirect(LPCRECT lpRect)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreateRectRgnIndirect(lpRect);
		return m_hRgn;
	}
#ifndef UNDER_CE
	HRGN CreateEllipticRgn(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreateEllipticRgn(x1, y1, x2, y2);
		return m_hRgn;
	}
	HRGN CreateEllipticRgnIndirect(LPCRECT lpRect)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreateEllipticRgnIndirect(lpRect);
		return m_hRgn;
	}
	HRGN CreatePolygonRgn(LPPOINT lpPoints, int nCount, int nMode)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreatePolygonRgn(lpPoints, nCount, nMode);
		return m_hRgn;
	}
	HRGN CreatePolyPolygonRgn(LPPOINT lpPoints, LPINT lpPolyCounts, int nCount, int nPolyFillMode)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreatePolyPolygonRgn(lpPoints, lpPolyCounts, nCount, nPolyFillMode);
		return m_hRgn;
	}
	HRGN CreateRoundRectRgn(int x1, int y1, int x2, int y2, int x3, int y3)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::CreateRoundRectRgn(x1, y1, x2, y2, x3, y3);
		return m_hRgn;
	}
	HRGN CreateFromPath(HDC hDC)
	{
		ATLASSERT(m_hRgn == NULL);
		ATLASSERT(hDC != NULL);
		m_hRgn = ::PathToRegion(hDC);
		return m_hRgn;
	}
	HRGN CreateFromData(const XFORM* lpXForm, int nCount, const RGNDATA* pRgnData)
	{
		ATLASSERT(m_hRgn == NULL);
		m_hRgn = ::ExtCreateRegion(lpXForm, nCount, pRgnData);
		return m_hRgn;
	}
#endif //!UNDER_CE

	BOOL DeleteObject()
	{
		ATLASSERT(m_hRgn != NULL);
		BOOL bRet = ::DeleteObject(m_hRgn);
		if(bRet)
			m_hRgn = NULL;
		return bRet;
	}

// Operations
	void SetRectRgn(int x1, int y1, int x2, int y2)
	{
		ATLASSERT(m_hRgn != NULL);
		::SetRectRgn(m_hRgn, x1, y1, x2, y2);
	}
	void SetRectRgn(LPCRECT lpRect)
	{
		ATLASSERT(m_hRgn != NULL);
		::SetRectRgn(m_hRgn, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom);
	}
	int CombineRgn(HRGN hRgnSrc1, HRGN hRgnSrc2, int nCombineMode)
	{
		ATLASSERT(m_hRgn != NULL);
		return ::CombineRgn(m_hRgn, hRgnSrc1, hRgnSrc2, nCombineMode);
	}
	int CombineRgn(HRGN hRgnSrc, int nCombineMode)
	{
		ATLASSERT(m_hRgn != NULL);
		return ::CombineRgn(m_hRgn, m_hRgn, hRgnSrc, nCombineMode);
	}
	int CopyRgn(HRGN hRgnSrc)
	{
		ATLASSERT(m_hRgn != NULL);
		return ::CombineRgn(m_hRgn, hRgnSrc, NULL, RGN_COPY);
	}
	BOOL EqualRgn(HRGN hRgn) const
	{
		ATLASSERT(m_hRgn != NULL);
		return ::EqualRgn(m_hRgn, hRgn);
	}
	int OffsetRgn(int x, int y)
	{
		ATLASSERT(m_hRgn != NULL);
		return ::OffsetRgn(m_hRgn, x, y);
	}
	int OffsetRgn(POINT point)
	{
		ATLASSERT(m_hRgn != NULL);
		return ::OffsetRgn(m_hRgn, point.x, point.y);
	}
	int GetRgnBox(LPRECT lpRect) const
	{
		ATLASSERT(m_hRgn != NULL);
		return ::GetRgnBox(m_hRgn, lpRect);
	}
	BOOL PtInRegion(int x, int y) const
	{
		ATLASSERT(m_hRgn != NULL);
		return ::PtInRegion(m_hRgn, x, y);
	}
	BOOL PtInRegion(POINT point) const
	{
		ATLASSERT(m_hRgn != NULL);
		return ::PtInRegion(m_hRgn, point.x, point.y);
	}
	BOOL RectInRegion(LPCRECT lpRect) const
	{
		ATLASSERT(m_hRgn != NULL);
		return ::RectInRegion(m_hRgn, lpRect);
	}
	int GetRegionData(LPRGNDATA lpRgnData, int nDataSize) const
	{
		ATLASSERT(m_hRgn != NULL);
		return (int)::GetRegionData(m_hRgn, nDataSize, lpRgnData);
	}
};

}; //namespace ATL

#endif // __ATLGDI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\ana2enc.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing analog capture to ovmixer
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef ANA2ENC_H
#define ANA2ENC_H

#pragma once

#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>
#include "resource.h"       // main symbols
#include <objectwithsiteimplsec.h>
#include "dsextend.h"

/////////////////////////////////////////////////////////////////////////////
// CAna2EncComp
class ATL_NO_VTABLE __declspec(uuid("28953661-0231-41db-8986-21FF4388EE9B")) CAna2EncComp : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAna2EncComp, &__uuidof(CAna2EncComp)>,
    public IObjectWithSiteImplSec<CAna2EncComp>,
	public IMSVidCompositionSegmentImpl<CAna2EncComp>
{
public:
    CAna2EncComp() {}
    virtual ~CAna2EncComp() {}

REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_ANA2ENCCOMP_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CAna2EncComp));

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CAna2EncComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
    	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY(IPersist)
    END_COM_MAP()

public:

	PQCreateDevEnum m_pSystemEnum;

	//////////////

// IMSVidGraphSegment
// IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
	{
        if (m_fComposed) {
            return NOERROR;
        }
        ASSERT(m_pGraph);
        try {
            TRACELM(TRACE_ERROR, "CVidCtl::Ana2Enc() Compose");
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
			if (upstream == downstream) {
		 	    return Error(IDS_CANT_COMPOSE_WITH_SELF, __uuidof(IMSVidCompositionSegment), E_INVALIDARG);
			}
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CComposition::Compose() can't compose empty up segment");
		 	    return NOERROR;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CComposition::Compose() can't compose empty down segment");
                // this is not an error, for example, CA is an empty segment.
		 	    return NOERROR;
            }
            // do the list backwards
            DSFilterList upF;
            for(VWGraphSegment::iterator upStart = up.begin(); upStart != up.end(); ++upStart){
                upF.push_back(*upStart);
            }

            for (DSFilterList::reverse_iterator iStart = upF.rbegin(); iStart != upF.rend(); ++iStart) {
                ASSERT((*iStart).GetGraph() == m_pGraph);
				for (VWGraphSegment::iterator iStop = down.begin(); iStop != down.end(); ++iStop) {
					ASSERT((*iStop).GetGraph() == m_pGraph);
					DSFilter pStart(*iStart);
					DSFilter pStop(*iStop);
					HRESULT hr = m_pGraph.Connect(pStart, pStop, m_Filters, 0x10);
                    if (SUCCEEDED(hr)) {
						m_Segments.push_back(up);
						m_Segments.push_back(down);
						m_pDown = m_Segments.end();
						--m_pDown;
						m_pUp = m_pDown;
						--m_pUp;
						m_fComposed = true;
						return NOERROR;
					}
				}
			}
            TRACELM(TRACE_ERROR, "CComposition::Compose() compose didn't connect anything");
	 	    return Error(IDS_CANT_COMPOSE, __uuidof(IMSVidCompositionSegment), E_FAIL);
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
	}
};

#endif // ANA2ENC_H
// end of file - ANA2ENC.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\ana2xds.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing analog capture to ovmixer
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef ANA2XDS_H
#define ANA2XDS_H

#pragma once

#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>
#include "resource.h"       // main symbols
#include <objectwithsiteimplsec.h>
#include "dsextend.h"

/////////////////////////////////////////////////////////////////////////////
// CAna2XDSComp
class ATL_NO_VTABLE __declspec(uuid("3540D440-5B1D-49cb-821A-E84B8CF065A7")) CAna2XDSComp : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAna2XDSComp, &__uuidof(CAna2XDSComp)>,
    public IObjectWithSiteImplSec<CAna2XDSComp>,
	public IMSVidCompositionSegmentImpl<CAna2XDSComp>
{
public:
    CAna2XDSComp() {}
    virtual ~CAna2XDSComp() {}

REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_ANA2XDSCOMP_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CAna2XDSComp));

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CAna2XDSComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
    	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY(IPersist)
    END_COM_MAP()

public:

	PQCreateDevEnum m_pSystemEnum;

	//////////////

// IMSVidGraphSegment
// IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
	{
        TRACELM(TRACE_ERROR, "CVidCtl::Ana2XDS() Compose");
        if (m_fComposed) {
            return NOERROR;
        }
        ASSERT(m_pGraph);
        try {

#if 0
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CAna2XDSComp::Compose() can't compose empty up segment");
                return E_INVALIDARG;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CAna2XDSComp::Compose() can't compose empty down segment");
                return E_INVALIDARG;
            }

            VWGraphSegment::iterator iCap;
            for(iCap = up.begin(); iCap != up.end(); ++iCap){
                if(IsAnalogVideoCapture(*iCap)){
                    break;
                }   
            }
            if (iCap == up.end()) {
                TRACELM(TRACE_ERROR, "CAna2XDSComp::Compose() upstream segment has no capture filter");
                return E_FAIL;
            }
            ASSERT((*iCap).GetGraph() == m_pGraph);
            DSFilter::iterator iVbi;
            for(iVbi = (*iCap).begin(); iVbi != (*iCap).end(); ++iVbi){
                if((*iVbi).HasCategory(PIN_CATEGORY_VBI)){
                    break;
                }
            }

            if(iVbi == (*iCap).end()){
                TRACELM(TRACE_ERROR, "CAna2XDSComp::Compose() capture filter has no vbi");
                return E_FAIL;
            }

            HRESULT hr = S_OK;
            DSFilterList intermediates;
            for(VWGraphSegment::iterator pXDS = down.begin(); pXDS != down.end(); ++pXDS){
                hr = (*iVbi).IntelligentConnect((*pXDS), intermediates);
                if(FAILED(hr)){
                    continue;
                }
                else{
                    break;
                }
            }

            if(FAILED(hr)){
                TRACELM(TRACE_ERROR, "CAna2XDSComp::Compose() can't connect vbi to xds");
                return hr;
            }
            m_Filters.insert(m_Filters.end(), intermediates.begin(), intermediates.end());
			return NOERROR;
#else
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
			if (upstream == downstream) {
		 	    return Error(IDS_CANT_COMPOSE_WITH_SELF, __uuidof(IMSVidCompositionSegment), E_INVALIDARG);
			}
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CComposition::Compose() can't compose empty up segment");
		 	    return NOERROR;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CComposition::Compose() can't compose empty down segment");
                // this is not an error, for example, CA is an empty segment.
		 	    return NOERROR;
            }
            // do the list backwards
            DSFilterList upF;
            for(VWGraphSegment::iterator upStart = up.begin(); upStart != up.end(); ++upStart){
                upF.push_back(*upStart);
            }

            for (DSFilterList::reverse_iterator iStart = upF.rbegin(); iStart != upF.rend(); ++iStart) {
                ASSERT((*iStart).GetGraph() == m_pGraph);
				for (VWGraphSegment::iterator iStop = down.begin(); iStop != down.end(); ++iStop) {
					ASSERT((*iStop).GetGraph() == m_pGraph);
					DSFilter pStart(*iStart);
					DSFilter pStop(*iStop);
//					HRESULT hr = m_pGraph.Connect(pStart, pStop, m_Filters);
					HRESULT hr = m_pGraph.Connect(pStop, pStart, m_Filters, 0, UPSTREAM);
                    if (SUCCEEDED(hr)) {
						m_Segments.push_back(up);
						m_Segments.push_back(down);
						m_pDown = m_Segments.end();
						--m_pDown;
						m_pUp = m_pDown;
						--m_pUp;
						m_fComposed = true;
						return NOERROR;
					}
				}
			}
            TRACELM(TRACE_ERROR, "CComposition::Compose() compose didn't connect anything");
	 	    return Error(IDS_CANT_COMPOSE, __uuidof(IMSVidCompositionSegment), E_FAIL);
#endif
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
	}
};

#endif // Ana2XDS_H
// end of file - Ana2XDS.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\atl\statreg.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __STATREG_H
#define __STATREG_H

#define E_ATL_REGISTRAR_DESC              0x0201
#define E_ATL_NOT_IN_MAP                  0x0202
#define E_ATL_UNEXPECTED_EOS              0x0203
#define E_ATL_VALUE_SET_FAILED            0x0204
#define E_ATL_RECURSE_DELETE_FAILED       0x0205
#define E_ATL_EXPECTING_EQUAL             0x0206
#define E_ATL_CREATE_KEY_FAILED           0x0207
#define E_ATL_DELETE_KEY_FAILED           0x0208
#define E_ATL_OPEN_KEY_FAILED             0x0209
#define E_ATL_CLOSE_KEY_FAILED            0x020A
#define E_ATL_UNABLE_TO_COERCE            0x020B
#define E_ATL_BAD_HKEY                    0x020C
#define E_ATL_MISSING_OPENKEY_TOKEN       0x020D
#define E_ATL_CONVERT_FAILED              0x020E
#define E_ATL_TYPE_NOT_SUPPORTED          0x020F
#define E_ATL_COULD_NOT_CONCAT            0x0210
#define E_ATL_COMPOUND_KEY                0x0211
#define E_ATL_INVALID_MAPKEY              0x0212
#define E_ATL_UNSUPPORTED_VT              0x0213
#define E_ATL_VALUE_GET_FAILED            0x0214
#define E_ATL_VALUE_TOO_LARGE             0x0215
#define E_ATL_MISSING_VALUE_DELIMETER     0x0216
#define E_ATL_DATA_NOT_BYTE_ALIGNED       0x0217

namespace ATL
{
const TCHAR  chDirSep            = _T('\\');
const TCHAR  chRightBracket      = _T('}');
const TCHAR  chLeftBracket       = _T('{');
const TCHAR  chQuote             = _T('\'');
const TCHAR  chEquals            = _T('=');
const LPCTSTR  szStringVal       = _T("S");
const LPCTSTR  szDwordVal        = _T("D");
const LPCTSTR  szBinaryVal       = _T("B");
const LPCTSTR  szValToken        = _T("Val");
const LPCTSTR  szForceRemove     = _T("ForceRemove");
const LPCTSTR  szNoRemove        = _T("NoRemove");
const LPCTSTR  szDelete          = _T("Delete");

class CExpansionVector
{
public:
	//Declare EXPANDER struct.  Only used locally.
	struct EXPANDER
	{
		LPOLESTR    szKey;
		LPOLESTR    szValue;
	};

	CExpansionVector()
	{
		m_cEls = 0;
		m_nSize=10;
		m_p = (EXPANDER**)malloc(m_nSize*sizeof(EXPANDER*));
	}
	~CExpansionVector()
	{
		 free(m_p);
	}
	HRESULT Add(LPCOLESTR lpszKey, LPCOLESTR lpszValue)
	{
		USES_CONVERSION;
		HRESULT hr = S_OK;

		EXPANDER* pExpand = NULL;
		ATLTRY(pExpand = new EXPANDER);
		if (pExpand == NULL)
			return E_OUTOFMEMORY;

		DWORD cbKey = (ocslen(lpszKey)+1)*sizeof(OLECHAR);
		DWORD cbValue = (ocslen(lpszValue)+1)*sizeof(OLECHAR);
		pExpand->szKey = (LPOLESTR)CoTaskMemAlloc(cbKey);
		pExpand->szValue = (LPOLESTR)CoTaskMemAlloc(cbValue);
		if (pExpand->szKey == NULL || pExpand->szValue == NULL)
		{
			CoTaskMemFree(pExpand->szKey);
			CoTaskMemFree(pExpand->szValue);
			delete pExpand;
			return E_OUTOFMEMORY;
		}
		memcpy(pExpand->szKey, lpszKey, cbKey);
		memcpy(pExpand->szValue, lpszValue, cbValue);

      EXPANDER** p;
		if (m_cEls == m_nSize)
		{
			m_nSize*=2;
			p = (EXPANDER**)realloc(m_p, m_nSize*sizeof(EXPANDER*));
         if (p == NULL)
         {
            CoTaskMemFree(pExpand->szKey);
            CoTaskMemFree(pExpand->szValue);
            hr = E_OUTOFMEMORY;
         }
         else
            m_p = p;
		}

      if (SUCCEEDED(hr))
      {
         ATLASSERT(m_p != NULL);
		   m_p[m_cEls] = pExpand;
		   m_cEls++;
      }

		return hr;

	}
	LPCOLESTR Find(LPTSTR lpszKey)
	{
		USES_CONVERSION;
		for (int iExpand = 0; iExpand < m_cEls; iExpand++)
		{
			if (!lstrcmpi(OLE2T(m_p[iExpand]->szKey), lpszKey)) //are equal
				return m_p[iExpand]->szValue;
		}
		return NULL;
	}
	HRESULT ClearReplacements()
	{
		for (int iExpand = 0; iExpand < m_cEls; iExpand++)
		{
			EXPANDER* pExp = m_p[iExpand];
			CoTaskMemFree(pExp->szValue);
			CoTaskMemFree(pExp->szKey);
			delete pExp;
		}
		m_cEls = 0;
		return S_OK;
	}

private:
	EXPANDER** m_p;
	int m_cEls;
	int m_nSize;
};

class CRegObject;

class CRegParser
{
public:
	CRegParser(CRegObject* pRegObj);

	HRESULT  PreProcessBuffer(LPCTSTR lpszReg, LPTSTR* ppszReg);
	HRESULT  RegisterBuffer(LPTSTR szReg, BOOL bRegister);

protected:

	void    SkipWhiteSpace();
	HRESULT NextToken(LPTSTR szToken);
	HRESULT AddValue(CRegKey& rkParent,LPCTSTR szValueName, LPTSTR szToken);
	BOOL    CanForceRemoveKey(LPCTSTR szKey);
	BOOL    HasSubKeys(HKEY hkey);
	BOOL    HasValues(HKEY hkey);
	HRESULT RegisterSubkeys(LPTSTR szToken, HKEY hkParent, BOOL bRegister, BOOL bInRecovery = FALSE);
	BOOL    IsSpace(TCHAR ch);
	LPTSTR  m_pchCur;

	CRegObject*     m_pRegObj;

	HRESULT GenerateError(UINT) {return DISP_E_EXCEPTION;}
	HRESULT HandleReplacements(LPTSTR& szToken);
	HRESULT SkipAssignment(LPTSTR szToken);

	BOOL    EndOfVar() { return chQuote == *m_pchCur && chQuote != *CharNext(m_pchCur); }
	static LPCTSTR StrChr(LPCTSTR lpsz, TCHAR ch);
	static HKEY HKeyFromString(LPTSTR szToken);
	static BYTE ChToByte(const TCHAR ch);
	static BOOL VTFromRegType(LPCTSTR szValueType, VARTYPE& vt);
	static LPCTSTR rgszNeverDelete[];
	static const int cbNeverDelete;
	static const int MAX_VALUE;
	static const int MAX_TYPE;
	class CParseBuffer
	{
	public:
		int nPos;
		int nSize;
		LPTSTR p;
		CParseBuffer(int nInitial)
		{
			nPos = 0;
			nSize = nInitial;
			p = (LPTSTR) CoTaskMemAlloc(nSize*sizeof(TCHAR));
		}
		~CParseBuffer()
		{
			CoTaskMemFree(p);
		}
		BOOL AddChar(const TCHAR* pch)
		{
			if (nPos == nSize) // realloc
			{
            LPTSTR pNew;
				nSize *= 2;
				pNew = (LPTSTR) CoTaskMemRealloc(p, nSize*sizeof(TCHAR));
            if (pNew == NULL)
               return FALSE;
            p = pNew;
			}
			p[nPos++] = *pch;
#ifndef _UNICODE
			if (IsDBCSLeadByte(*pch))
				p[nPos++] = *(pch + 1);
#endif
			return TRUE;
		}
		BOOL AddString(LPCOLESTR lpsz)
		{
			USES_CONVERSION;
			LPCTSTR lpszT = OLE2CT(lpsz);
			while (*lpszT)
			{
				AddChar(lpszT);
				lpszT++;
			}
			return TRUE;
		}
		LPTSTR Detach()
		{
			LPTSTR lp = p;
			p = NULL;
			return lp;
		}

	};
};

#if defined(_ATL_DLL) | defined(_ATL_DLL_IMPL)
class ATL_NO_VTABLE CRegObject
 : public IRegistrar
#else
class CRegObject
#endif
{
public:

	~CRegObject(){ClearReplacements();}
	HRESULT FinalConstruct() {return S_OK;}
	void FinalRelease() {}


	// Map based methods
	HRESULT STDMETHODCALLTYPE AddReplacement(LPCOLESTR lpszKey, LPCOLESTR lpszItem);
	HRESULT STDMETHODCALLTYPE ClearReplacements();
	LPCOLESTR StrFromMap(LPTSTR lpszKey);

	// Register via a given mechanism
	HRESULT STDMETHODCALLTYPE ResourceRegister(LPCOLESTR pszFileName, UINT nID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE ResourceRegisterSz(LPCOLESTR pszFileName, LPCOLESTR pszID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE ResourceUnregister(LPCOLESTR pszFileName, UINT nID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE ResourceUnregisterSz(LPCOLESTR pszFileName, LPCOLESTR pszID, LPCOLESTR pszType);
	HRESULT STDMETHODCALLTYPE FileRegister(LPCOLESTR bstrFileName)
	{
		return CommonFileRegister(bstrFileName, TRUE);
	}

	HRESULT STDMETHODCALLTYPE FileUnregister(LPCOLESTR bstrFileName)
	{
		return CommonFileRegister(bstrFileName, FALSE);
	}

	HRESULT STDMETHODCALLTYPE StringRegister(LPCOLESTR bstrData)
	{
		return RegisterWithString(bstrData, TRUE);
	}

	HRESULT STDMETHODCALLTYPE StringUnregister(LPCOLESTR bstrData)
	{
		return RegisterWithString(bstrData, FALSE);
	}

protected:

	HRESULT CommonFileRegister(LPCOLESTR pszFileName, BOOL bRegister);
	HRESULT RegisterFromResource(LPCOLESTR pszFileName, LPCTSTR pszID, LPCTSTR pszType, BOOL bRegister);
	HRESULT RegisterWithString(LPCOLESTR pszData, BOOL bRegister);

	static HRESULT GenerateError(UINT) {return DISP_E_EXCEPTION;}

	CExpansionVector                                m_RepMap;
    // NOTE: the original atl source code used CComObjectThreadModel, but if you're linking together 
    // multiple objects with different threading models then this breaks because the different models see different 
    // initialization sizes for the ctor.  since registration doesn't happen that often, we're just going to take
    // the microscopic perf hit of always assuming multithread and really grabbing a real critsec.  the alternative
    // would be to templatize all the CRegXXX classes with a threading model parameter.  but, its not worth doing that much work
    // for such a low use frequency component.
    CComMultiThreadModel::AutoCriticalSection      m_csMap;
};

inline HRESULT STDMETHODCALLTYPE CRegObject::AddReplacement(LPCOLESTR lpszKey, LPCOLESTR lpszItem)
{
	m_csMap.Lock();
	HRESULT hr = m_RepMap.Add(lpszKey, lpszItem);
	m_csMap.Unlock();
	return hr;
}

inline HRESULT CRegObject::RegisterFromResource(LPCOLESTR bstrFileName, LPCTSTR szID,
										 LPCTSTR szType, BOOL bRegister)
{
	USES_CONVERSION;

	HRESULT     hr;
	CRegParser  parser(this);
	HINSTANCE   hInstResDll;
	HRSRC       hrscReg;
	HGLOBAL     hReg;
	DWORD       dwSize;
	LPSTR       szRegA;
	LPTSTR      szReg;

	hInstResDll = LoadLibraryEx(OLE2CT(bstrFileName), NULL, LOAD_LIBRARY_AS_DATAFILE);

	if (NULL == hInstResDll)
	{
		ATLTRACE2(atlTraceRegistrar, 0, _T("Failed to LoadLibrary on %s\n"), OLE2CT(bstrFileName));
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ReturnHR;
	}

	hrscReg = FindResource((HMODULE)hInstResDll, szID, szType);

	if (NULL == hrscReg)
	{
		if (DWORD_PTR(szID) <= 0xffff)
			ATLTRACE2(atlTraceRegistrar, 0, _T("Failed to FindResource on ID:%d TYPE:%s\n"),
			(DWORD)(DWORD_PTR)szID, szType);
		else
			ATLTRACE2(atlTraceRegistrar, 0, _T("Failed to FindResource on ID:%s TYPE:%s\n"),
			szID, szType);
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ReturnHR;
	}

	hReg = LoadResource((HMODULE)hInstResDll, hrscReg);

	if (NULL == hReg)
	{
		ATLTRACE2(atlTraceRegistrar, 0, _T("Failed to LoadResource \n"));
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ReturnHR;
	}

	dwSize = SizeofResource((HMODULE)hInstResDll, hrscReg);
	szRegA = (LPSTR)hReg;
	if (szRegA[dwSize] != NULL)
	{
		szRegA = (LPSTR)_alloca(dwSize+1);
		memcpy(szRegA, (void*)hReg, dwSize+1);
		szRegA[dwSize] = NULL;
	}

	szReg = A2T(szRegA);

	hr = parser.RegisterBuffer(szReg, bRegister);

ReturnHR:

	if (NULL != hInstResDll)
		FreeLibrary((HMODULE)hInstResDll);
	return hr;
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceRegister(LPCOLESTR szFileName, UINT nID, LPCOLESTR szType)
{
	USES_CONVERSION;
	return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), OLE2CT(szType), TRUE);
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceRegisterSz(LPCOLESTR szFileName, LPCOLESTR szID, LPCOLESTR szType)
{
	USES_CONVERSION;
	if (szID == NULL || szType == NULL)
		return E_INVALIDARG;
	return RegisterFromResource(szFileName, OLE2CT(szID), OLE2CT(szType), TRUE);
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceUnregister(LPCOLESTR szFileName, UINT nID, LPCOLESTR szType)
{
	USES_CONVERSION;
	return RegisterFromResource(szFileName, MAKEINTRESOURCE(nID), OLE2CT(szType), FALSE);
}

inline HRESULT STDMETHODCALLTYPE CRegObject::ResourceUnregisterSz(LPCOLESTR szFileName, LPCOLESTR szID, LPCOLESTR szType)
{
	USES_CONVERSION;
	if (szID == NULL || szType == NULL)
		return E_INVALIDARG;

	return RegisterFromResource(szFileName, OLE2CT(szID), OLE2CT(szType), FALSE);
}

inline HRESULT CRegObject::RegisterWithString(LPCOLESTR bstrData, BOOL bRegister)
{
	USES_CONVERSION;
	CRegParser  parser(this);


	LPCTSTR szReg = OLE2CT(bstrData);

	HRESULT hr = parser.RegisterBuffer((LPTSTR)szReg, bRegister);

	return hr;
}

inline HRESULT CRegObject::ClearReplacements()
{
	m_csMap.Lock();
	HRESULT hr = m_RepMap.ClearReplacements();
	m_csMap.Unlock();
	return hr;
}


inline LPCOLESTR CRegObject::StrFromMap(LPTSTR lpszKey)
{
	m_csMap.Lock();
	LPCOLESTR lpsz = m_RepMap.Find(lpszKey);
	if (lpsz == NULL) // not found!!
		ATLTRACE2(atlTraceRegistrar, 0, _T("Map Entry not found\n"));
	m_csMap.Unlock();
	return lpsz;
}

inline HRESULT CRegObject::CommonFileRegister(LPCOLESTR bstrFileName, BOOL bRegister)
{
	USES_CONVERSION;

	CRegParser  parser(this);

	HANDLE hFile = CreateFile(OLE2CT(bstrFileName), GENERIC_READ, 0, NULL,
							  OPEN_EXISTING,
							  FILE_ATTRIBUTE_READONLY,
							  NULL);
	if (INVALID_HANDLE_VALUE == hFile)
	{
		ATLTRACE2(atlTraceRegistrar, 0, _T("Failed to CreateFile on %s\n"), OLE2CT(bstrFileName));
		return HRESULT_FROM_WIN32(GetLastError());
	}

	HRESULT hRes = S_OK;
	DWORD cbRead;
	DWORD cbFile = GetFileSize(hFile, NULL); // No HiOrder DWORD required
	char* szReg = (char*)_alloca(cbFile + 1);
	if (ReadFile(hFile, szReg, cbFile, &cbRead, NULL) == 0)
	{
		ATLTRACE2(atlTraceRegistrar, 0, "Read Failed on file%s\n", OLE2CT(bstrFileName));
		hRes =  HRESULT_FROM_WIN32(GetLastError());
	}
	if (SUCCEEDED(hRes))
	{
		szReg[cbRead] = NULL;
		LPTSTR szConverted = A2T(szReg);
		hRes = parser.RegisterBuffer(szConverted, bRegister);
	}
	CloseHandle(hFile);
	return hRes;
}

__declspec(selectany) LPCTSTR CRegParser::rgszNeverDelete[] = //Component Catagories
{
	_T("CLSID"), _T("TYPELIB")
};

__declspec(selectany) const int CRegParser::cbNeverDelete = sizeof(rgszNeverDelete) / sizeof(LPCTSTR*);
__declspec(selectany) const int CRegParser::MAX_VALUE=4096;
__declspec(selectany) const int CRegParser::MAX_TYPE=MAX_VALUE;


inline BOOL CRegParser::VTFromRegType(LPCTSTR szValueType, VARTYPE& vt)
{
	struct typemap
	{
		LPCTSTR lpsz;
		VARTYPE vt;
	};
	static const typemap map[] = {
		{szStringVal, VT_BSTR},
		{szDwordVal,  VT_UI4},
		{szBinaryVal, VT_UI1}
	};

	for (int i=0;i<sizeof(map)/sizeof(typemap);i++)
	{
		if (!lstrcmpi(szValueType, map[i].lpsz))
		{
			vt = map[i].vt;
			return TRUE;
		}
	}

	return FALSE;

}

inline BYTE CRegParser::ChToByte(const TCHAR ch)
{
	switch (ch)
	{
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
				return (BYTE) (ch - '0');
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
				return (BYTE) (10 + (ch - 'A'));
		case 'a':
		case 'b':
		case 'c':
		case 'd':
		case 'e':
		case 'f':
				return (BYTE) (10 + (ch - 'a'));
		default:
				ATLASSERT(FALSE);
				ATLTRACE2(atlTraceRegistrar, 0, _T("Bogus value %c passed as binary Hex value\n"), ch);
				return 0;
	}
}

inline HKEY CRegParser::HKeyFromString(LPTSTR szToken)
{
	struct keymap
	{
		LPCTSTR lpsz;
		HKEY hkey;
	};
	static const keymap map[] = {
		{_T("HKCR"), HKEY_CLASSES_ROOT},
		{_T("HKCU"), HKEY_CURRENT_USER},
		{_T("HKLM"), HKEY_LOCAL_MACHINE},
		{_T("HKU"),  HKEY_USERS},
		{_T("HKPD"), HKEY_PERFORMANCE_DATA},
		{_T("HKDD"), HKEY_DYN_DATA},
		{_T("HKCC"), HKEY_CURRENT_CONFIG},
		{_T("HKEY_CLASSES_ROOT"), HKEY_CLASSES_ROOT},
		{_T("HKEY_CURRENT_USER"), HKEY_CURRENT_USER},
		{_T("HKEY_LOCAL_MACHINE"), HKEY_LOCAL_MACHINE},
		{_T("HKEY_USERS"), HKEY_USERS},
		{_T("HKEY_PERFORMANCE_DATA"), HKEY_PERFORMANCE_DATA},
		{_T("HKEY_DYN_DATA"), HKEY_DYN_DATA},
		{_T("HKEY_CURRENT_CONFIG"), HKEY_CURRENT_CONFIG}
	};

	for (int i=0;i<sizeof(map)/sizeof(keymap);i++)
	{
		if (!lstrcmpi(szToken, map[i].lpsz))
			return map[i].hkey;
	}
	return NULL;
}

inline LPCTSTR CRegParser::StrChr(LPCTSTR lpsz, TCHAR ch)
{
	LPCTSTR p = NULL;
	while (*lpsz)
	{
		if (*lpsz == ch)
		{
			p = lpsz;
			break;
		}
		lpsz = CharNext(lpsz);
	}
	return p;
}

inline CRegParser::CRegParser(CRegObject* pRegObj)
{
	m_pRegObj           = pRegObj;
	m_pchCur            = NULL;
}

inline BOOL CRegParser::IsSpace(TCHAR ch)
{
	switch (ch)
	{
		case _T(' '):
		case _T('\t'):
		case _T('\r'):
		case _T('\n'):
				return TRUE;
	}

	return FALSE;
}

inline void CRegParser::SkipWhiteSpace()
{
	while(IsSpace(*m_pchCur))
		m_pchCur = CharNext(m_pchCur);
}

inline HRESULT CRegParser::NextToken(LPTSTR szToken)
{
	USES_CONVERSION;

	SkipWhiteSpace();

	// NextToken cannot be called at EOS
	if (NULL == *m_pchCur)
		return GenerateError(E_ATL_UNEXPECTED_EOS);

	// handle quoted value / key
	if (chQuote == *m_pchCur)
	{
		LPCTSTR szOrig = szToken;

		m_pchCur = CharNext(m_pchCur);

		while (NULL != *m_pchCur && !EndOfVar())
		{
			if (chQuote == *m_pchCur) // If it is a quote that means we must skip it
				m_pchCur = CharNext(m_pchCur);

			LPTSTR pchPrev = m_pchCur;
			m_pchCur = CharNext(m_pchCur);

			if (szToken + sizeof(WORD) >= MAX_VALUE + szOrig)
				return GenerateError(E_ATL_VALUE_TOO_LARGE);
			for (int i = 0; pchPrev+i < m_pchCur; i++, szToken++)
				*szToken = *(pchPrev+i);
		}

		if (NULL == *m_pchCur)
		{
			ATLTRACE2(atlTraceRegistrar, 0, _T("NextToken : Unexpected End of File\n"));
			return GenerateError(E_ATL_UNEXPECTED_EOS);
		}

		*szToken = NULL;
		m_pchCur = CharNext(m_pchCur);
	}

	else
	{   // Handle non-quoted ie parse up till first "White Space"
		while (NULL != *m_pchCur && !IsSpace(*m_pchCur))
		{
			LPTSTR pchPrev = m_pchCur;
			m_pchCur = CharNext(m_pchCur);
			for (int i = 0; pchPrev+i < m_pchCur; i++, szToken++)
				*szToken = *(pchPrev+i);
		}

		*szToken = NULL;
	}
	return S_OK;
}

inline HRESULT CRegParser::AddValue(CRegKey& rkParent,LPCTSTR szValueName, LPTSTR szToken)
{
	USES_CONVERSION;
	HRESULT hr;

	TCHAR       szTypeToken[MAX_TYPE];
	VARTYPE     vt;
	LONG        lRes = ERROR_SUCCESS;
	UINT        nIDRes = 0;

	if (FAILED(hr = NextToken(szTypeToken)))
		return hr;
	if (!VTFromRegType(szTypeToken, vt))
	{
		ATLTRACE2(atlTraceRegistrar, 0, _T("%s Type not supported\n"), szTypeToken);
		return GenerateError(E_ATL_TYPE_NOT_SUPPORTED);
	}

	TCHAR szValue[MAX_VALUE];
	SkipWhiteSpace();
	if (FAILED(hr = NextToken(szValue)))
		return hr;
	ULONG ulVal;

	switch (vt)
	{
	case VT_BSTR:
		lRes = rkParent.SetValue(szValue, szValueName);
		ATLTRACE2(atlTraceRegistrar, 2, _T("Setting Value %s at %s\n"), szValue, !szValueName ? _T("default") : szValueName);
		break;
	case VT_UI4:
#ifdef _WIN64
		ATLASSERT(FALSE);
      ulVal = 0;
#pragma message( "Still need VarUI4FromStr()." )
#else
		VarUI4FromStr(T2OLE(szValue), 0, 0, &ulVal);
#endif
		lRes = rkParent.SetValue(ulVal, szValueName);
		ATLTRACE2(atlTraceRegistrar, 2, _T("Setting Value %d at %s\n"), ulVal, !szValueName ? _T("default") : szValueName);
		break;
	case VT_UI1:
		{
			int cbValue = lstrlen(szValue);
			if (cbValue & 0x00000001)
			{
				ATLTRACE2(atlTraceRegistrar, 0, _T("Binary Data does not fall on BYTE boundries\n"));
				return E_FAIL;
			}
			int cbValDiv2 = cbValue/2;
			BYTE* rgBinary = (BYTE*)_alloca(cbValDiv2*sizeof(BYTE));
			memset(rgBinary, 0, cbValDiv2);
			if (rgBinary == NULL)
				return E_FAIL;
			for (int irg = 0; irg < cbValue; irg++)
				rgBinary[(irg/2)] |= (ChToByte(szValue[irg])) << (4*(1 - (irg & 0x00000001)));
			lRes = RegSetValueEx(rkParent, szValueName, 0, REG_BINARY, rgBinary, cbValDiv2);
			break;
		}
	}

	if (ERROR_SUCCESS != lRes)
	{
		nIDRes = E_ATL_VALUE_SET_FAILED;
		hr = HRESULT_FROM_WIN32(lRes);
	}

	if (FAILED(hr = NextToken(szToken)))
		return hr;

	return S_OK;
}

inline BOOL CRegParser::CanForceRemoveKey(LPCTSTR szKey)
{
	for (int iNoDel = 0; iNoDel < cbNeverDelete; iNoDel++)
		if (!lstrcmpi(szKey, rgszNeverDelete[iNoDel]))
			 return FALSE;                       // We cannot delete it

	return TRUE;
}

inline BOOL CRegParser::HasSubKeys(HKEY hkey)
{
	DWORD       cbSubKeys = 0;

	if (FAILED(RegQueryInfoKey(hkey, NULL, NULL, NULL,
							   &cbSubKeys, NULL, NULL,
							   NULL, NULL, NULL, NULL, NULL)))
	{
		ATLTRACE2(atlTraceRegistrar, 0, _T("Should not be here!!\n"));
		ATLASSERT(FALSE);
		return FALSE;
	}

	return cbSubKeys > 0;
}

inline BOOL CRegParser::HasValues(HKEY hkey)
{
	DWORD       cbValues = 0;

	LONG lResult = RegQueryInfoKey(hkey, NULL, NULL, NULL,
								  NULL, NULL, NULL,
								  &cbValues, NULL, NULL, NULL, NULL);
	if (ERROR_SUCCESS != lResult)
	{
		ATLTRACE2(atlTraceRegistrar, 0, _T("RegQueryInfoKey Failed "));
		ATLASSERT(FALSE);
		return FALSE;
	}

	if (1 == cbValues)
	{
		DWORD cbMaxName= MAX_VALUE;
		TCHAR szValueName[MAX_VALUE];
		// Check to see if the Value is default or named
		lResult = RegEnumValue(hkey, 0, szValueName, &cbMaxName, NULL, NULL, NULL, NULL);
		if (ERROR_SUCCESS == lResult && (szValueName[0] != NULL))
			return TRUE; // Named Value means we have a value
		return FALSE;
	}

	return cbValues > 0; // More than 1 means we have a non-default value
}

inline HRESULT CRegParser::SkipAssignment(LPTSTR szToken)
{
	HRESULT hr;
	TCHAR szValue[MAX_VALUE];

	if (*szToken == chEquals)
	{
		if (FAILED(hr = NextToken(szToken)))
			return hr;
		// Skip assignment
		SkipWhiteSpace();
		if (FAILED(hr = NextToken(szValue)))
			return hr;
		if (FAILED(hr = NextToken(szToken)))
			return hr;
	}

	return S_OK;
}

inline HRESULT CRegParser::PreProcessBuffer(LPCTSTR lpszReg, LPTSTR* ppszReg)
{
	USES_CONVERSION;
	ATLASSERT(lpszReg != NULL);
	ATLASSERT(ppszReg != NULL);
	*ppszReg = NULL;
	int nSize = lstrlen(lpszReg)*2;
	CParseBuffer pb(nSize);
	if (pb.p == NULL)
		return E_OUTOFMEMORY;
	LPCTSTR pchCur = lpszReg;
	HRESULT hr = S_OK;

	while (*pchCur != NULL) // look for end
	{
		if (*pchCur == _T('%'))
		{
			pchCur = CharNext(pchCur);
			if (*pchCur == _T('%'))
				pb.AddChar(pchCur);
			else
			{
				LPCTSTR lpszNext = StrChr(pchCur, _T('%'));
				if (lpszNext == NULL)
				{
					ATLTRACE2(atlTraceRegistrar, 0, _T("Error no closing % found\n"));
					hr = GenerateError(E_ATL_UNEXPECTED_EOS);
					break;
				}
				int nLength = int(lpszNext - pchCur);
				if (nLength > 31)
				{
					hr = E_FAIL;
					break;
				}
				TCHAR buf[32];
				lstrcpyn(buf, pchCur, nLength+1);
				LPCOLESTR lpszVar = m_pRegObj->StrFromMap(buf);
				if (lpszVar == NULL)
				{
					hr = GenerateError(E_ATL_NOT_IN_MAP);
					break;
				}
				pb.AddString(lpszVar);
				while (pchCur != lpszNext)
					pchCur = CharNext(pchCur);
			}
		}
		else
			pb.AddChar(pchCur);
		pchCur = CharNext(pchCur);
	}
	pb.AddChar(pchCur);
	if (SUCCEEDED(hr))
		*ppszReg = pb.Detach();
	return hr;
}

inline HRESULT CRegParser::RegisterBuffer(LPTSTR szBuffer, BOOL bRegister)
{
	TCHAR   szToken[MAX_VALUE];
	HRESULT hr = S_OK;

	LPTSTR szReg;
	hr = PreProcessBuffer(szBuffer, &szReg);
	if (FAILED(hr))
		return hr;

#if defined(_DEBUG) && defined(DEBUG_REGISTRATION)
	OutputDebugString(szReg); //would call ATLTRACE but szReg is > 512 bytes
	OutputDebugString(_T("\n"));
#endif //_DEBUG

	m_pchCur = szReg;

	// Preprocess szReg

	while (NULL != *m_pchCur)
	{
		if (FAILED(hr = NextToken(szToken)))
			break;
		HKEY hkBase;
		if ((hkBase = HKeyFromString(szToken)) == NULL)
		{
			ATLTRACE2(atlTraceRegistrar, 0, _T("HKeyFromString failed on %s\n"), szToken);
			hr = GenerateError(E_ATL_BAD_HKEY);
			break;
		}

		if (FAILED(hr = NextToken(szToken)))
			break;

		if (chLeftBracket != *szToken)
		{
			ATLTRACE2(atlTraceRegistrar, 0, _T("Syntax error, expecting a {, found a %s\n"), szToken);
			hr = GenerateError(E_ATL_MISSING_OPENKEY_TOKEN);
			break;
		}
		if (bRegister)
		{
			LPTSTR szRegAtRegister = m_pchCur;
			hr = RegisterSubkeys(szToken, hkBase, bRegister);
			if (FAILED(hr))
			{
				ATLTRACE2(atlTraceRegistrar, 0, _T("Failed to register, cleaning up!\n"));
				m_pchCur = szRegAtRegister;
				RegisterSubkeys(szToken, hkBase, FALSE);
				break;
			}
		}
		else
		{
			if (FAILED(hr = RegisterSubkeys(szToken, hkBase, bRegister)))
				break;
		}

		SkipWhiteSpace();
	}
	CoTaskMemFree(szReg);
	return hr;
}

inline HRESULT CRegParser::RegisterSubkeys(LPTSTR szToken, HKEY hkParent, BOOL bRegister, BOOL bRecover)
{
	CRegKey keyCur;
	LONG    lRes;
	LPTSTR  szKey = NULL;
	BOOL    bDelete = TRUE;
	BOOL    bInRecovery = bRecover;
	HRESULT hr = S_OK;

	ATLTRACE2(atlTraceRegistrar, 2, _T("Num Els = %d\n"), cbNeverDelete);
	if (FAILED(hr = NextToken(szToken)))
		return hr;


	while (*szToken != chRightBracket) // Continue till we see a }
	{
		BOOL bTokenDelete = !lstrcmpi(szToken, szDelete);

		if (!lstrcmpi(szToken, szForceRemove) || bTokenDelete)
		{
			if (FAILED(hr = NextToken(szToken)))
				break;

			if (bRegister)
			{
				CRegKey rkForceRemove;

				if (StrChr(szToken, chDirSep) != NULL)
					return GenerateError(E_ATL_COMPOUND_KEY);

				if (CanForceRemoveKey(szToken))
				{
					rkForceRemove.Attach(hkParent);
					rkForceRemove.RecurseDeleteKey(szToken);
					rkForceRemove.Detach();
				}
				if (bTokenDelete)
				{
					if (FAILED(hr = NextToken(szToken)))
						break;
					if (FAILED(hr = SkipAssignment(szToken)))
						break;
					goto EndCheck;
				}
			}

		}

		if (!lstrcmpi(szToken, szNoRemove))
		{
			bDelete = FALSE;    // set even for register
			if (FAILED(hr = NextToken(szToken)))
				break;
		}

		if (!lstrcmpi(szToken, szValToken)) // need to add a value to hkParent
		{
			TCHAR  szValueName[_MAX_PATH];

			if (FAILED(hr = NextToken(szValueName)))
				break;
			if (FAILED(hr = NextToken(szToken)))
				break;


			if (*szToken != chEquals)
				return GenerateError(E_ATL_EXPECTING_EQUAL);

			if (bRegister)
			{
				CRegKey rk;

				rk.Attach(hkParent);
				hr = AddValue(rk, szValueName, szToken);
				rk.Detach();

				if (FAILED(hr))
					return hr;

				goto EndCheck;
			}
			else
			{
				if (!bRecover)
				{
					ATLTRACE2(atlTraceRegistrar, 1, _T("Deleting %s\n"), szValueName);
					CRegKey rkParent;
					rkParent.Attach(hkParent);
					rkParent.DeleteValue(szValueName);
					rkParent.Detach();
				}

				if (FAILED(hr = SkipAssignment(szToken)))
					break;
				continue;  // can never have a subkey
			}
		}

		if (StrChr(szToken, chDirSep) != NULL)
			return GenerateError(E_ATL_COMPOUND_KEY);

		if (bRegister)
		{
			lRes = keyCur.Open(hkParent, szToken, KEY_ALL_ACCESS);
			if (ERROR_SUCCESS != lRes)
			{
				// Failed all access try read only
				lRes = keyCur.Open(hkParent, szToken, KEY_READ);
				if (ERROR_SUCCESS != lRes)
				{
					// Finally try creating it
					ATLTRACE2(atlTraceRegistrar, 2, _T("Creating key %s\n"), szToken);
					lRes = keyCur.Create(hkParent, szToken);
					if (ERROR_SUCCESS != lRes)
						return GenerateError(E_ATL_CREATE_KEY_FAILED);
				}
			}

			if (FAILED(hr = NextToken(szToken)))
				break;


			if (*szToken == chEquals)
			{
				if (FAILED(hr = AddValue(keyCur, NULL, szToken))) // NULL == default
					break;
			}
		}
		else
		{
			if (!bRecover && keyCur.Open(hkParent, szToken, KEY_READ) != ERROR_SUCCESS)
				bRecover = TRUE;

			// TRACE out Key open status and if in recovery mode
#ifdef _DEBUG
			if (!bRecover)
				ATLTRACE2(atlTraceRegistrar, 1, _T("Opened Key %s\n"), szToken);
			else
				ATLTRACE2(atlTraceRegistrar, 0, _T("Ignoring Open key on %s : In Recovery mode\n"), szToken);
#endif //_DEBUG

			// Remember Subkey
			if (szKey == NULL)
				szKey = (LPTSTR)_alloca(sizeof(TCHAR)*_MAX_PATH);
			lstrcpyn(szKey, szToken, _MAX_PATH);

			// If in recovery mode

			if (bRecover || HasSubKeys(keyCur) || HasValues(keyCur))
			{
				if (FAILED(hr = NextToken(szToken)))
					break;
				if (FAILED(hr = SkipAssignment(szToken)))
					break;


				if (*szToken == chLeftBracket)
				{
					if (FAILED(hr = RegisterSubkeys(szToken, keyCur.m_hKey, bRegister, bRecover)))
						break;
					if (bRecover) // Turn off recovery if we are done
					{
						bRecover = bInRecovery;
						ATLTRACE2(atlTraceRegistrar, 0, _T("Ending Recovery Mode\n"));
						if (FAILED(hr = NextToken(szToken)))
							break;
						if (FAILED(hr = SkipAssignment(szToken)))
							break;
						continue;
					}
				}

				if (!bRecover && HasSubKeys(keyCur))
				{
					// See if the KEY is in the NeverDelete list and if so, don't
					if (CanForceRemoveKey(szKey))
					{
						ATLTRACE2(atlTraceRegistrar, 0, _T("Deleting non-empty subkey %s by force\n"), szKey);
						keyCur.RecurseDeleteKey(szKey);
					}
					if (FAILED(hr = NextToken(szToken)))
						break;
					continue;
				}

				if (bRecover)
					continue;
			}

			if (!bRecover && keyCur.Close() != ERROR_SUCCESS)
			   return GenerateError(E_ATL_CLOSE_KEY_FAILED);

			if (!bRecover && bDelete)
			{
				ATLTRACE2(atlTraceRegistrar, 0, _T("Deleting Key %s\n"), szKey);
				CRegKey rkParent;
				rkParent.Attach(hkParent);
				rkParent.DeleteSubKey(szKey);
				rkParent.Detach();
			}

			if (FAILED(hr = NextToken(szToken)))
				break;
			if (FAILED(hr = SkipAssignment(szToken)))
				break;
		}

EndCheck:

		if (bRegister)
		{
			if (*szToken == chLeftBracket && lstrlen(szToken) == 1)
			{
				if (FAILED(hr = RegisterSubkeys(szToken, keyCur.m_hKey, bRegister, FALSE)))
					break;
				if (FAILED(hr = NextToken(szToken)))
					break;
			}
		}
	}

	return hr;
}

}; //namespace ATL

#endif //__STATREG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\anacap.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing analog capture to ovmixer
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef ANACAP_H
#define ANACAP_H

#pragma once
#include <uuids.h>
#include "bdamedia.h"
#include "MSVidTVTuner.h"
#include "resource.h"       // main symbols
#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>
#include <objectwithsiteimplsec.h>
#include "devices.h"


/////////////////////////////////////////////////////////////////////////////
// CAnaCapComp
class ATL_NO_VTABLE __declspec(uuid("E18AF75A-08AF-11d3-B64A-00C04F79498E")) CAnaCapComp : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CAnaCapComp, &__uuidof(CAnaCapComp)>,
    public IObjectWithSiteImplSec<CAnaCapComp>,
    public IMSVidCompositionSegmentImpl<CAnaCapComp>
{
public:
    CAnaCapComp() {}
    virtual ~CAnaCapComp() {}

    REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
        IDS_REG_ANACAPCOMP_DESC,
        LIBID_MSVidCtlLib,
        __uuidof(CAnaCapComp));

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CAnaCapComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
        COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY(IPersist)
    END_COM_MAP()

    // IMSVidComposition
public:
    // IMSVidGraphSegment
    // IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
    {
        if (m_fComposed) {
            return NOERROR;
        }
        ASSERT(m_pGraph);
        try {
            TRACELM(TRACE_DETAIL, "CAnaCapComp::Compose()");
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CAnaCapComp::Compose() can't compose empty up segment");
                return E_INVALIDARG;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CAnaCapComp::Compose() can't compose empty down segment");
                return E_INVALIDARG;
            }

            VWGraphSegment::iterator iOv;
            for (iOv = down.begin(); iOv != down.end(); ++iOv) {
                if (IsVideoRenderer(*iOv)) {
                    break;
                }
            }

            if (iOv == down.end()) {
                TRACELM(TRACE_ERROR, "CAnaCapComp::Compose() downstream segment has no ov mixer filter");
                return E_FAIL;
            }

            TRACELM(TRACE_DETAIL, "CAnaCapComp::Compose() found vr");

            ASSERT((*iOv).GetGraph() == m_pGraph);
            DSFilter pOv(*iOv);

            CComQIPtr<IMSVidAnalogTuner> qiITV(upstream);
            CMSVidTVTuner* qiTV;
            qiTV = static_cast<CMSVidTVTuner*>(qiITV.p);
            DSPin pVidPin;
            VWGraphSegment::iterator iCap;
            for (iCap = up.begin(); iCap != up.end(); ++iCap) {
                if (IsAnalogVideoCapture(*iCap)) {
                    break;
                }
            }
            if (iCap == up.end()) {
                TRACELM(TRACE_ERROR, "CAnaCapComp::Compose() upstream segment has no capture filter");
                return E_FAIL;
            }
            ASSERT((*iCap).GetGraph() == m_pGraph);
            TRACELM(TRACE_DETAIL, "CAnaCapComp::Compose() found capture filter");

            DSFilter pCap(*iCap);

            DSFilter::iterator iCapPin;
            DSFilter::iterator iPrePin;
            for (iCapPin = pCap.begin(); iCapPin != pCap.end(); ++iCapPin) {
                if (IsAnalogVideoCaptureViewingPin(*iCapPin)) {
                    break;
                }
            }
            for (iPrePin = pCap.begin(); iPrePin != pCap.end(); ++iPrePin) {
                if (IsAnalogVideoCapturePreviewPin(*iPrePin)) {
                    break;
                }
            }
            if (iCapPin == pCap.end() && iPrePin == pCap.end()) {  

                TRACELM(TRACE_ERROR, "CAnaCapComp::Compose() no video pin on capture");
                bool fDeMux = false;

                // See if this is an error or not
                PQVidCtl pqCtl;
                if(!!m_pContainer){
                    HRESULT hr = m_pContainer->QueryInterface(IID_IMSVidCtl, reinterpret_cast<void**>(&pqCtl));
                    if(FAILED(hr)){
                        return hr;
                    }

                    PQFeatures fa;
                    hr = pqCtl->get_FeaturesActive(&fa);
                    if(FAILED(hr)){
                        return hr;
                    }

                    CFeatures* pC = static_cast<CFeatures *>(fa.p);
                    DeviceCollection::iterator i;
                    for(i = pC->m_Devices.begin(); i != pC->m_Devices.end(); ++i){
                        if(VWGraphSegment(*i).ClassID() == CLSID_MSVidEncoder){
                            break;
                        }
                    }

                    if(i != pC->m_Devices.end()){
                        fDeMux = true;
                    }
                }
                if (fDeMux){
                    TRACELM(TRACE_DETAIL, "CAnaCapComp::Compose() no viewing or previewing pin found but encoder active");
                    return NOERROR;
                }
                else{
                    TRACELM(TRACE_ERROR, "CAnaCapComp::Compose() no viewing or previewing pin found");
                    return E_FAIL;
                }
            }

            TRACELM(TRACE_DETAIL, "CAnaCapComp::Compose() found viewing or previewing pin");

            // this is an intelligent connect so that we can bring in xforms
            // for example certain usb tuners want to have media type jpg not yuv which
            // means we need a jpg/yuv xform between capture and render
            // this will also bring in the vpm if necessary
            DSPin pCapPin(*iCapPin);
            DSPin pPrePin(*iPrePin);
            if(iCapPin != pCap.end()){
                if (pCapPin.HasCategory(PIN_CATEGORY_VIDEOPORT)) {

                    DSFilter vpm;
                    bool fVPMalreadyloaded = false;

                    for (DSGraph::iterator i = m_pGraph.begin(); i != m_pGraph.end(); ++i) {
                        DSFilter f(*i);
                        if (IsVPM(f)) {
                            vpm = f;
                            fVPMalreadyloaded = true;
                            break;
                        }
                    }

                    if (!fVPMalreadyloaded) {
                        HRESULT hr = vpm.CoCreateInstance(CLSID_VideoPortManager);
                        if (FAILED(hr)) {
                            TRACELM(TRACE_DETAIL, "CAnaCapComp::Compose() can't create vpm");
                            return E_UNEXPECTED;
                        }
                        CString csName;
                        hr = m_pGraph.AddFilter(vpm, csName);
                        if (FAILED(hr)) {
                            TRACELM(TRACE_DETAIL, "CAnaCapComp::Compose() can't insert vpm in graph");
                            return E_UNEXPECTED;
                        }
                    }

                    if (vpm && !fVPMalreadyloaded) {
                        m_Filters.push_back(vpm);
                    }
                    DSFilter::iterator iVPVBI;
                    for (iVPVBI = pCap.begin(); iVPVBI != pCap.end(); ++iVPVBI) {
                        DSPin pVPVBI(*iVPVBI);
                        if (pVPVBI.HasCategory(PIN_CATEGORY_VIDEOPORT_VBI)) {
                            HRESULT hr = pVPVBI.IntelligentConnect(vpm, m_Filters);
                            if (SUCCEEDED(hr)) {
                                break;
                            }
                        }
                    }


                }
            }
            HRESULT hr = E_FAIL;
            DSFilterList intermediates;
            if(iCapPin != pCap.end()){
                hr = pCapPin.IntelligentConnect(pOv, intermediates);
            }

            if(FAILED(hr)){
                if(iPrePin != pCap.end()){
                    pPrePin = *iPrePin;
                    hr = pPrePin.IntelligentConnect(pOv, intermediates);
                }
            }

            if (FAILED(hr)) {
                return Error(IDS_CANT_CONNECT_CAP_VR, __uuidof(IMSVidCtl), E_UNEXPECTED);
            }
            m_Filters.insert(m_Filters.end(), intermediates.begin(), intermediates.end());

            TRACELM(TRACE_DETAIL, "CAnaCapComp::Compose() SUCCEEDED");
            m_fComposed = true;
            return NOERROR;
        } catch (ComException &e) {
            HRESULT hr = e;
            TRACELSM(TRACE_ERROR, (dbgDump << "CAnaCapComp::Compose() exception = " << hexdump(hr)), "");
            return e;
        } catch (...) {
            TRACELM(TRACE_ERROR, "CAnaCapComp::Compose() exception ... ");
            return E_UNEXPECTED;
        }
    }
};

#endif // ANACAP_H
// end of file - anacap.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\analogtvcp.h ===
// Copyright (c) 2001  Microsoft Corporation.  All Rights Reserved.
#ifndef _MSVIDANALOGTUNERCP_H_
#define _MSVIDANALOGTUNERCP_H_

template <class T>
class CProxy_IMSVidAnalogTuner : public CProxy_Tuner<T, &IID_IMSVidAnalogTunerEvent, CComDynamicUnkArray>
{
	//Warning this class may be recreated by the wizard.
public:

// TODO: add fileplayback specific events here	
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\analogradiots.h ===
/////////////////////////////////////////////////////////////////////////////////////
// AnalogRadioTS.h : Declaration of the CAnalogRadioTS
// Copyright (c) Microsoft Corporation 1999.

#ifndef __ANALOGRADIOTS_H_
#define __ANALOGRADIOTS_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "analogradiotsimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CAnalogRadioTS
class ATL_NO_VTABLE __declspec(uuid("8A674B4C-1F63-11d3-B64C-00C04F79498E")) CAnalogRadioTS : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAnalogRadioTS, &__uuidof(CAnalogRadioTS)>,
    public IObjectWithSiteImplSec<CAnalogRadioTS>,
	public IAnalogRadioTSImpl<CAnalogRadioTS>
{
public:
    CAnalogRadioTS() : m_bRequiresSave(false)
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_ANALOGRADIOTS_PROGID, 
						   IDS_REG_ANALOGRADIOTS_DESC,
						   LIBID_TunerLib,
						   __uuidof(CAnalogRadioTS), tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAnalogRadioTS)
    COM_INTERFACE_ENTRY(IAnalogRadioTuningSpace)
    COM_INTERFACE_ENTRY(ITuningSpace)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP_WITH_FTM()

BEGIN_CATEGORY_MAP(CAnalogRadioTS)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
    IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
END_CATEGORY_MAP()

public:

    bool m_bRequiresSave;
    BEGIN_PROP_MAP(CAnalogRadioTS)
        CHAIN_PROP_MAP(IAnalogRadioTSImpl<CAnalogRadioTS>)
    END_PROPERTY_MAP()

};

typedef CComQIPtr<IAnalogRadioTuningSpace> PQAnalogRadioTS;

#endif //__ANALOGRADIOTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\analogtvts.h ===
/////////////////////////////////////////////////////////////////////////////////////
// AnalogTVTS.h : Declaration of the CAnalogTVTS
// Copyright (c) Microsoft Corporation 1999.

#ifndef __ANALOGTVTS_H_
#define __ANALOGTVTS_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "analogtvtsimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CAnalogTVTS
class ATL_NO_VTABLE __declspec(uuid("8A674B4D-1F63-11d3-B64C-00C04F79498E")) CAnalogTVTS : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAnalogTVTS, &__uuidof(CAnalogTVTS)>,
    public IObjectWithSiteImplSec<CAnalogTVTS>,
	public IAnalogTVTSImpl<CAnalogTVTS>
{
public:
    CAnalogTVTS() : m_bRequiresSave(false)
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_ANALOGTVTS_PROGID, 
						   IDS_REG_ANALOGTVTS_DESC,
						   LIBID_TunerLib,
						   __uuidof(CAnalogTVTS), tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAnalogTVTS)
    COM_INTERFACE_ENTRY(IAnalogTVTuningSpace)
    COM_INTERFACE_ENTRY(ITuningSpace)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP_WITH_FTM()

BEGIN_CATEGORY_MAP(CAnalogTVTS)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
    IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
END_CATEGORY_MAP()

public:

    bool m_bRequiresSave;
    BEGIN_PROP_MAP(CAnalogTVTS)
        CHAIN_PROP_MAP(IAnalogTVTSImpl<CAnalogTVTS>)
    END_PROPERTY_MAP()

};

typedef CComQIPtr<IAnalogTVTuningSpace> PQAnalogTVTS;

#endif //__ANALOGTVTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\anadata.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing analog capture to ovmixer
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef ANADATA_H
#define ANADATA_H

#pragma once

#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>
#include "resource.h"       // main symbols
#include <objectwithsiteimplsec.h>

/////////////////////////////////////////////////////////////////////////////
// CAnaDataComp
class ATL_NO_VTABLE __declspec(uuid("C5702CD6-9B79-11d3-B654-00C04F79498E")) CAnaDataComp : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CAnaDataComp, &__uuidof(CAnaDataComp)>,
    public IObjectWithSiteImplSec<CAnaDataComp>,
	public IMSVidCompositionSegmentImpl<CAnaDataComp>
{
public:
    CAnaDataComp() {}
    virtual ~CAnaDataComp() {}

REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_ANADATACOMP_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CAnaDataComp));

    DECLARE_PROTECT_FINAL_CONSTRUCT()

    BEGIN_COM_MAP(CAnaDataComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
    	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY(IPersist)
    END_COM_MAP()

public:

	PQCreateDevEnum m_pSystemEnum;

	//////////////
	HRESULT ConnectCodecPin(DSPin& pCodecPin, DSFilter& pCap, DSFilter& pIPSink) {
		// if this fails we just skip the pin not the whole filter so we don't need
		// to check the return code from the connect
		if (pCodecPin.IsInput()) {
			pCodecPin.IntelligentConnect(pCap, m_Filters, 0, UPSTREAM);
		} else {
            pCodecPin.IntelligentConnect(pIPSink, m_Filters, DSGraph::ATTEMPT_MERIT_DO_NOT_USE);
		}
		return NOERROR;
	}

	//////////////
	HRESULT AddCodec(const DSFilterMoniker& pCodecMkr, DSFilter& pCap, DSFilter& pIPSink) {
		DSFilter pCodec = m_pGraph.AddMoniker(pCodecMkr);
		if (!pCodec) {
            // this can happen if a codec is uninstalled or the driver file is removed
            // but the registry doesn't get cleaned up.
            // also can happen on an upgrade if a codec has been removed from the product.
            TRACELSM(TRACE_ERROR, (dbgDump << "CAnaDataComp::AddCodec() can't add mkr" << pCodecMkr), "");
            return S_FALSE;
		}
		m_Filters.push_back(pCodec);
		//connect all input pins including hw slicing support
		std::for_each(pCodec.begin(),
					  pCodec.end(),
					  bndr_obj_2_3<arity3pmf<CAnaDataComp, DSPin&, DSFilter&, DSFilter&, HRESULT> >(
						  *this, 
						  arity3pmf<CAnaDataComp, 
									DSPin&, 
									DSFilter&, 
									DSFilter&, 
									HRESULT>(&CAnaDataComp::ConnectCodecPin), 
						  pCap, 
						  pIPSink
					 ));

		return NOERROR;
	}

	//////////////
	HRESULT CapturePinPrep(DSPin& pCapPin, DSFilter& pMSTee, DSFilter& pVPM) {
		if (pCapPin.GetConnection() || pCapPin.GetDirection() == PINDIR_INPUT) {
			return NOERROR;  // skip connected pins
		}
		HRESULT hr;
		DSPin targ;
		if (pCapPin.HasCategory(PIN_CATEGORY_VBI)) {
			if (!pMSTee) {
				DSDevices teelist(m_pSystemEnum, KSCATEGORY_SPLITTER);
				pMSTee = m_pGraph.AddMoniker(*(teelist.begin()));
				if (!pMSTee) {
					TRACELM(TRACE_ERROR, "CAnaDataComp::Compose() can't add mstee moniker to graph");
					THROWCOM(E_UNEXPECTED);
				}
			}
			targ = pMSTee.FirstPin(PINDIR_INPUT);
		    ASSERT(targ);
		    hr = pCapPin.Connect(targ);
		    if (FAILED(hr)) {
			    TRACELSM(TRACE_ERROR, (dbgDump << "CAnaDataComp::CapturePinPrep() can't connect " << pCapPin << " " << pCapPin.GetFilter() << " to " << targ << " " << targ.GetFilter() << " hr = " << std::hex << hr), "");
			    THROWCOM(E_UNEXPECTED);
		    }
		} else if (pCapPin.HasCategory(PIN_CATEGORY_VIDEOPORT_VBI)) {
			// hook up vbi surf to pincat_vpvbi
			if (!pVPM) {
				CString csName(_T("VideoPort Manager"));
				pVPM = m_pGraph.AddFilter(CLSID_VideoPortManager, csName);
				if (!pVPM) {
					TRACELM(TRACE_ERROR, "CAnaDataComp::Compose() can't create vbisurf");
					THROWCOM(E_UNEXPECTED);
				}
			}
            DSFilterList intermediates;
		    hr = pCapPin.IntelligentConnect(pVPM, intermediates);
		    if (FAILED(hr)) {
			    TRACELSM(TRACE_ERROR, (dbgDump << "CAnaDataComp::CapturePinPrep() can't connect " << pCapPin << " " << pCapPin.GetFilter() << " to " << targ << " " << targ.GetFilter() << " hr = " << std::hex << hr), "");
			    THROWCOM(E_UNEXPECTED);
		    }
	        m_Filters.insert(m_Filters.end(), intermediates.begin(), intermediates.end());
		}
		return NOERROR;
	}

// IMSVidGraphSegment
// IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
	{
        if (m_fComposed) {
            return NOERROR;
        }
        ASSERT(m_pGraph);
        try {
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CAnaDataComp::Compose() can't compose empty up segment");
                return E_INVALIDARG;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CAnaDataComp::Compose() can't compose empty down segment");
                return E_INVALIDARG;
            }
            VWGraphSegment::iterator iCap = std::find_if(up.begin(),
                                                         up.end(),
                                                         arity1_pointer(&IsAnalogVideoCapture));
            if (iCap == up.end()) {
                TRACELM(TRACE_ERROR, "CAnaDataComp::Compose() upstream segment has no capture filter");
                return E_FAIL;
            }
            ASSERT((*iCap).GetGraph() == m_pGraph);

            VWGraphSegment::iterator iIPSink = std::find_if(down.begin(),
															down.end(),
															arity1_pointer(&IsIPSink));
            if (iIPSink == down.end()) {
                TRACELM(TRACE_ERROR, "CAnaDataComp::Compose() downstream segment has no ip sink filter");
                return E_FAIL;
            }
			if (!m_pSystemEnum) {
				HRESULT hr = m_pSystemEnum.CoCreateInstance(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER);
				if (FAILED(hr)) {
					return E_UNEXPECTED;
				}
			}
			DSFilter ipsink(*iIPSink);
            ASSERT(!!ipsink);
            ASSERT(ipsink.GetGraph() == m_pGraph);
            PQVidCtl pqCtl;
			HRESULT hr = m_pContainer->QueryInterface(IID_IMSVidCtl, reinterpret_cast<void**>(&pqCtl));
			if(FAILED(hr)){
				return hr;
			}
            CComQIPtr<IMSVidVideoRenderer> spVidVid;
            hr = pqCtl->get_VideoRendererActive(&spVidVid);
            if(FAILED(hr)){
                return hr;
            }
            DSFilter vpm;
            bool fVPMalreadyloaded = false;
            if(spVidVid){
                for (DSGraph::iterator i = m_pGraph.begin(); i != m_pGraph.end(); ++i) {
                    DSFilter f(*i);
                    if (IsVPM(f)) {
                        vpm = f;
                        fVPMalreadyloaded = true;
                        break;
                    }
                }
            }
            DSFilter mstee;
#if 0
			std::for_each((*iCap).begin(), 
						  (*iCap).end(), 
						  bndr_obj_2_3<arity3pmf<CAnaDataComp, DSPin&, DSFilter&, DSFilter&, HRESULT> >(
							  *this, 
							  arity3pmf<CAnaDataComp, 
										DSPin&, 
										DSFilter&, 
										DSFilter&, 
										HRESULT>(&CAnaDataComp::CapturePinPrep), 
							  mstee, 
							  vpm
						  ));
#else
            DSFilter::iterator i2;
            for (i2 = (*iCap).begin(); i2 != (*iCap).end(); ++i2) {
                CapturePinPrep(*i2, mstee, vpm);
            }
#endif
			if (!mstee) {
				TRACELM(TRACE_ERROR, "CAnaDataComp::Compose() no vbi pins on capture filter");
				return Error(IDS_E_NOVBI, __uuidof(CAnaCapComp), E_FAIL);
			}
            if (vpm && !fVPMalreadyloaded) {
                m_Filters.push_back(vpm);
            }
            m_Filters.push_back(mstee);
            //m_Filters.push_back(ipsink);

			// create codec enumerator
			DSDevices codeclist(m_pSystemEnum, KSCATEGORY_VBICODEC);
			std::for_each(codeclist.begin(), 
						  codeclist.end(), 
						  bndr_obj_2_3<arity3pmf<CAnaDataComp, const DSFilterMoniker&, DSFilter&, DSFilter&, HRESULT> >(
							  *this, 
							  arity3pmf<CAnaDataComp, 
										const DSFilterMoniker&, 
										DSFilter&, 
										DSFilter&, 
										HRESULT>(&CAnaDataComp::AddCodec), 
							  (*iCap), 
							  ipsink
						  ));
			return NOERROR;
        } catch (ComException &e) {
            return e;
        } catch (...) {
            return E_UNEXPECTED;
        }
	}
};

#endif // ANADATA_H
// end of file - anadata.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\anasin.h ===
//==========================================================================;
//
// Composition.h : Declaration of the custom composition class for gluing ANAlog capture to sbe SINk
// Copyright (c) Microsoft Corporation 1999.
//
/////////////////////////////////////////////////////////////////////////////


#ifndef ANASIN_H
#define ANASIN_H

#pragma once
#include "stdafx.h"
#include <uuids.h>
#include "bdamedia.h"
#include "MSVidTVTuner.h"
#include "MSVidSBESink.h"
#include "encdec.h"
#include "resource.h"       // main symbols
#include <objectwithsiteimplsec.h>
#include <winerror.h>
#include <algorithm>
#include <compimpl.h>
#include <seg.h>



/////////////////////////////////////////////////////////////////////////////
// CAnaSinComp
class ATL_NO_VTABLE __declspec(uuid("9F50E8B1-9530-4ddc-825E-1AF81D47AED6")) CAnaSinComp : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CAnaSinComp, &__uuidof(CAnaSinComp)>,
    public IObjectWithSiteImplSec<CAnaSinComp>,
    public IMSVidCompositionSegmentImpl<CAnaSinComp>
{
public:
    CAnaSinComp() {}
    virtual ~CAnaSinComp() {}
    
    REGISTER_NONAUTOMATION_OBJECT(IDS_PROJNAME, 
        IDS_REG_ANASINCOMP_DESC,
        LIBID_MSVidCtlLib,
        __uuidof(CAnaSinComp));
    
    DECLARE_PROTECT_FINAL_CONSTRUCT()
        
        BEGIN_COM_MAP(CAnaSinComp)
        COM_INTERFACE_ENTRY(IMSVidCompositionSegment)
        COM_INTERFACE_ENTRY(IMSVidGraphSegment)
        COM_INTERFACE_ENTRY(IObjectWithSite)
        COM_INTERFACE_ENTRY(IPersist)
        END_COM_MAP()
        
        // IMSVidComposition
public:
    // IMSVidGraphSegment
    // IMSVidCompositionSegment
    STDMETHOD(Compose)(IMSVidGraphSegment * upstream, IMSVidGraphSegment * downstream)
    {
        if (m_fComposed) {
            return NOERROR;
        }
        ASSERT(m_pGraph);
        try {
            TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose()");
            VWGraphSegment up(upstream);
            ASSERT(up.Graph() == m_pGraph);
            VWGraphSegment down(downstream);
            ASSERT(down.Graph() == m_pGraph);
            if (up.begin() == up.end()) {
                TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() can't compose empty up segment");
                return E_INVALIDARG;
            }
            if (down.begin() == down.end()) {
                TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() can't compose empty down segment");
                return E_INVALIDARG;
            }
#if 0
            VWGraphSegment::iterator iOv = std::find_if(down.begin(),
                down.end(),
                arity1_pointer(&IsVideoRenderer));
#endif            
            CMSVidStreamBufferSink* ds = (CMSVidStreamBufferSink*)downstream;
            DSFilter pSink(ds->m_Filters[0]);
            
            CComQIPtr<IMSVidAnalogTuner> qiITV(upstream);
            CMSVidTVTuner* qiTV;
            qiTV = static_cast<CMSVidTVTuner*>(qiITV.p);
            DSPin pVidPin;
            DSPin pAudPin;
#if 0
            if(!!qiTV && qiTV->m_iDeMux > 0){
                CString csName;
                // render demux out to vr
                DSFilter pDeMux = qiTV->m_Filters[qiTV->m_iDeMux];
                DSFilter::iterator iVidPin;
                DSMediaType mtVideo(MEDIATYPE_Video, MEDIASUBTYPE_MPEG2_VIDEO, FORMAT_MPEG2Video);
                DSMediaType mtAudio(MEDIATYPE_Audio, MEDIASUBTYPE_MPEG1Payload, FORMAT_WaveFormatEx);
                for (iVidPin = pDeMux.begin(); iVidPin != pDeMux.end(); ++iVidPin) {
                    DSPin::iterator j;
                    for(j = (*iVidPin).begin(); j != (*iVidPin).end(); ++j){
                        DSMediaType pinType(*j);
                        if (pinType == mtVideo){
                            CComPtr<IUnknown> spMpeg2Analyze(CLSID_Mpeg2VideoStreamAnalyzer, NULL, CLSCTX_INPROC_SERVER);
                            if (!spMpeg2Analyze) {
                                //TRACELSM(TRACE_ERROR, (dbgDump << "CMSVidStreamBufferSink::Build() can't load Stream Buffer Sink");
                                return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IStreamBufferSink), E_UNEXPECTED);
                            }
                            DSFilter vr(spMpeg2Analyze);
                            if (!vr) {
                                ASSERT(false);
                                return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IBaseFilter), E_UNEXPECTED);
                            }
                            m_Filters.push_back(vr);
                            csName = _T("Mpeg2 Analysis");
                            m_pGraph.AddFilter(vr, csName);
                            DSFilter::iterator a;
                            for(a = vr.begin(); a != vr.end(); ++a){
                                HRESULT hr = (*a).Connect(*iVidPin);
                                if(FAILED(hr)){
                                    continue;
                                }
                                else{
                                    break;
                                }
                            }
                            if(a == vr.end()){
                                return E_FAIL;
                            }
                            for(a = vr.begin(); a != vr.end(); ++a){
                                if((*a).GetDirection() == PINDIR_OUTPUT){
                                   pVidPin = (*a); 
                                }
                            }
                            if(!pVidPin){
                                return E_FAIL;
                            }
                        }
                        if(pinType == mtAudio){
                            pAudPin = (*iVidPin);
                        }
                    }
                    if(!!pVidPin && !!pAudPin){
                        break;
                    }
                }

                if(!pVidPin || !pAudPin){
                    TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't find video and/or audio pin on demux");
                    return E_UNEXPECTED;  
                }

                DSFilterList intermediates;
                CComBSTR encString(L"{C4C4C4F1-0049-4E2B-98FB-9537F6CE516D}");
                GUID2 encdecGuid (encString);
                HRESULT hr = S_OK;

                // Create and add to graph the Video Tagger Filter                
                CComPtr<IUnknown> spEncTagV(encdecGuid, NULL, CLSCTX_INPROC_SERVER);
                if (!spEncTagV) {
                    TRACELM(TRACE_ERROR, "CMSVidStreamBufferSink::Build() can't load Tagger filter");
                    return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IStreamBufferSink), E_UNEXPECTED);
                }

                DSFilter vrV(spEncTagV);
                if (!vrV) {
                    ASSERT(false);
                    return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IBaseFilter), E_UNEXPECTED);
                }

                m_Filters.push_back(vrV);
                csName = _T("Video Encoder Tagger Filter");
                m_pGraph.AddFilter(vrV, csName);
                
                // Connect video pin to Tagger
                hr = pVidPin.IntelligentConnect(vrV, intermediates);
                if(FAILED(hr)){
                    TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect audio pin to Audio Tagger");
                    return E_UNEXPECTED;  
                }
                
                // Connect Tagger to Sink
                DSFilter::iterator fil, vP;
                hr = E_FAIL;
                for(vP = vrV.begin(); vP != vrV.end(); ++ vP){
                    if((*vP).GetDirection() == PINDIR_OUTPUT){
                        break;   
                    }
                }
                if(vP == vrV.end()){
                    return E_UNEXPECTED;
                }
                for(fil = pSink.begin(); fil != pSink.end() && FAILED(hr); ++fil){
                    hr = (*vP).Connect((*fil));
                }
                if(FAILED(hr)){

                    TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect Video Tagger to Sink");
                    return E_UNEXPECTED;  
                }

                // Create and add to graph the Audio Tagger Filter 
                CComPtr<IUnknown> spEncTagA(encdecGuid, NULL, CLSCTX_INPROC_SERVER);
                if (!spEncTagA) {
                    TRACELM(TRACE_ERROR, "CMSVidStreamBufferSink::Build() can't load Tagger filter");
                    return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IStreamBufferSink), E_UNEXPECTED);
                }

                DSFilter vrA(spEncTagA);
                if (!vrA) {
                    ASSERT(false);
                    return ImplReportError(__uuidof(IMSVidStreamBufferSink), IDS_CANT_CREATE_FILTER, __uuidof(IBaseFilter), E_UNEXPECTED);
                }

                m_Filters.push_back(vrA);
                csName = _T("Audio Encoder Tagger Filter");
                m_pGraph.AddFilter(vrA, csName);

                // Connect audio pin to the Tagger
                hr = pAudPin.IntelligentConnect(vrA, intermediates);
                if(FAILED(hr)){
                    TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect audio pin to Audio Tagger");
                    return E_UNEXPECTED;  
                }
               
                // Connect Tagger to Sink
                hr = E_FAIL;
                for(vP = vrA.begin(); vP != vrA.end(); ++ vP){
                    if((*vP).GetDirection() == PINDIR_OUTPUT){
                        break;   
                    }
                }
                if(vP == vrA.end()){
                    return E_UNEXPECTED;
                }
                for(fil = pSink.begin(); fil != pSink.end() && FAILED(hr); ++fil){
                    hr = (*vP).Connect((*fil));
                }
                if(FAILED(hr)){

                    TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect Video Tagger to Sink");
                    return E_UNEXPECTED;  
                }
                /*                
                hr = m_pGraph.Connect(vrA, pSink, intermediates);
                if(FAILED(hr)){
                    TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() can't connect Audio Tagger to Sink");
                    return E_UNEXPECTED;  
                }
                */

                ASSERT(intermediates.begin() == intermediates.end());
                m_Filters.insert(m_Filters.end(), intermediates.begin(), intermediates.end());

            }
            else{
#endif
                return S_OK;
#if 0
            }
#endif
            TRACELM(TRACE_DETAIL, "CAnaSinComp::Compose() SUCCEEDED");
            m_fComposed = true;
            return NOERROR;
        } catch (ComException &e) {
            HRESULT hr = e;
            TRACELSM(TRACE_ERROR, (dbgDump << "CAnaSinComp::Compose() exception = " << hexdump(hr)), "");
            return e;
        } catch (...) {
            TRACELM(TRACE_ERROR, "CAnaSinComp::Compose() exception ... ");
            return E_UNEXPECTED;
        }
    }
};

#endif // AnaSin_H
// end of file - AnaSin.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\atscchanneltunerequest.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ATSCChannelTuneRequest.h : Declaration of the CATSCChannelTuneRequest
// Copyright (c) Microsoft Corporation 1999.

#ifndef __ATSCCHANNELTUNEREQUEST_H_
#define __ATSCCHANNELTUNEREQUEST_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "atscchanneltunerequestimpl.h"

typedef CComQIPtr<IATSCChannelTuneRequest> PQATSCChannelTuneRequest;

/////////////////////////////////////////////////////////////////////////////
// CATSCChannelTuneRequest
class ATL_NO_VTABLE CATSCChannelTuneRequest : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IATSCChannelTuneRequestImpl<CATSCChannelTuneRequest>,
	public CComCoClass<CATSCChannelTuneRequest, &CLSID_ATSCChannelTuneRequest>,
    public IObjectWithSiteImplSec<CATSCChannelTuneRequest>,
	public ISupportErrorInfo
{
public:

	CATSCChannelTuneRequest() {}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_ATSCCHANNELTUNEREQUEST_PROGID, 
						   IDS_REG_ATSCCHANNELTUNEREQUEST_DESC,
						   LIBID_TunerLib,
						   CLSID_ATSCChannelTuneRequest, tvBoth);

BEGIN_COM_MAP(CATSCChannelTuneRequest)
	COM_INTERFACE_ENTRY(IATSCChannelTuneRequest)
	COM_INTERFACE_ENTRY(IChannelTuneRequest)
	COM_INTERFACE_ENTRY(ITuneRequest)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
END_COM_MAP_WITH_FTM()

BEGIN_CATEGORY_MAP(CATSCChannelTuneRequest)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
    IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
END_CATEGORY_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    typedef IATSCChannelTuneRequestImpl<CATSCChannelTuneRequest> basetype;
    BEGIN_PROP_MAP(CATSCChannelTuneRequest)
        CHAIN_PROP_MAP(basetype)
    END_PROP_MAP()


};

#endif //__ATSCCHANNELTUNEREQUEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\atscchanneltunerequest.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// ATSCChannelTuneRequest.cpp : Implementation of CATSCChannelTuneRequest
// Copyright (c) Microsoft Corporation 1999.

#include "stdafx.h"
#include "Tuner.h"
#include "ATSCChannelTuneRequest.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_ATSCChannelTuneRequest, CATSCChannelTuneRequest)

/////////////////////////////////////////////////////////////////////////////
// CATSCChannelTuneRequest

STDMETHODIMP CATSCChannelTuneRequest::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IATSCChannelTuneRequest
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\atscts.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ATSCTS.h : Declaration of the CATSCTS
// Copyright (c) Microsoft Corporation 1999.

#ifndef __ATSCTS_H_
#define __ATSCTS_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "ATSCtsimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CATSCTS
class ATL_NO_VTABLE __declspec(uuid("A2E30750-6C3D-11d3-B653-00C04F79498E")) CATSCTS : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CATSCTS, &__uuidof(CATSCTS)>,
    public IObjectWithSiteImplSec<CATSCTS>,
	public IATSCTSImpl<CATSCTS>
{
public:
    CATSCTS() : m_bRequiresSave(false)
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_ATSCTUNINGSPACE_PROGID, 
						   IDS_REG_ATSCTUNINGSPACE_DESC,
						   LIBID_TunerLib,
						   __uuidof(CATSCTS), tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CATSCTS)
    COM_INTERFACE_ENTRY(IATSCTuningSpace)
    COM_INTERFACE_ENTRY(IAnalogTVTuningSpace)
    COM_INTERFACE_ENTRY(ITuningSpace)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IMPEG2TuneRequestSupport)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CATSCTS)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()


public:

    bool m_bRequiresSave;
    BEGIN_PROP_MAP(CATSCTS)
        CHAIN_PROP_MAP(IATSCTSImpl<CATSCTS>)
    END_PROPERTY_MAP()

};

typedef CComQIPtr<IATSCTuningSpace> PQATSCTS;

#endif //__ATSCTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\atsccomponenttype.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ATSCComponentType.h : Declaration of the CATSCComponentType
// Copyright (c) Microsoft Corporation 1999.

#ifndef __ATSCCOMPONENTTYPE_H_
#define __ATSCCOMPONENTTYPE_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "ATSCcomponenttypeimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CATSCComponentType
class ATL_NO_VTABLE __declspec(uuid("A8DCF3D5-0780-4ef4-8A83-2CFFAACB8ACE")) CATSCComponentType : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CATSCComponentType, &CLSID_ATSCComponentType>,
    public IObjectWithSiteImplSec<CATSCComponentType>,
	public IATSCComponentTypeImpl<CATSCComponentType>
{
public:
	CATSCComponentType()
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_ATSCCOMPONENTTYPE_PROGID, 
						   IDS_REG_ATSCCOMPONENTTYPE_DESC,
						   LIBID_TunerLib,
						   CLSID_ATSCComponentType, tvBoth);

DECLARE_NOT_AGGREGATABLE(CATSCComponentType)

DECLARE_PROTECT_FINAL_CONSTRUCT()

public:
    bool m_bRequiresSave;
    typedef IATSCComponentTypeImpl<CATSCComponentType> basetype;
    BEGIN_PROP_MAP(CATSCComponentType)
        CHAIN_PROP_MAP(basetype)
    END_PROPERTY_MAP()

    BEGIN_COM_MAP(CATSCComponentType)
	    COM_INTERFACE_ENTRY(IATSCComponentType)
		COM_INTERFACE_ENTRY(IMPEG2ComponentType)
	    COM_INTERFACE_ENTRY(IComponentType)
        COM_INTERFACE_ENTRY(IObjectWithSite)
	    COM_INTERFACE_ENTRY(IPersistPropertyBag)
    	COM_INTERFACE_ENTRY(IPersist)
	    COM_INTERFACE_ENTRY(IDispatch)
    END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CATSCComponentType)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()


};

typedef CComQIPtr<IATSCComponentType> PQATSCComponentType;

#endif //__ATSCCOMPONENTTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\auxiliaryints.h ===
/////////////////////////////////////////////////////////////////////////////////////
// AnalogRadioTS.h : Declaration of the CAuxInTS
// Copyright (c) Microsoft Corporation 1999.

#ifndef __AUXINTS_H_
#define __AUXINTS_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "AuxIntsimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CAuxInTS
class ATL_NO_VTABLE __declspec(uuid("F9769A06-7ACA-4e39-9CFB-97BB35F0E77E")) CAuxInTS : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAuxInTS, &__uuidof(CAuxInTS)>,
    public IObjectWithSiteImplSec<CAuxInTS>,
	public IAuxInTSImpl<CAuxInTS>
{
public:
    CAuxInTS() : m_bRequiresSave(false)
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_AUXINTS_PROGID, 
						   IDS_REG_AUXINTS_DESC,
						   LIBID_TunerLib,
						   __uuidof(CAuxInTS), tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAuxInTS)
    COM_INTERFACE_ENTRY(IAuxInTuningSpace)
    COM_INTERFACE_ENTRY(ITuningSpace)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP_WITH_FTM()

BEGIN_CATEGORY_MAP(CAuxInTS)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
    IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
END_CATEGORY_MAP()

public:

    bool m_bRequiresSave;
    BEGIN_PROP_MAP(CAuxInTS)
        CHAIN_PROP_MAP(IAuxInTSImpl<CAuxInTS>)
    END_PROPERTY_MAP()

};

typedef CComQIPtr<IAuxInTuningSpace> PQAuxInTS;

#endif //__AUXINTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\atsclocator.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// ATSCLocator.cpp : Implementation of CATSCLocator
// Copyright (c) Microsoft Corporation 1999-2000.

#include "stdafx.h"
#include "Tuner.h"
#include "ATSCLocator.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_ATSCLocator, CATSCLocator)

/////////////////////////////////////////////////////////////////////////////
// CATSCLocator

STDMETHODIMP CATSCLocator::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IATSCLocator
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\bcastevent.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// bcastevent.cpp : Implementation of CBroadcastEventService
// Copyright (c) Microsoft Corporation 2001.

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include "bcastevent.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_BroadcastEventService, CBroadcastEventService)

namespace BDATuningModel {

bool CReflectionThread::GetNextEvent(GUID& g) {
	CAutoLock lock(&m_WorkerLock);
    if (!m_FiringQ.size()) {
        return false;
    }
    g = m_FiringQ.front();
    m_FiringQ.pop();
    return true;
}

void CReflectionThread::GetAdviseList(AdviseList& l) {
	CAutoLock lock(&m_WorkerLock);
    AdviseList::iterator i;
    for (i = m_AdviseList.begin(); i != m_AdviseList.end(); ++i) {
        l.push_back(*i);
    }
    ASSERT(m_AdviseList.size() == l.size());
//    TRACELSM(TRACE_DEBUG, (dbgDump << "CReflectionThread::GetAdviseList() m_al = " << m_AdviseList.size() << " l = " << l.size()), "");
    return;
}

HRESULT CReflectionThread::Fire(PQGIT& pGIT) {
    GUID g;
    AdviseList l;
    GetAdviseList(l);
    while (GetNextEvent(g)) {
        for (AdviseList::iterator i = l.begin(); i != l.end(); ++i) {
            PQBroadcastEvent e;
            HRESULT hr = pGIT->GetInterfaceFromGlobal(*i, IID_IBroadcastEvent, reinterpret_cast<LPVOID*>(&e));
            if (SUCCEEDED(hr) && e) {
                e->Fire(g);
            }
        }
    }
    
	return NOERROR;
}

HRESULT CReflectionThread::Advise(PUnknown& p, DWORD *pdwCookie) {
    if (!m_pGIT) {
        HRESULT hr = m_pGIT.CoCreateInstance(CLSID_StdGlobalInterfaceTable, 0, CLSCTX_INPROC_SERVER);
        if (FAILED(hr)) {
            TRACELSM(TRACE_ERROR, (dbgDump << "CReflectionThread::Advise() can't create GIT.  hr = " << hr), "");
			return hr;
		}
    }
    ASSERT(m_pGIT);
    HRESULT hr = m_pGIT->RegisterInterfaceInGlobal(p, IID_IBroadcastEvent, pdwCookie);
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CReflectionThread::Advise() can't register interface. hr = " << hr), "");
		return hr;
	}
	CAutoLock lock(&m_WorkerLock);
    m_AdviseList.push_back(*pdwCookie);    

    return NOERROR;
}

HRESULT CReflectionThread::Unadvise(DWORD dwCookie) {
    if (!m_pGIT) {
        // if no GIT yet, then they can't have advised yet
        return E_INVALIDARG; 
    }
	CAutoLock lock(&m_WorkerLock);
    AdviseList::iterator i = std::find(m_AdviseList.begin(), m_AdviseList.end(), dwCookie);
    if (i == m_AdviseList.end()) {
        return E_INVALIDARG;
    }
    m_AdviseList.erase(i);
    ASSERT(m_pGIT);
    HRESULT hr = m_pGIT->RevokeInterfaceFromGlobal(dwCookie);
    if (FAILED(hr)) {
        TRACELSM(TRACE_ERROR, (dbgDump << "CReflectionThread::Advise() can't register interface. hr = " << hr), "");
		return hr;
	}

    return NOERROR;
}

}; // namespace

#endif //TUNING_MODEL_ONLY

// end of file - tuningspacecontainer.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\atsclocator.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ATSCLocator.h : Declaration of the CATSCLocator
// Copyright (c) Microsoft Corporation 2000.

#ifndef __ATSCLOCATOR_H_
#define __ATSCLOCATOR_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "ATSClocatorimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CATSCLocator
class ATL_NO_VTABLE __declspec(uuid("8872FF1B-98FA-4d7a-8D93-C9F1055F85BB"))CATSCLocator : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CATSCLocator, &CLSID_ATSCLocator>,
    public IObjectWithSiteImplSec<CATSCLocator>,
	public IATSCLocatorImpl<CATSCLocator>,
	public ISupportErrorInfo
{
public:
    CATSCLocator() : m_bRequiresSave(false)
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_ATSCLOCATOR_PROGID, 
						   IDS_REG_ATSCLOCATOR_DESC,
						   LIBID_TunerLib,
						   CLSID_ATSCLocator, tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CATSCLocator)
	COM_INTERFACE_ENTRY(IATSCLocator)
	COM_INTERFACE_ENTRY(ILocator)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CATSCLocator)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()


public:

    bool m_bRequiresSave;
    BEGIN_PROP_MAP(CATSCLocator)
        CHAIN_PROP_MAP(IATSCLocatorImpl<CATSCLocator>)
    END_PROPERTY_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

};

typedef CComQIPtr<IATSCLocator> PQATSCLocator;

#endif //__ATSCLOCATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\bcastevent.h ===
/////////////////////////////////////////////////////////////////////////////////////
// BroadcastEventService.h : Declaration of the CBroadcastEventService
// Copyright (c) Microsoft Corporation 2001.

#ifndef __BROADCASTEVENTSERVICE_H_
#define __BROADCASTEVENTSERVICE_H_

#pragma once

#include <queue>
#include "w32extend.h"
#include "regexthread.h"
#include <objectwithsiteimplsec.h>
#include "tuner.h"

namespace BDATuningModel {

typedef CComQIPtr<IBroadcastEvent> PQBroadcastEvent;
typedef std::list<DWORD> AdviseList;
typedef std::queue<GUID> EventQ;

class CReflectionThread : public CBaseThread {
public:
	typedef enum OP {
		RETHREAD_NOREQUEST,
		RETHREAD_FIRE,
		RETHREAD_EXIT,
	} OP;
	
private:	
	virtual DWORD ThreadProc(void) {
        PQGIT pGIT(CLSID_StdGlobalInterfaceTable, 0, CLSCTX_INPROC_SERVER);
        if (!pGIT) {
            TRACELM(TRACE_ERROR, "CReflectionThread::ThreadProc() can't create GIT");
			return 1;
		}
		for (;;) {
			OP req = GetRequest();
			switch (req) {
			case RETHREAD_FIRE: {
				Fire(pGIT);
				break;
			} case RETHREAD_EXIT:
				goto exit_thread;
			};
		};
exit_thread:
		return 0;
	}

	OP GetRequest() {
        HANDLE h[2];
        h[0] = m_EventSend;
        h[1] = m_EventTerminate;
		for (;;) {
			DWORD rc = MsgWaitForMultipleObjectsEx(2, h, INFINITE, QS_ALLEVENTS, 0);
			if (rc == WAIT_OBJECT_0) {
				m_EventSend.Reset();
				return RETHREAD_FIRE;
			} else if (rc == WAIT_OBJECT_0 + 1) {
                return RETHREAD_EXIT;
			} else {
				// pump messages so com runs
				MSG msg;
				while(PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
					TranslateMessage(&msg);
					DispatchMessage(&msg);
				}
			}

		}
	}

	HRESULT Fire(PQGIT& pGIT);
    bool GetNextEvent(GUID& g);
    void GetAdviseList(AdviseList& l);

	PQGIT m_pGIT;
	DWORD m_dwCookie;
    EventQ m_FiringQ;
    CAMEvent m_EventTerminate;
    AdviseList m_AdviseList;

public:
	CReflectionThread() : 
		CBaseThread(COINIT_APARTMENTTHREADED),
	    m_dwCookie(0)
			{}
	~CReflectionThread() {
		m_EventTerminate.Set();
		Close();
	}

    HRESULT PostFire(GUID& g) {
		CAutoLock lock(&m_WorkerLock);
        m_FiringQ.push(g);
        // signal the worker thread
        m_EventSend.Set();

        return NOERROR;
    }
    HRESULT Advise(PUnknown& p, DWORD* pdwCookie);
    HRESULT Unadvise(DWORD dwCookie);
};  // class CReflectionThread


/////////////////////////////////////////////////////////////////////////////
// CBroadcastEventService
class ATL_NO_VTABLE CBroadcastEventService : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CBroadcastEventService, &CLSID_BroadcastEventService>,
    public IObjectWithSiteImplSec<CBroadcastEventService>,
	public IBroadcastEvent, 
    public IConnectionPoint {

public:
    CBroadcastEventService() {
        m_pRT = new CReflectionThread;
		if (!m_pRT->Create()) {
			THROWCOM(E_UNEXPECTED);
		}
	}
    virtual ~CBroadcastEventService() {
		if (m_pRT) {
			delete m_pRT;
			m_pRT = NULL;
		}
	}

REGISTER_NONAUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
					                  IDS_REG_TUNINGSPACECONTAINER_DESC,
						              LIBID_TunerLib,
						              CLSID_BroadcastEventService, tvBoth);

DECLARE_NOT_AGGREGATABLE(CBroadcastEventService)

BEGIN_COM_MAP(CBroadcastEventService)
	COM_INTERFACE_ENTRY(IBroadcastEvent)
	COM_INTERFACE_ENTRY(IConnectionPoint)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP_WITH_FTM()

public:
// IConnectionPointContainer

// IBroadcastEventService
    STDMETHOD(Fire)(/*[in]*/ GUID EventID) {
        try {
            return m_pRT->PostFire(EventID);
        } catch(...) {
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(Advise)(LPUNKNOWN pUnk, LPDWORD pdwCookie) {
        if (!pUnk || !pdwCookie) {
            return E_POINTER;
        }
        try {
            return m_pRT->Advise(PUnknown(pUnk), pdwCookie);
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(Unadvise)(DWORD dwCookie) {
        try {
            return m_pRT->Unadvise(dwCookie);
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(EnumConnections)(IEnumConnections **ppEnum) {
        return E_NOTIMPL;
    }

    STDMETHOD(GetConnectionInterface)(IID* pIID) {
        if (!pIID) {
            return E_POINTER;
        }
        try {
            memcpy(pIID, &IID_IBroadcastEvent, sizeof(*pIID));
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }

    STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer** pContainer) {
        return E_NOTIMPL;
    }

protected:
	CReflectionThread *m_pRT; // <non-shared> worker thread
};

    

};


 
#endif //__BROADCASTEVENTSERVICE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\bdatuner.cpp ===
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1999-2000.
//
//--------------------------------------------------------------------------;
//
// MSVidBDATuner.cpp : Implementation of CMSVidBDATuner
//

#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY

#include "MSVidCtl.h"
#include "BDATuner.h"


DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidBDATunerDevice, CMSVidBDATuner)

/////////////////////////////////////////////////////////////////////////////
// CMSVidBDATuner

STDMETHODIMP CMSVidBDATuner::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSVidTuner,
		&__uuidof(CMSVidBDATuner)
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT CMSVidBDATuner::Unload(void) {
    BroadcastUnadvise();
    IMSVidGraphSegmentImpl<CMSVidBDATuner, MSVidSEG_SOURCE, &KSCATEGORY_BDA_RECEIVER_COMPONENT>::Unload();
    m_iNetworkProvider = -1;
    m_iTIF = -1;
	return NOERROR;
}

HRESULT CMSVidBDATuner::UpdateTR(TNTuneRequest &tr) {
	PQBDATuner pt(m_Filters[m_iNetworkProvider]);
	return pt->get_TuneRequest(&tr);
}

HRESULT CMSVidBDATuner::DoTune(TNTuneRequest &tr) {
	if (m_iNetworkProvider == -1) {
		return S_FALSE;
	}
	PQBDATuner pt(m_Filters[m_iNetworkProvider]);
	if (!pt) {
		return Error(IDS_INVALID_TR, __uuidof(CMSVidBDATuner), DISP_E_TYPEMISMATCH);
	}
	return pt->put_TuneRequest(tr);
}

HRESULT CMSVidBDATuner::put_Container(IMSVidGraphSegmentContainer *pCtl)	{
    if (!m_fInit) {
	 	return Error(IDS_OBJ_NO_INIT, __uuidof(CMSVidBDATuner), CO_E_NOTINITIALIZED);
    }
    try {
        if (!pCtl) {
            return Unload();
        }
        if (m_pContainer) {
			if (!m_pContainer.IsEqualObject(VWSegmentContainer(pCtl))) {
				return Error(IDS_OBJ_ALREADY_INIT, __uuidof(CMSVidBDATuner), CO_E_ALREADYINITIALIZED);
			} else {
				return NO_ERROR;
			}
        }
        // DON'T addref the container.  we're guaranteed nested lifetimes
        // and an addref creates circular refcounts so we never unload.
        m_pContainer.p = pCtl;
        m_pGraph = m_pContainer.GetGraph();

        if (!m_pCurrentTR) {
            // if we don't have a tune request we can't tell what NP we need.
		 	return Error(IDS_NO_NP, __uuidof(CMSVidBDATuner), E_FAIL);
        }
		// bring in the right network provider
        if (!m_pSystemEnum) {
            m_pSystemEnum = PQCreateDevEnum(CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER);
        }
        DSDevices pnpenum(m_pSystemEnum, KSCATEGORY_BDA_NETWORK_PROVIDER);
		if (!pnpenum) {
		    TRACELM(TRACE_ERROR, "CMSVidBDATuner::put_Container() can't create network provider category enumerator");
		 	return Error(IDS_NO_NP_CAT, __uuidof(CMSVidBDATuner), E_FAIL);
		}
        DSDevices::iterator i = pnpenum.begin();
        DSFilter np;
        for (;i != pnpenum.end(); ++i) {
			np = m_pGraph.AddMoniker(*i);
			if (!np) {
                continue;
			}
            PQTuner pt(np);
            if (pt) {
                HRESULT hr = pt->put_TuningSpace(m_pCurrentTR.TuningSpace());
                if (SUCCEEDED(hr)) {
                    hr = pt->put_TuneRequest(m_pCurrentTR);
                    if (SUCCEEDED(hr)) {
                        break;
                    }
                }
            }
            bool rc = m_pGraph.RemoveFilter(np);
            if (!rc) {
                return E_UNEXPECTED;
            }
        }
        if (i == pnpenum.end()) {
		    TRACELM(TRACE_ERROR, "CMSVidBDATuner::put_Container() can't load network provider");
		 	return Error(IDS_NO_NP, __uuidof(CMSVidBDATuner), E_FAIL);
        }
        _ASSERT(!!np);
		m_Filters.push_back(np);
		m_iNetworkProvider = m_Filters.size() - 1;
        TRACELM(TRACE_DETAIL, "CMSVidBDATuner::put_Container() attempting to load tuners from KSCATEGORY_BDA_NETWORK_TUNER");
        HRESULT hr = LoadTunerSection(np, KSCATEGORY_BDA_NETWORK_TUNER);
        if (FAILED(hr)) {
            TRACELM(TRACE_DETAIL, "CMSVidBDATuner::put_Container() attempting to load tuners from KSCATEGORY_BDA_RECEIVER_COMPONENT");
            hr = LoadTunerSection(np, KSCATEGORY_BDA_RECEIVER_COMPONENT);
            if (FAILED(hr)) {
                m_Filters.clear();
                m_iNetworkProvider = -1;
                return hr;
            }
        }
        hr = BroadcastAdvise();
        if (FAILED(hr)) {
            TRACELM(TRACE_ERROR, "CMSVidTVTuner::put_Container() can't advise for broadcast events");
            return E_UNEXPECTED;
        }
		return NOERROR;
    } catch (ComException &e) {
        return e;
    } catch(...) {
        return E_UNEXPECTED;
    }
	return NOERROR;
}

HRESULT CMSVidBDATuner::LoadTunerSection(DSFilter& np, const GUID& kscategory) {
        TRACELM(TRACE_DETAIL, "CMSVidBDATuner::LoadTunerSection()");
        DSFilter tuner;
		DSFilterList added;
        DSDevices ptunerenum(m_pSystemEnum, kscategory);
        DSDevices::iterator i = ptunerenum.begin();
        for (; i != ptunerenum.end(); ++i) {
			tuner = m_pGraph.AddMoniker(*i);
			if (!tuner) {
				continue;
			}
			// connect np to decode
			HRESULT hr = m_pGraph.Connect(np, tuner, added);
            if (FAILED(hr)) {
                bool rc = m_pGraph.RemoveFilter(tuner);
                if (!rc) {
                    return E_UNEXPECTED;
                }
                continue;
            }
			m_Filters.insert(m_Filters.end(), added.begin(), added.end());
			added.clear();

			// bring in the all right tifs
			DSDevices ptife(m_pSystemEnum, KSCATEGORY_BDA_TRANSPORT_INFORMATION);
            DSDevices::iterator itif = ptife.begin();
            DSFilter tif;
            int cTIFsAdded = 0;
            for (;itif != ptife.end(); ++itif) {
			    tif = m_pGraph.AddMoniker(*itif);
			    if (!tif) {
                    continue;
			    }
			    // connect np to tif
			    hr = m_pGraph.Connect(np, tif, added);
			    if (FAILED(hr)) {
        		    TRACELSM(TRACE_ERROR, (dbgDump << "CMSVidBDATuner::LoadTunerSection() can't connect network provider to transport information filter, trying next tif " << hr), "");
                    bool rc = m_pGraph.RemoveFilter(tif);
                    if (!rc) {
                        return E_UNEXPECTED;
                    }
                } else {
                    ++cTIFsAdded;
			        m_Filters.push_back(tif);
			        m_iTIF = m_Filters.size() - 1;
			        m_Filters.insert(m_Filters.end(), added.begin(), added.end());
			        added.clear();
                }
            }
            if (cTIFsAdded) {
                break;
            }
            // no tifs found for this "tuner", try the next one
            bool rc = m_pGraph.RemoveFilter(tuner);
            if (!rc) {
                return E_UNEXPECTED;
            }
        }
        if ( i == ptunerenum.end()) {
		    TRACELM(TRACE_ERROR, "CMSVidBDATuner::LoadTunerSection() can't connect network provider to any transport information filters.");
		 	return Error(IDS_CANT_CONNECT_NP_TIF, __uuidof(CMSVidBDATuner), E_FAIL);
        }

		m_Filters.push_back(tuner);
		m_iTuner = m_Filters.size() - 1;
        return NOERROR;
}

HRESULT CMSVidBDATuner::Fire(GUID gEventID) {
	TRACELM(TRACE_DETAIL, "CMSVidBDATuner::Fire()");
    if (gEventID == EVENTID_TuningChanged) {
        Fire_OnTuneChanged(this);
    }
    return NOERROR;
}



#endif //TUNING_MODEL_ONLY

// end of file - MSVidBDATuner.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\closedcaptioning.h ===
//==========================================================================;
// MSVidClosedCaptioning.h : Declaration of the CMSVidClosedCaptioning
// copyright (c) Microsoft Corp. 1998-1999.
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef __MSVidClosedCaptioning_H_
#define __MSVidClosedCaptioning_H_

#include <algorithm>
#include <tchar.h>
#include "segimpl.h"
#include "CC2impl.h"
#include <objectwithsiteimplsec.h>

#include "seg.h"

typedef CComQIPtr<ITuner> PQMSVidClosedCaptioning;

/////////////////////////////////////////////////////////////////////////////
// CMSVidClosedCaptioning
class ATL_NO_VTABLE __declspec(uuid("7F9CB14D-48E4-43b6-9346-1AEBC39C64D3")) CClosedCaptioning : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CClosedCaptioning, &__uuidof(CClosedCaptioning)>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CClosedCaptioning>,
    public IObjectWithSiteImplSec<CClosedCaptioning>,
	public IMSVidGraphSegmentImpl<CClosedCaptioning, MSVidSEG_XFORM, &GUID_NULL>,
    public IMSVidClosedCaptioningImpl2<CClosedCaptioning, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidClosedCaptioning2>
{
public:

	typedef IMSVidClosedCaptioningImpl2<CClosedCaptioning, &LIBID_MSVidCtlLib, &GUID_NULL, IMSVidClosedCaptioning2> ccimplbase;
    CClosedCaptioning() : m_iL21(-1) {
	}

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_CLOSEDCAPTIONING_PROGID, 
						   IDS_REG_CLOSEDCAPTIONING_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CClosedCaptioning));

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CClosedCaptioning)
	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
	COM_INTERFACE_ENTRY(IMSVidClosedCaptioning)
    COM_INTERFACE_ENTRY(IMSVidClosedCaptioning2)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IMSVidFeature)
	COM_INTERFACE_ENTRY(IMSVidDevice)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IPersist)
END_COM_MAP()

	BEGIN_CATEGORY_MAP(CClosedCaptioning)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

BEGIN_CONNECTION_POINT_MAP(CClosedCaptioning)
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
    int m_iL21;

    HRESULT Unload(void) {
        IMSVidGraphSegmentImpl<CClosedCaptioning, MSVidSEG_XFORM, &GUID_NULL>::Unload();
        m_iL21 = -1;
		return NOERROR;
	}

	HRESULT SetFilterState() {
		if (m_iL21 < 0) {
			return NOERROR;
		} 
		PQLine21Decoder pl21(m_Filters[m_iL21]);
		if (!pl21) {
			return NOERROR;
		}

        return pl21->SetServiceState(m_fCCEnable ? AM_L21_CCSTATE_On : AM_L21_CCSTATE_Off);
	}
// IMSVidGraphSegment
    STDMETHOD(Build)() {
        return NOERROR;
    }

    STDMETHOD(PreRun)() {
        return NOERROR;
    }

    STDMETHOD(Decompose)(){
        // The Line21 Decoder was not being disconnected from the vmr
        // This code disconnects all of the filters in this segment
	if(m_pGraph){
		for (DSFilterList::iterator i = m_Filters.begin(); i != m_Filters.end(); ++i) {
        		m_pGraph.DisconnectFilter(*i, false, false);
    		}
	}
	return S_OK;
    }

    STDMETHOD(PostRun)() {
        return SetFilterState();
    }

	STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pCtl)
	{
        if (!m_fInit) {
            return CO_E_NOTINITIALIZED;
        }
        try {
            if (!pCtl) {
                return Unload();
            }
            if (m_pContainer) {
				if (!m_pContainer.IsEqualObject(VWSegmentContainer(pCtl))) {
					return Error(IDS_OBJ_ALREADY_INIT, __uuidof(IMSVidClosedCaptioning2), CO_E_ALREADYINITIALIZED);
				} else {
					return NO_ERROR;
				}
            }
            // DON'T addref the container.  we're guaranteed nested lifetimes
            // and an addref creates circular refcounts so we never unload.
            m_pContainer.p = pCtl;
            m_pGraph = m_pContainer.GetGraph();

			// bring in the right network provider
			PQLine21Decoder l21(CLSID_Line21Decoder2, NULL, CLSCTX_INPROC_SERVER);
			if (!l21) {
		        TRACELM(TRACE_ERROR, "CMSVidClosedCaptioning::put_Container() can't load line 21 decoder");
				return E_FAIL;
			}
			DSFilter f(l21);
			if (!f) {
				return E_UNEXPECTED;
			}
			CString csName(_T("Line 21 Decoder"));
			HRESULT hr = m_pGraph.AddFilter(f, csName);
			if (FAILED(hr)) {
				return hr;
			}
			m_Filters.push_back(f);
			m_iL21 = m_Filters.size() - 1;
			return NOERROR;
        } catch (ComException &e) {
            return e;
        } catch(...) {
            return E_UNEXPECTED;
        }
		return NOERROR;
	}

    STDMETHOD(put_Enable)(VARIANT_BOOL fEnable) {
        HRESULT hr = ccimplbase::put_Enable(fEnable);
		if (FAILED(hr)) {
			return hr;
		}
		return SetFilterState();
    }

    // IMSVidDevice
	STDMETHOD(get_Name)(BSTR * Name)
	{
        if (!m_fInit) {
            return CO_E_NOTINITIALIZED;
        }
        try {
            return GetName(((m_iL21 > -1) ? (m_Filters[m_iL21]) : DSFilter()), m_pDev, CComBSTR(_T("Line 21 Decoder"))).CopyTo(Name);
        } catch(...) {
            return E_POINTER;
        }
	}
    STDMETHOD(put_Service)(MSVidCCService ccServ) {
		if (m_iL21 < 0) {
			return Error(IDS_INVALID_STATE, __uuidof(IMSVidClosedCaptioning2), CO_E_NOTINITIALIZED);
		}
        
		PQLine21Decoder pl21(m_Filters[m_iL21]);
		if (!pl21) {
			return E_UNEXPECTED;
		}

        AM_LINE21_CCSERVICE amServ = static_cast<AM_LINE21_CCSERVICE>(ccServ);
        HRESULT hr = pl21->SetCurrentService(amServ);
        if(FAILED(hr)){
            return hr;
        }
        
        return S_OK;
    }

    STDMETHOD(get_Service)(MSVidCCService *ccServ) {
        if (!ccServ) {
            return E_POINTER;
        }

		PQLine21Decoder pl21(m_Filters[m_iL21]);
		if (!pl21) {
			return E_UNEXPECTED;
		}

        AM_LINE21_CCSERVICE amServ;
        HRESULT hr = pl21->GetCurrentService(&amServ);
        if(FAILED(hr)){
            return hr;
        }
        *ccServ = static_cast<MSVidCCService>(amServ);
        
        return S_OK;
    }


};

STDMETHODIMP CClosedCaptioning::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSVidClosedCaptioning2
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

#endif //__MSVidClosedCaptioning_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\channeltunerequest.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// ChannelTuneRequest.cpp : Implementation of CChannelTuneRequest
// Copyright (c) Microsoft Corporation 1999.

#include "stdafx.h"
#include "Tuner.h"
#include "ChannelTuneRequest.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_ChannelTuneRequest, CChannelTuneRequest)

/////////////////////////////////////////////////////////////////////////////
// CChannelTuneRequest

STDMETHODIMP CChannelTuneRequest::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IChannelTuneRequest
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\channeltunerequest.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ChannelTuneRequest.h : Declaration of the CChannelTuneRequest
// Copyright (c) Microsoft Corporation 1999.

#ifndef __CHANNELTUNEREQUEST_H_
#define __CHANNELTUNEREQUEST_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "channeltunerequestimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CChannelTuneRequest
class ATL_NO_VTABLE CChannelTuneRequest : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public IChannelTuneRequestImpl<CChannelTuneRequest>,
    public IObjectWithSiteImplSec<CChannelTuneRequest>,
	public CComCoClass<CChannelTuneRequest, &CLSID_ChannelTuneRequest>,
	public ISupportErrorInfo
{
public:

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_CHANNELTUNEREQUEST_PROGID, 
						   IDS_REG_CHANNELTUNEREQUEST_DESC,
						   LIBID_TunerLib,
						   CLSID_ChannelTuneRequest, tvBoth);

BEGIN_COM_MAP(CChannelTuneRequest)
	COM_INTERFACE_ENTRY(IChannelTuneRequest)
	COM_INTERFACE_ENTRY(ITuneRequest)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CChannelTuneRequest)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    typedef IChannelTuneRequestImpl<CChannelTuneRequest> basetype;
    BEGIN_PROP_MAP(CChannelTuneRequest)
        CHAIN_PROP_MAP(basetype)
    END_PROP_MAP()


};

#endif //__CHANNELTUNEREQUEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\bdatuner.h ===
//==========================================================================;
// MSVidBDATuner.h : Declaration of the CMSVidBDATuner
// copyright (c) Microsoft Corp. 1998-1999.
/////////////////////////////////////////////////////////////////////////////

#pragma once

#ifndef __MSVidBDATUNER_H_
#define __MSVidBDATUNER_H_

#include <algorithm>
#include <tchar.h>
#include <bdamedia.h>
#include <objectwithsiteimplsec.h>
#include "bcasteventimpl.h"
#include "segimpl.h"
#include "tunerimpl.h"

#include "seg.h"

typedef CComQIPtr<ITuner> PQTuner;

/////////////////////////////////////////////////////////////////////////////
// CMSVidBDATuner
class ATL_NO_VTABLE __declspec(uuid("A2E3074E-6C3D-11d3-B653-00C04F79498E")) CMSVidBDATuner : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMSVidBDATuner, &__uuidof(CMSVidBDATuner)>,
	public ISupportErrorInfo,
	public IConnectionPointContainerImpl<CMSVidBDATuner>,
    public CProxy_Tuner<CMSVidBDATuner>,
    public IBroadcastEventImpl<CMSVidBDATuner>,
    public IObjectWithSiteImplSec<CMSVidBDATuner>,
	public IMSVidGraphSegmentImpl<CMSVidBDATuner, MSVidSEG_SOURCE, &KSCATEGORY_BDA_RECEIVER_COMPONENT>,
    public IMSVidTunerImpl<CMSVidBDATuner, &LIBID_MSVidCtlLib, &KSCATEGORY_BDA_RECEIVER_COMPONENT, IMSVidTuner>,
    public IProvideClassInfo2Impl<&CLSID_MSVidBDATunerDevice, &IID_IMSVidTunerEvent, &LIBID_MSVidCtlLib>
{
public:
    CMSVidBDATuner() : m_iNetworkProvider(-1), m_iTuner(-1), m_iTIF(-1)  {
	}

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
						   IDS_REG_BDATUNER_PROGID, 
						   IDS_REG_BDATUNER_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CMSVidBDATuner));

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSVidBDATuner)
	COM_INTERFACE_ENTRY(IMSVidGraphSegment)
	COM_INTERFACE_ENTRY(IMSVidTuner)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IMSVidDevice)
	COM_INTERFACE_ENTRY(IMSVidInputDevice)
	COM_INTERFACE_ENTRY(IMSVidVideoInputDevice)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(IBroadcastEvent)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY(IConnectionPointContainer)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IProvideClassInfo2)
	COM_INTERFACE_ENTRY(IProvideClassInfo)
END_COM_MAP()

	BEGIN_CATEGORY_MAP(CMSVidBDATuner)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

BEGIN_CONNECTION_POINT_MAP(CMSVidBDATuner)
	CONNECTION_POINT_ENTRY(IID_IMSVidTunerEvent)    
END_CONNECTION_POINT_MAP()


// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

public:
    PQCreateDevEnum m_pSystemEnum;
    int m_iNetworkProvider;
    int m_iTuner;
    int m_iTIF;

	virtual HRESULT DoTune(TNTuneRequest &ctr);
	virtual HRESULT UpdateTR(TNTuneRequest& pTR);

    HRESULT Unload(void);

    HRESULT LoadTunerSection(DSFilter& np, const GUID& kscategory);

// IMSVidGraphSegment
	STDMETHOD(put_Init)(IUnknown *pDeviceMoniker)
	{
        if (!pDeviceMoniker) {
            return E_POINTER;
        }

        HRESULT hr = IMSVidGraphSegmentImpl<CMSVidBDATuner, MSVidSEG_SOURCE, &KSCATEGORY_BDA_RECEIVER_COMPONENT>::put_Init(pDeviceMoniker);
        if (FAILED(hr)) {
            return hr;
        }
        if (!m_pDev) {
            m_fInit = false;
            return E_NOINTERFACE;
        }
		return NOERROR;
	}
    STDMETHOD(Build)() {
        // undone: should we tune here?
        return NOERROR;
    }

    STDMETHOD(PreRun)() {
		if (m_pCurrentTR) {
			return DoTune(m_pCurrentTR);
		}
		// undone: do any np initialization.

        return NOERROR;
    }

	STDMETHOD(put_Container)(IMSVidGraphSegmentContainer *pCtl);

    // IMSVidDevice
	STDMETHOD(get_Name)(BSTR * Name)
	{
        if (!m_fInit) {
	 	    return Error(IDS_OBJ_NO_INIT, __uuidof(CMSVidBDATuner), CO_E_NOTINITIALIZED);
        }
        try {
            return GetName(((m_iNetworkProvider > -1) ? (m_Filters[m_iNetworkProvider]) : DSFilter()), m_pDev, CComBSTR(_T("BDA NetworkProvider"))).CopyTo(Name);
            return NOERROR;
        } catch(...) {
            return E_POINTER;
        }
	}
    // IBroadcastEvent
    STDMETHOD(Fire)(GUID gEventID);
};
#endif //__MSVidBDATUNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\component.h ===
/////////////////////////////////////////////////////////////////////////////////////
// Component.h : Declaration of the CComponent
// Copyright (c) Microsoft Corporation 1999.

#ifndef __COMPONENT_H_
#define __COMPONENT_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "componentimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CComponent
class ATL_NO_VTABLE CComponent : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CComponent, &CLSID_Component>,
    public IObjectWithSiteImplSec<CComponent>,
	public IComponentImpl<CComponent>
{
public:
    CComponent() : m_bRequiresSave(false)
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_COMPONENT_PROGID, 
						   IDS_REG_COMPONENT_DESC,
						   LIBID_TunerLib,
						   CLSID_Component, tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CComponent)
	COM_INTERFACE_ENTRY(IComponent)
    COM_INTERFACE_ENTRY(IObjectWithSite)
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CComponent)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()


public:

    bool m_bRequiresSave;
    BEGIN_PROP_MAP(CComponent)
        CHAIN_PROP_MAP(IComponentImpl<CComponent>)
    END_PROPERTY_MAP()


};

typedef CComQIPtr<IComponent> PQComponent;

#endif //__COMPONENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\components.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// Components.cpp : Implementation of CComponents
// Copyright (c) Microsoft Corporation 1999.

#include "stdafx.h"
#include <Tuner.h>
#include "Components.h"
#include "MPEG2Component.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_Component, CComponent)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MPEG2Component, CMPEG2Component)

/////////////////////////////////////////////////////////////////////////////
// CComponents


STDMETHODIMP CComponents::get_Count(long *pVal)
{
    try {
        if (!pVal) {
            return E_POINTER;
        }
		ATL_LOCK();
	    *pVal = m_Components.size();
    } catch (...) {
        return E_POINTER;
    }

	return NOERROR;
}

STDMETHODIMP CComponents::get__NewEnum(IEnumVARIANT **ppVal)
{
    try {
        if (ppVal == NULL)
	        return E_POINTER;

        ComponentEnumerator_t* p;

        *ppVal = NULL;

        HRESULT hr = ComponentEnumerator_t::CreateInstance(&p);
        if (FAILED(hr) || !p) {
            return E_OUTOFMEMORY;
        }
		ATL_LOCK();
	    hr = p->Init(GetUnknown(), m_Components);
        if (FAILED(hr)) {
            delete p;
            return hr;
        }
		hr = p->QueryInterface(__uuidof(IEnumVARIANT), (void**)ppVal);
        if (FAILED(hr)) {
            delete p;
            return hr;
        }
        return NOERROR;
    } catch(...) {
        return E_POINTER;
    }
}

STDMETHODIMP CComponents::EnumComponents(IEnumComponents** pVal)
{
    ComponentBaseEnumerator_t *pe = NULL;
    ComponentBaseEnumerator_t::CreateInstance(&pe);
    pe->Init(static_cast<IComponents*>(this), m_Components);
    HRESULT hr = pe->QueryInterface(pVal);
    if (FAILED(hr)) {
        delete pe;
    }
	return hr;
}

STDMETHODIMP CComponents::get_Item(VARIANT varIndex, IComponent **ppComponent)
{
    try {
        if (!ppComponent) {
            return E_POINTER;
        }

	    int idx;
	    CComVariant vidx;
		if (FAILED(vidx.ChangeType(VT_I4, &varIndex))) {
            return E_INVALIDARG;
        }
		idx = vidx.lVal;
		if (idx >= m_Components.size()) {
			return E_INVALIDARG;
		}
	    *ppComponent = *(m_Components.begin() + idx);
        (*ppComponent)->AddRef();
    } catch (...) {
        return E_POINTER;
    }

	return NOERROR;
}

STDMETHODIMP CComponents::Add(IComponent *pComponent, VARIANT *pNewIndex)
{
    try {
        if (!pComponent) {
            return E_POINTER;
        }
        PQComponent p(pComponent);
        m_Components.push_back(p);
        if (pNewIndex) {
            VariantClear(pNewIndex);
            pNewIndex->vt = VT_UI4;
            pNewIndex->ulVal = m_Components.end() - m_Components.begin() - 1;
        }
    } catch (...) {
        return E_POINTER;
    }

	return NOERROR;
}

STDMETHODIMP CComponents::Remove(VARIANT varIndex)
{
    try {
	    int idx;
	    CComVariant vidx;
		if (FAILED(vidx.ChangeType(VT_I4, &varIndex))) {
            return E_INVALIDARG;
        }
		idx = vidx.lVal;
		if (idx >= m_Components.size()) {
			return E_INVALIDARG;
		}
	    m_Components.erase(m_Components.begin() + idx);
    } catch (...) {
        return E_UNEXPECTED;
    }

	return NOERROR;
}

STDMETHODIMP CComponents::Clone(IComponents **ppNewList)
{
    try {
		if (!ppNewList) {
			return E_POINTER;
		}
		CComponents* pCs = new CComObject<CComponents>;
		if (!pCs) {
			return E_OUTOFMEMORY;
		}
		ComponentList::iterator i;
		for (i = m_Components.begin(); i != m_Components.end(); ++i) {
			PQComponent p;
			HRESULT hr = (*i)->Clone(&p);
			if (FAILED(hr)) {
                pCs->Release();
				return hr;
			}
			pCs->m_Components.push_back(p);			
		}
		pCs->AddRef();
		*ppNewList = pCs;
		return NOERROR;
    } catch (...) {
        return E_UNEXPECTED;
    }

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\cmseventbinder.h ===
// CMSEventBinder.h : Declaration of the CMSEventBinder

#ifndef __MSEVENTBINDER_H_
#define __MSEVENTBINDER_H_

#include <map>
#include <Mshtml.h>
#include <activscp.h>
#include <Atlctl.h>
#include <Exdisp.h>
#include <objectwithsiteimplsec.h>
#include "segimpl.h"
#include "seg.h"
#include "resource.h"       // main symbols
#include "mslcid.h"

typedef CComQIPtr<IActiveScriptSite> PQIASSite;
typedef CComQIPtr<IActiveScript> PQIAScript;
/////////////////////////////////////////////////////
    
    
class __declspec(uuid("FCBF24F7-FB97-4fa3-B57E-97BCB5AF1D26")) ATL_NO_VTABLE CMSEventHandlerBase:
    public CComObjectRootEx<CComSingleThreadModel>,
    public IObjectWithSiteImplSec<CMSEventHandlerBase>,
    public IDispatchImpl<IDispatch, &IID_IDispatch>
    {
        BEGIN_COM_MAP(CMSEventHandlerBase)
            COM_INTERFACE_ENTRY(IDispatch)    
            COM_INTERFACE_ENTRY(IObjectWithSite)
        END_COM_MAP()
protected:
        CMSEventHandlerBase(){}

        // Cookie for canceling the advise
        DWORD cancelCookie;
public:
        virtual ~CMSEventHandlerBase(){
            if(cancelCookie!=-1){
                Cancel(cancelCookie);
            }
        }
        // Id of the handler function
        DISPID ID_handler;
        
        // The DISPID of the event 
        DISPID ID_event;

        // GUID of the Interface whose event we want to know about
        GUID gEventInf;
        
        // Connection Point that the advise is on
        CComQIPtr<IConnectionPoint> cancelPoint;
        
        // IDispatch where the handler function is from
        CComQIPtr<IDispatch> pDScript;

        // Override invoke to throw events on up
        STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
            LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
            EXCEPINFO* pexcepinfo, UINT* puArgErr){
            if(dispidMember == ID_event) {
                return pDScript->Invoke(ID_handler, riid, 
                    lcid, wFlags, pdispparams, pvarResult, 
                    pexcepinfo, puArgErr);
            } else {
                return E_NOTIMPL;
            }
        }

        // Unadvise
        STDMETHOD(Cancel)(DWORD dwCancel){
            HRESULT hr = E_INVALIDARG;
            if(dwCancel == cancelCookie && cancelCookie != -1){
                hr = cancelPoint->Unadvise(dwCancel);
                if (SUCCEEDED(hr)){
                    cancelPoint.Release();
                    pDScript.Release();
                    cancelCookie = -1;
                }
            }
            return hr;
        }
        DWORD getCookie(){
            return cancelCookie;
        }
        STDMETHOD(setCookie)(DWORD newValue){
            HRESULT hr = E_FAIL;
            if(cancelCookie==-1){
                cancelCookie = newValue;
                hr = S_OK;
            }
            return hr;
        }
    };
    
class __declspec(uuid("C092B145-B318-41a7-B890-C77C5DA41CFD")) CMSEventHandler : 
    public CComObject<CMSEventHandlerBase>
    {
    public:
            
        typedef CComObject<CMSEventHandlerBase> base;
        CMSEventHandler(DISPID handler, DISPID event, GUID gInf, IDispatch* IDispSite){
            ID_handler = handler;
            ID_event = event;
            gEventInf = gInf;
            pDScript = IDispSite;
            cancelCookie = -1;
        
        }
        STDMETHOD(QueryInterface) (REFIID iid, void **pp) {
            try {
                if (iid == gEventInf) {
                    CComQIPtr<IDispatch> pdispRet(static_cast<IDispatch *>(this));
                    pdispRet.CopyTo(pp);
                    pdispRet.Release();
                    return NOERROR;
                }
                return base::QueryInterface(iid, pp);
            } catch(...) {
                return E_NOINTERFACE;
            }
        }
        virtual ~CMSEventHandler() {            
            if(cancelCookie!=-1){
                Cancel(cancelCookie);
            }
        }
        
        
    };
    
    typedef std::map<DWORD, CComQIPtr<IDispatch> > CancelMap;

/////////////////////////////////////////////////////////////////////////////
// CMSEventBinder
class ATL_NO_VTABLE __declspec(uuid("577FAA18-4518-445E-8F70-1473F8CF4BA4")) CMSEventBinder : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CMSEventBinder, &__uuidof(CMSEventBinder)>,
    public IObjectWithSiteImplSec<CMSEventBinder>,
    public ISupportErrorInfo,
    public IObjectSafetyImpl<CMSEventBinder, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>,
    public IProvideClassInfo2Impl<&CLSID_MSEventBinder, &IID_IMSEventBinder, &LIBID_MSVidCtlLib>,
	public IDispatchImpl<IMSEventBinder, &IID_IMSEventBinder, &LIBID_MSVidCtlLib>
{
public:
    CMSEventBinder(){}	
    virtual ~CMSEventBinder(){
        CleanupConnection();
    }

REGISTER_AUTOMATION_OBJECT(IDS_PROJNAME, 
                           IDS_REG_MSEVENTBINDER_PROGID,
						   IDS_REG_MSEVENTBINDER_DESC,
						   LIBID_MSVidCtlLib,
						   __uuidof(CMSEventBinder));

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMSEventBinder)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IMSEventBinder)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
	COM_INTERFACE_ENTRY(IProvideClassInfo2) 
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP()

// IMSEventBinder
public:
    // ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);
    STDMETHOD(Bind)(LPDISPATCH pEventObject, BSTR EventName, BSTR EventHandler, LONG *CancelCookie);
    STDMETHOD(Unbind)(DWORD CancelCookie);

protected:
    HRESULT CleanupConnection();

private:
    CancelMap m_CancelMap; // map of cookies to CMSEventHandlers
};


#endif //__MSEVENTBINDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\cmseventbinder.cpp ===
// CMSEventBinder.cpp : Implementation of CMSEventBinder
#include "stdafx.h"
#include "MSVidCtl.h"
#include "CMSEventBinder.h"
#include <dispex.h>

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSEventBinder, CMSEventBinder)

/////////////////////////////////////////////////////////////////////////////
// CMSEventBinder

/**********************************************************************
// Function: CMSEventBinder                           
/**********************************************************************/
STDMETHODIMP CMSEventBinder::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMSEventBinder,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}
/**********************************************************************/
// Function: CleanupConnection
// Description: Unadvises if necessary
/**********************************************************************/
HRESULT CMSEventBinder::CleanupConnection()
{
    HRESULT hr = E_FAIL;
    try{
        // While the map is not empty
        while(!m_CancelMap.empty()){
            // See if it is bound to an event or an empty map
            CMSEventHandler* p(static_cast<CMSEventHandler *>((*m_CancelMap.begin()).second.p));
            // If it is not an empty map cancel the eventbinding
            if (p) {
                p->Cancel((*m_CancelMap.begin()).first);
            }
            // Delete the mapping
            m_CancelMap.erase(m_CancelMap.begin());
        }
        hr = S_OK;
    }
    catch(...){
        return Error(IDS_CANT_RELEASE_MAP, __uuidof(IMSEventBinder), E_FAIL);
    }

    return hr;
}/* end of function CleanupConnection */
/**********************************************************************/
// Function: Unbind
// Description: Unbinds an event on an object
/**********************************************************************/
STDMETHODIMP CMSEventBinder::Unbind(DWORD CancelCookie){
    HRESULT hr = E_FAIL;
    try{
        CMSEventHandler* p_Event(static_cast<CMSEventHandler *>((m_CancelMap[CancelCookie]).p));
        if(!p_Event){
            return Error(IDS_CANT_UNBIND, __uuidof(IMSEventBinder), E_FAIL);
        }
        hr = p_Event->Cancel(CancelCookie);
        if(SUCCEEDED(hr)){
            if(!m_CancelMap.erase(CancelCookie)){
                return Error(IDS_CANT_UNBIND, __uuidof(IMSEventBinder), E_FAIL);
            }   
        }
    }catch(...){
        return Error(IDS_CANT_UNBIND, __uuidof(IMSEventBinder), E_FAIL);
    }
    return hr;
}
/**********************************************************************/
// Function: Bind
// Description: Binds a function to an event on an object
/**********************************************************************/
STDMETHODIMP CMSEventBinder::Bind(LPDISPATCH inPEventObject, BSTR EventName, BSTR EventHandler, LONG *CancelID)
{
    try{
        HRESULT hr = E_FAIL;

        // query eventobject to see if its the dhtml object wrapper rather than the real object
        // if so, get its "object" property automatically here to save foolish script programmers from hard to find errors.
        CComQIPtr<IDispatch> pEventObject(inPEventObject);
        CComQIPtr<IHTMLObjectElement> IHOEle(inPEventObject);
        if(IHOEle){
            pEventObject.Release();
            hr = IHOEle->get_object(&pEventObject);
            if(FAILED(hr)){
                return Error(IDS_EVENT_OBJECT, __uuidof(IMSEventBinder), E_FAIL);
            }
        }
        
        // Get client site
        CComQIPtr<IOleClientSite> pSite(m_pSite);
        if (!pSite) {
            return Error(IDS_EVENT_HTM_SITE, __uuidof(IMSEventBinder), E_FAIL);
        }
        
        // Get container
        CComQIPtr<IOleContainer> pContainer;
        hr = pSite->GetContainer(&pContainer);
        if(FAILED(hr)){
            return Error(IDS_EVENT_HTM_SITE, __uuidof(IMSEventBinder), E_FAIL);
        }

        // Get the IHTMLDocumet2 for the container/site
        CComQIPtr<IHTMLDocument2> IHDoc(pContainer);
        if (!IHDoc) {
            return Error(IDS_EVENT_HTM_SITE, __uuidof(IMSEventBinder), E_FAIL);
        }
        
        // Get the script which is some object that is not the script engine
        CComQIPtr<IDispatch> IDispSite;
        hr = IHDoc->get_Script(&IDispSite);
        if(FAILED(hr)){
            return Error(IDS_EVENT_HTM_SITE, __uuidof(IMSEventBinder), E_FAIL);
        }
        
        // Get the function that will be the event handler
        DISPID dispidScriptHandler = -1;
        hr = IDispSite->GetIDsOfNames(IID_NULL, &EventHandler, 1, LOCALE_SYSTEM_DEFAULT, &dispidScriptHandler);
        if(FAILED(hr)){
            return Error(IDS_EVENT_HTM_SITE, __uuidof(IMSEventBinder), E_FAIL);
        }
        
        // Get info about the object/interface on which the event exsists
        CComQIPtr<IProvideClassInfo2> IPCInfo(pEventObject);
        if(!IPCInfo){
            return Error(IDS_EVENT_OBJECT, __uuidof(IMSEventBinder), E_FAIL);
        }
        
        // Get the guid of the object/interface
        GUID gEventObject;
        hr = IPCInfo->GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID, &gEventObject);
        if(FAILED(hr)){
            return Error(IDS_EVENT_OBJECT, __uuidof(IMSEventBinder), E_FAIL);
        }
        
        // Get type info about the interface/object
        CComQIPtr<ITypeInfo> ITInfo;
        hr = IPCInfo->GetClassInfo(&ITInfo);
        if(FAILED(hr)){
            return Error(IDS_EVENT_OBJECT, __uuidof(IMSEventBinder), E_FAIL);
        }
        
        // Get the Type lib
        CComQIPtr<ITypeLib> ITLib(ITInfo);
        unsigned int uNit;
        hr = ITInfo->GetContainingTypeLib(&ITLib, &uNit);
        if(FAILED(hr)){
            return Error(IDS_EVENT_OBJECT, __uuidof(IMSEventBinder), E_FAIL);
        }
        
        ITInfo.Release();
        
        // Get info about the object/interface's base class
        hr = ITLib->GetTypeInfoOfGuid(gEventObject, &ITInfo);
        if(FAILED(hr)){
            return Error(IDS_EVENT_OBJECT, __uuidof(IMSEventBinder), E_FAIL);
        }
        
        // Get the ID of the event
        MEMBERID dispidEvent = 0;
        hr = ITInfo->GetIDsOfNames(&EventName, 1, &dispidEvent);
        if(FAILED(hr)){
            return Error(IDS_EVENT_OBJECT, __uuidof(IMSEventBinder), E_FAIL);
        }

        //Create and store the event Handler 
        CMSEventHandler* pH;
        pH = new CMSEventHandler(dispidScriptHandler, dispidEvent, gEventObject, IDispSite);
        if(!pH){
            return Error(IDS_CANT_GET_EVENTHANDLER, __uuidof(IMSEventBinder), E_FAIL);
        }

        // Get Connection Point Container
        CComQIPtr<IConnectionPointContainer> ICPCon(pEventObject);
        if(!ICPCon){
            delete pH;
            return Error(IDS_EVENT_OBJECT, __uuidof(IMSEventBinder), E_FAIL);
        }

        // Find the connection point
        CComQIPtr<IConnectionPoint> ICPo;
        hr = ICPCon->FindConnectionPoint(gEventObject, &ICPo);
        if(FAILED(hr)){
            delete pH;
            return Error(IDS_EVENT_OBJECT, __uuidof(IMSEventBinder), E_FAIL);
        }

        // Set the event
        DWORD tempCookie;
        PQDispatch pdisp(pH);  // we have now addref'd and assoc'd ph with a smart pointer, no more deletes necessary
        hr = ICPo->Advise(pdisp, &tempCookie);
        pH->setCookie(tempCookie);
        if(FAILED(hr)){
            return Error(IDS_CANT_SET_ADVISE, __uuidof(IMSEventBinder), E_FAIL);
        }

        // Store all of the needed info
        pH->cancelPoint = ICPo;
        *CancelID = pH->getCookie();
        m_CancelMap[pH->getCookie()] = pH;
    }
    catch(HRESULT){
        return Error(IDS_CANT_SET_ADVISE, __uuidof(IMSEventBinder), E_FAIL);
    }
    catch(...){
        return Error(IDS_CANT_SET_ADVISE, __uuidof(IMSEventBinder), E_UNEXPECTED);
    }
    // call used to leave a funtion and "return" the value that is the paramater to the calling function
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\components.h ===
/////////////////////////////////////////////////////////////////////////////////////
// Components.h : Declaration of the CComponents
// Copyright (c) Microsoft Corporation 1999.

#ifndef __COMPONENTS_H_
#define __COMPONENTS_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "component.h"

typedef std::vector<PQComponent, stl_smart_ptr_allocator<PQComponent> > ComponentList;

/////////////////////////////////////////////////////////////////////////////
// CComponent
class ATL_NO_VTABLE CComponents : 
	public CComObjectRootEx<CComMultiThreadModel>,
    public IObjectWithSiteImplSec<CComponents>,
	public IDispatchImpl<IComponents, &IID_IComponents, &LIBID_TunerLib>
{
public:
	CComponents()
	{
	}

DECLARE_NOT_AGGREGATABLE(CComponents)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CComponents)
	COM_INTERFACE_ENTRY(IComponents)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP_WITH_FTM()
public:
    ComponentList m_Components;

// IComponents
public:
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ IEnumVARIANT* *pVal);
	STDMETHOD(EnumComponents)(/*[out, retval]*/ IEnumComponents** pVal);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_Item)(/*[in]*/ VARIANT varIndex, /*[out, retval]*/ IComponent **ppComponent);
    STDMETHOD(Add)(/*[in]*/ IComponent *pComponent, VARIANT *pNewIndex);
    STDMETHOD(Remove)(VARIANT varIndex);
    STDMETHOD(Clone)(IComponents **ppNewList);
};

typedef CComQIPtr<IComponents> PQComponents;

class CopyComponentToVARIANT {
public:
    static HRESULT copy(VARIANT *pv, IComponent** p) {
        VariantClear(pv);
        pv->vt = VT_UNKNOWN;
        pv->punkVal = *p;
        pv->punkVal->AddRef();
        return NOERROR;
    }
    static void init(VARIANT *v) { VariantInit(v); }
    static void destroy(VARIANT *v) { VariantClear(v); }
};

typedef CComObject<CComEnumOnSTL<IEnumVARIANT, &__uuidof(IEnumVARIANT), 
                                 VARIANT, 
                                 CopyComponentToVARIANT, 
                                 ComponentList, 
								 CComMultiThreadModel> > ComponentEnumerator_t;

typedef CComObject<CComEnumOnSTL<IEnumComponents, &__uuidof(IEnumComponents), 
                                 IComponent *, 
                                 _CopyInterface<IComponent>, 
                                 ComponentList, 
								 CComMultiThreadModel> > ComponentBaseEnumerator_t;


#endif //__COMPONENTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\componenttypes.cpp ===
/////////////////////////////////////////////////////////////////////////////////////
// ComponentTypes.cpp : Implementation of CComponentTypes
// Copyright (c) Microsoft Corporation 1999.

#include "stdafx.h"
#include "Tuner.h"
#include "ComponentTypes.h"
#include "ComponentType.h"
#include "LanguageComponentType.h"
#include "MPEG2ComponentType.h"
#include "ATSCComponentType.h"

DEFINE_EXTERN_OBJECT_ENTRY(CLSID_ComponentTypes, CComponentTypes)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_ComponentType, CComponentType)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_LanguageComponentType, CLanguageComponentType)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MPEG2ComponentType, CMPEG2ComponentType)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_ATSCComponentType, CATSCComponentType)

/////////////////////////////////////////////////////////////////////////////
// CComponentTypes
STDMETHODIMP CComponentTypes::Load(IPropertyBag2 *pBag2, IErrorLog *pErrLog) {
    try {
        ULONG count;
        HRESULT hr = pBag2->CountProperties(&count);
        if (FAILED(hr)) {
            return hr;
        }
		// undone: should this be on the heap not the stack?
        PROPBAG2 *props = reinterpret_cast<PROPBAG2 *>(_alloca(sizeof(PROPBAG2) * count));
        if (!props) {
            return E_OUTOFMEMORY;
        }
        ULONG readcount = 0;
        hr = pBag2->GetPropertyInfo(0, count, props, &readcount);
        if (FAILED(hr)) {
            return hr;
        }
        if (count != readcount) {
            return E_UNEXPECTED;
        }
        HRESULT *phr = reinterpret_cast<HRESULT *>(_alloca(sizeof(HRESULT) * readcount));
        if (!phr) {
            return E_OUTOFMEMORY;
        }
        VARIANT *pv = new VARIANT[readcount];
        if (!pv) {
            return E_OUTOFMEMORY;
        }
        // readcount is set from GetPropertyInfo
        // pv is an array of variants readcount in length
        memset(pv, 0, sizeof(VARIANT) * readcount);
        hr = pBag2->Read(readcount, props, pErrLog, pv, phr);
        if (FAILED(hr)) {
            delete[] pv;
            return hr;
        }
		ATL_LOCK();
        for (count = 0; count < readcount; ++count) {
            int idx = _wtoi(props[count].pstrName);
            switch(props[count].vt) {
            case VT_UNKNOWN:
                if (idx >= m_ComponentTypes.size()) {
                    m_ComponentTypes.reserve(idx + 1);
                    m_ComponentTypes.insert(m_ComponentTypes.end(), (idx - m_ComponentTypes.size()) + 1, PQComponentType());
                }
                m_ComponentTypes[idx] = pv[count].punkVal;
                break;
            case VT_DISPATCH:
                if (idx >= m_ComponentTypes.size()) {
                    m_ComponentTypes.reserve(idx + 1);
                    m_ComponentTypes.insert(m_ComponentTypes.end(), (idx - m_ComponentTypes.size()) + 1, PQComponentType());
                }
                m_ComponentTypes[idx] = pv[count].pdispVal;
                break;
            case VT_CLSID:
            case VT_BSTR:
                break; // ignore clsids
            default:
                _ASSERT(FALSE);
            }
            VariantClear(&pv[count]);
        }
        delete[] pv;
        return NOERROR;
    } catch (...) {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CComponentTypes::Save(IPropertyBag2 *pBag2, BOOL fClearDirty, BOOL fSaveAllProperties) {
    try {
        if (!m_bRequiresSave) {
            return NOERROR;
        }
        int propsize = sizeof(PROPBAG2) * m_ComponentTypes.size();
        PROPBAG2 *props = new PROPBAG2[m_ComponentTypes.size()];
        if (!props) {
            return E_OUTOFMEMORY;
        }
        // props points to memory _alloca'd propsize in length
        memset(props, 0, propsize);
        VARIANT *pv = new VARIANT[m_ComponentTypes.size()];
        if (!pv) {
            delete[] props;
            return E_OUTOFMEMORY;
        }
        int ctidx = 0;
        int propidx = 0;
        for (int i = 0; i < m_ComponentTypes.size(); ++i) {
            PQPersist pct(m_ComponentTypes[ctidx++]);
            if (!pct) continue;
            pv[i].vt = VT_UNKNOWN;
            pv[i].punkVal = pct;  // guaranteed nested lifetime(m_components isn't going away) thus no addref needed
            props[i].dwType = PROPBAG2_TYPE_OBJECT;
            props[i].vt = VT_UNKNOWN;
            HRESULT hr = pct->GetClassID(&(props[i].clsid));
            if (FAILED(hr)) {
                _ASSERT(false);
                --i; // reuse this slot and keep going
                continue;
            }
			USES_CONVERSION;
            const long idlen = sizeof(long) * 3 /* max digits per byte*/ + 1;
            props[i].pstrName = new OLECHAR[idlen + 1];
            _itow(i, props[i].pstrName, 10);
            ++propidx;
        }
        HRESULT hr = NOERROR; 
        hr = pBag2->Write(propidx, props, pv);
        if (SUCCEEDED(hr)) {
            m_bRequiresSave = false;
        }
        for (i = 0; i < propidx; ++i) {
            delete props[i].pstrName;
        }
        delete[] props;
        delete[] pv;
        return hr;
    } catch (...) {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CComponentTypes::get_Count(long *pVal)
{
    try {
        if (!pVal) {
            return E_POINTER;
        }
	    *pVal = m_ComponentTypes.size();
    } catch (...) {
        return E_POINTER;
    }

	return NOERROR;
}

STDMETHODIMP CComponentTypes::get__NewEnum(IEnumVARIANT** ppVal)
{
    try {
        if (ppVal == NULL)
	        return E_POINTER;

        ComponentTypeScriptEnumerator_t* p;

        *ppVal = NULL;

        HRESULT hr = ComponentTypeScriptEnumerator_t::CreateInstance(&p);
        if (FAILED(hr) || !p) {
            return E_OUTOFMEMORY;
        }
	    hr = p->Init(GetUnknown(), m_ComponentTypes);
        if (FAILED(hr)) {
            delete p;
            return hr;
        }
		hr = p->QueryInterface(__uuidof(IEnumVARIANT), (void**)ppVal);
        if (FAILED(hr)) {
            delete p;
            return hr;
        }
        return NOERROR;
    } catch(...) {
        return E_POINTER;
    }
}

STDMETHODIMP CComponentTypes::EnumComponentTypes(IEnumComponentTypes** pVal)
{
    ComponentTypeBaseEnumerator_t *pe = NULL;
    ComponentTypeBaseEnumerator_t::CreateInstance(&pe);
    pe->Init(static_cast<IComponentTypes*>(this), m_ComponentTypes);
    HRESULT hr = pe->QueryInterface(pVal);
    if (FAILED(hr)) {
        delete pe;
    }
	return hr;
}

STDMETHODIMP CComponentTypes::get_Item(VARIANT varIndex, IComponentType **ppComponentType)
{
    try {
        if (!ppComponentType) {
            return E_POINTER;
        }

	    int idx;
	    CComVariant vidx;
		if (FAILED(vidx.ChangeType(VT_I4, &varIndex))) {
            return E_INVALIDARG;
		}
    	idx = vidx.lVal;
		if (idx >= m_ComponentTypes.size()) {
			return E_INVALIDARG;
		}
	    (*(m_ComponentTypes.begin() + idx)).CopyTo(ppComponentType);
    } catch (...) {
        return E_POINTER;
    }

	return NOERROR;
}

STDMETHODIMP CComponentTypes::put_Item(VARIANT varIndex, IComponentType *pComponentType) {
    try {
	    int idx;
	    CComVariant vidx;
		if (FAILED(vidx.ChangeType(VT_I4, &varIndex))) {
            return E_INVALIDARG;
		}
		idx = vidx.lVal;
        PQComponentType p(pComponentType);
		if (idx >= m_ComponentTypes.size() || !p) {
			return E_INVALIDARG;
		}
        m_ComponentTypes[idx] = p;
        return NOERROR;
    } catch(...) {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CComponentTypes::Add(IComponentType *pComponentType, VARIANT *pNewIndex)
{
    try {
        if (!pComponentType) {
            return E_POINTER;
        }
        PQComponentType p(pComponentType);
        m_ComponentTypes.push_back(p);
        if (pNewIndex) {
            VariantClear(pNewIndex);
            pNewIndex->vt = VT_UI4;
            pNewIndex->ulVal = m_ComponentTypes.end() - m_ComponentTypes.begin() - 1;
        }
        m_bRequiresSave = true;
    } catch (...) {
        return E_POINTER;
    }

	return NOERROR;
}

STDMETHODIMP CComponentTypes::Remove(VARIANT varIndex)
{
    try {
	    int idx;
	    CComVariant vidx;
		if (FAILED(vidx.ChangeType(VT_I4, &varIndex))) {
            return E_INVALIDARG;
        }
		idx = vidx.lVal;
		if (idx >= m_ComponentTypes.size()) {
			return E_INVALIDARG;
		}
	    m_ComponentTypes.erase(m_ComponentTypes.begin() + idx);
        m_bRequiresSave = true;
    } catch (...) {
        return E_UNEXPECTED;
    }

	return NOERROR;
}

STDMETHODIMP CComponentTypes::Clone(IComponentTypes **ppNewList)
{
    try {
		if (!ppNewList) {
			return E_POINTER;
		}
		CComponentTypes* pCs = new CComObject<CComponentTypes>;
		if (!pCs) {
			return E_OUTOFMEMORY;
		}
		ComponentTypeList::iterator i;
		for (i = m_ComponentTypes.begin(); i != m_ComponentTypes.end(); ++i) {
			PQComponentType p;
			HRESULT hr = (*i)->Clone(&p);
			if (FAILED(hr)) {
                pCs->Release();
				return hr;
			}
			pCs->m_ComponentTypes.push_back(p);			
		}
		pCs->AddRef();
        pCs->m_bRequiresSave = true;
		*ppNewList = pCs;
		return NOERROR;
    } catch (...) {
        return E_UNEXPECTED;
    }

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\composition.cpp ===
// Composition.cpp : Implementation of CComposition
//==========================================================================;
//
// Copyright (c) Microsoft Corporation 1998-2000.
//
//--------------------------------------------------------------------------;
//
// Devices.cpp : Implementation of CDevices
//


#include "stdafx.h"

#ifndef TUNING_MODEL_ONLY
#include "MSVidCtl.h"
#include "Composition.h"
#include "anacap.h"
#include "anadata.h"
#include "anasin.h"
#include "WebDVDComp.h"
#include "WebDVDARComp.h"
#include "mp2cc.h"
#include "mp2sin.h"
#include "fp2vr.h"
#include "fp2ar.h"
#include "dat2xds.h"
#include "dat2sin.h"
#include "enc2sin.h"
#include "encdec.h"
#include "ana2xds.h"
#include "ana2enc.h"
#include "sbes2cc.h"
#include "sbes2vmr.h"


DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidGenericComposite, CComposition)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidAnalogCaptureToOverlayMixer, CAnaCapComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidAnalogCaptureToDataServices, CAnaDataComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidWebDVDToVideoRenderer, CWebDVDComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidMPEG2DecoderToClosedCaptioning, CMP2CCComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidAnalogCaptureToStreamBufferSink, CAnaSinComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidDigitalCaptureToStreamBufferSink, CMP2SinComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidFilePlaybackToVideoRenderer, CFP2VRComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidFilePlaybackToAudioRenderer, CFP2ARComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidWebDVDToAudioRenderer, CWebDVDARComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidDataServicesToXDS, CDat2XDSComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidDataServicesToStreamBufferSink, CDat2SinComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidEncoderToStreamBufferSink, CEnc2SinComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidAnalogCaptureToXDS, CAna2XDSComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidAnalogTVToEncoder, CAna2EncComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidSBESourceToCC, CSbeS2CCComp)
DEFINE_EXTERN_OBJECT_ENTRY(CLSID_MSVidStreamBufferSourceToVideoRenderer, CSbeS2VmrComp)
/////////////////////////////////////////////////////////////////////////////
// CComposition

#endif //TUNING_MODEL_ONLY

// end of file - composition.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\componenttype.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ComponentType.h : Declaration of the CComponentType
// Copyright (c) Microsoft Corporation 1999.

#ifndef __COMPONENTTYPE_H_
#define __COMPONENTTYPE_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "componenttypeimpl.h"

/////////////////////////////////////////////////////////////////////////////
// CComponentType
class ATL_NO_VTABLE __declspec(uuid("823535A0-0318-11d3-9D8E-00C04F72D980")) CComponentType : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CComponentType, &CLSID_ComponentType>,
    public IObjectWithSiteImplSec<CComponentType>,
    public IComponentTypeImpl<CComponentType>
{
public:
    CComponentType() : m_bRequiresSave(false)
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_COMPONENTTYPE_PROGID, 
						   IDS_REG_COMPONENTTYPE_DESC,
						   LIBID_TunerLib,
						   CLSID_ComponentType, tvBoth);

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CComponentType)
	COM_INTERFACE_ENTRY(IComponentType)	
	COM_INTERFACE_ENTRY(IPersistPropertyBag)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CComponentType)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

bool m_bRequiresSave;
BEGIN_PROP_MAP(CComponentType)
    CHAIN_PROP_MAP(IComponentTypeImpl<CComponentType>)
END_PROPERTY_MAP()


};

typedef CComQIPtr<IComponentType> PQComponentType;

#endif //__COMPONENTTYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\dshow\vidctl\msvidctl\componenttypes.h ===
/////////////////////////////////////////////////////////////////////////////////////
// ComponentTypes.h : Declaration of the CComponentTypes
// Copyright (c) Microsoft Corporation 1999.

#ifndef __COMPONENTTYPES_H_
#define __COMPONENTTYPES_H_

#pragma once

#include <objectwithsiteimplsec.h>
#include "componenttype.h"

typedef std::vector<PQComponentType, stl_smart_ptr_allocator<PQComponentType> > ComponentTypeList;
typedef CComQIPtr<IPersist> PQPersist;
/////////////////////////////////////////////////////////////////////////////
// CComponentTypes
class ATL_NO_VTABLE CComponentTypes : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CComponentTypes, &CLSID_ComponentTypes>,
    public IObjectWithSiteImplSec<CComponentTypes>,
	public IDispatchImpl<IComponentTypes, &IID_IComponentTypes, &LIBID_TunerLib>,
    public IPersistPropertyBag2
{
public:
	CComponentTypes()
	{
	}

REGISTER_AUTOMATION_OBJECT_WITH_TM(IDS_REG_TUNEROBJ, 
						   IDS_REG_COMPONENTTYPES_PROGID, 
						   IDS_REG_COMPONENTTYPES_DESC,
						   LIBID_TunerLib,
						   CLSID_ComponentTypes, tvBoth);

DECLARE_NOT_AGGREGATABLE(CComponentTypes)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CComponentTypes)
	COM_INTERFACE_ENTRY(IComponentTypes)
	COM_INTERFACE_ENTRY(IPersistPropertyBag2)
	COM_INTERFACE_ENTRY(IPersist)
	COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectWithSite)
END_COM_MAP_WITH_FTM()

	BEGIN_CATEGORY_MAP(CComponentTypes)
		IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
		IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
		IMPLEMENTED_CATEGORY(CATID_PersistsToPropertyBag)
	END_CATEGORY_MAP()

// IPersist
public:
    STDMETHOD(GetClassID)(CLSID *pclsid) {
        try {
            if (!pclsid) {
                return E_POINTER;
            }
            *pclsid = CLSID_ComponentTypes;
            return NOERROR;
        } catch(...) {
            return E_UNEXPECTED;
        }
    }
// IPersistPropertyBag
public:
    bool m_bRequiresSave;

    STDMETHOD(InitNew)() {
        try {
			ATL_LOCK();
            m_ComponentTypes.clear();
            return NOERROR;
        } catch (...) {
            return E_UNEXPECTED;
        }
    }
    STDMETHOD(IsDirty)() {
        return m_bRequiresSave ? S_OK : S_FALSE;
    }
    STDMETHOD(Load)(IPropertyBag2 *pBag2, IErrorLog *pErrLog);
    STDMETHOD(Save)(IPropertyBag2 *pBag2, BOOL fClearDirty, BOOL fSaveAllProperties);

// IComponentTypes
public:
    ComponentTypeList m