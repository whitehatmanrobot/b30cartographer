YTE *) PFXHelpAlloc(EncodedKeyID.cbData))) {
				goto ErrorReturn;
			}
			pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].cbData = EncodedKeyID.cbData;
			dwBytesRequired += INFO_LEN_ALIGN(EncodedKeyID.cbData);
			memcpy(
				pCurrentSafeBag->Attributes.rgAttr[0].rgValue[0].pbData, 
				EncodedKeyID.pbData, 
				EncodedKeyID.cbData);

		} // if (EncodedKeyID.pbData != NULL)

        // check to see if this cert has a friendly name property, if so, 
        // get it and put it in an attribute
        if (cbFriendlyName != 0) {
            
            if ((pFriendlyName = (BYTE *) PFXHelpAlloc(cbFriendlyName)) != NULL) {
                
                if (CertGetCertificateContextProperty(
                        pCertContext,
                        CERT_FRIENDLY_NAME_PROP_ID,
                        pFriendlyName,
                        &cbFriendlyName)) {

                    // set the index of the attribute which will hold the FRIENDLY_NAME,
                    // if there is a LOCAL_KEY_ID attribute then the index will be 1,
                    // if there isn't then the index will be 0
                    if (EncodedKeyID.pbData != NULL) {
                        dwFriendlyNameAttributeIndex = 1;
                    }
                    else {
                        dwFriendlyNameAttributeIndex = 0;
                    }

                    // set the OID in the szOID_PKCS_12_FRIENDLY_NAME_ATTR attribute
	                pCurrentSafeBag->Attributes.rgAttr[dwFriendlyNameAttributeIndex].pszObjId = 
						szOID_PKCS_12_FRIENDLY_NAME_ATTR;
					dwBytesRequired += INFO_LEN_ALIGN(strlen(szOID_PKCS_12_FRIENDLY_NAME_ATTR) + 1);
					
					// allocate space for the single value inside the attribute
					if (NULL == (pCurrentSafeBag->Attributes.rgAttr[dwFriendlyNameAttributeIndex].rgValue = 
									(CRYPT_ATTR_BLOB *) PFXHelpAlloc(sizeof(CRYPT_ATTR_BLOB)))) {
						goto ErrorReturn;
					}
					ZeroMemory(pCurrentSafeBag->Attributes.rgAttr[dwFriendlyNameAttributeIndex].rgValue, sizeof(CRYPT_ATTR_BLOB));
					dwBytesRequired += sizeof(CRYPT_ATTR_BLOB);
					pCurrentSafeBag->Attributes.rgAttr[dwFriendlyNameAttributeIndex].cValue = 1;

					// encode the friendly name, reuse the containerName variable because its there   
					wideFriendlyName.dwValueType = CERT_RDN_BMP_STRING;
					wideFriendlyName.Value.pbData = pFriendlyName;
					wideFriendlyName.Value.cbData = cbFriendlyName;
					
					if (!CryptEncodeObject(
							X509_ASN_ENCODING,
							X509_UNICODE_ANY_STRING,
							(void *)&wideFriendlyName,
							NULL,
							&pCurrentSafeBag->Attributes.rgAttr[dwFriendlyNameAttributeIndex].rgValue[0].cbData)) {
						goto ErrorReturn;
					}

					if (NULL == (pCurrentSafeBag->Attributes.rgAttr[dwFriendlyNameAttributeIndex].rgValue[0].pbData = 
									(BYTE *) PFXHelpAlloc(pCurrentSafeBag->Attributes.rgAttr[dwFriendlyNameAttributeIndex].rgValue[0].cbData))) {
						goto ErrorReturn;
					}
					dwBytesRequired += INFO_LEN_ALIGN(pCurrentSafeBag->Attributes.rgAttr[dwFriendlyNameAttributeIndex].rgValue[0].cbData);

					if (!CryptEncodeObject(
							X509_ASN_ENCODING,
							X509_UNICODE_ANY_STRING,
							(void *)&wideFriendlyName,
							pCurrentSafeBag->Attributes.rgAttr[dwFriendlyNameAttributeIndex].rgValue[0].pbData,
							&pCurrentSafeBag->Attributes.rgAttr[dwFriendlyNameAttributeIndex].rgValue[0].cbData)) {
						goto ErrorReturn;
					}

                } // if (CertGetCertificateContextProperty(CERT_FRIENDLY_NAME_PROP_ID))

            } // if (PFXHelpAlloc())

        } // if (CertGetCertificateContextProperty(CERT_FRIENDLY_NAME_PROP_ID))

	
	} // while (NULL != (pCertContext = CertEnumCertificatesInStore(hCertStore, pCertContext)))

	// check to see if the caller passed in a buffer with encough enough space
	if (0 == *pcbSafeContents) {
		*pcbSafeContents = dwBytesRequired;
		goto CommonReturn;
	}
	else if (*pcbSafeContents < dwBytesRequired) {
		*pcbSafeContents = dwBytesRequired;
		SetLastError((DWORD) ERROR_MORE_DATA);
		goto ErrorReturn;
	}

	// copy the contents into the callers buffer

	// initialize the SAFE_CONTENTS structure that is at the head of the buffer
	ZeroMemory(pSafeContents, dwBytesRequired);
	pCurrentBufferLocation = ((BYTE *) pSafeContents) + sizeof(SAFE_CONTENTS);
	
	// initialize the callers SAFE_CONTENTS
	pSafeContents->cSafeBags = localSafeContents.cSafeBags;

	if (0 == localSafeContents.cSafeBags) {
		pSafeContents->pSafeBags = NULL;
	}
	else {
		pSafeContents->pSafeBags = (SAFE_BAG *) pCurrentBufferLocation;
	}
	pCurrentBufferLocation += localSafeContents.cSafeBags * sizeof(SAFE_BAG);

	// copy each safe bag in the array
	for (i=0; i<localSafeContents.cSafeBags; i++) {
		
		// copy the bag type
		pSafeContents->pSafeBags[i].pszBagTypeOID = (LPSTR) pCurrentBufferLocation;
		strcpy(pSafeContents->pSafeBags[i].pszBagTypeOID, localSafeContents.pSafeBags[i].pszBagTypeOID);
		pCurrentBufferLocation += INFO_LEN_ALIGN(strlen(pSafeContents->pSafeBags[i].pszBagTypeOID) + 1);

		// copy the bag contents
		pSafeContents->pSafeBags[i].BagContents.cbData = localSafeContents.pSafeBags[i].BagContents.cbData;
		pSafeContents->pSafeBags[i].BagContents.pbData = pCurrentBufferLocation;
		memcpy(
			pSafeContents->pSafeBags[i].BagContents.pbData, 
			localSafeContents.pSafeBags[i].BagContents.pbData,
			pSafeContents->pSafeBags[i].BagContents.cbData);
		pCurrentBufferLocation += INFO_LEN_ALIGN(pSafeContents->pSafeBags[i].BagContents.cbData);

		// copy the attributes
		if (localSafeContents.pSafeBags[i].Attributes.cAttr > 0) 
        {
			pSafeContents->pSafeBags[i].Attributes.cAttr = localSafeContents.pSafeBags[i].Attributes.cAttr;
			pSafeContents->pSafeBags[i].Attributes.rgAttr = (PCRYPT_ATTRIBUTE) pCurrentBufferLocation;
			pCurrentBufferLocation += pSafeContents->pSafeBags[i].Attributes.cAttr * sizeof(CRYPT_ATTRIBUTE);
			
			for (j=0; j<pSafeContents->pSafeBags[i].Attributes.cAttr; j++) {
				
				// copy the OID of the attribute
				pSafeContents->pSafeBags[i].Attributes.rgAttr[j].pszObjId = 
					(LPSTR) pCurrentBufferLocation;
				strcpy(
					pSafeContents->pSafeBags[i].Attributes.rgAttr[j].pszObjId,
					localSafeContents.pSafeBags[i].Attributes.rgAttr[j].pszObjId);
				pCurrentBufferLocation += 
					INFO_LEN_ALIGN(strlen(pSafeContents->pSafeBags[i].Attributes.rgAttr[j].pszObjId) + 1);

				// copy value count
				pSafeContents->pSafeBags[i].Attributes.rgAttr[j].cValue = 
					localSafeContents.pSafeBags[i].Attributes.rgAttr[j].cValue;

				// copy the values
				if (pSafeContents->pSafeBags[i].Attributes.rgAttr[j].cValue > 0) {
					
					// setup the array of values
					pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue = 
						(PCRYPT_ATTR_BLOB) pCurrentBufferLocation;
					pCurrentBufferLocation += 
						pSafeContents->pSafeBags[i].Attributes.rgAttr[j].cValue * sizeof(CRYPT_ATTR_BLOB);

					// loop once for each value in the array
					for (k=0; k<pSafeContents->pSafeBags[i].Attributes.rgAttr[j].cValue; k++) {
						
						pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue[k].cbData = 
							localSafeContents.pSafeBags[i].Attributes.rgAttr[j].rgValue[k].cbData;
						
						pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue[k].pbData = 
							pCurrentBufferLocation;
						
						memcpy(
							pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue[k].pbData,
							localSafeContents.pSafeBags[i].Attributes.rgAttr[j].rgValue[k].pbData,
							pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue[k].cbData);
						
						pCurrentBufferLocation += 
							INFO_LEN_ALIGN(pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue[k].cbData);
					}
				}
				else {
					pSafeContents->pSafeBags[i].Attributes.rgAttr[j].rgValue = NULL;	
				}

			}
		}
		else {
			pSafeContents->pSafeBags[i].Attributes.cAttr = 0;
			pSafeContents->pSafeBags[i].Attributes.rgAttr = NULL;
		}
	}

	goto CommonReturn;

ErrorReturn:
	fResult = FALSE;
CommonReturn:
	FreeSafeContents(&localSafeContents);
	if (pCertContext)
		CertFreeCertificateContext(pCertContext);
	if (pCryptKeyProvInfo)
		PFXHelpFree(pCryptKeyProvInfo);
	if (pPrivateKey)
		PFXHelpFree(pPrivateKey);
    if (pFriendlyName)
        PFXHelpFree(pFriendlyName);
    if (pwszProviderName)
        PFXHelpFree(pwszProviderName);
	if (hCryptProv)
    {
		HRESULT hr = GetLastError();
        CryptReleaseContext(hCryptProv, 0);
        SetLastError(hr);
    }
	return fResult;
}


static DWORD ResolveKeySpec(
    CRYPT_PRIVATE_KEY_INFO	*pPrivateKeyInfo)
{
	DWORD			    i = 0;
	DWORD			    dwKeySpec;  
    DWORD			    cbAttribute = 0;
	CRYPT_BIT_BLOB	    *pAttribute = NULL;
    PCRYPT_ATTRIBUTES   pCryptAttributes = pPrivateKeyInfo->pAttributes;

    // set the default keyspec
    if ((0 == strcmp(pPrivateKeyInfo->Algorithm.pszObjId, szOID_RSA_RSA)) ||
        (0 == strcmp(pPrivateKeyInfo->Algorithm.pszObjId, szOID_ANSI_X942_DH)))
    {
        dwKeySpec = AT_KEYEXCHANGE;
    }
    else
    {
        dwKeySpec = AT_SIGNATURE;
    }

	if (pCryptAttributes != NULL)
		while (i < pCryptAttributes->cAttr) {
			if (lstrcmp(pCryptAttributes->rgAttr[i].pszObjId, szOID_KEY_USAGE) == 0) { 
				
				if (!CryptDecodeObject(
						X509_ASN_ENCODING,
						X509_BITS,
						pCryptAttributes->rgAttr[i].rgValue->pbData,
						pCryptAttributes->rgAttr[i].rgValue->cbData,
						0,
						NULL,
						&cbAttribute
						)) {
					i++;
					continue;
				}
				
				if (NULL == (pAttribute = (CRYPT_BIT_BLOB *) PFXHelpAlloc(cbAttribute))) {
					i++;
					continue;
				}
			
				if (!CryptDecodeObject(
						X509_ASN_ENCODING,
						X509_BITS,
						pCryptAttributes->rgAttr[i].rgValue->pbData,
						pCryptAttributes->rgAttr[i].rgValue->cbData,
						0,
						pAttribute,
						&cbAttribute
						)) {
					i++;
					PFXHelpFree(pAttribute);
					continue;
				}
									
				if ((pAttribute->pbData[0] & CERT_KEY_ENCIPHERMENT_KEY_USAGE) ||
					(pAttribute->pbData[0] & CERT_DATA_ENCIPHERMENT_KEY_USAGE)) {
					dwKeySpec = AT_KEYEXCHANGE;
					goto CommonReturn;
				}
				else if ((pAttribute->pbData[0] & CERT_DIGITAL_SIGNATURE_KEY_USAGE) ||
						(pAttribute->pbData[0] & CERT_KEY_CERT_SIGN_KEY_USAGE) ||
						(pAttribute->pbData[0] & CERT_CRL_SIGN_KEY_USAGE)) {
					dwKeySpec = AT_SIGNATURE;
					goto CommonReturn;
				}
			} // if (lstrcmp(pCryptAttributes->rgAttr[i].pszObjId, szOID_KEY_USAGE) == 0) 
			
			i++;
		} // while (i < pCryptAttributes->cAttr)

//ErrorReturn:
CommonReturn:
	if (pAttribute)
		PFXHelpFree(pAttribute);
	return dwKeySpec;
}



typedef struct _HCRYPT_QUERY_FUNC_STATE {
	DWORD					dwSafeBagIndex;
	PHCRYPTPROV_QUERY_FUNC	phCryptQueryFunc;
	LPVOID					pVoid;
	DWORD					dwKeySpec;
    DWORD                   dwPFXImportFlags;
} HCRYPT_QUERY_FUNC_STATE, *PHCRYPT_QUERY_FUNC_STATE;

// this is the callback handler for resolving what HCRYPTPROV should
// be used to import the key to, it is handed in to the ImportPKCS8
// call, and will be called from that context.  
// this callback will just turn around and call the callback provided
// when CertImportSafeContents was called.
static BOOL CALLBACK ResolvehCryptFunc(
	CRYPT_PRIVATE_KEY_INFO	*pPrivateKeyInfo,
	HCRYPTPROV  			*phCryptProv,
	LPVOID		    		pVoidResolveFunc)
{
	HCRYPT_QUERY_FUNC_STATE *pState = (HCRYPT_QUERY_FUNC_STATE *) pVoidResolveFunc;
	
	// set the dwKeySpec field in the HCRYPT_QUERY_FUNC_STATE structure
	// so that the CertImportSafeContents function can use it
	pState->dwKeySpec = ResolveKeySpec(pPrivateKeyInfo);

	return (pState->phCryptQueryFunc(
						pPrivateKeyInfo,
						pState->dwSafeBagIndex,
						phCryptProv,
						pState->pVoid,
                        pState->dwPFXImportFlags));

}


// this function will seach through two arrays of attributes and find the KeyID 
// attributes and see if they match
static BOOL WINAPI KeyIDsMatch(
	CRYPT_ATTRIBUTES *pAttr1,
	CRYPT_ATTRIBUTES *pAttr2
	)
{
	BOOL			bMatch = FALSE;
	BOOL			bFound = FALSE;
	DWORD			i = 0;
	DWORD			j = 0;
	CRYPT_ATTR_BLOB	*pDecodedAttr1 = NULL;
	DWORD			cbDecodedAttr1 = 0;
	CRYPT_ATTR_BLOB	*pDecodedAttr2 = NULL;
	DWORD			cbDecodedAttr2 = 0;

	// search the first attribute array for a key id
	while ((i<pAttr1->cAttr) && (!bFound)) {
		
		if ((strcmp(pAttr1->rgAttr[i].pszObjId, szOID_PKCS_12_LOCAL_KEY_ID) == 0) &&
			(pAttr1->rgAttr[i].cValue != 0)){
			
			bFound = TRUE;
		}
		else {
			i++;
		}
	}

	// check to see if a key id was found
	if (!bFound)
		goto CommonReturn;

	// search the second attribute array for a key id
	bFound = FALSE;
	while ((j<pAttr2->cAttr) && (!bFound)) {
		if ((strcmp(pAttr2->rgAttr[j].pszObjId, szOID_PKCS_12_LOCAL_KEY_ID) == 0) &&
			(pAttr2->rgAttr[j].cValue != 0)) {
			
			bFound = TRUE;
		}
		else {
			j++;
		}	
	}

	// check to see if a key id was found
	if (!bFound)
		goto CommonReturn;

	// decode the values
	if (!CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_OCTET_STRING,
			pAttr1->rgAttr[i].rgValue[0].pbData,
			pAttr1->rgAttr[i].rgValue[0].cbData,
			0,
			NULL,
			&cbDecodedAttr1
			)) {
		goto ErrorReturn;
	}

	if (NULL == (pDecodedAttr1 = (CRYPT_ATTR_BLOB *) PFXHelpAlloc(cbDecodedAttr1))) {
		goto ErrorReturn;
	}

	if (!CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_OCTET_STRING,
			pAttr1->rgAttr[i].rgValue[0].pbData,
			pAttr1->rgAttr[i].rgValue[0].cbData,
			0,
			pDecodedAttr1,
			&cbDecodedAttr1
			)) {
		goto ErrorReturn;
	}

	if (!CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_OCTET_STRING,
			pAttr2->rgAttr[j].rgValue[0].pbData,
			pAttr2->rgAttr[j].rgValue[0].cbData,
			0,
			NULL,
			&cbDecodedAttr2
			)) {
		goto ErrorReturn;
	}

	if (NULL == (pDecodedAttr2 = (CRYPT_ATTR_BLOB *) PFXHelpAlloc(cbDecodedAttr1))) {
		goto ErrorReturn;
	}

	if (!CryptDecodeObject(
			X509_ASN_ENCODING,
			X509_OCTET_STRING,
			pAttr2->rgAttr[j].rgValue[0].pbData,
			pAttr2->rgAttr[j].rgValue[0].cbData,
			0,
			pDecodedAttr2,
			&cbDecodedAttr2
			)) {
		goto ErrorReturn;
	}

	if ((pDecodedAttr1->cbData == pDecodedAttr2->cbData) && 
		(memcmp(pDecodedAttr1->pbData, pDecodedAttr2->pbData, pDecodedAttr1->cbData) == 0)) {
		bMatch = TRUE;
	}

	goto CommonReturn;

ErrorReturn:
	bMatch = FALSE;
CommonReturn:
	if (pDecodedAttr1)
		PFXHelpFree(pDecodedAttr1);
	if (pDecodedAttr2)
		PFXHelpFree(pDecodedAttr2);
	return bMatch;
}


// this function will search the attributes array and try to find a 
// FRIENDLY_NAME attribute, if it does it will add it as a property
// to the given cert context
static 
BOOL
WINAPI
AddFriendlyNameProperty(
    PCCERT_CONTEXT      pCertContext, 
    CRYPT_ATTRIBUTES    *pAttr
    )
{
    BOOL            fReturn = TRUE;
    BOOL            bFound = FALSE;
    DWORD           i = 0;
    CERT_NAME_VALUE *pFriendlyName = NULL;
    DWORD           cbDecodedFriendlyName = 0;
    CRYPT_DATA_BLOB friendlyNameDataBlob;

    // search the attribute array for a FRIENDLY_NAME
	while ((i<pAttr->cAttr) && (!bFound)) {
		
		if ((strcmp(pAttr->rgAttr[i].pszObjId, szOID_PKCS_12_FRIENDLY_NAME_ATTR) == 0) &&
			(pAttr->rgAttr[i].cValue != 0)){
			
			bFound = TRUE;

            // try to decode the FRIENDLY_NAME
            if (!CryptDecodeObject(
			        X509_ASN_ENCODING,
			        X509_UNICODE_ANY_STRING,
			        pAttr->rgAttr[i].rgValue[0].pbData,
			        pAttr->rgAttr[i].rgValue[0].cbData,
			        0,
			        NULL,
			        &cbDecodedFriendlyName
			        )) {
		        goto ErrorReturn;
	        }

            if (NULL == (pFriendlyName = (CERT_NAME_VALUE *) PFXHelpAlloc(cbDecodedFriendlyName))) {
                goto ErrorReturn;
            }

            if (!CryptDecodeObject(
			        X509_ASN_ENCODING,
			        X509_UNICODE_ANY_STRING,
			        pAttr->rgAttr[i].rgValue[0].pbData,
			        pAttr->rgAttr[i].rgValue[0].cbData,
			        0,
			        pFriendlyName,
			        &cbDecodedFriendlyName
			        )) {
		        goto ErrorReturn;
	        }

            friendlyNameDataBlob.pbData = pFriendlyName->Value.pbData;
            friendlyNameDataBlob.cbData = 
                (wcslen((LPWSTR)friendlyNameDataBlob.pbData) + 1) * sizeof(WCHAR);
            
            if (!CertSetCertificateContextProperty(
                    pCertContext,
                    CERT_FRIENDLY_NAME_PROP_ID,
                    0,
                    &friendlyNameDataBlob)) {
                goto ErrorReturn;
            }  
		}
		else {
			i++;
		}
	}

    goto CommonReturn;

ErrorReturn:
    fReturn = FALSE;
CommonReturn:
    if (pFriendlyName)
        PFXHelpFree(pFriendlyName);
    return fReturn;
}


static BOOL GetProvType(HCRYPTPROV hCryptProv, DWORD *pdwProvType)
{
    BOOL            fRet = TRUE;
    HCRYPTKEY	    hCryptKey = NULL;
    PUBLICKEYSTRUC  *pKeyBlob = NULL;
	DWORD	        cbKeyBlob = 0;
    
    *pdwProvType = 0;
    
    // get a handle to the keyset to export
	if (!CryptGetUserKey(
			hCryptProv,
			AT_KEYEXCHANGE,
			&hCryptKey))
        if (!CryptGetUserKey(
			    hCryptProv,
			    AT_SIGNATURE,
			    &hCryptKey))
		    goto ErrorReturn;

    // export the key set to a CAPI blob
	if (!CryptExportKey(
			hCryptKey,
			0,
			PUBLICKEYBLOB,
			0,
			NULL,
			&cbKeyBlob))
        goto ErrorReturn;

    if (NULL == (pKeyBlob = (PUBLICKEYSTRUC *) SSAlloc(cbKeyBlob)))
		goto ErrorReturn;

    if (!CryptExportKey(
			hCryptKey,
			0,
			PUBLICKEYBLOB,
			0,
			(BYTE *)pKeyBlob,
			&cbKeyBlob))
        goto ErrorReturn;

    switch (pKeyBlob->aiKeyAlg)
    {
    case CALG_DSS_SIGN:
        *pdwProvType = PROV_DSS_DH;
        break;
        
    case CALG_RSA_SIGN:
        *pdwProvType = PROV_RSA_SIG;
        break;

    case CALG_RSA_KEYX:
        *pdwProvType = PROV_RSA_FULL;
        break;

    default:
        goto ErrorReturn;
    }

    goto CommonReturn;

ErrorReturn:
    fRet = FALSE;

CommonReturn:

    if (hCryptKey)
    {
        DWORD dwErr = GetLastError();
        CryptDestroyKey(hCryptKey);
        SetLastError(dwErr);
    }

    if (pKeyBlob)
		SSFree(pKeyBlob);

    return (fRet);
}


//+-------------------------------------------------------------------------
// hCertStore -  handle of the cert store to import the safe contents to
// SafeContents - pointer to the safe contents to import to the store
// dwCertAddDisposition - used when importing certificate to the store.
//						  for a full explanation of the possible values
//						  and their meanings see documentation for
//						  CertAddEncodedCertificateToStore
// ImportSafeCallbackStruct - structure that contains pointers to functions
//							  which are callled to get a HCRYPTPROV for import
//							  and to decrypt the key if a EncryptPrivateKeyInfo
//							  is encountered during import
// dwFlags - The available flags are:
//				CRYPT_EXPORTABLE 
//				this flag is used when importing private keys, for a full 
//				explanation please see the documentation for CryptImportKey.
//              CRYPT_USER_PROTECTED
//              this flag is used when importing private keys, for a full 
//				explanation please see the documentation for CryptImportKey.
//              CRYPT_MACHINE_KEYSET
//              this flag is used when calling CryptAcquireContext.
// pvAuxInfo - reserved for future use, must be set to NULL
//+-------------------------------------------------------------------------
BOOL WINAPI CertImportSafeContents(
	HCERTSTORE					hCertStore,					// in
	SAFE_CONTENTS				*pSafeContents,				// in
	DWORD						dwCertAddDisposition,		// in
	IMPORT_SAFE_CALLBACK_STRUCT *ImportSafeCallbackStruct,	// in
	DWORD						dwFlags,					// in
	void						*pvAuxInfo					// in
)
{
	BOOL						fResult = TRUE;
	DWORD						i,j;
	PCCERT_CONTEXT				pCertContext = NULL;
	BOOL						*pAlreadyInserted = NULL;
	HCRYPT_QUERY_FUNC_STATE		stateStruct;
	CRYPT_PKCS8_IMPORT_PARAMS   PrivateKeyBlobAndParams;
	HCRYPTPROV					hCryptProv = NULL;
	CRYPT_KEY_PROV_INFO			cryptKeyProvInfo;
	LPSTR						pszContainerName = NULL;
	DWORD						cbContainerName = 0;
	LPSTR						pszProviderName = NULL;
	DWORD						cbProviderName = 0;
	DWORD						dwProvType;
	DWORD						cbProvType = sizeof(DWORD);
	DWORD						dwNumWideChars = 0;
    BYTE                        *pbEncodedCert = NULL;
    DWORD                       cbEncodedCert = 0;
    DWORD                       dwKeySetType;
    DWORD                       cbKeySetType = sizeof(DWORD);                       
	
	ZeroMemory(&cryptKeyProvInfo, sizeof(CRYPT_KEY_PROV_INFO));	
	
	// validate parameters
	if (pvAuxInfo != NULL) {
		SetLastError((DWORD)ERROR_INVALID_PARAMETER);
		goto ErrorReturn;
	}

	// set up the pAlreadyInserted array so that it has an entry for each safe
	// bag and all entries are set to false.  this is used so that the certificates
	// can be imported at the same time their corresponding private keys are imported
	if (NULL == (pAlreadyInserted = (BOOL *) PFXHelpAlloc(sizeof(BOOL) * pSafeContents->cSafeBags))) {
		goto ErrorReturn;
	}
	else {
		for (i=0; i<pSafeContents->cSafeBags; i++) {
			pAlreadyInserted[i] = FALSE;
		}
	}

	// loop for each safe bag and import it if it is a private key
	for (i=0; i<pSafeContents->cSafeBags; i++) {
		
		// check to see if it is a cert or a key
		if ((strcmp(pSafeContents->pSafeBags[i].pszBagTypeOID, szOID_PKCS_12_KEY_BAG) == 0) ||
            (strcmp(pSafeContents->pSafeBags[i].pszBagTypeOID, szOID_PKCS_12_SHROUDEDKEY_BAG) == 0)) {
			
			// set up the stateStruct so when the hCryptQueryFunc is called when can make
			// our callback
			stateStruct.dwSafeBagIndex		= i;
			stateStruct.phCryptQueryFunc	= ImportSafeCallbackStruct->phCryptProvQueryFunc;
			stateStruct.pVoid				= ImportSafeCallbackStruct->pVoidhCryptProvQuery;
            stateStruct.dwPFXImportFlags    = dwFlags;

			// import the private key
			PrivateKeyBlobAndParams.PrivateKey.pbData		= pSafeContents->pSafeBags[i].BagContents.pbData;
			PrivateKeyBlobAndParams.PrivateKey.cbData		= pSafeContents->pSafeBags[i].BagContents.cbData;
			PrivateKeyBlobAndParams.pResolvehCryptProvFunc	= ResolvehCryptFunc;
			PrivateKeyBlobAndParams.pVoidResolveFunc		= (LPVOID) &stateStruct;
			PrivateKeyBlobAndParams.pDecryptPrivateKeyFunc	= ImportSafeCallbackStruct->pDecryptPrivateKeyFunc;
			PrivateKeyBlobAndParams.pVoidDecryptFunc		= ImportSafeCallbackStruct->pVoidDecryptFunc;
            			
			if (!CryptImportPKCS8(
					PrivateKeyBlobAndParams,
					dwFlags,
					&hCryptProv,
					NULL)) {
				goto ErrorReturn;
			}

			pAlreadyInserted[i] = TRUE;

			// now look at each safe bag and see if it contains a cert with a KeyID that
			// matches the private key that we just imported
			for (j=0; j<pSafeContents->cSafeBags; j++) {
				
				if ((strcmp(pSafeContents->pSafeBags[j].pszBagTypeOID, szOID_PKCS_12_CERT_BAG) == 0)	&&
					(!pAlreadyInserted[j])															&&
					(KeyIDsMatch(&pSafeContents->pSafeBags[i].Attributes, &pSafeContents->pSafeBags[j].Attributes))){
				
                    
                    // extract the encoded cert from an encoded cert bag
                    pbEncodedCert = NULL;
                    cbEncodedCert = 0;
                    if (!GetEncodedCertFromEncodedCertBag(
                            pSafeContents->pSafeBags[j].BagContents.pbData,
							pSafeContents->pSafeBags[j].BagContents.cbData,
                            NULL,
                            &cbEncodedCert)) {
                        goto ErrorReturn;
                    }

                    if (NULL == (pbEncodedCert = (BYTE *) PFXHelpAlloc(cbEncodedCert))) {
                        goto ErrorReturn;
                    }

                    if (!GetEncodedCertFromEncodedCertBag(
                            pSafeContents->pSafeBags[j].BagContents.pbData,
							pSafeContents->pSafeBags[j].BagContents.cbData,
                            pbEncodedCert,
                            &cbEncodedCert)) {
                        PFXHelpFree(pbEncodedCert);
                        goto ErrorReturn;
                    }

					// insert the X509 cert blob into the store
					if (!CertAddEncodedCertificateToStore(
							hCertStore,
							X509_ASN_ENCODING,
							pbEncodedCert,
							cbEncodedCert,
							dwCertAddDisposition,
							&pCertContext)) {
                        PFXHelpFree(pbEncodedCert);
						goto ErrorReturn;
					}

                    // we don't need this anymore
                    PFXHelpFree(pbEncodedCert);

                    if (!AddFriendlyNameProperty(
                            pCertContext, 
                            &pSafeContents->pSafeBags[j].Attributes)) {
                        goto ErrorReturn;
                    }

					// get information needed to set up a connection between the
					// certificate and private key
					if (!CryptGetProvParam(
							hCryptProv,
							PP_CONTAINER,
							NULL,
							&cbContainerName,
							0))
						goto ErrorReturn;

					if (NULL == (pszContainerName = 
									(LPSTR) PFXHelpAlloc(cbContainerName)))
						goto ErrorReturn;
					
					if (!CryptGetProvParam(
							hCryptProv,
							PP_CONTAINER,
							(BYTE *) pszContainerName,
							&cbContainerName,
							0))
						goto ErrorReturn;

					if (!CryptGetProvParam(
							hCryptProv,
							PP_NAME,
							NULL,
							&cbProviderName,
							0))
						goto ErrorReturn;

					if (NULL == (pszProviderName = 
									(LPSTR) PFXHelpAlloc(cbProviderName)))
						goto ErrorReturn;
					
					if (!CryptGetProvParam(
							hCryptProv,
							PP_NAME,
							(BYTE *) pszProviderName,
							&cbProviderName,
							0))
						goto ErrorReturn;

					if (!CryptGetProvParam(
							hCryptProv,
							PP_PROVTYPE,
							(BYTE *) &dwProvType,
							&cbProvType,
							0)) {
						
                        // we couldn't get the information from the provider
                        // so try to figure it out ourselves
                        if (!GetProvType(hCryptProv, &dwProvType))
                        {
						    goto ErrorReturn;
                        }
					}

					// convert strings to wide chars
					dwNumWideChars = MultiByteToWideChar(
										CP_ACP,
										0,
										pszContainerName,
										-1,
										NULL,
										0);

					if (NULL == (cryptKeyProvInfo.pwszContainerName = (LPWSTR)
									PFXHelpAlloc(dwNumWideChars * sizeof(WCHAR)))) {
						goto ErrorReturn;
					}

					if (!MultiByteToWideChar(
										CP_ACP,
										0,
										pszContainerName,
										-1,
										cryptKeyProvInfo.pwszContainerName,
										dwNumWideChars)) {
						goto ErrorReturn;
					}

					dwNumWideChars = MultiByteToWideChar(
										CP_ACP,
										0,
										pszProviderName,
										-1,
										NULL,
										0);

					if (NULL == (cryptKeyProvInfo.pwszProvName = (LPWSTR)
									PFXHelpAlloc(dwNumWideChars * sizeof(WCHAR)))) {
						goto ErrorReturn;
					}

					if (!MultiByteToWideChar(
										CP_ACP,
										0,
										pszProviderName,
										-1,
										cryptKeyProvInfo.pwszProvName,
										dwNumWideChars)) {
						goto ErrorReturn;
					}

					cryptKeyProvInfo.dwProvType = dwProvType;

                    if (CryptGetProvParam(
							hCryptProv,
							PP_KEYSET_TYPE,
							(BYTE *) &dwKeySetType,
							&cbKeySetType,
							0)) {
					    if (CRYPT_MACHINE_KEYSET == dwKeySetType)
                        {
                            cryptKeyProvInfo.dwFlags = CRYPT_MACHINE_KEYSET;
                        }
                    }

					// the dwKeySpec field was set by the callback generated from the
					// CryptImportPKCS8 call.  the callback is currently used to because at
                    // the point the callback is made the private key has been decoded and 
                    // the attributes are available, one of which is the key usage attribute.
                    
                    // FIX - in the future we should be able to call CryptGetProvParam to get
                    // the dwKeySpec, right now that is not supported.
					cryptKeyProvInfo.dwKeySpec = stateStruct.dwKeySpec;

					// set up a property to point to the private key
					if (!CertSetCertificateContextProperty(
							pCertContext,
							CERT_KEY_PROV_INFO_PROP_ID,
							0,
							(void *) &cryptKeyProvInfo)) {
						CertFreeCertificateContext(pCertContext);
						goto ErrorReturn;
					}
					CertFreeCertificateContext(pCertContext);
					pAlreadyInserted[j] = TRUE;
				}

			} // for (j=0; j<pSafeContents->cSafeBags; j++)

		} // if (strcmp(pSafeContents->pSafeBags[i].pszBagTypeOID, szOID_PKCS_12_KEY_BAG) == 0)

	} // for (i=0; i<pSafeContents->cSafeBags; i++)

	// now loop for each safe bag again and import the certificates which didn't have private keys
	for (i=0; i<pSafeContents->cSafeBags; i++) {
		
		// if the certificate has not been inserted, then do it
        if (!pAlreadyInserted[i]) {
			
            // extract the encoded cert from an encoded cert bag
            pbEncodedCert = NULL;
            cbEncodedCert = 0;
            if (!GetEncodedCertFromEncodedCertBag(
                    pSafeContents->pSafeBags[i].BagContents.pbData,
					pSafeContents->pSafeBags[i].BagContents.cbData,
                    NULL,
                    &cbEncodedCert)) {
                goto ErrorReturn;
            }

            if (NULL == (pbEncodedCert = (BYTE *) PFXHelpAlloc(cbEncodedCert))) {
                goto ErrorReturn;
            }

            if (!GetEncodedCertFromEncodedCertBag(
                    pSafeContents->pSafeBags[i].BagContents.pbData,
					pSafeContents->pSafeBags[i].BagContents.cbData,
                    pbEncodedCert,
                    &cbEncodedCert)) {
                PFXHelpFree(pbEncodedCert);
                goto ErrorReturn;
            }
            
            if (!CertAddEncodedCertificateToStore(
					hCertStore,
					X509_ASN_ENCODING,
					pbEncodedCert,
					cbEncodedCert,
					dwCertAddDisposition,
					&pCertContext)) {
                PFXHelpFree(pbEncodedCert);
				goto ErrorReturn;
			}

            // we don't need this anymore
            PFXHelpFree(pbEncodedCert);

            if (!AddFriendlyNameProperty(
                    pCertContext, 
                    &pSafeContents->pSafeBags[i].Attributes)) {
                goto ErrorReturn;
            }

            CertFreeCertificateContext(pCertContext);
        }
	}

	goto CommonReturn;
ErrorReturn:
	fResult = FALSE;
CommonReturn:
	if (pAlreadyInserted)
		PFXHelpFree(pAlreadyInserted);
	if (pszContainerName)
		PFXHelpFree(pszContainerName);
	if (pszProviderName)
		PFXHelpFree(pszProviderName);
	if (cryptKeyProvInfo.pwszContainerName)
		PFXHelpFree(cryptKeyProvInfo.pwszContainerName);
	if (cryptKeyProvInfo.pwszProvName)
		PFXHelpFree(cryptKeyProvInfo.pwszProvName);
    if (hCryptProv) 
    {
        HRESULT hr = GetLastError();
        CryptReleaseContext(hCryptProv, 0);  
        SetLastError(hr);
    }
	return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\pfxlib\pfxpkcs.c ===
/* Copyright (C) Microsoft Corporation, 1996 - 1999 All rights reserved. */
/* ASN.1 definitions for PFXPKCS */

#include <windows.h>
#include "pfxpkcs.h"

ASN1module_t PFXPKCS_Module = NULL;

static int ASN1CALL ASN1Enc_ObjectIdentifierType(ASN1encoding_t enc, ASN1uint32_t tag, ObjectIdentifierType *val);
static int ASN1CALL ASN1Enc_OctetStringType(ASN1encoding_t enc, ASN1uint32_t tag, OctetStringType *val);
static int ASN1CALL ASN1Enc_IntegerType(ASN1encoding_t enc, ASN1uint32_t tag, IntegerType *val);
static int ASN1CALL ASN1Enc_RSAPublicKey(ASN1encoding_t enc, ASN1uint32_t tag, RSAPublicKey *val);
static int ASN1CALL ASN1Enc_RSAPrivateKey(ASN1encoding_t enc, ASN1uint32_t tag, RSAPrivateKey *val);
static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_PBEParameter(ASN1encoding_t enc, ASN1uint32_t tag, PBEParameter *val);
static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_AttributeSetValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValue *val);
static int ASN1CALL ASN1Enc_Attribute(ASN1encoding_t enc, ASN1uint32_t tag, Attribute *val);
static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Enc_ContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfo *val);
static int ASN1CALL ASN1Enc_AuthenticatedSafes(ASN1encoding_t enc, ASN1uint32_t tag, AuthenticatedSafes *val);
static int ASN1CALL ASN1Enc_SafeContents(ASN1encoding_t enc, ASN1uint32_t tag, SafeContents *val);
static int ASN1CALL ASN1Enc_SafeBag(ASN1encoding_t enc, ASN1uint32_t tag, SafeBag *val);
static int ASN1CALL ASN1Enc_CertBag(ASN1encoding_t enc, ASN1uint32_t tag, CertBag *val);
static int ASN1CALL ASN1Enc_CRLBag(ASN1encoding_t enc, ASN1uint32_t tag, CRLBag *val);
static int ASN1CALL ASN1Enc_SecretBag(ASN1encoding_t enc, ASN1uint32_t tag, SecretBag *val);
static int ASN1CALL ASN1Enc_PrivateKeyAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyAlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_EncryptionAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, EncryptionAlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_ContentEncryptionAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, ContentEncryptionAlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_DigestInfo(ASN1encoding_t enc, ASN1uint32_t tag, DigestInfo *val);
static int ASN1CALL ASN1Enc_MacData(ASN1encoding_t enc, ASN1uint32_t tag, MacData *val);
static int ASN1CALL ASN1Enc_PrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyInfo *val);
static int ASN1CALL ASN1Enc_EncryptedContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedContentInfo *val);
static int ASN1CALL ASN1Enc_PFX(ASN1encoding_t enc, ASN1uint32_t tag, PFX *val);
static int ASN1CALL ASN1Enc_KeyBag(ASN1encoding_t enc, ASN1uint32_t tag, KeyBag *val);
static int ASN1CALL ASN1Enc_EncryptedData(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedData *val);
static int ASN1CALL ASN1Enc_EncryptedPrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedPrivateKeyInfo *val);
static int ASN1CALL ASN1Enc_Pkcs_8ShroudedKeyBag(ASN1encoding_t enc, ASN1uint32_t tag, Pkcs_8ShroudedKeyBag *val);
static int ASN1CALL ASN1Dec_ObjectIdentifierType(ASN1decoding_t dec, ASN1uint32_t tag, ObjectIdentifierType *val);
static int ASN1CALL ASN1Dec_OctetStringType(ASN1decoding_t dec, ASN1uint32_t tag, OctetStringType *val);
static int ASN1CALL ASN1Dec_IntegerType(ASN1decoding_t dec, ASN1uint32_t tag, IntegerType *val);
static int ASN1CALL ASN1Dec_RSAPublicKey(ASN1decoding_t dec, ASN1uint32_t tag, RSAPublicKey *val);
static int ASN1CALL ASN1Dec_RSAPrivateKey(ASN1decoding_t dec, ASN1uint32_t tag, RSAPrivateKey *val);
static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_PBEParameter(ASN1decoding_t dec, ASN1uint32_t tag, PBEParameter *val);
static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_AttributeSetValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValue *val);
static int ASN1CALL ASN1Dec_Attribute(ASN1decoding_t dec, ASN1uint32_t tag, Attribute *val);
static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Dec_ContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfo *val);
static int ASN1CALL ASN1Dec_AuthenticatedSafes(ASN1decoding_t dec, ASN1uint32_t tag, AuthenticatedSafes *val);
static int ASN1CALL ASN1Dec_SafeContents(ASN1decoding_t dec, ASN1uint32_t tag, SafeContents *val);
static int ASN1CALL ASN1Dec_SafeBag(ASN1decoding_t dec, ASN1uint32_t tag, SafeBag *val);
static int ASN1CALL ASN1Dec_CertBag(ASN1decoding_t dec, ASN1uint32_t tag, CertBag *val);
static int ASN1CALL ASN1Dec_CRLBag(ASN1decoding_t dec, ASN1uint32_t tag, CRLBag *val);
static int ASN1CALL ASN1Dec_SecretBag(ASN1decoding_t dec, ASN1uint32_t tag, SecretBag *val);
static int ASN1CALL ASN1Dec_PrivateKeyAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyAlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_EncryptionAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, EncryptionAlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_ContentEncryptionAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, ContentEncryptionAlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_DigestInfo(ASN1decoding_t dec, ASN1uint32_t tag, DigestInfo *val);
static int ASN1CALL ASN1Dec_MacData(ASN1decoding_t dec, ASN1uint32_t tag, MacData *val);
static int ASN1CALL ASN1Dec_PrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyInfo *val);
static int ASN1CALL ASN1Dec_EncryptedContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedContentInfo *val);
static int ASN1CALL ASN1Dec_PFX(ASN1decoding_t dec, ASN1uint32_t tag, PFX *val);
static int ASN1CALL ASN1Dec_KeyBag(ASN1decoding_t dec, ASN1uint32_t tag, KeyBag *val);
static int ASN1CALL ASN1Dec_EncryptedData(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedData *val);
static int ASN1CALL ASN1Dec_EncryptedPrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedPrivateKeyInfo *val);
static int ASN1CALL ASN1Dec_Pkcs_8ShroudedKeyBag(ASN1decoding_t dec, ASN1uint32_t tag, Pkcs_8ShroudedKeyBag *val);
static void ASN1CALL ASN1Free_ObjectIdentifierType(ObjectIdentifierType *val);
static void ASN1CALL ASN1Free_OctetStringType(OctetStringType *val);
static void ASN1CALL ASN1Free_IntegerType(IntegerType *val);
static void ASN1CALL ASN1Free_RSAPublicKey(RSAPublicKey *val);
static void ASN1CALL ASN1Free_RSAPrivateKey(RSAPrivateKey *val);
static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_PBEParameter(PBEParameter *val);
static void ASN1CALL ASN1Free_DigestAlgorithmIdentifier(DigestAlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_AttributeSetValue(AttributeSetValue *val);
static void ASN1CALL ASN1Free_Attribute(Attribute *val);
static void ASN1CALL ASN1Free_Attributes(Attributes *val);
static void ASN1CALL ASN1Free_ContentInfo(ContentInfo *val);
static void ASN1CALL ASN1Free_AuthenticatedSafes(AuthenticatedSafes *val);
static void ASN1CALL ASN1Free_SafeContents(SafeContents *val);
static void ASN1CALL ASN1Free_SafeBag(SafeBag *val);
static void ASN1CALL ASN1Free_CertBag(CertBag *val);
static void ASN1CALL ASN1Free_CRLBag(CRLBag *val);
static void ASN1CALL ASN1Free_SecretBag(SecretBag *val);
static void ASN1CALL ASN1Free_PrivateKeyAlgorithmIdentifier(PrivateKeyAlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_EncryptionAlgorithmIdentifier(EncryptionAlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_ContentEncryptionAlgorithmIdentifier(ContentEncryptionAlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_DigestInfo(DigestInfo *val);
static void ASN1CALL ASN1Free_MacData(MacData *val);
static void ASN1CALL ASN1Free_PrivateKeyInfo(PrivateKeyInfo *val);
static void ASN1CALL ASN1Free_EncryptedContentInfo(EncryptedContentInfo *val);
static void ASN1CALL ASN1Free_PFX(PFX *val);
static void ASN1CALL ASN1Free_KeyBag(KeyBag *val);
static void ASN1CALL ASN1Free_EncryptedData(EncryptedData *val);
static void ASN1CALL ASN1Free_EncryptedPrivateKeyInfo(EncryptedPrivateKeyInfo *val);
static void ASN1CALL ASN1Free_Pkcs_8ShroudedKeyBag(Pkcs_8ShroudedKeyBag *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[22] = {
    (ASN1EncFun_t) ASN1Enc_ObjectIdentifierType,
    (ASN1EncFun_t) ASN1Enc_OctetStringType,
    (ASN1EncFun_t) ASN1Enc_IntegerType,
    (ASN1EncFun_t) ASN1Enc_RSAPublicKey,
    (ASN1EncFun_t) ASN1Enc_RSAPrivateKey,
    (ASN1EncFun_t) ASN1Enc_PBEParameter,
    (ASN1EncFun_t) ASN1Enc_AttributeSetValue,
    (ASN1EncFun_t) ASN1Enc_Attributes,
    (ASN1EncFun_t) ASN1Enc_AuthenticatedSafes,
    (ASN1EncFun_t) ASN1Enc_SafeContents,
    (ASN1EncFun_t) ASN1Enc_SafeBag,
    (ASN1EncFun_t) ASN1Enc_CertBag,
    (ASN1EncFun_t) ASN1Enc_CRLBag,
    (ASN1EncFun_t) ASN1Enc_SecretBag,
    (ASN1EncFun_t) ASN1Enc_DigestInfo,
    (ASN1EncFun_t) ASN1Enc_MacData,
    (ASN1EncFun_t) ASN1Enc_PrivateKeyInfo,
    (ASN1EncFun_t) ASN1Enc_PFX,
    (ASN1EncFun_t) ASN1Enc_KeyBag,
    (ASN1EncFun_t) ASN1Enc_EncryptedData,
    (ASN1EncFun_t) ASN1Enc_EncryptedPrivateKeyInfo,
    (ASN1EncFun_t) ASN1Enc_Pkcs_8ShroudedKeyBag,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[22] = {
    (ASN1DecFun_t) ASN1Dec_ObjectIdentifierType,
    (ASN1DecFun_t) ASN1Dec_OctetStringType,
    (ASN1DecFun_t) ASN1Dec_IntegerType,
    (ASN1DecFun_t) ASN1Dec_RSAPublicKey,
    (ASN1DecFun_t) ASN1Dec_RSAPrivateKey,
    (ASN1DecFun_t) ASN1Dec_PBEParameter,
    (ASN1DecFun_t) ASN1Dec_AttributeSetValue,
    (ASN1DecFun_t) ASN1Dec_Attributes,
    (ASN1DecFun_t) ASN1Dec_AuthenticatedSafes,
    (ASN1DecFun_t) ASN1Dec_SafeContents,
    (ASN1DecFun_t) ASN1Dec_SafeBag,
    (ASN1DecFun_t) ASN1Dec_CertBag,
    (ASN1DecFun_t) ASN1Dec_CRLBag,
    (ASN1DecFun_t) ASN1Dec_SecretBag,
    (ASN1DecFun_t) ASN1Dec_DigestInfo,
    (ASN1DecFun_t) ASN1Dec_MacData,
    (ASN1DecFun_t) ASN1Dec_PrivateKeyInfo,
    (ASN1DecFun_t) ASN1Dec_PFX,
    (ASN1DecFun_t) ASN1Dec_KeyBag,
    (ASN1DecFun_t) ASN1Dec_EncryptedData,
    (ASN1DecFun_t) ASN1Dec_EncryptedPrivateKeyInfo,
    (ASN1DecFun_t) ASN1Dec_Pkcs_8ShroudedKeyBag,
};
static const ASN1FreeFun_t freefntab[22] = {
    (ASN1FreeFun_t) ASN1Free_ObjectIdentifierType,
    (ASN1FreeFun_t) ASN1Free_OctetStringType,
    (ASN1FreeFun_t) ASN1Free_IntegerType,
    (ASN1FreeFun_t) ASN1Free_RSAPublicKey,
    (ASN1FreeFun_t) ASN1Free_RSAPrivateKey,
    (ASN1FreeFun_t) ASN1Free_PBEParameter,
    (ASN1FreeFun_t) ASN1Free_AttributeSetValue,
    (ASN1FreeFun_t) ASN1Free_Attributes,
    (ASN1FreeFun_t) ASN1Free_AuthenticatedSafes,
    (ASN1FreeFun_t) ASN1Free_SafeContents,
    (ASN1FreeFun_t) ASN1Free_SafeBag,
    (ASN1FreeFun_t) ASN1Free_CertBag,
    (ASN1FreeFun_t) ASN1Free_CRLBag,
    (ASN1FreeFun_t) ASN1Free_SecretBag,
    (ASN1FreeFun_t) ASN1Free_DigestInfo,
    (ASN1FreeFun_t) ASN1Free_MacData,
    (ASN1FreeFun_t) ASN1Free_PrivateKeyInfo,
    (ASN1FreeFun_t) ASN1Free_PFX,
    (ASN1FreeFun_t) ASN1Free_KeyBag,
    (ASN1FreeFun_t) ASN1Free_EncryptedData,
    (ASN1FreeFun_t) ASN1Free_EncryptedPrivateKeyInfo,
    (ASN1FreeFun_t) ASN1Free_Pkcs_8ShroudedKeyBag,
};
static const ULONG sizetab[22] = {
    SIZE_PFXPKCS_Module_PDU_0,
    SIZE_PFXPKCS_Module_PDU_1,
    SIZE_PFXPKCS_Module_PDU_2,
    SIZE_PFXPKCS_Module_PDU_3,
    SIZE_PFXPKCS_Module_PDU_4,
    SIZE_PFXPKCS_Module_PDU_5,
    SIZE_PFXPKCS_Module_PDU_6,
    SIZE_PFXPKCS_Module_PDU_7,
    SIZE_PFXPKCS_Module_PDU_8,
    SIZE_PFXPKCS_Module_PDU_9,
    SIZE_PFXPKCS_Module_PDU_10,
    SIZE_PFXPKCS_Module_PDU_11,
    SIZE_PFXPKCS_Module_PDU_12,
    SIZE_PFXPKCS_Module_PDU_13,
    SIZE_PFXPKCS_Module_PDU_14,
    SIZE_PFXPKCS_Module_PDU_15,
    SIZE_PFXPKCS_Module_PDU_16,
    SIZE_PFXPKCS_Module_PDU_17,
    SIZE_PFXPKCS_Module_PDU_18,
    SIZE_PFXPKCS_Module_PDU_19,
    SIZE_PFXPKCS_Module_PDU_20,
    SIZE_PFXPKCS_Module_PDU_21,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */
ASN1int32_t MacData_macIterationCount_default = 1;

void ASN1CALL PFXPKCS_Module_Startup(void)
{
    PFXPKCS_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 22, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x70786670);
}

void ASN1CALL PFXPKCS_Module_Cleanup(void)
{
    ASN1_CloseModule(PFXPKCS_Module);
    PFXPKCS_Module = NULL;
}

static int ASN1CALL ASN1Enc_ObjectIdentifierType(ASN1encoding_t enc, ASN1uint32_t tag, ObjectIdentifierType *val)
{
    if (!ASN1BEREncObjectIdentifier2(enc, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ObjectIdentifierType(ASN1decoding_t dec, ASN1uint32_t tag, ObjectIdentifierType *val)
{
    if (!ASN1BERDecObjectIdentifier2(dec, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ObjectIdentifierType(ObjectIdentifierType *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_OctetStringType(ASN1encoding_t enc, ASN1uint32_t tag, OctetStringType *val)
{
    if (!ASN1DEREncOctetString(enc, tag ? tag : 0x4, (val)->length, (val)->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OctetStringType(ASN1decoding_t dec, ASN1uint32_t tag, OctetStringType *val)
{
    if (!ASN1BERDecOctetString(dec, tag ? tag : 0x4, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OctetStringType(OctetStringType *val)
{
    if (val) {
	ASN1octetstring_free(val);
    }
}

static int ASN1CALL ASN1Enc_IntegerType(ASN1encoding_t enc, ASN1uint32_t tag, IntegerType *val)
{
    if (!ASN1BEREncSX(enc, tag ? tag : 0x2, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IntegerType(ASN1decoding_t dec, ASN1uint32_t tag, IntegerType *val)
{
    if (!ASN1BERDecSXVal(dec, tag ? tag : 0x2, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_IntegerType(IntegerType *val)
{
    if (val) {
	ASN1intx_free(val);
    }
}

static int ASN1CALL ASN1Enc_RSAPublicKey(ASN1encoding_t enc, ASN1uint32_t tag, RSAPublicKey *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->modulus))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->publicExponent))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RSAPublicKey(ASN1decoding_t dec, ASN1uint32_t tag, RSAPublicKey *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->modulus))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->publicExponent))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RSAPublicKey(RSAPublicKey *val)
{
    if (val) {
	ASN1intx_free(&(val)->modulus);
	ASN1intx_free(&(val)->publicExponent);
    }
}

static int ASN1CALL ASN1Enc_RSAPrivateKey(ASN1encoding_t enc, ASN1uint32_t tag, RSAPrivateKey *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->modulus))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->publicExponent))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->privateExponent))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->prime1))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->prime2))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->exponent1))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->exponent2))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->coefficient))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RSAPrivateKey(ASN1decoding_t dec, ASN1uint32_t tag, RSAPrivateKey *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->modulus))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->publicExponent))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->privateExponent))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->prime1))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->prime2))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->exponent1))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->exponent2))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->coefficient))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RSAPrivateKey(RSAPrivateKey *val)
{
    if (val) {
	ASN1intx_free(&(val)->modulus);
	ASN1intx_free(&(val)->privateExponent);
	ASN1intx_free(&(val)->prime1);
	ASN1intx_free(&(val)->prime2);
	ASN1intx_free(&(val)->exponent1);
	ASN1intx_free(&(val)->exponent2);
	ASN1intx_free(&(val)->coefficient);
    }
}

static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1open_free(&(val)->parameters);
	}
    }
}

static int ASN1CALL ASN1Enc_PBEParameter(ASN1encoding_t enc, ASN1uint32_t tag, PBEParameter *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->salt).length, ((val)->salt).value))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->iterationCount))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PBEParameter(ASN1decoding_t dec, ASN1uint32_t tag, PBEParameter *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->salt))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->iterationCount))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PBEParameter(PBEParameter *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->salt);
    }
}

static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifier *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifier *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestAlgorithmIdentifier(DigestAlgorithmIdentifier *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_AttributeSetValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValue *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributeSetValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValue *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (AttributeSetValue_Set *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributeSetValue(AttributeSetValue *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1open_free(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1open_free(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_Attribute(ASN1encoding_t enc, ASN1uint32_t tag, Attribute *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->attributeType))
	return 0;
    if (!ASN1Enc_AttributeSetValue(enc, 0, &(val)->attributeValue))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attribute(ASN1decoding_t dec, ASN1uint32_t tag, Attribute *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->attributeType))
	return 0;
    if (!ASN1Dec_AttributeSetValue(dd, 0, &(val)->attributeValue))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attribute(Attribute *val)
{
    if (val) {
	ASN1Free_AttributeSetValue(&(val)->attributeValue);
    }
}

static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_Attribute(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (Attribute *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_Attribute(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attributes(Attributes *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_Attribute(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_Attribute(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_ContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfo *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->contentType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->content))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->contentType))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	if (t == 0x80000000) {
	    (val)->o[0] |= 0x80;
	    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
		return 0;
	    if (!ASN1BERDecOpenType(dd0, &(val)->content))
		return 0;
	    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
		return 0;
	}
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentInfo(ContentInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1open_free(&(val)->content);
	}
    }
}

static int ASN1CALL ASN1Enc_AuthenticatedSafes(ASN1encoding_t enc, ASN1uint32_t tag, AuthenticatedSafes *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_ContentInfo(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AuthenticatedSafes(ASN1decoding_t dec, ASN1uint32_t tag, AuthenticatedSafes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (ContentInfo *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_ContentInfo(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AuthenticatedSafes(AuthenticatedSafes *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_ContentInfo(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_ContentInfo(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SafeContents(ASN1encoding_t enc, ASN1uint32_t tag, SafeContents *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_SafeBag(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SafeContents(ASN1decoding_t dec, ASN1uint32_t tag, SafeContents *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (SafeBag *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_SafeBag(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SafeContents(SafeContents *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_SafeBag(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_SafeBag(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SafeBag(ASN1encoding_t enc, ASN1uint32_t tag, SafeBag *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->safeBagType))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->safeBagContent))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Attributes(enc, 0, &(val)->safeBagAttribs))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SafeBag(ASN1decoding_t dec, ASN1uint32_t tag, SafeBag *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->safeBagType))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOpenType(dd0, &(val)->safeBagContent))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x11) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Attributes(dd, 0, &(val)->safeBagAttribs))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SafeBag(SafeBag *val)
{
    if (val) {
	ASN1open_free(&(val)->safeBagContent);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Attributes(&(val)->safeBagAttribs);
	}
    }
}

static int ASN1CALL ASN1Enc_CertBag(ASN1encoding_t enc, ASN1uint32_t tag, CertBag *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->certType))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertBag(ASN1decoding_t dec, ASN1uint32_t tag, CertBag *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->certType))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOpenType(dd0, &(val)->value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertBag(CertBag *val)
{
    if (val) {
	ASN1open_free(&(val)->value);
    }
}

static int ASN1CALL ASN1Enc_CRLBag(ASN1encoding_t enc, ASN1uint32_t tag, CRLBag *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->crlType))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CRLBag(ASN1decoding_t dec, ASN1uint32_t tag, CRLBag *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->crlType))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOpenType(dd0, &(val)->value))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CRLBag(CRLBag *val)
{
    if (val) {
	ASN1open_free(&(val)->value);
    }
}

static int ASN1CALL ASN1Enc_SecretBag(ASN1encoding_t enc, ASN1uint32_t tag, SecretBag *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->secretType))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->secretContent))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SecretBag(ASN1decoding_t dec, ASN1uint32_t tag, SecretBag *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->secretType))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1BERDecOpenType(dd0, &(val)->secretContent))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SecretBag(SecretBag *val)
{
    if (val) {
	ASN1open_free(&(val)->secretContent);
    }
}

static int ASN1CALL ASN1Enc_PrivateKeyAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyAlgorithmIdentifier *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKeyAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyAlgorithmIdentifier *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKeyAlgorithmIdentifier(PrivateKeyAlgorithmIdentifier *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_EncryptionAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, EncryptionAlgorithmIdentifier *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, EncryptionAlgorithmIdentifier *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionAlgorithmIdentifier(EncryptionAlgorithmIdentifier *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_ContentEncryptionAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, ContentEncryptionAlgorithmIdentifier *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentEncryptionAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, ContentEncryptionAlgorithmIdentifier *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentEncryptionAlgorithmIdentifier(ContentEncryptionAlgorithmIdentifier *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_DigestInfo(ASN1encoding_t enc, ASN1uint32_t tag, DigestInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_DigestAlgorithmIdentifier(enc, 0, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->digest).length, ((val)->digest).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestInfo(ASN1decoding_t dec, ASN1uint32_t tag, DigestInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_DigestAlgorithmIdentifier(dd, 0, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->digest))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestInfo(DigestInfo *val)
{
    if (val) {
	ASN1Free_DigestAlgorithmIdentifier(&(val)->digestAlgorithm);
	ASN1octetstring_free(&(val)->digest);
    }
}

static int ASN1CALL ASN1Enc_MacData(ASN1encoding_t enc, ASN1uint32_t tag, MacData *val)
{
    ASN1uint32_t nLenOff;
    ASN1octet_t o[1];
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    CopyMemory(o, (val)->o, 1);
    if ((val)->macIterationCount == 1)
	o[0] &= ~0x80;
    if (!ASN1Enc_DigestInfo(enc, 0, &(val)->safeMac))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->macSalt).length, ((val)->macSalt).value))
	return 0;
    if (o[0] & 0x80) {
	if (!ASN1BEREncS32(enc, 0x2, (val)->macIterationCount))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MacData(ASN1decoding_t dec, ASN1uint32_t tag, MacData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1Dec_DigestInfo(dd, 0, &(val)->safeMac))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->macSalt))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x2) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecS32Val(dd, 0x2, &(val)->macIterationCount))
	    return 0;
    }
    if (!((val)->o[0] & 0x80))
	(val)->macIterationCount = 1;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MacData(MacData *val)
{
    if (val) {
	ASN1Free_DigestInfo(&(val)->safeMac);
	ASN1octetstring_free(&(val)->macSalt);
    }
}

static int ASN1CALL ASN1Enc_PrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_PrivateKeyAlgorithmIdentifier(enc, 0, &(val)->privateKeyAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->privateKey).length, ((val)->privateKey).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Attributes(enc, 0x80000000, &(val)->attributes))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_PrivateKeyAlgorithmIdentifier(dd, 0, &(val)->privateKeyAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->privateKey))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Attributes(dd, 0x80000000, &(val)->attributes))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKeyInfo(PrivateKeyInfo *val)
{
    if (val) {
	ASN1Free_PrivateKeyAlgorithmIdentifier(&(val)->privateKeyAlgorithm);
	ASN1octetstring_free(&(val)->privateKey);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Attributes(&(val)->attributes);
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptedContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedContentInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1Enc_ContentEncryptionAlgorithmIdentifier(enc, 0, &(val)->contentEncryptionAlg))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->encryptedContent).length, ((val)->encryptedContent).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptedContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedContentInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1Dec_ContentEncryptionAlgorithmIdentifier(dd, 0, &(val)->contentEncryptionAlg))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOctetString(dd, 0x80000000, &(val)->encryptedContent))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptedContentInfo(EncryptedContentInfo *val)
{
    if (val) {
	ASN1Free_ContentEncryptionAlgorithmIdentifier(&(val)->contentEncryptionAlg);
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->encryptedContent);
	}
    }
}

static int ASN1CALL ASN1Enc_PFX(ASN1encoding_t enc, ASN1uint32_t tag, PFX *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_ContentInfo(enc, 0, &(val)->authSafes))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_MacData(enc, 0, &(val)->macData))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PFX(ASN1decoding_t dec, ASN1uint32_t tag, PFX *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_ContentInfo(dd, 0, &(val)->authSafes))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_MacData(dd, 0, &(val)->macData))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PFX(PFX *val)
{
    if (val) {
	ASN1Free_ContentInfo(&(val)->authSafes);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_MacData(&(val)->macData);
	}
    }
}

static int ASN1CALL ASN1Enc_KeyBag(ASN1encoding_t enc, ASN1uint32_t tag, KeyBag *val)
{
    if (!ASN1Enc_PrivateKeyInfo(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeyBag(ASN1decoding_t dec, ASN1uint32_t tag, KeyBag *val)
{
    if (!ASN1Dec_PrivateKeyInfo(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KeyBag(KeyBag *val)
{
    if (val) {
	ASN1Free_PrivateKeyInfo(val);
    }
}

static int ASN1CALL ASN1Enc_EncryptedData(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_EncryptedContentInfo(enc, 0, &(val)->encryptedContentInfo))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptedData(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_EncryptedContentInfo(dd, 0, &(val)->encryptedContentInfo))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptedData(EncryptedData *val)
{
    if (val) {
	ASN1Free_EncryptedContentInfo(&(val)->encryptedContentInfo);
    }
}

static int ASN1CALL ASN1Enc_EncryptedPrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedPrivateKeyInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_EncryptionAlgorithmIdentifier(enc, 0, &(val)->encryptionAlgorithm))
	return 0;
    if (!ASN1Enc_EncryptedData(enc, 0, &(val)->encryptedData))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptedPrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedPrivateKeyInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_EncryptionAlgorithmIdentifier(dd, 0, &(val)->encryptionAlgorithm))
	return 0;
    if (!ASN1Dec_EncryptedData(dd, 0, &(val)->encryptedData))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptedPrivateKeyInfo(EncryptedPrivateKeyInfo *val)
{
    if (val) {
	ASN1Free_EncryptionAlgorithmIdentifier(&(val)->encryptionAlgorithm);
	ASN1Free_EncryptedData(&(val)->encryptedData);
    }
}

static int ASN1CALL ASN1Enc_Pkcs_8ShroudedKeyBag(ASN1encoding_t enc, ASN1uint32_t tag, Pkcs_8ShroudedKeyBag *val)
{
    if (!ASN1Enc_EncryptedPrivateKeyInfo(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Pkcs_8ShroudedKeyBag(ASN1decoding_t dec, ASN1uint32_t tag, Pkcs_8ShroudedKeyBag *val)
{
    if (!ASN1Dec_EncryptedPrivateKeyInfo(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Pkcs_8ShroudedKeyBag(Pkcs_8ShroudedKeyBag *val)
{
    if (val) {
	ASN1Free_EncryptedPrivateKeyInfo(val);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\pfxlib\prvtkey.c ===
/* Copyright (C) Microsoft Corporation, 1996 - 1999 All rights reserved. */
/* ASN.1 definitions for X509 v3 certificates */

#include <windows.h>
#include "prvtkey.h"

ASN1module_t PRVTKEY_Module = NULL;

static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_AttributeSetValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValue *val);
static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Enc_RSAPrivateKey(ASN1encoding_t enc, ASN1uint32_t tag, RSAPrivateKey *val);
static int ASN1CALL ASN1Enc_PrivateKeyAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyAlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_PrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyInfo *val);
static int ASN1CALL ASN1Enc_EncryptionAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, EncryptionAlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_EncryptedPrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedPrivateKeyInfo *val);
static int ASN1CALL ASN1Enc_Attribute(ASN1encoding_t enc, ASN1uint32_t tag, Attribute *val);
static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_AttributeSetValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValue *val);
static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Dec_RSAPrivateKey(ASN1decoding_t dec, ASN1uint32_t tag, RSAPrivateKey *val);
static int ASN1CALL ASN1Dec_PrivateKeyAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyAlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_PrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyInfo *val);
static int ASN1CALL ASN1Dec_EncryptionAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, EncryptionAlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_EncryptedPrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedPrivateKeyInfo *val);
static int ASN1CALL ASN1Dec_Attribute(ASN1decoding_t dec, ASN1uint32_t tag, Attribute *val);
static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_AttributeSetValue(AttributeSetValue *val);
static void ASN1CALL ASN1Free_Attributes(Attributes *val);
static void ASN1CALL ASN1Free_RSAPrivateKey(RSAPrivateKey *val);
static void ASN1CALL ASN1Free_PrivateKeyAlgorithmIdentifier(PrivateKeyAlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_PrivateKeyInfo(PrivateKeyInfo *val);
static void ASN1CALL ASN1Free_EncryptionAlgorithmIdentifier(EncryptionAlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_EncryptedPrivateKeyInfo(EncryptedPrivateKeyInfo *val);
static void ASN1CALL ASN1Free_Attribute(Attribute *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[4] = {
    (ASN1EncFun_t) ASN1Enc_RSAPrivateKey,
    (ASN1EncFun_t) ASN1Enc_PrivateKeyInfo,
    (ASN1EncFun_t) ASN1Enc_EncryptedPrivateKeyInfo,
    (ASN1EncFun_t) ASN1Enc_Attribute,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[4] = {
    (ASN1DecFun_t) ASN1Dec_RSAPrivateKey,
    (ASN1DecFun_t) ASN1Dec_PrivateKeyInfo,
    (ASN1DecFun_t) ASN1Dec_EncryptedPrivateKeyInfo,
    (ASN1DecFun_t) ASN1Dec_Attribute,
};
static const ASN1FreeFun_t freefntab[4] = {
    (ASN1FreeFun_t) ASN1Free_RSAPrivateKey,
    (ASN1FreeFun_t) ASN1Free_PrivateKeyInfo,
    (ASN1FreeFun_t) ASN1Free_EncryptedPrivateKeyInfo,
    (ASN1FreeFun_t) ASN1Free_Attribute,
};
static const ULONG sizetab[4] = {
    SIZE_PRVTKEY_Module_PDU_0,
    SIZE_PRVTKEY_Module_PDU_1,
    SIZE_PRVTKEY_Module_PDU_2,
    SIZE_PRVTKEY_Module_PDU_3,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL PRVTKEY_Module_Startup(void)
{
    PRVTKEY_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 4, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x74767270);
}

void ASN1CALL PRVTKEY_Module_Cleanup(void)
{
    ASN1_CloseModule(PRVTKEY_Module);
    PRVTKEY_Module = NULL;
}

static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_AttributeSetValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValue *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributeSetValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValue *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (NOCOPYANY *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributeSetValue(AttributeSetValue *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_Attribute(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (Attribute *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_Attribute(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attributes(Attributes *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_Attribute(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_Attribute(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_RSAPrivateKey(ASN1encoding_t enc, ASN1uint32_t tag, RSAPrivateKey *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->modulus))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->publicExponent))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->privateExponent))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->prime1))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->prime2))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->exponent1))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->exponent2))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->coefficient))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RSAPrivateKey(ASN1decoding_t dec, ASN1uint32_t tag, RSAPrivateKey *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->modulus))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->publicExponent))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->privateExponent))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->prime1))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->prime2))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->exponent1))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->exponent2))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->coefficient))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RSAPrivateKey(RSAPrivateKey *val)
{
    if (val) {
	ASN1intx_free(&(val)->modulus);
	ASN1intx_free(&(val)->privateExponent);
	ASN1intx_free(&(val)->prime1);
	ASN1intx_free(&(val)->prime2);
	ASN1intx_free(&(val)->exponent1);
	ASN1intx_free(&(val)->exponent2);
	ASN1intx_free(&(val)->coefficient);
    }
}

static int ASN1CALL ASN1Enc_PrivateKeyAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyAlgorithmIdentifier *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKeyAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyAlgorithmIdentifier *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKeyAlgorithmIdentifier(PrivateKeyAlgorithmIdentifier *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_PrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, PrivateKeyInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_PrivateKeyAlgorithmIdentifier(enc, 0, &(val)->privateKeyAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->privateKey).length, ((val)->privateKey).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Attributes(enc, 0x80000000, &(val)->privateKeyAttributes))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_PrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, PrivateKeyInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_PrivateKeyAlgorithmIdentifier(dd, 0, &(val)->privateKeyAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->privateKey))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Attributes(dd, 0x80000000, &(val)->privateKeyAttributes))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_PrivateKeyInfo(PrivateKeyInfo *val)
{
    if (val) {
	ASN1Free_PrivateKeyAlgorithmIdentifier(&(val)->privateKeyAlgorithm);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Attributes(&(val)->privateKeyAttributes);
	}
    }
}

static int ASN1CALL ASN1Enc_EncryptionAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, EncryptionAlgorithmIdentifier *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptionAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, EncryptionAlgorithmIdentifier *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptionAlgorithmIdentifier(EncryptionAlgorithmIdentifier *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_EncryptedPrivateKeyInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedPrivateKeyInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_EncryptionAlgorithmIdentifier(enc, 0, &(val)->encryptionAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->encryptedData).length, ((val)->encryptedData).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptedPrivateKeyInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedPrivateKeyInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_EncryptionAlgorithmIdentifier(dd, 0, &(val)->encryptionAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->encryptedData))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptedPrivateKeyInfo(EncryptedPrivateKeyInfo *val)
{
    if (val) {
	ASN1Free_EncryptionAlgorithmIdentifier(&(val)->encryptionAlgorithm);
    }
}

static int ASN1CALL ASN1Enc_Attribute(ASN1encoding_t enc, ASN1uint32_t tag, Attribute *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->type))
	return 0;
    if (!ASN1Enc_AttributeSetValue(enc, 0, &(val)->values))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attribute(ASN1decoding_t dec, ASN1uint32_t tag, Attribute *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->type))
	return 0;
    if (!ASN1Dec_AttributeSetValue(dd, 0, &(val)->values))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attribute(Attribute *val)
{
    if (val) {
	ASN1Free_AttributeSetValue(&(val)->values);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\pfxlib\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------


#define IDS_ROOT_MSG_BOX_TITLE              6100
#define IDS_ROOT_MSG_BOX_SUBJECT            6110
#define IDS_ROOT_MSG_BOX_ISSUER             6120
#define IDS_ROOT_MSG_BOX_SELF_ISSUED        6121
#define IDS_ROOT_MSG_BOX_SERIAL_NUMBER      6130
#define IDS_ROOT_MSG_BOX_SHA1_THUMBPRINT    6140
#define IDS_ROOT_MSG_BOX_MD5_THUMBPRINT     6150
#define IDS_ROOT_MSG_BOX_TIME_VALIDITY      6160
#define IDS_ROOT_MSG_BOX_ADD_ACTION         6170
#define IDS_ROOT_MSG_BOX_DELETE_ACTION      6180
#define	IDS_FRMT_SPACE						6200
#define	IDS_FRMT_A							6201
#define	IDS_FRMT_ZERO						6202
#define	IDS_FRMT_HEX						6203
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\pfxlib\pfxpkcs.h ===
/* Copyright (C) Microsoft Corporation, 1996 - 1999 All rights reserved. */
/* ASN.1 definitions for PFXPKCS */

#ifndef _PFXPKCS_Module_H_
#define _PFXPKCS_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef ASN1open_t AttributeSetValue_Set;

typedef ASN1objectidentifier2_t ObjectID;

typedef ObjectID ObjID;

typedef ASN1open_t Any;

typedef ObjectID ObjectIdentifierType;
#define ObjectIdentifierType_PDU 0
#define SIZE_PFXPKCS_Module_PDU_0 sizeof(ObjectIdentifierType)

typedef ASN1octetstring_t OctetStringType;
#define OctetStringType_PDU 1
#define SIZE_PFXPKCS_Module_PDU_1 sizeof(OctetStringType)

typedef ASN1intx_t IntegerType;
#define IntegerType_PDU 2
#define SIZE_PFXPKCS_Module_PDU_2 sizeof(IntegerType)

typedef ASN1intx_t HugeInteger;

typedef ASN1int32_t Version;

typedef ASN1octetstring_t PrivateKey;

typedef ASN1octetstring_t EncryptedContent;

typedef ASN1octetstring_t Digest;

typedef ObjectID ContentType;

typedef ASN1octetstring_t X509Cert;

typedef ASN1ztcharstring_t SDSICert;

typedef ASN1octetstring_t X509CRL;

typedef struct RSAPublicKey {
    HugeInteger modulus;
    HugeInteger publicExponent;
} RSAPublicKey;
#define RSAPublicKey_PDU 3
#define SIZE_PFXPKCS_Module_PDU_3 sizeof(RSAPublicKey)

typedef struct RSAPrivateKey {
    Version version;
    HugeInteger modulus;
    ASN1int32_t publicExponent;
    HugeInteger privateExponent;
    HugeInteger prime1;
    HugeInteger prime2;
    HugeInteger exponent1;
    HugeInteger exponent2;
    HugeInteger coefficient;
} RSAPrivateKey;
#define RSAPrivateKey_PDU 4
#define SIZE_PFXPKCS_Module_PDU_4 sizeof(RSAPrivateKey)

typedef struct AlgorithmIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID algorithm;
#   define parameters_present 0x80
    ASN1open_t parameters;
} AlgorithmIdentifier;

typedef struct PBEParameter {
    ASN1octetstring_t salt;
    ASN1int32_t iterationCount;
} PBEParameter;
#define PBEParameter_PDU 5
#define SIZE_PFXPKCS_Module_PDU_5 sizeof(PBEParameter)

typedef AlgorithmIdentifier DigestAlgorithmIdentifier;

typedef struct AttributeSetValue {
    ASN1uint32_t count;
    AttributeSetValue_Set *value;
} AttributeSetValue;
#define AttributeSetValue_PDU 6
#define SIZE_PFXPKCS_Module_PDU_6 sizeof(AttributeSetValue)

typedef struct Attribute {
    ObjectID attributeType;
    AttributeSetValue attributeValue;
} Attribute;

typedef struct Attributes {
    ASN1uint32_t count;
    struct Attribute *value;
} Attributes;
#define Attributes_PDU 7
#define SIZE_PFXPKCS_Module_PDU_7 sizeof(Attributes)

typedef struct ContentInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentType;
#   define content_present 0x80
    ASN1open_t content;
} ContentInfo;

typedef struct AuthenticatedSafes {
    ASN1uint32_t count;
    struct ContentInfo *value;
} AuthenticatedSafes;
#define AuthenticatedSafes_PDU 8
#define SIZE_PFXPKCS_Module_PDU_8 sizeof(AuthenticatedSafes)

typedef struct SafeContents {
    ASN1uint32_t count;
    struct SafeBag *value;
} SafeContents;
#define SafeContents_PDU 9
#define SIZE_PFXPKCS_Module_PDU_9 sizeof(SafeContents)

typedef struct SafeBag {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID safeBagType;
    ASN1open_t safeBagContent;
#   define safeBagAttribs_present 0x80
    Attributes safeBagAttribs;
} SafeBag;
#define SafeBag_PDU 10
#define SIZE_PFXPKCS_Module_PDU_10 sizeof(SafeBag)

typedef struct CertBag {
    ObjectID certType;
    ASN1open_t value;
} CertBag;
#define CertBag_PDU 11
#define SIZE_PFXPKCS_Module_PDU_11 sizeof(CertBag)

typedef struct CRLBag {
    ObjectID crlType;
    ASN1open_t value;
} CRLBag;
#define CRLBag_PDU 12
#define SIZE_PFXPKCS_Module_PDU_12 sizeof(CRLBag)

typedef struct SecretBag {
    ObjectID secretType;
    ASN1open_t secretContent;
} SecretBag;
#define SecretBag_PDU 13
#define SIZE_PFXPKCS_Module_PDU_13 sizeof(SecretBag)

typedef AlgorithmIdentifier PrivateKeyAlgorithmIdentifier;

typedef AlgorithmIdentifier EncryptionAlgorithmIdentifier;

typedef AlgorithmIdentifier ContentEncryptionAlgorithmIdentifier;

typedef struct DigestInfo {
    DigestAlgorithmIdentifier digestAlgorithm;
    Digest digest;
} DigestInfo;
#define DigestInfo_PDU 14
#define SIZE_PFXPKCS_Module_PDU_14 sizeof(DigestInfo)

typedef struct MacData {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    DigestInfo safeMac;
    ASN1octetstring_t macSalt;
#   define macIterationCount_present 0x80
    ASN1int32_t macIterationCount;
} MacData;
#define MacData_PDU 15
#define SIZE_PFXPKCS_Module_PDU_15 sizeof(MacData)

typedef struct PrivateKeyInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Version version;
    PrivateKeyAlgorithmIdentifier privateKeyAlgorithm;
    PrivateKey privateKey;
#   define attributes_present 0x80
    Attributes attributes;
} PrivateKeyInfo;
#define PrivateKeyInfo_PDU 16
#define SIZE_PFXPKCS_Module_PDU_16 sizeof(PrivateKeyInfo)

typedef struct EncryptedContentInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentType;
    ContentEncryptionAlgorithmIdentifier contentEncryptionAlg;
#   define encryptedContent_present 0x80
    EncryptedContent encryptedContent;
} EncryptedContentInfo;

typedef struct PFX {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Version version;
    ContentInfo authSafes;
#   define macData_present 0x80
    MacData macData;
} PFX;
#define PFX_PDU 17
#define SIZE_PFXPKCS_Module_PDU_17 sizeof(PFX)

typedef PrivateKeyInfo KeyBag;
#define KeyBag_PDU 18
#define SIZE_PFXPKCS_Module_PDU_18 sizeof(KeyBag)

typedef struct EncryptedData {
    Version version;
    EncryptedContentInfo encryptedContentInfo;
} EncryptedData;
#define EncryptedData_PDU 19
#define SIZE_PFXPKCS_Module_PDU_19 sizeof(EncryptedData)

typedef struct EncryptedPrivateKeyInfo {
    EncryptionAlgorithmIdentifier encryptionAlgorithm;
    EncryptedData encryptedData;
} EncryptedPrivateKeyInfo;
#define EncryptedPrivateKeyInfo_PDU 20
#define SIZE_PFXPKCS_Module_PDU_20 sizeof(EncryptedPrivateKeyInfo)

typedef EncryptedPrivateKeyInfo Pkcs_8ShroudedKeyBag;
#define Pkcs_8ShroudedKeyBag_PDU 21
#define SIZE_PFXPKCS_Module_PDU_21 sizeof(Pkcs_8ShroudedKeyBag)

extern ASN1int32_t MacData_macIterationCount_default;

extern ASN1module_t PFXPKCS_Module;
extern void ASN1CALL PFXPKCS_Module_Startup(void);
extern void ASN1CALL PFXPKCS_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _PFXPKCS_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\pfxlib\sha.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       sha.h
//
//--------------------------------------------------------------------------

/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifndef _SHA_H_
#define _SHA_H_ 1

#ifdef __cplusplus
extern "C" {
#endif

#include "shacomm.h"

typedef struct {
	DWORD		FinishFlag;
	BYTE		HashVal[A_SHA_DIGEST_LEN];
	A_SHA_COMM_CTX	commonContext;
} A_SHA_CTX;

void A_SHAInit(A_SHA_CTX *);
void A_SHAUpdate(A_SHA_CTX *, unsigned char *, unsigned int);
void A_SHAFinal(A_SHA_CTX *, unsigned char [A_SHA_DIGEST_LEN]);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\pfxlib\randlib.h ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : randlib.h                                             //
//  DESCRIPTION   :                                                        //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Oct 11 1996 jeffspel moved from ntagimp1.h                                        //
//                                                                         //
//  Copyright (C) Microsoft Corporation, 1993 - 1999All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////

#ifndef __RANDLIB_H__
#define __RANDLIB_H__

#ifdef __cplusplus
extern "C" {
#endif

// Additons for the New CryptGenRandom 

// #defines
#define RAND_CTXT_LEN 60
#define RC4_REKEY_PARAM 500             // rekey every 500 bytes

typedef struct _RandContext
{
	DWORD   dwBitsFilled;
	BYTE    rgbBitBuffer[RAND_CTXT_LEN];
}       RandContext;

// prototypes
BOOL NewGenRandom (
                   IN OUT PBYTE *ppbRandSeed,
                   IN PDWORD pcbRandSeed,
                   IN OUT BYTE *pbBuffer,
                   IN size_t dwLength
                   );

BOOL InitRand(
              IN OUT PBYTE *ppbRandSeed,
              IN PDWORD pcbRandSeed
              );

BOOL DeInitRand(
                IN OUT PBYTE pbRandSeed,
                IN DWORD cbRandSeed
                );

// DO NOT USE THIS CALL ANYMORE SHOULD ONLY BE USED BY RSA32 BSafeMakeKeyPair
// Instead now use NewGenRandom
BOOL GenRandom (
                IN HCRYPTPROV hUID,
                OUT BYTE *pbBuffer,
                IN size_t dwLength
                );


BOOL RandomFillBuffer(
                      OUT BYTE *pbBuffer,
                      IN DWORD *pdwLength
                      );

void GatherRandomBits(
                      IN OUT RandContext *prandContext
                      );

void AppendRand(RandContext* prandContext, void* pv, DWORD dwSize);


#ifdef __cplusplus
}
#endif

#endif // __RANDLIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\pfxlib\shacomm.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       shacomm.h
//
//--------------------------------------------------------------------------

/* Copyright (C) RSA Data Security, Inc. created 1993.  This is an
   unpublished work protected as such under copyright law.  This work
   contains proprietary, confidential, and trade secret information of
   RSA Data Security, Inc.  Use, disclosure or reproduction without the
   express written authorization of RSA Data Security, Inc. is
   prohibited.
 */

#ifndef _SHACOMM_H_
#define _SHACOMM_H_ 1

#define A_SHA_DIGEST_LEN 20

typedef struct {
  DWORD state[5];                                           /* state (ABCDE) */
  DWORD count[2];                              /* number of bytes, msb first */
  unsigned char buffer[64];                                  /* input buffer */
} A_SHA_COMM_CTX;

typedef void (A_SHA_TRANSFORM) (DWORD [5], unsigned char [64]);

void A_SHAInitCommon (A_SHA_COMM_CTX *);
void A_SHAUpdateCommon(A_SHA_COMM_CTX *, BYTE *, DWORD, A_SHA_TRANSFORM *);
void A_SHAFinalCommon(A_SHA_COMM_CTX *, BYTE[A_SHA_DIGEST_LEN],
		      A_SHA_TRANSFORM *);

void DWORDToBigEndian(unsigned char *, DWORD *, unsigned int);
void DWORDFromBigEndian(DWORD *, unsigned int, unsigned char *);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\pfxlib\prvtkey.h ===
/* Copyright (C) Microsoft Corporation, 1996 - 1999 All rights reserved. */
/* ASN.1 definitions for X509 v3 certificates */

#ifndef _PRVTKEY_Module_H_
#define _PRVTKEY_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef ASN1intx_t HUGEINTEGER;

typedef ASN1bitstring_t BITSTRING;

typedef ASN1octetstring_t OCTETSTRING;

typedef ASN1open_t NOCOPYANY;

typedef ASN1charstring_t NUMERICSTRING;

typedef ASN1charstring_t PRINTABLESTRING;

typedef ASN1charstring_t TELETEXSTRING;

typedef ASN1charstring_t T61STRING;

typedef ASN1charstring_t VIDEOTEXSTRING;

typedef ASN1charstring_t IA5STRING;

typedef ASN1charstring_t GRAPHICSTRING;

typedef ASN1charstring_t VISIBLESTRING;

typedef ASN1charstring_t ISO646STRING;

typedef ASN1charstring_t GENERALSTRING;

typedef ASN1char32string_t UNIVERSALSTRING;

typedef ASN1char16string_t BMPSTRING;

typedef ASN1objectidentifier2_t ObjectID;

typedef ASN1int32_t Version;

typedef OCTETSTRING PrivateKey;

typedef OCTETSTRING EncryptedData;

typedef struct AlgorithmIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID algorithm;
#   define parameters_present 0x80
    NOCOPYANY parameters;
} AlgorithmIdentifier;

typedef struct AttributeSetValue {
    ASN1uint32_t count;
    NOCOPYANY *value;
} AttributeSetValue;

typedef struct Attributes {
    ASN1uint32_t count;
    struct Attribute *value;
} Attributes;

typedef struct RSAPrivateKey {
    Version version;
    HUGEINTEGER modulus;
    ASN1int32_t publicExponent;
    HUGEINTEGER privateExponent;
    HUGEINTEGER prime1;
    HUGEINTEGER prime2;
    HUGEINTEGER exponent1;
    HUGEINTEGER exponent2;
    HUGEINTEGER coefficient;
} RSAPrivateKey;
#define RSAPrivateKey_PDU 0
#define SIZE_PRVTKEY_Module_PDU_0 sizeof(RSAPrivateKey)

typedef AlgorithmIdentifier PrivateKeyAlgorithmIdentifier;

typedef struct PrivateKeyInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    Version version;
    PrivateKeyAlgorithmIdentifier privateKeyAlgorithm;
    PrivateKey privateKey;
#   define privateKeyAttributes_present 0x80
    Attributes privateKeyAttributes;
} PrivateKeyInfo;
#define PrivateKeyInfo_PDU 1
#define SIZE_PRVTKEY_Module_PDU_1 sizeof(PrivateKeyInfo)

typedef AlgorithmIdentifier EncryptionAlgorithmIdentifier;

typedef struct EncryptedPrivateKeyInfo {
    EncryptionAlgorithmIdentifier encryptionAlgorithm;
    EncryptedData encryptedData;
} EncryptedPrivateKeyInfo;
#define EncryptedPrivateKeyInfo_PDU 2
#define SIZE_PRVTKEY_Module_PDU_2 sizeof(EncryptedPrivateKeyInfo)

typedef struct Attribute {
    ObjectID type;
    AttributeSetValue values;
} Attribute;
#define Attribute_PDU 3
#define SIZE_PRVTKEY_Module_PDU_3 sizeof(Attribute)


extern ASN1module_t PRVTKEY_Module;
extern void ASN1CALL PRVTKEY_Module_Startup(void);
extern void ASN1CALL PRVTKEY_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _PRVTKEY_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\cba.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cba.cpp
//
//  Contents:   Implementation of CCryptBlobArray
//
//  History:    23-Jul-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Member:     CCryptBlobArray::CCryptBlobArray, public
//
//  Synopsis:   Initialize the internal CRYPT_BLOB_ARRAY
//
//----------------------------------------------------------------------------
CCryptBlobArray::CCryptBlobArray (
                       ULONG cMinBlobs,
                       ULONG cGrowBlobs,
                       BOOL& rfResult
                       )
{
    rfResult = TRUE;
    m_cGrowBlobs = cGrowBlobs;
    m_cba.cBlob = 0;
    m_cba.rgBlob = new CRYPT_DATA_BLOB [cMinBlobs];
    if ( m_cba.rgBlob != NULL )
    {
        memset( m_cba.rgBlob, 0, sizeof(CRYPT_DATA_BLOB)*cMinBlobs );
        m_cArray = cMinBlobs;
    }
    else
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        rfResult = FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptBlobArray::CCryptBlobArray, public
//
//  Synopsis:   Initialize the internal CRYPT_BLOB_ARRAY with a native form
//              blob array created via ::GetArrayInNativeForm
//
//----------------------------------------------------------------------------
CCryptBlobArray::CCryptBlobArray (
                       PCRYPT_BLOB_ARRAY pcba,
                       ULONG cGrowBlobs
                       )
{
    m_cGrowBlobs = cGrowBlobs;
    m_cba.cBlob = pcba->cBlob;
    m_cba.rgBlob = pcba->rgBlob;
    m_cArray = pcba->cBlob;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptBlobArray::AllocBlob, public, static
//
//  Synopsis:   allocate a blob using the same allocator used for ::AddBlob
//              copies.  This means that the resulting blob can be added
//              without copying.
//
//----------------------------------------------------------------------------
LPBYTE
CCryptBlobArray::AllocBlob (ULONG cb)
{
    return( (LPBYTE)CryptMemAlloc( cb ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptBlobArray::ReallocBlob, public, static
//
//  Synopsis:   see ::AllocBlob
//
//----------------------------------------------------------------------------
LPBYTE
CCryptBlobArray::ReallocBlob (LPBYTE pb, ULONG cb)
{
    return( (LPBYTE)CryptMemRealloc( pb, cb ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptBlobArray::FreeBlob, public
//
//  Synopsis:   free blob allocated using ::AllocBlob or ::ReallocBlob
//
//----------------------------------------------------------------------------
VOID
CCryptBlobArray::FreeBlob (LPBYTE pb)
{
    CryptMemFree( pb );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptBlobArray::AddBlob, public
//
//  Synopsis:   add a blob
//
//----------------------------------------------------------------------------
BOOL
CCryptBlobArray::AddBlob (
                    ULONG cb,
                    LPBYTE pb,
                    BOOL fCopyBlob
                    )
{
    BOOL   fResult = TRUE;
    LPBYTE pbToUse;

    //
    // If we need to copy the blob, do so
    //

    if ( fCopyBlob == TRUE )
    {
        pbToUse = AllocBlob( cb );
        if ( pbToUse != NULL )
        {
            memcpy( pbToUse, pb, cb );
        }
        else
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            return( FALSE );
        }
    }
    else
    {
        pbToUse = pb;
    }

    //
    // If we need to grow the array, do so
    //

    if ( m_cArray == m_cba.cBlob )
    {
        fResult = GrowArray();
    }

    //
    // Add the blob to the array
    //

    if ( fResult == TRUE )
    {
        m_cba.rgBlob[m_cba.cBlob].cbData = cb;
        m_cba.rgBlob[m_cba.cBlob].pbData = pbToUse;
        m_cba.cBlob += 1;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptBlobArray::GetBlob, public
//
//  Synopsis:   gets blob given an index
//
//----------------------------------------------------------------------------
PCRYPT_DATA_BLOB
CCryptBlobArray::GetBlob (ULONG index)
{
    assert( m_cba.cBlob > index );

    return( &m_cba.rgBlob[index] );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptBlobArray::GetBlobCount, public
//
//  Synopsis:   get the count of blobs
//
//----------------------------------------------------------------------------
ULONG
CCryptBlobArray::GetBlobCount ()
{
    return( m_cba.cBlob );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptBlobArray::GetArrayInNativeForm, public
//
//  Synopsis:   get the array in native form
//
//----------------------------------------------------------------------------
VOID
CCryptBlobArray::GetArrayInNativeForm (PCRYPT_BLOB_ARRAY pcba)
{
    pcba->cBlob = m_cba.cBlob;
    pcba->rgBlob = m_cba.rgBlob;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptBlobArray::GetArrayInSingleBufferEncodedForm, public
//
//  Synopsis:   gets the array in a single buffer encoded form
//
//----------------------------------------------------------------------------
BOOL
CCryptBlobArray::GetArrayInSingleBufferEncodedForm (
                         PCRYPT_BLOB_ARRAY* ppcba,
                         ULONG* pcb
                         )
{
    ULONG             cbStruct;
    ULONG             cbPointers;
    ULONG             cbData;
    ULONG             cb;
    ULONG             cbSize;
    ULONG             cCount;
    PCRYPT_BLOB_ARRAY pcba = NULL;

    //
    // Calculate the buffer size we will need and allocate it
    //

    cbStruct = sizeof( CRYPT_BLOB_ARRAY );
    cbPointers = m_cba.cBlob * sizeof( CRYPT_DATA_BLOB );

    for ( cCount = 0, cbData = 0; cCount < m_cba.cBlob; cCount++ )
    {
        cbData += m_cba.rgBlob[cCount].cbData;
    }

    cbSize = cbStruct + cbPointers + cbData;
    pcba = (PCRYPT_BLOB_ARRAY)CryptMemAlloc( cbSize );
    if ( pcba == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    //
    // Fill in the data
    //

    pcba->cBlob = m_cba.cBlob;
    pcba->rgBlob = (PCRYPT_DATA_BLOB)((LPBYTE)pcba+cbStruct);

    __try
    {
        for ( cCount = 0, cb = 0; cCount < m_cba.cBlob; cCount++ )
        {
            pcba->rgBlob[cCount].cbData = m_cba.rgBlob[cCount].cbData;
            pcba->rgBlob[cCount].pbData = (LPBYTE)pcba+cbStruct+cbPointers+cb;

            memcpy(
               pcba->rgBlob[cCount].pbData,
               m_cba.rgBlob[cCount].pbData,
               m_cba.rgBlob[cCount].cbData
               );

            cb += m_cba.rgBlob[cCount].cbData;
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        CryptMemFree( pcba );
        SetLastError( GetExceptionCode() );
        return( FALSE );
    }

    *ppcba = pcba;

    if ( pcb != NULL )
    {
        *pcb = cbSize;
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptBlobArray::FreeArray, public
//
//  Synopsis:   frees the array and optionally frees the blobs
//
//----------------------------------------------------------------------------
VOID
CCryptBlobArray::FreeArray (BOOL fFreeBlobs)
{
    if ( fFreeBlobs == TRUE )
    {
        ULONG cCount;

        for ( cCount = 0; cCount < m_cba.cBlob; cCount++ )
        {
            FreeBlob( m_cba.rgBlob[cCount].pbData );
        }
    }

    delete m_cba.rgBlob;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptBlobArray::GrowArray, private
//
//  Synopsis:   grows the array
//
//----------------------------------------------------------------------------
BOOL
CCryptBlobArray::GrowArray ()
{
    ULONG            cNewArray;
    PCRYPT_DATA_BLOB pcba;

    //
    // Check if we are allowed to grow
    //
    //

    if ( m_cGrowBlobs == 0 )
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    //
    // Allocate and initialize the new array
    //

    cNewArray = m_cArray + m_cGrowBlobs;
    pcba = new CRYPT_DATA_BLOB [cNewArray];
    if ( pcba == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    memset(pcba, 0, cNewArray*sizeof( CRYPT_DATA_BLOB ));

    //
    // Copy the old to the new
    //

    memcpy(pcba, m_cba.rgBlob, m_cba.cBlob*sizeof( CRYPT_DATA_BLOB ) );

    //
    // Free the old and use the new
    //

    delete m_cba.rgBlob;
    m_cba.rgBlob = pcba;
    m_cArray = cNewArray;

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\cgou.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cgou.cpp
//
//  Contents:   CryptGetObjectUrl implementation
//
//  History:    16-Sep-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Function:   CryptGetObjectUrl
//
//  Synopsis:   get a locator from a CAPI object
//
//----------------------------------------------------------------------------
BOOL WINAPI
CryptGetObjectUrl (
     IN LPCSTR pszUrlOid,
     IN LPVOID pvPara,
     IN DWORD dwFlags,
     OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
     IN OUT DWORD* pcbUrlArray,
     OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
     IN OUT OPTIONAL DWORD* pcbUrlInfo,
     IN OPTIONAL LPVOID pvReserved
     )
{
    BOOL                    fResult;
    HCRYPTOIDFUNCADDR       hGetObjectUrl;
    PFN_GET_OBJECT_URL_FUNC pfnGetObjectUrl;
    DWORD                   LastError;

    if ( CryptGetOIDFunctionAddress(
              hGetObjectUrlFuncSet,
              X509_ASN_ENCODING,
              pszUrlOid,
              0,
              (LPVOID *)&pfnGetObjectUrl,
              &hGetObjectUrl
              ) == FALSE )
    {
        return( FALSE );
    }

    if ( dwFlags == 0 )
    {
        dwFlags |= CRYPT_GET_URL_FROM_PROPERTY;
        dwFlags |= CRYPT_GET_URL_FROM_EXTENSION;
        dwFlags |= CRYPT_GET_URL_FROM_UNAUTH_ATTRIBUTE;
        dwFlags |= CRYPT_GET_URL_FROM_AUTH_ATTRIBUTE;
    }

    fResult = ( *pfnGetObjectUrl )(
                       pszUrlOid,
                       pvPara,
                       dwFlags,
                       pUrlArray,
                       pcbUrlArray,
                       pUrlInfo,
                       pcbUrlInfo,
                       pvReserved
                       );

    LastError = GetLastError();
    CryptFreeOIDFunctionAddress( hGetObjectUrl, 0 );
    SetLastError( LastError );

    return( fResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\crobu.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       crobu.h
//
//  Contents:   CryptRetrieveObjectByUrl and support functions
//
//  History:    02-Jun-00    philh    Created
//
//----------------------------------------------------------------------------
#if !defined(__CRYPTNET_CROBU_H__)
#define __CRYPTNET_CROBU_H__

VOID
WINAPI
InitializeCryptRetrieveObjectByUrl(
    HMODULE hModule
    );

VOID
WINAPI
DeleteCryptRetrieveObjectByUrl();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\cba.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cba.h
//
//  Contents:   CCryptBlobArray class definition
//
//  History:    23-Jul-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__CBA_H__)
#define __CBA_H__

#include <windows.h>
#include <wincrypt.h>

//
// class CCryptBlobArray.  This class manages a CRYPT_BLOB_ARRAY structure.
// Note that the freeing of the internal array structure must be done
// explicitly
//

class CCryptBlobArray
{
public:

    //
    // Construction
    //

    CCryptBlobArray (ULONG cMinBlobs, ULONG cGrowBlobs, BOOL& rfResult);

    // NOTE: Only accepts native form blob arrays or read-only single buffer
    //       encoded arrays
    CCryptBlobArray (PCRYPT_BLOB_ARRAY pcba, ULONG cGrowBlobs);

    ~CCryptBlobArray () {};

    //
    // Blob management methods
    //

    static LPBYTE AllocBlob (ULONG cb);
    static LPBYTE ReallocBlob (LPBYTE pb, ULONG cb);
    static VOID FreeBlob (LPBYTE pb);

    BOOL AddBlob (ULONG cb, LPBYTE pb, BOOL fCopyBlob);

    PCRYPT_DATA_BLOB GetBlob (ULONG index);

    //
    // Array management methods
    //

    ULONG GetBlobCount ();

    VOID GetArrayInNativeForm (PCRYPT_BLOB_ARRAY pcba);

    BOOL GetArrayInSingleBufferEncodedForm (
                 PCRYPT_BLOB_ARRAY* ppcba,
                 ULONG* pcb = NULL
                 );

    VOID FreeArray (BOOL fFreeBlobs);

private:

    //
    // Internal blob array
    //

    CRYPT_BLOB_ARRAY m_cba;

    //
    // Current blob array size
    //

    ULONG            m_cArray;

    //
    // Grow blobs by
    //

    ULONG            m_cGrowBlobs;

    //
    // Private methods
    //

    BOOL GrowArray ();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\cua.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cua.cpp
//
//  Contents:   CCryptUrlArray implementation
//
//  History:    16-Sep-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Member:     CCryptUrlArray::CCryptUrlArray, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CCryptUrlArray::CCryptUrlArray (ULONG cMinUrls, ULONG cGrowUrls, BOOL& rfResult)
{
    rfResult = TRUE;
    m_cGrowUrls = cGrowUrls;
    m_cua.cUrl = 0;
    m_cua.rgwszUrl = new LPWSTR [cMinUrls];
    if ( m_cua.rgwszUrl != NULL )
    {
        memset( m_cua.rgwszUrl, 0, sizeof(LPWSTR)*cMinUrls );
        m_cArray = cMinUrls;
    }
    else
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        rfResult = FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptUrlArray::CCryptUrlArray, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CCryptUrlArray::CCryptUrlArray (PCRYPT_URL_ARRAY pcua, ULONG cGrowUrls)
{
    m_cGrowUrls = cGrowUrls;
    m_cua.cUrl = pcua->cUrl;
    m_cua.rgwszUrl = pcua->rgwszUrl;
    m_cArray = pcua->cUrl;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptUrlArray::AllocUrl, public, static
//
//  Synopsis:   allocate an URL using the same allocator used for ::AddUrl
//              copies.  This means that the resulting URL can be added
//              without copying.
//
//----------------------------------------------------------------------------
LPWSTR
CCryptUrlArray::AllocUrl (ULONG cw)
{
    return( (LPWSTR)CryptMemAlloc( cw * sizeof( WCHAR ) ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptUrlArray::ReallocUrl, public, static
//
//  Synopsis:   see ::AllocUrl
//
//----------------------------------------------------------------------------
LPWSTR
CCryptUrlArray::ReallocUrl (LPWSTR pwszUrl, ULONG cw)
{
    return( (LPWSTR)CryptMemRealloc( pwszUrl, cw * sizeof( WCHAR ) ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptUrlArray::FreeUrl, public, static
//
//  Synopsis:   free URL allocated using ::AllocBlob or ::ReallocBlob
//
//----------------------------------------------------------------------------
VOID
CCryptUrlArray::FreeUrl (LPWSTR pwszUrl)
{
    CryptMemFree( pwszUrl );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptUrlArray::AddUrl, public
//
//  Synopsis:   add an URL to the array
//
//----------------------------------------------------------------------------
BOOL
CCryptUrlArray::AddUrl (LPWSTR pwszUrl, BOOL fCopyUrl)
{
    BOOL   fResult = TRUE;
    LPWSTR pwszToUse;

    //
    // If we need to copy the URL, do so
    //

    if ( fCopyUrl == TRUE )
    {
        ULONG cw = wcslen( pwszUrl ) + 1;

        pwszToUse = AllocUrl( cw );
        if ( pwszToUse != NULL )
        {
            memcpy( pwszToUse, pwszUrl, cw * sizeof( WCHAR ) );
        }
        else
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            return( FALSE );
        }
    }
    else
    {
        pwszToUse = pwszUrl;
    }

    //
    // If we need to grow the array, do so
    //

    if ( m_cArray == m_cua.cUrl )
    {
        fResult = GrowArray();
    }

    //
    // Add the URL to the array
    //

    if ( fResult == TRUE )
    {
        m_cua.rgwszUrl[m_cua.cUrl] = pwszToUse;
        m_cua.cUrl += 1;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptUrlArray::GetUrl, public
//
//  Synopsis:   get an URL from the array
//
//----------------------------------------------------------------------------
LPWSTR
CCryptUrlArray::GetUrl (ULONG Index)
{
    assert( m_cua.cUrl > Index );

    return( m_cua.rgwszUrl[Index] );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptUrlArray::GetUrlCount, public
//
//  Synopsis:   get the count of URLs in the array
//
//----------------------------------------------------------------------------
ULONG
CCryptUrlArray::GetUrlCount ()
{
    return( m_cua.cUrl );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptUrlArray::GetArrayInNativeForm, public
//
//  Synopsis:   get the array in native form
//
//----------------------------------------------------------------------------
VOID
CCryptUrlArray::GetArrayInNativeForm (PCRYPT_URL_ARRAY pcua)
{
    pcua->cUrl = m_cua.cUrl;
    pcua->rgwszUrl = m_cua.rgwszUrl;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptUrlArray::GetArrayInSingleBufferEncodedForm, public
//
//  Synopsis:   get the array encoded in a single buffer
//
//----------------------------------------------------------------------------
BOOL
CCryptUrlArray::GetArrayInSingleBufferEncodedForm (
                        PCRYPT_URL_ARRAY* ppcua,
                        ULONG* pcb
                        )
{
    ULONG            cbStruct;
    ULONG            cbPointers;
    ULONG            cbData;
    ULONG            cb;
    ULONG            cbSize;
    ULONG            cCount;
    PCRYPT_URL_ARRAY pcua = NULL;
    ULONG            cbUrl;

    //
    // Calculate the buffer size we will need and allocate it
    //

    cbStruct = sizeof( CRYPT_URL_ARRAY );
    cbPointers = m_cua.cUrl * sizeof( LPWSTR );

    for ( cCount = 0, cbData = 0; cCount < m_cua.cUrl; cCount++ )
    {
        cbData += ( wcslen( m_cua.rgwszUrl[cCount] ) + 1 ) * sizeof( WCHAR );
    }

    cbSize = cbStruct + cbPointers + cbData;

    if ( ppcua == NULL )
    {
        if ( pcb != NULL )
        {
            *pcb = cbSize;
            return( TRUE );
        }

        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    if ( *ppcua == NULL )
    {
        pcua = (PCRYPT_URL_ARRAY)CryptMemAlloc( cbSize );
        if ( pcua == NULL )
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            return( FALSE );
        }
    }
    else
    {
        if ( pcb == NULL )
        {
            SetLastError( (DWORD) E_INVALIDARG );
            return( FALSE );
        }
        else if ( *pcb < cbSize )
        {
            SetLastError( (DWORD) E_INVALIDARG );
            return( FALSE );
        }

        pcua = *ppcua;
    }

    //
    // Fill in the data
    //

    pcua->cUrl = m_cua.cUrl;
    pcua->rgwszUrl = (LPWSTR *)((LPBYTE)pcua+cbStruct);

    for ( cCount = 0, cb = 0; cCount < m_cua.cUrl; cCount++ )
    {
        pcua->rgwszUrl[cCount] = (LPWSTR)((LPBYTE)pcua+cbStruct+cbPointers+cb);

        cbUrl = ( wcslen( m_cua.rgwszUrl[cCount] ) + 1 ) * sizeof( WCHAR );

        memcpy( pcua->rgwszUrl[cCount], m_cua.rgwszUrl[cCount], cbUrl );

        cb += cbUrl;
    }

    if ( *ppcua != pcua )
    {
        *ppcua = pcua;

        if ( pcb != NULL )
        {
            *pcb = cbSize;
        }
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptUrlArray::FreeArray, public
//
//  Synopsis:   free the URL array
//
//----------------------------------------------------------------------------
VOID
CCryptUrlArray::FreeArray (BOOL fFreeUrls)
{
    if ( fFreeUrls == TRUE )
    {
        ULONG cCount;

        for ( cCount = 0; cCount < m_cua.cUrl; cCount++ )
        {
            FreeUrl( m_cua.rgwszUrl[cCount] );
        }
    }

    delete m_cua.rgwszUrl;
}

//+---------------------------------------------------------------------------
//
//  Member:     CCryptUrlArray::GrowArray, private
//
//  Synopsis:   grow the URL array
//
//----------------------------------------------------------------------------
BOOL
CCryptUrlArray::GrowArray ()
{
    ULONG   cNewArray;
    LPWSTR* rgwsz;

    //
    // Check if we are allowed to grow
    //
    //

    if ( m_cGrowUrls == 0 )
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    //
    // Allocate and initialize the new array
    //

    cNewArray = m_cArray + m_cGrowUrls;
    rgwsz = new LPWSTR [cNewArray];
    if ( rgwsz == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    memset( rgwsz, 0, cNewArray * sizeof( LPWSTR ) );

    //
    // Copy the old to the new
    //

    memcpy( rgwsz, m_cua.rgwszUrl, m_cua.cUrl*sizeof( LPWSTR ) );

    //
    // Free the old and use the new
    //

    delete m_cua.rgwszUrl;
    m_cua.rgwszUrl = rgwsz;
    m_cArray = cNewArray;

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\cua.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       cua.h
//
//  Contents:   CCryptUrlArray class definition
//
//  History:    16-Sep-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__CUA_H__)
#define __CUA_H__

#include <windows.h>
#include <wincrypt.h>

//
// CCryptUrlArray.  This class manages a CRYPT_URL_ARRAY structure.  Note that
// the freeing of the internal array structure must be done explicitly
//

class CCryptUrlArray
{
public:

    //
    // Construction
    //

    CCryptUrlArray (ULONG cMinUrls, ULONG cGrowUrls, BOOL& rfResult);

    // NOTE: Only accepts native form URL arrays or read-only single buffer
    //       encoded arrays
    CCryptUrlArray (PCRYPT_URL_ARRAY pcua, ULONG cGrowUrls);

    ~CCryptUrlArray () {};

    //
    // URL management methods
    //

    static LPWSTR AllocUrl (ULONG cw);
    static LPWSTR ReallocUrl (LPWSTR pwszUrl, ULONG cw);
    static VOID FreeUrl (LPWSTR pwszUrl);

    BOOL AddUrl (LPWSTR pwszUrl, BOOL fCopyUrl);

    LPWSTR GetUrl (ULONG Index);

    //
    // Array management methods
    //

    DWORD GetUrlCount ();

    VOID GetArrayInNativeForm (PCRYPT_URL_ARRAY pcua);

    BOOL GetArrayInSingleBufferEncodedForm (
                 PCRYPT_URL_ARRAY* ppcua,
                 ULONG* pcb = NULL
                 );

    VOID FreeArray (BOOL fFreeUrls);

private:

    //
    // Internal URL array
    //

    CRYPT_URL_ARRAY m_cua;

    //
    // Current URL array size
    //

    ULONG           m_cArray;

    //
    // Grow URLs by
    //

    ULONG           m_cGrowUrls;

    //
    // Private methods
    //

    BOOL GrowArray ();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\demand.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       demand.cpp
//
//  Contents:   On demand loading of wininet.dll
//
//  History:    12-Dec-98    philh    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <winwlx.h>

CRITICAL_SECTION DemandLoadCriticalSection;
HMODULE hDllWininet = NULL;
DWORD dwWininetRefCnt = 0;

// The following is set by CryptnetWlxLogoffEvent()
BOOL fUnloadWininet = FALSE;

//+---------------------------------------------------------------------------
//
//  Function:   DemandLoadDllMain
//
//  Synopsis:   DLL Main like initialization of on demand loading
//
//----------------------------------------------------------------------------
BOOL WINAPI DemandLoadDllMain (
                HMODULE hModule,
                ULONG ulReason,
                LPVOID pvReserved
                )
{
    BOOL fRet = TRUE;

    switch ( ulReason )
    {
    case DLL_PROCESS_ATTACH:
        fRet = Pki_InitializeCriticalSection(&DemandLoadCriticalSection);
        break;
    case DLL_THREAD_ATTACH:
        break;
    case DLL_PROCESS_DETACH:
        if (hDllWininet) {
            // assert(0 == dwWininetRefCnt);
            // assert(FALSE == fUnloadWininet);

            FreeLibrary(hDllWininet);
            hDllWininet = NULL;
        }
        DeleteCriticalSection(&DemandLoadCriticalSection );
        break;
    case DLL_THREAD_DETACH:
        break;
    }

    return( fRet );
}


void *
WINAPI
ICN_GetWininetProcAddress(
    IN LPCSTR pszProc
    )
{
    void *pvProc;

    EnterCriticalSection(&DemandLoadCriticalSection);
    if (NULL == hDllWininet) {
        assert(0 == dwWininetRefCnt);
        assert(FALSE == fUnloadWininet);
        hDllWininet = LoadLibraryA("wininet.dll");

        if (NULL == hDllWininet) {
            pvProc = NULL;
            goto CommonReturn;
        } else {
            dwWininetRefCnt = 0;
            fUnloadWininet = FALSE;
        }
    }

    
    if (pvProc = GetProcAddress(hDllWininet, pszProc)) {
        dwWininetRefCnt++;
    }

CommonReturn:
    LeaveCriticalSection(&DemandLoadCriticalSection);
    return pvProc;
}

void
WINAPI
ICN_ReleaseWininet()
{
    DWORD dwErr;

    dwErr = GetLastError();
    EnterCriticalSection(&DemandLoadCriticalSection);
    assert(0 < dwWininetRefCnt);
    if (0 < dwWininetRefCnt) {
        dwWininetRefCnt--;

        if (fUnloadWininet && 0 == dwWininetRefCnt) {
            fUnloadWininet = FALSE;

            FreeLibrary(hDllWininet);
            hDllWininet = NULL;
        }
    }

    LeaveCriticalSection(&DemandLoadCriticalSection);
    SetLastError(dwErr);
}


typedef BOOL (WINAPI *PFN_InternetSetOptionA)(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    );

//+---------------------------------------------------------------------------
//
//  Function:   CryptnetWlxLogoffEvent
//
//  Synopsis:   logoff event processing
//
//----------------------------------------------------------------------------
BOOL WINAPI
CryptnetWlxLogoffEvent (PWLX_NOTIFICATION_INFO pNotificationInfo)
{
    EnterCriticalSection(&DemandLoadCriticalSection);

    if (hDllWininet && !fUnloadWininet) {
        if (0 == dwWininetRefCnt) {
            FreeLibrary(hDllWininet);
            hDllWininet = NULL;
        } else {
            fUnloadWininet = TRUE;

            // Give other threads time to complete their wininet usage
            //
            // Note, a better solution would be to create an event to
            // wait for
            LeaveCriticalSection(&DemandLoadCriticalSection);
            Sleep(5000);
            EnterCriticalSection(&DemandLoadCriticalSection);
        }
    }

    LeaveCriticalSection(&DemandLoadCriticalSection);

    // Just in case wininet is still loaded. Force wininet.dll to close
    // all user cached HKEYs: g_hkeyBase and hKeyInternetSettings.
    //
    // Any opened wininet registry keys inhibit the closing of the user registry
    // hive and break roaming profiles.
    __try
    {
        HMODULE hDllClose = NULL;

        // The following only returns a nonNULL if the DLL is already loaded.
        // Also, doesn't addRef the module.
        hDllClose = GetModuleHandleA("wininet.dll");

        if (NULL != hDllClose) {
            PFN_InternetSetOptionA pfnInternetSetOptionA;

            if (pfnInternetSetOptionA =
                    (PFN_InternetSetOptionA) GetProcAddress(
                        hDllClose, "InternetSetOptionA")) {
                pfnInternetSetOptionA(
                    NULL,                       // hInternet OPTIONAL
                    INTERNET_OPTION_END_BROWSER_SESSION,
                    NULL,                       // lpBuffer
                    0                           // dwBufferLength
                    );
            }
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
    }

    return TRUE;
}


typedef BOOL (WINAPI *PFN_InternetCrackUrlA)(
    IN LPCSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTSA lpUrlComponents
    );

BOOL
WINAPI
ICN_InternetCrackUrlA(
    IN LPCSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTSA lpUrlComponents
    )
{
    BOOL fRet;
    PFN_InternetCrackUrlA pfn;

    pfn = (PFN_InternetCrackUrlA) ICN_GetWininetProcAddress(
        "InternetCrackUrlA");

    if (pfn) {
        fRet = pfn(
            lpszUrl,
            dwUrlLength,
            dwFlags,
            lpUrlComponents
            );
        ICN_ReleaseWininet();
    } else {
        fRet = FALSE;
    }

    return fRet;
}


typedef BOOL (WINAPI *PFN_InternetCrackUrlW)(
    IN LPCWSTR lpwszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTSW lpUrlComponents
    );

BOOL
WINAPI
ICN_InternetCrackUrlW(
    IN LPCWSTR lpwszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTSW lpUrlComponents
    )
{
    BOOL fRet;
    PFN_InternetCrackUrlW pfn;

    pfn = (PFN_InternetCrackUrlW) ICN_GetWininetProcAddress(
        "InternetCrackUrlW");

    if (pfn) {
        fRet = pfn(
            lpwszUrl,
            dwUrlLength,
            dwFlags,
            lpUrlComponents
            );
        ICN_ReleaseWininet();
    } else {
        fRet = FALSE;
    }

    return fRet;
}


typedef BOOL (WINAPI *PFN_InternetCanonicalizeUrlA)(
    IN LPCSTR lpszUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );

BOOL
WINAPI
ICN_InternetCanonicalizeUrlA(
    IN LPCSTR lpszUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )
{
    BOOL fRet;
    PFN_InternetCanonicalizeUrlA pfn;

    pfn = (PFN_InternetCanonicalizeUrlA) ICN_GetWininetProcAddress(
        "InternetCanonicalizeUrlA");

    if (pfn) {
        fRet = pfn(
            lpszUrl,
            lpszBuffer,
            lpdwBufferLength,
            dwFlags
            );
        ICN_ReleaseWininet();
    } else {
        fRet = FALSE;
    }

    return fRet;
}

typedef BOOL (WINAPI *PFN_InternetReadFile)(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    );

BOOL
WINAPI
ICN_InternetReadFile(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )
{
    BOOL fRet;
    PFN_InternetReadFile pfn;

    pfn = (PFN_InternetReadFile) ICN_GetWininetProcAddress(
        "InternetReadFile");

    if (pfn) {
        fRet = pfn(
            hFile,
            lpBuffer,
            dwNumberOfBytesToRead,
            lpdwNumberOfBytesRead
            );
        ICN_ReleaseWininet();
    } else {
        fRet = FALSE;
    }

    return fRet;
}

typedef BOOL (WINAPI *PFN_HttpQueryInfoA)(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    );

BOOL
WINAPI
ICN_HttpQueryInfoA(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    )
{
    BOOL fRet;
    PFN_HttpQueryInfoA pfn;

    pfn = (PFN_HttpQueryInfoA) ICN_GetWininetProcAddress(
        "HttpQueryInfoA");

    if (pfn) {
        fRet = pfn(
            hRequest,
            dwInfoLevel,
            lpBuffer,
            lpdwBufferLength,
            lpdwIndex
            );
        ICN_ReleaseWininet();
    } else {
        fRet = FALSE;
    }

    return fRet;
}

typedef BOOL (WINAPI *PFN_DeleteUrlCacheEntry)(
    IN LPCSTR lpszUrlName
    );

BOOL
WINAPI
ICN_DeleteUrlCacheEntry(
    IN LPCSTR lpszUrlName
    )
{
    BOOL fRet;
    PFN_DeleteUrlCacheEntry pfn;

    pfn = (PFN_DeleteUrlCacheEntry) ICN_GetWininetProcAddress(
        "DeleteUrlCacheEntry");

    if (pfn) {
        fRet = pfn(
            lpszUrlName
            );
        ICN_ReleaseWininet();
    } else {
        fRet = FALSE;
    }

    return fRet;
}


typedef BOOL (WINAPI *PFN_CommitUrlCacheEntryA)(
    IN LPCSTR lpszUrlName,
    IN LPCSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPBYTE lpHeaderInfo,
    IN DWORD dwHeaderSize,
    IN LPCSTR lpszFileExtension,
    IN LPCSTR lpszOriginalUrl
    );

BOOL
WINAPI
ICN_CommitUrlCacheEntryA(
    IN LPCSTR lpszUrlName,
    IN LPCSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPBYTE lpHeaderInfo,
    IN DWORD dwHeaderSize,
    IN LPCSTR lpszFileExtension,
    IN LPCSTR lpszOriginalUrl
    )
{
    BOOL fRet;
    PFN_CommitUrlCacheEntryA pfn;

    pfn = (PFN_CommitUrlCacheEntryA) ICN_GetWininetProcAddress(
        "CommitUrlCacheEntryA");

    if (pfn) {
        fRet = pfn(
            lpszUrlName,
            lpszLocalFileName,
            ExpireTime,
            LastModifiedTime,
            CacheEntryType,
            lpHeaderInfo,
            dwHeaderSize,
            lpszFileExtension,
            lpszOriginalUrl
            );
        ICN_ReleaseWininet();
    } else {
        fRet = FALSE;
    }

    return fRet;
}

typedef BOOL (WINAPI *PFN_CreateUrlCacheEntryA)(
    IN LPCSTR lpszUrlName,
    IN DWORD dwExpectedFileSize,
    IN LPCSTR lpszFileExtension,
    OUT LPSTR lpszFileName,
    IN DWORD dwReserved
    );

BOOL
WINAPI
ICN_CreateUrlCacheEntryA(
    IN LPCSTR lpszUrlName,
    IN DWORD dwExpectedFileSize,
    IN LPCSTR lpszFileExtension,
    OUT LPSTR lpszFileName,
    IN DWORD dwReserved
    )
{
    BOOL fRet;
    PFN_CreateUrlCacheEntryA pfn;

    pfn = (PFN_CreateUrlCacheEntryA) ICN_GetWininetProcAddress(
        "CreateUrlCacheEntryA");

    if (pfn) {
        fRet = pfn(
            lpszUrlName,
            dwExpectedFileSize,
            lpszFileExtension,
            lpszFileName,
            dwReserved
            );
        ICN_ReleaseWininet();
    } else {
        fRet = FALSE;
    }

    return fRet;
}

typedef BOOL (WINAPI *PFN_GetUrlCacheEntryInfoA)(
    IN LPCSTR lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize
    );

BOOL
WINAPI
ICN_GetUrlCacheEntryInfoA(
    IN LPCSTR lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize
    )
{
    BOOL fRet;
    PFN_GetUrlCacheEntryInfoA pfn;

    pfn = (PFN_GetUrlCacheEntryInfoA) ICN_GetWininetProcAddress(
        "GetUrlCacheEntryInfoA");

    if (pfn) {
        fRet = pfn(
            lpszUrlName,
            lpCacheEntryInfo,
            lpdwCacheEntryInfoBufferSize
            );
        ICN_ReleaseWininet();
    } else {
        fRet = FALSE;
    }

    return fRet;
}

typedef BOOL (WINAPI *PFN_SetUrlCacheEntryInfoA)(
    IN LPCSTR lpszUrlName,
    IN LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN DWORD dwFieldControl
    );

BOOL
WINAPI
ICN_SetUrlCacheEntryInfoA(
    IN LPCSTR lpszUrlName,
    IN LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN DWORD dwFieldControl
    )
{
    BOOL fRet;
    PFN_SetUrlCacheEntryInfoA pfn;

    pfn = (PFN_SetUrlCacheEntryInfoA) ICN_GetWininetProcAddress(
        "SetUrlCacheEntryInfoA");

    if (pfn) {
        fRet = pfn(
            lpszUrlName,
            lpCacheEntryInfo,
            dwFieldControl
            );
        ICN_ReleaseWininet();
    } else {
        fRet = FALSE;
    }

    return fRet;
}

BOOL
WINAPI
ICN_InternetSetOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )
{
    BOOL fRet;
    PFN_InternetSetOptionA pfn;

    pfn = (PFN_InternetSetOptionA) ICN_GetWininetProcAddress(
        "InternetSetOptionA");

    if (pfn) {
        fRet = pfn(
            hInternet,
            dwOption,
            lpBuffer,
            dwBufferLength
            );
        ICN_ReleaseWininet();
    } else {
        fRet = FALSE;
    }

    return fRet;
}

typedef BOOL (WINAPI *PFN_InternetQueryOptionA)(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    );

BOOL
WINAPI
ICN_InternetQueryOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    )
{
    BOOL fRet;
    PFN_InternetQueryOptionA pfn;

    pfn = (PFN_InternetQueryOptionA) ICN_GetWininetProcAddress(
        "InternetQueryOptionA");

    if (pfn) {
        fRet = pfn(
            hInternet,
            dwOption,
            lpBuffer,
            lpdwBufferLength
            );
        ICN_ReleaseWininet();
    } else {
        fRet = FALSE;
    }

    return fRet;
}

typedef BOOL (WINAPI *PFN_InternetQueryDataAvailable)(
    IN HINTERNET hFile,
    OUT LPDWORD lpdwNumberOfBytesAvailable OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );

BOOL
WINAPI
ICN_InternetQueryDataAvailable(
    IN HINTERNET hFile,
    OUT LPDWORD lpdwNumberOfBytesAvailable OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    )
{
    BOOL fRet;
    PFN_InternetQueryDataAvailable pfn;

    pfn = (PFN_InternetQueryDataAvailable) ICN_GetWininetProcAddress(
        "InternetQueryDataAvailable");

    if (pfn) {
        fRet = pfn(
            hFile,
            lpdwNumberOfBytesAvailable,
            dwFlags,
            dwContext
            );
        ICN_ReleaseWininet();
    } else {
        fRet = FALSE;
    }

    return fRet;
}


typedef HINTERNET (WINAPI *PFN_InternetOpenUrlA)(
    IN HINTERNET hInternet,
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );

HINTERNET
WINAPI
ICN_InternetOpenUrlA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    HINTERNET hRet;
    PFN_InternetOpenUrlA pfn;

    pfn = (PFN_InternetOpenUrlA) ICN_GetWininetProcAddress(
        "InternetOpenUrlA");

    if (pfn) {
        hRet = pfn(
            hInternet,
            lpszUrl,
            lpszHeaders,
            dwHeadersLength,
            dwFlags,
            dwContext
            );
        if (NULL == hRet)
            ICN_ReleaseWininet();
        // else
        //  Keep loaded until InternetCloseHandle is called
    } else {
        hRet = NULL;
    }

    return hRet;
}

typedef HINTERNET (WINAPI *PFN_InternetOpenA)(
    IN LPCSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );

HINTERNET
WINAPI
ICN_InternetOpenA(
    IN LPCSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    )
{
    HINTERNET hRet;
    PFN_InternetOpenA pfn;

    pfn = (PFN_InternetOpenA) ICN_GetWininetProcAddress(
        "InternetOpenA");

    if (pfn) {
        hRet = pfn(
            lpszAgent,
            dwAccessType,
            lpszProxy,
            lpszProxyBypass,
            dwFlags
            );
        if (NULL == hRet)
            ICN_ReleaseWininet();
        // else
        //  Keep loaded until InternetCloseHandle is called
    } else {
        hRet = NULL;
    }

    return hRet;
}

typedef HINTERNET (WINAPI *PFN_InternetConnectA)(
    IN HINTERNET hInternet,
    IN LPCSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszUserName OPTIONAL,
    IN LPCSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );

HINTERNET
WINAPI
ICN_InternetConnectA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszUserName OPTIONAL,
    IN LPCSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    HINTERNET hRet;
    PFN_InternetConnectA pfn;

    pfn = (PFN_InternetConnectA) ICN_GetWininetProcAddress(
        "InternetConnectA");

    if (pfn) {
        hRet = pfn(
            hInternet,
            lpszServerName,
            nServerPort,
            lpszUserName OPTIONAL,
            lpszPassword OPTIONAL,
            dwService,
            dwFlags,
            dwContext
            );
        if (NULL == hRet)
            ICN_ReleaseWininet();
        // else
        //  Keep loaded until InternetCloseHandle is called
    } else {
        hRet = NULL;
    }

    return hRet;
}

typedef BOOL (WINAPI *PFN_InternetCloseHandle)(
    IN HINTERNET hInternet
    );

BOOL
WINAPI
ICN_InternetCloseHandle(
    IN HINTERNET hInternet
    )
{
    BOOL fRet;
    PFN_InternetCloseHandle pfn;

    if (NULL == hInternet)
        return TRUE;

    pfn = (PFN_InternetCloseHandle) ICN_GetWininetProcAddress(
        "InternetCloseHandle");

    if (pfn) {
        fRet = pfn(
            hInternet
            );
        ICN_ReleaseWininet();
    } else {
        fRet = FALSE;
    }

    // Release the open ref count
    ICN_ReleaseWininet();

    return fRet;
}

typedef BOOL (WINAPI *PFN_InternetGetConnectedState)(
    OUT LPDWORD  lpdwFlags,
    IN DWORD    dwReserved
    );

BOOL
WINAPI
InternetGetConnectedState(
    OUT LPDWORD  lpdwFlags,
    IN DWORD    dwReserved
    )
{
    BOOL fRet;
    PFN_InternetGetConnectedState pfn;

    pfn = (PFN_InternetGetConnectedState) ICN_GetWininetProcAddress(
        "InternetGetConnectedState");

    if (pfn) {
        fRet = pfn(
            lpdwFlags,
            dwReserved
            );
        ICN_ReleaseWininet();
    } else {
        fRet = FALSE;
        *lpdwFlags = 0;
    }

    return fRet;
}

BOOL
WINAPI
I_CryptNetIsConnected()
{
    DWORD dwFlags;

    return InternetGetConnectedState(&dwFlags, 0);
}

//
// Cracks the Url and returns the host name component.
//
BOOL
WINAPI
I_CryptNetGetHostNameFromUrl (
        IN LPWSTR pwszUrl,
        IN DWORD cchHostName,
        OUT LPWSTR pwszHostName
        )
{
    URL_COMPONENTSW UrlComponents;

    memset( &UrlComponents, 0, sizeof( UrlComponents ) );
    UrlComponents.dwStructSize = sizeof( UrlComponents );
    UrlComponents.dwHostNameLength = cchHostName - 1;
    UrlComponents.lpszHostName = pwszHostName;

    *pwszHostName = L'\0';

    return InternetCrackUrlW(
        pwszUrl,
        0,              // dwUrlLength, 0 => NULL terminated
        0,              // dwFlags 
        &UrlComponents
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\crobu.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       crobu.cpp
//
//  Contents:   CryptRetrieveObjectByUrl
//
//  History:    23-Jul-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <dbgdef.h>

// Initial commit size of the stack, in bytes. Estimate of 20K needed for
// wininet.
#define URL_WITH_TIMEOUT_THREAD_STACK_SIZE      0x5000

//
// CryptRetrieveObjectByUrl Entry
//
// Passed to the thread that does the real URL retrieval. The creator
// thread waits for either the URL retrieval to complete or a timeout.
//
typedef struct _CROBU_ENTRY CROBU_ENTRY, *PCROBU_ENTRY;
struct _CROBU_ENTRY {
    LPSTR                       pszUrl;
    LPCSTR                      pszObjectOid;
    DWORD                       dwRetrievalFlags;
    DWORD                       dwTimeout;
    LPVOID                      pvObject;

    CRYPT_RETRIEVE_AUX_INFO     AuxInfo;
    FILETIME                    LastSyncTime;

    BOOL                        fResult;
    DWORD                       dwErr;

    HMODULE                     hModule;
    HANDLE                      hWaitEvent;
    DWORD                       dwState;
    PCROBU_ENTRY                pNext;
    PCROBU_ENTRY                pPrev;
};

#define CROBU_RUN_STATE         1
#define CROBU_DONE_STATE        2
#define CROBU_PENDING_STATE     3

CRITICAL_SECTION            CrobuCriticalSection;
HMODULE                     hCrobuModule;

// Linked list of pending URL retrievals
PCROBU_ENTRY                pCrobuPendingHead;

VOID
WINAPI
InitializeCryptRetrieveObjectByUrl(
    HMODULE hModule
    )
{
    Pki_InitializeCriticalSection(&CrobuCriticalSection);
    hCrobuModule = hModule;
}

VOID
WINAPI
DeleteCryptRetrieveObjectByUrl()
{
    DeleteCriticalSection(&CrobuCriticalSection);
}


//
// Local Functions (Forward Reference)
// 

BOOL WINAPI IsPendingCryptRetrieveObjectByUrl (
                 IN LPCSTR pszUrl
                 );
BOOL WINAPI CryptRetrieveObjectByUrlWithTimeout (
                 IN LPCSTR pszUrl,
                 IN LPCSTR pszObjectOid,
                 IN DWORD dwRetrievalFlags,
                 IN DWORD dwTimeout,
                 OUT LPVOID* ppvObject,
                 IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                 );

void
DebugPrintUrlRetrievalError(
    IN LPCSTR pszUrl,
    IN DWORD dwTimeout,
    IN DWORD dwErr
    );


//+---------------------------------------------------------------------------
//
//  Function:   CryptRetrieveObjectByUrlA
//
//  Synopsis:   retrieve PKI object given an URL
//
//----------------------------------------------------------------------------
BOOL WINAPI CryptRetrieveObjectByUrlA (
                 IN LPCSTR pszUrl,
                 IN LPCSTR pszObjectOid,
                 IN DWORD dwRetrievalFlags,
                 IN DWORD dwTimeout,
                 OUT LPVOID* ppvObject,
                 IN HCRYPTASYNC hAsyncRetrieve,
                 IN PCRYPT_CREDENTIALS pCredentials,
                 IN LPVOID pvVerify,
                 IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                 )
{
    BOOL                     fResult;
    CObjectRetrievalManager* porm = NULL;

    // For a nonCache retrieval with timeout, do the retrieval in another
    // thread. wininet and winldap don't always honor the timeout value.
    //
    // Check for parameters not supported by doing in another thread.
    //
    // Also, check that a cancel callback hasn't been registered via
    // CryptInstallCancelRetrieval()
    if (0 != dwTimeout && !(dwRetrievalFlags & CRYPT_CACHE_ONLY_RETRIEVAL) &&
            0xFFFF >= (DWORD_PTR) pszObjectOid &&
            NULL == hAsyncRetrieve && NULL == pCredentials &&
            NULL == pvVerify &&
	        NULL == I_CryptGetTls(hCryptNetCancelTls) )
    {
        if (IsPendingCryptRetrieveObjectByUrl( pszUrl ))
        {
#if DBG
            DbgPrintf(DBG_SS_CRYPT32,
                "CryptRetrieveObjectByUrl, already pending for : %s\n",
                pszUrl);
#endif
            SetLastError( (DWORD) ERROR_BAD_NET_RESP );
            return( FALSE );
        }
        else
        {
            return CryptRetrieveObjectByUrlWithTimeout (
                 pszUrl,
                 pszObjectOid,
                 dwRetrievalFlags,
                 dwTimeout,
                 ppvObject,
                 pAuxInfo
                 );
        }
    }
            
            

    porm = new CObjectRetrievalManager;
    if ( porm == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    fResult = porm->RetrieveObjectByUrl(
                            pszUrl,
                            pszObjectOid,
                            dwRetrievalFlags,
                            dwTimeout,
                            ppvObject,
                            NULL,
                            NULL,
                            hAsyncRetrieve,
                            pCredentials,
                            pvVerify,
                            pAuxInfo
                            );

    porm->Release();

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   CryptRetrieveObjectByUrlW
//
//  Synopsis:   retrieve PKI object given an URL
//
//----------------------------------------------------------------------------
BOOL WINAPI CryptRetrieveObjectByUrlW (
                 IN LPCWSTR pszUrl,
                 IN LPCSTR pszObjectOid,
                 IN DWORD dwRetrievalFlags,
                 IN DWORD dwTimeout,
                 OUT LPVOID* ppvObject,
                 IN HCRYPTASYNC hAsyncRetrieve,
                 IN PCRYPT_CREDENTIALS pCredentials,
                 IN LPVOID pvVerify,
                 IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                 )
{
    CHAR pszUrlA[INTERNET_MAX_PATH_LENGTH+1];

    if ( WideCharToMultiByte(
             CP_ACP,
             0,
             pszUrl,
             -1,
             pszUrlA,
             INTERNET_MAX_PATH_LENGTH+1,
             NULL,
             NULL
             ) == FALSE )
    {
        return( FALSE );
    }

    return( CryptRetrieveObjectByUrlA(
                 pszUrlA,
                 pszObjectOid,
                 dwRetrievalFlags,
                 dwTimeout,
                 ppvObject,
                 hAsyncRetrieve,
                 pCredentials,
                 pvVerify,
                 pAuxInfo
                 ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CryptCancelAsyncRetrieval
//
//  Synopsis:   cancel asynchronous object retrieval
//
//----------------------------------------------------------------------------
BOOL WINAPI CryptCancelAsyncRetrieval (HCRYPTASYNC hAsyncRetrieval)
{
    SetLastError( (DWORD) E_NOTIMPL );
    return( FALSE );
}

//+===========================================================================
//
//  Functions supporting URL retrieval with timeout. The actual retrieval
//  is done in another, created thread.
//
//============================================================================


//+---------------------------------------------------------------------------
//  Returns TRUE if the previously initiated URL retrieval hasn't completed.
//----------------------------------------------------------------------------
BOOL WINAPI IsPendingCryptRetrieveObjectByUrl (
    IN LPCSTR pszUrl
    )
{
    BOOL fPending = FALSE;
    PCROBU_ENTRY pEntry;

    EnterCriticalSection(&CrobuCriticalSection);

    for (pEntry = pCrobuPendingHead; NULL != pEntry; pEntry = pEntry->pNext) {
        assert(CROBU_PENDING_STATE == pEntry->dwState);

        if (0 == strcmp(pszUrl, pEntry->pszUrl)) {
            fPending = TRUE;
            break;
        }
    }

    LeaveCriticalSection(&CrobuCriticalSection);

    return fPending;
}

//+-------------------------------------------------------------------------
//  Duplicate the Dll library's handle
//--------------------------------------------------------------------------
static HMODULE DuplicateLibrary(
    IN HMODULE hDll
    )
{
    if (hDll) {
        WCHAR wszModule[_MAX_PATH];
        if (0 == GetModuleFileNameU(hDll, wszModule, _MAX_PATH))
            goto GetModuleFileNameError;
        if (NULL == (hDll = LoadLibraryExU(wszModule, NULL, 0)))
            goto LoadLibraryError;
    }

CommonReturn:
    return hDll;
ErrorReturn:
    hDll = NULL;
    goto CommonReturn;
TRACE_ERROR(GetModuleFileNameError)
TRACE_ERROR(LoadLibraryError)
}

//+---------------------------------------------------------------------------
//  Thread procedure that does the actual URL retrieval.
//
//  Note, even if the creator thread times out, this thread will continue to
//  execute until the underlying URL retrieval returns.
//----------------------------------------------------------------------------
DWORD WINAPI CryptRetrieveObjectByUrlWithTimeoutThreadProc (
    LPVOID lpThreadParameter
    )
{
    PCROBU_ENTRY pEntry = (PCROBU_ENTRY) lpThreadParameter;
    CObjectRetrievalManager* porm = NULL;
    HMODULE hModule;

    // Do the actual URL retrieval using the parameters passed to this
    // thread by the creator thread.
    porm = new CObjectRetrievalManager;
    if (NULL == porm ) {
        pEntry->dwErr = (DWORD) E_OUTOFMEMORY;
        pEntry->fResult = FALSE;
    } else {
        pEntry->fResult = porm->RetrieveObjectByUrl(
                            pEntry->pszUrl,
                            pEntry->pszObjectOid,
                            pEntry->dwRetrievalFlags,
                            pEntry->dwTimeout,
                            &pEntry->pvObject,
                            NULL,                   // ppfnFreeObject
                            NULL,                   // ppvFreeContext
                            NULL,                   // hAsyncRetrieve
                            NULL,                   // pCredentials
                            NULL,                   // pvVerify
                            &pEntry->AuxInfo
                            );
        pEntry->dwErr = GetLastError();
        porm->Release();
    }

    EnterCriticalSection(&CrobuCriticalSection);

    // The creator thread incremented cryptnet's ref count to prevent us
    // from being unloaded until this thread exits.
    hModule = pEntry->hModule;
    pEntry->hModule = NULL;

    if (CROBU_RUN_STATE == pEntry->dwState) {
        // The creator thread didn't timeout. Wake it up and set the
        // state to indicate we completed.

        assert(pEntry->hWaitEvent);
        SetEvent(pEntry->hWaitEvent);
        pEntry->dwState = CROBU_DONE_STATE;

        LeaveCriticalSection(&CrobuCriticalSection);

    } else {
        // The creator thread timed out. We were added to the pending
        // list when it timed out.

        LPVOID pv = pEntry->pvObject;
        LPCSTR pOID = pEntry->pszObjectOid;

        assert(CROBU_PENDING_STATE == pEntry->dwState);
        assert(NULL == pEntry->hWaitEvent);

        // Remove from pending list
        if (pEntry->pNext)
            pEntry->pNext->pPrev = pEntry->pPrev;

        if (pEntry->pPrev)
            pEntry->pPrev->pNext = pEntry->pNext;
        else {
            assert(pCrobuPendingHead == pEntry);
            pCrobuPendingHead = pEntry->pNext;
        }

        LeaveCriticalSection(&CrobuCriticalSection);

#if DBG
        DbgPrintf(DBG_SS_CRYPT32,
            "CryptRetrieveObjectByUrl, pending completed for : %s\n",
            pEntry->pszUrl);
#endif

        if (pv) {
            // Free the returned object
            if (NULL == pOID)
                CryptMemFree( pv );
            else if (pEntry->dwRetrievalFlags &
                    CRYPT_RETRIEVE_MULTIPLE_OBJECTS)
                CertCloseStore((HCERTSTORE) pv, 0);
            else if (CONTEXT_OID_CERTIFICATE == pOID)
                CertFreeCertificateContext((PCCERT_CONTEXT) pv);
            else if (CONTEXT_OID_CTL == pOID)
                CertFreeCTLContext((PCCTL_CONTEXT) pv);
            else if (CONTEXT_OID_CRL == pOID)
                CertFreeCRLContext((PCCRL_CONTEXT) pv);
            else {
                assert(CONTEXT_OID_CAPI2_ANY == pOID ||
                    CONTEXT_OID_PKCS7 == pOID);
                if (CONTEXT_OID_CAPI2_ANY == pOID ||
                        CONTEXT_OID_PKCS7 == pOID)
                    CertCloseStore((HCERTSTORE) pv, 0);
             }
        }
        

        // Finally free the entry
        PkiFree(pEntry);
    }


    if (hModule)
        FreeLibraryAndExitThread(hModule, 0);
    else
        ExitThread(0);
}

//+---------------------------------------------------------------------------
//  Creates another thread to do the URL retrieval. Waits for either the
//  URL retrieval to complete or the timeout. For a timeout, the URL retrieval
//  entry is added to a pending list and the URL retrieval is allowed to
//  complete. However, for a timeout, this procedure returns.
//
//  This function guarantees the timeout value is honored.
//----------------------------------------------------------------------------
BOOL WINAPI CryptRetrieveObjectByUrlWithTimeout (
                 IN LPCSTR pszUrl,
                 IN LPCSTR pszObjectOid,
                 IN DWORD dwRetrievalFlags,
                 IN DWORD dwTimeout,
                 OUT LPVOID* ppvObject,
                 IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                 )
{
    BOOL fResult;
    DWORD dwErr = 0;
    PCROBU_ENTRY pEntry = NULL;
    HANDLE hThread = NULL;
    HANDLE hToken = NULL;
    DWORD dwThreadId;
    DWORD cchUrl;

    // Allocate and initialize the entry to be passed to the created
    // thread for doing the URL retrieval.

    cchUrl = strlen(pszUrl) + 1;

    pEntry = (PCROBU_ENTRY) PkiZeroAlloc(sizeof(CROBU_ENTRY) + cchUrl);
    if (NULL == pEntry)
        goto OutOfMemory;

    pEntry->pszUrl = (LPSTR) &pEntry[1];
    memcpy(pEntry->pszUrl, pszUrl, cchUrl);

    assert(0xFFFF >= (DWORD_PTR) pszObjectOid);
    pEntry->pszObjectOid = pszObjectOid;
    pEntry->dwRetrievalFlags = dwRetrievalFlags;
    pEntry->dwTimeout = dwTimeout;
    // pEntry->pvObject

    pEntry->AuxInfo.cbSize = sizeof(pEntry->AuxInfo);
    pEntry->AuxInfo.pLastSyncTime = &pEntry->LastSyncTime;

    // pEntry->LastSyncTime
    // pEntry->fResult
    // pEntry->dwErr
    // pEntry->hModule
    // pEntry->hWaitEvent
    // pEntry->dwState
    // pEntry->pNext
    // pEntry->pPrev


    if (NULL == (pEntry->hWaitEvent =
            CreateEvent(
                NULL,       // lpsa
                FALSE,      // fManualReset
                FALSE,      // fInitialState
                NULL)))     // lpszEventName
        goto CreateWaitEventError;

    // Inhibit cryptnet.dll from being unloaded until the created thread
    // exits.
    pEntry->hModule = DuplicateLibrary(hCrobuModule);
    pEntry->dwState = CROBU_RUN_STATE;

    // Create the thread to do the Url retrieval
    if (NULL == (hThread = CreateThread(
            NULL,           // lpThreadAttributes
            URL_WITH_TIMEOUT_THREAD_STACK_SIZE,
            CryptRetrieveObjectByUrlWithTimeoutThreadProc,
            pEntry,
            CREATE_SUSPENDED,
            &dwThreadId
            )))
        goto CreateThreadError;

    // If we are impersonating, then, the created thread should also impersonate
    if (OpenThreadToken(
                GetCurrentThread(),
                TOKEN_QUERY | TOKEN_IMPERSONATE,
                TRUE,
                &hToken
                )) {
        SetThreadToken(&hThread, hToken);
        CloseHandle(hToken);
        hToken = NULL;
    }

    ResumeThread(hThread);
    CloseHandle(hThread);
    hThread = NULL;


    // Wait for either the Url retrieval to complete or a timeout
    WaitForSingleObjectEx(
        pEntry->hWaitEvent,
        dwTimeout,
        FALSE                       // bAlertable
        );

    EnterCriticalSection(&CrobuCriticalSection);

    if (CROBU_DONE_STATE == pEntry->dwState) {
        // The URL retrieval completed in the created thread. Copy the
        // results from the entry block shared by this and the created
        // thread.

        fResult = pEntry->fResult;
        dwErr = pEntry->dwErr;

        *ppvObject = pEntry->pvObject;
        if ( pAuxInfo &&
                offsetof(CRYPT_RETRIEVE_AUX_INFO, pLastSyncTime) <
                            pAuxInfo->cbSize &&
                pAuxInfo->pLastSyncTime )
        {
            *pAuxInfo->pLastSyncTime = pEntry->LastSyncTime;
        }

        LeaveCriticalSection(&CrobuCriticalSection);
    } else {
        // The URL retrieval didn't complete in the created thread.
        // Add to the pending queue and return URL retrieval failure status.
        // Note, the created thread will be allowed to complete the initiated
        // retrieval.

        assert(CROBU_RUN_STATE == pEntry->dwState);

        CloseHandle(pEntry->hWaitEvent);
        pEntry->hWaitEvent = NULL;
        pEntry->dwState = CROBU_PENDING_STATE;

        // Add to the pending queue
        if (pCrobuPendingHead) {
            pCrobuPendingHead->pPrev = pEntry;
            pEntry->pNext = pCrobuPendingHead;
        }
        pCrobuPendingHead = pEntry;

#if DBG
        DbgPrintf(DBG_SS_CRYPT32,
            "CryptRetrieveObjectByUrl, %d timeout for : %s\n",
            pEntry->dwTimeout, pEntry->pszUrl);
#endif

        pEntry = NULL;

        LeaveCriticalSection(&CrobuCriticalSection);
        goto RetrieveObjectByUrlTimeout;
    }

CommonReturn:
    if (!fResult)
        DebugPrintUrlRetrievalError(
            pszUrl,
            dwTimeout,
            dwErr
            );

    if (pEntry) {
        if (pEntry->hWaitEvent)
            CloseHandle(pEntry->hWaitEvent);
        if (pEntry->hModule)
            FreeLibrary(pEntry->hModule);
        PkiFree(pEntry);
    }
    SetLastError(dwErr);
    return fResult;

ErrorReturn:
    dwErr = GetLastError();
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CreateWaitEventError)
TRACE_ERROR(CreateThreadError)
SET_ERROR(RetrieveObjectByUrlTimeout, ERROR_TIMEOUT)
}

BOOL
IsDebugPrintEnabled()
{
    BOOL fEnable = FALSE;
    HKEY hKey = NULL;
    DWORD dwType = 0;
    DWORD dwValue = 0;
    DWORD cbValue = sizeof(dwValue);

    if (ERROR_SUCCESS != RegOpenKeyExA(
            HKEY_LOCAL_MACHINE,
            "SYSTEM\\CurrentControlSet\\Services\\crypt32",
            0,                      // dwReserved
            KEY_READ,
            &hKey
            ))
        return FALSE;

    if (ERROR_SUCCESS != RegQueryValueExA(
            hKey,
            "DebugFlags",
            NULL,               // pdwReserved
            &dwType,
            (BYTE *) &dwValue,
            &cbValue
            ))
        goto CommonReturn;

    if (dwType != REG_DWORD || cbValue != sizeof(dwValue))
        goto CommonReturn;

    if (dwValue & 0x1)
        fEnable = TRUE;

CommonReturn:
    RegCloseKey(hKey);
    return fEnable;
}

void
DebugPrintfA(
    LPCSTR szFormat,
    ...
    )
{
    char szBuffer[1024];
    va_list arglist;
    _try
    {
        va_start(arglist, szFormat);
        _vsnprintf(szBuffer, sizeof(szBuffer), szFormat, arglist);
        va_end(arglist);

        OutputDebugStringA(szBuffer);
    } _except( EXCEPTION_EXECUTE_HANDLER) {
    }
}

void
DebugPrintUrlRetrievalError(
    IN LPCSTR pszUrl,
    IN DWORD dwTimeout,
    IN DWORD dwErr
    )
{
    if (!IsDebugPrintEnabled())
        return;

    DebugPrintfA("CRYPTNET.DLL --> Url retrieval timeout: %d  error: %d (0x%x) for::\n  %s\n",
         dwTimeout, dwErr, dwErr, pszUrl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\ctxpvdr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ctxpvdr.cpp
//
//  Contents:   Context Providers for Remote Object Retrieval
//
//  History:    23-Jul-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>

//+---------------------------------------------------------------------------
//  Function:   CreateObjectContext
//
//  Synopsis:   create single context or store containing multiple contexts
//----------------------------------------------------------------------------
BOOL WINAPI CreateObjectContext (
                 IN DWORD dwRetrievalFlags,
                 IN PCRYPT_BLOB_ARRAY pObject,
                 IN DWORD dwExpectedContentTypeFlags,
                 IN BOOL fQuerySingleContext,
                 OUT LPVOID* ppvContext
                 )
{
    BOOL       fResult = TRUE;
    HCERTSTORE hStore;
    DWORD      cCount;
    int        iQueryResult;
    DWORD      dwQueryErr = 0;
    
    if ( !( dwRetrievalFlags & CRYPT_RETRIEVE_MULTIPLE_OBJECTS ) )
    {
        assert( pObject->cBlob > 0 );

        return( CryptQueryObject(
                     CERT_QUERY_OBJECT_BLOB,
                     (const void *)&(pObject->rgBlob[0]),
                     fQuerySingleContext ?
                         (dwExpectedContentTypeFlags &
                             ( CERT_QUERY_CONTENT_FLAG_CERT |
                               CERT_QUERY_CONTENT_FLAG_CTL  |
                               CERT_QUERY_CONTENT_FLAG_CRL  ))
                         : dwExpectedContentTypeFlags,
                     CERT_QUERY_FORMAT_FLAG_ALL,
                     0,
                     NULL,
                     NULL,
                     NULL,
                     fQuerySingleContext ? NULL : (HCERTSTORE *) ppvContext,
                     NULL,
                     fQuerySingleContext ? (const void **) ppvContext : NULL
                     ) );
    }
                       
    if ( ( hStore = CertOpenStore(
                        CERT_STORE_PROV_MEMORY,
                        0,
                        NULL,
                        0,
                        NULL
                        ) ) == NULL )
    {
        return( FALSE );
    }
    
    //  0 =>  no CryptQueryObject()
    //  1 =>  1 successful CryptQueryObject()
    // -1 =>  all CryptQueryObject()'s failed
    iQueryResult = 0;

    for ( cCount = 0; 
          ( fResult == TRUE ) && ( cCount < pObject->cBlob ); 
          cCount++ )
    {
        PCERT_BLOB pBlob = &pObject->rgBlob[cCount];
        HCERTSTORE hChildStore;

        // Skip empty blobs. I have seen empty LDAP attributes containing
        // a single byte set to 0.
        if (0 == pBlob->cbData ||
                (1 == pBlob->cbData && 0 == pBlob->pbData[0]))
        {
            continue;
        }

        if (CryptQueryObject(
                       CERT_QUERY_OBJECT_BLOB,
                       (LPVOID) pBlob,
                       dwExpectedContentTypeFlags,
                       CERT_QUERY_FORMAT_FLAG_ALL,
                       0,
                       NULL,
                       NULL,
                       NULL,
                       &hChildStore,
                       NULL,
                       NULL
                       ))
        {
            if (fQuerySingleContext)
            {
                if (0 == (dwExpectedContentTypeFlags &
                            CERT_QUERY_CONTENT_FLAG_CERT))
                {
                    PCCERT_CONTEXT pDeleteCert;
                    while (pDeleteCert = CertEnumCertificatesInStore(
                            hChildStore, NULL))
                    {
                        CertDeleteCertificateFromStore(pDeleteCert);
                    }
                }

                if (0 == (dwExpectedContentTypeFlags &
                            CERT_QUERY_CONTENT_FLAG_CRL))
                {
                    PCCRL_CONTEXT pDeleteCrl;
                    while (pDeleteCrl = CertEnumCRLsInStore(
                            hChildStore, NULL))
                    {
                        CertDeleteCRLFromStore(pDeleteCrl);
                    }
                }
            }

            fResult = I_CertUpdateStore( hStore, hChildStore, 0, NULL );
            CertCloseStore( hChildStore, 0 );
            iQueryResult = 1;
        }
        else if (iQueryResult == 0)
        {
            iQueryResult = -1;
            dwQueryErr = GetLastError();
        }
    }

    if ( fResult == TRUE && iQueryResult < 0)
    {
        fResult = FALSE;
        SetLastError(dwQueryErr);
    }
    
    if ( fResult == TRUE )
    {
        *ppvContext = (LPVOID)hStore;
    }
    else
    {
        CertCloseStore( hStore, 0 );
    }
    
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertificateCreateObjectContext
//
//  Synopsis:   creates a certificate context from encoded certificate bits
//
//----------------------------------------------------------------------------
BOOL WINAPI CertificateCreateObjectContext (
                       IN LPCSTR pszObjectOid,
                       IN DWORD dwRetrievalFlags,
                       IN PCRYPT_BLOB_ARRAY pObject,
                       OUT LPVOID* ppvContext
                       )
{
    return CreateObjectContext (
                dwRetrievalFlags,
                pObject,
                CERT_QUERY_CONTENT_FLAG_CERT |
                    CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED |
                    CERT_QUERY_CONTENT_FLAG_CERT_PAIR,
                TRUE,                               // fQuerySingleContext
                ppvContext
                );
}

//+---------------------------------------------------------------------------
//
//  Function:   CTLCreateObjectContext
//
//  Synopsis:   creates a CTL context from encoded CTL bits
//
//----------------------------------------------------------------------------
BOOL WINAPI CTLCreateObjectContext (
                     IN LPCSTR pszObjectOid,
                     IN DWORD dwRetrievalFlags,
                     IN PCRYPT_BLOB_ARRAY pObject,
                     OUT LPVOID* ppvContext
                     )
{
    return CreateObjectContext (
                dwRetrievalFlags,
                pObject,
                CERT_QUERY_CONTENT_FLAG_CTL,
                TRUE,                               // fQuerySingleContext
                ppvContext
                );
}

//+---------------------------------------------------------------------------
//
//  Function:   CRLCreateObjectContext
//
//  Synopsis:   creates a CRL context from encoded CRL bits
//
//----------------------------------------------------------------------------
BOOL WINAPI CRLCreateObjectContext (
                     IN LPCSTR pszObjectOid,
                     IN DWORD dwRetrievalFlags,
                     IN PCRYPT_BLOB_ARRAY pObject,
                     OUT LPVOID* ppvContext
                     )
{
    return CreateObjectContext (
                dwRetrievalFlags,
                pObject,
                CERT_QUERY_CONTENT_FLAG_CRL |
                    CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED,
                TRUE,                               // fQuerySingleContext
                ppvContext
                );
}

//+---------------------------------------------------------------------------
//
//  Function:   Pkcs7CreateObjectContext
//
//  Synopsis:   creates a certificate store context from a PKCS7 message
//
//----------------------------------------------------------------------------
BOOL WINAPI Pkcs7CreateObjectContext (
                 IN LPCSTR pszObjectOid,
                 IN DWORD dwRetrievalFlags,
                 IN PCRYPT_BLOB_ARRAY pObject,
                 OUT LPVOID* ppvContext
                 )
{
    return CreateObjectContext (
                dwRetrievalFlags,
                pObject,
                CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED,
                FALSE,                              // fQuerySingleContext
                ppvContext
                );
}

//+---------------------------------------------------------------------------
//
//  Function:   Capi2CreateObjectContext
//
//  Synopsis:   create a store of CAPI objects
//
//----------------------------------------------------------------------------
BOOL WINAPI Capi2CreateObjectContext (
                 IN LPCSTR pszObjectOid,
                 IN DWORD dwRetrievalFlags,
                 IN PCRYPT_BLOB_ARRAY pObject,
                 OUT LPVOID* ppvContext
                 )
{
    return CreateObjectContext (
                dwRetrievalFlags,
                pObject,
                CERT_QUERY_CONTENT_FLAG_CERT |
                    CERT_QUERY_CONTENT_FLAG_CTL |
                    CERT_QUERY_CONTENT_FLAG_CRL |
                    CERT_QUERY_CONTENT_FLAG_SERIALIZED_STORE |
                    CERT_QUERY_CONTENT_FLAG_SERIALIZED_CERT |
                    CERT_QUERY_CONTENT_FLAG_SERIALIZED_CTL |
                    CERT_QUERY_CONTENT_FLAG_SERIALIZED_CRL |
                    CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED |
                    CERT_QUERY_CONTENT_FLAG_CERT_PAIR,
                FALSE,                              // fQuerySingleContext
                ppvContext
                );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\demand.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       demand.h
//
//  Contents:   On demand loading of wininet.dll
//
//  History:    12-Dec-98    philh    Created
//
//----------------------------------------------------------------------------
#if !defined(__CRYPTNET_DEMAND_H__)
#define __CRYPTNET_DEMAND_H__

#undef InternetCrackUrlA
#undef InternetCrackUrlW
#undef InternetOpenUrlA
#undef InternetOpenA
#undef InternetCanonicalizeUrlA
#undef InternetReadFile
#undef HttpQueryInfoA
#undef InternetCloseHandle
#undef DeleteUrlCacheEntry
#undef CommitUrlCacheEntryA
#undef CreateUrlCacheEntryA
#undef GetUrlCacheEntryInfoA
#undef SetUrlCacheEntryInfoA
#undef InternetSetOptionA
#undef InternetQueryOptionA
#undef InternetQueryDataAvailable
#undef InternetConnectA
#undef InternetGetConnectedState

#define InternetCrackUrlA ICN_InternetCrackUrlA
#define InternetCrackUrlW ICN_InternetCrackUrlW
#define InternetOpenUrlA ICN_InternetOpenUrlA
#define InternetOpenA ICN_InternetOpenA
#define InternetCanonicalizeUrlA ICN_InternetCanonicalizeUrlA
#define InternetReadFile ICN_InternetReadFile
#define HttpQueryInfoA ICN_HttpQueryInfoA
#define InternetCloseHandle ICN_InternetCloseHandle
#define DeleteUrlCacheEntry ICN_DeleteUrlCacheEntry
#define CommitUrlCacheEntryA ICN_CommitUrlCacheEntryA
#define CreateUrlCacheEntryA ICN_CreateUrlCacheEntryA
#define GetUrlCacheEntryInfoA ICN_GetUrlCacheEntryInfoA
#define SetUrlCacheEntryInfoA ICN_SetUrlCacheEntryInfoA
#define InternetSetOptionA ICN_InternetSetOptionA
#define InternetQueryOptionA ICN_InternetQueryOptionA
#define InternetQueryDataAvailable ICN_InternetQueryDataAvailable
#define InternetConnectA ICN_InternetConnectA
#define InternetGetConnectedState ICN_InternetGetConnectedState


BOOL
WINAPI
ICN_InternetCrackUrlA(
    IN LPCSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTSA lpUrlComponents
    );

BOOL
WINAPI
ICN_InternetCrackUrlW(
    IN LPCWSTR lpwszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTSW lpUrlComponents
    );

BOOL
WINAPI
ICN_InternetCanonicalizeUrlA(
    IN LPCSTR lpszUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );

BOOL
WINAPI
ICN_InternetReadFile(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    );

BOOL
WINAPI
ICN_HttpQueryInfoA(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    );

BOOL
WINAPI
ICN_InternetCloseHandle(
    IN HINTERNET hInternet
    );

BOOL
WINAPI
ICN_DeleteUrlCacheEntry(
    IN LPCSTR lpszUrlName
    );

BOOL
WINAPI
ICN_CommitUrlCacheEntryA(
    IN LPCSTR lpszUrlName,
    IN LPCSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPBYTE lpHeaderInfo,
    IN DWORD dwHeaderSize,
    IN LPCSTR lpszFileExtension,
    IN LPCSTR lpszOriginalUrl
    );

BOOL
WINAPI
ICN_CreateUrlCacheEntryA(
    IN LPCSTR lpszUrlName,
    IN DWORD dwExpectedFileSize,
    IN LPCSTR lpszFileExtension,
    OUT LPSTR lpszFileName,
    IN DWORD dwReserved
    );

BOOL
WINAPI
ICN_GetUrlCacheEntryInfoA(
    IN LPCSTR lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize
    );

BOOL
WINAPI
ICN_SetUrlCacheEntryInfoA(
    IN LPCSTR lpszUrlName,
    IN LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN DWORD dwFieldControl
    );

BOOL
WINAPI
ICN_InternetSetOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    );

BOOL
WINAPI
ICN_InternetQueryOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwBufferLength
    );

BOOL
WINAPI
ICN_InternetQueryDataAvailable(
    IN HINTERNET hFile,
    OUT LPDWORD lpdwNumberOfBytesAvailable OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );

HINTERNET
WINAPI
ICN_InternetOpenUrlA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );

HINTERNET
WINAPI
ICN_InternetOpenA(
    IN LPCSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );

HINTERNET
WINAPI
ICN_InternetConnectA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszUserName OPTIONAL,
    IN LPCSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );

BOOL
WINAPI
InternetGetConnectedState(
    OUT LPDWORD  lpdwFlags,
    IN DWORD    dwReserved
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\filesp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       filesp.cpp
//
//  Contents:   File Scheme Provider
//
//  History:    08-Aug-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Function:   FileRetrieveEncodedObject
//
//  Synopsis:   retrieve encoded object via Win32 File I/O
//
//----------------------------------------------------------------------------
BOOL WINAPI FileRetrieveEncodedObject (
                IN LPCSTR pszUrl,
                IN LPCSTR pszObjectOid,
                IN DWORD dwRetrievalFlags,
                IN DWORD dwTimeout,
                OUT PCRYPT_BLOB_ARRAY pObject,
                OUT PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                OUT LPVOID* ppvFreeContext,
                IN HCRYPTASYNC hAsyncRetrieve,
                IN PCRYPT_CREDENTIALS pCredentials,
                IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                )
{
    BOOL              fResult;
    IObjectRetriever* por = NULL;

    if ( !( dwRetrievalFlags & CRYPT_ASYNC_RETRIEVAL ) )
    {
        por = new CFileSynchronousRetriever;
    }

    if ( por == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    fResult = por->RetrieveObjectByUrl(
                           pszUrl,
                           pszObjectOid,
                           dwRetrievalFlags,
                           dwTimeout,
                           (LPVOID *)pObject,
                           ppfnFreeObject,
                           ppvFreeContext,
                           hAsyncRetrieve,
                           pCredentials,
                           NULL,
                           pAuxInfo
                           );

    por->Release();

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   FileFreeEncodedObject
//
//  Synopsis:   free encoded object retrieved via FileRetrieveEncodedObject
//
//----------------------------------------------------------------------------
VOID WINAPI FileFreeEncodedObject (
                IN LPCSTR pszObjectOid,
                IN PCRYPT_BLOB_ARRAY pObject,
                IN LPVOID pvFreeContext
                )
{
    BOOL           fFreeBlobs = TRUE;
    PFILE_BINDINGS pfb = (PFILE_BINDINGS)pvFreeContext;

    //
    // If no file bindings were given in the context then this
    // must be a mapped file so we deal with it as such
    //

    if ( pfb != NULL )
    {
        fFreeBlobs = FALSE;
        FileFreeBindings( pfb );
    }

    FileFreeCryptBlobArray( pObject, fFreeBlobs );
}

//+---------------------------------------------------------------------------
//
//  Function:   FileCancelAsyncRetrieval
//
//  Synopsis:   cancel asynchronous object retrieval
//
//----------------------------------------------------------------------------
BOOL WINAPI FileCancelAsyncRetrieval (
                IN HCRYPTASYNC hAsyncRetrieve
                )
{
    SetLastError( (DWORD) E_NOTIMPL );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileSynchronousRetriever::CFileSynchronousRetriever, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CFileSynchronousRetriever::CFileSynchronousRetriever ()
{
    m_cRefs = 1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileSynchronousRetriever::~CFileSynchronousRetriever, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CFileSynchronousRetriever::~CFileSynchronousRetriever ()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileSynchronousRetriever::AddRef, public
//
//  Synopsis:   IRefCountedObject::AddRef
//
//----------------------------------------------------------------------------
VOID
CFileSynchronousRetriever::AddRef ()
{
    InterlockedIncrement( (LONG *)&m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileSynchronousRetriever::Release, public
//
//  Synopsis:   IRefCountedObject::Release
//
//----------------------------------------------------------------------------
VOID
CFileSynchronousRetriever::Release ()
{
    if ( InterlockedDecrement( (LONG *)&m_cRefs ) == 0 )
    {
        delete this;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CFileSynchronousRetriever::RetrieveObjectByUrl, public
//
//  Synopsis:   IObjectRetriever::RetrieveObjectByUrl
//
//----------------------------------------------------------------------------
BOOL
CFileSynchronousRetriever::RetrieveObjectByUrl (
                                   LPCSTR pszUrl,
                                   LPCSTR pszObjectOid,
                                   DWORD dwRetrievalFlags,
                                   DWORD dwTimeout,
                                   LPVOID* ppvObject,
                                   PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                                   LPVOID* ppvFreeContext,
                                   HCRYPTASYNC hAsyncRetrieve,
                                   PCRYPT_CREDENTIALS pCredentials,
                                   LPVOID pvVerify,
                                   PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                                   )
{
    BOOL           fResult = FALSE;
    DWORD          LastError = 0;
    PFILE_BINDINGS pfb = NULL;
    LPVOID         pvFreeContext = NULL;
    BOOL           fIsUncUrl;

    assert( hAsyncRetrieve == NULL );

#if DBG
    printf( "File to retrieve: %s\n", pszUrl );
#endif

    fIsUncUrl = FileIsUncUrl( pszUrl );

    if ( ( dwRetrievalFlags & CRYPT_CACHE_ONLY_RETRIEVAL ) &&
         ( fIsUncUrl == TRUE ) )
    {
        return( SchemeRetrieveCachedCryptBlobArray(
                      pszUrl,
                      dwRetrievalFlags,
                      (PCRYPT_BLOB_ARRAY)ppvObject,
                      ppfnFreeObject,
                      ppvFreeContext,
                      pAuxInfo
                      ) );
    }

    fResult = FileGetBindings( pszUrl, dwRetrievalFlags, pCredentials, &pfb );

    if ( fResult == TRUE )
    {
        if ( pfb->fMapped == FALSE )
        {
            fResult = FileSendReceiveUrlRequest(
                          pfb,
                          (PCRYPT_BLOB_ARRAY)ppvObject
                          );

            LastError = GetLastError();
            FileFreeBindings( pfb );
        }
        else
        {
            fResult = FileConvertMappedBindings(
                          pfb,
                          (PCRYPT_BLOB_ARRAY)ppvObject
                          );

            if ( fResult == TRUE )
            {
                pvFreeContext = (LPVOID)pfb;
            }
            else
            {
                LastError = GetLastError();
                FileFreeBindings( pfb );
            }
        }
    }

    if ( fResult == TRUE ) 
    {
        if ( !( dwRetrievalFlags & CRYPT_DONT_CACHE_RESULT ) &&
              ( fIsUncUrl == TRUE ) )
        {
            fResult = SchemeCacheCryptBlobArray(
                            pszUrl,
                            dwRetrievalFlags,
                            (PCRYPT_BLOB_ARRAY)ppvObject,
                            pAuxInfo
                            );

            if ( fResult == FALSE )
            {
                FileFreeEncodedObject(
                    pszObjectOid,
                    (PCRYPT_BLOB_ARRAY)ppvObject,
                    pvFreeContext
                    );
            }
        }
        else
        {
            SchemeRetrieveUncachedAuxInfo( pAuxInfo );
        }
    }

    if ( fResult == TRUE )
    {

        *ppfnFreeObject = FileFreeEncodedObject;
        *ppvFreeContext = pvFreeContext;
    }

    if ( LastError != 0 )
    {
        SetLastError( LastError );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CInetSynchronousRetriever::CancelAsyncRetrieval, public
//
//  Synopsis:   IObjectRetriever::CancelAsyncRetrieval
//
//----------------------------------------------------------------------------
BOOL
CFileSynchronousRetriever::CancelAsyncRetrieval ()
{
    SetLastError( (DWORD) E_NOTIMPL );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   FileGetBindings
//
//  Synopsis:   get the file bindings
//
//----------------------------------------------------------------------------
BOOL
FileGetBindings (
    LPCSTR pszUrl,
    DWORD dwRetrievalFlags,
    PCRYPT_CREDENTIALS pCredentials,
    PFILE_BINDINGS* ppfb
    )
{
    DWORD          LastError;
    LPSTR          pszFile = (LPSTR)pszUrl;
    HANDLE         hFile;
    HANDLE         hFileMap;
    LPVOID         pvMap = NULL;
    DWORD          dwSize;
    PFILE_BINDINGS pfb;

    if ( pCredentials != NULL )
    {
        SetLastError( (DWORD) E_NOTIMPL );
        return( FALSE );
    }

    pfb = new FILE_BINDINGS;
    if ( pfb == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    if ( strstr( pszUrl, FILE_SCHEME_PLUSPLUS ) != NULL )
    {
        pszFile += sizeof( FILE_SCHEME_PLUSPLUS ) - 1;
    }

    hFile = CreateFileA(
                  pszFile,
                  GENERIC_READ,
                  FILE_SHARE_READ,
                  NULL,
                  OPEN_EXISTING,
                  0,
                  NULL
                  );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        delete pfb;
        return( FALSE );
    }

    if ( ( dwSize = GetFileSize( hFile, NULL ) ) <= FILE_MAPPING_THRESHOLD )
    {
        pfb->hFile = hFile;
        pfb->dwSize = dwSize;
        pfb->fMapped = FALSE;
        pfb->hFileMap = NULL;
        pfb->pvMap = NULL;

        *ppfb = pfb;

        return( TRUE );
    }

    hFileMap = CreateFileMappingA(
                     hFile,
                     NULL,
                     PAGE_READONLY,
                     0,
                     0,
                     NULL
                     );

    if ( hFileMap != NULL )
    {
        pvMap = MapViewOfFile( hFileMap, FILE_MAP_READ, 0, 0, 0 );
    }

    if ( pvMap != NULL )
    {
        pfb->hFile = hFile;
        pfb->dwSize = dwSize;
        pfb->fMapped = TRUE;
        pfb->hFileMap = hFileMap;
        pfb->pvMap = pvMap;

        *ppfb = pfb;

        return( TRUE );
    }

    LastError = GetLastError();

    if ( hFileMap != NULL )
    {
        CloseHandle( hFileMap );
    }

    if ( hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( hFile );
    }

    delete pfb;

    SetLastError( LastError );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   FileFreeBindings
//
//  Synopsis:   free the file bindings
//
//----------------------------------------------------------------------------
VOID
FileFreeBindings (
    PFILE_BINDINGS pfb
    )
{
    if ( pfb->fMapped == TRUE )
    {
        UnmapViewOfFile( pfb->pvMap );
        CloseHandle( pfb->hFileMap );
    }

    CloseHandle( pfb->hFile );
    delete pfb;
}

//+---------------------------------------------------------------------------
//
//  Function:   FileSendReceiveUrlRequest
//
//  Synopsis:   synchronously process the request for the file bits using
//              Win32 File API.  Note that this only works for non-mapped
//              file bindings, for mapped file bindings use
//              FileConvertMappedBindings
//
//----------------------------------------------------------------------------
BOOL
FileSendReceiveUrlRequest (
    PFILE_BINDINGS pfb,
    PCRYPT_BLOB_ARRAY pcba
    )
{
    BOOL   fResult;
    LPBYTE pb;
    DWORD  dwRead;

    assert( pfb->fMapped == FALSE );

    pb = CCryptBlobArray::AllocBlob( pfb->dwSize );
    if ( pb == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    fResult = ReadFile( pfb->hFile, pb, pfb->dwSize, &dwRead, NULL );
    if ( fResult == TRUE )
    {
        CCryptBlobArray cba( 1, 1, fResult );

        if ( ( fResult == TRUE ) && ( dwRead == pfb->dwSize ) )
        {
            if ( dwRead == pfb->dwSize )
            {
                fResult = cba.AddBlob( pfb->dwSize, pb, FALSE );
            }
            else
            {
                SetLastError( (DWORD) E_FAIL );
                fResult = FALSE;
            }
        }

        if ( fResult == TRUE )
        {
            cba.GetArrayInNativeForm( pcba );
        }
        else
        {
            cba.FreeArray( FALSE );
        }
    }

    if ( fResult == FALSE )
    {
        CCryptBlobArray::FreeBlob( pb );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   FileConvertMappedBindings
//
//  Synopsis:   convert mapped bindings to a CRYPT_BLOB_ARRAY
//
//----------------------------------------------------------------------------
BOOL
FileConvertMappedBindings (
    PFILE_BINDINGS pfb,
    PCRYPT_BLOB_ARRAY pcba
    )
{
    BOOL fResult;

    assert( pfb->fMapped == TRUE );

    CCryptBlobArray cba( 1, 1, fResult );

    if ( fResult == TRUE )
    {
        fResult = cba.AddBlob( pfb->dwSize, (LPBYTE)pfb->pvMap, FALSE );
    }

    if ( fResult == TRUE )
    {
        cba.GetArrayInNativeForm( pcba );
    }
    else
    {
        cba.FreeArray( FALSE );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   FileFreeCryptBlobArray
//
//  Synopsis:   free the CRYPT_BLOB_ARRAY
//
//----------------------------------------------------------------------------
VOID
FileFreeCryptBlobArray (
    PCRYPT_BLOB_ARRAY pcba,
    BOOL fFreeBlobs
    )
{
    CCryptBlobArray cba( pcba, 0 );

    cba.FreeArray( fFreeBlobs );
}

//+---------------------------------------------------------------------------
//
//  Function:   FileIsUncUrl
//
//  Synopsis:   is this a UNC path URL?
//
//----------------------------------------------------------------------------
BOOL
FileIsUncUrl (
    LPCSTR pszUrl
    )
{
    DWORD cch = 0;

    if ( strstr( pszUrl, FILE_SCHEME_PLUSPLUS ) != NULL )
    {
        cch += sizeof( FILE_SCHEME_PLUSPLUS ) - 1;
    }

    if ( ( pszUrl[ cch ] == '\\' ) && ( pszUrl[ cch + 1 ] == '\\' ) )
    {
        return( TRUE );
    }

    return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\filesp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       filesp.h
//
//  Contents:   File Scheme Provider definitions
//
//  History:    08-Aug-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__FILESP_H__)
#define __FILESP_H__

#include <orm.h>
#include <wininet.h>

//
// File scheme provider entry points
//

#define FILE_SCHEME          "file"
#define FILE_SCHEME_PLUSPLUS "file://"

BOOL WINAPI FileRetrieveEncodedObject (
                IN LPCSTR pszUrl,
                IN LPCSTR pszObjectOid,
                IN DWORD dwRetrievalFlags,
                IN DWORD dwTimeout,
                OUT PCRYPT_BLOB_ARRAY pObject,
                OUT PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                OUT LPVOID* ppvFreeContext,
                IN HCRYPTASYNC hAsyncRetrieve,
                IN PCRYPT_CREDENTIALS pCredentials,
                IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                );

VOID WINAPI FileFreeEncodedObject (
                IN LPCSTR pszObjectOid,
                IN PCRYPT_BLOB_ARRAY pObject,
                IN LPVOID pvFreeContext
                );

BOOL WINAPI FileCancelAsyncRetrieval (
                IN HCRYPTASYNC hAsyncRetrieve
                );

//
// File Synchronous Object Retriever
//

class CFileSynchronousRetriever : public IObjectRetriever
{
public:

    //
    // Construction
    //

    CFileSynchronousRetriever ();
    ~CFileSynchronousRetriever ();

    //
    // IRefCountedObject methods
    //

    virtual VOID AddRef ();
    virtual VOID Release ();

    //
    // IObjectRetriever methods
    //

    virtual BOOL RetrieveObjectByUrl (
                         LPCSTR pszUrl,
                         LPCSTR pszObjectOid,
                         DWORD dwRetrievalFlags,
                         DWORD dwTimeout,
                         LPVOID* ppvObject,
                         PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                         LPVOID* ppvFreeContext,
                         HCRYPTASYNC hAsyncRetrieve,
                         PCRYPT_CREDENTIALS pCredentials,
                         LPVOID pvVerify,
                         PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                         );

    virtual BOOL CancelAsyncRetrieval ();

private:

    //
    // Reference count
    //

    ULONG m_cRefs;
};

//
// File Scheme Provider support API
//

#define FILE_MAPPING_THRESHOLD 20*4096

typedef struct _FILE_BINDINGS {

    HANDLE hFile;
    DWORD  dwSize;
    BOOL   fMapped;
    HANDLE hFileMap;
    LPVOID pvMap;

} FILE_BINDINGS, *PFILE_BINDINGS;

BOOL
FileGetBindings (
    LPCSTR pszUrl,
    DWORD dwRetrievalFlags,
    PCRYPT_CREDENTIALS pCredentials,
    PFILE_BINDINGS* ppfb
    );

VOID
FileFreeBindings (
    PFILE_BINDINGS pfb
    );

BOOL
FileSendReceiveUrlRequest (
    PFILE_BINDINGS pfb,
    PCRYPT_BLOB_ARRAY pcba
    );

BOOL
FileConvertMappedBindings (
    PFILE_BINDINGS pfb,
    PCRYPT_BLOB_ARRAY pcba
    );

VOID
FileFreeCryptBlobArray (
    PCRYPT_BLOB_ARRAY pcba,
    BOOL fFreeBlobs
    );

BOOL
FileIsUncUrl (
    LPCSTR pszUrl
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\inetsp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       inetsp.cpp
//
//  Contents:   Inet Scheme Provider for Remote Object Retrieval
//
//  History:    06-Aug-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Function:   InetRetrieveEncodedObject
//
//  Synopsis:   retrieve encoded object via HTTP, FTP, GOPHER protocols
//
//----------------------------------------------------------------------------
BOOL WINAPI InetRetrieveEncodedObject (
                IN LPCSTR pszUrl,
                IN LPCSTR pszObjectOid,
                IN DWORD dwRetrievalFlags,
                IN DWORD dwTimeout,
                OUT PCRYPT_BLOB_ARRAY pObject,
                OUT PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                OUT LPVOID* ppvFreeContext,
                IN HCRYPTASYNC hAsyncRetrieve,
                IN PCRYPT_CREDENTIALS pCredentials,
                IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                )
{
    BOOL              fResult;
    IObjectRetriever* por = NULL;

    if ( !( dwRetrievalFlags & CRYPT_ASYNC_RETRIEVAL ) )
    {
        por = new CInetSynchronousRetriever;
    }

    if ( por == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    fResult = por->RetrieveObjectByUrl(
                           pszUrl,
                           pszObjectOid,
                           dwRetrievalFlags,
                           dwTimeout,
                           (LPVOID *)pObject,
                           ppfnFreeObject,
                           ppvFreeContext,
                           hAsyncRetrieve,
                           pCredentials,
                           NULL,
                           pAuxInfo
                           );

    por->Release();

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   InetFreeEncodedObject
//
//  Synopsis:   free encoded object retrieved via InetRetrieveEncodedObject
//
//----------------------------------------------------------------------------
VOID WINAPI InetFreeEncodedObject (
                IN LPCSTR pszObjectOid,
                IN PCRYPT_BLOB_ARRAY pObject,
                IN LPVOID pvFreeContext
                )
{
    assert( pvFreeContext == NULL );

    InetFreeCryptBlobArray( pObject );
}

//+---------------------------------------------------------------------------
//
//  Function:   InetCancelAsyncRetrieval
//
//  Synopsis:   cancel asynchronous object retrieval
//
//----------------------------------------------------------------------------
BOOL WINAPI InetCancelAsyncRetrieval (
                IN HCRYPTASYNC hAsyncRetrieve
                )
{
    SetLastError( (DWORD) E_NOTIMPL );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CInetSynchronousRetriever::CInetSynchronousRetriever, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CInetSynchronousRetriever::CInetSynchronousRetriever ()
{
    m_cRefs = 1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInetSynchronousRetriever::~CInetSynchronousRetriever, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CInetSynchronousRetriever::~CInetSynchronousRetriever ()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CInetSynchronousRetriever::AddRef, public
//
//  Synopsis:   IRefCountedObject::AddRef
//
//----------------------------------------------------------------------------
VOID
CInetSynchronousRetriever::AddRef ()
{
    InterlockedIncrement( (LONG *)&m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CInetSynchronousRetriever::Release, public
//
//  Synopsis:   IRefCountedObject::Release
//
//----------------------------------------------------------------------------
VOID
CInetSynchronousRetriever::Release ()
{
    if ( InterlockedDecrement( (LONG *)&m_cRefs ) == 0 )
    {
        delete this;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CInetSynchronousRetriever::RetrieveObjectByUrl, public
//
//  Synopsis:   IObjectRetriever::RetrieveObjectByUrl
//
//----------------------------------------------------------------------------
BOOL
CInetSynchronousRetriever::RetrieveObjectByUrl (
                                   LPCSTR pszUrl,
                                   LPCSTR pszObjectOid,
                                   DWORD dwRetrievalFlags,
                                   DWORD dwTimeout,
                                   LPVOID* ppvObject,
                                   PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                                   LPVOID* ppvFreeContext,
                                   HCRYPTASYNC hAsyncRetrieve,
                                   PCRYPT_CREDENTIALS pCredentials,
                                   LPVOID pvVerify,
                                   PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                                   )
{
    BOOL      fResult;
    DWORD     LastError = 0;
    HINTERNET hInetSession = NULL;
    CHAR      pszCanonicalUrl[INTERNET_MAX_PATH_LENGTH+1];

    assert( hAsyncRetrieve == NULL );

    fResult = InetGetBindings(
                  pszUrl,
                  dwRetrievalFlags,
                  dwTimeout,
                  &hInetSession,
                  INTERNET_MAX_PATH_LENGTH+1,
                  pszCanonicalUrl
                  );

#if DBG

    if ( fResult == TRUE )
    {
        printf( "Canonical URL to retrieve: %s\n", pszCanonicalUrl );
    }

#endif

    if ( fResult == TRUE )
    {
        fResult = InetSendReceiveUrlRequest(
                      hInetSession,
                      pszCanonicalUrl,
                      dwRetrievalFlags,
                      pCredentials,
                      (PCRYPT_BLOB_ARRAY)ppvObject,
                      pAuxInfo
                      );
    }

    if ( fResult == TRUE )
    {
        *ppfnFreeObject = InetFreeEncodedObject;
        *ppvFreeContext = NULL;
    }
    else
    {
        LastError = GetLastError();
    }

    InetFreeBindings( hInetSession );

    SetLastError( LastError );
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CInetSynchronousRetriever::CancelAsyncRetrieval, public
//
//  Synopsis:   IObjectRetriever::CancelAsyncRetrieval
//
//----------------------------------------------------------------------------
BOOL
CInetSynchronousRetriever::CancelAsyncRetrieval ()
{
    SetLastError( (DWORD) E_NOTIMPL );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   InetGetBindings
//
//  Synopsis:   get the session bindings
//
//----------------------------------------------------------------------------
BOOL
InetGetBindings (
    LPCSTR pszUrl,
    DWORD dwRetrievalFlags,
    DWORD dwTimeout,
    HINTERNET* phInetSession,
    DWORD cbCanonicalUrl,
    LPSTR pszCanonicalUrl
    )
{
    BOOL      fResult = TRUE;
    DWORD     LastError = 0;
    HINTERNET hInetSession;
    DWORD     dwSessionFlags = 0;

    //
    // Create and configure the session handle
    //

    if ( dwRetrievalFlags & CRYPT_ASYNC_RETRIEVAL )
    {
        dwSessionFlags |= INTERNET_FLAG_ASYNC;
    }

    if ( dwRetrievalFlags & CRYPT_CACHE_ONLY_RETRIEVAL )
    {
        dwSessionFlags |= INTERNET_FLAG_OFFLINE;
    }

    hInetSession = InternetOpen(
                           "CryptRetrieveObjectByUrl::InetSchemeProvider",
                           INTERNET_OPEN_TYPE_PRECONFIG,
                           NULL,
                           NULL,
                           dwSessionFlags
                           );

    if ( hInetSession == NULL )
    {
        return( FALSE );
    }

#if ASYNC_RETRIEVAL_SUPPORTED
    if ( dwRetrievalFlags & CRYPT_ASYNC_RETRIEVAL )
    {
        if ( InternetSetStatusCallback(
                     hInetSession,
                     InetAsyncStatusCallback
                     ) == INTERNET_INVALID_STATUS_CALLBACK )
        {
            SetLastError( (DWORD)INTERNET_INVALID_STATUS_CALLBACK );
            fResult = FALSE;
        }
    }
#endif

    if ( ( fResult == TRUE ) && ( dwTimeout != 0 ) )
    {
        DWORD dwOptionValue;

        dwOptionValue = 0;

        fResult = InternetSetOption(
                          hInetSession,
                          INTERNET_OPTION_CONNECT_RETRIES,
                          &dwOptionValue,
                          sizeof( DWORD )
                          );

        dwOptionValue = dwTimeout;

        if ( fResult == TRUE )
        {
            fResult = InternetSetOption(
                              hInetSession,
                              INTERNET_OPTION_CONNECT_TIMEOUT,
                              &dwOptionValue,
                              sizeof( DWORD )
                              );
        }

        if ( fResult == TRUE )
        {
            fResult = InternetSetOption(
                              hInetSession,
                              INTERNET_OPTION_CONTROL_SEND_TIMEOUT,
                              &dwOptionValue,
                              sizeof( DWORD )
                              );
        }

        if ( fResult == TRUE )
        {
            fResult = InternetSetOption(
                              hInetSession,
                              INTERNET_OPTION_CONTROL_RECEIVE_TIMEOUT,
                              &dwOptionValue,
                              sizeof( DWORD )
                              );
        }

        if ( fResult == TRUE )
        {
            fResult = InternetSetOption(
                              hInetSession,
                              INTERNET_OPTION_DATA_SEND_TIMEOUT,
                              &dwOptionValue,
                              sizeof( DWORD )
                              );
        }

        if ( fResult == TRUE )
        {
            fResult = InternetSetOption(
                              hInetSession,
                              INTERNET_OPTION_DATA_RECEIVE_TIMEOUT,
                              &dwOptionValue,
                              sizeof( DWORD )
                              );
        }
    }

    if ( fResult == TRUE )
    {
        BOOL fDisableAutodial = TRUE;

        fResult = InternetSetOption(
                          hInetSession,
                          INTERNET_OPTION_DISABLE_AUTODIAL,
                          &fDisableAutodial,
                          sizeof( BOOL )
                          );
    }

	//we turn off the auto proxy config since it will show a 
	//dialogue, which will hang a service (lsa.exe)
/*	if( fResult == TRUE )
	{
		dwSize=sizeof(IntOptList);

		memset(&IntOptList, 0, sizeof(IntOptList));
		
		IntOptList.dwSize=sizeof(IntOptList);
		IntOptList.pszConnection=NULL;
		IntOptList.dwOptionCount=1;
		IntOptList.pOptions=&IntOption;

		memset(&IntOption, 0, sizeof(IntOption));

		IntOption.dwOption=INTERNET_PER_CONN_FLAGS;

		fResult=InternetQueryOption(
						hInetSession,
						INTERNET_OPTION_PER_CONNECTION_OPTION,
						&IntOptList,
						&dwSize);

		if(fResult == TRUE)
		{
			IntOption.Value.dwValue &= ~(PROXY_TYPE_AUTO_DETECT | PROXY_TYPE_AUTO_PROXY_URL);

			fResult=InternetSetOption(
							hInetSession,
							INTERNET_OPTION_PER_CONNECTION_OPTION,
							&IntOptList,
							dwSize);
		}
	}  */

    //
    // Canonicalize the URL
    //

    if ( fResult == TRUE )
    {
        fResult = InternetCanonicalizeUrlA(
                          pszUrl,
                          pszCanonicalUrl,
                          &cbCanonicalUrl,
                          0
                          );
    }

    if ( fResult == TRUE )
    {
        *phInetSession = hInetSession;
    }
    else
    {
        LastError = GetLastError();
        InternetCloseHandle( hInetSession );
    }

    SetLastError( LastError );
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   InetFreeBindings
//
//  Synopsis:   free the inet session bindings
//
//----------------------------------------------------------------------------
VOID
InetFreeBindings (
    HINTERNET hInetSession
    )
{
    if ( hInetSession != NULL )
    {
        InternetCloseHandle( hInetSession );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   InetSendReceiveUrlRequest
//
//  Synopsis:   synchronous processing of an URL via WinInet
//
//----------------------------------------------------------------------------
BOOL
InetSendReceiveUrlRequest (
    HINTERNET hInetSession,
    LPSTR pszCanonicalUrl,
    DWORD dwRetrievalFlags,
    PCRYPT_CREDENTIALS pCredentials,
    PCRYPT_BLOB_ARRAY pcba,
    PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
    )
{
    BOOL                        fResult = TRUE;
    BOOL                        fDataAvailable = TRUE;
    DWORD                       LastError = 0;
    HINTERNET                   hInetConnect;
    HINTERNET                   hInetFile;
    DWORD                       dwOpenFlags = 0;
    ULONG                       cbRead;
    ULONG                       cbData;
    ULONG                       cb;
    ULONG                       cbPerRead;
    LPBYTE                      pb;
    CRYPT_PASSWORD_CREDENTIALSA PasswordCredentials;
    BOOL                        fFreeCredentials = FALSE;
    CHAR                        pszServer[MAX_PATH + 1];
    URL_COMPONENTSA             UrlComponents;
    DWORD                       dwService;
	PCRYPTNET_CANCEL_BLOCK		pCancelBlock=NULL;

    memset( &PasswordCredentials, 0, sizeof( PasswordCredentials ) );
    PasswordCredentials.cbSize = sizeof( PasswordCredentials );

    if ( SchemeGetPasswordCredentialsA(
               pCredentials,
               &PasswordCredentials,
               &fFreeCredentials
               ) == FALSE )
    {
        return( FALSE );
    }

    memset( &UrlComponents, 0, sizeof( UrlComponents ) );
    UrlComponents.dwStructSize = sizeof( UrlComponents );
    UrlComponents.dwHostNameLength = MAX_PATH;
    UrlComponents.lpszHostName = pszServer;

    if ( InternetCrackUrlA(
                 pszCanonicalUrl,
                 0,
                 0,
                 &UrlComponents
                 ) == FALSE )
    {
        return( FALSE );
    }

    switch ( UrlComponents.nScheme )
    {
    case INTERNET_SCHEME_HTTP:
    case INTERNET_SCHEME_HTTPS:
        dwService = INTERNET_SERVICE_HTTP;
        break;
    case INTERNET_SCHEME_FTP:
        dwService = INTERNET_SERVICE_FTP;
        break;
    case INTERNET_SCHEME_GOPHER:
        dwService = INTERNET_SERVICE_GOPHER;
        break;
    default:
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    if ( ( hInetConnect = InternetConnect(
                                  hInetSession,
                                  UrlComponents.lpszHostName,
                                  UrlComponents.nPort,
                                  PasswordCredentials.pszUsername,
                                  PasswordCredentials.pszPassword,
                                  dwService,
                                  0,
                                  0
                                  ) ) == NULL )
    {
        return( FALSE );
    }

    if ( fFreeCredentials == TRUE )
    {
        SchemeFreePasswordCredentialsA( &PasswordCredentials );
    }

    if ( dwRetrievalFlags & CRYPT_DONT_CACHE_RESULT )
    {
        dwOpenFlags |= INTERNET_FLAG_DONT_CACHE;
    }

    if ( dwRetrievalFlags & CRYPT_WIRE_ONLY_RETRIEVAL )
    {
        dwOpenFlags |= INTERNET_FLAG_RELOAD;
    }

    if ( dwRetrievalFlags & CRYPT_NO_AUTH_RETRIEVAL )
    {
        dwOpenFlags |= INTERNET_FLAG_NO_AUTH;
    }

    //         We hope that INTERNET_FLAG_EXISTING_CONNECT will cause the
    //         previous InternetConnect handle we opened to be used so that
    //         the appropriate username and password will be set.  If not
    //         we will have to implement access to each of the protocols
    //         ourselves and that would make me very unhappy :-(
    dwOpenFlags |= INTERNET_FLAG_RAW_DATA | INTERNET_FLAG_EXISTING_CONNECT;

    hInetFile = InternetOpenUrl(
                        hInetSession,
                        pszCanonicalUrl,
                        "Accept: */*\r\n",
                        (DWORD) -1L,
                        dwOpenFlags,
                        0
                        );

    if ( hInetFile == NULL )
    {
        LastError = GetLastError();
        InternetCloseHandle( hInetConnect );
        SetLastError( LastError );
        return( FALSE );
    }

    if ( ( ( UrlComponents.nScheme == INTERNET_SCHEME_HTTP ) ||
           ( UrlComponents.nScheme == INTERNET_SCHEME_HTTPS ) ) &&
         ( !( dwRetrievalFlags & CRYPT_CACHE_ONLY_RETRIEVAL ) ) )
    {
        DWORD dwStatus;
        DWORD dwSizeofStatus = sizeof( dwStatus );

        if ( HttpQueryInfo(
                 hInetFile,
                 HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE,
                 &dwStatus,
                 &dwSizeofStatus,
                 NULL
                 ) == FALSE )
        {
            dwStatus = HTTP_STATUS_OK;
        }

        if ( dwStatus != HTTP_STATUS_OK )
        {
            InternetCloseHandle( hInetFile );
            InternetCloseHandle( hInetConnect );
            SetLastError( dwStatus );
            return( FALSE );
        }
    }

    cbRead = 0;
    cb = INET_INITIAL_DATA_BUFFER_SIZE;
    pb = CCryptBlobArray::AllocBlob( cb );
    if ( pb == NULL )
    {
        fResult = FALSE;
        SetLastError( (DWORD) E_OUTOFMEMORY );
    }

	pCancelBlock=(PCRYPTNET_CANCEL_BLOCK)I_CryptGetTls(hCryptNetCancelTls);

    while ( ( fResult == TRUE ) && ( fDataAvailable == TRUE ) )
    {
		if(pCancelBlock)
		{
			if(pCancelBlock->pfnCancel(0, pCancelBlock->pvArg))
				fResult=FALSE;
		}

		if(FALSE == fResult) 
		{
			SetLastError((DWORD) ERROR_CANCELLED);
		}
		else
		{
			fDataAvailable = InternetQueryDataAvailable( hInetFile, &cbData, 0, 0 );

			if ( ( fDataAvailable == TRUE ) && ( cbData == 0 ) )
			{
				fDataAvailable = FALSE;
			}

			if ( fDataAvailable == TRUE )
			{
				if ( cb < ( cbRead + cbData ) )
				{
					pb = CCryptBlobArray::ReallocBlob(
												 pb,
												 cb + cbData +
												 INET_GROW_DATA_BUFFER_SIZE
												 );

					if ( pb != NULL )
					{
						cb += cbData + INET_GROW_DATA_BUFFER_SIZE;
					}
					else
					{
						fResult = FALSE;
						SetLastError( (DWORD) E_OUTOFMEMORY );
					}
				}

				fResult = InternetReadFile(
								  hInetFile,
								  ( pb+cbRead ),
								  cbData,
								  &cbPerRead
								  );

				if ( fResult == TRUE )
				{
					cbRead += cbPerRead;
				}
			}
		}
    }

    if ( fResult == TRUE )
    {
        if ( !( dwRetrievalFlags & CRYPT_DONT_CACHE_RESULT ) )
        {
            fResult = SchemeRetrieveCachedAuxInfo (
                        pszCanonicalUrl,
                        dwRetrievalFlags,
                        pAuxInfo
                        );
        }
        else
        {
            fResult = SchemeRetrieveUncachedAuxInfo( pAuxInfo );
        }
    }

    if ( fResult == TRUE )
    {
        CCryptBlobArray cba( 1, 1, fResult );

        if ( fResult == TRUE )
        {
            fResult = cba.AddBlob( cbRead, pb, FALSE );
        }

        if ( fResult == TRUE )
        {
            cba.GetArrayInNativeForm( pcba );
        }
        else
        {
            cba.FreeArray( FALSE );
        }
    }

    if ( fResult != TRUE )
    {
        if ( pb != NULL )
        {
            CCryptBlobArray::FreeBlob( pb );
        }

        LastError = GetLastError();
    }

    InternetCloseHandle( hInetFile );
    InternetCloseHandle( hInetConnect );

    SetLastError( LastError );
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   InetFreeCryptBlobArray
//
//  Synopsis:   free the crypt blob array
//
//----------------------------------------------------------------------------
VOID
InetFreeCryptBlobArray (
    PCRYPT_BLOB_ARRAY pcba
    )
{
    CCryptBlobArray cba( pcba, 0 );

    cba.FreeArray( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   InetAsyncStatusCallback
//
//  Synopsis:   status callback for async
//
//----------------------------------------------------------------------------
VOID WINAPI
InetAsyncStatusCallback (
    HINTERNET hInet,
    DWORD dwContext,
    DWORD dwInternetStatus,
    LPVOID pvStatusInfo,
    DWORD dwStatusLength
    )
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\inetsp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       inetsp.h
//
//  Contents:   Inet (HTTP, FTP, GOPHER) scheme provider definitions
//
//  History:    05-Aug-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__INETSP_H__)
#define __INETSP_H__

#include <orm.h>
#include <wininet.h>

//
// Inet scheme provider entry points
//

#define HTTP_SCHEME   "http"
#define HTTPS_SCHEME  "https"
#define FTP_SCHEME    "ftp"
#define GOPHER_SCHEME "gopher"

extern HCRYPTTLS hCryptNetCancelTls;

typedef struct _CRYPTNET_CANCEL_BLOCK {
    PFN_CRYPT_CANCEL_RETRIEVAL pfnCancel; 
    void *pvArg;
} CRYPTNET_CANCEL_BLOCK, *PCRYPTNET_CANCEL_BLOCK;



BOOL WINAPI InetRetrieveEncodedObject (
                IN LPCSTR pszUrl,
                IN LPCSTR pszObjectOid,
                IN DWORD dwRetrievalFlags,
                IN DWORD dwTimeout,
                OUT PCRYPT_BLOB_ARRAY pObject,
                OUT PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                OUT LPVOID* ppvFreeContext,
                IN HCRYPTASYNC hAsyncRetrieve,
                IN PCRYPT_CREDENTIALS pCredentials,
                IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                );

VOID WINAPI InetFreeEncodedObject (
                IN LPCSTR pszObjectOid,
                IN PCRYPT_BLOB_ARRAY pObject,
                IN LPVOID pvFreeContext
                );

BOOL WINAPI InetCancelAsyncRetrieval (
                IN HCRYPTASYNC hAsyncRetrieve
                );

//
// Inet Synchronous Object Retriever
//

class CInetSynchronousRetriever : public IObjectRetriever
{
public:

    //
    // Construction
    //

    CInetSynchronousRetriever ();
    ~CInetSynchronousRetriever ();

    //
    // IRefCountedObject methods
    //

    virtual VOID AddRef ();
    virtual VOID Release ();

    //
    // IObjectRetriever methods
    //

    virtual BOOL RetrieveObjectByUrl (
                         LPCSTR pszUrl,
                         LPCSTR pszObjectOid,
                         DWORD dwRetrievalFlags,
                         DWORD dwTimeout,
                         LPVOID* ppvObject,
                         PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                         LPVOID* ppvFreeContext,
                         HCRYPTASYNC hAsyncRetrieve,
                         PCRYPT_CREDENTIALS pCredentials,
                         LPVOID pvVerify,
                         PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                         );

    virtual BOOL CancelAsyncRetrieval ();

private:

    //
    // Reference count
    //

    ULONG m_cRefs;
};

//
// Inet Scheme Provider Support API
//

#define INET_INITIAL_DATA_BUFFER_SIZE 4096
#define INET_GROW_DATA_BUFFER_SIZE    4096

BOOL
InetGetBindings (
    LPCSTR pszUrl,
    DWORD dwRetrievalFlags,
    DWORD dwTimeout,
    HINTERNET* phInetSession,
    DWORD cbCanonicalUrl,
    LPSTR pszCanonicalUrl
    );

VOID
InetFreeBindings (
    HINTERNET hInetSession
    );

BOOL
InetSendReceiveUrlRequest (
    HINTERNET hInetSession,
    LPSTR pszCanonicalUrl,
    DWORD dwRetrievalFlags,
    PCRYPT_CREDENTIALS pCredentials,
    PCRYPT_BLOB_ARRAY pcba,
    PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
    );

VOID
InetFreeCryptBlobArray (
    PCRYPT_BLOB_ARRAY pcba
    );

VOID WINAPI
InetAsyncStatusCallback (
    HINTERNET hInet,
    DWORD dwContext,
    DWORD dwInternetStatus,
    LPVOID pvStatusInfo,
    DWORD dwStatusLength
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\ldapsp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ldapsp.cpp
//
//  Contents:   LDAP Scheme Provider for Remote Object Retrieval
//
//  History:    23-Jul-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Function:   LdapRetrieveEncodedObject
//
//  Synopsis:   retrieve encoded object via LDAP protocol
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapRetrieveEncodedObject (
                IN LPCSTR pszUrl,
                IN LPCSTR pszObjectOid,
                IN DWORD dwRetrievalFlags,
                IN DWORD dwTimeout,
                OUT PCRYPT_BLOB_ARRAY pObject,
                OUT PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                OUT LPVOID* ppvFreeContext,
                IN HCRYPTASYNC hAsyncRetrieve,
                IN PCRYPT_CREDENTIALS pCredentials,
                IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                )
{
    BOOL              fResult;
    IObjectRetriever* por = NULL;

    if ( !( dwRetrievalFlags & CRYPT_ASYNC_RETRIEVAL ) )
    {
        por = new CLdapSynchronousRetriever;
    }

    if ( por == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    fResult = por->RetrieveObjectByUrl(
                           pszUrl,
                           pszObjectOid,
                           dwRetrievalFlags,
                           dwTimeout,
                           (LPVOID *)pObject,
                           ppfnFreeObject,
                           ppvFreeContext,
                           hAsyncRetrieve,
                           pCredentials,
                           NULL,
                           pAuxInfo
                           );

    por->Release();

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapFreeEncodedObject
//
//  Synopsis:   free encoded object retrieved via LdapRetrieveEncodedObject
//
//----------------------------------------------------------------------------
VOID WINAPI LdapFreeEncodedObject (
                IN LPCSTR pszObjectOid,
                IN PCRYPT_BLOB_ARRAY pObject,
                IN LPVOID pvFreeContext
                )
{
    assert( pvFreeContext == NULL );

    LdapFreeCryptBlobArray( pObject );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapCancelAsyncRetrieval
//
//  Synopsis:   cancel asynchronous object retrieval
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapCancelAsyncRetrieval (
                IN HCRYPTASYNC hAsyncRetrieve
                )
{
    SetLastError( (DWORD) E_NOTIMPL );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapSynchronousRetriever::CLdapSynchronousRetriever, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CLdapSynchronousRetriever::CLdapSynchronousRetriever ()
{
    m_cRefs = 1;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapSynchronousRetriever::~CLdapSynchronousRetriever, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CLdapSynchronousRetriever::~CLdapSynchronousRetriever ()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapSynchronousRetriever::AddRef, public
//
//  Synopsis:   IRefCountedObject::AddRef
//
//----------------------------------------------------------------------------
VOID
CLdapSynchronousRetriever::AddRef ()
{
    InterlockedIncrement( (LONG *)&m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapSynchronousRetriever::Release, public
//
//  Synopsis:   IRefCountedObject::Release
//
//----------------------------------------------------------------------------
VOID
CLdapSynchronousRetriever::Release ()
{
    if ( InterlockedDecrement( (LONG *)&m_cRefs ) == 0 )
    {
        delete this;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapSynchronousRetriever::RetrieveObjectByUrl, public
//
//  Synopsis:   IObjectRetriever::RetrieveObjectByUrl
//
//----------------------------------------------------------------------------
BOOL
CLdapSynchronousRetriever::RetrieveObjectByUrl (
                                   LPCSTR pszUrl,
                                   LPCSTR pszObjectOid,
                                   DWORD dwRetrievalFlags,
                                   DWORD dwTimeout,
                                   LPVOID* ppvObject,
                                   PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                                   LPVOID* ppvFreeContext,
                                   HCRYPTASYNC hAsyncRetrieve,
                                   PCRYPT_CREDENTIALS pCredentials,
                                   LPVOID pvVerify,
                                   PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                                   )
{
    BOOL                fResult;
    DWORD               LastError = 0;
    LDAP_URL_COMPONENTS LdapUrlComponents;
    LDAP*               pld = NULL;
    BOOL                fLdapUrlCracked = FALSE;

    assert( hAsyncRetrieve == NULL );

    if ( dwRetrievalFlags & CRYPT_CACHE_ONLY_RETRIEVAL )
    {
        return( SchemeRetrieveCachedCryptBlobArray(
                      pszUrl,
                      dwRetrievalFlags,
                      (PCRYPT_BLOB_ARRAY)ppvObject,
                      ppfnFreeObject,
                      ppvFreeContext,
                      pAuxInfo
                      ) );
    }

    fResult = LdapCrackUrl( pszUrl, &LdapUrlComponents );

#if DBG

    if ( fResult == TRUE )
    {
        LdapDisplayUrlComponents( &LdapUrlComponents );
    }

#endif

    if ( fResult == TRUE )
    {
        fLdapUrlCracked = TRUE;

        if ( dwRetrievalFlags & CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL )
        {
            if ( LdapUrlComponents.Scope != LDAP_SCOPE_BASE )
            {
                fResult = FALSE;
                SetLastError( (DWORD) E_INVALIDARG );
            }
        }
    }

    if ( fResult == TRUE )
    {
        DWORD iAuth;

        if ( dwRetrievalFlags &
                (CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL |
                    CRYPT_LDAP_SIGN_RETRIEVAL) )
        {
            // Only attempt AUTH_SSPI binds
            iAuth = 1;
        }
        else
        {
            // First attempt AUTH_SIMPLE bind. If that fails or returns
            // nothing, then, attempt AUTH_SSPI bind.
            iAuth = 0;
        }

        for ( ; iAuth < 2; iAuth++)
        {
            fResult = LdapGetBindings(
                LdapUrlComponents.pszHost,
                LdapUrlComponents.Port,
                dwRetrievalFlags,
                0 == iAuth ? LDAP_BIND_AUTH_SIMPLE_ENABLE_FLAG :
                             LDAP_BIND_AUTH_SSPI_ENABLE_FLAG,
                dwTimeout,
                pCredentials,
                &pld
                );

            if ( fResult == TRUE )
            {
                fResult = LdapSendReceiveUrlRequest(
                    pld,
                    &LdapUrlComponents,
                    dwRetrievalFlags,
                    dwTimeout,
                    (PCRYPT_BLOB_ARRAY)ppvObject
                    );

                if ( fResult == TRUE )
                {
                    break;
                }
                else
                {
                    LastError = GetLastError();
                    LdapFreeBindings( pld );
                    pld = NULL;
                    SetLastError( LastError );
                }
            }
        }
    }

    if ( fResult == TRUE )
    {
        if ( !( dwRetrievalFlags & CRYPT_DONT_CACHE_RESULT ) )
        {
            fResult = SchemeCacheCryptBlobArray(
                            pszUrl,
                            dwRetrievalFlags,
                            (PCRYPT_BLOB_ARRAY)ppvObject,
                            pAuxInfo
                            );

            if ( fResult == FALSE )
            {
                LdapFreeEncodedObject(
                    pszObjectOid,
                    (PCRYPT_BLOB_ARRAY)ppvObject,
                    NULL
                    );
            }
        }
        else
        {
            SchemeRetrieveUncachedAuxInfo( pAuxInfo );
        }
    }

    if ( fResult == TRUE )
    {
        *ppfnFreeObject = LdapFreeEncodedObject;
        *ppvFreeContext = NULL;
    }
    else
    {
        LastError = GetLastError();
    }

    if ( fLdapUrlCracked == TRUE )
    {
        LdapFreeUrlComponents( &LdapUrlComponents );
    }

    LdapFreeBindings( pld );

    SetLastError( LastError );
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapSynchronousRetriever::CancelAsyncRetrieval, public
//
//  Synopsis:   IObjectRetriever::CancelAsyncRetrieval
//
//----------------------------------------------------------------------------
BOOL
CLdapSynchronousRetriever::CancelAsyncRetrieval ()
{
    SetLastError( (DWORD) E_NOTIMPL );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapCrackUrl
//
//  Synopsis:   Crack an LDAP URL into its relevant parts.  The result must
//              be freed using LdapFreeUrlComponents
//
//----------------------------------------------------------------------------
BOOL
LdapCrackUrl (
    LPCSTR pszUrl,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    BOOL  fResult = TRUE;
    ULONG cbUrl = INTERNET_MAX_PATH_LENGTH;
    LPSTR pszHostInfo = NULL;
    LPSTR pszDN = NULL;
    LPSTR pszAttrList = NULL;
    LPSTR pszScope = NULL;
    LPSTR pszFilter = NULL;
    LPSTR pszToken = NULL;
    CHAR  psz[INTERNET_MAX_PATH_LENGTH+1];

    //
    // Capture the URL and initialize the out parameter
    //

    __try
    {
        if ( InternetCanonicalizeUrlA(
                     pszUrl,
                     psz,
                     &cbUrl,
                     ICU_NO_ENCODE | ICU_DECODE
                     ) == FALSE )
        {
            return( FALSE );
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError( GetExceptionCode() );
        return( FALSE );
    }

    memset( pLdapUrlComponents, 0, sizeof( LDAP_URL_COMPONENTS ) );

    //
    // Find the host
    //

    pszHostInfo = psz + sizeof( "ldap://" ) - sizeof( CHAR );
    if ( *pszHostInfo == '/' )
    {
        pszToken = pszHostInfo + 1;
        pszHostInfo = NULL;
    }
    else
    {
#if 0
        pszHostInfo = strtok( pszHostInfo, "/" );
#else
        pszToken = pszHostInfo;
        while ( ( *pszToken != '\0' ) && ( *pszToken != '/' ) )
            pszToken++;

        if ( *pszToken == '/' )
        {
            *pszToken = '\0';
            pszToken += 1;
        }

        while ( *pszToken == '/' )
            pszToken++;
#endif

    }

    //
    // Find the DN
    //

    if ( pszToken != NULL )
    {
        pszDN = "";

        if ( *pszToken != '\0' )
        {
            if ( *pszToken == '?' )
            {
                pszToken += 1;
            }
            else
            {
                pszDN = pszToken;

                do
                {
                    pszToken += 1;
                }
                while ( ( *pszToken != '\0' ) && ( *pszToken != '?' ) );

                if ( *pszToken == '?' )
                {
                    *pszToken = '\0';
                    pszToken += 1;
                }
            }
        }
    }
    else
    {
        pszDN = strtok( pszToken, "?" );
        pszToken = NULL;
        if ( pszDN == NULL )
        {
            SetLastError( (DWORD) E_INVALIDARG );
            return( FALSE );
        }
    }

    //
    // Check for attributes
    //

    if ( pszToken != NULL )
    {
        if ( *pszToken == '?' )
        {
            pszAttrList = "";
            pszToken += 1;
        }
        else if ( *pszToken == '\0' )
        {
            pszAttrList = NULL;
        }
        else
        {
            pszAttrList = strtok( pszToken, "?" );
            pszToken = NULL;
        }
    }
    else
    {
        pszAttrList = strtok( NULL, "?" );
    }

    //
    // Check for a scope and filter
    //

    if ( pszAttrList != NULL )
    {
        pszScope = strtok( pszToken, "?" );
        if ( pszScope != NULL )
        {
            pszFilter = strtok( NULL, "?" );
        }
    }

    if ( pszScope == NULL )
    {
        pszScope = "base";
    }

    if ( pszFilter == NULL )
    {
        pszFilter = "(objectClass=*)";
    }

    //
    // Now we build up our URL components
    //

    fResult = LdapParseCrackedHost( pszHostInfo, pLdapUrlComponents );

    if ( fResult == TRUE )
    {
        fResult = LdapParseCrackedDN( pszDN, pLdapUrlComponents );
    }

    if ( fResult == TRUE )
    {
        fResult = LdapParseCrackedAttributeList(
                      pszAttrList,
                      pLdapUrlComponents
                      );
    }

    if ( fResult == TRUE )
    {
        fResult = LdapParseCrackedScopeAndFilter(
                      pszScope,
                      pszFilter,
                      pLdapUrlComponents
                      );
    }

    if ( fResult != TRUE )
    {
        LdapFreeUrlComponents( pLdapUrlComponents );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapParseCrackedHost
//
//  Synopsis:   Parse the cracked host string (pszHost is modified)
//
//----------------------------------------------------------------------------
BOOL
LdapParseCrackedHost (
    LPSTR pszHost,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    LPSTR pszPort;

    if ( pszHost == NULL )
    {
        pLdapUrlComponents->pszHost = NULL;
        pLdapUrlComponents->Port = LDAP_PORT;
        return( TRUE );
    }

    pszPort = strchr( pszHost, ':' );
    if ( pszPort != NULL )
    {
        *pszPort = '\0';
        pszPort++;
    }

    pLdapUrlComponents->pszHost = new CHAR [strlen( pszHost ) + 1];
    if ( pLdapUrlComponents->pszHost == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    strcpy( pLdapUrlComponents->pszHost, pszHost );
    pLdapUrlComponents->Port = 0;

    if ( pszPort != NULL )
    {
        pLdapUrlComponents->Port = atol( pszPort );
    }

    if ( pLdapUrlComponents->Port == 0 )
    {
        pLdapUrlComponents->Port = LDAP_PORT;
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapParseCrackedDN
//
//  Synopsis:   Parse the cracked DN
//
//----------------------------------------------------------------------------
BOOL
LdapParseCrackedDN (
    LPSTR pszDN,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    pLdapUrlComponents->pszDN = new CHAR [strlen( pszDN ) + 1];
    if ( pLdapUrlComponents->pszDN == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    strcpy( pLdapUrlComponents->pszDN, pszDN );
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapParseCrackedAttributeList
//
//  Synopsis:   Parse the cracked attribute list
//
//----------------------------------------------------------------------------
BOOL
LdapParseCrackedAttributeList (
    LPSTR pszAttrList,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    LPSTR psz;
    LPSTR pszAttr;
    ULONG cAttr = 0;
    ULONG cCount;

    if ( ( pszAttrList == NULL ) || ( strlen( pszAttrList ) == 0 ) )
    {
        pLdapUrlComponents->cAttr = 0;
        pLdapUrlComponents->apszAttr = NULL;
        return( TRUE );
    }

    psz = new CHAR [strlen( pszAttrList ) + 1];
    if ( psz == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    strcpy( psz, pszAttrList );

    pszAttr = strtok( psz, "," );
    while ( pszAttr != NULL )
    {
        cAttr += 1;
        pszAttr = strtok( NULL, "," );
    }

    pLdapUrlComponents->apszAttr = new LPSTR [cAttr+1];
    if ( pLdapUrlComponents->apszAttr == NULL )
    {
        delete psz;
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    pLdapUrlComponents->cAttr = cAttr;
    for ( cCount = 0; cCount < cAttr; cCount++ )
    {
        pLdapUrlComponents->apszAttr[cCount] = psz;
        psz += ( strlen(psz) + 1 );
    }

    pLdapUrlComponents->apszAttr[cAttr] = NULL;

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapParseCrackedScopeAndFilter
//
//  Synopsis:   Parse the cracked scope and filter
//
//----------------------------------------------------------------------------
BOOL
LdapParseCrackedScopeAndFilter (
    LPSTR pszScope,
    LPSTR pszFilter,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    ULONG Scope;

    if ( _stricmp( pszScope, "base" ) == 0 )
    {
        Scope = LDAP_SCOPE_BASE;
    }
    else if ( _stricmp( pszScope, "one" ) == 0 )
    {
        Scope = LDAP_SCOPE_ONELEVEL;
    }
    else if ( _stricmp( pszScope, "sub" ) == 0 )
    {
        Scope = LDAP_SCOPE_SUBTREE;
    }
    else
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    pLdapUrlComponents->pszFilter = new CHAR [strlen( pszFilter ) + 1];
    if ( pLdapUrlComponents->pszFilter == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    strcpy( pLdapUrlComponents->pszFilter, pszFilter );
    pLdapUrlComponents->Scope = Scope;

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapFreeUrlComponents
//
//  Synopsis:   Frees allocate URL components returned from LdapCrackUrl
//
//----------------------------------------------------------------------------
VOID
LdapFreeUrlComponents (
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    delete pLdapUrlComponents->pszHost;
    delete pLdapUrlComponents->pszDN;

    if ( pLdapUrlComponents->apszAttr != NULL )
    {
        delete pLdapUrlComponents->apszAttr[0];
    }

    delete pLdapUrlComponents->apszAttr;
    delete pLdapUrlComponents->pszFilter;
}


//+---------------------------------------------------------------------------
//
//  Function:   LdapGetBindings
//
//  Synopsis:   allocates and initializes the LDAP session binding
//
//----------------------------------------------------------------------------
BOOL
LdapGetBindings (
    LPSTR pszHost,
    ULONG Port,
    DWORD dwRetrievalFlags,
    DWORD dwBindFlags,
    DWORD dwTimeout,                    // milliseconds
    PCRYPT_CREDENTIALS pCredentials,
    LDAP** ppld
    )
{
    BOOL                        fResult = TRUE;
    DWORD                       LastError = 0;
    CRYPT_PASSWORD_CREDENTIALSA PasswordCredentials;
    LDAP*                       pld = NULL;
    BOOL                        fFreeCredentials = FALSE;

    memset( &PasswordCredentials, 0, sizeof( PasswordCredentials ) );
    PasswordCredentials.cbSize = sizeof( PasswordCredentials );

    if ( SchemeGetPasswordCredentialsA(
               pCredentials,
               &PasswordCredentials,
               &fFreeCredentials
               ) == FALSE )
    {
        return( FALSE );
    }

    pld = ldap_initA( pszHost, Port );
    if ( pld != NULL )
    {
        SEC_WINNT_AUTH_IDENTITY_A AuthIdentity;
        ULONG                     ldaperr;
        struct l_timeval          tv;
        struct l_timeval          *ptv = NULL;

        if (dwRetrievalFlags & CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL)
        {
            void                      *pvOn;
            pvOn = LDAP_OPT_ON;
            ldap_set_option(
                pld,
                LDAP_OPT_AREC_EXCLUSIVE,
                &pvOn
                );
        }

        // Note, dwTimeout is in units of milliseconds.
        // LDAP_OPT_TIMELIMIT is in units of seconds.
        if ( 0 != dwTimeout )
        {
            DWORD dwTimeoutSeconds = dwTimeout / 1000;

            if ( LDAP_MIN_TIMEOUT_SECONDS > dwTimeoutSeconds )
            {
                dwTimeoutSeconds = LDAP_MIN_TIMEOUT_SECONDS;
            }

            tv.tv_sec = dwTimeoutSeconds;
            tv.tv_usec = 0;
            ptv = &tv;

            ldap_set_option( pld, LDAP_OPT_TIMELIMIT,
                (void *)&dwTimeoutSeconds );
        }

        ldaperr = ldap_connect( pld, ptv );

        if ( ( ldaperr != LDAP_SUCCESS ) && ( pszHost == NULL ) )
        {
            DWORD dwFlags = DS_FORCE_REDISCOVERY;
            ULONG ldapsaveerr = ldaperr;

            ldaperr = ldap_set_option(
                           pld,
                           LDAP_OPT_GETDSNAME_FLAGS,
                           (LPVOID)&dwFlags
                           );

            if ( ldaperr == LDAP_SUCCESS )
            {
                ldaperr = ldap_connect( pld, ptv );

            }
            else
            {
                ldaperr = ldapsaveerr;
            }
        }

        if ( ldaperr != LDAP_SUCCESS )
        {
            fResult = FALSE;
            SetLastError( LdapMapErrorToWin32( ldaperr ) );
        }

        if ( fResult == TRUE )
        {
            LPSTR                     pRestore;

            SchemeGetAuthIdentityFromPasswordCredentialsA(
                  &PasswordCredentials,
                  &AuthIdentity,
                  &pRestore
                  );

#if DBG
            printf(
               "Credentials = %s\\%s <%s>\n",
               AuthIdentity.Domain,
               AuthIdentity.User,
               AuthIdentity.Password
               );
#endif

            fResult = LdapSSPIOrSimpleBind(
                          pld,
                          &AuthIdentity,
                          dwRetrievalFlags,
                          dwBindFlags
                          );

            // following doesn't globber LastError
            SchemeRestorePasswordCredentialsFromAuthIdentityA(
                  &PasswordCredentials,
                  &AuthIdentity,
                  pRestore
                  );
        }
    }
    else
    {
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        *ppld = pld;
    }
    else
    {
        LastError = GetLastError();
        LdapFreeBindings( pld );
    }

    if ( fFreeCredentials == TRUE )
    {
        SchemeFreePasswordCredentialsA( &PasswordCredentials );
    }

    SetLastError( LastError );
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapFreeBindings
//
//  Synopsis:   frees allocated LDAP session binding
//
//----------------------------------------------------------------------------
VOID
LdapFreeBindings (
    LDAP* pld
    )
{
    if ( pld != NULL )
    {
        ldap_unbind_s( pld );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapSendReceiveUrlRequest
//
//  Synopsis:   sends an URL based search request to the LDAP server, receives
//              the result message and converts it to a CRYPT_BLOB_ARRAY of
//              encoded object bits
//
//----------------------------------------------------------------------------
BOOL
LdapSendReceiveUrlRequest (
    LDAP* pld,
    PLDAP_URL_COMPONENTS pLdapUrlComponents,
    DWORD dwRetrievalFlags,
    DWORD dwTimeout,        // milliseconds
    PCRYPT_BLOB_ARRAY pcba
    )
{
    BOOL         fResult;
    DWORD        LastError = 0;
    ULONG        lderr;
    LDAPMessage* plm = NULL;

    if ( 0 != dwTimeout )
    {
        DWORD dwTimeoutSeconds = dwTimeout / 1000;
        struct l_timeval tv;

        if ( LDAP_MIN_TIMEOUT_SECONDS > dwTimeoutSeconds )
        {
            dwTimeoutSeconds = LDAP_MIN_TIMEOUT_SECONDS;
        }

        tv.tv_sec = dwTimeoutSeconds;
        tv.tv_usec = 0;

        lderr = ldap_search_st(
                 pld,
                 pLdapUrlComponents->pszDN,
                 pLdapUrlComponents->Scope,
                 pLdapUrlComponents->pszFilter,
                 pLdapUrlComponents->apszAttr,
                 FALSE,
                 &tv,
                 &plm
                 );
    }
    else
    {
        lderr = ldap_search_s(
                 pld,
                 pLdapUrlComponents->pszDN,
                 pLdapUrlComponents->Scope,
                 pLdapUrlComponents->pszFilter,
                 pLdapUrlComponents->apszAttr,
                 FALSE,
                 &plm
                 );
    }

    if ( lderr != LDAP_SUCCESS )
    {
        if ( plm != NULL )
        {
            ldap_msgfree( plm );
        }

        SetLastError( LdapMapErrorToWin32( lderr ) );
        return( FALSE );
    }

    fResult = LdapConvertLdapResultMessage( pld, plm, dwRetrievalFlags, pcba );
    if ( !fResult )
    {
        LastError = GetLastError();
    }
    ldap_msgfree( plm );

    SetLastError( LastError );
    return( fResult );
}


//+---------------------------------------------------------------------------
//
//  Function:   LdapConvertResultMessage
//
//  Synopsis:   convert returned LDAP message to a crypt blob array
//
//----------------------------------------------------------------------------
BOOL
LdapConvertLdapResultMessage (
    LDAP* pld,
    PLDAPMessage plm,
    DWORD dwRetrievalFlags,
    PCRYPT_BLOB_ARRAY pcba
    )
{
    BOOL            fResult = TRUE;
    PLDAPMessage    plmElem;
    BerElement*     pber;
    CHAR*           pszAttr;
    struct berval** apbv;
    ULONG           cCount;
    CCryptBlobArray cba( 10, 5, fResult );
    DWORD           dwIndex;
    ULONG           cbIndex = 0;
    char            szIndex[33];

    for ( plmElem = ldap_first_entry( pld, plm ), dwIndex = 0;
          ( plmElem != NULL ) && ( fResult == TRUE );
          plmElem = ldap_next_entry( pld, plmElem ), dwIndex++ )
    {
        if ( dwRetrievalFlags & CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE )
        {
            _ltoa(dwIndex, szIndex, 10);
            cbIndex = strlen(szIndex) + 1;
        }

        for ( pszAttr = ldap_first_attributeA( pld, plmElem, &pber );
              ( pszAttr != NULL ) && ( fResult == TRUE );
              pszAttr = ldap_next_attributeA( pld, plmElem, pber ) )
        {
            apbv = ldap_get_values_lenA( pld, plmElem, pszAttr );
            if ( apbv == NULL )
            {
                fResult = FALSE;
            }

            for ( cCount = 0;
                  ( fResult == TRUE ) && ( apbv[cCount] != NULL );
                  cCount++ )
            {
                ULONG cbAttr = 0;
                ULONG cbVal;
                ULONG cbToAdd;
                LPBYTE pbToAdd;

                cbToAdd = cbVal = apbv[cCount]->bv_len;

                if ( dwRetrievalFlags & CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE )
                {
                    cbAttr = strlen(pszAttr) + 1;
                    cbToAdd += cbIndex + cbAttr;
                }

                pbToAdd = cba.AllocBlob( cbToAdd );
                if ( pbToAdd != NULL )
                {
                    LPBYTE pb;

                    pb = pbToAdd;
                    if ( dwRetrievalFlags & CRYPT_LDAP_INSERT_ENTRY_ATTRIBUTE )
                    {
                        memcpy( pb, szIndex, cbIndex );
                        pb += cbIndex;
                        memcpy( pb, pszAttr, cbAttr );
                        pb += cbAttr;
                    }
                    memcpy( pb, (LPBYTE)apbv[cCount]->bv_val, cbVal );
                }
                else
                {
                    SetLastError( (DWORD) E_OUTOFMEMORY );
                    fResult = FALSE;
                }

                if ( fResult == TRUE )
                {
                    fResult = cba.AddBlob(
                                     cbToAdd,
                                     pbToAdd,
                                     FALSE
                                     );
                    if ( fResult == FALSE )
                    {
                        cba.FreeBlob( pbToAdd );
                    }
                }
            }

            ldap_value_free_len( apbv );
        }
    }

    if ( fResult == TRUE )
    {
        if ( cba.GetBlobCount() > 0 )
        {
            cba.GetArrayInNativeForm( pcba );
        }
        else
        {
            cba.FreeArray( TRUE );
            SetLastError( (DWORD) CRYPT_E_NOT_FOUND );
            fResult = FALSE;
        }
    }
    else
    {
        cba.FreeArray( TRUE );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapFreeCryptBlobArray
//
//  Synopsis:   free CRYPT_BLOB_ARRAY allocated in LdapConvertLdapResultMessage
//
//----------------------------------------------------------------------------
VOID
LdapFreeCryptBlobArray (
    PCRYPT_BLOB_ARRAY pcba
    )
{
    CCryptBlobArray cba( pcba, 0 );

    cba.FreeArray( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapHasWriteAccess
//
//  Synopsis:   check if the caller has write access to the given LDAP URL
//              query components
//
//----------------------------------------------------------------------------
BOOL
LdapHasWriteAccess (
    LDAP* pld,
    PLDAP_URL_COMPONENTS pLdapUrlComponents,
    DWORD dwTimeout
    )
{
    BOOL                fResult = FALSE;
    LPSTR               pszAttr = "allowedAttributesEffective";
    LPSTR               apszAttr[2] = {pszAttr, NULL};
    LDAP_URL_COMPONENTS LdapUrlComponents;
    CRYPT_BLOB_ARRAY    cba;
    ULONG               cCount;
    ULONG               cbAttr;

    if ( ( pLdapUrlComponents->cAttr != 1 ) ||
         ( pLdapUrlComponents->Scope != LDAP_SCOPE_BASE ) )
    {
        return( FALSE );
    }

    memset( &LdapUrlComponents, 0, sizeof( LdapUrlComponents ) );

    LdapUrlComponents.pszHost = pLdapUrlComponents->pszHost;
    LdapUrlComponents.Port = pLdapUrlComponents->Port;
    LdapUrlComponents.pszDN = pLdapUrlComponents->pszDN;

    LdapUrlComponents.cAttr = 1;
    LdapUrlComponents.apszAttr = apszAttr;

    LdapUrlComponents.Scope = LDAP_SCOPE_BASE;
    LdapUrlComponents.pszFilter = "(objectClass=*)";

    if ( LdapSendReceiveUrlRequest( pld, &LdapUrlComponents, 0, dwTimeout, &cba ) == FALSE )
    {
        return( FALSE );
    }

    cbAttr = strlen( pLdapUrlComponents->apszAttr[ 0 ] );

    for ( cCount = 0; cCount < cba.cBlob; cCount++ )
    {
        if ( cba.rgBlob[ cCount ].cbData != cbAttr )
        {
            continue;
        }

        if ( _strnicmp(
                 pLdapUrlComponents->apszAttr[ 0 ],
                 (LPSTR)cba.rgBlob[ cCount ].pbData,
                 cbAttr
                 ) == 0 )
        {
            fResult = TRUE;
            break;
        }
    }

    LdapFreeCryptBlobArray( &cba );

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapSSPIOrSimpleBind
//
//  Synopsis:   do a SSPI and/or simple bind
//
//----------------------------------------------------------------------------
BOOL
LdapSSPIOrSimpleBind (
    LDAP* pld,
    SEC_WINNT_AUTH_IDENTITY_A* pAuthIdentity,
    DWORD dwRetrievalFlags,
    DWORD dwBindFlags
    )
{
    BOOL  fResult = TRUE;
    ULONG ldaperr;
	ULONG uVersion= LDAP_VERSION3;

    // Per bug 25497, do V3 negotiate instead of the default V2.
    ldap_set_option(pld, LDAP_OPT_VERSION, &uVersion);

    if (dwRetrievalFlags & CRYPT_LDAP_SIGN_RETRIEVAL)
    {
        void *pvOn;
        pvOn = LDAP_OPT_ON;

        ldaperr = ldap_set_option(
                       pld,
                       LDAP_OPT_SIGN,
                       &pvOn
                       );
        if ( ldaperr != LDAP_SUCCESS )
        {
            SetLastError( LdapMapErrorToWin32( ldaperr ) );
            return FALSE;
        }
    }

    ldaperr = LDAP_AUTH_METHOD_NOT_SUPPORTED;

    if (dwBindFlags & LDAP_BIND_AUTH_SSPI_ENABLE_FLAG)
    {

        ldaperr = ldap_bind_sA(
                       pld,
                       NULL,
                       (PCHAR)pAuthIdentity,
                       LDAP_AUTH_SSPI
                       );
    }

    if (dwBindFlags & LDAP_BIND_AUTH_SIMPLE_ENABLE_FLAG)
    {
        // Per Anoop's 4/25/00 email:
        //  You should fall back to anonymous bind only if the server returns
        //  LDAP_AUTH_METHOD_NOT_SUPPORTED.
        //
        // Per sergiod/trevorf 4/25/01 also need to check for invalid creds
        // because target server could be in a different forest.

        if ( ldaperr == LDAP_AUTH_METHOD_NOT_SUPPORTED ||
             ldaperr == LDAP_INVALID_CREDENTIALS )

        {
            ldaperr = ldap_bind_sA(
                           pld,
                           NULL,
                           NULL,
                           LDAP_AUTH_SIMPLE
                           );

            if ( ldaperr != LDAP_SUCCESS )
            {
                uVersion = LDAP_VERSION2;

                if ( LDAP_SUCCESS == ldap_set_option(pld,
                                            LDAP_OPT_VERSION,
                                            &uVersion) )
                {
                    ldaperr = ldap_bind_sA(
                                   pld,
                                   NULL,
                                   NULL,
                                   LDAP_AUTH_SIMPLE
                                   );
                }
            }
        }
    }

    if ( ldaperr != LDAP_SUCCESS )
    {
        fResult = FALSE;

        if ( ldaperr != LDAP_LOCAL_ERROR )
        {
            SetLastError( LdapMapErrorToWin32( ldaperr ) );
        }
        // else per Anoop's 4/25/00 email:
        //  For LDAP_LOCAL_ERROR, its an underlying security error where
        //  LastError has already been updated with a more meaningful error
        //  value.
    }

    return( fResult );
}

#if DBG
//+---------------------------------------------------------------------------
//
//  Function:   LdapDisplayUrlComponents
//
//  Synopsis:   display the URL components
//
//----------------------------------------------------------------------------
VOID
LdapDisplayUrlComponents (
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    )
{
    ULONG cCount;

    printf( "pLdapUrlComponents->pszHost = %s\n", pLdapUrlComponents->pszHost );
    printf( "pLdapUrlComponents->Port = %d\n", pLdapUrlComponents->Port );
    printf( "pLdapUrlComponents->pszDN = %s\n", pLdapUrlComponents->pszDN );
    printf( "pLdapUrlComponents->cAttr = %d\n", pLdapUrlComponents->cAttr );

    for ( cCount = 0; cCount < pLdapUrlComponents->cAttr; cCount++ )
    {
        printf(
           "pLdapUrlComponents->apszAttr[%d] = %s\n",
           cCount,
           pLdapUrlComponents->apszAttr[cCount]
           );
    }

    printf( "pLdapUrlComponents->Scope = %d\n", pLdapUrlComponents->Scope );
    printf( "pLdapUrlComponents->pszFilter = %s\n", pLdapUrlComponents->pszFilter );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\init.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       init.cpp
//
//  Contents:   Initialization for Remote Object Retrieval
//
//  History:    23-Jul-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>

//
// Remote Object Retrieval Function Set definitions
//

HCRYPTOIDFUNCSET hSchemeRetrieveFuncSet;
HCRYPTOIDFUNCSET hContextCreateFuncSet;
HCRYPTOIDFUNCSET hGetObjectUrlFuncSet;
HCRYPTOIDFUNCSET hGetTimeValidObjectFuncSet;
HCRYPTOIDFUNCSET hFlushTimeValidObjectFuncSet;

static const CRYPT_OID_FUNC_ENTRY SchemeRetrieveFuncTable[] = {
    LDAP_SCHEME, LdapRetrieveEncodedObject,
    HTTP_SCHEME, InetRetrieveEncodedObject,
    HTTPS_SCHEME, InetRetrieveEncodedObject,
    FTP_SCHEME, InetRetrieveEncodedObject,
    GOPHER_SCHEME, InetRetrieveEncodedObject,
    FILE_SCHEME, FileRetrieveEncodedObject
};

static const CRYPT_OID_FUNC_ENTRY ContextCreateFuncTable[] = {
    CONTEXT_OID_CERTIFICATE, CertificateCreateObjectContext,
    CONTEXT_OID_CTL, CTLCreateObjectContext,
    CONTEXT_OID_CRL, CRLCreateObjectContext,
    CONTEXT_OID_PKCS7, Pkcs7CreateObjectContext,
    CONTEXT_OID_CAPI2_ANY, Capi2CreateObjectContext
};

static const CRYPT_OID_FUNC_ENTRY GetObjectUrlFuncTable[] = {
    URL_OID_CERTIFICATE_ISSUER, CertificateIssuerGetObjectUrl,
    URL_OID_CERTIFICATE_CRL_DIST_POINT, CertificateCrlDistPointGetObjectUrl,
    URL_OID_CTL_ISSUER, CtlIssuerGetObjectUrl,
    URL_OID_CTL_NEXT_UPDATE, CtlNextUpdateGetObjectUrl,
    URL_OID_CRL_ISSUER, CrlIssuerGetObjectUrl,
    URL_OID_CERTIFICATE_FRESHEST_CRL, CertificateFreshestCrlGetObjectUrl,
    URL_OID_CRL_FRESHEST_CRL, CrlFreshestCrlGetObjectUrl,
    URL_OID_CROSS_CERT_DIST_POINT, CertificateCrossCertDistPointGetObjectUrl
};

static const CRYPT_OID_FUNC_ENTRY GetTimeValidObjectFuncTable[] = {
    TIME_VALID_OID_GET_CTL, CtlGetTimeValidObject,
    TIME_VALID_OID_GET_CRL, CrlGetTimeValidObject,
    TIME_VALID_OID_GET_CRL_FROM_CERT, CrlFromCertGetTimeValidObject,
    TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CERT, FreshestCrlFromCertGetTimeValidObject,
    TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CRL, FreshestCrlFromCrlGetTimeValidObject
};

static const CRYPT_OID_FUNC_ENTRY FlushTimeValidObjectFuncTable[] = {
    TIME_VALID_OID_FLUSH_CTL, CtlFlushTimeValidObject,
    TIME_VALID_OID_FLUSH_CRL, CrlFlushTimeValidObject,
    TIME_VALID_OID_FLUSH_CRL_FROM_CERT, CrlFromCertFlushTimeValidObject,
    TIME_VALID_OID_FLUSH_FRESHEST_CRL_FROM_CERT, FreshestCrlFromCertFlushTimeValidObject,
    TIME_VALID_OID_FLUSH_FRESHEST_CRL_FROM_CRL, FreshestCrlFromCrlFlushTimeValidObject
};

#define SCHEME_RETRIEVE_FUNC_COUNT (sizeof(SchemeRetrieveFuncTable)/ \
                                    sizeof(SchemeRetrieveFuncTable[0]))

#define CONTEXT_CREATE_FUNC_COUNT (sizeof(ContextCreateFuncTable)/ \
                                   sizeof(ContextCreateFuncTable[0]))

#define GET_OBJECT_URL_FUNC_COUNT (sizeof(GetObjectUrlFuncTable)/ \
                                   sizeof(GetObjectUrlFuncTable[0]))

#define GET_TIME_VALID_OBJECT_FUNC_COUNT (sizeof(GetTimeValidObjectFuncTable)/ \
                                          sizeof(GetTimeValidObjectFuncTable[0]))

#define FLUSH_TIME_VALID_OBJECT_FUNC_COUNT (sizeof(FlushTimeValidObjectFuncTable)/ \
                                            sizeof(FlushTimeValidObjectFuncTable[0]))

HCRYPTTLS hCryptNetCancelTls;

CTVOAgent* g_pProcessTVOAgent = NULL;

CRITICAL_SECTION MSCtlDefaultStoresCriticalSection;
extern void MSCtlCloseDefaultStores ();


static
VOID
WINAPI
CancelRetrievalFree(
    IN LPVOID pv
    )
{
    if (pv) 
        free(pv);
}

//+---------------------------------------------------------------------------
//
//  Function:   CryptInstallCancelRetrieval
//
//  Synopsis:   Install the call back function to cancel object retrieval
//				by HTTP, HTTPS, GOPHER, and FTP protocols.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
CryptInstallCancelRetrieval(
    IN PFN_CRYPT_CANCEL_RETRIEVAL pfnCancel, 
    IN const void *pvArg,
    IN DWORD dwFlags,
    IN void *pvReserved
)
{
	PCRYPTNET_CANCEL_BLOCK	pCancelBlock=NULL;

	if(NULL == pfnCancel)
	{
		SetLastError((DWORD) E_INVALIDARG);
		return FALSE;
	}

	pCancelBlock = (PCRYPTNET_CANCEL_BLOCK)malloc(sizeof(CRYPTNET_CANCEL_BLOCK));

	if(NULL == pCancelBlock)
	{
		SetLastError((DWORD) E_OUTOFMEMORY);
		return FALSE;
	}

	pCancelBlock->pfnCancel=pfnCancel;
	pCancelBlock->pvArg=(void *)pvArg;
	
	//uninstall the previous one
	if(!CryptUninstallCancelRetrieval(0, NULL))
	{
		free(pCancelBlock);
		return FALSE;
	}

	if(!I_CryptSetTls(hCryptNetCancelTls, pCancelBlock))
	{
		free(pCancelBlock);
		return FALSE;
	}

	return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   CryptUninstallCancelRetrieval
//
//  Synopsis:   Uninstall the call back function to cancel object retrieval
//				by HTTP, HTTPS, GOPHER, and FTP protocols.
//
//----------------------------------------------------------------------------
BOOL
WINAPI
CryptUninstallCancelRetrieval(
	IN DWORD dwFlags,
	IN void  *pvReserved
	)
{
	PCRYPTNET_CANCEL_BLOCK	pCancelBlock=NULL;
	
	//we just free the memory if there is one
	pCancelBlock = (PCRYPTNET_CANCEL_BLOCK)I_CryptGetTls(hCryptNetCancelTls);

	if(pCancelBlock)
	{
		free(pCancelBlock);
		I_CryptSetTls(hCryptNetCancelTls, NULL);
	}

	return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   RPORDllMain
//
//  Synopsis:   DLL Main like initialization of Remote PKI object retrieval
//
//----------------------------------------------------------------------------
BOOL WINAPI RPORDllMain (
                HMODULE hModule,
                ULONG ulReason,
                LPVOID pvReserved
                )
{
    switch ( ulReason )
    {
    case DLL_PROCESS_ATTACH:

        hSchemeRetrieveFuncSet = CryptInitOIDFunctionSet(
                                      SCHEME_OID_RETRIEVE_ENCODED_OBJECT_FUNC,
                                      0
                                      );

        hContextCreateFuncSet = CryptInitOIDFunctionSet(
                                     CONTEXT_OID_CREATE_OBJECT_CONTEXT_FUNC,
                                     0
                                     );

        hGetObjectUrlFuncSet = CryptInitOIDFunctionSet(
                                    URL_OID_GET_OBJECT_URL_FUNC,
                                    0
                                    );

        hGetTimeValidObjectFuncSet = CryptInitOIDFunctionSet(
                                          TIME_VALID_OID_GET_OBJECT_FUNC,
                                          0
                                          );

        hFlushTimeValidObjectFuncSet = CryptInitOIDFunctionSet(
                                            TIME_VALID_OID_FLUSH_OBJECT_FUNC,
                                            0
                                            );

        if ( ( hSchemeRetrieveFuncSet == NULL ) ||
             ( hContextCreateFuncSet == NULL ) ||
             ( hGetObjectUrlFuncSet == NULL ) ||
             ( hGetTimeValidObjectFuncSet == NULL ) ||
             ( hFlushTimeValidObjectFuncSet == NULL ) )
        {
            return( FALSE );
        }

        if ( CryptInstallOIDFunctionAddress(
                  hModule,
                  X509_ASN_ENCODING,
                  SCHEME_OID_RETRIEVE_ENCODED_OBJECT_FUNC,
                  SCHEME_RETRIEVE_FUNC_COUNT,
                  SchemeRetrieveFuncTable,
                  0
                  ) == FALSE )
        {
            return( FALSE );
        }

        if ( CryptInstallOIDFunctionAddress(
                  hModule,
                  X509_ASN_ENCODING,
                  CONTEXT_OID_CREATE_OBJECT_CONTEXT_FUNC,
                  CONTEXT_CREATE_FUNC_COUNT,
                  ContextCreateFuncTable,
                  0
                  ) == FALSE )
        {
            return( FALSE );
        }

        if ( CryptInstallOIDFunctionAddress(
                  hModule,
                  X509_ASN_ENCODING,
                  URL_OID_GET_OBJECT_URL_FUNC,
                  GET_OBJECT_URL_FUNC_COUNT,
                  GetObjectUrlFuncTable,
                  0
                  ) == FALSE )
        {
            return( FALSE );
        }

        if ( CryptInstallOIDFunctionAddress(
                  hModule,
                  X509_ASN_ENCODING,
                  TIME_VALID_OID_GET_OBJECT_FUNC,
                  GET_TIME_VALID_OBJECT_FUNC_COUNT,
                  GetTimeValidObjectFuncTable,
                  0
                  ) == FALSE )
        {
            return( FALSE );
        }

        if ( CryptInstallOIDFunctionAddress(
                  hModule,
                  X509_ASN_ENCODING,
                  TIME_VALID_OID_FLUSH_OBJECT_FUNC,
                  FLUSH_TIME_VALID_OBJECT_FUNC_COUNT,
                  FlushTimeValidObjectFuncTable,
                  0
                  ) == FALSE )
        {
            return( FALSE );
        }

		hCryptNetCancelTls = I_CryptAllocTls();

		if (hCryptNetCancelTls == NULL )
			return( FALSE );

        InitializeOfflineUrlCache();

        InitializeCryptRetrieveObjectByUrl(hModule);

        if ( CreateProcessTVOAgent( &g_pProcessTVOAgent ) == FALSE )
        {
            return( FALSE );
        }

        if ( !Pki_InitializeCriticalSection(
                &MSCtlDefaultStoresCriticalSection ) )
        {
            return( FALSE );
        }
        
        return( TRUE );
        break;
    case DLL_THREAD_ATTACH:
        break;
    case DLL_PROCESS_DETACH:
		I_CryptFreeTls( hCryptNetCancelTls, CancelRetrievalFree );
        delete g_pProcessTVOAgent;

        DeleteCryptRetrieveObjectByUrl();

        DeleteOfflineUrlCache();

        MSCtlCloseDefaultStores();
        DeleteCriticalSection( &MSCtlDefaultStoresCriticalSection );
        break;

    case DLL_THREAD_DETACH:
		CancelRetrievalFree(I_CryptDetachTls(hCryptNetCancelTls));

        break;
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   RPORDllRegisterServer
//
//  Synopsis:   DllRegisterServer like registration of RPOR functions
//
//----------------------------------------------------------------------------
STDAPI RPORDllRegisterServer (HMODULE hModule)
{
    CHAR  pszDll[MAX_PATH+1];
    WCHAR pwszDll[MAX_PATH+1];
    LPSTR pszDllRel = NULL;

    if ( GetModuleFileNameA( hModule, pszDll, MAX_PATH ) == 0 )
    {
        return( HRESULT_FROM_WIN32( GetLastError() ) );
    }

    pszDllRel = strrchr( pszDll, '\\' );

    assert( pszDllRel != NULL );

    pszDllRel += 1;

    if ( MultiByteToWideChar(
              CP_ACP,
              0,
              pszDllRel,
              -1,
              pwszDll,
              MAX_PATH+1
              ) == 0 )
    {
        return( HRESULT_FROM_WIN32( GetLastError() ) );
    }

    if ( ( CryptRegisterDefaultOIDFunction(
                X509_ASN_ENCODING,
                CRYPT_OID_VERIFY_REVOCATION_FUNC,
                CRYPT_REGISTER_FIRST_INDEX,
                pwszDll
                ) == FALSE ) && ( GetLastError() != ERROR_FILE_EXISTS ) )
    {
        return( HRESULT_FROM_WIN32( GetLastError() ) );
    }

    if ( ( CryptRegisterDefaultOIDFunction(
                X509_ASN_ENCODING,
                CRYPT_OID_VERIFY_CTL_USAGE_FUNC,
                CRYPT_REGISTER_FIRST_INDEX,
                pwszDll
                ) == FALSE ) && ( GetLastError() != ERROR_FILE_EXISTS ) )
    {
        return( HRESULT_FROM_WIN32( GetLastError() ) );
    }

    if ( ( CryptRegisterOIDFunction(
                0,
                CRYPT_OID_OPEN_STORE_PROV_FUNC,
                sz_CERT_STORE_PROV_LDAP,
                pwszDll,
                LDAP_OPEN_STORE_PROV_FUNC
                ) == FALSE ) && ( GetLastError() != ERROR_FILE_EXISTS ) )
    {
        return( GetLastError() );
    }

    if ( ( CryptRegisterOIDFunction(
                0,
                CRYPT_OID_OPEN_STORE_PROV_FUNC,
                CERT_STORE_PROV_LDAP,
                pwszDll,
                LDAP_OPEN_STORE_PROV_FUNC
                ) == FALSE ) && ( GetLastError() != ERROR_FILE_EXISTS ) )
    {
        return( GetLastError() );
    }

    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   RPORDllUnregisterServer
//
//  Synopsis:   DllUnregisterServer like registration of RPOR functions
//
//----------------------------------------------------------------------------
STDAPI RPORDllUnregisterServer (HMODULE hModule)
{
    CHAR  pszDll[MAX_PATH+1];
    WCHAR pwszDll[MAX_PATH+1];
    LPSTR pszDllRel = NULL;

    if ( GetModuleFileNameA( hModule, pszDll, MAX_PATH ) == 0 )
    {
        return( HRESULT_FROM_WIN32( GetLastError() ) );
    }

    pszDllRel = strrchr( pszDll, '\\' );

    assert( pszDllRel != NULL );

    pszDllRel += 1;

    if ( MultiByteToWideChar(
              CP_ACP,
              0,
              pszDllRel,
              -1,
              pwszDll,
              MAX_PATH+1
              ) == 0 )
    {
        return( HRESULT_FROM_WIN32( GetLastError() ) );
    }

    if ( ( CryptUnregisterDefaultOIDFunction(
                X509_ASN_ENCODING,
                CRYPT_OID_VERIFY_REVOCATION_FUNC,
                pwszDll
                ) == FALSE ) && ( GetLastError() != ERROR_FILE_NOT_FOUND ) )
    {
        return( HRESULT_FROM_WIN32( GetLastError() ) );
    }

    if ( ( CryptUnregisterDefaultOIDFunction(
                X509_ASN_ENCODING,
                CRYPT_OID_VERIFY_CTL_USAGE_FUNC,
                pwszDll
                ) == FALSE ) && ( GetLastError() != ERROR_FILE_NOT_FOUND ) )
    {
        return( HRESULT_FROM_WIN32( GetLastError() ) );
    }

    if ( ( CryptUnregisterOIDFunction(
                0,
                CRYPT_OID_OPEN_STORE_PROV_FUNC,
                sz_CERT_STORE_PROV_LDAP
                ) == FALSE ) && ( GetLastError() != ERROR_FILE_NOT_FOUND ) )
    {
        return( GetLastError() );
    }

    if ( ( CryptUnregisterOIDFunction(
                0,
                CRYPT_OID_OPEN_STORE_PROV_FUNC,
                CERT_STORE_PROV_LDAP
                ) == FALSE ) && ( GetLastError() != ERROR_FILE_NOT_FOUND ) )
    {
        return( GetLastError() );
    }

    return( S_OK );
}

//+---------------------------------------------------------------------------
//
//  Function:   RPORDllRegUnregServer
//
//  Synopsis:   reg unreg server entry point for RPOR
//
//----------------------------------------------------------------------------
HRESULT WINAPI RPORDllRegUnregServer (HMODULE hModule, BOOL fRegUnreg)
{
    if ( fRegUnreg == TRUE )
    {
        return( RPORDllRegisterServer( hModule ) );
    }

    return( RPORDllUnregisterServer( hModule ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\ldapsp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ldapsp.h
//
//  Contents:   LDAP Scheme Provider definitions
//
//  History:    28-Jul-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__LDAPSP_H__)
#define __LDAPSP_H__

#include <orm.h>
#include <winldap.h>
#include <dsgetdc.h>

//
// The minimum time to allow for LDAP timeouts
//

#define LDAP_MIN_TIMEOUT_SECONDS    10

//
// LDAP Scheme Provider Entry Points
//

#define LDAP_SCHEME "ldap"

BOOL WINAPI LdapRetrieveEncodedObject (
                IN LPCSTR pszUrl,
                IN LPCSTR pszObjectOid,
                IN DWORD dwRetrievalFlags,
                IN DWORD dwTimeout,
                OUT PCRYPT_BLOB_ARRAY pObject,
                OUT PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                OUT LPVOID* ppvFreeContext,
                IN HCRYPTASYNC hAsyncRetrieve,
                IN PCRYPT_CREDENTIALS pCredentials,
                IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                );

VOID WINAPI LdapFreeEncodedObject (
                IN LPCSTR pszObjectOid,
                IN PCRYPT_BLOB_ARRAY pObject,
                IN LPVOID pvFreeContext
                );

BOOL WINAPI LdapCancelAsyncRetrieval (
                IN HCRYPTASYNC hAsyncRetrieve
                );

//
// LDAP Scheme Provider Notes.  The LDAP API model has synchronous with
// timeout and asynchronous via polling mechanisms.
//

//
// LDAP Synchronous Object Retriever
//

class CLdapSynchronousRetriever : public IObjectRetriever
{
public:

    //
    // Construction
    //

    CLdapSynchronousRetriever ();
    ~CLdapSynchronousRetriever ();

    //
    // IRefCountedObject methods
    //

    virtual VOID AddRef ();
    virtual VOID Release ();

    //
    // IObjectRetriever methods
    //

    virtual BOOL RetrieveObjectByUrl (
                         LPCSTR pszUrl,
                         LPCSTR pszObjectOid,
                         DWORD dwRetrievalFlags,
                         DWORD dwTimeout,
                         LPVOID* ppvObject,
                         PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                         LPVOID* ppvFreeContext,
                         HCRYPTASYNC hAsyncRetrieve,
                         PCRYPT_CREDENTIALS pCredentials,
                         LPVOID pvVerify,
                         PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                         );

    virtual BOOL CancelAsyncRetrieval ();

private:

    //
    // Reference count
    //

    ULONG m_cRefs;
};

//
// LDAP Scheme Provider Support API
//

typedef struct _LDAP_URL_COMPONENTS {

    LPSTR  pszHost;
    ULONG  Port;
    LPSTR  pszDN;
    ULONG  cAttr;
    LPSTR* apszAttr;
    ULONG  Scope;
    LPSTR  pszFilter;

} LDAP_URL_COMPONENTS, *PLDAP_URL_COMPONENTS;

BOOL
LdapCrackUrl (
    LPCSTR pszUrl,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

BOOL
LdapParseCrackedHost (
    LPSTR pszHost,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

BOOL
LdapParseCrackedDN (
    LPSTR pszDN,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

BOOL
LdapParseCrackedAttributeList (
    LPSTR pszAttrList,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

BOOL
LdapParseCrackedScopeAndFilter (
    LPSTR pszScope,
    LPSTR pszFilter,
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

VOID
LdapFreeUrlComponents (
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

VOID
LdapDisplayUrlComponents (
    PLDAP_URL_COMPONENTS pLdapUrlComponents
    );

#define LDAP_BIND_AUTH_SSPI_ENABLE_FLAG     0x1
#define LDAP_BIND_AUTH_SIMPLE_ENABLE_FLAG   0x2

BOOL
LdapGetBindings (
    LPSTR pszHost,
    ULONG Port,
    DWORD dwRetrievalFlags,
    DWORD dwBindFlags,
    DWORD dwTimeout,
    PCRYPT_CREDENTIALS pCredentials,
    LDAP** ppld
    );

VOID
LdapFreeBindings (
    LDAP* pld
    );

BOOL
LdapSendReceiveUrlRequest (
    LDAP* pld,
    PLDAP_URL_COMPONENTS pLdapUrlComponents,
    DWORD dwRetrievalFlags,
    DWORD dwTimeout,
    PCRYPT_BLOB_ARRAY pcba
    );

BOOL
LdapConvertLdapResultMessage (
    LDAP* pld,
    PLDAPMessage plm,
    DWORD dwRetrievalFlags,
    PCRYPT_BLOB_ARRAY pcba
    );

VOID
LdapFreeCryptBlobArray (
    PCRYPT_BLOB_ARRAY pcba
    );

BOOL
LdapHasWriteAccess (
    LDAP* pld,
    PLDAP_URL_COMPONENTS pLdapUrlComponents,
    DWORD dwTimeout
    );

BOOL
LdapSSPIOrSimpleBind (
    LDAP* pld,
    SEC_WINNT_AUTH_IDENTITY_A* pAuthIdentity,
    DWORD dwRetrievalFlags,
    DWORD dwBindFlags
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\msctl.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:	    msctl.cpp
//
//  Contents:   Default version of CertDllVerifyCTLUsage.
//
//              Default implementation:
//              - If CtlStores are specified, then, only those stores are
//                searched to find a CTL with the specified usage and optional
//                ListIdentifier.  Otherwise, the "Trust" system store is
//                searched to find a CTL.
//              - If CERT_VERIFY_TRUSTED_SIGNERS_FLAG is set, then, only the
//                SignerStores are searched to find the certificate
//                corresponding to the signer's issuer and serial number.
//                Otherwise, the CTL message's store, SignerStores,
//                "Trust" system store, "CA" system store, "ROOT" and "SPC"
//                system stores are searched to find the signer's certificate.
//                In either case, the public key in the found
//                certificate is used to verify the CTL's signature.
//              - If the CTL has a NextUpdate and
//                CERT_VERIFY_NO_TIME_CHECK_FLAG isn't set, then its
//                verified for time validity.
//              - If the CTL is time invalid, then, attempts to
//                get a time valid version. Uses either the CTL's
//                NextUpdateLocation property or CTL's NextUpdateLocation
//                extension or searches the signer's info for a
//                NextUpdateLocation attribute. The NextUpdateLocation
//                is encoded as a GeneralNames. Any non-URL name choices are
//                skipped.
//
//  Functions:  DllMain
//              DllRegisterServer
//              DllUnregisterServer
//              CertDllVerifyCTLUsage
//
//  History:	29-Apr-97   philh   created
//              09-Oct-97   kirtd   simplification, use CryptGetTimeValidObject
//--------------------------------------------------------------------------
#include <global.hxx>
#include <dbgdef.h>

#define MSCTL_TIMEOUT 15000
//+-------------------------------------------------------------------------
// Default stores searched to find a CTL or signer
//--------------------------------------------------------------------------

// The CTL stores must be at the beginning. CTL stores are opened as
// READ/WRITE. Remaining stores are opened READONLY.
//
// CTL stores are also searched for signers.
static const struct {
    LPCWSTR     pwszStore;
    DWORD       dwFlags;
} rgDefaultStoreInfo[] = {
    L"TRUST",       CERT_SYSTEM_STORE_CURRENT_USER,
    L"CA",          CERT_SYSTEM_STORE_CURRENT_USER,
    L"ROOT",        CERT_SYSTEM_STORE_CURRENT_USER,
    L"SPC",         CERT_SYSTEM_STORE_LOCAL_MACHINE
};
#define NUM_DEFAULT_STORES          (sizeof(rgDefaultStoreInfo) / \
                                        sizeof(rgDefaultStoreInfo[0]))
#define NUM_DEFAULT_CTL_STORES      1
#define NUM_DEFAULT_SIGNER_STORES   NUM_DEFAULT_STORES
//+-------------------------------------------------------------------------
// The following HCERTSTORE handles once opened, remain open until
// ProcessDetach
//--------------------------------------------------------------------------
static HCERTSTORE rghDefaultStore[NUM_DEFAULT_STORES];
static BOOL fOpenedDefaultStores;
extern CRITICAL_SECTION MSCtlDefaultStoresCriticalSection;

//+-------------------------------------------------------------------------
//  Close the default stores that might have been opened
//--------------------------------------------------------------------------
void MSCtlCloseDefaultStores()
{
    if (fOpenedDefaultStores) {
        DWORD i;
        for (i = 0; i < NUM_DEFAULT_STORES; i++) {
            HCERTSTORE hStore = rghDefaultStore[i];
            if (hStore)
                CertCloseStore(hStore, 0);
        }
        fOpenedDefaultStores = FALSE;
    }
}

//+-------------------------------------------------------------------------
//  Returns TRUE if the CTL is still time valid.
//
//  A CTL without a NextUpdate is considered time valid.
//--------------------------------------------------------------------------
static BOOL IsTimeValidCtl(
    IN LPFILETIME pTimeToVerify,
    IN PCCTL_CONTEXT pCtl
    )
{
    PCTL_INFO pCtlInfo = pCtl->pCtlInfo;

    // Note, NextUpdate is optional. When not present, its set to 0
    if ((0 == pCtlInfo->NextUpdate.dwLowDateTime &&
                0 == pCtlInfo->NextUpdate.dwHighDateTime) ||
            CompareFileTime(&pCtlInfo->NextUpdate, pTimeToVerify) >= 0)
        return TRUE;
    else
        return FALSE;
}


//+-------------------------------------------------------------------------
//  Local functions called by CertDllVerifyCTLUsage
//--------------------------------------------------------------------------
static void MSCtlOpenDefaultStores();

static BOOL VerifyCtl(
    IN PCCTL_CONTEXT pCtl,
    IN DWORD dwFlags,
    IN PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
    OUT PCCERT_CONTEXT *ppSigner,
    OUT DWORD *pdwSignerIndex
    );

static BOOL GetTimeValidCtl(
    IN LPFILETIME pCurrentTime,
    IN PCCTL_CONTEXT pCtl,
    IN DWORD dwFlags,
    IN PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
    OUT PCCTL_CONTEXT *ppValidCtl,
    IN OUT PCCERT_CONTEXT *ppSigner,
    IN OUT DWORD *pdwSignerIndex
    );

static PCCTL_CONTEXT ReplaceCtl(
    IN HCERTSTORE hStore,
    IN PCCTL_CONTEXT pOrigCtl,
    IN PCCTL_CONTEXT pValidCtl
    );

static BOOL CompareCtlUsage(
    IN DWORD dwFindFlags,
    IN PCTL_FIND_USAGE_PARA pPara,
    IN PCCTL_CONTEXT pCtl
    )
{
    PCTL_INFO pInfo = pCtl->pCtlInfo;

    if ((CTL_FIND_SAME_USAGE_FLAG & dwFindFlags) &&
            pPara->SubjectUsage.cUsageIdentifier !=
                pInfo->SubjectUsage.cUsageIdentifier)
        return FALSE;
    if (pPara->SubjectUsage.cUsageIdentifier) {
        DWORD cId1 = pPara->SubjectUsage.cUsageIdentifier;
        LPSTR *ppszId1 = pPara->SubjectUsage.rgpszUsageIdentifier;
        for ( ; cId1 > 0; cId1--, ppszId1++) {
            DWORD cId2 = pInfo->SubjectUsage.cUsageIdentifier;
            LPSTR *ppszId2 = pInfo->SubjectUsage.rgpszUsageIdentifier;
            for ( ; cId2 > 0; cId2--, ppszId2++) {
                if (0 == strcmp(*ppszId1, *ppszId2))
                    break;
            }
            if (0 == cId2)
                return FALSE;
        }
    }

    if (pPara->ListIdentifier.cbData) {
        DWORD cb = pPara->ListIdentifier.cbData;
        if (CTL_FIND_NO_LIST_ID_CBDATA == cb)
            cb = 0;
        if (cb != pInfo->ListIdentifier.cbData)
            return FALSE;
        if (0 != cb && 0 != memcmp(pPara->ListIdentifier.pbData,
                pInfo->ListIdentifier.pbData, cb))
            return FALSE;
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Default version of CertDllVerifyCTLUsage
//--------------------------------------------------------------------------
BOOL
WINAPI
CertDllVerifyCTLUsage(
    IN DWORD dwEncodingType,
    IN DWORD dwSubjectType,
    IN void *pvSubject,
    IN PCTL_USAGE pSubjectUsage,
    IN DWORD dwFlags,
    IN OPTIONAL PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
    IN OUT PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus
    )
{
    BOOL fResult = FALSE;
    DWORD dwError = (DWORD) CRYPT_E_NO_VERIFY_USAGE_CHECK;
    DWORD cCtlStore;
    HCERTSTORE *phCtlStore;             // not allocated or reference counted
    FILETIME CurrentTime;
    CTL_FIND_USAGE_PARA FindUsagePara;
    DWORD dwFindFlags;
    PCCTL_CONTEXT pValidCtl;
    PCCERT_CONTEXT pSigner;
    PCTL_ENTRY pEntry;
    DWORD dwSignerIndex;

    assert(NULL == pVerifyUsagePara || pVerifyUsagePara->cbSize >=
        sizeof(CTL_VERIFY_USAGE_PARA));
    assert(pVerifyUsageStatus && pVerifyUsageStatus->cbSize >=
        sizeof(CTL_VERIFY_USAGE_STATUS));

    if (pVerifyUsagePara && pVerifyUsagePara->cCtlStore > 0) {
        cCtlStore = pVerifyUsagePara->cCtlStore;
        phCtlStore = pVerifyUsagePara->rghCtlStore;
    } else {
        MSCtlOpenDefaultStores();
        dwFlags &= ~CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG;
        cCtlStore = NUM_DEFAULT_CTL_STORES;
        phCtlStore = rghDefaultStore;
    }

    // Get current time to be used to determine if CTLs are time valid
    {
        SYSTEMTIME SystemTime;
        GetSystemTime(&SystemTime);
        SystemTimeToFileTime(&SystemTime, &CurrentTime);
    }

    memset(&FindUsagePara, 0, sizeof(FindUsagePara));
    FindUsagePara.cbSize = sizeof(FindUsagePara);
    dwFindFlags = 0;
    if (pSubjectUsage) {
        FindUsagePara.SubjectUsage = *pSubjectUsage;
        if (0 == (CERT_VERIFY_ALLOW_MORE_USAGE_FLAG & dwFlags))
            dwFindFlags = CTL_FIND_SAME_USAGE_FLAG;
    }
    if (pVerifyUsagePara)
        FindUsagePara.ListIdentifier = pVerifyUsagePara->ListIdentifier;

    for ( ; ( cCtlStore > 0 ) && ( dwError != 0 ); cCtlStore--, phCtlStore++)
    {
        HCERTSTORE hCtlStore = *phCtlStore;
        PCCTL_CONTEXT pCtl;

        if (NULL == hCtlStore)
            continue;

        pCtl = NULL;
        while ( ( pCtl = CertFindCTLInStore(
                             hCtlStore,
                             dwEncodingType,
                             dwFindFlags,
                             CTL_FIND_USAGE,
                             &FindUsagePara,
                             pCtl
                             ) ) )
        {
            pValidCtl = NULL;
            pSigner = NULL;
            pEntry = NULL;
            dwSignerIndex = 0;

            if ( ( fResult = VerifyCtl(
                                   pCtl,
                                   dwFlags,
                                   pVerifyUsagePara,
                                   &pSigner,
                                   &dwSignerIndex
                                   ) ) == TRUE )
            {
                if ( !( dwFlags & CERT_VERIFY_NO_TIME_CHECK_FLAG ) &&
                      ( IsTimeValidCtl( &CurrentTime, pCtl ) == FALSE ) )
                {
                    fResult = GetTimeValidCtl(
                                 &CurrentTime,
                                 pCtl,
                                 dwFlags,
                                 pVerifyUsagePara,
                                 &pValidCtl,
                                 &pSigner,
                                 &dwSignerIndex
                                 );

                    if ( fResult == TRUE )
                    {
                        if ( !( dwFlags & CERT_VERIFY_INHIBIT_CTL_UPDATE_FLAG ) )
                        {
                            pValidCtl = ReplaceCtl( hCtlStore, pCtl, pValidCtl );
                            pVerifyUsageStatus->dwFlags |= CERT_VERIFY_UPDATED_CTL_FLAG;
                        }

                        fResult =  CompareCtlUsage(
                                          dwFindFlags,
                                          &FindUsagePara,
                                          pValidCtl
                                          );
                    }
                    else
                    {
                        dwError = (DWORD) CRYPT_E_VERIFY_USAGE_OFFLINE;
                    }
                }

                if ( fResult == TRUE )
                {
                    PCCTL_CONTEXT pCtlToUse;

                    if ( pValidCtl != NULL )
                    {
                        pCtlToUse = CertDuplicateCTLContext( pValidCtl );
                    }
                    else
                    {
                        pCtlToUse = CertDuplicateCTLContext( pCtl );
                    }

                    pEntry = CertFindSubjectInCTL(
                                 dwEncodingType,
                                 dwSubjectType,
                                 pvSubject,
                                 pCtlToUse,
                                 0
                                 );

                    if ( pEntry != NULL )
                    {
                        pVerifyUsageStatus->dwCtlEntryIndex =
                            (DWORD)(pEntry - pCtlToUse->pCtlInfo->rgCTLEntry);

                        if ( pVerifyUsageStatus->ppCtl != NULL )
                        {
                            *pVerifyUsageStatus->ppCtl = pCtlToUse;
                        }
                        else
                        {
                            CertFreeCTLContext( pCtlToUse );
                        }

                        pVerifyUsageStatus->dwSignerIndex = dwSignerIndex;

                        if ( pVerifyUsageStatus->ppSigner != NULL )
                        {
                            *pVerifyUsageStatus->ppSigner =
                                    CertDuplicateCertificateContext( pSigner );
                        }

                        dwError = 0;
                    }
                    else
                    {
                        dwError = (DWORD) CRYPT_E_NOT_IN_CTL;
                        CertFreeCTLContext( pCtlToUse );
                    }
                }
            }
            else
            {
                dwError = (DWORD) CRYPT_E_NO_TRUSTED_SIGNER;
            }

            if ( pValidCtl != NULL )
            {
                CertFreeCTLContext( pValidCtl );
            }

            if ( pSigner != NULL )
            {
                CertFreeCertificateContext( pSigner );
            }

            if ( dwError == 0 ) {
                CertFreeCTLContext(pCtl);
                break;
            }
        }
    }

    if ( dwError != 0 )
    {
        fResult = FALSE;
    }

    pVerifyUsageStatus->dwError = dwError;
    SetLastError( dwError );

    return fResult;
}

//+=========================================================================
//  Open default stores functions
//==========================================================================

static const CRYPT_OID_FUNC_ENTRY UsageFuncTable[] = {
    CRYPT_DEFAULT_OID, CertDllVerifyCTLUsage
};
#define USAGE_FUNC_COUNT (sizeof(UsageFuncTable) / sizeof(UsageFuncTable[0]))

//+-------------------------------------------------------------------------
//  Open the default stores used to find the CTL or signer. Also, install
//  ourself so we aren't unloaded.
//
//  Open and install are only done once.
//--------------------------------------------------------------------------
static void MSCtlOpenDefaultStores()
{
    if (fOpenedDefaultStores)
        return;

    assert(NUM_DEFAULT_STORES >= NUM_DEFAULT_CTL_STORES);
    assert(NUM_DEFAULT_STORES >= NUM_DEFAULT_SIGNER_STORES);

    EnterCriticalSection(&MSCtlDefaultStoresCriticalSection);
    if (!fOpenedDefaultStores) {
        DWORD i;

        for (i = 0; i < NUM_DEFAULT_STORES; i++) {
            DWORD dwFlags;

            dwFlags = rgDefaultStoreInfo[i].dwFlags;
            if (i >= NUM_DEFAULT_CTL_STORES)
                dwFlags |= CERT_STORE_READONLY_FLAG;
            rghDefaultStore[i] = CertOpenStore(
                    CERT_STORE_PROV_SYSTEM_W,
                    0,                          // dwEncodingType
                    0,                          // hCryptProv
                    dwFlags,
                    (const void *) rgDefaultStoreInfo[i].pwszStore
                    );
        }

        fOpenedDefaultStores = TRUE;
    }
    LeaveCriticalSection(&MSCtlDefaultStoresCriticalSection);
}

//+=========================================================================
//  Verify and replace CTL functions
//==========================================================================

//+-------------------------------------------------------------------------
//  Verifies the signature of the CTL.
//--------------------------------------------------------------------------
static BOOL VerifyCtl(
    IN PCCTL_CONTEXT pCtl,
    IN DWORD dwFlags,
    IN PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
    OUT PCCERT_CONTEXT *ppSigner,
    OUT DWORD *pdwSignerIndex
    )
{
    BOOL fResult;
    DWORD cParaStore;
    HCERTSTORE *phParaStore;  // not allocated or reference counted

    DWORD cStore;
    HCERTSTORE *phStore;      // if allocated, via _alloca
    DWORD dwGetFlags;

    if (pVerifyUsagePara) {
        cParaStore = pVerifyUsagePara->cSignerStore;
        phParaStore = pVerifyUsagePara->rghSignerStore;
    } else {
        cParaStore = 0;
        phParaStore = NULL;
    }

    if (dwFlags & CERT_VERIFY_TRUSTED_SIGNERS_FLAG) {
        cStore = cParaStore;
        phStore = phParaStore;
        dwGetFlags = CMSG_TRUSTED_SIGNER_FLAG;
    } else {
        MSCtlOpenDefaultStores();

        if (cParaStore) {
            cStore = cParaStore + NUM_DEFAULT_SIGNER_STORES;
            if (NULL == (phStore = (HCERTSTORE *) _alloca(
                    cStore * sizeof(HCERTSTORE))))
                goto OutOfMemory;
            memcpy(phStore, phParaStore, cParaStore * sizeof(HCERTSTORE));
            memcpy(&phStore[cParaStore], rghDefaultStore,
                NUM_DEFAULT_SIGNER_STORES * sizeof(HCERTSTORE));
        } else {
            cStore = NUM_DEFAULT_SIGNER_STORES;
            phStore = rghDefaultStore;
        }

        dwGetFlags = 0;
    }

    fResult = CryptMsgGetAndVerifySigner(
            pCtl->hCryptMsg,
            cStore,
            phStore,
            dwGetFlags,
            ppSigner,
            pdwSignerIndex);

CommonReturn:
    return fResult;

ErrorReturn:
    *ppSigner = NULL;
    *pdwSignerIndex = 0;
    fResult = FALSE;
    goto CommonReturn;
SET_ERROR(OutOfMemory, E_OUTOFMEMORY)
}


//+-------------------------------------------------------------------------
//  Replaces the CTL in the store. Copies over any original properties.
//--------------------------------------------------------------------------
static PCCTL_CONTEXT ReplaceCtl(
    IN HCERTSTORE hStore,
    IN PCCTL_CONTEXT pOrigCtl,
    IN PCCTL_CONTEXT pValidCtl
    )
{
    PCCTL_CONTEXT pNewCtl;

    if (CertAddCTLContextToStore(
            hStore,
            pValidCtl,
            CERT_STORE_ADD_REPLACE_EXISTING_INHERIT_PROPERTIES,
            &pNewCtl))
        CertFreeCTLContext(pValidCtl);
    else
        pNewCtl = pValidCtl;

    return pNewCtl;
}

//+=========================================================================
//  Get time valid CTL via URL obtained from old CTL's NextUpdateLocation
//  property, extension or signer attribute.
//==========================================================================
static BOOL GetTimeValidCtl(
    IN LPFILETIME pCurrentTime,
    IN PCCTL_CONTEXT pCtl,
    IN DWORD dwFlags,
    IN PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
    OUT PCCTL_CONTEXT *ppValidCtl,
    IN OUT PCCERT_CONTEXT *ppSigner,
    IN OUT DWORD *pdwSignerIndex
    )
{
    BOOL fResult;

    *ppValidCtl = NULL;

    fResult = CryptGetTimeValidObject(
                   TIME_VALID_OID_GET_CTL,
                   (LPVOID)pCtl,
                   *ppSigner,
                   pCurrentTime,
                   0,
                   MSCTL_TIMEOUT,
                   (LPVOID *)ppValidCtl,
                   NULL,
                   NULL
                   );

    if ( fResult == FALSE )
    {
        fResult = CryptGetTimeValidObject(
                       TIME_VALID_OID_GET_CTL,
                       (LPVOID)pCtl,
                       *ppSigner,
                       pCurrentTime,
                       CRYPT_DONT_VERIFY_SIGNATURE,
                       MSCTL_TIMEOUT,
                       (LPVOID *)ppValidCtl,
                       NULL,
                       NULL
                       );

        if ( fResult == TRUE )
        {
            DWORD          dwSignerIndex = *pdwSignerIndex;
            PCCERT_CONTEXT pSigner = *ppSigner;

            fResult = VerifyCtl(
                            *ppValidCtl,
                            dwFlags,
                            pVerifyUsagePara,
                            ppSigner,
                            pdwSignerIndex
                            );

            if ( fResult == TRUE )
            {
                CertFreeCertificateContext( pSigner );
            }
            else
            {
                *pdwSignerIndex = dwSignerIndex;
                *ppSigner = pSigner;

                CertFreeCTLContext( *ppValidCtl );
                SetLastError( (DWORD) CRYPT_E_NO_TRUSTED_SIGNER );
            }
        }
    }

    return( fResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\msrevoke.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:	    msrevoke.cpp
//
//  Contents:   CRL Distribution Points version of CertDllVerifyRevocation.
//
//              Restrictions:
//               - Only support CRYPT_ASN_ENCODING
//               - Only processes certificates having the
//                 szOID_CRL_DIST_POINTS extension.
//               - For szOID_CRL_DIST_POINTS extension: only URL FullName,
//                 no ReasonFlags or CRLIssuer.
//               - URLs: http:, file:
//               - CRL must be issued and signed by the issuer of the
//                 certificate
//               - CRL must not have any critical extensions
//
//  Functions:  DllMain
//              DllRegisterServer
//              DllUnregisterServer
//              CertDllVerifyRevocation
//
//  History:	10-Apr-97   philh   created
//              01-Oct-97   kirtd   major simplification, use
//                                  CryptGetTimeValidObject
//
//--------------------------------------------------------------------------
#include "global.hxx"
#include <dbgdef.h>


#define MSREVOKE_TIMEOUT 15000
//+-------------------------------------------------------------------------
// Default stores searched to find an issuer of the subject certificate
//--------------------------------------------------------------------------
static struct {
    LPCWSTR     pwszStore;
    DWORD       dwFlags;
} rgDefaultIssuerStores[] = {
    L"CA",          CERT_SYSTEM_STORE_CURRENT_USER,
    L"ROOT",        CERT_SYSTEM_STORE_CURRENT_USER,
    L"SPC",         CERT_SYSTEM_STORE_LOCAL_MACHINE
};

#define NUM_DEFAULT_ISSUER_STORES (sizeof(rgDefaultIssuerStores) / \
                                   sizeof(rgDefaultIssuerStores[0]))


//+-------------------------------------------------------------------------
//  Local functions called by MicrosoftCertDllVerifyRevocation
//--------------------------------------------------------------------------
PCCERT_CONTEXT GetIssuerCert(
    IN DWORD cCert,
    IN PCCERT_CONTEXT rgpCert[],
    IN DWORD dwFlags,
    IN PCERT_REVOCATION_PARA pRevPara
    );

BOOL HasUnsupportedCrlCriticalExtension(
    IN PCCRL_CONTEXT pCrl
    );


// msrevoke specific flags that can be passed to GetTimeValidCrl
#define MSREVOKE_DONT_CHECK_TIME_VALIDITY_FLAG  0x1
#define MSREVOKE_DELTA_CRL_FLAG                 0x2

BOOL GetTimeValidCrl (
        IN LPCSTR pszTimeValidOid,
        IN LPVOID pvTimeValidPara,
        IN PCCERT_CONTEXT pSubject,
        IN PCCERT_CONTEXT pIssuer,
        IN PCERT_REVOCATION_PARA pRevPara,
        IN PCERT_EXTENSION pCDPExt,
        IN DWORD dwRevFlags,
        IN DWORD dwMsrevokeFlags,
        IN FILETIME *pftEndUrlRetrieval,
        OUT PCCRL_CONTEXT *ppCrl,
        IN OUT BOOL *pfWireRetrieval
        );
BOOL GetBaseCrl (
        IN PCCERT_CONTEXT pSubject,
        IN PCCERT_CONTEXT pIssuer,
        IN PCERT_REVOCATION_PARA pRevPara,
        IN PCERT_EXTENSION pCDPExt,
        IN DWORD dwRevFlags,
        IN FILETIME *pftEndUrlRetrieval,
        OUT PCCRL_CONTEXT *ppBaseCrl,
        OUT BOOL *pfBaseCrlTimeValid,
        OUT BOOL *pfBaseWireRetrieval
        );
BOOL GetDeltaCrl (
        IN PCCERT_CONTEXT pSubject,
        IN PCCERT_CONTEXT pIssuer,
        IN PCERT_REVOCATION_PARA pRevPara,
        IN DWORD dwRevFlags,
        IN BOOL fBaseWireRetrieval,
        IN FILETIME *pftEndUrlRetrieval,
        IN OUT PCCRL_CONTEXT *ppBaseCrl,
        IN OUT BOOL *pfCrlTimeValid,
        OUT PCCRL_CONTEXT *ppDeltaCrl,
        OUT DWORD *pdwFreshnessTime
        );

DWORD GetCrlReason(
        IN PCRL_ENTRY pCrlEntry
        );

BOOL CrlIssuerIsCertIssuer (
        IN PCCERT_CONTEXT pCert,
        IN PCERT_EXTENSION pCrlDistPointExt
        );

//+-------------------------------------------------------------------------
//  External functions called by CertDllVerifyRevocation
//--------------------------------------------------------------------------

BOOL
WINAPI
NetscapeCertDllVerifyRevocation(
    IN DWORD dwEncodingType,
    IN DWORD dwRevType,
    IN DWORD cContext,
    IN PVOID rgpvContext[],
    IN DWORD dwFlags,
    IN PVOID pvReserved,
    IN OUT PCERT_REVOCATION_STATUS pRevStatus
    );

//+-------------------------------------------------------------------------
//  MicrosoftCertDllVerifyRevocation using CRL Distribution Points extension.
//--------------------------------------------------------------------------
BOOL
WINAPI
MicrosoftCertDllVerifyRevocation(
    IN DWORD dwEncodingType,
    IN DWORD dwRevType,
    IN DWORD cContext,
    IN PVOID rgpvContext[],
    IN DWORD dwFlags,
    IN PCERT_REVOCATION_PARA pRevPara,
    IN OUT PCERT_REVOCATION_STATUS pRevStatus
    )
{
    BOOL fResult;
    DWORD dwIndex = 0;
    DWORD dwError = (DWORD) CRYPT_E_NO_REVOCATION_CHECK;
    DWORD dwReason = 0;
    PCCERT_CONTEXT pCert;                       // not allocated
    PCCERT_CONTEXT pIssuer = NULL;
    PCCRL_CONTEXT pBaseCrl = NULL;
    PCCRL_CONTEXT pDeltaCrl = NULL;
    PCRL_ENTRY pCrlEntry = NULL;                // not allocated
    BOOL fDeltaCrlEntry = FALSE;
    BOOL fCrlTimeValid = FALSE;
    BOOL fBaseWireRetrieval = FALSE;
    PCERT_EXTENSION pCDPExt;
    BOOL fSaveCheckFreshnessTime;
    DWORD dwFreshnessTime;

    CERT_REVOCATION_PARA RevPara;
    FILETIME ftCurrent;

    // Following is only used for CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG
    FILETIME ftEndUrlRetrieval;

    // Ensure we have a structure containing all the possible parameters
    memset(&RevPara, 0, sizeof(RevPara));
    if (pRevPara != NULL)
        memcpy(&RevPara, pRevPara, min(pRevPara->cbSize, sizeof(RevPara)));
    RevPara.cbSize = sizeof(RevPara);
    if (0 == RevPara.dwUrlRetrievalTimeout)
        RevPara.dwUrlRetrievalTimeout = MSREVOKE_TIMEOUT;
    if (NULL == RevPara.pftCurrentTime) {
        GetSystemTimeAsFileTime(&ftCurrent);
        RevPara.pftCurrentTime = &ftCurrent;
    }
    pRevPara = &RevPara;

    if (dwFlags & CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG) {
        FILETIME ftStartUrlRetrieval;

        GetSystemTimeAsFileTime(&ftStartUrlRetrieval);
        I_CryptIncrementFileTimeByMilliseconds(
            &ftStartUrlRetrieval, pRevPara->dwUrlRetrievalTimeout,
            &ftEndUrlRetrieval);
    }

    if (cContext == 0)
        goto NoContextError;
    if (GET_CERT_ENCODING_TYPE(dwEncodingType) != CRYPT_ASN_ENCODING)
        goto NoRevocationCheckForEncodingTypeError;
    if (dwRevType != CERT_CONTEXT_REVOCATION_TYPE)
        goto NoRevocationCheckForRevTypeError;

    pCert = (PCCERT_CONTEXT) rgpvContext[0];

    // Check if we have a CRL dist point
    pCDPExt = CertFindExtension(
               szOID_CRL_DIST_POINTS,
               pCert->pCertInfo->cExtension,
               pCert->pCertInfo->rgExtension
               );

    // On 04-05-01 changed back to W2K semantics. Continue to check
    // if expired certificates are on the CRL.

    // If we have a CDP and an expired certificate,
    // then, the CA no longer maintains CRL information for the 
    // certificate. We must consider it as being revoked.
    //  if (NULL != pCDPExt &&
    //          0 < CompareFileTime(RevPara.pftCurrentTime,
    //              &pCert->pCertInfo->NotAfter)) {
    //      dwReason = CRL_REASON_CESSATION_OF_OPERATION;
    //      goto ExpiredCertError;
    //  }

    // Get the certificate's issuer
    if (NULL == (pIssuer = GetIssuerCert(
            cContext,
            (PCCERT_CONTEXT *) rgpvContext,
            dwFlags,
            &RevPara
            )))
        goto NoIssuerError;


    // Get the Base CRL for the subject certificate.
    //
    // Remember and disable the freshness retrieval option.
    fSaveCheckFreshnessTime = RevPara.fCheckFreshnessTime;
    RevPara.fCheckFreshnessTime = FALSE;
    if (!GetBaseCrl(
            pCert,
            pIssuer,
            &RevPara,
            pCDPExt,
            dwFlags,
            &ftEndUrlRetrieval,
            &pBaseCrl,
            &fCrlTimeValid,
            &fBaseWireRetrieval
            ))
        goto GetBaseCrlError;
    RevPara.fCheckFreshnessTime = fSaveCheckFreshnessTime;


    // If either the base crl or subject cert has a freshest, delta CRL,
    // get it
    if (!GetDeltaCrl(
            pCert,
            pIssuer,
            &RevPara,
            dwFlags,
            fBaseWireRetrieval,
            &ftEndUrlRetrieval,
            &pBaseCrl,
            &fCrlTimeValid,
            &pDeltaCrl,
            &dwFreshnessTime
            ))
        goto GetDeltaCrlError;

    if (NULL == pDeltaCrl) {
        dwFreshnessTime = I_CryptSubtractFileTimes(
            RevPara.pftCurrentTime, &pBaseCrl->pCrlInfo->ThisUpdate);

        if (RevPara.fCheckFreshnessTime) {
            if (RevPara.dwFreshnessTime >= dwFreshnessTime)
                fCrlTimeValid = TRUE;
            else {
                // Attempt to get a base CRL with better "freshness"
                PCCRL_CONTEXT pNewCrl;

                if (GetBaseCrl(
                        pCert,
                        pIssuer,
                        &RevPara,
                        pCDPExt,
                        dwFlags,
                        &ftEndUrlRetrieval,
                        &pNewCrl,
                        &fCrlTimeValid,
                        &fBaseWireRetrieval
                        )) {
                    CertFreeCRLContext(pBaseCrl);
                    pBaseCrl = pNewCrl;
                    dwFreshnessTime = I_CryptSubtractFileTimes(
                        RevPara.pftCurrentTime,
                            &pBaseCrl->pCrlInfo->ThisUpdate);
                } else
                    fCrlTimeValid = FALSE;
            }
        }
    } else {
        if (!CertFindCertificateInCRL(
                pCert,
                pDeltaCrl,
                0,                      // dwFlags
                NULL,                   // pvReserved
                &pCrlEntry
                ))
            goto CertFindCertificateInDeltaCRLError;
    }

    if (pCrlEntry) {
        // Delta CRL entry

        dwReason = GetCrlReason(pCrlEntry);
        if (CRL_REASON_REMOVE_FROM_CRL != dwReason)
            fDeltaCrlEntry = TRUE;
        else {
            if (!CertFindCertificateInCRL(
                    pCert,
                    pBaseCrl,
                    0,                      // dwFlags
                    NULL,                   // pvReserved
                    &pCrlEntry
                    ))
                goto CertFindCertificateInBaseCRLError;
            if (pCrlEntry) {
                dwReason = GetCrlReason(pCrlEntry);
                if (CRL_REASON_CERTIFICATE_HOLD == dwReason)
                    pCrlEntry = NULL;
            }

            if (NULL == pCrlEntry)
                dwReason = 0;
        }
    } else {
        if (!CertFindCertificateInCRL(
                pCert,
                pBaseCrl,
                0,                      // dwFlags
                NULL,                   // pvReserved
                &pCrlEntry
                ))
            goto CertFindCertificateInBaseCRLError;

        if (pCrlEntry)
            dwReason = GetCrlReason(pCrlEntry);
    }

    dwError = 0;
    if ( ( pCrlEntry != NULL ) &&
         ( ( RevPara.pftTimeToUse == NULL ) ||
           ( CompareFileTime(
                    RevPara.pftTimeToUse,
                    &pCrlEntry->RevocationDate ) >= 0 ) ) )
    {
        dwError = (DWORD) CRYPT_E_REVOKED;
    }
    else if (!fCrlTimeValid)
    {
        dwError = (DWORD) CRYPT_E_REVOCATION_OFFLINE;
    }

    if (pRevStatus->cbSize >=
            (offsetof(CERT_REVOCATION_STATUS, dwFreshnessTime) +
                sizeof(pRevStatus->dwFreshnessTime))) {
        pRevStatus->fHasFreshnessTime = TRUE;
        pRevStatus->dwFreshnessTime = dwFreshnessTime;
    }

    if (RevPara.pCrlInfo) {
        PCERT_REVOCATION_CRL_INFO pInfo = RevPara.pCrlInfo;

        if (pInfo->cbSize >= sizeof(*pInfo)) {
            if (pInfo->pBaseCrlContext)
                CertFreeCRLContext(pInfo->pBaseCrlContext);
            pInfo->pBaseCrlContext = CertDuplicateCRLContext(pBaseCrl);
            if (pInfo->pDeltaCrlContext) {
                CertFreeCRLContext(pInfo->pDeltaCrlContext);
                pInfo->pDeltaCrlContext = NULL;
            }

            if (pDeltaCrl)
                pInfo->pDeltaCrlContext = CertDuplicateCRLContext(pDeltaCrl);

            pInfo->fDeltaCrlEntry = fDeltaCrlEntry;
            pInfo->pCrlEntry = pCrlEntry;
                
        }
    }

CommonReturn:
    if (0 == dwError) {
        // Successfully checked that the certificate wasn't revoked
        if (1 < cContext) {
            dwIndex = 1;
            dwError = (DWORD) CRYPT_E_NO_REVOCATION_CHECK;
            fResult = FALSE;
        } else
            fResult = TRUE;
    } else
        fResult = FALSE;


    if (pIssuer)
        CertFreeCertificateContext(pIssuer);
    if (pBaseCrl)
        CertFreeCRLContext(pBaseCrl);
    if (pDeltaCrl)
        CertFreeCRLContext(pDeltaCrl);

    pRevStatus->dwIndex = dwIndex;
    pRevStatus->dwError = dwError;
    pRevStatus->dwReason = dwReason;
    SetLastError(dwError);
    return fResult;
ErrorReturn:
    dwError = GetLastError();
    if (0 == dwError)
        dwError = (DWORD) E_UNEXPECTED;
    goto CommonReturn;

SET_ERROR(NoContextError, E_INVALIDARG)
SET_ERROR(NoRevocationCheckForEncodingTypeError, CRYPT_E_NO_REVOCATION_CHECK)
SET_ERROR(NoRevocationCheckForRevTypeError, CRYPT_E_NO_REVOCATION_CHECK)
// SET_ERROR(ExpiredCertError, CRYPT_E_REVOKED)
TRACE_ERROR(NoIssuerError)
TRACE_ERROR(GetBaseCrlError)
TRACE_ERROR(GetDeltaCrlError)
TRACE_ERROR(CertFindCertificateInDeltaCRLError)
TRACE_ERROR(CertFindCertificateInBaseCRLError)
}



//+---------------------------------------------------------------------------
//
//  Function:   HasUnsupportedCrlCriticalExtension
//
//  Synopsis:   checks if the CRL has an unsupported critical section
//
//----------------------------------------------------------------------------

LPCSTR rgpszSupportedCrlExtensionOID[] = {
    szOID_DELTA_CRL_INDICATOR,
    szOID_ISSUING_DIST_POINT,
    szOID_FRESHEST_CRL,
    szOID_CRL_NUMBER,
    szOID_AUTHORITY_KEY_IDENTIFIER2,
    NULL
};

BOOL IsSupportedCrlExtension(
    PCERT_EXTENSION pExt
    )
{
    LPSTR pszExtOID = pExt->pszObjId;
    LPCSTR *ppSupOID;
    for (ppSupOID = rgpszSupportedCrlExtensionOID;
                                            NULL != *ppSupOID; ppSupOID++) {
        if (0 == strcmp(pszExtOID, *ppSupOID))
            return TRUE;
    }

    return FALSE;
}

BOOL HasUnsupportedCrlCriticalExtension(
    IN PCCRL_CONTEXT pCrl
    )
{
    PCRL_INFO pCrlInfo = pCrl->pCrlInfo;
    DWORD cExt = pCrlInfo->cExtension;
    PCERT_EXTENSION pExt = pCrlInfo->rgExtension;

    for ( ; 0 < cExt; cExt--, pExt++) {
        if (pExt->fCritical && !IsSupportedCrlExtension(pExt))
            return TRUE;
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetTimeValidCrl
//
//  Synopsis:   get a time valid base or delta CRL
//
//----------------------------------------------------------------------------
BOOL GetTimeValidCrl (
        IN LPCSTR pszTimeValidOid,
        IN LPVOID pvTimeValidPara,
        IN PCCERT_CONTEXT pSubject,
        IN PCCERT_CONTEXT pIssuer,
        IN PCERT_REVOCATION_PARA pRevPara,
        IN PCERT_EXTENSION pCDPExt,
        IN DWORD dwRevFlags,
        IN DWORD dwMsrevokeFlags,
        IN FILETIME *pftEndUrlRetrieval,
        OUT PCCRL_CONTEXT *ppCrl,
        IN OUT BOOL *pfWireRetrieval
        )
{
    BOOL  fResult = FALSE;
    DWORD dwFlags = 0;
    FILETIME ftFreshness;
    LPFILETIME pftValidFor;

    if (pRevPara->fCheckFreshnessTime)
    {
        I_CryptDecrementFileTimeBySeconds(
            pRevPara->pftCurrentTime,
            pRevPara->dwFreshnessTime,
            &ftFreshness);
        pftValidFor = &ftFreshness;

        dwFlags |= CRYPT_CHECK_FRESHNESS_TIME_VALIDITY;
    }
    else
    {
        pftValidFor = pRevPara->pftCurrentTime;
    }

    if ( dwMsrevokeFlags & MSREVOKE_DONT_CHECK_TIME_VALIDITY_FLAG )
    {
        dwFlags |= CRYPT_DONT_CHECK_TIME_VALIDITY;
    }

    if ( pCDPExt != NULL )
    {
        fResult = CryptGetTimeValidObject(
                       pszTimeValidOid,
                       pvTimeValidPara,
                       pIssuer,
                       pftValidFor,
                       dwFlags | CRYPT_CACHE_ONLY_RETRIEVAL,
                       0,                                       // dwTimeout
                       (LPVOID *)ppCrl,
                       NULL,                                    // pCredentials
                       NULL                                     // pvReserved
                       );
    }

    if ( fResult == FALSE )
    {
        DWORD dwSaveErr = 0;
        HCERTSTORE hCrlStore = pRevPara->hCrlStore;

        *ppCrl = NULL;

        if ( hCrlStore != NULL )
        {
            PCCRL_CONTEXT pFindCrl = NULL;
            DWORD dwFindFlags;
            CRL_FIND_ISSUED_FOR_PARA FindPara;

            dwSaveErr = GetLastError();

            dwFindFlags = CRL_FIND_ISSUED_BY_AKI_FLAG |
                CRL_FIND_ISSUED_BY_SIGNATURE_FLAG;
            if (dwMsrevokeFlags & MSREVOKE_DELTA_CRL_FLAG)
                dwFindFlags |= CRL_FIND_ISSUED_BY_DELTA_FLAG;
            else
                dwFindFlags |= CRL_FIND_ISSUED_BY_BASE_FLAG;

            FindPara.pSubjectCert = pSubject;
            FindPara.pIssuerCert = pIssuer;

            while ((pFindCrl = CertFindCRLInStore(
                    hCrlStore,
                    pIssuer->dwCertEncodingType,
                    dwFindFlags,
                    CRL_FIND_ISSUED_FOR,
                    (const void *) &FindPara,
                    pFindCrl
                    )))
            {
                if (!CertIsValidCRLForCertificate(
                        pSubject,
                        pFindCrl,
                        0,                  // dwFlags
                        NULL                // pvReserved
                        ))
                    continue;

                if ( !(dwMsrevokeFlags &
                            MSREVOKE_DONT_CHECK_TIME_VALIDITY_FLAG ))
                {
                    if (pRevPara->fCheckFreshnessTime)
                    {
                        if (CompareFileTime(pftValidFor,
                                &pFindCrl->pCrlInfo->ThisUpdate) > 0)
                        {
                            continue;
                        }
                    }
                    else
                    {
                        if ( CompareFileTime(
                                    pftValidFor,
                                    &pFindCrl->pCrlInfo->NextUpdate
                                    ) > 0 && 
                             !I_CryptIsZeroFileTime(
                                    &pFindCrl->pCrlInfo->NextUpdate) )
                        {
                            continue;
                        }
                    }
                }

                if ( NULL == *ppCrl )
                {
                    *ppCrl = CertDuplicateCRLContext(pFindCrl);
                }
                else
                {
                    PCCRL_CONTEXT pPrevCrl = *ppCrl;

                    // See if this CRL is newer
                    if ( CompareFileTime(
                            &pFindCrl->pCrlInfo->ThisUpdate,
                            &pPrevCrl->pCrlInfo->ThisUpdate
                            ) > 0 )
                    {
                        CertFreeCRLContext(pPrevCrl);
                        *ppCrl = CertDuplicateCRLContext(pFindCrl);
                    }
                }
            }
        }

        if ( *ppCrl != NULL )
        {
            return( TRUE );
        }
        else if ( pCDPExt == NULL )
        {
            SetLastError( (DWORD) CRYPT_E_NO_REVOCATION_CHECK );
            return( FALSE );
        }

        if ( !( dwRevFlags & CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION ) )
        {
            if (dwRevFlags & CERT_VERIFY_REV_ACCUMULATIVE_TIMEOUT_FLAG) {
                pRevPara->dwUrlRetrievalTimeout =
                    I_CryptRemainingMilliseconds(pftEndUrlRetrieval);
                if (0 == pRevPara->dwUrlRetrievalTimeout)
                    pRevPara->dwUrlRetrievalTimeout = 1;

                dwFlags |= CRYPT_ACCUMULATIVE_TIMEOUT;
            }

            fResult = CryptGetTimeValidObject(
                           pszTimeValidOid,
                           pvTimeValidPara,
                           pIssuer,
                           pftValidFor,
                           dwFlags | CRYPT_WIRE_ONLY_RETRIEVAL,
                           pRevPara->dwUrlRetrievalTimeout,
                           (LPVOID *)ppCrl,
                           NULL,                            // pCredentials
                           NULL                             // pvReserved
                           );
            *pfWireRetrieval = TRUE;
        }
        else if ( hCrlStore != NULL )
        {
            SetLastError( dwSaveErr );
        }

        assert( pCDPExt );
        if (!fResult)
        {
            if ( CRYPT_E_NOT_FOUND == GetLastError() )
            {
                SetLastError( (DWORD) CRYPT_E_NO_REVOCATION_CHECK );
            }
            else
            {
                SetLastError( (DWORD) CRYPT_E_REVOCATION_OFFLINE );
            }
        }
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   GetBaseCrl
//
//  Synopsis:   get the base CRL associated with the subject certificate
//
//----------------------------------------------------------------------------
BOOL GetBaseCrl (
        IN PCCERT_CONTEXT pSubject,
        IN PCCERT_CONTEXT pIssuer,
        IN PCERT_REVOCATION_PARA pRevPara,
        IN PCERT_EXTENSION pCDPExt,
        IN DWORD dwRevFlags,
        IN FILETIME *pftEndUrlRetrieval,
        OUT PCCRL_CONTEXT *ppBaseCrl,
        OUT BOOL *pfBaseCrlTimeValid,
        OUT BOOL *pfBaseWireRetrieval
        )
{
    BOOL fResult;
    PCCRL_CONTEXT pBaseCrl = NULL;

    *pfBaseWireRetrieval = FALSE;

    if (GetTimeValidCrl(
            TIME_VALID_OID_GET_CRL_FROM_CERT,
            (LPVOID) pSubject,
            pSubject,
            pIssuer,
            pRevPara,
            pCDPExt,
            dwRevFlags,
            0,                  // dwMsrevokeFlags
            pftEndUrlRetrieval,
            &pBaseCrl,
            pfBaseWireRetrieval
            )) {
        *pfBaseCrlTimeValid = TRUE;
    } else {
        *pfBaseCrlTimeValid = FALSE;

        if (!GetTimeValidCrl(
                TIME_VALID_OID_GET_CRL_FROM_CERT,
                (LPVOID) pSubject,
                pSubject,
                pIssuer,
                pRevPara,
                pCDPExt,
                dwRevFlags,
                MSREVOKE_DONT_CHECK_TIME_VALIDITY_FLAG,
                pftEndUrlRetrieval,
                &pBaseCrl,
                pfBaseWireRetrieval
                ))
        {
            goto GetTimeInvalidCrlError;
        }
    }

    if (HasUnsupportedCrlCriticalExtension(pBaseCrl))
        goto HasUnsupportedCriticalExtensionError;

    fResult = TRUE;

CommonReturn:
    *ppBaseCrl = pBaseCrl;
    return fResult;
ErrorReturn:
    if (pBaseCrl) {
        CertFreeCRLContext(pBaseCrl);
        pBaseCrl = NULL;
    }
    fResult = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetTimeInvalidCrlError)
SET_ERROR(HasUnsupportedCriticalExtensionError, CRYPT_E_NO_REVOCATION_CHECK)
}

//+---------------------------------------------------------------------------
//
//  Function:   GetDeltaCrl
//
//  Synopsis:   get the delta CRL associated with the subject certificate and
//              its base CRL
//
//  For now, always return TRUE. If not able to find a delta CRL, set
//  *pfCrlTimeValid to FALSE.
//
//----------------------------------------------------------------------------
BOOL GetDeltaCrl (
        IN PCCERT_CONTEXT pSubject,
        IN PCCERT_CONTEXT pIssuer,
        IN PCERT_REVOCATION_PARA pRevPara,
        IN DWORD dwRevFlags,
        IN BOOL fBaseWireRetrieval,
        IN FILETIME *pftEndUrlRetrieval,
        IN OUT PCCRL_CONTEXT *ppBaseCrl,
        IN OUT BOOL *pfCrlTimeValid,
        OUT PCCRL_CONTEXT *ppDeltaCrl,
        OUT DWORD *pdwFreshnessTime
        )
{
    PCERT_EXTENSION pFreshestExt;
    PCCRL_CONTEXT pBaseCrl = *ppBaseCrl;
    PCCRL_CONTEXT pDeltaCrl = NULL;
    LPCSTR pszTimeValidOid;
    LPVOID pvTimeValidPara;
    CERT_CRL_CONTEXT_PAIR CertCrlPair;
    BOOL fDeltaWireRetrieval;

    PCERT_EXTENSION pBaseCrlNumberExt;
    PCERT_EXTENSION pDeltaCrlIndicatorExt;
    int iBaseCrlNumber = 0;
    int iDeltaCrlIndicator = 0;
    DWORD cbInt;

    LPFILETIME pFreshnessThisUpdate;

    assert(pBaseCrl);

    // Check if the base CRL or the subject certificate has a freshest
    // ext
    if (pFreshestExt = CertFindExtension(
            szOID_FRESHEST_CRL,
            pBaseCrl->pCrlInfo->cExtension,
            pBaseCrl->pCrlInfo->rgExtension
            )) {
        pszTimeValidOid = TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CRL;

        CertCrlPair.pCertContext = pSubject;
        CertCrlPair.pCrlContext = pBaseCrl;
        pvTimeValidPara = (LPVOID) &CertCrlPair;
    } else if (pFreshestExt = CertFindExtension(
            szOID_FRESHEST_CRL,
            pSubject->pCertInfo->cExtension,
            pSubject->pCertInfo->rgExtension
            )) {
        pszTimeValidOid = TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CERT;
        pvTimeValidPara = (LPVOID) pSubject;
    } else {
        goto NoDeltaCrlReturn;
    }

    if (GetTimeValidCrl(
            pszTimeValidOid,
            pvTimeValidPara,
            pSubject,
            pIssuer,
            pRevPara,
            pFreshestExt,
            dwRevFlags,
            MSREVOKE_DELTA_CRL_FLAG,
            pftEndUrlRetrieval,
            &pDeltaCrl,
            &fDeltaWireRetrieval
            )) {
        *pfCrlTimeValid = TRUE;
    } else {
        *pfCrlTimeValid = FALSE;

        if (!GetTimeValidCrl(
                pszTimeValidOid,
                pvTimeValidPara,
                pSubject,
                pIssuer,
                pRevPara,
                pFreshestExt,
                dwRevFlags,
                MSREVOKE_DELTA_CRL_FLAG |
                    MSREVOKE_DONT_CHECK_TIME_VALIDITY_FLAG,
                pftEndUrlRetrieval,
                &pDeltaCrl,
                &fDeltaWireRetrieval
                ))
        {
            goto GetTimeInvalidCrlError;
        }
    }

    if (HasUnsupportedCrlCriticalExtension(pDeltaCrl))
        goto HasUnsupportedCriticalExtensionError;

    // Check that the base CRL number >= delta CRL indicator
    if (NULL == (pBaseCrlNumberExt = CertFindExtension(
            szOID_CRL_NUMBER,
            pBaseCrl->pCrlInfo->cExtension,
            pBaseCrl->pCrlInfo->rgExtension
            )))
        goto MissingBaseCrlNumberError;
    if (NULL == (pDeltaCrlIndicatorExt = CertFindExtension(
            szOID_DELTA_CRL_INDICATOR,
            pDeltaCrl->pCrlInfo->cExtension,
            pDeltaCrl->pCrlInfo->rgExtension
            )))
        goto MissingDeltaCrlIndicatorError;

    cbInt = sizeof(iBaseCrlNumber);
    if (!CryptDecodeObject(
            pBaseCrl->dwCertEncodingType,
            X509_INTEGER,
            pBaseCrlNumberExt->Value.pbData,
            pBaseCrlNumberExt->Value.cbData,
            0,                      // dwFlags
            &iBaseCrlNumber,
            &cbInt
            ))
        goto DecodeBaseCrlNumberError;

    cbInt = sizeof(iDeltaCrlIndicator);
    if (!CryptDecodeObject(
            pDeltaCrl->dwCertEncodingType,
            X509_INTEGER,
            pDeltaCrlIndicatorExt->Value.pbData,
            pDeltaCrlIndicatorExt->Value.cbData,
            0,                      // dwFlags
            &iDeltaCrlIndicator,
            &cbInt
            ))
        goto DecodeDeltaCrlIndicatorError;

    pFreshnessThisUpdate = &pDeltaCrl->pCrlInfo->ThisUpdate;

    if (iBaseCrlNumber < iDeltaCrlIndicator) {
        BOOL fValidBaseCrl = FALSE;

        if (!fBaseWireRetrieval &&
                0 == (dwRevFlags & CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION)) {
            // Attempt to get a more recent base CRL by hitting the wire
            PCCRL_CONTEXT pWireBaseCrl = NULL;

            if (CryptGetTimeValidObject(
                    TIME_VALID_OID_GET_CRL_FROM_CERT,
                    (LPVOID)pSubject,
                    pIssuer,
                    NULL,                           // pftValidFor
                    CRYPT_WIRE_ONLY_RETRIEVAL | CRYPT_DONT_CHECK_TIME_VALIDITY,
                    pRevPara->dwUrlRetrievalTimeout,
                    (LPVOID *) &pWireBaseCrl,
                    NULL,                                    // pCredentials
                    NULL                                     // pvReserved
                    )) {
                PCERT_EXTENSION pWireBaseCrlNumberExt;
                int iWireBaseCrlNumber;

                cbInt = sizeof(iWireBaseCrlNumber);
                if (NULL != (pWireBaseCrlNumberExt = CertFindExtension(
                        szOID_CRL_NUMBER,
                        pWireBaseCrl->pCrlInfo->cExtension,
                        pWireBaseCrl->pCrlInfo->rgExtension))
                                &&
                    CryptDecodeObject(
                        pWireBaseCrl->dwCertEncodingType,
                        X509_INTEGER,
                        pWireBaseCrlNumberExt->Value.pbData,
                        pWireBaseCrlNumberExt->Value.cbData,
                        0,                      // dwFlags
                        &iWireBaseCrlNumber,
                        &cbInt)) {
                    if (iWireBaseCrlNumber > iBaseCrlNumber) {
                        CertFreeCRLContext(pBaseCrl);
                        *ppBaseCrl = pBaseCrl = pWireBaseCrl;
                        pWireBaseCrl = NULL;
                        if (iWireBaseCrlNumber >= iDeltaCrlIndicator)
                            fValidBaseCrl = TRUE;
                    }
                }

                if (pWireBaseCrl)
                    CertFreeCRLContext(pWireBaseCrl);
            }
        }

        if (!fValidBaseCrl) {
            *pfCrlTimeValid = FALSE;
            pFreshnessThisUpdate = &pBaseCrl->pCrlInfo->ThisUpdate;
        }
    }

    *pdwFreshnessTime = I_CryptSubtractFileTimes(
        pRevPara->pftCurrentTime, pFreshnessThisUpdate);

    if (pRevPara->fCheckFreshnessTime) {
        if (pRevPara->dwFreshnessTime >= *pdwFreshnessTime)
            *pfCrlTimeValid = TRUE;
        else
            *pfCrlTimeValid = FALSE;
    }

NoDeltaCrlReturn:

CommonReturn:
    *ppDeltaCrl = pDeltaCrl;
    return TRUE;
ErrorReturn:
    if (pDeltaCrl) {
        CertFreeCRLContext(pDeltaCrl);
        pDeltaCrl = NULL;
    }
    *pfCrlTimeValid = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetTimeInvalidCrlError)
SET_ERROR(HasUnsupportedCriticalExtensionError, CRYPT_E_NO_REVOCATION_CHECK)
SET_ERROR(MissingBaseCrlNumberError, CRYPT_E_NO_REVOCATION_CHECK)
SET_ERROR(MissingDeltaCrlIndicatorError, CRYPT_E_NO_REVOCATION_CHECK)
TRACE_ERROR(DecodeBaseCrlNumberError)
TRACE_ERROR(DecodeDeltaCrlIndicatorError)
}

//+-------------------------------------------------------------------------
//  If the CRL entry has a CRL Reason extension, the enumerated reason
//  code is returned. Otherwise, a reason code of 0 is returned.
//--------------------------------------------------------------------------
DWORD GetCrlReason(
    IN PCRL_ENTRY pCrlEntry
    )
{
    DWORD dwReason = 0;
    PCERT_EXTENSION pExt;

    // Check if the certificate has a szOID_CRL_REASON_CODE extension
    if (pExt = CertFindExtension(
            szOID_CRL_REASON_CODE,
            pCrlEntry->cExtension,
            pCrlEntry->rgExtension
            )) {
        DWORD cbInfo = sizeof(dwReason);
        CryptDecodeObject(
            CRYPT_ASN_ENCODING,
            X509_CRL_REASON_CODE,
            pExt->Value.pbData,
            pExt->Value.cbData,
            0,                      // dwFlags
            &dwReason,
            &cbInfo);
    }
    return dwReason;
}

//+=========================================================================
//  Get Issuer Certificate Functions
//==========================================================================

PCCERT_CONTEXT FindIssuerCertInStores(
    IN PCCERT_CONTEXT pSubjectCert,
    IN DWORD cStore,
    IN HCERTSTORE rgStore[]
    )
{
    PCCERT_CONTEXT pIssuerCert = NULL;
    DWORD i;

    for (i = 0; i < cStore; i++) {
        while (TRUE) {
            DWORD dwFlags = CERT_STORE_SIGNATURE_FLAG;
            pIssuerCert = CertGetIssuerCertificateFromStore(
                rgStore[i],
                pSubjectCert,
                pIssuerCert,
                &dwFlags);
            if (NULL == pIssuerCert) {
                if (CRYPT_E_SELF_SIGNED == GetLastError()) {
                    if (0 == (dwFlags & CERT_STORE_SIGNATURE_FLAG))
                        pIssuerCert = CertDuplicateCertificateContext(
                            pSubjectCert);
                    return pIssuerCert;
                }
                break;
            } else if (0 == (dwFlags & CERT_STORE_SIGNATURE_FLAG))
                return pIssuerCert;
        }
    }

    return NULL;
}

static PCCERT_CONTEXT FindIssuerCertInDefaultStores(
    IN PCCERT_CONTEXT pSubjectCert
    )
{
    PCCERT_CONTEXT pIssuerCert;
    HCERTSTORE hStore;
    DWORD i;

    for (i = 0; i < NUM_DEFAULT_ISSUER_STORES; i++) {
        if (hStore = CertOpenStore(
                CERT_STORE_PROV_SYSTEM_W,
                0,                          // dwEncodingType
                0,                          // hCryptProv
                rgDefaultIssuerStores[i].dwFlags | CERT_STORE_READONLY_FLAG,
                (const void *) rgDefaultIssuerStores[i].pwszStore
                )) {
            pIssuerCert = FindIssuerCertInStores(pSubjectCert, 1, &hStore);
            CertCloseStore(hStore, 0);
            if (pIssuerCert)
                return pIssuerCert;
        }
    }

    return NULL;
}

//+-------------------------------------------------------------------------
//  Get the issuer of the first certificate in the array
//
//  Note, pRevPara is our copy and guaranteed to contain all the fields.
//--------------------------------------------------------------------------
PCCERT_CONTEXT GetIssuerCert(
    IN DWORD cCert,
    IN PCCERT_CONTEXT rgpCert[],
    IN DWORD dwFlags,
    IN PCERT_REVOCATION_PARA pRevPara
    )
{
    PCCERT_CONTEXT pSubjectCert;
    PCCERT_CONTEXT pIssuerCert = NULL;

    assert(cCert >= 1);
    pSubjectCert = rgpCert[0];
    if (cCert == 1) {
        pIssuerCert = pRevPara->pIssuerCert;
        if (NULL == pIssuerCert && CertCompareCertificateName(
                pSubjectCert->dwCertEncodingType,
                &pSubjectCert->pCertInfo->Subject,
                &pSubjectCert->pCertInfo->Issuer))
            // Self issued
            pIssuerCert = pSubjectCert;
    } else if (dwFlags & CERT_VERIFY_REV_CHAIN_FLAG)
        pIssuerCert = rgpCert[1];

    if (pIssuerCert)
        pIssuerCert = CertDuplicateCertificateContext(pIssuerCert);
    else {
        pIssuerCert = FindIssuerCertInStores(
            pSubjectCert, pRevPara->cCertStore, pRevPara->rgCertStore);
        if (NULL == pIssuerCert)
            pIssuerCert = FindIssuerCertInDefaultStores(pSubjectCert);
    }

    if (NULL == pIssuerCert)
        SetLastError((DWORD) CRYPT_E_REVOCATION_OFFLINE);
    return pIssuerCert;
}

//+---------------------------------------------------------------------------
//
//  Function:   CrlIssuerIsCertIssuer
//
//  Synopsis:   is the issuer of the CRL the issuer of the cert
//
//----------------------------------------------------------------------------
BOOL CrlIssuerIsCertIssuer (
        IN PCCERT_CONTEXT pCert,
        IN PCERT_EXTENSION pCrlDistPointExt
        )
{
    BOOL                  fResult = FALSE;
    DWORD                 cb = sizeof( PCRL_DIST_POINTS_INFO );
    PCRL_DIST_POINTS_INFO pDistPointInfo;

    if ( pCrlDistPointExt == NULL )
    {
        return( TRUE );
    }

    if ( CryptDecodeObjectEx(
              X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
              szOID_CRL_DIST_POINTS,
              pCrlDistPointExt->Value.pbData,
              pCrlDistPointExt->Value.cbData,
              CRYPT_DECODE_ALLOC_FLAG,
              NULL,
              (void *)&pDistPointInfo,
              &cb
              ) == TRUE )
    {
        if ( pDistPointInfo->cDistPoint > 0 )
        {
            if ( pDistPointInfo->rgDistPoint[ 0 ].CRLIssuer.cAltEntry == 0 )
            {
                fResult = TRUE;
            }
            else if ( pDistPointInfo->rgDistPoint[ 0 ].CRLIssuer.rgAltEntry[ 0 ].dwAltNameChoice == CERT_ALT_NAME_DIRECTORY_NAME )
            {
                if ( pDistPointInfo->rgDistPoint[ 0 ].CRLIssuer.rgAltEntry[ 0 ].DirectoryName.cbData == 0 )
                {
                    fResult = TRUE;
                }
                else if ( ( pDistPointInfo->rgDistPoint[ 0 ].CRLIssuer.rgAltEntry[ 0 ].DirectoryName.cbData ==
                            pCert->pCertInfo->Issuer.cbData ) &&
                          ( memcmp(
                               pDistPointInfo->rgDistPoint[ 0 ].CRLIssuer.rgAltEntry[ 0 ].DirectoryName.pbData,
                               pCert->pCertInfo->Issuer.pbData,
                               pCert->pCertInfo->Issuer.cbData
                               ) == 0 ) )
                {
                    fResult = TRUE;
                }
            }
        }
        else
        {
            fResult = TRUE;
        }

        LocalFree( pDistPointInfo );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertDllVerifyRevocation
//
//  Synopsis:   Dispatches to msrevoke and nsrevoke
//
//----------------------------------------------------------------------------
BOOL WINAPI
CertDllVerifyRevocation(
    IN DWORD dwEncodingType,
    IN DWORD dwRevType,
    IN DWORD cContext,
    IN PVOID rgpvContext[],
    IN DWORD dwFlags,
    IN PCERT_REVOCATION_PARA pRevPara,
    IN OUT PCERT_REVOCATION_STATUS pRevStatus
    )
{
    BOOL                   fResult;
    BOOL                   fNsResult;
    CERT_REVOCATION_STATUS NsRevocationStatus;

    fResult = MicrosoftCertDllVerifyRevocation(
                       dwEncodingType,
                       dwRevType,
                       cContext,
                       rgpvContext,
                       dwFlags,
                       pRevPara,
                       pRevStatus
                       );

    if ( ( fResult == TRUE ) ||
         ( pRevStatus->dwError == CRYPT_E_REVOKED ) ||
         ( pRevStatus->dwIndex > 0 ) )
    {
        return( fResult );
    }

    memset( &NsRevocationStatus, 0, sizeof( CERT_REVOCATION_STATUS ) );
    NsRevocationStatus.cbSize = sizeof( CERT_REVOCATION_STATUS );

    fNsResult = NetscapeCertDllVerifyRevocation(
                        dwEncodingType,
                        dwRevType,
                        cContext,
                        rgpvContext,
                        dwFlags,
                        pRevPara,
                        &NsRevocationStatus
                        );

    if ( NsRevocationStatus.dwError != CRYPT_E_NO_REVOCATION_CHECK )
    {
        DWORD cbSize = pRevStatus->cbSize;
        DWORD cbCopy = min(cbSize, sizeof(CERT_REVOCATION_STATUS));

        memcpy(pRevStatus, &NsRevocationStatus, cbCopy);
        pRevStatus->cbSize = cbSize;

        fResult = fNsResult;
    }

    return( fResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\ldapstor.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ldapstor.cpp
//
//  Contents:   Ldap Store Provider implementation
//
//  History:    17-Oct-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::CLdapStore, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CLdapStore::CLdapStore ( 
              OUT BOOL& rfResult
              )
                
           : m_pBinding( NULL ),
             m_hCacheStore( NULL ),
             m_dwOpenFlags( 0 ),
             m_fDirty( FALSE )
{
    rfResult = TRUE;
    memset( &m_UrlComponents, 0, sizeof( m_UrlComponents ) );

    if (! Pki_InitializeCriticalSection( &m_StoreLock ))
    {
        rfResult = FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::~CLdapStore, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CLdapStore::~CLdapStore ()
{
    DeleteCriticalSection( &m_StoreLock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::OpenStore, public
//
//  Synopsis:   open store
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::OpenStore (
                LPCSTR pszStoreProv,
                DWORD dwMsgAndCertEncodingType,
                HCRYPTPROV hCryptProv,
                DWORD dwFlags,
                const void* pvPara,
                HCERTSTORE hCertStore,
                PCERT_STORE_PROV_INFO pStoreProvInfo
                )
{
    BOOL    fResult;
    LPCWSTR pwszUrl = (LPCWSTR)pvPara;
    CHAR    pszUrl[INTERNET_MAX_PATH_LENGTH+1];
    DWORD   dwRetrievalFlags;
    DWORD   dwBindFlags;

    assert( m_pBinding == NULL );
    assert( m_hCacheStore == NULL );
    assert( m_dwOpenFlags == 0 );
    assert( m_fDirty == FALSE );

    if ( pvPara == NULL )
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    if ( WideCharToMultiByte(
             CP_ACP,
             0,
             pwszUrl,
             -1,
             pszUrl,
             INTERNET_MAX_PATH_LENGTH+1,
             NULL,
             NULL
             ) == 0 )
    {
        return( FALSE );
    }

    if ( LdapCrackUrl( pszUrl, &m_UrlComponents ) == FALSE )
    {
        return( FALSE );
    }

    m_dwOpenFlags = dwFlags;
    m_hCacheStore = hCertStore;

    dwRetrievalFlags = 0;
    dwBindFlags = LDAP_BIND_AUTH_SSPI_ENABLE_FLAG |
                    LDAP_BIND_AUTH_SIMPLE_ENABLE_FLAG;

    if (dwFlags & CERT_LDAP_STORE_SIGN_FLAG)
    {
        dwRetrievalFlags |= CRYPT_LDAP_SIGN_RETRIEVAL;
        dwBindFlags &= ~LDAP_BIND_AUTH_SIMPLE_ENABLE_FLAG;
    }

    if (dwFlags & CERT_LDAP_STORE_AREC_EXCLUSIVE_FLAG)
    {
        dwRetrievalFlags |= CRYPT_LDAP_AREC_EXCLUSIVE_RETRIEVAL;
        dwBindFlags &= ~LDAP_BIND_AUTH_SIMPLE_ENABLE_FLAG;
    }

    fResult = LdapGetBindings(
                  m_UrlComponents.pszHost,
                  m_UrlComponents.Port,
                  dwRetrievalFlags,
                  dwBindFlags,
                  LDAP_STORE_TIMEOUT,
                  NULL,
                  &m_pBinding
                  );

    if ( ( fResult == TRUE ) && !( dwFlags & CERT_STORE_READONLY_FLAG ) )
    {
        fResult = LdapHasWriteAccess( m_pBinding, &m_UrlComponents,
            LDAP_STORE_TIMEOUT );

        if ( fResult == FALSE )
        {
            SetLastError( (DWORD) ERROR_ACCESS_DENIED );
        }
    }

    if ( fResult == TRUE )
    {
        if ( m_dwOpenFlags & CERT_STORE_DELETE_FLAG )
        {
            m_fDirty = TRUE;

            fResult = InternalCommit( 0 );

            if ( fResult == TRUE )
            {
                pStoreProvInfo->dwStoreProvFlags = CERT_STORE_PROV_DELETED_FLAG;
            }

            CloseStore( 0 );
            return( fResult );
        }

        fResult = FillCacheStore( FALSE );
    }

    if ( fResult == TRUE )
    {
        pStoreProvInfo->cStoreProvFunc = LDAP_PROV_FUNC_COUNT;
        pStoreProvInfo->rgpvStoreProvFunc = (void **)rgpvLdapProvFunc;
        pStoreProvInfo->hStoreProv = (HCERTSTOREPROV)this;
    }
    else
    {
        CloseStore( 0 );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::CloseStore, public
//
//  Synopsis:   close the store
//
//----------------------------------------------------------------------------
VOID
CLdapStore::CloseStore (DWORD dwFlags)
{
    DWORD LastError = GetLastError();

    EnterCriticalSection( &m_StoreLock );

    InternalCommit( 0 );

    LdapFreeUrlComponents( &m_UrlComponents );
    memset( &m_UrlComponents, 0, sizeof( m_UrlComponents ) );

    LdapFreeBindings( m_pBinding );
    m_pBinding = NULL;

    LeaveCriticalSection( &m_StoreLock );

    SetLastError( LastError );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::DeleteCert, public
//
//  Synopsis:   delete cert from store
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::DeleteCert (PCCERT_CONTEXT pCertContext, DWORD dwFlags)
{
    return( WriteCheckSetDirtyWithLock(
                 CONTEXT_OID_CERTIFICATE,
                 (LPVOID)pCertContext,
                 0
                 ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::DeleteCrl, public
//
//  Synopsis:   delete CRL from store
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::DeleteCrl (PCCRL_CONTEXT pCrlContext, DWORD dwFlags)
{
    return( WriteCheckSetDirtyWithLock(
                 CONTEXT_OID_CRL,
                 (LPVOID)pCrlContext,
                 0
                 ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::DeleteCtl, public
//
//  Synopsis:   delete CTL from store
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::DeleteCtl (PCCTL_CONTEXT pCtlContext, DWORD dwFlags)
{
    return( WriteCheckSetDirtyWithLock(
                 CONTEXT_OID_CTL,
                 (LPVOID)pCtlContext,
                 0
                 ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::SetCertProperty, public
//
//  Synopsis:   set a property on the cert
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::SetCertProperty (
               PCCERT_CONTEXT pCertContext,
               DWORD dwPropId,
               DWORD dwFlags,
               const void* pvPara
               )
{
    // NOTENOTE: Properties are NOT persisted
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::SetCrlProperty, public
//
//  Synopsis:   set a property on the CRL
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::SetCrlProperty (
               PCCRL_CONTEXT pCrlContext,
               DWORD dwPropId,
               DWORD dwFlags,
               const void* pvPara
               )
{
    // NOTENOTE: Properties are NOT persisted
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::SetCtlProperty, public
//
//  Synopsis:   set a property on the CTL
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::SetCtlProperty (
               PCCTL_CONTEXT pCrlContext,
               DWORD dwPropId,
               DWORD dwFlags,
               const void* pvPara
               )
{
    // NOTENOTE: Properties are NOT persisted
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::WriteCert, public
//
//  Synopsis:   write cert to store
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::WriteCert (PCCERT_CONTEXT pCertContext, DWORD dwFlags)
{
    return( WriteCheckSetDirtyWithLock(
                 CONTEXT_OID_CERTIFICATE,
                 (LPVOID)pCertContext,
                 dwFlags
                 ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::WriteCrl, public
//
//  Synopsis:   write CRL to store
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::WriteCrl (PCCRL_CONTEXT pCrlContext, DWORD dwFlags)
{
    return( WriteCheckSetDirtyWithLock(
                 CONTEXT_OID_CRL,
                 (LPVOID)pCrlContext,
                 dwFlags
                 ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::WriteCtl, public
//
//  Synopsis:   write CTL to store
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::WriteCtl (PCCTL_CONTEXT pCtlContext, DWORD dwFlags)
{
    return( WriteCheckSetDirtyWithLock(
                 CONTEXT_OID_CTL,
                 (LPVOID)pCtlContext,
                 dwFlags
                 ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::StoreControl, public
//
//  Synopsis:   store control dispatch
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::StoreControl (DWORD dwFlags, DWORD dwCtrlType, LPVOID pvCtrlPara)
{
    switch ( dwCtrlType )
    {
    case CERT_STORE_CTRL_COMMIT:
         return( Commit( dwFlags ) );
    case CERT_STORE_CTRL_RESYNC:
         return( Resync() );
    }

    SetLastError( (DWORD) ERROR_CALL_NOT_IMPLEMENTED );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::Commit, public
//
//  Synopsis:   commit the store
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::Commit (DWORD dwFlags)
{
    BOOL fResult;

    EnterCriticalSection( &m_StoreLock );

    fResult = InternalCommit( dwFlags );

    LeaveCriticalSection( &m_StoreLock );

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::Resync, public
//
//  Synopsis:   resync the store
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::Resync ()
{
    BOOL fResult;

    EnterCriticalSection( &m_StoreLock );

    fResult = FillCacheStore( TRUE );

    LeaveCriticalSection( &m_StoreLock );

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::FillCacheStore, private
//
//  Synopsis:   fill the cache store
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::FillCacheStore (BOOL fClearCache)
{
    BOOL             fResult;
    CRYPT_BLOB_ARRAY cba;

    if ( fClearCache == TRUE )
    {
        if ( ObjectContextDeleteAllObjectsFromStore( m_hCacheStore ) == FALSE )
        {
            return( FALSE );
        }
    }

    fResult = LdapSendReceiveUrlRequest(
                  m_pBinding,
                  &m_UrlComponents,
                  0,                    // dwRetrievalFlags
                  LDAP_STORE_TIMEOUT,
                  &cba
                  );

    if (fResult)
    {
        HCERTSTORE hStore = NULL;

        fResult = CreateObjectContext (
            CRYPT_RETRIEVE_MULTIPLE_OBJECTS,
            &cba,
            CERT_QUERY_CONTENT_FLAG_CERT                |
                CERT_QUERY_CONTENT_FLAG_CTL             |
                CERT_QUERY_CONTENT_FLAG_CRL             |
                CERT_QUERY_CONTENT_FLAG_PKCS7_SIGNED    |
                CERT_QUERY_CONTENT_FLAG_CERT_PAIR,
            FALSE,          // fQuerySingleContext
            (LPVOID*) &hStore
            );

        if (fResult)
        {
            fResult = I_CertUpdateStore( m_hCacheStore, hStore, 0, NULL );
            CertCloseStore( hStore, 0 );
        }

        CCryptBlobArray BlobArray( &cba, 0 );

        BlobArray.FreeArray( TRUE );
    }
    else if (GetLastError() == CRYPT_E_NOT_FOUND)
    {
        fResult = TRUE;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::InternalCommit, private
//
//  Synopsis:   commit current changes
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::InternalCommit (DWORD dwFlags)
{
    BOOL            fResult = TRUE;
    LPCSTR          pszContextOid = CONTEXT_OID_CERTIFICATE;
    LPVOID          pvContext = NULL;
    struct berval** abv;
    struct berval** oldabv;
    DWORD           cbv = 0;
    DWORD           cCount;
    DWORD           cArray = MIN_BERVAL;

    if ( dwFlags & CERT_STORE_CTRL_COMMIT_CLEAR_FLAG )
    {
        m_fDirty = FALSE;
        return( TRUE );
    }

    if ( m_dwOpenFlags & CERT_STORE_READONLY_FLAG )
    {
        SetLastError( (DWORD) ERROR_ACCESS_DENIED );
        return( FALSE );
    }

    if ( ( m_fDirty == FALSE ) &&
         !( dwFlags & CERT_STORE_CTRL_COMMIT_FORCE_FLAG ) )
    {
        return( TRUE );
    }

    abv = (struct berval**)malloc( cArray * sizeof( struct berval* ) );
    if ( abv == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    memset( abv, 0, cArray * sizeof( struct berval * ) );

    while ( ( fResult == TRUE ) &&
            ( ( pvContext = ObjectContextEnumObjectsInStore(
                                  m_hCacheStore,
                                  pszContextOid,
                                  pvContext,
                                  &pszContextOid
                                  ) ) != NULL ) )
    {
        abv[cbv] = (struct berval*)malloc( sizeof( struct berval ) );
        if ( abv[cbv] != NULL )
        {
            ObjectContextGetEncodedBits(
                  pszContextOid,
                  pvContext,
                  &(abv[cbv]->bv_len),
                  (LPBYTE *)&(abv[cbv]->bv_val)
                  );

            cbv += 1;
        }
        else
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            fResult = FALSE;
            ObjectContextFree( pszContextOid, pvContext );
        }

        if ( cbv == ( cArray - 1 ) )
        {
            oldabv = abv;

            abv = (struct berval**)realloc(
                                     abv,
                                     ( cArray + GROW_BERVAL ) *
                                     sizeof( struct berval* )
                                     );

            if ( abv != NULL )
            {
                memset( &abv[cArray], 0, GROW_BERVAL * sizeof( struct berval* ) );
                cArray += GROW_BERVAL;
            }
            else
            {
                free( oldabv );
                SetLastError( (DWORD) E_OUTOFMEMORY );
                fResult = FALSE;
            }
        }
    }

    if ( fResult == TRUE )
    {
        ULONG     lderr;
        LDAPModA  mod;
        LDAPModA* amod[2];

        assert( m_UrlComponents.cAttr == 1 );

        mod.mod_type = m_UrlComponents.apszAttr[0];
        mod.mod_op = LDAP_MOD_BVALUES;

        amod[0] = &mod;
        amod[1] = NULL;

        if ( cbv > 0 )
        {
            mod.mod_op |= LDAP_MOD_REPLACE;
            mod.mod_bvalues = abv;
        }
        else
        {
            mod.mod_op |= LDAP_MOD_DELETE;
            mod.mod_bvalues = NULL;
        }

        if ( ( lderr = ldap_modify_sA(
                            m_pBinding,
                            m_UrlComponents.pszDN,
                            amod
                            ) ) == LDAP_SUCCESS )
        {
            m_fDirty = FALSE;
        }
        else
        {
            SetLastError( LdapMapErrorToWin32( lderr ) );
            fResult = FALSE;
        }
    }

    for ( cCount = 0; cCount < cbv; cCount++ )
    {
        free( abv[cCount] );
    }

    free( abv );

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CLdapStore::WriteCheckSetDirtyWithLock, private
//
//  Synopsis:   if the store is writable, set the dirty flag taking the store
//              lock where appropriate
//
//----------------------------------------------------------------------------
BOOL
CLdapStore::WriteCheckSetDirtyWithLock (
                 LPCSTR pszContextOid,
                 LPVOID pvContext,
                 DWORD dwFlags
                 )
{
    if ( m_dwOpenFlags & CERT_STORE_READONLY_FLAG )
    {
        SetLastError( (DWORD) ERROR_ACCESS_DENIED );
        return( FALSE );
    }

    EnterCriticalSection( &m_StoreLock );

    if ( ( dwFlags >> 16 ) == CERT_STORE_ADD_ALWAYS )
    {
        LPVOID pv;

        if ( ( pv = ObjectContextFindCorrespondingObject(
                          m_hCacheStore,
                          pszContextOid,
                          pvContext
                          ) ) != NULL )
        {
            ObjectContextFree( pszContextOid, pv );
            SetLastError( (DWORD) CRYPT_E_EXISTS );
            return( FALSE );
        }
    }

    m_fDirty = TRUE;

    LeaveCriticalSection( &m_StoreLock );

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapProvOpenStore
//
//  Synopsis:   provider open store entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapProvOpenStore (
                IN LPCSTR pszStoreProv,
                IN DWORD dwMsgAndCertEncodingType,
                IN HCRYPTPROV hCryptProv,
                IN DWORD dwFlags,
                IN const void* pvPara,
                IN HCERTSTORE hCertStore,
                IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
                )
{
    BOOL        fResult = FALSE;
    CLdapStore* pLdap;

    pLdap = new CLdapStore ( fResult );
    if ( pLdap == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    if ( fResult == FALSE )
    {
        delete pLdap;
        return( FALSE );
    }

    fResult = pLdap->OpenStore(
                         pszStoreProv,
                         dwMsgAndCertEncodingType,
                         hCryptProv,
                         dwFlags,
                         pvPara,
                         hCertStore,
                         pStoreProvInfo
                         );

    if ( fResult == FALSE )
    {
        delete pLdap;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapProvCloseStore
//
//  Synopsis:   provider close store entry point
//
//----------------------------------------------------------------------------
void WINAPI LdapProvCloseStore (
                IN HCERTSTOREPROV hStoreProv,
                IN DWORD dwFlags
                )
{
    ( (CLdapStore *)hStoreProv )->CloseStore( dwFlags );
    delete (CLdapStore *)hStoreProv;
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapProvDeleteCert
//
//  Synopsis:   provider delete certificate entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapProvDeleteCert (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCERT_CONTEXT pCertContext,
                IN DWORD dwFlags
                )
{
    return( ( (CLdapStore *)hStoreProv )->DeleteCert( pCertContext, dwFlags ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapProvDeleteCrl
//
//  Synopsis:   provider delete CRL entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapProvDeleteCrl (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCRL_CONTEXT pCrlContext,
                IN DWORD dwFlags
                )
{
    return( ( (CLdapStore *)hStoreProv )->DeleteCrl( pCrlContext, dwFlags ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapProvDeleteCtl
//
//  Synopsis:   provider delete CTL entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapProvDeleteCtl (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCTL_CONTEXT pCtlContext,
                IN DWORD dwFlags
                )
{
    return( ( (CLdapStore *)hStoreProv )->DeleteCtl( pCtlContext, dwFlags ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapProvSetCertProperty
//
//  Synopsis:   provider set certificate property entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapProvSetCertProperty (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCERT_CONTEXT pCertContext,
                IN DWORD dwPropId,
                IN DWORD dwFlags,
                IN const void* pvData
                )
{
    return( ( (CLdapStore *)hStoreProv )->SetCertProperty(
                                             pCertContext,
                                             dwPropId,
                                             dwFlags,
                                             pvData
                                             ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapProvSetCrlProperty
//
//  Synopsis:   provider set CRL property entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapProvSetCrlProperty (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCRL_CONTEXT pCrlContext,
                IN DWORD dwPropId,
                IN DWORD dwFlags,
                IN const void* pvData
                )
{
    return( ( (CLdapStore *)hStoreProv )->SetCrlProperty(
                                             pCrlContext,
                                             dwPropId,
                                             dwFlags,
                                             pvData
                                             ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapProvSetCtlProperty
//
//  Synopsis:   provider set CTL property entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapProvSetCtlProperty (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCTL_CONTEXT pCtlContext,
                IN DWORD dwPropId,
                IN DWORD dwFlags,
                IN const void* pvData
                )
{
    return( ( (CLdapStore *)hStoreProv )->SetCtlProperty(
                                             pCtlContext,
                                             dwPropId,
                                             dwFlags,
                                             pvData
                                             ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapProvWriteCert
//
//  Synopsis:   provider write certificate entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapProvWriteCert (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCERT_CONTEXT pCertContext,
                IN DWORD dwFlags
                )
{
    return( ( (CLdapStore *)hStoreProv )->WriteCert( pCertContext, dwFlags ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapProvWriteCrl
//
//  Synopsis:   provider write CRL entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapProvWriteCrl (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCRL_CONTEXT pCrlContext,
                IN DWORD dwFlags
                )
{
    return( ( (CLdapStore *)hStoreProv )->WriteCrl( pCrlContext, dwFlags ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapProvWriteCtl
//
//  Synopsis:   provider write CTL entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapProvWriteCtl (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCTL_CONTEXT pCtlContext,
                IN DWORD dwFlags
                )
{
    return( ( (CLdapStore *)hStoreProv )->WriteCtl( pCtlContext, dwFlags ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   LdapProvStoreControl
//
//  Synopsis:   provider control entry point
//
//----------------------------------------------------------------------------
BOOL WINAPI LdapProvStoreControl (
                IN HCERTSTOREPROV hStoreProv,
                IN DWORD dwFlags,
                IN DWORD dwCtrlType,
                IN LPVOID pvCtrlPara
                )
{
    return( ( (CLdapStore *)hStoreProv )->StoreControl(
                                               dwFlags,
                                               dwCtrlType,
                                               pvCtrlPara
                                               ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   I_CryptNetGetUserDsStoreUrl
//
//  Synopsis:   get user DS store URL
//
//----------------------------------------------------------------------------
BOOL WINAPI
I_CryptNetGetUserDsStoreUrl (
          IN LPWSTR pwszUserAttribute,
          OUT LPWSTR* ppwszUrl
          )
{
    BOOL               fResult;
    CHAR               szUser[MAX_PATH];
    ULONG              nUser = MAX_PATH;
    LPSTR              pszUser = szUser;
    DWORD              cUrl = 0;
    LPSTR              pszUrl = NULL;
    LPWSTR             pwszUrl = NULL;
    HMODULE            hModule = NULL;
    PFN_GETUSERNAMEEXA pfnGetUserNameExA = NULL;

    hModule = LoadLibraryA( "secur32.dll" );
    if ( hModule == NULL )
    {
        return( FALSE );
    }

    pfnGetUserNameExA = (PFN_GETUSERNAMEEXA)GetProcAddress(
                                               hModule,
                                               "GetUserNameExA"
                                               );

    if ( pfnGetUserNameExA == NULL )
    {
        FreeLibrary( hModule );
        return( FALSE );
    }

    fResult = ( *pfnGetUserNameExA )( NameFullyQualifiedDN, pszUser, &nUser );
    if ( fResult == FALSE )
    {
        if ( ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) ||
             ( GetLastError() == ERROR_MORE_DATA ) )
        {
            pszUser = new CHAR [nUser];
            if ( pszUser != NULL )
            {
                fResult = ( *pfnGetUserNameExA )(
                                   NameFullyQualifiedDN,
                                   pszUser,
                                   &nUser
                                   );
            }
            else
            {
                SetLastError( (DWORD) E_OUTOFMEMORY );
                return( FALSE );
            }
        }
    }

    if ( fResult == TRUE )
    {
        cUrl = strlen( USER_DS_STORE_URL_FORMAT ) + nUser + 1;

        pszUrl = new CHAR [cUrl];
        if ( pszUrl != NULL )
        {
            wsprintfA( pszUrl, USER_DS_STORE_URL_FORMAT, pszUser );
        }
        else
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        pwszUrl = (LPWSTR)CryptMemAlloc(
                               ( cUrl +
                                 wcslen( pwszUserAttribute ) ) *
                               sizeof( WCHAR )
                               );

        if ( pwszUrl != NULL )
        {
            if ( MultiByteToWideChar(
                      CP_ACP,
                      0,
                      pszUrl,
                      cUrl,
                      pwszUrl,
                      cUrl
                      ) == 0 )
            {
                fResult = FALSE;
            }
        }
        else
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        wcscat( pwszUrl, pwszUserAttribute );
        *ppwszUrl = pwszUrl;
    }
    else
    {
        CryptMemFree( pwszUrl );
    }

    if ( pszUser != szUser )
    {
        delete pszUser;
    }

    delete pszUrl;

    return( fResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\octxutil.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       octxutil.cpp
//
//  Contents:   General Object Context Utility Function implemention
//
//  History:    29-Sep-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextGetOriginIdentifier
//
//  Synopsis:   get origin identifier for a CAPI2 object
//
//----------------------------------------------------------------------------
BOOL WINAPI ObjectContextGetOriginIdentifier (
                  IN LPCSTR pszContextOid,
                  IN LPVOID pvContext,
                  IN PCCERT_CONTEXT pIssuer,
                  IN DWORD dwFlags,
                  OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
                  )
{
    if ( pszContextOid == CONTEXT_OID_CERTIFICATE )
    {
        return( CertGetOriginIdentifier(
                    (PCCERT_CONTEXT)pvContext,
                    pIssuer,
                    dwFlags,
                    OriginIdentifier
                    ) );
    }
    else if ( pszContextOid == CONTEXT_OID_CTL )
    {
        return( CtlGetOriginIdentifier(
                   (PCCTL_CONTEXT)pvContext,
                   pIssuer,
                   dwFlags,
                   OriginIdentifier
                   ) );
    }
    else if ( pszContextOid == CONTEXT_OID_CRL )
    {
        return( CrlGetOriginIdentifier(
                   (PCCRL_CONTEXT)pvContext,
                   pIssuer,
                   dwFlags,
                   OriginIdentifier
                   ) );
    }

    SetLastError( (DWORD) E_INVALIDARG );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextIsValidForSubject
//
//  Synopsis:   returns TRUE if the object context is valid for the specified
//              subject
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextIsValidForSubject (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN LPVOID pvSubject
      )
{
    if ( pszContextOid == CONTEXT_OID_CRL && pvSubject != NULL )
    {
        return CertIsValidCRLForCertificate(
            (PCCERT_CONTEXT) pvSubject,
            (PCCRL_CONTEXT) pvContext,
            0,                              // dwFlags
            NULL                            // pvReserved
            );
    }
    else
    {
        return TRUE;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextFindExtension
//
//  Synopsis:   get the specified extension from the object
//
//----------------------------------------------------------------------------
PCERT_EXTENSION WINAPI
ObjectContextFindExtension (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN LPCSTR pszExtOid
      )
{
    DWORD           cExt;
    PCERT_EXTENSION rgExt;

    if ( pszContextOid == CONTEXT_OID_CERTIFICATE )
    {
        PCCERT_CONTEXT pCertContext = (PCCERT_CONTEXT)pvContext;

        cExt = pCertContext->pCertInfo->cExtension;
        rgExt = pCertContext->pCertInfo->rgExtension;
    }
    else if ( pszContextOid == CONTEXT_OID_CTL )
    {
        PCCTL_CONTEXT pCtlContext = (PCCTL_CONTEXT)pvContext;

        cExt = pCtlContext->pCtlInfo->cExtension;
        rgExt = pCtlContext->pCtlInfo->rgExtension;
    }
    else if ( pszContextOid == CONTEXT_OID_CRL )
    {
        PCCRL_CONTEXT pCrlContext = (PCCRL_CONTEXT)pvContext;

        cExt = pCrlContext->pCrlInfo->cExtension;
        rgExt = pCrlContext->pCrlInfo->rgExtension;
    }
    else
    {
        return( NULL );
    }

    return( CertFindExtension( pszExtOid, cExt, rgExt ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextGetProperty
//
//  Synopsis:   get the specified property from the object
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextGetProperty (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN DWORD dwPropId,
      IN LPVOID pvData,
      IN DWORD* pcbData
      )
{
    if ( pszContextOid == CONTEXT_OID_CERTIFICATE )
    {
        return( CertGetCertificateContextProperty(
                    (PCCERT_CONTEXT)pvContext,
                    dwPropId,
                    pvData,
                    pcbData
                    ) );
    }
    else if ( pszContextOid == CONTEXT_OID_CTL )
    {
        return( CertGetCTLContextProperty(
                    (PCCTL_CONTEXT)pvContext,
                    dwPropId,
                    pvData,
                    pcbData
                    ) );
    }
    else if ( pszContextOid == CONTEXT_OID_CRL )
    {
        return( CertGetCRLContextProperty(
                    (PCCRL_CONTEXT)pvContext,
                    dwPropId,
                    pvData,
                    pcbData
                    ) );
    }

    SetLastError( (DWORD) E_INVALIDARG );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextGetAttribute
//
//  Synopsis:   find an attribute
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextGetAttribute (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN DWORD Index,
      IN DWORD dwFlags,
      IN LPCSTR pszAttrOid,
      OUT PCRYPT_ATTRIBUTE pAttribute,
      IN OUT DWORD* pcbAttribute
      )
{
    BOOL              fResult;
    PCRYPT_ATTRIBUTES pAttributes;
    DWORD             cbData;
    DWORD             cCount;
    HCRYPTMSG         hCryptMsg;
    DWORD             dwParamType;
    BOOL              fFound = FALSE;

    if ( Index == -1 )
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    if ( dwFlags == CRYPT_GET_URL_FROM_UNAUTH_ATTRIBUTE )
    {
        dwParamType = CMSG_SIGNER_UNAUTH_ATTR_PARAM;
    }
    else if ( dwFlags == CRYPT_GET_URL_FROM_AUTH_ATTRIBUTE )
    {
        dwParamType = CMSG_SIGNER_AUTH_ATTR_PARAM;
    }
    else
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    if ( pszContextOid == CONTEXT_OID_CTL )
    {
        hCryptMsg = ((PCCTL_CONTEXT)pvContext)->hCryptMsg;
    }
    else if ( pszContextOid == CONTEXT_OID_PKCS7 )
    {
        hCryptMsg = (HCRYPTMSG)pvContext;
    }
    else
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    if ( CryptMsgGetParam(
              hCryptMsg,
              dwParamType,
              Index,
              NULL,
              &cbData
              ) == FALSE )
    {
        return( FALSE );
    }

    pAttributes = (PCRYPT_ATTRIBUTES)new BYTE [cbData];
    if ( pAttributes == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    if ( CryptMsgGetParam(
              hCryptMsg,
              dwParamType,
              Index,
              pAttributes,
              &cbData
              ) == FALSE )
    {
        delete (LPBYTE)pAttributes;
        return( FALSE );
    }

    fResult = TRUE;

    for ( cCount = 0; cCount < pAttributes->cAttr; cCount++ )
    {
        if ( strcmp( pAttributes->rgAttr[cCount].pszObjId, pszAttrOid ) == 0 )
        {
            DWORD cbAttribute;
            DWORD cbOid;

            cbAttribute = sizeof( CRYPT_ATTRIBUTE ) + sizeof( CRYPT_ATTR_BLOB );
            cbOid = strlen( pszAttrOid ) + 1;
            cbData = pAttributes->rgAttr[cCount].rgValue[0].cbData;
            cbAttribute += cbOid + cbData;

            if ( pAttribute == NULL )
            {
                if ( pcbAttribute == NULL )
                {
                    SetLastError( (DWORD) E_INVALIDARG );
                    fResult = FALSE;
                }
                else
                {
                    *pcbAttribute = cbAttribute;
                    fFound = TRUE;
                    break;
                }
            }
            else if ( *pcbAttribute < cbAttribute )
            {
                SetLastError( (DWORD) ERROR_MORE_DATA );
                fResult = FALSE;
            }

            if ( fResult == TRUE )
            {
                pAttribute->pszObjId = (LPSTR)((LPBYTE)pAttribute +
                                               sizeof( CRYPT_ATTRIBUTE ) +
                                               sizeof( CRYPT_ATTR_BLOB ));

                strcpy( pAttribute->pszObjId, pszAttrOid );

                pAttribute->cValue = 1;
                pAttribute->rgValue = (PCRYPT_ATTR_BLOB)((LPBYTE)pAttribute +
                                                     sizeof( CRYPT_ATTRIBUTE ));

                pAttribute->rgValue[0].cbData = cbData;
                pAttribute->rgValue[0].pbData = (LPBYTE)pAttribute->pszObjId +
                                                cbOid;

                memcpy(
                   pAttribute->rgValue[0].pbData,
                   pAttributes->rgAttr[cCount].rgValue[0].pbData,
                   cbData
                   );
            }

            fFound = TRUE;
            break;
        }
    }

    delete (LPBYTE)pAttributes;

    if ( fResult == TRUE )
    {
        fResult = fFound;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextDuplicate
//
//  Synopsis:   duplicate the context
//
//----------------------------------------------------------------------------
LPVOID WINAPI
ObjectContextDuplicate (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext
      )
{
    if ( pszContextOid == CONTEXT_OID_CERTIFICATE )
    {
        return( (LPVOID)CertDuplicateCertificateContext(
                            (PCCERT_CONTEXT)pvContext
                            ) );
    }
    else if ( pszContextOid == CONTEXT_OID_CTL )
    {
        return( (LPVOID)CertDuplicateCTLContext( (PCCTL_CONTEXT)pvContext ) );
    }
    else if ( pszContextOid == CONTEXT_OID_CRL )
    {
        return( (LPVOID)CertDuplicateCRLContext( (PCCRL_CONTEXT)pvContext ) );
    }

    SetLastError( (DWORD) E_INVALIDARG );
    return( NULL );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextAdd
//
//  Synopsis:   object context create
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextCreate (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      OUT LPVOID* ppvContext
      )
{
    if ( pszContextOid == CONTEXT_OID_CERTIFICATE )
    {
        return( CertAddCertificateContextToStore(
                    NULL,
                    (PCCERT_CONTEXT)pvContext,
                    CERT_STORE_ADD_ALWAYS,
                    (PCCERT_CONTEXT *)ppvContext
                    ) );
    }
    else if ( pszContextOid == CONTEXT_OID_CTL )
    {
        return( CertAddCTLContextToStore(
                    NULL,
                    (PCCTL_CONTEXT)pvContext,
                    CERT_STORE_ADD_ALWAYS,
                    (PCCTL_CONTEXT *)ppvContext
                    ) );
    }
    else if ( pszContextOid == CONTEXT_OID_CRL )
    {
        return( CertAddCRLContextToStore(
                    NULL,
                    (PCCRL_CONTEXT)pvContext,
                    CERT_STORE_ADD_ALWAYS,
                    (PCCRL_CONTEXT *)ppvContext
                    ) );
    }

    SetLastError( (DWORD) E_INVALIDARG );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextGetCreateAndExpireTimes
//
//  Synopsis:   get create and expire times
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextGetCreateAndExpireTimes (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      OUT LPFILETIME pftCreateTime,
      OUT LPFILETIME pftExpireTime
      )
{
    if ( pszContextOid == CONTEXT_OID_CERTIFICATE )
    {
        *pftCreateTime = ((PCCERT_CONTEXT)pvContext)->pCertInfo->NotBefore;
        *pftExpireTime = ((PCCERT_CONTEXT)pvContext)->pCertInfo->NotAfter;
        return( TRUE );
    }
    else if ( pszContextOid == CONTEXT_OID_CTL )
    {
        *pftCreateTime = ((PCCTL_CONTEXT)pvContext)->pCtlInfo->ThisUpdate;
        *pftExpireTime = ((PCCTL_CONTEXT)pvContext)->pCtlInfo->NextUpdate;
        return( TRUE );
    }
    else if ( pszContextOid == CONTEXT_OID_CRL )
    {
        *pftCreateTime = ((PCCRL_CONTEXT)pvContext)->pCrlInfo->ThisUpdate;
        *pftExpireTime = ((PCCRL_CONTEXT)pvContext)->pCrlInfo->NextUpdate;
        return( TRUE );
    }

    SetLastError( (DWORD) E_INVALIDARG );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextGetNextUpdateUrl
//
//  Synopsis:   get the renewal URL
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextGetNextUpdateUrl (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN PCCERT_CONTEXT pIssuer,
      IN LPWSTR pwszUrlHint,
      OUT PCRYPT_URL_ARRAY* ppUrlArray,
      OUT DWORD* pcbUrlArray,
      OUT DWORD* pPreferredUrlIndex,
      OUT BOOL* pfHintInArray
      )
{
    BOOL             fResult;
    DWORD            cbUrlArray;
    PCRYPT_URL_ARRAY pUrlArray = NULL;
    DWORD            PreferredUrlIndex;
    DWORD            cCount;
    DWORD            cSigner;
    DWORD            cbData;
    BOOL             fHintInArray = FALSE;
    PCCTL_CONTEXT    pCtlContext = (PCCTL_CONTEXT)pvContext;
    PCERT_INFO       pCertInfo;
    BOOL             fFoundIssuer = FALSE;
    LPVOID           apv[2];

    if ( pszContextOid != CONTEXT_OID_CTL )
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    cbData = sizeof( DWORD );
    if ( CryptMsgGetParam(
              pCtlContext->hCryptMsg,
              CMSG_SIGNER_COUNT_PARAM,
              0,
              &cSigner,
              &cbData
              ) == FALSE )
    {
        return( FALSE );
    }

    for ( cCount = 0;
         ( cCount < cSigner ) && ( fFoundIssuer == FALSE );
         cCount++ )
    {
        if ( CryptMsgGetParam(
                  pCtlContext->hCryptMsg,
                  CMSG_SIGNER_CERT_INFO_PARAM,
                  cCount,
                  NULL,
                  &cbData
                  ) == FALSE )
        {
            printf("GetLastError() = %lx\n", GetLastError());
            return( FALSE );
        }

        pCertInfo = (PCERT_INFO)new BYTE [cbData];
        if ( pCertInfo == NULL )
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            return( FALSE );
        }

        if ( CryptMsgGetParam(
                  pCtlContext->hCryptMsg,
                  CMSG_SIGNER_CERT_INFO_PARAM,
                  cCount,
                  (LPVOID)pCertInfo,
                  &cbData
                  ) == FALSE )
        {
            delete (LPBYTE)pCertInfo;
            return( FALSE );
        }

        if ( ( pIssuer->pCertInfo->Issuer.cbData ==
               pCertInfo->Issuer.cbData ) &&
             ( pIssuer->pCertInfo->SerialNumber.cbData ==
               pCertInfo->SerialNumber.cbData ) &&
             ( memcmp(
                  pIssuer->pCertInfo->Issuer.pbData,
                  pCertInfo->Issuer.pbData,
                  pCertInfo->Issuer.cbData
                  ) == 0 ) &&
             ( memcmp(
                  pIssuer->pCertInfo->SerialNumber.pbData,
                  pCertInfo->SerialNumber.pbData,
                  pCertInfo->SerialNumber.cbData
                  ) == 0 ) )
        {
            fFoundIssuer = TRUE;
        }

        delete (LPBYTE)pCertInfo;
    }

    if ( fFoundIssuer == FALSE )
    {
        SetLastError( (DWORD) CRYPT_E_NOT_FOUND );
        return( FALSE );
    }

    apv[0] = pvContext;
    apv[1] = (LPVOID)(UINT_PTR)(cCount - 1);

    fResult = CryptGetObjectUrl(
                   URL_OID_CTL_NEXT_UPDATE,
                   apv,
                   0,
                   NULL,
                   &cbUrlArray,
                   NULL,
                   NULL,
                   NULL
                   );

    if ( fResult == TRUE )
    {
        pUrlArray = (PCRYPT_URL_ARRAY)new BYTE [ cbUrlArray ];
        if ( pUrlArray != NULL )
        {
            fResult = CryptGetObjectUrl(
                           URL_OID_CTL_NEXT_UPDATE,
                           apv,
                           0,
                           pUrlArray,
                           &cbUrlArray,
                           NULL,
                           NULL,
                           NULL
                           );
        }
        else
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        GetUrlArrayIndex(
           pUrlArray,
           pwszUrlHint,
           0,
           &PreferredUrlIndex,
           &fHintInArray
           );

        *ppUrlArray = pUrlArray;
        *pcbUrlArray = cbUrlArray;

        if ( pPreferredUrlIndex != NULL )
        {
            *pPreferredUrlIndex = PreferredUrlIndex;
        }

        if ( pfHintInArray != NULL )
        {
            *pfHintInArray = fHintInArray;
        }
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextFree
//
//  Synopsis:   free context
//
//----------------------------------------------------------------------------
VOID WINAPI
ObjectContextFree (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext
      )
{
    if ( pszContextOid == CONTEXT_OID_CERTIFICATE )
    {
        CertFreeCertificateContext( (PCCERT_CONTEXT)pvContext );
    }
    else if ( pszContextOid == CONTEXT_OID_CTL )
    {
        CertFreeCTLContext( (PCCTL_CONTEXT)pvContext );
    }
    else if ( pszContextOid == CONTEXT_OID_CRL )
    {
        CertFreeCRLContext( (PCCRL_CONTEXT)pvContext );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextVerifySignature
//
//  Synopsis:   verify the object signature
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextVerifySignature (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN PCCERT_CONTEXT pSigner
      )
{
    if ( ( pszContextOid == CONTEXT_OID_CERTIFICATE ) ||
         ( pszContextOid == CONTEXT_OID_CRL ) )
    {
#ifdef CMS_PKCS7
        DWORD dwSubjectType = 0;
#else
        DWORD  cbEncoded;
        LPBYTE pbEncoded;
#endif  // CMS_PKCS7

        if ( pszContextOid == CONTEXT_OID_CERTIFICATE )
        {
#ifdef CMS_PKCS7
            dwSubjectType = CRYPT_VERIFY_CERT_SIGN_SUBJECT_CERT;
#else
            cbEncoded = ((PCCERT_CONTEXT)pvContext)->cbCertEncoded;
            pbEncoded = ((PCCERT_CONTEXT)pvContext)->pbCertEncoded;
#endif  // CMS_PKCS7
        }
        else if ( pszContextOid == CONTEXT_OID_CRL )
        {
#ifdef CMS_PKCS7
            dwSubjectType = CRYPT_VERIFY_CERT_SIGN_SUBJECT_CRL;
#else
            cbEncoded = ((PCCRL_CONTEXT)pvContext)->cbCrlEncoded;
            pbEncoded = ((PCCRL_CONTEXT)pvContext)->pbCrlEncoded;
#endif  // CMS_PKCS7
        }

#ifdef CMS_PKCS7
        return( CryptVerifyCertificateSignatureEx(
                    NULL,                   // hCryptProv
                    X509_ASN_ENCODING,
                    dwSubjectType,
                    pvContext,
                    CRYPT_VERIFY_CERT_SIGN_ISSUER_CERT,
                    (void *) pSigner,
                    0,                      // dwFlags
                    NULL                    // pvReserved
                    ) );
#else
        return( CryptVerifyCertificateSignature(
                     NULL,
                     X509_ASN_ENCODING,
                     pbEncoded,
                     cbEncoded,
                     &pSigner->pCertInfo->SubjectPublicKeyInfo
                     ) );
#endif  // CMS_PKCS7
    }
    else if ( pszContextOid == CONTEXT_OID_CTL )
    {
#ifdef CMS_PKCS7
        CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA CtrlPara;

        memset(&CtrlPara, 0, sizeof(CtrlPara));
        CtrlPara.cbSize = sizeof(CtrlPara);
        // CtrlPara.hCryptProv =

        // Assumption: CTL only has one signer
        CtrlPara.dwSignerIndex = 0;
        CtrlPara.dwSignerType = CMSG_VERIFY_SIGNER_CERT;
        CtrlPara.pvSigner = (void *) pSigner;

        if (CryptMsgControl(
                     ((PCCTL_CONTEXT)pvContext)->hCryptMsg,
                     0,
                     CMSG_CTRL_VERIFY_SIGNATURE_EX,
                     &CtrlPara
                     ))
            return TRUE;

        // Otherwise, fall through in case it wasn't signer 0.
#endif  // CMS_PKCS7

        return( CryptMsgControl(
                     ((PCCTL_CONTEXT)pvContext)->hCryptMsg,
                     0,
                     CMSG_CTRL_VERIFY_SIGNATURE,
                     pSigner->pCertInfo
                     ) );
    }

    SetLastError( (DWORD) E_INVALIDARG );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextEnumObjectsInStore
//
//  Synopsis:   enumerate objects in a store
//
//----------------------------------------------------------------------------
LPVOID WINAPI
ObjectContextEnumObjectsInStore (
      IN HCERTSTORE hStore,
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      OUT OPTIONAL LPCSTR* ppszContextOid
      )
{
    if ( ppszContextOid )
    {
        *ppszContextOid = pszContextOid;
    }

    if ( pszContextOid == CONTEXT_OID_CERTIFICATE )
    {
        pvContext = (LPVOID)CertEnumCertificatesInStore(
                         hStore,
                         (PCCERT_CONTEXT)pvContext
                         );

        if ( pvContext != NULL )
        {
            return( pvContext );
        }

        if (ppszContextOid == NULL)
        {
            return( NULL );
        }

        *ppszContextOid = pszContextOid = CONTEXT_OID_CTL;
    }

    if ( pszContextOid == CONTEXT_OID_CTL )
    {
        pvContext = (LPVOID)CertEnumCTLsInStore(
                         hStore,
                         (PCCTL_CONTEXT)pvContext
                         );

        if ( pvContext != NULL )
        {
            return( pvContext );
        }

        if (ppszContextOid == NULL)
        {
            return( NULL );
        }

        *ppszContextOid = pszContextOid = CONTEXT_OID_CRL;
    }

    if ( pszContextOid == CONTEXT_OID_CRL )
    {
        pvContext = (LPVOID)CertEnumCRLsInStore(
                         hStore,
                         (PCCRL_CONTEXT)pvContext
                         );

        if ( pvContext != NULL )
        {
            return( pvContext );
        }
    }

    return( NULL );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextGetEncodedBits
//
//  Synopsis:   get encoded bits out of the context
//
//----------------------------------------------------------------------------
VOID WINAPI
ObjectContextGetEncodedBits (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      OUT DWORD* pcbEncoded,
      OUT LPBYTE* ppbEncoded
      )
{
    if ( pszContextOid == CONTEXT_OID_CERTIFICATE )
    {
        *pcbEncoded = ((PCCERT_CONTEXT)pvContext)->cbCertEncoded;
        *ppbEncoded = ((PCCERT_CONTEXT)pvContext)->pbCertEncoded;
    }
    else if ( pszContextOid == CONTEXT_OID_CTL )
    {
        *pcbEncoded = ((PCCTL_CONTEXT)pvContext)->cbCtlEncoded;
        *ppbEncoded = ((PCCTL_CONTEXT)pvContext)->pbCtlEncoded;
    }
    else if ( pszContextOid == CONTEXT_OID_CRL )
    {
        *pcbEncoded = ((PCCRL_CONTEXT)pvContext)->cbCrlEncoded;
        *ppbEncoded = ((PCCRL_CONTEXT)pvContext)->pbCrlEncoded;
    }
    else
    {
        assert( !"Bad context" );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextFindCorrespondingObject
//
//  Synopsis:   find corresponding object
//
//----------------------------------------------------------------------------
LPVOID WINAPI
ObjectContextFindCorrespondingObject (
      IN HCERTSTORE hStore,
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext
      )
{
    DWORD           cbHash = MAX_HASH_SIZE;
    BYTE            aHash[MAX_HASH_SIZE];
    CRYPT_HASH_BLOB HashBlob;

    if ( pszContextOid == CONTEXT_OID_CERTIFICATE )
    {
        if ( CertGetCertificateContextProperty(
                 (PCCERT_CONTEXT)pvContext,
                 CERT_HASH_PROP_ID,
                 aHash,
                 &cbHash
                 ) == FALSE )
        {
            return( NULL );
        }

        HashBlob.cbData = cbHash;
        HashBlob.pbData = aHash;

        return( (LPVOID)CertFindCertificateInStore(
                            hStore,
                            X509_ASN_ENCODING,
                            0,
                            CERT_FIND_HASH,
                            &HashBlob,
                            NULL
                            ) );
    }
    else if ( pszContextOid == CONTEXT_OID_CTL )
    {
        if ( CertGetCTLContextProperty(
                 (PCCTL_CONTEXT)pvContext,
                 CERT_SHA1_HASH_PROP_ID,
                 aHash,
                 &cbHash
                 ) == FALSE )
        {
            return( NULL );
        }

        HashBlob.cbData = cbHash;
        HashBlob.pbData = aHash;

        return( (LPVOID)CertFindCTLInStore(
                            hStore,
                            X509_ASN_ENCODING,
                            0,
                            CTL_FIND_SHA1_HASH,
                            &HashBlob,
                            NULL
                            ) );
    }
    else if ( pszContextOid == CONTEXT_OID_CRL )
    {
        DWORD         cbFindHash = MAX_HASH_SIZE;
        BYTE          aFindHash[MAX_HASH_SIZE];
        PCCRL_CONTEXT pFindCrl = NULL;
        DWORD         dwFlags = 0;

        if ( CertGetCRLContextProperty(
                 (PCCRL_CONTEXT)pvContext,
                 CERT_HASH_PROP_ID,
                 aHash,
                 &cbHash
                 ) == FALSE )
        {
            return( NULL );
        }

        while ( ( pFindCrl = CertGetCRLFromStore(
                                 hStore,
                                 NULL,
                                 pFindCrl,
                                 &dwFlags
                                 ) ) != NULL )
        {
            if ( CertGetCRLContextProperty(
                     pFindCrl,
                     CERT_HASH_PROP_ID,
                     aFindHash,
                     &cbFindHash
                     ) == TRUE )
            {
                if ( cbHash == cbFindHash )
                {
                    if ( memcmp( aHash, aFindHash, cbHash ) == 0 )
                    {
                        return( (LPVOID)pFindCrl );
                    }
                }
            }
        }
    }

    return( NULL );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextDeleteAllObjectsFromStore
//
//  Synopsis:   delete all objects from the specified store
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextDeleteAllObjectsFromStore (
      IN HCERTSTORE hStore
      )
{
    PCCERT_CONTEXT pCertContext;
    PCCRL_CONTEXT  pCrlContext;
    PCCTL_CONTEXT  pCtlContext;
    DWORD          dwFlags = 0;

    while ( pCertContext = CertEnumCertificatesInStore( hStore, NULL ) )
    {
        CertDeleteCertificateFromStore( pCertContext );
    }

    while ( pCrlContext = CertGetCRLFromStore( hStore, NULL, NULL, &dwFlags ) )
    {
        CertDeleteCRLFromStore( pCrlContext );
    }

    while ( pCtlContext = CertEnumCTLsInStore( hStore, NULL ) )
    {
        CertDeleteCTLFromStore( pCtlContext );
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   MapOidToPropertyId
//
//  Synopsis:   maps an OID to a property id
//
//----------------------------------------------------------------------------
BOOL WINAPI
MapOidToPropertyId (
   IN LPCSTR pszOid,
   OUT DWORD* pPropId
   )
{
    if ( (DWORD_PTR)pszOid <= 0xFFFF )
    {
        // NOTE: Switch on pszOid and map
        return( FALSE );
    }
    else if ( 0 == strcmp(pszOid, szOID_CROSS_CERT_DIST_POINTS) )
    {
        *pPropId = CERT_CROSS_CERT_DIST_POINTS_PROP_ID;
    }
    else if ( 0 == strcmp(pszOid, szOID_NEXT_UPDATE_LOCATION) )
    {
        *pPropId = CERT_NEXT_UPDATE_LOCATION_PROP_ID;
    }
    else
    {
        // NOTE: Compare pszOid and map
        return( FALSE );
    }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\offurl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       offurl.cpp
//
//  Contents:   Offline URL Caching
//
//  History:    19-Jan-00    philh    Created
//----------------------------------------------------------------------------
#include <global.hxx>


//
// Offline URL Cache Entry.
//
// The earliest wire retrieval is delayed according to the number of
// offline failures.
//
// For a successful wire URL retrieval, the entry is removed and deleted.
//
// Assumption: the number of offline entries is small, less than 20.
//
typedef struct _OFFLINE_URL_CACHE_ENTRY
                        OFFLINE_URL_CACHE_ENTRY, *POFFLINE_URL_CACHE_ENTRY;
struct _OFFLINE_URL_CACHE_ENTRY {
    CRYPT_DATA_BLOB             UrlBlob;
    CRYPT_DATA_BLOB             ExtraBlob;
    DWORD                       dwContextOid;
    OFFLINE_URL_TIME_INFO       OfflineUrlTimeInfo;
    POFFLINE_URL_CACHE_ENTRY    pNext;
    POFFLINE_URL_CACHE_ENTRY    pPrev;
};

CRITICAL_SECTION            OfflineUrlCacheCriticalSection;
POFFLINE_URL_CACHE_ENTRY    pOfflineUrlCacheHead;


//
// Local Functions (Forward Reference)
// 

//  Assumption: OfflineUrlCache is locked
POFFLINE_URL_CACHE_ENTRY
WINAPI
CreateAndAddOfflineUrlCacheEntry(
    IN PCRYPT_DATA_BLOB pUrlBlob,
    IN PCRYPT_DATA_BLOB pExtraBlob,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    );

//  Assumption: OfflineUrlCache is locked
VOID
WINAPI
RemoveAndFreeOfflineUrlCacheEntry(
    IN OUT POFFLINE_URL_CACHE_ENTRY pEntry
    );

//  Assumption: OfflineUrlCache is locked
POFFLINE_URL_CACHE_ENTRY
WINAPI
FindOfflineUrlCacheEntry(
    IN PCRYPT_DATA_BLOB pUrlBlob,
    IN PCRYPT_DATA_BLOB pExtraBlob,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    );



VOID
WINAPI
InitializeOfflineUrlCache()
{
    Pki_InitializeCriticalSection(&OfflineUrlCacheCriticalSection);
}

VOID
WINAPI
DeleteOfflineUrlCache()
{
    while (pOfflineUrlCacheHead)
        RemoveAndFreeOfflineUrlCacheEntry(pOfflineUrlCacheHead);

    DeleteCriticalSection(&OfflineUrlCacheCriticalSection);
}


//
// Return status:
//  +1 - Online
//   0 - Offline, current time >= earliest online time, hit the wire
//  -1 - Offline, current time < earliest onlime time
//
LONG
WINAPI
GetOfflineUrlTimeStatus(
    IN POFFLINE_URL_TIME_INFO pInfo
    )
{
    FILETIME CurrentTime;

    if (0 == pInfo->dwOfflineCnt)
    {
        return 1;
    }

    GetSystemTimeAsFileTime(&CurrentTime);
    if (0 <= CompareFileTime(&CurrentTime, &pInfo->EarliestOnlineTime))
    {
        return 0;
    }
    else
    {
        return -1;
    }
}


const DWORD rgdwOfflineUrlDeltaSeconds[] = {
    15,                 // 15 seconds
    15,                 // 15 seconds
    60,                 // 1 minute
    60 * 5,             // 5 minutes
    60 * 10,            // 10 minutes
    60 * 30,            // 30 minutes
};

#define OFFLINE_URL_DELTA_SECONDS_CNT \
    (sizeof(rgdwOfflineUrlDeltaSeconds) / \
        sizeof(rgdwOfflineUrlDeltaSeconds[0]))


VOID
WINAPI
SetOfflineUrlTime(
    IN OUT POFFLINE_URL_TIME_INFO pInfo
    )
{
    DWORD dwOfflineCnt;
    FILETIME CurrentTime;

    dwOfflineCnt = ++pInfo->dwOfflineCnt;

    if (OFFLINE_URL_DELTA_SECONDS_CNT < dwOfflineCnt)
    {
        dwOfflineCnt = OFFLINE_URL_DELTA_SECONDS_CNT;
    }

    GetSystemTimeAsFileTime( &CurrentTime );
    I_CryptIncrementFileTimeBySeconds(
        &CurrentTime,
        rgdwOfflineUrlDeltaSeconds[dwOfflineCnt - 1],
        &pInfo->EarliestOnlineTime
        );
}

VOID
WINAPI
SetOnlineUrlTime(
    IN OUT POFFLINE_URL_TIME_INFO pInfo
    )
{
    pInfo->dwOfflineCnt = 0;
}




//
// Return status:
//  +1 - Online
//   0 - Offline, current time >= earliest online time, hit the wire
//  -1 - Offline, current time < earliest onlime time
//
LONG
WINAPI
GetOriginUrlStatusW(
    IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
    IN LPCWSTR pwszUrl,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    )
{
    LONG lStatus;
    POFFLINE_URL_CACHE_ENTRY pEntry;
    CRYPT_DATA_BLOB UrlBlob;
    CRYPT_DATA_BLOB ExtraBlob;

    UrlBlob.pbData = (BYTE *) pwszUrl;
    UrlBlob.cbData = wcslen(pwszUrl) * sizeof(WCHAR);
    ExtraBlob.pbData = OriginIdentifier;
    ExtraBlob.cbData = MD5DIGESTLEN;

    EnterCriticalSection(&OfflineUrlCacheCriticalSection);

    pEntry = FindOfflineUrlCacheEntry(
        &UrlBlob,
        &ExtraBlob,
        pszContextOid,
        dwRetrievalFlags
        );
    if (pEntry)
        lStatus = GetOfflineUrlTimeStatus(&pEntry->OfflineUrlTimeInfo);
    else
        lStatus = 1;

    LeaveCriticalSection(&OfflineUrlCacheCriticalSection);

    return lStatus;
}

VOID
WINAPI
SetOnlineOriginUrlW(
    IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
    IN LPCWSTR pwszUrl,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    )
{
    POFFLINE_URL_CACHE_ENTRY pEntry;
    CRYPT_DATA_BLOB UrlBlob;
    CRYPT_DATA_BLOB ExtraBlob;

    UrlBlob.pbData = (BYTE *) pwszUrl;
    UrlBlob.cbData = wcslen(pwszUrl) * sizeof(WCHAR);
    ExtraBlob.pbData = OriginIdentifier;
    ExtraBlob.cbData = MD5DIGESTLEN;

    EnterCriticalSection(&OfflineUrlCacheCriticalSection);

    pEntry = FindOfflineUrlCacheEntry(
        &UrlBlob,
        &ExtraBlob,
        pszContextOid,
        dwRetrievalFlags
        );
    if (pEntry)
        RemoveAndFreeOfflineUrlCacheEntry(pEntry);

    LeaveCriticalSection(&OfflineUrlCacheCriticalSection);
}

VOID
WINAPI
SetOfflineOriginUrlW(
    IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
    IN LPCWSTR pwszUrl,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    )
{
    POFFLINE_URL_CACHE_ENTRY pEntry;
    CRYPT_DATA_BLOB UrlBlob;
    CRYPT_DATA_BLOB ExtraBlob;

    UrlBlob.pbData = (BYTE *) pwszUrl;
    UrlBlob.cbData = wcslen(pwszUrl) * sizeof(WCHAR);
    ExtraBlob.pbData = OriginIdentifier;
    ExtraBlob.cbData = MD5DIGESTLEN;

    EnterCriticalSection(&OfflineUrlCacheCriticalSection);

    pEntry = FindOfflineUrlCacheEntry(
        &UrlBlob,
        &ExtraBlob,
        pszContextOid,
        dwRetrievalFlags
        );

    if (NULL == pEntry)
        pEntry = CreateAndAddOfflineUrlCacheEntry( 
            &UrlBlob,
            &ExtraBlob,
            pszContextOid,
            dwRetrievalFlags
            );

    if (pEntry)
        SetOfflineUrlTime(&pEntry->OfflineUrlTimeInfo);

    LeaveCriticalSection(&OfflineUrlCacheCriticalSection);
}


//
// Return status:
//  +1 - Online
//   0 - Offline, current time >= earliest online time, hit the wire
//  -1 - Offline, current time < earliest onlime time
//
LONG
WINAPI
GetUrlStatusA(
    IN LPCSTR pszUrl,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    )
{
    LONG lStatus;
    POFFLINE_URL_CACHE_ENTRY pEntry;
    CRYPT_DATA_BLOB UrlBlob;
    CRYPT_DATA_BLOB ExtraBlob;

    UrlBlob.pbData = (BYTE *) pszUrl;
    UrlBlob.cbData = strlen(pszUrl);
    ExtraBlob.pbData = NULL;
    ExtraBlob.cbData = 0;

    EnterCriticalSection(&OfflineUrlCacheCriticalSection);

    pEntry = FindOfflineUrlCacheEntry(
        &UrlBlob,
        &ExtraBlob,
        pszContextOid,
        dwRetrievalFlags
        );
    if (pEntry)
        lStatus = GetOfflineUrlTimeStatus(&pEntry->OfflineUrlTimeInfo);
    else
        lStatus = 1;

    LeaveCriticalSection(&OfflineUrlCacheCriticalSection);

    return lStatus;
}

VOID
WINAPI
SetOnlineUrlA(
    IN LPCSTR pszUrl,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    )
{
    POFFLINE_URL_CACHE_ENTRY pEntry;
    CRYPT_DATA_BLOB UrlBlob;
    CRYPT_DATA_BLOB ExtraBlob;

    UrlBlob.pbData = (BYTE *) pszUrl;
    UrlBlob.cbData = strlen(pszUrl);
    ExtraBlob.pbData = NULL;
    ExtraBlob.cbData = 0;

    EnterCriticalSection(&OfflineUrlCacheCriticalSection);

    pEntry = FindOfflineUrlCacheEntry(
        &UrlBlob,
        &ExtraBlob,
        pszContextOid,
        dwRetrievalFlags
        );
    if (pEntry)
        RemoveAndFreeOfflineUrlCacheEntry(pEntry);

    LeaveCriticalSection(&OfflineUrlCacheCriticalSection);
}

VOID
WINAPI
SetOfflineUrlA(
    IN LPCSTR pszUrl,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    )
{
    POFFLINE_URL_CACHE_ENTRY pEntry;
    CRYPT_DATA_BLOB UrlBlob;
    CRYPT_DATA_BLOB ExtraBlob;

    UrlBlob.pbData = (BYTE *) pszUrl;
    UrlBlob.cbData = strlen(pszUrl);
    ExtraBlob.pbData = NULL;
    ExtraBlob.cbData = 0;

    EnterCriticalSection(&OfflineUrlCacheCriticalSection);

    pEntry = FindOfflineUrlCacheEntry(
        &UrlBlob,
        &ExtraBlob,
        pszContextOid,
        dwRetrievalFlags
        );

    if (NULL == pEntry)
        pEntry = CreateAndAddOfflineUrlCacheEntry( 
            &UrlBlob,
            &ExtraBlob,
            pszContextOid,
            dwRetrievalFlags
            );

    if (pEntry)
        SetOfflineUrlTime(&pEntry->OfflineUrlTimeInfo);

    LeaveCriticalSection(&OfflineUrlCacheCriticalSection);
}

inline
DWORD
GetOfflineUrlCacheContextOid(
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    )
{
    DWORD dwContextOid;

    if (0xFFFF >= (DWORD) ((DWORD_PTR) pszContextOid))
        dwContextOid = (DWORD) ((DWORD_PTR) pszContextOid);
    else
        dwContextOid = 0x10000;

    if (dwRetrievalFlags & CRYPT_WIRE_ONLY_RETRIEVAL)
        dwContextOid |= 0x20000;

    return dwContextOid;
}

//  Assumption: OfflineUrlCache is locked
POFFLINE_URL_CACHE_ENTRY
WINAPI
CreateAndAddOfflineUrlCacheEntry(
    IN PCRYPT_DATA_BLOB pUrlBlob,
    IN PCRYPT_DATA_BLOB pExtraBlob,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    )
{
    POFFLINE_URL_CACHE_ENTRY pEntry;
    DWORD cbEntry;
    BYTE *pb;

    cbEntry = sizeof(OFFLINE_URL_CACHE_ENTRY) +
        pUrlBlob->cbData + pExtraBlob->cbData;

    pEntry = (POFFLINE_URL_CACHE_ENTRY) new BYTE [cbEntry];

    if (pEntry == NULL)
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( NULL );
    }

    memset( pEntry, 0, sizeof( OFFLINE_URL_CACHE_ENTRY ) );
    pb = (BYTE *) &pEntry[1];

    if (pUrlBlob->cbData) {
        pEntry->UrlBlob.pbData = pb;
        pEntry->UrlBlob.cbData = pUrlBlob->cbData;
        memcpy(pb, pUrlBlob->pbData, pUrlBlob->cbData);
        pb += pUrlBlob->cbData;
    }

    if (pExtraBlob->cbData) {
        pEntry->ExtraBlob.pbData = pb;
        pEntry->ExtraBlob.cbData = pExtraBlob->cbData;
        memcpy(pb, pExtraBlob->pbData, pExtraBlob->cbData);
    }

    pEntry->dwContextOid =
        GetOfflineUrlCacheContextOid(pszContextOid, dwRetrievalFlags);

    if (pOfflineUrlCacheHead) {
        assert(NULL == pOfflineUrlCacheHead->pPrev);
        pOfflineUrlCacheHead->pPrev = pEntry;
        pEntry->pNext = pOfflineUrlCacheHead;
    }
    // else
    //  pEntry->pNext = NULL;        // already zeroed above

    // pEntry->pPrev = NULL;        // already zeroed above
    pOfflineUrlCacheHead = pEntry;

    return pEntry;
}


//  Assumption: OfflineUrlCache is locked
VOID
WINAPI
RemoveAndFreeOfflineUrlCacheEntry(
    IN OUT POFFLINE_URL_CACHE_ENTRY pEntry
    )
{
    if (pEntry->pNext)
    {
        pEntry->pNext->pPrev = pEntry->pPrev;
    }

    if (pEntry->pPrev)
    {
        pEntry->pPrev->pNext = pEntry->pNext;
    }
    else
    {
        assert(pOfflineUrlCacheHead == pEntry);
        pOfflineUrlCacheHead = pEntry->pNext;
    }

    delete (LPBYTE) pEntry;
}

//  Assumption: OfflineUrlCache is locked
POFFLINE_URL_CACHE_ENTRY
WINAPI
FindOfflineUrlCacheEntry(
    IN PCRYPT_DATA_BLOB pUrlBlob,
    IN PCRYPT_DATA_BLOB pExtraBlob,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    )
{
    DWORD cbUrl = pUrlBlob->cbData;
    BYTE *pbUrl = pUrlBlob->pbData;
    DWORD cbExtra = pExtraBlob->cbData;
    BYTE *pbExtra = pExtraBlob->pbData;
    DWORD dwContextOid;
    POFFLINE_URL_CACHE_ENTRY pEntry;

    dwContextOid =
        GetOfflineUrlCacheContextOid(pszContextOid, dwRetrievalFlags);

    for (pEntry = pOfflineUrlCacheHead; pEntry; pEntry = pEntry->pNext)
    {
        if (pEntry->dwContextOid == dwContextOid
                        &&
            pEntry->UrlBlob.cbData == cbUrl
                        &&
            pEntry->ExtraBlob.cbData == cbExtra
                        &&
            (0 == cbExtra || 0 == memcmp(
                pEntry->ExtraBlob.pbData, pbExtra, cbExtra))
                        &&
            (0 == cbUrl || 0 == memcmp(
                pEntry->UrlBlob.pbData, pbUrl, cbUrl))
                        )
        {
            return pEntry;
        }
    }

    return ( NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\ldapstor.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ldapstor.h
//
//  Contents:   LDAP Certificate Store Provider definitions
//
//  History:    16-Oct-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__LDAPSTOR_H__)
#define __LDAPSTOR_H__

#include <ldapsp.h>
#define SECURITY_WIN32
#include <security.h>

//
// Store provider open store function name
//

#define LDAP_OPEN_STORE_PROV_FUNC "LdapProvOpenStore"

//
// BERVAL array definitions
//

#define MIN_BERVAL  10
#define GROW_BERVAL 50

//
// User DS Store URL format
//

#define USER_DS_STORE_URL_FORMAT "ldap:///%s?"

//
// Store timeout (15 seconds)
//

#define LDAP_STORE_TIMEOUT 15000

//
// GetUserNameExA function pointer prototype
//

typedef BOOLEAN (SEC_ENTRY *PFN_GETUSERNAMEEXA) (
                                EXTENDED_NAME_FORMAT NameFormat,
                                LPSTR lpNameBuffer,
                                PULONG nSize
                                );

//
// CLdapStore.  This class implements all callbacks for the Ldap Store
// provider.  A pointer to an instance of this class is used as the hStoreProv
// parameter for the callback functions implemented
//

class CLdapStore
{
public:

    //
    // Construction
    //

    CLdapStore (
             OUT BOOL& rfResult
             );
    ~CLdapStore ();

    //
    // Store functions
    //

    BOOL OpenStore (
             LPCSTR pszStoreProv,
             DWORD dwMsgAndCertEncodingType,
             HCRYPTPROV hCryptProv,
             DWORD dwFlags,
             const void* pvPara,
             HCERTSTORE hCertStore,
             PCERT_STORE_PROV_INFO pStoreProvInfo
             );

    VOID CloseStore (DWORD dwFlags);

    BOOL DeleteCert (PCCERT_CONTEXT pCertContext, DWORD dwFlags);

    BOOL DeleteCrl (PCCRL_CONTEXT pCrlContext, DWORD dwFlags);

    BOOL DeleteCtl (PCCTL_CONTEXT pCtlContext, DWORD dwFlags);

    BOOL SetCertProperty (
            PCCERT_CONTEXT pCertContext,
            DWORD dwPropId,
            DWORD dwFlags,
            const void* pvPara
            );

    BOOL SetCrlProperty (
            PCCRL_CONTEXT pCertContext,
            DWORD dwPropId,
            DWORD dwFlags,
            const void* pvPara
            );

    BOOL SetCtlProperty (
            PCCTL_CONTEXT pCertContext,
            DWORD dwPropId,
            DWORD dwFlags,
            const void* pvPara
            );

    BOOL WriteCert (PCCERT_CONTEXT pCertContext, DWORD dwFlags);

    BOOL WriteCrl (PCCRL_CONTEXT pCertContext, DWORD dwFlags);

    BOOL WriteCtl (PCCTL_CONTEXT pCertContext, DWORD dwFlags);

    BOOL StoreControl (DWORD dwFlags, DWORD dwCtrlType, LPVOID pvCtrlPara);

    BOOL Commit (DWORD dwFlags);

    BOOL Resync ();

private:

    //
    // Object lock
    //

    CRITICAL_SECTION    m_StoreLock;

    //
    // LDAP URL
    //

    LDAP_URL_COMPONENTS m_UrlComponents;

    //
    // LDAP binding
    //

    LDAP*               m_pBinding;

    //
    // Cache store reference
    //

    HCERTSTORE          m_hCacheStore;

    //
    // Open Store flags
    //

    DWORD               m_dwOpenFlags;

    //
    // Dirty flag
    //

    BOOL                m_fDirty;

    //
    // Private methods
    //

    BOOL FillCacheStore (BOOL fClearCache);

    BOOL InternalCommit (DWORD dwFlags);

    BOOL WriteCheckSetDirtyWithLock (
              LPCSTR pszContextOid,
              LPVOID pvContext,
              DWORD dwFlags
              );
};

//
// Ldap Store Provider functions
//

BOOL WINAPI LdapProvOpenStore (
                IN LPCSTR pszStoreProv,
                IN DWORD dwMsgAndCertEncodingType,
                IN HCRYPTPROV hCryptProv,
                IN DWORD dwFlags,
                IN const void* pvPara,
                IN HCERTSTORE hCertStore,
                IN OUT PCERT_STORE_PROV_INFO pStoreProvInfo
                );

void WINAPI LdapProvCloseStore (
                IN HCERTSTOREPROV hStoreProv,
                IN DWORD dwFlags
                );

BOOL WINAPI LdapProvDeleteCert (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCERT_CONTEXT pCertContext,
                IN DWORD dwFlags
                );

BOOL WINAPI LdapProvDeleteCrl (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCRL_CONTEXT pCrlContext,
                IN DWORD dwFlags
                );

BOOL WINAPI LdapProvDeleteCtl (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCTL_CONTEXT pCtlContext,
                IN DWORD dwFlags
                );

BOOL WINAPI LdapProvSetCertProperty (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCERT_CONTEXT pCertContext,
                IN DWORD dwPropId,
                IN DWORD dwFlags,
                IN const void* pvData
                );

BOOL WINAPI LdapProvSetCrlProperty (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCRL_CONTEXT pCrlContext,
                IN DWORD dwPropId,
                IN DWORD dwFlags,
                IN const void* pvData
                );

BOOL WINAPI LdapProvSetCtlProperty (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCTL_CONTEXT pCtlContext,
                IN DWORD dwPropId,
                IN DWORD dwFlags,
                IN const void* pvData
                );

BOOL WINAPI LdapProvWriteCert (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCERT_CONTEXT pCertContext,
                IN DWORD dwFlags
                );

BOOL WINAPI LdapProvWriteCrl (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCRL_CONTEXT pCrlContext,
                IN DWORD dwFlags
                );

BOOL WINAPI LdapProvWriteCtl (
                IN HCERTSTOREPROV hStoreProv,
                IN PCCTL_CONTEXT pCtlContext,
                IN DWORD dwFlags
                );

BOOL WINAPI LdapProvStoreControl (
                IN HCERTSTOREPROV hStoreProv,
                IN DWORD dwFlags,
                IN DWORD dwCtrlType,
                IN LPVOID pvCtrlPara
                );

//
// Ldap Store Provider Function table
//

static void* const rgpvLdapProvFunc[] = {

    // CERT_STORE_PROV_CLOSE_FUNC              0
    LdapProvCloseStore,
    // CERT_STORE_PROV_READ_CERT_FUNC          1
    NULL,
    // CERT_STORE_PROV_WRITE_CERT_FUNC         2
    LdapProvWriteCert,
    // CERT_STORE_PROV_DELETE_CERT_FUNC        3
    LdapProvDeleteCert,
    // CERT_STORE_PROV_SET_CERT_PROPERTY_FUNC  4
    LdapProvSetCertProperty,
    // CERT_STORE_PROV_READ_CRL_FUNC           5
    NULL,
    // CERT_STORE_PROV_WRITE_CRL_FUNC          6
    LdapProvWriteCrl,
    // CERT_STORE_PROV_DELETE_CRL_FUNC         7
    LdapProvDeleteCrl,
    // CERT_STORE_PROV_SET_CRL_PROPERTY_FUNC   8
    LdapProvSetCrlProperty,
    // CERT_STORE_PROV_READ_CTL_FUNC           9
    NULL,
    // CERT_STORE_PROV_WRITE_CTL_FUNC          10
    LdapProvWriteCtl,
    // CERT_STORE_PROV_DELETE_CTL_FUNC         11
    LdapProvDeleteCtl,
    // CERT_STORE_PROV_SET_CTL_PROPERTY_FUNC   12
    LdapProvSetCtlProperty,
    // CERT_STORE_PROV_CONTROL_FUNC            13
    LdapProvStoreControl
};

#define LDAP_PROV_FUNC_COUNT (sizeof(rgpvLdapProvFunc) / \
                              sizeof(rgpvLdapProvFunc[0]))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\nsrevoke.cpp ===
//+-------------------------------------------------------------------------
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:	    nsrevoke.cpp
//
//  Contents:   Netscape online HTTP GET version of CertDllVerifyRevocation.
//
//              Checks if the certificate has either the
//              szOID_NETSCAPE_REVOCATION_URL or
//              szOID_NETSCAPE_CA_REVOCATION_URL extension.
//              If either is present, converts the certicate's serial
//              number to ascii hex, appends and does an HTTP GET. The
//              revocation server returns a single ascii digit: '1' if
//              the certificate is not currently valid, and '0' if it is
//              currently valid.
//
//              The certificate may also contain a szOID_NETSCAPE_BASE_URL
//              extension which is inserted before either of the above
//              URL extensions.
//
//              The URL extensions are encoded as IA5 strings.
//
//  Functions:  NSRevokeDllMain
//              NetscapeCertDllVerifyRevocation
//
//  History:	01-Apr-97	philh   created
//--------------------------------------------------------------------------
#include "global.hxx"
#include <dbgdef.h>

// TLS pointer is set to (void*) 1 if already doing a VerifyRevocation
HCRYPTTLS hTlsNSRevokeRecursion;

//+---------------------------------------------------------------------------
//
//  Function:   DemandLoadDllMain
//
//  Synopsis:   DLL Main like initialization of on demand loading
//
//----------------------------------------------------------------------------
BOOL WINAPI NSRevokeDllMain (
                HMODULE hModule,
                ULONG ulReason,
                LPVOID pvReserved
                )
{
    BOOL fRet = TRUE;

    switch ( ulReason )
    {
    case DLL_PROCESS_ATTACH:
        if (NULL == (hTlsNSRevokeRecursion = I_CryptAllocTls()))
            fRet = FALSE;
        break;
    case DLL_THREAD_ATTACH:
        // Note, no memory is allocated for this TLS.
        I_CryptDetachTls(hTlsNSRevokeRecursion);
        break;
    case DLL_PROCESS_DETACH:
        // Note, no memory is allocated for this TLS.
        I_CryptFreeTls(hTlsNSRevokeRecursion, NULL);
        break;
    case DLL_THREAD_DETACH:
        break;
    }

    return( fRet );
}
//+-------------------------------------------------------------------------
//  Allocation and free functions
//--------------------------------------------------------------------------
static void *NSAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}
static void NSFree(
    IN void *pv
    )
{
    if (pv)
        free(pv);
}

static void *NSAllocAndDecodeObject(
    IN DWORD dwCertEncodingType,
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    BOOL fResult;
    DWORD cbStructInfo;
    void *pvStructInfo;

    fResult = CryptDecodeObject(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG,
            NULL,                   // pvStructInfo
            &cbStructInfo
            );
    if (!fResult || cbStructInfo == 0)
        goto DecodeError;
    if (NULL == (pvStructInfo = NSAlloc(cbStructInfo)))
        goto OutOfMemory;
    if (!CryptDecodeObject(
            dwCertEncodingType,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG,
            pvStructInfo,
            &cbStructInfo
            )) {
        NSFree(pvStructInfo);
        goto DecodeError;
    }

CommonReturn:
    return pvStructInfo;
ErrorReturn:
    pvStructInfo = NULL;
    goto CommonReturn;
TRACE_ERROR(DecodeError)
TRACE_ERROR(OutOfMemory)
}

static void ReverseAndPutAsciiHex(
    IN PCERT_RDN_VALUE_BLOB pValue,
    OUT LPSTR psz
    )
{
    DWORD cb = pValue->cbData;
    BYTE *pb = pValue->pbData + cb - 1;

    // Remove leading 00's
    for ( ; cb > 1 && 0 == *pb; cb--, pb--)
        ;

    for ( ; cb > 0; cb--, pb--) {
        int b;
        b = (*pb >> 4) & 0x0F;
        *psz++ = (CHAR)( (b <= 9) ? b + '0' : (b - 10) + 'a' );
        b = *pb & 0x0F;
        *psz++ = (CHAR)( (b <= 9) ? b + '0' : (b - 10) + 'a' );
    }
}

static LPSTR GetAndFormatUrl(
    IN PCCERT_CONTEXT pCert
    )
{
    PCERT_EXTENSION pUrlExt;        // not allocated
    PCERT_NAME_VALUE pRevUrlName = NULL;
    PCERT_NAME_VALUE pBaseUrlName = NULL;

    DWORD cchBaseUrl;
    LPSTR pszBaseUrl;       // not allocated
    DWORD cchRevUrl;
    LPSTR pszRevUrl;        // not allocated
    DWORD cchSerialNumber;
    DWORD cchUrl;
    LPSTR pszUrl = NULL;
    LPSTR pszCanonicalizeUrl = NULL;
    LPSTR psz;
    DWORD cb;
    char rgch[1];

    // Check if the certificate has either a szOID_NETSCAPE_REVOCATION_URL or
    // szOID_NETSCAPE_CA_REVOCATION_URL extension.
    pUrlExt = CertFindExtension(
            szOID_NETSCAPE_REVOCATION_URL,
            pCert->pCertInfo->cExtension,
            pCert->pCertInfo->rgExtension
            );
    if (pUrlExt == NULL) {
        pUrlExt = CertFindExtension(
                szOID_NETSCAPE_CA_REVOCATION_URL,
                pCert->pCertInfo->cExtension,
                pCert->pCertInfo->rgExtension
                );
        if (pUrlExt == NULL)
            goto NoURLExtError;
    }

    // Decode the extension as an IA5 string
    if (NULL == (pRevUrlName = (PCERT_NAME_VALUE) NSAllocAndDecodeObject(
            pCert->dwCertEncodingType,
            X509_ANY_STRING,
            pUrlExt->Value.pbData,
            pUrlExt->Value.cbData)))
        goto DecodeUrlError;

    cchRevUrl = pRevUrlName->Value.cbData;
    pszRevUrl = (LPSTR) pRevUrlName->Value.pbData;
    if (0 != cchRevUrl && '\0' == pszRevUrl[cchRevUrl - 1])
        cchRevUrl--;
    if (CERT_RDN_IA5_STRING != pRevUrlName->dwValueType || 0 == cchRevUrl)
        goto BadUrlExtError;

    // Check if the certificate has a szOID_NETSCAPE_BASE_URL extension.
    pUrlExt = CertFindExtension(
            szOID_NETSCAPE_BASE_URL,
            pCert->pCertInfo->cExtension,
            pCert->pCertInfo->rgExtension
            );
    if (pUrlExt) {
        // Decode the extension as an IA5 string
        if (NULL == (pBaseUrlName = (PCERT_NAME_VALUE) NSAllocAndDecodeObject(
                pCert->dwCertEncodingType,
                X509_ANY_STRING,
                pUrlExt->Value.pbData,
                pUrlExt->Value.cbData)))
            goto DecodeUrlError;

        cchBaseUrl = pBaseUrlName->Value.cbData;
        pszBaseUrl = (LPSTR) pBaseUrlName->Value.pbData;
        if (0 != cchBaseUrl && '\0' == pszBaseUrl[cchBaseUrl - 1])
            cchBaseUrl--;
        if (CERT_RDN_IA5_STRING != pBaseUrlName->dwValueType)
            goto BadUrlExtError;
    } else {
        cchBaseUrl = 0;
        pszBaseUrl = NULL;
    }

    cchSerialNumber = pCert->pCertInfo->SerialNumber.cbData * 2;
    if (0 == cchSerialNumber)
        goto BadSerialNumberError;

    cchUrl = cchBaseUrl + cchRevUrl + cchSerialNumber + 1;
    if (NULL == (pszUrl = (LPSTR) NSAlloc(cchUrl)))
        goto OutOfMemory;
    psz = pszUrl;
    if (cchBaseUrl) {
        memcpy(psz, pszBaseUrl, cchBaseUrl);
        psz += cchBaseUrl;
    }
    memcpy(psz, pszRevUrl, cchRevUrl);
    psz += cchRevUrl;
    // Note serial number is decoded as little endian
    ReverseAndPutAsciiHex(&pCert->pCertInfo->SerialNumber, psz);
    psz += cchSerialNumber;
    *psz = '\0';

    cb = 1;

    __try
    {
        if (!InternetCanonicalizeUrlA(
                pszUrl,
                rgch,                   // (must be non-null) pszCanonicalizeUrl
                &cb,                    // (must be non-zero)
                ICU_BROWSER_MODE        // dwFlags
                )) {
            if (ERROR_INSUFFICIENT_BUFFER != GetLastError())
                goto CanonicalizeUrlError;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError( GetExceptionCode() );
        goto CanonicalizeUrlError;
    }

    cb++;
    if (NULL == (pszCanonicalizeUrl = (LPSTR) NSAlloc(cb)))
        goto OutOfMemory;
    if (!InternetCanonicalizeUrlA(
            pszUrl,
            pszCanonicalizeUrl,
            &cb,
            ICU_BROWSER_MODE        // dwFlags
            ))
        goto CanonicalizeUrlError;

CommonReturn:
    NSFree(pRevUrlName);
    NSFree(pBaseUrlName);
    NSFree(pszUrl);
    return pszCanonicalizeUrl;
ErrorReturn:
    NSFree(pszCanonicalizeUrl);
    pszCanonicalizeUrl = NULL;
    goto CommonReturn;

SET_ERROR(NoURLExtError, CRYPT_E_NO_REVOCATION_CHECK)
TRACE_ERROR(DecodeUrlError)
SET_ERROR(BadUrlExtError, CRYPT_E_NO_REVOCATION_CHECK)
SET_ERROR(BadSerialNumberError, CRYPT_E_NO_REVOCATION_CHECK)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(CanonicalizeUrlError)
}

static DWORD GetAndCheckResponse(
    IN HINTERNET hInternetFile
    )
{
    DWORD dwError;
    DWORD dwStatus;
    DWORD cbBuf;
#define MAX_RESPONSE_LEN    4096
    BYTE rgbBuf[MAX_RESPONSE_LEN];
    DWORD cbTotal;

    // Check that the server is online and is responding to our revocation
    // request
    dwStatus = 0;
    cbBuf = sizeof(dwStatus);
    if (!HttpQueryInfoA(
            hInternetFile,
            HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
            &dwStatus,
            &cbBuf,
            NULL                // lpdwIndex
            ))
        goto HttpQueryInfoError;
    if (HTTP_STATUS_OK != dwStatus)
        goto BadHttpStatusError;

    // Get the type of the response
    cbBuf = MAX_RESPONSE_LEN;
    if (!HttpQueryInfoA(
            hInternetFile,
            HTTP_QUERY_CONTENT_TYPE,
            rgbBuf,
            &cbBuf,
            NULL                // lpdwIndex
            ))
        goto HttpQueryInfoError;
    rgbBuf[cbBuf] = '\0';

    // We are expecting the following type:
    //  "application/x-netscape-revocation". Since this type isn't
    //  mandatory, don't make an explicit check of.

    // Loop until no more bytes available or filled the buffer. Note, only
    // expecting a single byte
    cbTotal = 0;
    while (cbTotal < MAX_RESPONSE_LEN) {
        DWORD cbRead = 0;

        if (!InternetReadFile(
                hInternetFile,
                &rgbBuf[cbTotal],
                MAX_RESPONSE_LEN - cbTotal,
                &cbRead))
            goto InternetReadError;
        if (0 == cbRead)
            break;

        cbTotal += cbRead;
    }

    if (cbTotal == 0)
        dwError = (DWORD) CRYPT_E_NO_REVOCATION_CHECK;
    else {
        // Only expecting a single byte. Again, this isn't mandatory. Will
        // only check the first byte.

        char ch = (char) rgbBuf[0];
        if ('1' == ch)
            dwError = (DWORD) CRYPT_E_REVOKED;
        else if ('0' == ch)
            dwError = 0;            // successfully checked as not revoked
        else
            dwError = (DWORD) CRYPT_E_NO_REVOCATION_CHECK;
    }

CommonReturn:
    return dwError;
ErrorReturn:
    dwError = GetLastError();
    if (0 == dwError)
        dwError = (DWORD) E_UNEXPECTED;
    goto CommonReturn;
SET_ERROR(BadHttpStatusError, CRYPT_E_REVOCATION_OFFLINE)
TRACE_ERROR(HttpQueryInfoError)
TRACE_ERROR(InternetReadError)
}

//+-------------------------------------------------------------------------
//  CertDllVerifyRevocation using Netscape's Revocation URL extensions
//--------------------------------------------------------------------------
BOOL
WINAPI
NetscapeCertDllVerifyRevocation(
    IN DWORD dwEncodingType,
    IN DWORD dwRevType,
    IN DWORD cContext,
    IN PVOID rgpvContext[],
    IN DWORD dwFlags,
    IN PVOID pvReserved,
    IN OUT PCERT_REVOCATION_STATUS pRevStatus
    )
{
    BOOL fResult = FALSE;
    DWORD dwIndex = 0;
    DWORD dwError = (DWORD) CRYPT_E_NO_REVOCATION_CHECK;
    PCCERT_CONTEXT pCert;           // not allocated
    LPSTR pszUrl = NULL;
    HINTERNET hInternetSession = NULL;
    HINTERNET hInternetFile = NULL;
    BOOL fNetscapeUrlRetrieval = FALSE;

    if ( dwFlags & CERT_VERIFY_CACHE_ONLY_BASED_REVOCATION ) {
        goto NoRevocationCheckForCacheOnlyError;
    }

    if (cContext == 0)
        goto NoContextError;
    if (GET_CERT_ENCODING_TYPE(dwEncodingType) != CRYPT_ASN_ENCODING)
        goto NoRevocationCheckForEncodingTypeError;
    if (dwRevType != CERT_CONTEXT_REVOCATION_TYPE)
        goto NoRevocationCheckForRevTypeError;

    pCert = (PCCERT_CONTEXT) rgpvContext[0];

    // Check if the certificate has a Netscape URL extension. If it
    // does get and format the HTTP GET URL.
    if (NULL == (pszUrl = GetAndFormatUrl(pCert)))
        goto NoUrlError;

    // Check if we are already doing a Netscape URL retrieval for this thread
    if (NULL != I_CryptGetTls(hTlsNSRevokeRecursion))
        goto NetscapeUrlRecursionError;

    if (!I_CryptSetTls(hTlsNSRevokeRecursion, (void *) 1))
        goto SetNetscapeTlsError;
    fNetscapeUrlRetrieval = TRUE;

    if (NULL == (hInternetSession = InternetOpenA(
            "Netscape Revocation Agent",    // lpszAgent
            INTERNET_OPEN_TYPE_PRECONFIG,   // dwAccessType
            NULL,                           // lpszProxy
            NULL,                           // lpszProxyBypass
            0                               // dwFlags
            )))
        goto InternetOpenError;

    // The following does the HTTP GET
    if (NULL == (hInternetFile = InternetOpenUrlA(
            hInternetSession,
            pszUrl,
            "Accept: */*\r\n",  // lpszHeaders
            (DWORD) -1L,        // dwHeadersLength
            INTERNET_FLAG_RELOAD | INTERNET_FLAG_IGNORE_CERT_CN_INVALID,
            0                   // dwContext
            )))
        goto InternetOpenUrlError;

    dwError = GetAndCheckResponse(hInternetFile);
    if (0 == dwError) {
        // Successfully checked that the certificate wasn't revoked
        if (1 < cContext) {
            dwIndex = 1;
            dwError = (DWORD) CRYPT_E_NO_REVOCATION_CHECK;
        } else
            fResult = TRUE;
    }

    if (pRevStatus->cbSize >=
            (offsetof(CERT_REVOCATION_STATUS, dwFreshnessTime) +
                sizeof(pRevStatus->dwFreshnessTime))) {
        if (0 == dwError || CRYPT_E_REVOKED == dwError) {
            pRevStatus->fHasFreshnessTime = TRUE;
            pRevStatus->dwFreshnessTime = 0;
        }
    }

CommonReturn:
    if (fNetscapeUrlRetrieval)
        I_CryptSetTls(hTlsNSRevokeRecursion, NULL);
    if (hInternetFile)
        InternetCloseHandle(hInternetFile);
    if (hInternetSession)
        InternetCloseHandle(hInternetSession);

    pRevStatus->dwIndex = dwIndex;
    pRevStatus->dwError = dwError;
    SetLastError(dwError);
    return fResult;
ErrorReturn:
    dwError = GetLastError();
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(NoContextError, E_INVALIDARG)
SET_ERROR(NoRevocationCheckForCacheOnlyError, CRYPT_E_NO_REVOCATION_CHECK)
SET_ERROR(NoRevocationCheckForEncodingTypeError, CRYPT_E_NO_REVOCATION_CHECK)
SET_ERROR(NoRevocationCheckForRevTypeError, CRYPT_E_NO_REVOCATION_CHECK)
SET_ERROR(NetscapeUrlRecursionError, CRYPT_E_NO_REVOCATION_CHECK)

TRACE_ERROR(NoUrlError)
TRACE_ERROR(SetNetscapeTlsError)
TRACE_ERROR(InternetOpenError)
TRACE_ERROR(InternetOpenUrlError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\octxutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       octxutil.h
//
//  Contents:   General Object Context Utility definitions and prototypes
//
//  History:    29-Sep-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__OCTXUTIL_H__)
#define __OCTXUTIL_H__

#include <origin.h>

#define MAX_HASH_SIZE 20

BOOL WINAPI
ObjectContextGetOriginIdentifier (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN PCCERT_CONTEXT pIssuer,
      IN DWORD dwFlags,
      OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
      );

BOOL WINAPI
ObjectContextIsValidForSubject (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN LPVOID pvSubject
      );


PCERT_EXTENSION WINAPI
ObjectContextFindExtension (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN LPCSTR pszExtOid
      );

BOOL WINAPI
ObjectContextGetProperty (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN DWORD dwPropId,
      IN LPVOID pvData,
      IN DWORD* pcbData
      );

BOOL WINAPI
ObjectContextGetAttribute (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN DWORD Index,
      IN DWORD dwFlags,
      IN LPCSTR pszAttrOid,
      IN PCRYPT_ATTRIBUTE pAttribute,
      IN OUT DWORD* pcbAttribute
      );

LPVOID WINAPI
ObjectContextDuplicate (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext
      );

BOOL WINAPI
ObjectContextCreate (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      OUT LPVOID* ppvContext
      );

BOOL WINAPI
ObjectContextGetCreateAndExpireTimes (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      OUT LPFILETIME pftCreateTime,
      OUT LPFILETIME pftExpireTime
      );

BOOL WINAPI
ObjectContextGetNextUpdateUrl (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN PCCERT_CONTEXT pIssuer,
      IN LPWSTR pwszUrlHint,
      OUT PCRYPT_URL_ARRAY* ppUrlArray,
      OUT DWORD* pcbUrlArray,
      OUT DWORD* pPreferredUrlIndex,
      OUT OPTIONAL BOOL* pfHintInArray
      );

VOID WINAPI
ObjectContextFree (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext
      );

BOOL WINAPI
ObjectContextVerifySignature (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN PCCERT_CONTEXT pSigner
      );

BOOL WINAPI
MapOidToPropertyId (
   IN LPCSTR pszOid,
   OUT DWORD* pPropId
   );

// If ppszContextOid is nonNULL, will advance on to next pszContextOid
LPVOID WINAPI
ObjectContextEnumObjectsInStore (
      IN HCERTSTORE hStore,
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      OUT OPTIONAL LPCSTR* ppszContextOid = NULL
      );

VOID WINAPI
ObjectContextGetEncodedBits (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      OUT DWORD* pcbEncoded,
      OUT LPBYTE* ppbEncoded
      );

LPVOID WINAPI
ObjectContextFindCorrespondingObject (
      IN HCERTSTORE hStore,
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext
      );

BOOL WINAPI
ObjectContextDeleteAllObjectsFromStore (
      IN HCERTSTORE hStore
      );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\origin.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       origin.h
//
//  Contents:   Crypt Origin Identifier Definitions
//
//  History:    10-Sep-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__ORIGIN_H__)
#define __ORIGIN_H__

#include <md5.h>

//
// A CRYPT_ORIGIN_IDENTIFIER is an MD5 hash of selected components of a
// CAPI2 object.  This allows a unique identifier to be derived for any
// CAPI2 object where any two objects with the same origin identifier
// are the same object at possibly different points in its evolution.
// If those objects have the same HASH id then they are the same object
// at the same point in time.  For the main CAPI2 objects the selected
// components are as follows:
//
// All objects: Issuer public key
//
// Certificate: Issuer Name, Subject Name, Public Key
//
// CTL: Appropriate Issuer Name and Issuer Serial No., Usage, List Identifier
//
// CRL: Issuer Name (an issuer can only publish ONE CRL, Hygiene work in
//      progress)
//

typedef BYTE CRYPT_ORIGIN_IDENTIFIER[ MD5DIGESTLEN ];

//
// Function prototypes
//

BOOL WINAPI CertGetOriginIdentifier (
                IN PCCERT_CONTEXT pCertContext,
                IN PCCERT_CONTEXT pIssuer,
                IN DWORD dwFlags,
                OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
                );

BOOL WINAPI CtlGetOriginIdentifier (
               IN PCCTL_CONTEXT pCtlContext,
               IN PCCERT_CONTEXT pIssuer,
               IN DWORD dwFlags,
               OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
               );

BOOL WINAPI CrlGetOriginIdentifier (
               IN PCCRL_CONTEXT pCrlContext,
               IN PCCERT_CONTEXT pIssuer,
               IN DWORD dwFlags,
               OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
               );

BOOL WINAPI CrlGetOriginIdentifierFromSubjectCert (
               IN PCCERT_CONTEXT pSubjectCert,
               IN PCCERT_CONTEXT pIssuer,
               IN BOOL fFreshest,
               OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
               );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\offurl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       offurl.h
//
//  Contents:   Offline URL Caching
//
//  History:    19-Jan-00    philh    Created
//
//----------------------------------------------------------------------------
#if !defined(__CRYPTNET_OFFURL_H__)
#define __CRYPTNET_OFFURL_H__

#include <origin.h>

VOID
WINAPI
InitializeOfflineUrlCache();

VOID
WINAPI
DeleteOfflineUrlCache();

//
// Offline Url Time Information.
//
// For each offline detection, dwOfflineCnt is incrmented and
// EarliestOnlineTime =
//      CurrentTime + rgdwOfflineUrlDeltaSeconds[dwOfflineCnt - 1]
//
// On the next online detection, dwOfflineCnt is cleared.
//
typedef struct _OFFLINE_URL_TIME_INFO {
    // If dwOfflineCnt != 0, then, offline and the wire
    // won't be hit until CurrentTime >= EarliestOnlineTime
    DWORD                   dwOfflineCnt;
    FILETIME                EarliestOnlineTime;
} OFFLINE_URL_TIME_INFO, *POFFLINE_URL_TIME_INFO;

//
// Return status:
//  +1 - Online
//   0 - Offline, current time >= earliest online time, hit the wire
//  -1 - Offline, current time < earliest onlime time
//
LONG
WINAPI
GetOfflineUrlTimeStatus(
    IN POFFLINE_URL_TIME_INFO pInfo
    );

VOID
WINAPI
SetOfflineUrlTime(
    IN OUT POFFLINE_URL_TIME_INFO pInfo
    );

VOID
WINAPI
SetOnlineUrlTime(
    IN OUT POFFLINE_URL_TIME_INFO pInfo
    );

LONG
WINAPI
GetOriginUrlStatusW(
    IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
    IN LPCWSTR pwszUrl,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    );

VOID
WINAPI
SetOnlineOriginUrlW(
    IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
    IN LPCWSTR pwszUrl,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    );

VOID
WINAPI
SetOfflineOriginUrlW(
    IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
    IN LPCWSTR pwszUrl,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    );

LONG
WINAPI
GetUrlStatusA(
    IN LPCSTR pszUrl,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    );

VOID
WINAPI
SetOnlineUrlA(
    IN LPCSTR pszUrl,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    );

VOID
WINAPI
SetOfflineUrlA(
    IN LPCSTR pszUrl,
    IN LPCSTR pszContextOid,
    IN DWORD dwRetrievalFlags
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\origin.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       origin.cpp
//
//  Contents:   Origin Identifier implementation
//
//  History:    10-Sep-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#include <dbgdef.h>
//+---------------------------------------------------------------------------
//
//  Function:   CertGetOriginIdentifier
//
//  Synopsis:   get the origin identifier for a certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI CertGetOriginIdentifier (
                IN PCCERT_CONTEXT pCertContext,
                IN PCCERT_CONTEXT pIssuer,
                IN DWORD dwFlags,
                OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
                )
{
    MD5_CTX    md5ctx;
    PCERT_INFO pCertInfo = pCertContext->pCertInfo;
    PCERT_INFO pIssuerCertInfo = pIssuer->pCertInfo;

    MD5Init( &md5ctx );

    MD5Update( &md5ctx, pIssuerCertInfo->Subject.pbData, pIssuerCertInfo->Subject.cbData );
    MD5Update( &md5ctx, pCertInfo->Subject.pbData, pCertInfo->Subject.cbData );

    MD5Update(
       &md5ctx,
       (LPBYTE)pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId,
       strlen( pCertInfo->SubjectPublicKeyInfo.Algorithm.pszObjId )
       );

    MD5Update(
       &md5ctx,
       pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.pbData,
       pCertInfo->SubjectPublicKeyInfo.Algorithm.Parameters.cbData
       );

    // We assume that the unused public key bits are zero
    MD5Update(
       &md5ctx,
       pCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
       pCertInfo->SubjectPublicKeyInfo.PublicKey.cbData
       );

    MD5Update(
       &md5ctx,
       pIssuerCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
       pIssuerCertInfo->SubjectPublicKeyInfo.PublicKey.cbData
       );

    MD5Final( &md5ctx );

    memcpy( OriginIdentifier, md5ctx.digest, MD5DIGESTLEN );
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   CtlGetOriginIdentifier
//
//  Synopsis:   get the origin identifier for a CTL
//
//----------------------------------------------------------------------------
BOOL WINAPI CtlGetOriginIdentifier (
                IN PCCTL_CONTEXT pCtlContext,
                IN PCCERT_CONTEXT pIssuer,
                IN DWORD dwFlags,
                OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
                )
{
    MD5_CTX    md5ctx;
    DWORD      cCount;
    PCTL_INFO  pCtlInfo = pCtlContext->pCtlInfo;
    PCTL_USAGE pCtlUsage = &( pCtlContext->pCtlInfo->SubjectUsage );
    PCERT_INFO pIssuerCertInfo = pIssuer->pCertInfo;

    MD5Init( &md5ctx );

    MD5Update(
       &md5ctx,
       pIssuerCertInfo->Subject.pbData,
       pIssuerCertInfo->Subject.cbData
       );

    MD5Update(
       &md5ctx,
       pIssuerCertInfo->SerialNumber.pbData,
       pIssuerCertInfo->SerialNumber.cbData
       );

    for ( cCount = 0; cCount < pCtlUsage->cUsageIdentifier; cCount++ )
    {
        MD5Update(
           &md5ctx,
           (LPBYTE)pCtlUsage->rgpszUsageIdentifier[cCount],
           strlen( pCtlUsage->rgpszUsageIdentifier[cCount] )
           );
    }

    MD5Update(
       &md5ctx,
       pCtlInfo->ListIdentifier.pbData,
       pCtlInfo->ListIdentifier.cbData
       );

    MD5Update(
       &md5ctx,
       pIssuerCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
       pIssuerCertInfo->SubjectPublicKeyInfo.PublicKey.cbData
       );

    MD5Final( &md5ctx );

    memcpy( OriginIdentifier, md5ctx.digest, MD5DIGESTLEN );
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   CrlGetOriginIdentifierFromCrlIssuer
//
//  Synopsis:   get origin identifier for a CRL given the CRL's issuer cert
//
//  Comments:   A freshest, delta CRL will have a different OriginIdentifier
//              from a base CRL having the same issuer.
//
//----------------------------------------------------------------------------
BOOL WINAPI CrlGetOriginIdentifierFromCrlIssuer (
               IN PCCERT_CONTEXT pIssuerContext,
               IN PCERT_NAME_BLOB pIssuerName,
               IN BOOL fFreshest,
               OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
               )
{
    MD5_CTX    md5ctx;
    PCERT_INFO pIssuerCertInfo = pIssuerContext->pCertInfo;
    BYTE       bFreshest;


    MD5Init( &md5ctx );
    
    if (fFreshest)
    {
        bFreshest = 1;
    }
    else
    {
        bFreshest = 0;
    }

    MD5Update(
       &md5ctx,
       &bFreshest,
       sizeof(bFreshest)
       );

    MD5Update(
       &md5ctx,
       pIssuerName->pbData,
       pIssuerName->cbData
       );

    MD5Update(
       &md5ctx,
       pIssuerCertInfo->SubjectPublicKeyInfo.PublicKey.pbData,
       pIssuerCertInfo->SubjectPublicKeyInfo.PublicKey.cbData
       );

    MD5Final( &md5ctx );

    memcpy( OriginIdentifier, md5ctx.digest, MD5DIGESTLEN );
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   CrlGetOriginIdentifier
//
//  Synopsis:   get the origin identifier for a CRL
//
//----------------------------------------------------------------------------
BOOL WINAPI CrlGetOriginIdentifier (
                IN PCCRL_CONTEXT pCrlContext,
                IN PCCERT_CONTEXT pIssuer,
                IN DWORD dwFlags,
                OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
                )
{
    BOOL fFreshest;

    // See if this is a delta, freshest CRL.
    if (CertFindExtension(
            szOID_DELTA_CRL_INDICATOR,
            pCrlContext->pCrlInfo->cExtension,
            pCrlContext->pCrlInfo->rgExtension
            ))
    {
        fFreshest = TRUE;
    }
    else
    {
        fFreshest = FALSE;
    }

    return CrlGetOriginIdentifierFromCrlIssuer (
        pIssuer,
        &pCrlContext->pCrlInfo->Issuer,
        fFreshest,
        OriginIdentifier
        );
}

//+---------------------------------------------------------------------------
//
//  Function:   CrlGetOriginIdentifierFromSubjectCert
//
//  Synopsis:   get origin identifier for a CRL given the subject cert
//
//  Comments:   OBJECT_CONTEXT_FRESHEST_CRL_FLAG can be set in dwFlags.
//
//  Assumption: Subject certificate and CRL's issuer are the same.
//----------------------------------------------------------------------------
BOOL WINAPI CrlGetOriginIdentifierFromSubjectCert (
               IN PCCERT_CONTEXT pSubjectCert,
               IN PCCERT_CONTEXT pIssuer,
               IN BOOL fFreshest,
               OUT CRYPT_ORIGIN_IDENTIFIER OriginIdentifier
               )
{
    //
    // NOTENOTE: For the first version of this code we assume that the
    //           issuer of the CRL and the issuer of a subject certificate
    //           in the CRL are the same.  Therefore, we can calculate
    //           the CRL origin identifier by using the subject cert's
    //           issuer name
    //

    return CrlGetOriginIdentifierFromCrlIssuer (
        pIssuer,
        &pSubjectCert->pCertInfo->Issuer,
        fFreshest,
        OriginIdentifier
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\orm.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       orm.h
//
//  Contents:   Object Retrieval Manager class definition
//
//  History:    24-Jul-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__ORM_H__)
#define __ORM_H__

//
// IRefCountedObject.  Abstract base class to provide reference counting
//

class IRefCountedObject
{
public:

    virtual VOID AddRef () = 0;
    virtual VOID Release () = 0;
};

//
// IObjectRetriever.  Abstract base class for object retrieval
//

class IObjectRetriever : public IRefCountedObject
{
public:

    virtual BOOL RetrieveObjectByUrl (
                         LPCSTR pszUrl,
                         LPCSTR pszObjectOid,
                         DWORD dwRetrievalFlags,
                         DWORD dwTimeout,
                         LPVOID* ppvObject,
                         PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                         LPVOID* ppvFreeContext,
                         HCRYPTASYNC hAsyncRetrieve,
                         PCRYPT_CREDENTIALS pCredentials,
                         LPVOID pvVerify,
                         PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                         ) = 0;

    virtual BOOL CancelAsyncRetrieval () = 0;
};

//
// CObjectRetrievalManager.  Manages retrieval of PKI objects when requested
// via CryptRetrieveObjectByUrl.
//

class CObjectRetrievalManager : public IObjectRetriever
{
public:

    //
    // Construction
    //

    CObjectRetrievalManager ();
    ~CObjectRetrievalManager ();

    //
    // IRefCountedObject methods
    //

    virtual VOID AddRef ();
    virtual VOID Release ();

    //
    // IObjectRetriever methods
    //

    virtual BOOL RetrieveObjectByUrl (
                         LPCSTR pszUrl,
                         LPCSTR pszObjectOid,
                         DWORD dwRetrievalFlags,
                         DWORD dwTimeout,
                         LPVOID* ppvObject,
                         PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                         LPVOID* ppvFreeContext,
                         HCRYPTASYNC hAsyncRetrieve,
                         PCRYPT_CREDENTIALS pCredentials,
                         LPVOID pvVerify,
                         PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                         );

    virtual BOOL CancelAsyncRetrieval ();

    //
    // Retrieval Notification methods
    //

    BOOL OnRetrievalCompletion (
                    DWORD dwCompletionCode,
                    LPCSTR pszUrl,
                    LPCSTR pszObjectOid,
                    DWORD dwRetrievalFlags,
                    PCRYPT_BLOB_ARRAY pObject,
                    PFN_FREE_ENCODED_OBJECT_FUNC pfnFreeObject,
                    LPVOID pvFreeContext,
                    LPVOID pvVerify,
                    LPVOID* ppvObject
                    );

private:

    //
    // Reference count
    //

    ULONG                        m_cRefs;

    //
    // Scheme Provider entry points
    //

    HCRYPTOIDFUNCADDR            m_hSchemeRetrieve;
    PFN_SCHEME_RETRIEVE_FUNC     m_pfnSchemeRetrieve;

    //
    // Context Provider entry points
    //

    HCRYPTOIDFUNCADDR            m_hContextCreate;
    PFN_CONTEXT_CREATE_FUNC      m_pfnContextCreate;

    //
    // Private methods
    //

    //
    // Parameter validation
    //

    BOOL ValidateRetrievalArguments (
                 LPCSTR pszUrl,
                 LPCSTR pszObjectOid,
                 DWORD dwRetrievalFlags,
                 DWORD dwTimeout,
                 LPVOID* ppvObject,
                 HCRYPTASYNC hAsyncRetrieve,
                 PCRYPT_CREDENTIALS pCredentials,
                 LPVOID pvVerify,
                 PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                 );

    //
    // Provider initialization
    //

    BOOL LoadProviders (
             LPCSTR pszUrl,
             LPCSTR pszObjectOid
             );

    VOID UnloadProviders ();

    //
    // Provider entry point usage
    //

    BOOL CallSchemeRetrieveObjectByUrl (
                   LPCSTR pszUrl,
                   LPCSTR pszObjectOid,
                   DWORD dwRetrievalFlags,
                   DWORD dwTimeout,
                   PCRYPT_BLOB_ARRAY pObject,
                   PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                   LPVOID* ppvFreeContext,
                   HCRYPTASYNC hAsyncRetrieve,
                   PCRYPT_CREDENTIALS pCredentials,
                   PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                   );

    BOOL CallContextCreateObjectContext (
                    LPCSTR pszObjectOid,
                    DWORD dwRetrievalFlags,
                    PCRYPT_BLOB_ARRAY pObject,
                    LPVOID* ppvContext
                    );
};

//
// Provider table externs
//

extern HCRYPTOIDFUNCSET hSchemeRetrieveFuncSet;
extern HCRYPTOIDFUNCSET hContextCreateFuncSet;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\scheme.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       scheme.cpp
//
//  Contents:   Generic Scheme Provider Utility Functions
//
//  History:    18-Aug-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
#ifndef STABLE_CACHE_ENTRY
#define STABLE_CACHE_ENTRY NORMAL_CACHE_ENTRY
#endif

#if defined( DeleteUrlCacheEntry ) && ! defined(__CRYPTNET_DEMAND_H__)

#undef DeleteUrlCacheEntry

extern "C" {
BOOL WINAPI
DeleteUrlCacheEntry(
    IN LPCSTR lpszUrlName
    );
}

#endif


//+---------------------------------------------------------------------------
//
//  Function:   SchemeCacheCryptBlobArray
//
//  Synopsis:   cache the crypt blob array under the given URL
//
//----------------------------------------------------------------------------
BOOL WINAPI
SchemeCacheCryptBlobArray (
      IN LPCSTR pszUrl,
      IN DWORD dwRetrievalFlags,
      IN PCRYPT_BLOB_ARRAY pcba,
      IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
      )
{
    BOOL            fResult;
    CCryptBlobArray cba( pcba, 0 );
    LPBYTE          pb = NULL;
    ULONG           cb;
    CHAR            pszFile[MAX_PATH+1];
    HANDLE          hFile = INVALID_HANDLE_VALUE;
    ULONG           cbWritten = 0;
    DWORD           LastError = 0;
    BOOL            fCacheEntryCreated = FALSE;


    fResult = cba.GetArrayInSingleBufferEncodedForm(
                          (PCRYPT_BLOB_ARRAY *)&pb,
                          &cb
                          );

    if ( fResult == TRUE )
    {
        fResult = CreateUrlCacheEntryA(
                        pszUrl,
                        cb,
                        0,
                        pszFile,
                        0
                        );
    }

    if ( fResult == TRUE )
    {
        fCacheEntryCreated = TRUE;

        hFile = CreateFileA(
                      pszFile,
                      GENERIC_WRITE,
                      0,
                      NULL,
                      OPEN_EXISTING,
                      0,
                      NULL
                      );
    }

    if ( hFile != INVALID_HANDLE_VALUE )
    {
        fResult = WriteFile( hFile, pb, cb, &cbWritten, NULL );
        if ( fResult == TRUE )
        {
            if ( cbWritten != cb )
            {
                LastError = (DWORD) E_FAIL;
                fResult = FALSE;
            }
        }
        else
        {
            LastError = GetLastError();
        }

        CloseHandle( hFile );
    }
    else
    {
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        FILETIME                  ft = { 0, 0 };
        SCHEME_CACHE_ENTRY_HEADER sceh;
        DWORD CacheEntryType;

        memset( &sceh, 0, sizeof( SCHEME_CACHE_ENTRY_HEADER ) );

        sceh.cbSize = sizeof( SCHEME_CACHE_ENTRY_HEADER );
        sceh.MagicNumber = SCHEME_CACHE_ENTRY_MAGIC;
        sceh.OriginalBase = (DWORD_PTR)pb;

        CacheEntryType = STABLE_CACHE_ENTRY;
        if ( dwRetrievalFlags & CRYPT_STICKY_CACHE_RETRIEVAL )
        {
            CacheEntryType |= STICKY_CACHE_ENTRY;
        }
        fResult = CommitUrlCacheEntryA(
                        pszUrl,
                        pszFile,
                        ft,
                        ft,
                        CacheEntryType,
                        (LPBYTE)&sceh,
                        sizeof( SCHEME_CACHE_ENTRY_HEADER ),
                        NULL,
                        0
                        );
    }

    if ( fResult == TRUE )
    {
        fResult = SchemeRetrieveCachedAuxInfo (
                        pszUrl,
                        dwRetrievalFlags & ~CRYPT_STICKY_CACHE_RETRIEVAL,
                        pAuxInfo
                        );
    }

    if ( LastError == 0 )
    {
        LastError = GetLastError();
    }

    if ( pb != NULL )
    {
        CryptMemFree( pb );
    }

    if ( fResult == FALSE )
    {
        if ( hFile != INVALID_HANDLE_VALUE )
        {
            DeleteFileA( pszFile );
        }

        if ( fCacheEntryCreated == TRUE )
        {
            DeleteUrlCacheEntry( pszUrl );
        }
    }

    SetLastError( LastError );
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   SchemeRetrieveCachedCryptBlobArray
//
//  Synopsis:   retrieve cached blob array bits
//
//----------------------------------------------------------------------------
BOOL WINAPI
SchemeRetrieveCachedCryptBlobArray (
      IN LPCSTR pszUrl,
      IN DWORD dwRetrievalFlags,
      OUT PCRYPT_BLOB_ARRAY pcba,
      OUT PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
      OUT LPVOID* ppvFreeContext,
      IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
      )
{
    BOOL                         fResult;
    DWORD                        cb = 0;
    LPINTERNET_CACHE_ENTRY_INFOA pCacheEntry = NULL;
    HANDLE                       hFile = INVALID_HANDLE_VALUE;
    DWORD                        dwSize = 0;
    LPBYTE                       pb = NULL;
    DWORD                        LastError = 0;
    DWORD                        dwRead;
    PCRYPT_BLOB_ARRAY            pCachedArray = NULL;
    PSCHEME_CACHE_ENTRY_HEADER   psceh = NULL;

    fResult = GetUrlCacheEntryInfoA( pszUrl, pCacheEntry, &cb );
    if ( ( fResult == FALSE ) &&
         ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) )
    {
        pCacheEntry = (LPINTERNET_CACHE_ENTRY_INFOA)new BYTE [cb];
        if ( pCacheEntry != NULL )
        {
            fResult = GetUrlCacheEntryInfoA( pszUrl, pCacheEntry, &cb );
        }
        else
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            return( FALSE );
        }
    }

    if ( fResult == TRUE )
    {
        psceh = (PSCHEME_CACHE_ENTRY_HEADER)pCacheEntry->lpHeaderInfo;

        if ( ( psceh->cbSize != sizeof( SCHEME_CACHE_ENTRY_HEADER ) ) ||
             ( psceh->MagicNumber != SCHEME_CACHE_ENTRY_MAGIC ) )
        {
            delete (LPBYTE)pCacheEntry;
            SetLastError( (DWORD) E_INVALIDARG );
            return( FALSE );
        }

        if ( pAuxInfo &&
                offsetof(CRYPT_RETRIEVE_AUX_INFO, pLastSyncTime) <
                            pAuxInfo->cbSize &&
                pAuxInfo->pLastSyncTime )
        {
            *pAuxInfo->pLastSyncTime = pCacheEntry->LastSyncTime;
        }
    }

    if ( fResult == TRUE )
    {
        hFile = CreateFileA(
                      pCacheEntry->lpszLocalFileName,
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      0,
                      NULL
                      );
    }

    if ( hFile != INVALID_HANDLE_VALUE )
    {
        dwSize = GetFileSize( hFile, NULL );
        pb = new BYTE [dwSize];
        if ( pb != NULL )
        {
            fResult = ReadFile( hFile, pb, dwSize, &dwRead, NULL );
            if ( fResult == TRUE )
            {
                if ( dwRead != dwSize )
                {
                    LastError = (DWORD) E_FAIL;
                    fResult = FALSE;
                }
            }
            else
            {
                LastError = GetLastError();
            }
        }
        else
        {
            LastError = (DWORD) E_OUTOFMEMORY;
            fResult = FALSE;
        }

        CloseHandle( hFile );
    }
    else
    {
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        DWORD dwFieldControl = CACHE_ENTRY_ACCTIME_FC;

        GetSystemTimeAsFileTime( &pCacheEntry->LastAccessTime );

        if ( dwRetrievalFlags & CRYPT_STICKY_CACHE_RETRIEVAL )
        {
            if ( 0 == (pCacheEntry->CacheEntryType & STICKY_CACHE_ENTRY) )
            {
                pCacheEntry->CacheEntryType |= STICKY_CACHE_ENTRY;
                dwFieldControl |= CACHE_ENTRY_ATTRIBUTE_FC;
            }
        }

        SetUrlCacheEntryInfoA( pszUrl, pCacheEntry, dwFieldControl );

        fResult = SchemeFixupCachedBits(
                        dwSize,
                        pb,
                        &pCachedArray
                        );
    }

    if ( fResult == TRUE )
    {
        pcba->cBlob = pCachedArray->cBlob;
        pcba->rgBlob = pCachedArray->rgBlob;

        *ppfnFreeObject = SchemeFreeEncodedCryptBlobArray;
        *ppvFreeContext = (LPVOID)pCachedArray;
    }
    else
    {
        if ( LastError != 0 )
        {
            SetLastError( LastError );
        }

        delete pb;
    }

    delete (LPBYTE)pCacheEntry;

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   SchemeFixupCachedBits
//
//  Synopsis:   fixup cached crypt blob array bits which have been stored in
//              single buffer encoded form
//
//----------------------------------------------------------------------------
BOOL WINAPI
SchemeFixupCachedBits (
      IN ULONG cb,
      IN LPBYTE pb,
      OUT PCRYPT_BLOB_ARRAY* ppcba
      )
{
    ULONG             cCount;
    PCRYPT_BLOB_ARRAY pcba = (PCRYPT_BLOB_ARRAY)pb;
    DWORD_PTR         OriginalBase;

    OriginalBase = (DWORD_PTR)( (LPBYTE)pcba->rgBlob - sizeof( CRYPT_BLOB_ARRAY ) );
    pcba->rgBlob = (PCRYPT_DATA_BLOB)( pb + sizeof( CRYPT_BLOB_ARRAY ) );

    for ( cCount = 0; cCount < pcba->cBlob; cCount++ )
    {
        pcba->rgBlob[cCount].pbData =
              ( pb + ( pcba->rgBlob[cCount].pbData - (LPBYTE)OriginalBase ) );

        if ( (DWORD)( pcba->rgBlob[ cCount ].pbData - pb ) > cb )
        {
            SetLastError( (DWORD) CRYPT_E_UNEXPECTED_ENCODING );
            return( FALSE );
        }
    }

    *ppcba = pcba;

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   SchemeDeleteUrlCacheEntry
//
//  Synopsis:   delete URL cache entry
//
//----------------------------------------------------------------------------
BOOL WINAPI
SchemeDeleteUrlCacheEntry (
      IN LPCWSTR pwszUrl
      )
{
    CHAR pszUrl[ INTERNET_MAX_PATH_LENGTH + 1 ];

    if ( WideCharToMultiByte(
             CP_ACP,
             0,
             pwszUrl,
             -1,
             pszUrl,
             INTERNET_MAX_PATH_LENGTH,
             NULL,
             NULL
             ) == 0 )
    {
        return( FALSE );
    }

    return( DeleteUrlCacheEntry( pszUrl ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   SchemeFreeEncodedCryptBlobArray
//
//  Synopsis:   free encoded crypt blob array
//
//----------------------------------------------------------------------------
VOID WINAPI
SchemeFreeEncodedCryptBlobArray (
      IN LPCSTR pszObjectOid,
      IN PCRYPT_BLOB_ARRAY pcba,
      IN LPVOID pvFreeContext
      )
{
    delete (LPBYTE)pvFreeContext;
}

//+---------------------------------------------------------------------------
//
//  Function:   SchemeGetPasswordCredentialsA
//
//  Synopsis:   get password credentials from crypt credentials
//
//----------------------------------------------------------------------------
BOOL WINAPI
SchemeGetPasswordCredentialsA (
      IN PCRYPT_CREDENTIALS pCredentials,
      OUT PCRYPT_PASSWORD_CREDENTIALSA pPasswordCredentials,
      OUT BOOL* pfFreeCredentials
      )
{
    DWORD                        cwUsername;
    DWORD                        cwPassword;
    PCRYPT_PASSWORD_CREDENTIALSA pPassCredA;
    PCRYPT_PASSWORD_CREDENTIALSW pPassCredW;
    LPSTR                        pszUsername;
    LPSTR                        pszPassword;

    if ( pPasswordCredentials->cbSize != sizeof( CRYPT_PASSWORD_CREDENTIALS ) )
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    if ( pCredentials == NULL )
    {
        pPasswordCredentials->pszUsername = NULL;
        pPasswordCredentials->pszPassword = NULL;
        *pfFreeCredentials = FALSE;

        return( TRUE );
    }

    if ( pCredentials->pszCredentialsOid ==
         CREDENTIAL_OID_PASSWORD_CREDENTIALS_A )
    {
        pPassCredA = (PCRYPT_PASSWORD_CREDENTIALSA)pCredentials->pvCredentials;
        *pPasswordCredentials = *pPassCredA;
        *pfFreeCredentials = FALSE;

        return( TRUE );
    }

    if ( pCredentials->pszCredentialsOid !=
         CREDENTIAL_OID_PASSWORD_CREDENTIALS_W )
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    pPassCredW = (PCRYPT_PASSWORD_CREDENTIALSW)pCredentials->pvCredentials;
    cwUsername = wcslen( pPassCredW->pszUsername ) + 1;
    cwPassword = wcslen( pPassCredW->pszPassword ) + 1;

    pszUsername = new CHAR [ cwUsername ];
    pszPassword = new CHAR [ cwPassword ];

    if ( ( pszUsername == NULL ) || ( pszPassword == NULL ) )
    {
        delete pszUsername;
        delete pszPassword;
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    *pfFreeCredentials = TRUE;

    WideCharToMultiByte(
        CP_ACP,
        0,
        pPassCredW->pszUsername,
        cwUsername,
        pszUsername,
        cwUsername,
        NULL,
        NULL
        );

    WideCharToMultiByte(
        CP_ACP,
        0,
        pPassCredW->pszPassword,
        cwPassword,
        pszPassword,
        cwPassword,
        NULL,
        NULL
        );

    pPasswordCredentials->pszUsername = pszUsername;
    pPasswordCredentials->pszPassword = pszPassword;

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Function:   SchemeFreePasswordCredentialsA
//
//  Synopsis:   free password credentials
//
//----------------------------------------------------------------------------
VOID WINAPI
SchemeFreePasswordCredentialsA (
      IN PCRYPT_PASSWORD_CREDENTIALSA pPasswordCredentials
      )
{
    delete pPasswordCredentials->pszUsername;
    delete pPasswordCredentials->pszPassword;
}

//+---------------------------------------------------------------------------
//
//  Function:   SchemeGetAuthIdentityFromPasswordCredentialsA
//
//  Synopsis:   converts a CRYPT_PASSWORD_CREDENTIALSA to a
//              SEC_WINNT_AUTH_IDENTITY_A
//
//----------------------------------------------------------------------------
VOID WINAPI
SchemeGetAuthIdentityFromPasswordCredentialsA (
      IN PCRYPT_PASSWORD_CREDENTIALSA pPasswordCredentials,
      OUT PSEC_WINNT_AUTH_IDENTITY_A pAuthIdentity,
      OUT LPSTR* ppDomainRestorePos
      )
{
    DWORD cDomain = 0;

    *ppDomainRestorePos = NULL;

    if ( pPasswordCredentials->pszUsername == NULL )
    {
        pAuthIdentity->User = NULL;
        pAuthIdentity->UserLength = 0;
        pAuthIdentity->Domain = NULL;
        pAuthIdentity->DomainLength = 0;
        pAuthIdentity->Password = NULL;
        pAuthIdentity->PasswordLength = 0;
        pAuthIdentity->Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
        return;
    }

    while ( ( pPasswordCredentials->pszUsername[cDomain] != '\0' ) &&
            ( pPasswordCredentials->pszUsername[cDomain] != '\\' ) )
    {
        cDomain += 1;
    }

    if ( cDomain != (DWORD)strlen( pPasswordCredentials->pszUsername ) )
    {
        pAuthIdentity->Domain = (UCHAR *)pPasswordCredentials->pszUsername;
        pAuthIdentity->DomainLength = cDomain - 1;

        pAuthIdentity->User = (UCHAR *)&pPasswordCredentials->pszUsername[
                                                                 cDomain+1
                                                                 ];

        pAuthIdentity->UserLength = strlen( (LPCSTR)pAuthIdentity->User );

        *ppDomainRestorePos = &pPasswordCredentials->pszUsername[cDomain];
        **ppDomainRestorePos = '\0';
    }
    else
    {
        pAuthIdentity->Domain = NULL;
        pAuthIdentity->DomainLength = 0;
        pAuthIdentity->User = (UCHAR *)pPasswordCredentials->pszUsername;
        pAuthIdentity->UserLength = cDomain;
    }

    pAuthIdentity->Password = (UCHAR *)pPasswordCredentials->pszPassword;
    pAuthIdentity->PasswordLength = strlen( (LPCSTR)pAuthIdentity->Password );
    pAuthIdentity->Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
}

//+---------------------------------------------------------------------------
//
//  Function:   SchemeRestorePasswordCredentialsFromAuthIdentityA
//
//  Synopsis:   restore the backslash to the domain username pair
//
//----------------------------------------------------------------------------
VOID WINAPI
SchemeRestorePasswordCredentialsFromAuthIdentityA (
      IN PCRYPT_PASSWORD_CREDENTIALSA pPasswordCredentials,
      IN PSEC_WINNT_AUTH_IDENTITY_A pAuthIdentity,
      IN LPSTR pDomainRestorePos
      )
{
    if ( pDomainRestorePos != NULL )
    {
        *pDomainRestorePos = '\\';
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   SchemeRetrieveCachedAuxInfo
//
//  Synopsis:   get the LastSyncTime from the Url cache entry info and update
//              the retrieval AuxInfo. If CRYPT_STICKY_CACHE_RETRIEVAL is
//              set, mark the Url cache entry as being sticky.
//
//----------------------------------------------------------------------------
BOOL WINAPI
SchemeRetrieveCachedAuxInfo (
      IN LPCSTR pszUrl,
      IN DWORD dwRetrievalFlags,
      IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
      )
{
    BOOL                         fResult = TRUE;
    BOOL                         fGetLastSyncTime = FALSE;
    DWORD                        cb = 0;
    LPINTERNET_CACHE_ENTRY_INFOA pCacheEntry = NULL;

    if ( pAuxInfo &&
            offsetof(CRYPT_RETRIEVE_AUX_INFO, pLastSyncTime) <
                        pAuxInfo->cbSize &&
            pAuxInfo->pLastSyncTime )
    {
        fGetLastSyncTime = TRUE;
    }

    if ( !fGetLastSyncTime &&
            0 == (dwRetrievalFlags & CRYPT_STICKY_CACHE_RETRIEVAL) )
    {
        return( TRUE );
    }

    fResult = GetUrlCacheEntryInfoA( pszUrl, pCacheEntry, &cb );
    if ( ( fResult == FALSE ) &&
         ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) )
    {
        pCacheEntry = (LPINTERNET_CACHE_ENTRY_INFOA)new BYTE [cb];
        if ( pCacheEntry != NULL )
        {
            fResult = GetUrlCacheEntryInfoA( pszUrl, pCacheEntry, &cb );
        }
        else
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            return( FALSE );
        }
    }

    if ( fResult == TRUE )
    {
        if ( fGetLastSyncTime )
        {
            *pAuxInfo->pLastSyncTime = pCacheEntry->LastSyncTime;
        }

        if ( dwRetrievalFlags & CRYPT_STICKY_CACHE_RETRIEVAL )
        {
            if ( 0 == (pCacheEntry->CacheEntryType & STICKY_CACHE_ENTRY) )
            {
                pCacheEntry->CacheEntryType |= STICKY_CACHE_ENTRY;
                fResult = SetUrlCacheEntryInfoA( pszUrl, pCacheEntry,
                    CACHE_ENTRY_ATTRIBUTE_FC );
            }
        }
    }


    delete (LPBYTE)pCacheEntry;

    return( fResult );
}


//+---------------------------------------------------------------------------
//
//  Function:   SchemeRetrieveUncachedAuxInfo
//
//  Synopsis:   update the LastSyncTime in the retrieval AuxInfo with the
//              current time.
//
//----------------------------------------------------------------------------
BOOL WINAPI
SchemeRetrieveUncachedAuxInfo (
      IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
      )
{
    if ( pAuxInfo &&
            offsetof(CRYPT_RETRIEVE_AUX_INFO, pLastSyncTime) <
                        pAuxInfo->cbSize &&
            pAuxInfo->pLastSyncTime )
    {
        GetSystemTimeAsFileTime( pAuxInfo->pLastSyncTime );
    }

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\rporprov.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       rporprov.h
//
//  Contents:   Remote PKI Object Retrieval Provider Prototypes
//
//  History:    23-Jul-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__RPORPROV_H__)
#define __RPORPROV_H__

#if defined(__cplusplus)
extern "C" {
#endif

//
// Scheme provider prototypes
//

typedef BOOL (WINAPI *PFN_SCHEME_RETRIEVE_FUNC) (
                          IN LPCSTR pszUrl,
                          IN LPCSTR pszObjectOid,
                          IN DWORD dwRetrievalFlags,
                          IN DWORD dwTimeout,
                          OUT PCRYPT_BLOB_ARRAY pObject,
                          OUT PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                          OUT LPVOID* ppvFreeContext,
                          IN HCRYPTASYNC hAsyncRetrieve,
                          IN PCRYPT_CREDENTIALS pCredentials,
                          IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                          );

typedef BOOL (WINAPI *PFN_CONTEXT_CREATE_FUNC) (
                          IN LPCSTR pszObjectOid,
                          IN DWORD dwRetrievalFlags,
                          IN PCRYPT_BLOB_ARRAY pObject,
                          OUT LPVOID* ppvContext
                          );

//
// Generic scheme provider utility functions
//

#define SCHEME_CACHE_ENTRY_MAGIC 0x41372

typedef struct _SCHEME_CACHE_ENTRY_HEADER {

    DWORD cbSize;
    DWORD MagicNumber;
    DWORD_PTR OriginalBase;

} SCHEME_CACHE_ENTRY_HEADER, *PSCHEME_CACHE_ENTRY_HEADER;

BOOL WINAPI
SchemeCacheCryptBlobArray (
      IN LPCSTR pszUrl,
      IN DWORD dwRetrievalFlags,
      IN PCRYPT_BLOB_ARRAY pcba,
      IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
      );

BOOL WINAPI
SchemeRetrieveCachedCryptBlobArray (
      IN LPCSTR pszUrl,
      IN DWORD dwRetrievalFlags,
      OUT PCRYPT_BLOB_ARRAY pcba,
      OUT PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
      OUT LPVOID* ppvFreeContext,
      IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
      );

BOOL WINAPI
SchemeRetrieveCachedAuxInfo (
      IN LPCSTR pszUrl,
      IN DWORD dwRetrievalFlags,
      IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
      );

BOOL WINAPI
SchemeRetrieveUncachedAuxInfo (
      IN PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
      );

BOOL WINAPI
SchemeFixupCachedBits (
      IN ULONG cb,
      IN LPBYTE pb,
      OUT PCRYPT_BLOB_ARRAY* ppcba
      );

BOOL WINAPI
SchemeDeleteUrlCacheEntry (
      IN LPCWSTR pwszUrl
      );

VOID WINAPI
SchemeFreeEncodedCryptBlobArray (
      IN LPCSTR pszObjectOid,
      IN PCRYPT_BLOB_ARRAY pcba,
      IN LPVOID pvFreeContext
      );

BOOL WINAPI
SchemeGetPasswordCredentialsA (
      IN PCRYPT_CREDENTIALS pCredentials,
      OUT PCRYPT_PASSWORD_CREDENTIALSA pPasswordCredentials,
      OUT BOOL* pfFreeCredentials
      );

VOID WINAPI
SchemeFreePasswordCredentialsA (
      IN PCRYPT_PASSWORD_CREDENTIALSA pPasswordCredentials
      );

VOID WINAPI
SchemeGetAuthIdentityFromPasswordCredentialsA (
      IN PCRYPT_PASSWORD_CREDENTIALSA pPasswordCredentials,
      OUT PSEC_WINNT_AUTH_IDENTITY_A pAuthIdentity,
      OUT LPSTR* ppDomainRestorePos
      );

VOID WINAPI
SchemeRestorePasswordCredentialsFromAuthIdentityA (
      IN PCRYPT_PASSWORD_CREDENTIALSA pPasswordCredentials,
      IN PSEC_WINNT_AUTH_IDENTITY_A pAuthIdentity,
      IN LPSTR pDomainRestorePos
      );

//
// LDAP
//

#include <ldapsp.h>

//
// HTTP, FTP, GOPHER
//

#include <inetsp.h>

//
// Win32 File I/O
//

#include <filesp.h>

//
// Context Provider prototypes
//

//
// Any, controlled via fQuerySingleContext and dwExpectedContentTypeFlags
//

BOOL WINAPI CreateObjectContext (
                 IN DWORD dwRetrievalFlags,
                 IN PCRYPT_BLOB_ARRAY pObject,
                 IN DWORD dwExpectedContentTypeFlags,
                 IN BOOL fQuerySingleContext,
                 OUT LPVOID* ppvContext
                 );

//
// Certificate
//

BOOL WINAPI CertificateCreateObjectContext (
                       IN LPCSTR pszObjectOid,
                       IN DWORD dwRetrievalFlags,
                       IN PCRYPT_BLOB_ARRAY pObject,
                       OUT LPVOID* ppvContext
                       );

//
// CTL
//

BOOL WINAPI CTLCreateObjectContext (
                     IN LPCSTR pszObjectOid,
                     IN DWORD dwRetrievalFlags,
                     IN PCRYPT_BLOB_ARRAY pObject,
                     OUT LPVOID* ppvContext
                     );

//
// CRL
//

BOOL WINAPI CRLCreateObjectContext (
                     IN LPCSTR pszObjectOid,
                     IN DWORD dwRetrievalFlags,
                     IN PCRYPT_BLOB_ARRAY pObject,
                     OUT LPVOID* ppvContext
                     );

//
// PKCS7
//

BOOL WINAPI Pkcs7CreateObjectContext (
                 IN LPCSTR pszObjectOid,
                 IN DWORD dwRetrievalFlags,
                 IN PCRYPT_BLOB_ARRAY pObject,
                 OUT LPVOID* ppvContext
                 );

//
// CAPI2 objects
//

BOOL WINAPI Capi2CreateObjectContext (
                 IN LPCSTR pszObjectOid,
                 IN DWORD dwRetrievalFlags,
                 IN PCRYPT_BLOB_ARRAY pObject,
                 OUT LPVOID* ppvContext
                 );

#if defined(__cplusplus)
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\tvo.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       tvo.cpp
//
//  Contents:   Implementation of CryptGetTimeValidObject
//
//  History:    25-Sep-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>


//+---------------------------------------------------------------------------
//
//  Function:   CryptGetTimeValidObject
//
//  Synopsis:   get a time valid CAPI2 object
//
//----------------------------------------------------------------------------
BOOL WINAPI
CryptGetTimeValidObject (
     IN LPCSTR pszTimeValidOid,
     IN LPVOID pvPara,
     IN PCCERT_CONTEXT pIssuer,
     IN LPFILETIME pftValidFor,
     IN DWORD dwFlags,
     IN DWORD dwTimeout,
     OUT OPTIONAL LPVOID* ppvObject,
     IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
     IN OPTIONAL LPVOID pvReserved
     )
{
    BOOL                           fResult;
    HCRYPTOIDFUNCADDR              hGetTimeValidObject;
    PFN_GET_TIME_VALID_OBJECT_FUNC pfnGetTimeValidObject;
    DWORD                          LastError;
    FILETIME                       CurrentTime;

    if ( CryptGetOIDFunctionAddress(
              hGetTimeValidObjectFuncSet,
              X509_ASN_ENCODING,
              pszTimeValidOid,
              0,
              (LPVOID *)&pfnGetTimeValidObject,
              &hGetTimeValidObject
              ) == FALSE )
    {
        return( FALSE );
    }

    if ( pftValidFor == NULL )
    {
        GetSystemTimeAsFileTime( &CurrentTime );
        pftValidFor = &CurrentTime;
    }

    fResult = ( *pfnGetTimeValidObject )(
                       pszTimeValidOid,
                       pvPara,
                       pIssuer,
                       pftValidFor,
                       dwFlags,
                       dwTimeout,
                       ppvObject,
                       pCredentials,
                       pvReserved
                       );

    LastError = GetLastError();
    CryptFreeOIDFunctionAddress( hGetTimeValidObject, 0 );
    SetLastError( LastError );

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   CtlGetTimeValidObject
//
//  Synopsis:   get a time valid CTL
//
//----------------------------------------------------------------------------
BOOL WINAPI
CtlGetTimeValidObject (
   IN LPCSTR pszTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN LPFILETIME pftValidFor,
   IN DWORD dwFlags,
   IN DWORD dwTimeout,
   OUT OPTIONAL LPVOID* ppvObject,
   IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
   IN OPTIONAL LPVOID pvReserved
   )
{
    return( g_pProcessTVOAgent->GetTimeValidObject(
                                   pszTimeValidOid,
                                   pvPara,
                                   CONTEXT_OID_CTL,
                                   pIssuer,
                                   pftValidFor,
                                   dwFlags,
                                   dwTimeout,
                                   ppvObject,
                                   pCredentials,
                                   pvReserved
                                   ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CrlGetTimeValidObject
//
//  Synopsis:   get a time valid CRL
//
//----------------------------------------------------------------------------
BOOL WINAPI
CrlGetTimeValidObject (
   IN LPCSTR pszTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN LPFILETIME pftValidFor,
   IN DWORD dwFlags,
   IN DWORD dwTimeout,
   OUT OPTIONAL LPVOID* ppvObject,
   IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
   IN OPTIONAL LPVOID pvReserved
   )
{
    return( g_pProcessTVOAgent->GetTimeValidObject(
                                   pszTimeValidOid,
                                   pvPara,
                                   CONTEXT_OID_CRL,
                                   pIssuer,
                                   pftValidFor,
                                   dwFlags,
                                   dwTimeout,
                                   ppvObject,
                                   pCredentials,
                                   pvReserved
                                   ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CrlFromCertGetTimeValidObject
//
//  Synopsis:   get a time valid CRL from a subject certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI
CrlFromCertGetTimeValidObject (
   IN LPCSTR pszTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN LPFILETIME pftValidFor,
   IN DWORD dwFlags,
   IN DWORD dwTimeout,
   OUT OPTIONAL LPVOID* ppvObject,
   IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
   IN OPTIONAL LPVOID pvReserved
   )
{
    return( g_pProcessTVOAgent->GetTimeValidObject(
                                   pszTimeValidOid,
                                   pvPara,
                                   CONTEXT_OID_CRL,
                                   pIssuer,
                                   pftValidFor,
                                   dwFlags,
                                   dwTimeout,
                                   ppvObject,
                                   pCredentials,
                                   pvReserved
                                   ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   FreshestCrlFromCertGetTimeValidObject
//
//  Synopsis:   get a time valid freshest, delta CRL from a subject certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI
FreshestCrlFromCertGetTimeValidObject (
   IN LPCSTR pszTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN LPFILETIME pftValidFor,
   IN DWORD dwFlags,
   IN DWORD dwTimeout,
   OUT OPTIONAL LPVOID* ppvObject,
   IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
   IN OPTIONAL LPVOID pvReserved
   )
{
    return( g_pProcessTVOAgent->GetTimeValidObject(
                                   pszTimeValidOid,
                                   pvPara,
                                   CONTEXT_OID_CRL,
                                   pIssuer,
                                   pftValidFor,
                                   dwFlags,
                                   dwTimeout,
                                   ppvObject,
                                   pCredentials,
                                   pvReserved
                                   ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   FreshestCrlFromCrlGetTimeValidObject
//
//  Synopsis:   get a time valid freshest, delta CRL from a base CRL
//
//----------------------------------------------------------------------------
BOOL WINAPI
FreshestCrlFromCrlGetTimeValidObject (
   IN LPCSTR pszTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN LPFILETIME pftValidFor,
   IN DWORD dwFlags,
   IN DWORD dwTimeout,
   OUT OPTIONAL LPVOID* ppvObject,
   IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
   IN OPTIONAL LPVOID pvReserved
   )
{
    return( g_pProcessTVOAgent->GetTimeValidObject(
                                   pszTimeValidOid,
                                   pvPara,
                                   CONTEXT_OID_CRL,
                                   pIssuer,
                                   pftValidFor,
                                   dwFlags,
                                   dwTimeout,
                                   ppvObject,
                                   pCredentials,
                                   pvReserved
                                   ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CryptFlushTimeValidObject
//
//  Synopsis:   flush the object from the "TVO" system
//
//----------------------------------------------------------------------------
BOOL WINAPI
CryptFlushTimeValidObject (
     IN LPCSTR pszFlushTimeValidOid,
     IN LPVOID pvPara,
     IN PCCERT_CONTEXT pIssuer,
     IN DWORD dwFlags,
     IN LPVOID pvReserved
     )
{
    BOOL                             fResult;
    HCRYPTOIDFUNCADDR                hFlushTimeValidObject;
    PFN_FLUSH_TIME_VALID_OBJECT_FUNC pfnFlushTimeValidObject;
    DWORD                            LastError;

    if ( CryptGetOIDFunctionAddress(
              hFlushTimeValidObjectFuncSet,
              X509_ASN_ENCODING,
              pszFlushTimeValidOid,
              0,
              (LPVOID *)&pfnFlushTimeValidObject,
              &hFlushTimeValidObject
              ) == FALSE )
    {
        return( FALSE );
    }

    fResult = ( *pfnFlushTimeValidObject )(
                         pszFlushTimeValidOid,
                         pvPara,
                         pIssuer,
                         dwFlags,
                         pvReserved
                         );

    LastError = GetLastError();
    CryptFreeOIDFunctionAddress( hFlushTimeValidObject, 0 );
    SetLastError( LastError );

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   CtlFlushTimeValidObject
//
//  Synopsis:   flush a CTL from the "TVO" system
//
//----------------------------------------------------------------------------
BOOL WINAPI
CtlFlushTimeValidObject (
   IN LPCSTR pszFlushTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN DWORD dwFlags,
   IN LPVOID pvReserved
   )
{
    return( g_pProcessTVOAgent->FlushTimeValidObject(
                                     pszFlushTimeValidOid,
                                     pvPara,
                                     CONTEXT_OID_CTL,
                                     pIssuer,
                                     dwFlags,
                                     pvReserved
                                     ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CrlFlushTimeValidObject
//
//  Synopsis:   flush a CRL from the "TVO" system
//
//----------------------------------------------------------------------------
BOOL WINAPI
CrlFlushTimeValidObject (
   IN LPCSTR pszFlushTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN DWORD dwFlags,
   IN LPVOID pvReserved
   )
{
    return( g_pProcessTVOAgent->FlushTimeValidObject(
                                     pszFlushTimeValidOid,
                                     pvPara,
                                     CONTEXT_OID_CRL,
                                     pIssuer,
                                     dwFlags,
                                     pvReserved
                                     ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CrlFromCertFlushTimeValidObject
//
//  Synopsis:   flush a CRL from the "TVO" system given a subject cert
//
//----------------------------------------------------------------------------
BOOL WINAPI
CrlFromCertFlushTimeValidObject (
   IN LPCSTR pszFlushTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN DWORD dwFlags,
   IN LPVOID pvReserved
   )
{
    return( g_pProcessTVOAgent->FlushTimeValidObject(
                                     pszFlushTimeValidOid,
                                     pvPara,
                                     CONTEXT_OID_CRL,
                                     pIssuer,
                                     dwFlags,
                                     pvReserved
                                     ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   FreshedtCrlFromCertFlushTimeValidObject
//
//  Synopsis:   flush a freshest, delta CRL from the "TVO" system given a
//              subject cert
//
//----------------------------------------------------------------------------
BOOL WINAPI
FreshestCrlFromCertFlushTimeValidObject (
   IN LPCSTR pszFlushTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN DWORD dwFlags,
   IN LPVOID pvReserved
   )
{
    return( g_pProcessTVOAgent->FlushTimeValidObject(
                                     pszFlushTimeValidOid,
                                     pvPara,
                                     CONTEXT_OID_CRL,
                                     pIssuer,
                                     dwFlags,
                                     pvReserved
                                     ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   FreshestCrlFromCrlFlushTimeValidObject
//
//  Synopsis:   flush a freshest, delta CRL from the "TVO" system given a
//              base CRL
//
//----------------------------------------------------------------------------
BOOL WINAPI
FreshestCrlFromCrlFlushTimeValidObject (
   IN LPCSTR pszFlushTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN DWORD dwFlags,
   IN LPVOID pvReserved
   )
{
    return( g_pProcessTVOAgent->FlushTimeValidObject(
                                     pszFlushTimeValidOid,
                                     pvPara,
                                     CONTEXT_OID_CRL,
                                     pIssuer,
                                     dwFlags,
                                     pvReserved
                                     ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CTVOCache::CTVOCache, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CTVOCache::CTVOCache (
               DWORD cCacheBuckets,
               DWORD MaxCacheEntries,
               BOOL& rfResult
               )
{
    LRU_CACHE_CONFIG CacheConfig;

    assert( MaxCacheEntries > 0 );

    memset( &CacheConfig, 0, sizeof( CacheConfig ) );

    CacheConfig.dwFlags = LRU_CACHE_NO_SERIALIZE | LRU_CACHE_NO_COPY_IDENTIFIER;
    CacheConfig.cBuckets = cCacheBuckets;
    CacheConfig.MaxEntries = MaxCacheEntries;
    CacheConfig.pfnHash = TVOCacheHashOriginIdentifier;
    CacheConfig.pfnOnRemoval = TVOCacheOnRemoval;

    rfResult = I_CryptCreateLruCache( &CacheConfig, &m_hCache );
}

//+---------------------------------------------------------------------------
//
//  Member:     CTVOCache::~CTVOCache, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CTVOCache::~CTVOCache ()
{
    I_CryptFreeLruCache( m_hCache, 0, NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CTVOCache::InsertCacheEntry, public
//
//  Synopsis:   insert entry into cache
//
//----------------------------------------------------------------------------
VOID
CTVOCache::InsertCacheEntry (PTVO_CACHE_ENTRY pEntry)
{
    I_CryptInsertLruEntry( pEntry->hLruEntry, NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CTVOCache::RemoveCacheEntry, public
//
//  Synopsis:   remove entry from cache
//
//----------------------------------------------------------------------------
VOID
CTVOCache::RemoveCacheEntry (PTVO_CACHE_ENTRY pEntry, BOOL fSuppressFree)
{
    DWORD dwFlags = 0;

    if ( fSuppressFree == TRUE )
    {
        dwFlags = LRU_SUPPRESS_REMOVAL_NOTIFICATION;
    }

    I_CryptRemoveLruEntry( pEntry->hLruEntry, dwFlags, NULL );
}

//+---------------------------------------------------------------------------
//
//  Member:     CTVOCache::TouchCacheEntry, public
//
//  Synopsis:   touch an entry
//
//----------------------------------------------------------------------------
VOID
CTVOCache::TouchCacheEntry (PTVO_CACHE_ENTRY pEntry)
{
    I_CryptTouchLruEntry( pEntry->hLruEntry, 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CTVOCache::FindCacheEntry, public
//
//  Synopsis:   find an entry in the cache given the origin identifier.
//              Skip entries that aren't valid for the subject.
//
//----------------------------------------------------------------------------
PTVO_CACHE_ENTRY
CTVOCache::FindCacheEntry (
    CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
    LPCSTR pszContextOid,
    LPVOID pvSubject
    )
{
    HLRUENTRY        hEntry;
    CRYPT_DATA_BLOB  DataBlob;
    PTVO_CACHE_ENTRY pEntry = NULL;

    DataBlob.cbData = MD5DIGESTLEN;
    DataBlob.pbData = OriginIdentifier;

    hEntry = I_CryptFindLruEntry( m_hCache, &DataBlob );
    while ( hEntry != NULL )
    {
        pEntry = (PTVO_CACHE_ENTRY)I_CryptGetLruEntryData( hEntry );
        assert(pEntry);
        assert(pszContextOid == pEntry->pszContextOid);
        if (pszContextOid == pEntry->pszContextOid && 
            ObjectContextIsValidForSubject (
                pszContextOid,
                pEntry->pvContext,
                pvSubject
                ))
        {
            I_CryptReleaseLruEntry( hEntry );
            break;
        }
        else
        {
            pEntry = NULL;
            hEntry = I_CryptEnumMatchingLruEntries ( hEntry );
        }
    }

    return( pEntry );
}

//+---------------------------------------------------------------------------
//
//  Member:     CTVOCache::RemoveAllCacheEntries, public
//
//  Synopsis:   remove all cache entries
//
//----------------------------------------------------------------------------
VOID
CTVOCache::RemoveAllCacheEntries ()
{
    I_CryptFlushLruCache( m_hCache, 0, NULL );
}

//+---------------------------------------------------------------------------
//
//  Function:   TVOCacheHashOriginIdentifier
//
//  Synopsis:   hash the origin identifier to a DWORD, since the origin
//              identifier is already a unique MD5 hash our algorithm is
//              to simply use some of the bytes
//
//----------------------------------------------------------------------------
DWORD WINAPI
TVOCacheHashOriginIdentifier (PCRYPT_DATA_BLOB pIdentifier)
{
    DWORD Hash;

    assert( pIdentifier->cbData == MD5DIGESTLEN );

    memcpy( &Hash, pIdentifier->pbData, sizeof( DWORD ) );

    return( Hash );
}

//+---------------------------------------------------------------------------
//
//  Function:   TVOCacheOnRemoval
//
//  Synopsis:   removal notification callback
//
//----------------------------------------------------------------------------
VOID WINAPI
TVOCacheOnRemoval (LPVOID pvData, LPVOID pvRemovalContext)
{
    ObjectContextFreeTVOCacheEntry( (PTVO_CACHE_ENTRY)pvData );
}

//+---------------------------------------------------------------------------
//
//  Member:     CTVOAgent::CTVOAgent, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CTVOAgent::CTVOAgent (
               DWORD cCacheBuckets,
               DWORD MaxCacheEntries,
               BOOL& rfResult
               )
              : m_Cache( cCacheBuckets, MaxCacheEntries, rfResult )
{
    if (!Pki_InitializeCriticalSection( &m_Lock ))
    {
        rfResult = FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CTVOAgent::~CTVOAgent, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CTVOAgent::~CTVOAgent ()
{
    m_Cache.RemoveAllCacheEntries();

    DeleteCriticalSection( &m_Lock );
}

//+---------------------------------------------------------------------------
//
//  Member:     CTVOAgent::GetTimeValidObject, public
//
//  Synopsis:   get a time valid CAPI2 object
//
//----------------------------------------------------------------------------
BOOL
CTVOAgent::GetTimeValidObject (
              IN LPCSTR pszTimeValidOid,
              IN LPVOID pvPara,
              IN LPCSTR pszContextOid,
              IN PCCERT_CONTEXT pIssuer,
              IN LPFILETIME pftValidFor,
              IN DWORD dwFlags,
              IN DWORD dwTimeout,
              OUT OPTIONAL LPVOID* ppvObject,
              IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
              IN OPTIONAL LPVOID pvReserved
              )
{
    BOOL                    fResult = TRUE;
    CRYPT_ORIGIN_IDENTIFIER OriginIdentifier;
    PTVO_CACHE_ENTRY        pCacheEntry = NULL;
    DWORD                   PreferredUrlIndex = 0;
    PCRYPT_URL_ARRAY        pUrlArray = NULL;
    DWORD                   cb = 0;
    DWORD                   cbUrlArray = 0;
    PCRYPT_URL_ARRAY        pCacheUrlArray = NULL;
    LPWSTR                  pwszUrlHint = NULL;
    BOOL                    fHintInArray = FALSE;
    BOOL                    fArrayOwned = FALSE;

    BOOL                    fCrlFromCert = FALSE;
    LPCSTR                  pszUrlOidCrlFromCert = NULL;
    LPVOID                  pvSubject = NULL;
    BOOL                    fFreshest = FALSE;

    if ( pszTimeValidOid == TIME_VALID_OID_GET_CRL_FROM_CERT )
    {
        fCrlFromCert = TRUE;
        pszUrlOidCrlFromCert = URL_OID_CERTIFICATE_CRL_DIST_POINT;
        pvSubject = pvPara;
    }
    else if ( pszTimeValidOid == TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CERT )
    {
        fCrlFromCert = TRUE;
        pszUrlOidCrlFromCert = URL_OID_CERTIFICATE_FRESHEST_CRL;
        pvSubject = pvPara;
        fFreshest = TRUE;
    }
    else if ( pszTimeValidOid == TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CRL )
    {
        fCrlFromCert = TRUE;
        pszUrlOidCrlFromCert = URL_OID_CRL_FRESHEST_CRL;
        pvSubject = (LPVOID) ((PCCERT_CRL_CONTEXT_PAIR)pvPara)->pCertContext;
        fFreshest = TRUE;
    }

    if (fCrlFromCert)
    {
        if ( CrlGetOriginIdentifierFromSubjectCert(
                   (PCCERT_CONTEXT)pvSubject,
                   pIssuer,
                   fFreshest,
                   OriginIdentifier
                   ) == FALSE )
        {
            return( FALSE );
        }

        assert( pszContextOid == CONTEXT_OID_CRL );
    }
    else
    {
        if ( ObjectContextGetOriginIdentifier(
                   pszContextOid,
                   pvPara,
                   pIssuer,
                   0,
                   OriginIdentifier
                   ) == FALSE )
        {
            return( FALSE );
        }
    }

    PreferredUrlIndex = 0;
    pUrlArray = NULL;

    EnterCriticalSection( &m_Lock );

    pCacheEntry = m_Cache.FindCacheEntry(
        OriginIdentifier,
        pszContextOid,
        pvSubject
        );

    if ( pCacheEntry != NULL )
    {
        if ( !( dwFlags & CRYPT_WIRE_ONLY_RETRIEVAL ) )
        {
            if ( ( dwFlags & CRYPT_DONT_CHECK_TIME_VALIDITY ) ||
                        IsValidCreateOrExpireTime (
                              0 != (dwFlags & CRYPT_CHECK_FRESHNESS_TIME_VALIDITY),
                              pftValidFor,
                              &pCacheEntry->CreateTime,
                              &pCacheEntry->ExpireTime ) )
            {
                m_Cache.TouchCacheEntry( pCacheEntry );

                if ( ppvObject != NULL )
                {
                    *ppvObject = ObjectContextDuplicate(
                                       pCacheEntry->pszContextOid,
                                       pCacheEntry->pvContext
                                       );
                }

                LeaveCriticalSection( &m_Lock );

                return( TRUE );
            }
        }

        if ( !( dwFlags & CRYPT_CACHE_ONLY_RETRIEVAL ) )
        {
            if ( GetOfflineUrlTimeStatus(&pCacheEntry->OfflineUrlTimeInfo) < 0
                            ||
                    !I_CryptNetIsConnected() )
            {
                if ( dwFlags & CRYPT_WIRE_ONLY_RETRIEVAL )
                {
                    LeaveCriticalSection( &m_Lock );
                    SetLastError( (DWORD) ERROR_NOT_CONNECTED );
                    return( FALSE );
                }
                else
                {
                    dwFlags |= CRYPT_CACHE_ONLY_RETRIEVAL;
                }
            }
        }

        if ( pCacheEntry->pUrlArrayNext != NULL )
        {
            cbUrlArray = pCacheEntry->cbUrlArrayNext;
            pCacheUrlArray = pCacheEntry->pUrlArrayNext;
            PreferredUrlIndex = pCacheEntry->UrlIndexNext;
        }
        else
        {
            cbUrlArray = pCacheEntry->cbUrlArrayThis;
            pCacheUrlArray = pCacheEntry->pUrlArrayThis;
            PreferredUrlIndex = pCacheEntry->UrlIndexThis;
        }
    }
    else if ( !( dwFlags & CRYPT_CACHE_ONLY_RETRIEVAL ) )
    {
        if ( !I_CryptNetIsConnected() )
        {
            if ( dwFlags & CRYPT_WIRE_ONLY_RETRIEVAL )
            {
                LeaveCriticalSection( &m_Lock );
                SetLastError( (DWORD) ERROR_NOT_CONNECTED );
                return( FALSE );
            }
            else
            {
                dwFlags |= CRYPT_CACHE_ONLY_RETRIEVAL;
            }
        }
    }

    if ( ( fResult == TRUE ) && ( pUrlArray == NULL ) )
    {
        if ( pCacheEntry != NULL )
        {
            pwszUrlHint = pCacheUrlArray->rgwszUrl[ PreferredUrlIndex ];
        }

        if ( fCrlFromCert )
        {
            fResult = CertificateGetCrlDistPointUrl(
                                 pszUrlOidCrlFromCert,
                                 pvPara,
                                 pwszUrlHint,
                                 &pUrlArray,
                                 &cb,
                                 &PreferredUrlIndex,
                                 &fHintInArray
                                 );
        }
        else if ( pszTimeValidOid == TIME_VALID_OID_GET_CTL )
        {
            fResult = ObjectContextGetNextUpdateUrl(
                            pszContextOid,
                            pvPara,
                            pIssuer,
                            pwszUrlHint,
                            &pUrlArray,
                            &cb,
                            &PreferredUrlIndex,
                            &fHintInArray
                            );
        }
        else
        {
            SetLastError( (DWORD) CRYPT_E_NOT_FOUND );
            fResult = FALSE;
        }

        if ( fResult == TRUE )
        {
            cbUrlArray = cb;
        }
        else if ( pCacheEntry != NULL )
        {
            pUrlArray = (PCRYPT_URL_ARRAY)new BYTE [ cbUrlArray ];
            if ( pUrlArray != NULL )
            {
                CopyUrlArray( pUrlArray, pCacheUrlArray, cbUrlArray );
                fHintInArray = TRUE;
                fResult = TRUE;
            }
            else
            {
                SetLastError( (DWORD) E_OUTOFMEMORY );
            }
        }
    }

    LeaveCriticalSection( &m_Lock );

    if ( fResult == TRUE )
    {
        fResult = GetTimeValidObjectByUrl(
                     cbUrlArray,
                     pUrlArray,
                     PreferredUrlIndex,
                     pszContextOid,
                     pIssuer,
                     pvSubject,
                     OriginIdentifier,
                     pftValidFor,
                     dwFlags,
                     dwTimeout,
                     ppvObject,
                     pCredentials,
                     ( fHintInArray == TRUE ) ? NULL : pwszUrlHint,
                     &fArrayOwned,
                     pvReserved
                     );
    }

    if ( fArrayOwned == FALSE )
    {
        delete pUrlArray;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CTVOAgent::GetTimeValidObjectByUrl, public
//
//  Synopsis:   get a time valid object using URL
//
//----------------------------------------------------------------------------
BOOL
CTVOAgent::GetTimeValidObjectByUrl (
              IN DWORD cbUrlArray,
              IN PCRYPT_URL_ARRAY pUrlArray,
              IN DWORD PreferredUrlIndex,
              IN LPCSTR pszContextOid,
              IN PCCERT_CONTEXT pIssuer,
              IN LPVOID pvSubject,
              IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
              IN LPFILETIME pftValidFor,
              IN DWORD dwFlags,
              IN DWORD dwTimeout,
              OUT OPTIONAL LPVOID* ppvObject,
              IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
              IN OPTIONAL LPWSTR pwszUrlExtra,
              OUT BOOL* pfArrayOwned,
              IN OPTIONAL LPVOID pvReserved
              )
{
    BOOL             fResult = FALSE;
    DWORD            cCount;
    LPWSTR           pwsz;
    LPVOID           pvContext = NULL;
    PTVO_CACHE_ENTRY pEntry = NULL;
    PTVO_CACHE_ENTRY pFound;
    DWORD            LastError;

    // Following is only used for CRYPT_ACCUMULATIVE_TIMEOUT
    FILETIME ftEndUrlRetrieval;

    if ( PreferredUrlIndex != 0 )
    {
        pwsz = pUrlArray->rgwszUrl[PreferredUrlIndex];
        pUrlArray->rgwszUrl[PreferredUrlIndex] = pUrlArray->rgwszUrl[0];
        pUrlArray->rgwszUrl[0] = pwsz;
    }

    if (dwFlags & CRYPT_ACCUMULATIVE_TIMEOUT)
    {
        if (0 == dwTimeout)
        {
            dwFlags &= ~CRYPT_ACCUMULATIVE_TIMEOUT;
        }
        else
        {
            FILETIME ftStartUrlRetrieval;

            GetSystemTimeAsFileTime(&ftStartUrlRetrieval);
            I_CryptIncrementFileTimeByMilliseconds(
                &ftStartUrlRetrieval, dwTimeout,
                &ftEndUrlRetrieval);
        }
    }

    for ( cCount = 0; cCount < pUrlArray->cUrl; cCount++ )
    {
        if (dwFlags & CRYPT_ACCUMULATIVE_TIMEOUT)
        {
            // Limit each URL timeout to half of the remaining time
            dwTimeout = I_CryptRemainingMilliseconds(&ftEndUrlRetrieval) / 2;
            if (0 == dwTimeout)
            {
                dwTimeout = 1;
            }
        }

        fResult = RetrieveTimeValidObjectByUrl(
                          pUrlArray->rgwszUrl[cCount],
                          pszContextOid,
                          pftValidFor,
                          dwFlags,
                          dwTimeout,
                          pCredentials,
                          pIssuer,
                          pvSubject,
                          OriginIdentifier,
                          &pvContext
                          );

        if ( fResult == TRUE )
        {
            fResult = ObjectContextCreateTVOCacheEntry(
                            m_Cache.LruCacheHandle(),
                            pszContextOid,
                            pvContext,
                            OriginIdentifier,
                            cbUrlArray,
                            pUrlArray,
                            cCount,
                            pIssuer,
                            &pEntry
                            );

            *pfArrayOwned = fResult;
            break;
        }
    }

    if ( ( PreferredUrlIndex != 0 ) && ( *pfArrayOwned == FALSE ) )
    {
        pwsz = pUrlArray->rgwszUrl[PreferredUrlIndex];
        pUrlArray->rgwszUrl[PreferredUrlIndex] = pUrlArray->rgwszUrl[0];
        pUrlArray->rgwszUrl[0] = pwsz;
    }

    if ( ( fResult == FALSE ) && ( pwszUrlExtra != NULL ) )
    {
        if (dwFlags & CRYPT_ACCUMULATIVE_TIMEOUT)
        {
            // Limit each URL timeout to half of the remaining time
            dwTimeout = I_CryptRemainingMilliseconds(&ftEndUrlRetrieval) / 2;
            if (0 == dwTimeout)
            {
                dwTimeout = 1;
            }
        }

        fResult = RetrieveTimeValidObjectByUrl(
                          pwszUrlExtra,
                          pszContextOid,
                          pftValidFor,
                          dwFlags,
                          dwTimeout,
                          pCredentials,
                          pIssuer,
                          pvSubject,
                          OriginIdentifier,
                          &pvContext
                          );

        if ( fResult == TRUE )
        {
            CCryptUrlArray   cua( pUrlArray->cUrl + 1, 5, fResult );
            DWORD            cb = 0;
            PCRYPT_URL_ARRAY pcua = NULL;

            if ( fResult == TRUE )
            {
                for ( cCount = 0; cCount < pUrlArray->cUrl; cCount++ )
                {
                    fResult = cua.AddUrl( pUrlArray->rgwszUrl[cCount], FALSE );
                    if ( fResult == FALSE )
                    {
                        break;
                    }
                }
            }

            if ( fResult == TRUE )
            {
                fResult = cua.GetArrayInSingleBufferEncodedForm(
                                 &pcua,
                                 &cb
                                 );
            }

            if ( fResult == TRUE )
            {
                fResult = ObjectContextCreateTVOCacheEntry(
                                m_Cache.LruCacheHandle(),
                                pszContextOid,
                                pvContext,
                                OriginIdentifier,
                                cb,
                                pcua,
                                pUrlArray->cUrl,
                                pIssuer,
                                &pEntry
                                );

                if ( fResult == FALSE )
                {
                    CryptMemFree( pcua );
                }
            }

            cua.FreeArray( FALSE );
        }
    }

    LastError = GetLastError();

    EnterCriticalSection( &m_Lock );

    pFound = m_Cache.FindCacheEntry(
        OriginIdentifier,
        pszContextOid,
        pvSubject
        );

    if ( !fResult && pFound && !( dwFlags & CRYPT_CACHE_ONLY_RETRIEVAL ) )
    {
        SetOfflineUrlTime( &pFound->OfflineUrlTimeInfo );
    }

    if ( ( fResult == TRUE ) && !( dwFlags & CRYPT_DONT_VERIFY_SIGNATURE ) )
    {
        if ( ( pFound != NULL ) &&
             ( CompareFileTime(
                      &pFound->CreateTime,
                      &pEntry->CreateTime
                      ) >= 0 ) )
        {
            ObjectContextFree( pszContextOid, pvContext );

            pvContext = ObjectContextDuplicate(
                              pFound->pszContextOid,
                              pFound->pvContext
                              );

            SetOnlineUrlTime( &pFound->OfflineUrlTimeInfo );

            ObjectContextFreeTVOCacheEntry( pEntry );
        }
        else
        {
            if ( pFound != NULL )
            {
                m_Cache.RemoveCacheEntry( pFound );
            }

            m_Cache.InsertCacheEntry( pEntry );
        }

    }
    else if ( pEntry != NULL )
    {
        ObjectContextFreeTVOCacheEntry( pEntry );
    }

    LeaveCriticalSection( &m_Lock );

    if ( pvContext != NULL )
    {
        if ( ( ppvObject != NULL ) && ( fResult == TRUE ) )
        {
            *ppvObject = pvContext;
        }
        else
        {
            ObjectContextFree( pszContextOid, pvContext );
        }
    }

    SetLastError( LastError );
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CTVOAgent::FlushTimeValidObject, public
//
//  Synopsis:   flush time valid object
//
//----------------------------------------------------------------------------
BOOL
CTVOAgent::FlushTimeValidObject (
                IN LPCSTR pszFlushTimeValidOid,
                IN LPVOID pvPara,
                IN LPCSTR pszFlushContextOid,
                IN PCCERT_CONTEXT pIssuer,
                IN DWORD dwFlags,
                IN LPVOID pvReserved
                )
{
    BOOL                    fResult = TRUE;
    CRYPT_ORIGIN_IDENTIFIER OriginIdentifier;
    PTVO_CACHE_ENTRY        pCacheEntry = NULL;
    PCRYPT_URL_ARRAY        pUrlArray = NULL;
    DWORD                   cbUrlArray;
    DWORD                   dwError = 0;
    DWORD                   cCount;

    BOOL                    fCrlFromCert = FALSE;
    LPCSTR                  pszUrlOidCrlFromCert = NULL;
    LPVOID                  pvSubject = NULL;
    BOOL                    fFreshest = FALSE;

    if ( pszFlushTimeValidOid == TIME_VALID_OID_GET_CRL_FROM_CERT )
    {
        fCrlFromCert = TRUE;
        pszUrlOidCrlFromCert = URL_OID_CERTIFICATE_CRL_DIST_POINT;
        pvSubject = pvPara;
    }
    else if ( pszFlushTimeValidOid == TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CERT )
    {
        fCrlFromCert = TRUE;
        pszUrlOidCrlFromCert = URL_OID_CERTIFICATE_FRESHEST_CRL;
        pvSubject = pvPara;
        fFreshest = TRUE;
    }
    else if ( pszFlushTimeValidOid == TIME_VALID_OID_GET_FRESHEST_CRL_FROM_CRL )
    {
        fCrlFromCert = TRUE;
        pszUrlOidCrlFromCert = URL_OID_CRL_FRESHEST_CRL;
        pvSubject = (LPVOID) ((PCCERT_CRL_CONTEXT_PAIR)pvPara)->pCertContext;
        fFreshest = TRUE;
    }

    if (fCrlFromCert)
    {
        if ( CrlGetOriginIdentifierFromSubjectCert(
                   (PCCERT_CONTEXT)pvSubject,
                   pIssuer,
                   fFreshest,
                   OriginIdentifier
                   ) == FALSE )
        {
            return( FALSE );
        }

        assert( pszFlushContextOid == CONTEXT_OID_CRL );
    }
    else
    {
        if ( ObjectContextGetOriginIdentifier(
                   pszFlushContextOid,
                   pvPara,
                   pIssuer,
                   0,
                   OriginIdentifier
                   ) == FALSE )
        {
            return( FALSE );
        }
    }

    EnterCriticalSection( &m_Lock );

    pCacheEntry = m_Cache.FindCacheEntry(
        OriginIdentifier,
        pszFlushContextOid,
        pvSubject
        );

    if ( pCacheEntry != NULL )
    {
        // Remove the entry but suppress the freeing of it since we are going
        // to use the data structure later
        m_Cache.RemoveCacheEntry( pCacheEntry, TRUE );
    }

    LeaveCriticalSection( &m_Lock );

    if ( pCacheEntry != NULL )
    {
        if ( pCacheEntry->pUrlArrayThis != NULL )
        {
            for ( cCount = 0;
                  cCount < pCacheEntry->pUrlArrayThis->cUrl;
                  cCount++ )
            {
                if ( ( SchemeDeleteUrlCacheEntry(
                             pCacheEntry->pUrlArrayThis->rgwszUrl[cCount]
                             ) == FALSE ) &&
                     ( GetLastError() != ERROR_FILE_NOT_FOUND ) )
                {
                    dwError = GetLastError();
                }
            }
        }

        if ( pCacheEntry->pUrlArrayNext != NULL )
        {
            for ( cCount = 0;
                  cCount < pCacheEntry->pUrlArrayNext->cUrl;
                  cCount++ )
            {
                if ( ( SchemeDeleteUrlCacheEntry(
                             pCacheEntry->pUrlArrayNext->rgwszUrl[cCount]
                             ) == FALSE ) &&
                     ( GetLastError() != ERROR_FILE_NOT_FOUND ) )
                {
                    dwError = GetLastError();
                }
            }
        }

        //
        //         Can place optimization here where if the hashes of the
        //         cache object and the passed in object are the same,
        //         we don't need to do any more work
        //

        ObjectContextFreeTVOCacheEntry( pCacheEntry );
    }

    if ( fCrlFromCert )
    {
        fResult = CertificateGetCrlDistPointUrl(
                             pszUrlOidCrlFromCert,
                             pvPara,
                             NULL,                      // pwszUrlHint
                             &pUrlArray,
                             &cbUrlArray,
                             NULL,                      // pPreferredUrlIndex
                             NULL                       // pfHintInArray
                             );
    }
    else if ( pszFlushTimeValidOid == TIME_VALID_OID_GET_CTL )
    {
        fResult = ObjectContextGetNextUpdateUrl(
                        pszFlushContextOid,
                        pvPara,
                        pIssuer,
                        NULL,
                        &pUrlArray,
                        &cbUrlArray,
                        NULL,
                        NULL
                        );
    }

    if ( ( fResult == TRUE ) && ( pUrlArray != NULL ) )
    {
        for ( cCount = 0; cCount < pUrlArray->cUrl; cCount++ )
        {
            if ( ( SchemeDeleteUrlCacheEntry(
                         pUrlArray->rgwszUrl[cCount]
                         ) == FALSE ) &&
                 ( GetLastError() != ERROR_FILE_NOT_FOUND ) )
            {
                dwError = GetLastError();
            }
        }
    }

    if ( ( fResult == TRUE ) && ( dwError != 0 ) )
    {
        SetLastError( dwError );
        fResult = FALSE;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   IsValidCreateOrExpireTime
//
//  Synopsis:   for fCheckFreshnessTime, checks if the
//              specified time is before or the same as the create time.
//              Otherwise, checks if the specified time is before or the
//              same as the expire time. A zero expire time matches any time.
//
//----------------------------------------------------------------------------
BOOL WINAPI
IsValidCreateOrExpireTime (
    IN BOOL fCheckFreshnessTime,
    IN LPFILETIME pftValidFor,
    IN LPFILETIME pftCreateTime,
    IN LPFILETIME pftExpireTime
    )
{
    if (fCheckFreshnessTime) {
        if (CompareFileTime(pftValidFor, pftCreateTime) <= 0)
            return TRUE;
        else
            return FALSE;
    } else {
        if (CompareFileTime(pftValidFor, pftExpireTime) <= 0 ||
                I_CryptIsZeroFileTime(pftExpireTime))
            return TRUE;
        else
            return FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextCreateTVOCacheEntry
//
//  Synopsis:   create a TVO cache entry
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextCreateTVOCacheEntry (
      IN HLRUCACHE hCache,
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
      IN DWORD cbUrlArrayThis,
      IN PCRYPT_URL_ARRAY pUrlArrayThis,
      IN DWORD UrlIndexThis,
      IN PCCERT_CONTEXT pIssuer,
      OUT PTVO_CACHE_ENTRY* ppEntry
      )
{
    BOOL             fResult = TRUE;
    PTVO_CACHE_ENTRY pEntry;
    CRYPT_DATA_BLOB  DataBlob;

    pEntry = new TVO_CACHE_ENTRY;
    if ( pEntry == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    memset( pEntry, 0, sizeof( TVO_CACHE_ENTRY ) );

    // NOTENOTE: This presumes a predefined context oid constant
    pEntry->pszContextOid = pszContextOid;
    pEntry->pvContext = ObjectContextDuplicate( pszContextOid, pvContext );
    memcpy(pEntry->OriginIdentifier, OriginIdentifier,
        sizeof(pEntry->OriginIdentifier));

    DataBlob.cbData = MD5DIGESTLEN;
    DataBlob.pbData = pEntry->OriginIdentifier;

    fResult = I_CryptCreateLruEntry(
                     hCache,
                     &DataBlob,
                     pEntry,
                     &pEntry->hLruEntry
                     );

    if ( fResult == TRUE )
    {
        ObjectContextGetNextUpdateUrl(
              pszContextOid,
              pvContext,
              pIssuer,
              pUrlArrayThis->rgwszUrl[UrlIndexThis],
              &pEntry->pUrlArrayNext,
              &pEntry->cbUrlArrayNext,
              &pEntry->UrlIndexNext,
              NULL
              );

        fResult = ObjectContextGetCreateAndExpireTimes(
                        pszContextOid,
                        pvContext,
                        &pEntry->CreateTime,
                        &pEntry->ExpireTime
                        );
    }

    if ( fResult == TRUE )
    {
        pEntry->cbUrlArrayThis = cbUrlArrayThis;
        pEntry->pUrlArrayThis = pUrlArrayThis;
        pEntry->UrlIndexThis = UrlIndexThis;

        *ppEntry = pEntry;
    }
    else
    {
        ObjectContextFreeTVOCacheEntry( pEntry );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextFreeTVOCacheEntry
//
//  Synopsis:   free TVO cache entry
//
//----------------------------------------------------------------------------
VOID WINAPI
ObjectContextFreeTVOCacheEntry (
      IN PTVO_CACHE_ENTRY pEntry
      )
{
    if ( pEntry->hLruEntry != NULL )
    {
        I_CryptReleaseLruEntry( pEntry->hLruEntry );
    }

    delete pEntry->pUrlArrayThis;
    delete pEntry->pUrlArrayNext;

    if ( pEntry->pvContext != NULL )
    {
        ObjectContextFree( pEntry->pszContextOid, pEntry->pvContext );
    }

    delete pEntry;
}


//+---------------------------------------------------------------------------
//
//  Function:   CertificateGetCrlDistPointUrl
//
//  Synopsis:   get crl dist point URL from certificate
//
//----------------------------------------------------------------------------
BOOL WINAPI
CertificateGetCrlDistPointUrl (
           IN LPCSTR pszUrlOid,
           IN LPVOID pvPara,
           IN LPWSTR pwszUrlHint,
           OUT PCRYPT_URL_ARRAY* ppUrlArray,
           OUT DWORD* pcbUrlArray,
           OUT DWORD* pPreferredUrlIndex,
           OUT BOOL* pfHintInArray
           )
{
    BOOL             fResult;
    DWORD            cbUrlArray;
    PCRYPT_URL_ARRAY pUrlArray = NULL;
    DWORD            PreferredUrlIndex;

    fResult = CryptGetObjectUrl(
                   pszUrlOid,
                   pvPara,
                   0,
                   NULL,
                   &cbUrlArray,
                   NULL,
                   NULL,
                   NULL
                   );

    if ( fResult == TRUE )
    {
        pUrlArray = (PCRYPT_URL_ARRAY)new BYTE [ cbUrlArray ];
        if ( pUrlArray != NULL )
        {
            fResult = CryptGetObjectUrl(
                           pszUrlOid,
                           pvPara,
                           0,
                           pUrlArray,
                           &cbUrlArray,
                           NULL,
                           NULL,
                           NULL
                           );
        }
        else
        {
            SetLastError( (DWORD) E_OUTOFMEMORY );
            fResult = FALSE;
        }
    }

    if ( fResult == TRUE )
    {
        BOOL fHintInArray = FALSE;

        GetUrlArrayIndex(
           pUrlArray,
           pwszUrlHint,
           0,
           &PreferredUrlIndex,
           &fHintInArray
           );

        *ppUrlArray = pUrlArray;
        *pcbUrlArray = cbUrlArray;

        if ( pfHintInArray != NULL )
        {
            *pfHintInArray = fHintInArray;
        }

        if ( pPreferredUrlIndex != NULL )
        {
            *pPreferredUrlIndex = PreferredUrlIndex;
        }
    }
    else
    {
        if ( pUrlArray )
        {
            delete pUrlArray;
        }
    }

    return( fResult );
}

BOOL WINAPI
RetrieveObjectByUrlValidForSubject(
        IN LPWSTR pwszUrl,
        IN LPCSTR pszContextOid,
        IN BOOL fCheckFreshnessTime,
        IN LPFILETIME pftValidFor,
        IN DWORD dwRetrievalFlags,
        IN DWORD dwTimeout,
        IN PCRYPT_CREDENTIALS pCredentials,
        IN PCCERT_CONTEXT pSigner,
        IN LPVOID pvSubject,
        IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
        OUT LPVOID* ppvObject
        )
{
    BOOL fResult;
    HCERTSTORE hUrlStore = NULL;
    LPVOID pvObject;

    fResult = CryptRetrieveObjectByUrlW(
        pwszUrl,
        pszContextOid,
        (dwRetrievalFlags | 
                CRYPT_RETRIEVE_MULTIPLE_OBJECTS |
                CRYPT_LDAP_SCOPE_BASE_ONLY_RETRIEVAL) &
            ~CRYPT_VERIFY_CONTEXT_SIGNATURE,
        dwTimeout,
        (LPVOID *) &hUrlStore,
        NULL,                               // hAsyncRetrieve
        NULL,                               // pCredentials
        NULL,                               // pSigner
        NULL                                // pvReserved
        );

    if (!fResult)
        goto CommonReturn;

    pvObject = NULL;
    while (pvObject = ObjectContextEnumObjectsInStore (
            hUrlStore,
            pszContextOid,
            pvObject
            ))
    {
        CRYPT_ORIGIN_IDENTIFIER ObjectOriginIdentifier;

        if (!ObjectContextGetOriginIdentifier(
                    pszContextOid,
                    pvObject,
                    pSigner,
                    0,
                    ObjectOriginIdentifier
                    ))
            continue;

        if (0 != memcmp(OriginIdentifier, ObjectOriginIdentifier,
                sizeof(ObjectOriginIdentifier)))
            continue;

        if (dwRetrievalFlags & CRYPT_VERIFY_CONTEXT_SIGNATURE) {
            if (!ObjectContextVerifySignature (
                    pszContextOid,
                    pvObject,
                    pSigner
                    ))
                continue;
        }

        if (!ObjectContextIsValidForSubject (
                pszContextOid,
                pvObject,
                pvSubject
                ))
            continue;

        if (NULL != pftValidFor) {
            FILETIME CreateTime;
            FILETIME ExpireTime;

            if (!ObjectContextGetCreateAndExpireTimes(
                    pszContextOid,
                    pvObject,
                    &CreateTime,
                    &ExpireTime
                    ))
                continue;

            if (!IsValidCreateOrExpireTime (
                    fCheckFreshnessTime,
                    pftValidFor,
                    &CreateTime,
                    &ExpireTime ) )
                continue;
        }

        *ppvObject = pvObject;
        fResult = TRUE;
        goto CommonReturn;
    }

    fResult = FALSE;

CommonReturn:
    if (hUrlStore)
        CertCloseStore(hUrlStore, 0);
    return fResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   RetrieveTimeValidObjectByUrl
//
//  Synopsis:   retrieve a time valid object given an URL
//
//----------------------------------------------------------------------------
BOOL WINAPI
RetrieveTimeValidObjectByUrl (
        IN LPWSTR pwszUrl,
        IN LPCSTR pszContextOid,
        IN LPFILETIME pftValidFor,
        IN DWORD dwFlags,
        IN DWORD dwTimeout,
        IN PCRYPT_CREDENTIALS pCredentials,
        IN PCCERT_CONTEXT pSigner,
        IN LPVOID pvSubject,
        IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
        OUT LPVOID* ppvObject
        )
{
    BOOL     fResult = FALSE;
    LPVOID   pvContext = NULL;
    DWORD    dwVerifyFlags = 0;
    DWORD    dwCacheStoreFlags = CRYPT_DONT_CACHE_RESULT;

    if ( dwFlags & CRYPT_DONT_CHECK_TIME_VALIDITY )
    {
        pftValidFor = NULL;
    }

    if ( !( dwFlags & CRYPT_DONT_VERIFY_SIGNATURE ) )
    {
        dwVerifyFlags |= CRYPT_VERIFY_CONTEXT_SIGNATURE;
        dwCacheStoreFlags &= ~CRYPT_DONT_CACHE_RESULT;
    }

    if ( !( dwFlags & CRYPT_WIRE_ONLY_RETRIEVAL ) )
    {
        fResult = RetrieveObjectByUrlValidForSubject(
                       pwszUrl,
                       pszContextOid,
                       0 != (dwFlags & CRYPT_CHECK_FRESHNESS_TIME_VALIDITY),
                       pftValidFor,
                       CRYPT_CACHE_ONLY_RETRIEVAL |
                           dwVerifyFlags,
                       0,                               // dwTimeout
                       NULL,                            // pCredentials
                       pSigner,
                       pvSubject,
                       OriginIdentifier,
                       &pvContext
                       );
    }

    if ( fResult == FALSE )
    {
        if ( !( dwFlags & CRYPT_CACHE_ONLY_RETRIEVAL ) )
        {
            DWORD dwRetrievalFlags = CRYPT_WIRE_ONLY_RETRIEVAL |
                                       dwCacheStoreFlags |
                                       dwVerifyFlags;

            LONG lStatus;

            //  +1 - Online
            //   0 - Offline, current time >= earliest online time, hit the wire
            //  -1 - Offline, current time < earliest onlime time
            lStatus = GetOriginUrlStatusW(
                            OriginIdentifier,
                            pwszUrl,
                            pszContextOid,
                            dwRetrievalFlags
                            );

            if (lStatus >= 0)
            {
                fResult = RetrieveObjectByUrlValidForSubject(
                           pwszUrl,
                           pszContextOid,
                           0 != (dwFlags & CRYPT_CHECK_FRESHNESS_TIME_VALIDITY),
                           pftValidFor,
                           dwRetrievalFlags,
                           dwTimeout,
                           pCredentials,
                           pSigner,
                           pvSubject,
                           OriginIdentifier,
                           &pvContext
                           );
                if (!fResult)
                {
                    DWORD dwErr = GetLastError();

                    SetOfflineOriginUrlW(
                        OriginIdentifier,
                        pwszUrl,
                        pszContextOid,
                        dwRetrievalFlags
                        );

                    SetLastError( dwErr );
                }
                else if (lStatus == 0)
                {
                    // Remove from offline list
                    SetOnlineOriginUrlW(
                            OriginIdentifier,
                            pwszUrl,
                            pszContextOid,
                            dwRetrievalFlags
                            );
                }
            }

        }
    }

    *ppvObject = pvContext;

    return( fResult );
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateProcessTVOAgent
//
//  Synopsis:   create process TVO agent
//
//----------------------------------------------------------------------------
BOOL WINAPI
CreateProcessTVOAgent (
      OUT CTVOAgent** ppAgent
      )
{
    BOOL       fResult = FALSE;
    HKEY       hKey;
    DWORD      dwType = REG_DWORD;
    DWORD      dwSize = sizeof( DWORD );
    DWORD      cCacheBuckets;
    DWORD      MaxCacheEntries;
    CTVOAgent* pAgent;

    if ( RegOpenKeyA(
            HKEY_LOCAL_MACHINE,
            TVO_KEY_NAME,
            &hKey
            ) == ERROR_SUCCESS )
    {
        if ( RegQueryValueExA(
                hKey,
                TVO_CACHE_BUCKETS_VALUE_NAME,
                NULL,
                &dwType,
                (LPBYTE)&cCacheBuckets,
                &dwSize
                ) != ERROR_SUCCESS )
        {
            cCacheBuckets = TVO_DEFAULT_CACHE_BUCKETS;
        }

        if ( RegQueryValueExA(
                hKey,
                TVO_MAX_CACHE_ENTRIES_VALUE_NAME,
                NULL,
                &dwType,
                (LPBYTE)&MaxCacheEntries,
                &dwSize
                ) != ERROR_SUCCESS )
        {
            MaxCacheEntries = TVO_DEFAULT_MAX_CACHE_ENTRIES;
        }
    }
    else
    {
        cCacheBuckets = TVO_DEFAULT_CACHE_BUCKETS;
        MaxCacheEntries = TVO_DEFAULT_MAX_CACHE_ENTRIES;
    }

    pAgent = new CTVOAgent( cCacheBuckets, MaxCacheEntries, fResult );
    if ( pAgent == NULL )
    {
        SetLastError( (DWORD) E_OUTOFMEMORY );
        return( FALSE );
    }

    if ( fResult == TRUE )
    {
        *ppAgent = pAgent;
    }
    else
    {
        delete pAgent;
    }

    return( fResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\orm.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       orm.cpp
//
//  Contents:   Implementation of object retrieval manager
//
//  History:    24-Jul-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>
//+---------------------------------------------------------------------------
//
//  Member:     CObjectRetrievalManager::CObjectRetrievalManager, public
//
//  Synopsis:   Constructor
//
//----------------------------------------------------------------------------
CObjectRetrievalManager::CObjectRetrievalManager ()
{
    m_cRefs = 1;
    m_hSchemeRetrieve = NULL;
    m_pfnSchemeRetrieve = NULL;
    m_hContextCreate = NULL;
    m_pfnContextCreate = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectRetrievalManager::~CObjectRetrievalManager, public
//
//  Synopsis:   Destructor
//
//----------------------------------------------------------------------------
CObjectRetrievalManager::~CObjectRetrievalManager ()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectRetrievalManager::AddRef, public
//
//  Synopsis:   IRefCountedObject::AddRef
//
//----------------------------------------------------------------------------
VOID
CObjectRetrievalManager::AddRef ()
{
    InterlockedIncrement( (LONG *)&m_cRefs );
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectRetrievalManager::Release, public
//
//  Synopsis:   IRefCountedObject::Release
//
//----------------------------------------------------------------------------
VOID
CObjectRetrievalManager::Release ()
{
    if ( InterlockedDecrement( (LONG *)&m_cRefs ) == 0 )
    {
        delete this;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectRetrievalManager::RetrieveObjectByUrl, public
//
//  Synopsis:   object retrieval given an URL
//
//----------------------------------------------------------------------------
BOOL
CObjectRetrievalManager::RetrieveObjectByUrl (
                                 LPCSTR pszUrl,
                                 LPCSTR pszObjectOid,
                                 DWORD dwRetrievalFlags,
                                 DWORD dwTimeout,
                                 LPVOID* ppvObject,
                                 PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                                 LPVOID* ppvFreeContext,
                                 HCRYPTASYNC hAsyncRetrieve,
                                 PCRYPT_CREDENTIALS pCredentials,
                                 LPVOID pvVerify,
                                 PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                                 )
{
    BOOL                          fResult;
    CRYPT_BLOB_ARRAY              cba;
    PFN_FREE_ENCODED_OBJECT_FUNC  pfnFreeObject = NULL;
    LPVOID                        pvFreeContext = NULL;

    assert( ppfnFreeObject == NULL );
    assert( ppvFreeContext == NULL );

    //
    // Validate arguments and initialize the providers
    //

    fResult = ValidateRetrievalArguments(
                      pszUrl,
                      pszObjectOid,
                      dwRetrievalFlags,
                      dwTimeout,
                      ppvObject,
                      hAsyncRetrieve,
                      pCredentials,
                      pvVerify,
                      pAuxInfo
                      );

    if ( fResult == TRUE )
    {
        fResult = LoadProviders( pszUrl, pszObjectOid );
    }

    //
    // For Async support we should prepare here
    //

    //
    // Call the scheme provider to process the retrieval
    //

    if ( fResult == TRUE )
    {
        //  +1 - Online
        //   0 - Offline, current time >= earliest online time, hit the wire
        //  -1 - Offline, current time < earliest onlime time
        LONG lStatus;

        if ( CRYPT_OFFLINE_CHECK_RETRIEVAL ==
                ( dwRetrievalFlags & ( CRYPT_OFFLINE_CHECK_RETRIEVAL |
                                       CRYPT_CACHE_ONLY_RETRIEVAL ) ) )
        {
            lStatus = GetUrlStatusA( pszUrl, pszObjectOid, dwRetrievalFlags );
        }
        else
        {
            lStatus = 1;
        }

        if (lStatus >= 0)
        {
            fResult = CallSchemeRetrieveObjectByUrl(
                            pszUrl,
                            pszObjectOid,
                            dwRetrievalFlags,
                            dwTimeout,
                            &cba,
                            &pfnFreeObject,
                            &pvFreeContext,
                            hAsyncRetrieve,
                            pCredentials,
                            pAuxInfo
                            );
            if ( CRYPT_OFFLINE_CHECK_RETRIEVAL ==
                    ( dwRetrievalFlags & ( CRYPT_OFFLINE_CHECK_RETRIEVAL |
                                           CRYPT_CACHE_ONLY_RETRIEVAL ) ) )
            {
                if ( fResult != TRUE )
                {
                    DWORD dwErr = GetLastError();
                    SetOfflineUrlA( pszUrl, pszObjectOid, dwRetrievalFlags );
                    SetLastError( dwErr );
                }
                else if ( lStatus == 0 )
                {
                    SetOnlineUrlA( pszUrl, pszObjectOid, dwRetrievalFlags );
                }
            }
        }
        else
        {
            SetLastError( (DWORD) ERROR_NOT_CONNECTED );
            fResult = FALSE;
        }
    }

    //
    // If we successfully retrieved the object and this is a synchronous
    // retrieval, then we call our own OnRetrievalCompletion in order
    // to complete the processing
    //

    if ( ( fResult == TRUE ) && !( dwRetrievalFlags & CRYPT_ASYNC_RETRIEVAL ) )
    {
        fResult = OnRetrievalCompletion(
                             S_OK,
                             pszUrl,
                             pszObjectOid,
                             dwRetrievalFlags,
                             &cba,
                             pfnFreeObject,
                             pvFreeContext,
                             pvVerify,
                             ppvObject
                             );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectRetrievalManager::CancelAsyncRetrieval, public
//
//  Synopsis:   cancel asynchronous retrieval
//
//----------------------------------------------------------------------------
BOOL
CObjectRetrievalManager::CancelAsyncRetrieval ()
{
    SetLastError( (DWORD) E_NOTIMPL );
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectRetrievalManager::OnRetrievalCompletion, public
//
//  Synopsis:   completion notification
//
//----------------------------------------------------------------------------
BOOL
CObjectRetrievalManager::OnRetrievalCompletion (
                                    DWORD dwCompletionCode,
                                    LPCSTR pszUrl,
                                    LPCSTR pszObjectOid,
                                    DWORD dwRetrievalFlags,
                                    PCRYPT_BLOB_ARRAY pObject,
                                    PFN_FREE_ENCODED_OBJECT_FUNC pfnFreeObject,
                                    LPVOID pvFreeContext,
                                    LPVOID pvVerify,
                                    LPVOID* ppvObject
                                    )
{
    BOOL fResult = FALSE;

    //
    // If the retrieval was successfully completed, we go about getting the
    // appropriate return value for *ppvObject.  If an OID was given then
    // we must use the context provider to convert the encoded bits into
    // a context value.  Otherwise, we hand back a buffer with the encoded
    // bits
    //

    if ( dwCompletionCode == (DWORD)S_OK )
    {
        if ( pszObjectOid != NULL )
        {
            fResult = CallContextCreateObjectContext(
                                 pszObjectOid,
                                 dwRetrievalFlags,
                                 pObject,
                                 ppvObject
                                 );

            if ( fResult == TRUE )
            {
                if ( dwRetrievalFlags & CRYPT_VERIFY_CONTEXT_SIGNATURE )
                {
                    fResult = ObjectContextVerifySignature(
                                    pszObjectOid,
                                    *ppvObject,
                                    (PCCERT_CONTEXT)pvVerify
                                    );
                }
            }
        }
        else
        {
            CCryptBlobArray cba( pObject, 0 );

            fResult = cba.GetArrayInSingleBufferEncodedForm(
                                  (PCRYPT_BLOB_ARRAY *)ppvObject
                                  );
        }

        ( *pfnFreeObject )( pszObjectOid, pObject, pvFreeContext );
    }

    //
    // We can now unload the providers
    //

    UnloadProviders();

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectRetrievalManager::ValidateRetrievalArguments, private
//
//  Synopsis:   validate arguments to RetrieveObjectByUrl
//
//----------------------------------------------------------------------------
BOOL
CObjectRetrievalManager::ValidateRetrievalArguments (
                                 LPCSTR pszUrl,
                                 LPCSTR pszObjectOid,
                                 DWORD dwRetrievalFlags,
                                 DWORD dwTimeout,
                                 LPVOID* ppvObject,
                                 HCRYPTASYNC hAsyncRetrieve,
                                 PCRYPT_CREDENTIALS pCredentials,
                                 LPVOID pvVerify,
                                 PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                                 )
{
    //
    // Assume badness :-)
    //

    SetLastError( (DWORD) E_INVALIDARG );

    //
    // Must have an URL
    //
    //         It is possible that this will be ok in the async case
    //         and the URLs will be parameters on the HCRYPTASYNC
    //

    if ( pszUrl == NULL )
    {
        return( FALSE );
    }

    //
    // NOTENOTE: For now we fail async support and I know that I have
    //           other async flag checks below, they are there as a
    //           reminder :-)
    //

    if ( dwRetrievalFlags & CRYPT_ASYNC_RETRIEVAL )
    {
        return( FALSE );
    }

    //
    // If we retrieve from the cache then we can't be async
    //

    if ( ( dwRetrievalFlags & CRYPT_CACHE_ONLY_RETRIEVAL ) &&
         ( dwRetrievalFlags & CRYPT_ASYNC_RETRIEVAL ) )
    {
        return( FALSE );
    }

    //
    // If we retrieve from the wire we can't be only retrieving from the
    // cache
    //

    if ( ( dwRetrievalFlags & CRYPT_WIRE_ONLY_RETRIEVAL ) &&
         ( dwRetrievalFlags & CRYPT_CACHE_ONLY_RETRIEVAL ) )
    {
        return( FALSE );
    }

    //
    // If we are retrieving async we must have an async handle
    //

    if ( ( dwRetrievalFlags & CRYPT_ASYNC_RETRIEVAL ) &&
         ( hAsyncRetrieve == NULL ) )
    {
        return( FALSE );
    }

    //
    //         This is a temporary check since CRYPT_VERIFY_DATA_HASH is not
    //         yet implemented
    //

    if ( dwRetrievalFlags & CRYPT_VERIFY_DATA_HASH )
    {
        SetLastError( (DWORD) E_NOTIMPL );
        return( FALSE );
    }

    //
    // We can't have both CRYPT_VERIFY_CONTEXT_SIGNATURE and
    // CRYPT_VERIFY_DATA_HASH set
    //

    if ( ( dwRetrievalFlags &
           ( CRYPT_VERIFY_CONTEXT_SIGNATURE | CRYPT_VERIFY_DATA_HASH ) ) ==
         ( CRYPT_VERIFY_CONTEXT_SIGNATURE | CRYPT_VERIFY_DATA_HASH ) )
    {
        return( FALSE );
    }

    //
    // If either of the above is set, then pvVerify should be non NULL and
    // CRYPT_RETRIEVE_MULTIPLE_OBJECTS should not be set
    //

    if ( ( dwRetrievalFlags &
           ( CRYPT_VERIFY_CONTEXT_SIGNATURE | CRYPT_VERIFY_DATA_HASH ) ) &&
         ( ( pvVerify == NULL ) ||
           ( dwRetrievalFlags & CRYPT_RETRIEVE_MULTIPLE_OBJECTS ) ) )
    {
        return( FALSE );
    }

    //
    // We must have an out parameter
    //

    if ( ppvObject == NULL )
    {
        return( FALSE );
    }

    SetLastError( 0 );
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectRetrievalManager::LoadProviders, private
//
//  Synopsis:   load scheme and context providers based on URL and OID resp.
//
//----------------------------------------------------------------------------
BOOL
CObjectRetrievalManager::LoadProviders (
                             LPCSTR pszUrl,
                             LPCSTR pszObjectOid
                             )
{
    CHAR            pszCanonicalUrl[INTERNET_MAX_PATH_LENGTH];
    CHAR            pszScheme[MAX_PATH+1];
    CHAR*           psz = NULL;
    DWORD           cbUrl = INTERNET_MAX_PATH_LENGTH;
    URL_COMPONENTSA UrlComponents;

    //
    // Get the scheme
    //

    __try
    {
        if ( InternetCanonicalizeUrlA(
                     pszUrl,
                     pszCanonicalUrl,
                     &cbUrl,
                     ICU_BROWSER_MODE
                     ) == FALSE )
        {
            return( FALSE );
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        SetLastError( GetExceptionCode() );
        return( FALSE );
    }

    memset( &UrlComponents, 0, sizeof( URL_COMPONENTSA ) );
    UrlComponents.dwStructSize = sizeof( URL_COMPONENTSA );
    UrlComponents.lpszScheme = pszScheme;
    UrlComponents.dwSchemeLength = MAX_PATH;

    if ( InternetCrackUrlA(
                 pszCanonicalUrl,
                 0,
                 0,
                 &UrlComponents
                 ) == FALSE )
    {
        psz = strchr( pszCanonicalUrl, ':' );
        if ( psz != NULL )
        {
            cbUrl = (DWORD)(psz - pszCanonicalUrl);
            if ( cbUrl > MAX_PATH )
            {
                return( FALSE );
            }

            memcpy( pszScheme, pszCanonicalUrl, cbUrl );
            pszScheme[cbUrl] = '\0';
        }
        else
        {
            strcpy( pszScheme, FILE_SCHEME );
        }
    }


    //
    // Use the scheme to load the appropriate scheme provider
    //

    if ( CryptGetOIDFunctionAddress(
              hSchemeRetrieveFuncSet,
              X509_ASN_ENCODING,
              UrlComponents.lpszScheme,
              0,
              (LPVOID *)&m_pfnSchemeRetrieve,
              &m_hSchemeRetrieve
              ) == FALSE )
    {
        return( FALSE );
    }

    //
    // Load the appropriate context provider using the object oid
    //

    if ( pszObjectOid != NULL )
    {
        if ( CryptGetOIDFunctionAddress(
                  hContextCreateFuncSet,
                  X509_ASN_ENCODING,
                  pszObjectOid,
                  0,
                  (LPVOID *)&m_pfnContextCreate,
                  &m_hContextCreate
                  ) == FALSE )
        {
            return( FALSE );
        }
    }

    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectRetrievalManager::UnloadProviders, private
//
//  Synopsis:   unload scheme and context providers
//
//----------------------------------------------------------------------------
VOID
CObjectRetrievalManager::UnloadProviders ()
{
    if ( m_hSchemeRetrieve != NULL )
    {
        CryptFreeOIDFunctionAddress( m_hSchemeRetrieve, 0 );
    }

    if ( m_hContextCreate != NULL )
    {
        CryptFreeOIDFunctionAddress( m_hContextCreate, 0 );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectRetrievalManager::CallSchemeRetrieveObjectByUrl, private
//
//  Synopsis:   Call the scheme provider RetrieveObjectByUrl entry point
//
//----------------------------------------------------------------------------
BOOL
CObjectRetrievalManager::CallSchemeRetrieveObjectByUrl (
                                   LPCSTR pszUrl,
                                   LPCSTR pszObjectOid,
                                   DWORD dwRetrievalFlags,
                                   DWORD dwTimeout,
                                   PCRYPT_BLOB_ARRAY pObject,
                                   PFN_FREE_ENCODED_OBJECT_FUNC* ppfnFreeObject,
                                   LPVOID* ppvFreeContext,
                                   HCRYPTASYNC hAsyncRetrieve,
                                   PCRYPT_CREDENTIALS pCredentials,
                                   PCRYPT_RETRIEVE_AUX_INFO pAuxInfo
                                   )
{
    return( ( *m_pfnSchemeRetrieve ) (
                          pszUrl,
                          pszObjectOid,
                          dwRetrievalFlags,
                          dwTimeout,
                          pObject,
                          ppfnFreeObject,
                          ppvFreeContext,
                          hAsyncRetrieve,
                          pCredentials,
                          pAuxInfo
                          ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectRetrievalManager::CallContextCreateObjectContext, private
//
//  Synopsis:   call the context provider CreateObjectContext entry point
//
//----------------------------------------------------------------------------
BOOL
CObjectRetrievalManager::CallContextCreateObjectContext (
                                    LPCSTR pszObjectOid,
                                    DWORD dwRetrievalFlags,
                                    PCRYPT_BLOB_ARRAY pObject,
                                    LPVOID* ppvContext
                                    )
{
    return( ( *m_pfnContextCreate ) (
                           pszObjectOid,
                           dwRetrievalFlags,
                           pObject,
                           ppvContext
                           ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\urlprov.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       urlprov.cpp
//
//  Contents:   CryptGetObjectUrl provider implementation
//
//  History:    16-Sep-97    kirtd    Created
//
//----------------------------------------------------------------------------
#include <global.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   CertificateIssuerGetObjectUrl
//
//  Synopsis:   get certificate issuer URL
//
//----------------------------------------------------------------------------
BOOL WINAPI
CertificateIssuerGetObjectUrl (
           IN LPCSTR pszUrlOid,
           IN LPVOID pvPara,
           IN DWORD dwFlags,
           OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
           IN OUT DWORD* pcbUrlArray,
           OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
           IN OUT OPTIONAL DWORD* pcbUrlInfo,
           IN OPTIONAL LPVOID pvReserved
           )
{
    return( ObjectContextUrlFromInfoAccess(
                  CONTEXT_OID_CERTIFICATE,
                  pvPara,
                  (DWORD) -1L,
                  szOID_AUTHORITY_INFO_ACCESS,
                  dwFlags,
                  szOID_PKIX_CA_ISSUERS,
                  pUrlArray,
                  pcbUrlArray,
                  pUrlInfo,
                  pcbUrlInfo,
                  pvReserved
                  ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CertificateCrlDistPointGetObjectUrl
//
//  Synopsis:   get certificate CRL URL
//
//----------------------------------------------------------------------------
BOOL WINAPI
CertificateCrlDistPointGetObjectUrl (
           IN LPCSTR pszUrlOid,
           IN LPVOID pvPara,
           IN DWORD dwFlags,
           OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
           IN OUT DWORD* pcbUrlArray,
           OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
           IN OUT OPTIONAL DWORD* pcbUrlInfo,
           IN LPVOID pvReserved
           )
{
    return( ObjectContextUrlFromCrlDistPoint(
                  CONTEXT_OID_CERTIFICATE,
                  pvPara,
                  (DWORD) -1L,
                  dwFlags,
                  szOID_CRL_DIST_POINTS,
                  pUrlArray,
                  pcbUrlArray,
                  pUrlInfo,
                  pcbUrlInfo,
                  pvReserved
                  ) );
}


//+---------------------------------------------------------------------------
//
//  Function:   CertificateFreshestCrlGetObjectUrl
//
//  Synopsis:   get certificate freshest CRL URL
//
//----------------------------------------------------------------------------
BOOL WINAPI
CertificateFreshestCrlGetObjectUrl(
           IN LPCSTR pszUrlOid,
           IN LPVOID pvPara,
           IN DWORD dwFlags,
           OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
           IN OUT DWORD* pcbUrlArray,
           OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
           IN OUT OPTIONAL DWORD* pcbUrlInfo,
           IN OPTIONAL LPVOID pvReserved
           )
{

    return( ObjectContextUrlFromCrlDistPoint(
                  CONTEXT_OID_CERTIFICATE,
                  pvPara,
                  (DWORD) -1L,
                  dwFlags,
                  szOID_FRESHEST_CRL,
                  pUrlArray,
                  pcbUrlArray,
                  pUrlInfo,
                  pcbUrlInfo,
                  pvReserved
                  ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CrlFreshestCrlGetObjectUrl
//
//  Synopsis:   get freshest CRL URL from the certificate's base CRL
//
//----------------------------------------------------------------------------
BOOL WINAPI
CrlFreshestCrlGetObjectUrl(
           IN LPCSTR pszUrlOid,
           IN LPVOID pvPara,
           IN DWORD dwFlags,
           OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
           IN OUT DWORD* pcbUrlArray,
           OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
           IN OUT OPTIONAL DWORD* pcbUrlInfo,
           IN OPTIONAL LPVOID pvReserved
           )
{
    PCCERT_CRL_CONTEXT_PAIR pCertCrlPair = (PCCERT_CRL_CONTEXT_PAIR) pvPara;

    return( ObjectContextUrlFromCrlDistPoint(
                  CONTEXT_OID_CRL,
                  (LPVOID) pCertCrlPair->pCrlContext,
                  (DWORD) -1L,
                  dwFlags,
                  szOID_FRESHEST_CRL,
                  pUrlArray,
                  pcbUrlArray,
                  pUrlInfo,
                  pcbUrlInfo,
                  pvReserved
                  ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CtlIssuerGetObjectUrl
//
//  Synopsis:   get CTL issuer URL
//
//----------------------------------------------------------------------------
BOOL WINAPI
CtlIssuerGetObjectUrl (
   IN LPCSTR pszUrlOid,
   IN LPVOID pvPara,
   IN DWORD dwFlags,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo,
   IN LPVOID pvReserved
   )
{
    PURL_OID_CTL_ISSUER_PARAM pParam = (PURL_OID_CTL_ISSUER_PARAM)pvPara;

    return( ObjectContextUrlFromInfoAccess(
                  CONTEXT_OID_CTL,
                  (LPVOID)pParam->pCtlContext,
                  pParam->SignerIndex,
                  szOID_AUTHORITY_INFO_ACCESS,
                  CRYPT_GET_URL_FROM_AUTH_ATTRIBUTE |
                  CRYPT_GET_URL_FROM_UNAUTH_ATTRIBUTE,
                  szOID_PKIX_CA_ISSUERS,
                  pUrlArray,
                  pcbUrlArray,
                  pUrlInfo,
                  pcbUrlInfo,
                  pvReserved
                  ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CtlNextUpdateGetObjectUrl
//
//  Synopsis:   get CTL renewal URL
//
//----------------------------------------------------------------------------
BOOL WINAPI
CtlNextUpdateGetObjectUrl (
   IN LPCSTR pszUrlOid,
   IN LPVOID pvPara,
   IN DWORD dwFlags,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo,
   IN LPVOID pvReserved
   )
{
    LPVOID* apv = (LPVOID *)pvPara;

    return( ObjectContextUrlFromNextUpdateLocation(
                  CONTEXT_OID_CTL,
                  apv[0],
                  (DWORD)(DWORD_PTR)apv[1],
                  dwFlags,
                  pUrlArray,
                  pcbUrlArray,
                  pUrlInfo,
                  pcbUrlInfo,
                  pvReserved
                  ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   CrlIssuerGetObjectUrl
//
//  Synopsis:   get CRL issuer URL
//
//----------------------------------------------------------------------------
BOOL WINAPI
CrlIssuerGetObjectUrl (
   IN LPCSTR pszUrlOid,
   IN LPVOID pvPara,
   IN DWORD dwFlags,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo,
   IN LPVOID pvReserved
   )
{
    return( ObjectContextUrlFromInfoAccess(
                  CONTEXT_OID_CRL,
                  pvPara,
                  (DWORD) -1L,
                  szOID_AUTHORITY_INFO_ACCESS,
                  dwFlags,
                  szOID_PKIX_CA_ISSUERS,
                  pUrlArray,
                  pcbUrlArray,
                  pUrlInfo,
                  pcbUrlInfo,
                  pvReserved
                  ) );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextUrlFromInfoAccess
//
//  Synopsis:   get the URLs specified by the access method OID from the given
//              context and format it as a CRYPT_URL_ARRAY
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextUrlFromInfoAccess (
           IN LPCSTR pszContextOid,
           IN LPVOID pvContext,
           IN DWORD Index,
           IN LPCSTR pszInfoAccessOid,
           IN DWORD dwFlags,
           IN LPCSTR pszAccessMethodOid,
           OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
           IN OUT DWORD* pcbUrlArray,
           OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
           IN OUT OPTIONAL DWORD* pcbUrlInfo,
           IN LPVOID pvReserved
           )
{
    BOOL               fResult = FALSE;
    CRYPT_RAW_URL_DATA RawData[MAX_RAW_URL_DATA];
    ULONG              cRawData = MAX_RAW_URL_DATA;

    fResult = ObjectContextGetRawUrlData(
                    pszContextOid,
                    pvContext,
                    Index,
                    dwFlags,
                    pszInfoAccessOid,
                    RawData,
                    &cRawData
                    );

    if ( fResult == TRUE )
    {
        fResult = GetUrlArrayAndInfoFromInfoAccess(
                     cRawData,
                     RawData,
                     pszAccessMethodOid,
                     pUrlArray,
                     pcbUrlArray,
                     pUrlInfo,
                     pcbUrlInfo
                     );

        ObjectContextFreeRawUrlData( cRawData, RawData );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextUrlFromCrlDistPoint
//
//  Synopsis:   get the URLs from the CRL distribution point on the object and
//              format as a CRYPT_URL_ARRAY
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextUrlFromCrlDistPoint (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN DWORD Index,
      IN DWORD dwFlags,
      IN LPCSTR pszSourceOid,
      OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
      IN OUT DWORD* pcbUrlArray,
      OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
      IN OUT OPTIONAL DWORD* pcbUrlInfo,
      IN LPVOID pvReserved
      )
{
    BOOL               fResult = FALSE;
    CRYPT_RAW_URL_DATA RawData[MAX_RAW_URL_DATA];
    ULONG              cRawData = MAX_RAW_URL_DATA;

    fResult = ObjectContextGetRawUrlData(
                    pszContextOid,
                    pvContext,
                    Index,
                    dwFlags,
                    pszSourceOid,
                    RawData,
                    &cRawData
                    );

    if ( fResult == TRUE )
    {
        fResult = GetUrlArrayAndInfoFromCrlDistPoint(
                     cRawData,
                     RawData,
                     pUrlArray,
                     pcbUrlArray,
                     pUrlInfo,
                     pcbUrlInfo
                     );

        ObjectContextFreeRawUrlData( cRawData, RawData );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextUrlFromNextUpdateLocation
//
//  Synopsis:   get the URLs from the next update location
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextUrlFromNextUpdateLocation (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN DWORD Index,
      IN DWORD dwFlags,
      OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
      IN OUT DWORD* pcbUrlArray,
      OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
      IN OUT OPTIONAL DWORD* pcbUrlInfo,
      IN LPVOID pvReserved
      )
{
    BOOL               fResult = FALSE;
    CRYPT_RAW_URL_DATA RawData[MAX_RAW_URL_DATA];
    ULONG              cRawData = MAX_RAW_URL_DATA;

    fResult = ObjectContextGetRawUrlData(
                    pszContextOid,
                    pvContext,
                    Index,
                    dwFlags,
                    szOID_NEXT_UPDATE_LOCATION,
                    RawData,
                    &cRawData
                    );

    if ( fResult == TRUE )
    {
        fResult = GetUrlArrayAndInfoFromNextUpdateLocation(
                     cRawData,
                     RawData,
                     pUrlArray,
                     pcbUrlArray,
                     pUrlInfo,
                     pcbUrlInfo
                     );

        ObjectContextFreeRawUrlData( cRawData, RawData );
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   InitializeDefaultUrlInfo
//
//  Synopsis:   initialize default URL info
//
//----------------------------------------------------------------------------
VOID WINAPI
InitializeDefaultUrlInfo (
          OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
          IN OUT DWORD* pcbUrlInfo
          )
{

    if ( pUrlInfo == NULL )
    {
        *pcbUrlInfo = sizeof( CRYPT_URL_INFO );
        return;
    }

    if (*pcbUrlInfo >= sizeof( CRYPT_URL_INFO ))
    {
        *pcbUrlInfo = sizeof( CRYPT_URL_INFO );
        memset( pUrlInfo, 0, sizeof( CRYPT_URL_INFO ) );
        pUrlInfo->cbSize = sizeof( CRYPT_URL_INFO );
    }
    else if (*pcbUrlInfo >= sizeof( DWORD ))
    {
        *pcbUrlInfo = sizeof( DWORD );
        pUrlInfo->cbSize = sizeof( DWORD );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextGetRawUrlData
//
//  Synopsis:   Raw URL data is a decoded extension, property or attribute
//              specified by a source OID that contains locator information.
//              This API retrieves and decodes such data
//
//----------------------------------------------------------------------------
BOOL WINAPI
ObjectContextGetRawUrlData (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN DWORD Index,
      IN DWORD dwFlags,
      IN LPCSTR pszSourceOid,
      OUT PCRYPT_RAW_URL_DATA aRawUrlData,
      IN OUT DWORD* pcRawUrlData
      )
{
    BOOL               fResult = TRUE;
    DWORD              cCount;
    DWORD              cError = 0;
    DWORD              cRawData = 0;
    CRYPT_RAW_URL_DATA RawData[MAX_RAW_URL_DATA];
    CRYPT_DATA_BLOB    DataBlob = {0, NULL};
    BOOL               fFreeDataBlob = FALSE;
    DWORD              cbDecoded;
    LPBYTE             pbDecoded = NULL;
    PCRYPT_ATTRIBUTE   pAttr = NULL;
    DWORD              cbAttr;

    if ( dwFlags & CRYPT_GET_URL_FROM_PROPERTY )
    {
        RawData[cRawData].dwFlags = CRYPT_GET_URL_FROM_PROPERTY;
        RawData[cRawData].pvData = NULL;
        cRawData += 1;
    }

    if ( dwFlags & CRYPT_GET_URL_FROM_EXTENSION )
    {
        RawData[cRawData].dwFlags = CRYPT_GET_URL_FROM_EXTENSION;
        RawData[cRawData].pvData = NULL;
        cRawData += 1;
    }

    if ( dwFlags & CRYPT_GET_URL_FROM_UNAUTH_ATTRIBUTE )
    {
        RawData[cRawData].dwFlags = CRYPT_GET_URL_FROM_UNAUTH_ATTRIBUTE;
        RawData[cRawData].pvData = NULL;
        cRawData += 1;
    }

    if ( dwFlags & CRYPT_GET_URL_FROM_AUTH_ATTRIBUTE )
    {
        RawData[cRawData].dwFlags = CRYPT_GET_URL_FROM_AUTH_ATTRIBUTE;
        RawData[cRawData].pvData = NULL;
        cRawData += 1;
    }

    if ( *pcRawUrlData < cRawData )
    {
        SetLastError( (DWORD) E_INVALIDARG );
        return( FALSE );
    }

    for ( cCount = 0; cCount < cRawData; cCount++ )
    {
        switch ( RawData[cCount].dwFlags )
        {
        case CRYPT_GET_URL_FROM_PROPERTY:
            {
                DWORD PropId;

                fResult = MapOidToPropertyId( pszSourceOid, &PropId );
                if ( fResult == TRUE )
                {
                    fResult = ObjectContextGetProperty(
                                  pszContextOid,
                                  pvContext,
                                  PropId,
                                  NULL,
                                  &DataBlob.cbData
                                  );
                }

                if ( fResult == TRUE )
                {
                    DataBlob.pbData = new BYTE [ DataBlob.cbData ];
                    if ( DataBlob.pbData != NULL )
                    {
                        fFreeDataBlob = TRUE;

                        fResult = ObjectContextGetProperty(
                                      pszContextOid,
                                      pvContext,
                                      PropId,
                                      DataBlob.pbData,
                                      &DataBlob.cbData
                                      );
                    }
                    else
                    {
                        fResult = FALSE;
                        SetLastError( (DWORD) E_OUTOFMEMORY );
                    }
                }
            }
            break;
        case CRYPT_GET_URL_FROM_EXTENSION:
            {
                PCERT_EXTENSION pExt;

                pExt = ObjectContextFindExtension(
                           pszContextOid,
                           pvContext,
                           pszSourceOid
                           );

                if ( pExt != NULL )
                {
                    DataBlob.cbData = pExt->Value.cbData;
                    DataBlob.pbData = pExt->Value.pbData;
                    fResult = TRUE;
                }
                else
                {
                    fResult = FALSE;
                }
            }
            break;
        case CRYPT_GET_URL_FROM_UNAUTH_ATTRIBUTE:
        case CRYPT_GET_URL_FROM_AUTH_ATTRIBUTE:
            {
                fResult = ObjectContextGetAttribute(
                                pszContextOid,
                                pvContext,
                                Index,
                                RawData[cCount].dwFlags,
                                pszSourceOid,
                                NULL,
                                &cbAttr
                                );

                if ( fResult == TRUE )
                {
                    pAttr = (PCRYPT_ATTRIBUTE)new BYTE [cbAttr];
                    if ( pAttr != NULL )
                    {
                        fResult = ObjectContextGetAttribute(
                                        pszContextOid,
                                        pvContext,
                                        Index,
                                        RawData[cCount].dwFlags,
                                        pszSourceOid,
                                        pAttr,
                                        &cbAttr
                                        );
                    }
                    else
                    {
                        fResult = FALSE;
                        SetLastError( (DWORD) E_OUTOFMEMORY );
                    }
                }

                if ( fResult == TRUE )
                {
                    // We only deal with single valued attributes
                    DataBlob.cbData = pAttr->rgValue[0].cbData;
                    DataBlob.pbData = pAttr->rgValue[0].pbData;
                }
            }
            break;
        }

        if ( fResult == TRUE )
        {
            fResult = CryptDecodeObject(
                           X509_ASN_ENCODING,
                           pszSourceOid,
                           DataBlob.pbData,
                           DataBlob.cbData,
                           0,
                           NULL,
                           &cbDecoded
                           );

            if ( fResult == TRUE )
            {
                pbDecoded = new BYTE [ cbDecoded ];
                if ( pbDecoded != NULL )
                {
                    fResult = CryptDecodeObject(
                                   X509_ASN_ENCODING,
                                   pszSourceOid,
                                   DataBlob.pbData,
                                   DataBlob.cbData,
                                   0,
                                   pbDecoded,
                                   &cbDecoded
                                   );
                }
                else
                {
                    fResult = FALSE;
                }
            }
        }

        if ( fResult == TRUE )
        {
            RawData[cCount].pvData = (LPVOID)pbDecoded;
        }
        else
        {
            cError += 1;
        }

        if ( fFreeDataBlob == TRUE )
        {
            delete DataBlob.pbData;
            fFreeDataBlob = FALSE;
        }

        if ( pAttr != NULL )
        {
            delete (LPBYTE)pAttr;
            pAttr = NULL;
        }
    }

    if ( cError != cRawData )
    {
        memcpy( aRawUrlData, RawData, cRawData * sizeof( CRYPT_RAW_URL_DATA ) );
        *pcRawUrlData = cRawData;
        fResult = TRUE;
    }
    else
    {
        SetLastError( (DWORD) CRYPT_E_NOT_FOUND );
        fResult = FALSE;
    }

    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ObjectContextFreeRawUrlData
//
//  Synopsis:   free the raw URL data
//
//----------------------------------------------------------------------------
VOID WINAPI
ObjectContextFreeRawUrlData (
      IN DWORD cRawUrlData,
      IN PCRYPT_RAW_URL_DATA aRawUrlData
      )
{
    DWORD cCount;

    for ( cCount = 0; cCount < cRawUrlData; cCount++ )
    {
        delete aRawUrlData[cCount].pvData;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetUrlArrayAndInfoFromAuthInfoAccess
//
//  Synopsis:   get URL data using decoded info access data
//
//----------------------------------------------------------------------------
BOOL WINAPI
GetUrlArrayAndInfoFromInfoAccess (
   IN DWORD cRawUrlData,
   IN PCRYPT_RAW_URL_DATA aRawUrlData,
   IN LPCSTR pszAccessMethodOid,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo
   )
{
    BOOL                        fResult = FALSE;
    PCERT_AUTHORITY_INFO_ACCESS pAuthInfoAccess = NULL;
    PCERT_ACCESS_DESCRIPTION    rgAccDescr = NULL;
    DWORD                       cRaw;
    DWORD                       cCount;
    BOOL                        fAnyFound = FALSE;
    CCryptUrlArray              cua( 1, 5, fResult );

    for ( cRaw = 0; ( fResult == TRUE ) && ( cRaw < cRawUrlData ); cRaw++ )
    {
        pAuthInfoAccess = (PCERT_AUTHORITY_INFO_ACCESS)aRawUrlData[cRaw].pvData;
        if ( pAuthInfoAccess != NULL )
        {
            rgAccDescr = pAuthInfoAccess->rgAccDescr;

            for ( cCount = 0;
                  ( cCount < pAuthInfoAccess->cAccDescr ) &&
                  ( fResult == TRUE );
                  cCount++ )
            {
                if ( !strcmp(
                         pszAccessMethodOid,
                         rgAccDescr[cCount].pszAccessMethod
                         ) )
                {
                    if ( rgAccDescr[cCount].AccessLocation.dwAltNameChoice ==
                         CERT_ALT_NAME_URL )
                    {
                        fResult = cua.AddUrl(
                                      rgAccDescr[cCount].AccessLocation.pwszURL,
                                      TRUE
                                      );

                        fAnyFound = TRUE;
                    }
                }
            }
        }
    }

    if ( ( fAnyFound == FALSE ) && ( fResult == TRUE ) )
    {
        SetLastError( (DWORD) CRYPT_E_NOT_FOUND );
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        PCRYPT_URL_ARRAY* ppUrlArray = NULL;

        if ( pUrlArray != NULL )
        {
            ppUrlArray = &pUrlArray;
        }

        fResult = cua.GetArrayInSingleBufferEncodedForm(
                              ppUrlArray,
                              pcbUrlArray
                              );
    }

    if ( ( fResult == TRUE ) && ( pcbUrlInfo != NULL ) )
    {
        InitializeDefaultUrlInfo( pUrlInfo, pcbUrlInfo );
    }

    cua.FreeArray( TRUE );
    return( fResult );
}

#define DIR_NAME_LDAP_URL_PREFIX    L"ldap://"

#define URL_OID_CDP_DIR_NAME_LDAP_HOST_PORTS_VALUE_NAME \
            L"DirectoryNameLdapHostPorts"
#define URL_OID_CDP_DIR_NAME_LDAP_SUFFIX_VALUE_NAME \
            L"DirectoryNameLdapSuffix"

LPCWSTR pwszDefaultCDPDirNameLdapUrlHostPorts = L"\0\0"; 

LPCWSTR pwszDefaultCDPDirNameLdapUrlSuffix=
    L"?certificateRevocationList;binary,authorityRevocationList;binary,deltaRevocationList;binary";

LPWSTR WINAPI
GetCDPOIDFunctionValue(
    IN LPCWSTR pwszValueName
    )
{
    BOOL fResult;
    DWORD dwType;
    DWORD cchValue;
    DWORD cbValue = 0;
    LPWSTR pwszValue = NULL;

    fResult = CryptGetOIDFunctionValue(
        X509_ASN_ENCODING,
        URL_OID_GET_OBJECT_URL_FUNC,
        URL_OID_CERTIFICATE_CRL_DIST_POINT,
        pwszValueName,
        &dwType,
        NULL,
        &cbValue
        );
    cchValue = cbValue / sizeof(WCHAR);
    if (!fResult || 0 == cchValue ||
            !(REG_MULTI_SZ == dwType || REG_SZ == dwType ||
                 REG_EXPAND_SZ == dwType))
        goto ErrorReturn;

    pwszValue = new WCHAR [cchValue + 2];
    if (NULL == pwszValue)
        goto OutOfMemory;

    fResult = CryptGetOIDFunctionValue(
        X509_ASN_ENCODING,
        URL_OID_GET_OBJECT_URL_FUNC,
        URL_OID_CERTIFICATE_CRL_DIST_POINT,
        pwszValueName,
        &dwType,
        (BYTE *) pwszValue,
        &cbValue
        );
    if (!fResult)
        goto ErrorReturn;

    // Ensure the value has two null terminators
    pwszValue[cchValue] = L'\0';
    pwszValue[cchValue + 1] = L'\0';

CommonReturn:
    return pwszValue;
ErrorReturn:
    if (pwszValue) {
        delete pwszValue;
        pwszValue = NULL;
    }
    goto CommonReturn;
OutOfMemory:
    SetLastError( (DWORD) E_OUTOFMEMORY );
    goto ErrorReturn;
}

// For an error or no found registry value,
// returns pwszDefaultCDPDirNameLdapUrlHostPorts
LPWSTR WINAPI
GetCDPDirNameLdapUrlHostPorts()
{
    LPWSTR pwszHostPorts;

    pwszHostPorts = GetCDPOIDFunctionValue(
        URL_OID_CDP_DIR_NAME_LDAP_HOST_PORTS_VALUE_NAME);
    if (NULL == pwszHostPorts)
        pwszHostPorts = (LPWSTR) pwszDefaultCDPDirNameLdapUrlHostPorts;

    return pwszHostPorts;
}

// For an error or no found registry value,
// returns pwszDefaultCDPDirNameLdapUrlSuffix
LPWSTR WINAPI
GetCDPDirNameLdapUrlSuffix()
{
    LPWSTR pwszSuffix = NULL;

    pwszSuffix = GetCDPOIDFunctionValue(
        URL_OID_CDP_DIR_NAME_LDAP_SUFFIX_VALUE_NAME);
    if (NULL == pwszSuffix)
        pwszSuffix = (LPWSTR) pwszDefaultCDPDirNameLdapUrlSuffix;

    return pwszSuffix;
}

BOOL WINAPI
AddUrlsFromCDPDirectoryName (
    IN PCERT_NAME_BLOB pDirNameBlob,
    IN OUT CCryptUrlArray *pcua
    )
{
    BOOL fResult;
    LPWSTR pwszHP;
    LPWSTR pwszHostPorts;
    LPWSTR pwszSuffix;
    LPWSTR pwszDirName = NULL;
    DWORD cchDirName;

    pwszHostPorts = GetCDPDirNameLdapUrlHostPorts();
    pwszSuffix = GetCDPDirNameLdapUrlSuffix();
    assert(NULL != pwszHostPorts && NULL != pwszSuffix);

    cchDirName = CertNameToStrW(
        X509_ASN_ENCODING,
        pDirNameBlob,
        CERT_X500_NAME_STR  | CERT_NAME_STR_REVERSE_FLAG,
        NULL,                   // pwsz
        0                       // cch
        );
    if (1 >= cchDirName)
        goto ErrorReturn;
    pwszDirName = new WCHAR [cchDirName];
    if (NULL == pwszDirName)
        goto OutOfMemory;
    cchDirName = CertNameToStrW(
        X509_ASN_ENCODING,
        pDirNameBlob,
        CERT_X500_NAME_STR  | CERT_NAME_STR_REVERSE_FLAG,
        pwszDirName,
        cchDirName
        );
    if (1 >= cchDirName)
        goto ErrorReturn;
    cchDirName--;           // exclude trailing L'\0'

    pwszHP = pwszHostPorts;
    while (TRUE) {
        DWORD cchHP;
        LPWSTR pwszUrl;
        DWORD cchUrl;

        // Skip past any spaces in the HostPort
        while (L' ' == *pwszHP)
            pwszHP++;
        cchHP = wcslen(pwszHP);

        cchUrl = wcslen(DIR_NAME_LDAP_URL_PREFIX);
        cchUrl += cchHP;
        cchUrl += 1;        // L'/'
        cchUrl += cchDirName;
        cchUrl += wcslen(pwszSuffix);
        cchUrl += 1;        // L'\0'

        pwszUrl = new WCHAR [cchUrl];
        if (NULL == pwszUrl)
            goto OutOfMemory;

        wcscpy(pwszUrl, DIR_NAME_LDAP_URL_PREFIX);
        wcscat(pwszUrl, pwszHP);
        wcscat(pwszUrl, L"/");
        wcscat(pwszUrl, pwszDirName);
        wcscat(pwszUrl, pwszSuffix);

        fResult = pcua->AddUrl(pwszUrl, TRUE);

        delete pwszUrl;
        if (!fResult)
            goto ErrorReturn;

        pwszHP += cchHP + 1;
        if (L'\0' == *pwszHP)
            break;
    }

    fResult = TRUE;
CommonReturn:
    if (pwszDirName)
        delete pwszDirName;
    if (pwszHostPorts != pwszDefaultCDPDirNameLdapUrlHostPorts)
        delete pwszHostPorts;
    if (pwszSuffix != pwszDefaultCDPDirNameLdapUrlSuffix)
        delete pwszSuffix;

    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

OutOfMemory:
    SetLastError( (DWORD) E_OUTOFMEMORY );
    goto ErrorReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetUrlArrayAndInfoFromCrlDistPoint
//
//  Synopsis:   get URL data using decoded CRL distribution point info
//
//----------------------------------------------------------------------------
BOOL WINAPI
GetUrlArrayAndInfoFromCrlDistPoint (
   IN DWORD cRawUrlData,
   IN PCRYPT_RAW_URL_DATA aRawUrlData,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo
   )
{
    BOOL                  fResult = FALSE;
    PCRL_DIST_POINTS_INFO pDistPointsInfo;
    PCRL_DIST_POINT       rgDistPoint;
    PCRL_DIST_POINT_NAME  pDistPointName;
    PCERT_ALT_NAME_ENTRY  rgAltEntry;
    DWORD                 cRaw;
    DWORD                 cCount;
    DWORD                 cEntry;
    BOOL                  fAnyFound = FALSE;
    CCryptUrlArray        cua( 1, 5, fResult );

    for ( cRaw = 0; ( fResult == TRUE ) && ( cRaw < cRawUrlData ); cRaw++ )
    {
        pDistPointsInfo = (PCRL_DIST_POINTS_INFO)aRawUrlData[cRaw].pvData;
        if ( pDistPointsInfo != NULL )
        {
            rgDistPoint = pDistPointsInfo->rgDistPoint;

            for ( cCount = 0;
                  ( cCount < pDistPointsInfo->cDistPoint ) &&
                  ( fResult == TRUE );
                  cCount++ )
            {
                // Assumption:: don't support partial reasons

                // For now, will ignore CRL issuers, they might
                // be the same as the cert's issuer. That was the case
                // with a Netscape CDP
                if (rgDistPoint[cCount].ReasonFlags.cbData)
                    continue;

                pDistPointName = &rgDistPoint[cCount].DistPointName;

                if ( pDistPointName->dwDistPointNameChoice ==
                     CRL_DIST_POINT_FULL_NAME )
                {
                    rgAltEntry = pDistPointName->FullName.rgAltEntry;

                    for ( cEntry = 0;
                          ( fResult == TRUE ) &&
                          ( cEntry < pDistPointName->FullName.cAltEntry );
                          cEntry++ )
                    {
                        switch (rgAltEntry[cEntry].dwAltNameChoice) {
                        case CERT_ALT_NAME_URL:
                            fResult = cua.AddUrl(
                                             rgAltEntry[cEntry].pwszURL,
                                             TRUE
                                             );
                            fAnyFound = TRUE;
                            break;
                        case CERT_ALT_NAME_DIRECTORY_NAME:
                            fResult = AddUrlsFromCDPDirectoryName(
                                &rgAltEntry[cEntry].DirectoryName,
                                &cua
                                );
                            fAnyFound = TRUE;
                            break;
                        default:
                            break;
                        }
                    }
                }
            }
        }
    }

    if ( ( fAnyFound == FALSE ) && ( fResult == TRUE ) )
    {
        SetLastError( (DWORD) CRYPT_E_NOT_FOUND );
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        PCRYPT_URL_ARRAY* ppUrlArray = NULL;

        if ( pUrlArray != NULL )
        {
            ppUrlArray = &pUrlArray;
        }

        fResult = cua.GetArrayInSingleBufferEncodedForm(
                              ppUrlArray,
                              pcbUrlArray
                              );
    }

    if ( ( fResult == TRUE ) && ( pcbUrlInfo != NULL ) )
    {
        InitializeDefaultUrlInfo( pUrlInfo, pcbUrlInfo );
    }

    cua.FreeArray( TRUE );
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   GetUrlArrayAndInfoFromNextUpdateLocation
//
//  Synopsis:   get URL data using decoded next update location data
//
//----------------------------------------------------------------------------
BOOL WINAPI
GetUrlArrayAndInfoFromNextUpdateLocation (
   IN DWORD cRawUrlData,
   IN PCRYPT_RAW_URL_DATA aRawUrlData,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo
   )
{
    BOOL                 fResult = FALSE;
    PCERT_ALT_NAME_INFO  pAltNameInfo;
    PCERT_ALT_NAME_ENTRY rgAltEntry;
    DWORD                cRaw;
    DWORD                cEntry;
    BOOL                 fAnyFound = FALSE;
    CCryptUrlArray       cua( 1, 5, fResult );

    for ( cRaw = 0; ( fResult == TRUE ) && ( cRaw < cRawUrlData ); cRaw++ )
    {
        pAltNameInfo = (PCERT_ALT_NAME_INFO)aRawUrlData[cRaw].pvData;
        if ( pAltNameInfo != NULL )
        {
            rgAltEntry = pAltNameInfo->rgAltEntry;

            for ( cEntry = 0;
                  ( cEntry < pAltNameInfo->cAltEntry ) &&
                  ( fResult == TRUE );
                  cEntry++ )
            {
                if ( rgAltEntry[cEntry].dwAltNameChoice == CERT_ALT_NAME_URL )
                {
                    fResult = cua.AddUrl( rgAltEntry[cEntry].pwszURL, TRUE );
                    fAnyFound = TRUE;
                }
            }
        }
    }

    if ( ( fAnyFound == FALSE ) && ( fResult == TRUE ) )
    {
        SetLastError( (DWORD) CRYPT_E_NOT_FOUND );
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        PCRYPT_URL_ARRAY* ppUrlArray = NULL;

        if ( pUrlArray != NULL )
        {
            ppUrlArray = &pUrlArray;
        }

        fResult = cua.GetArrayInSingleBufferEncodedForm(
                              ppUrlArray,
                              pcbUrlArray
                              );
    }

    if ( ( fResult == TRUE ) && ( pcbUrlInfo != NULL ) )
    {
        InitializeDefaultUrlInfo( pUrlInfo, pcbUrlInfo );
    }

    cua.FreeArray( TRUE );
    return( fResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   CopyUrlArray
//
//  Synopsis:   copy URL array
//
//----------------------------------------------------------------------------
VOID WINAPI
CopyUrlArray (
    IN PCRYPT_URL_ARRAY pDest,
    IN PCRYPT_URL_ARRAY pSource,
    IN DWORD cbSource
    )
{
    DWORD cCount;
    DWORD cb;
    DWORD cbStruct;
    DWORD cbPointers;
    DWORD cbUrl;

    cbStruct = sizeof( CRYPT_URL_ARRAY );
    cbPointers = pSource->cUrl * sizeof( LPWSTR );

    pDest->cUrl = pSource->cUrl;
    pDest->rgwszUrl = (LPWSTR *)( (LPBYTE)pDest + cbStruct );

    for ( cCount = 0, cb = 0; cCount < pSource->cUrl; cCount++ )
    {
        pDest->rgwszUrl[cCount] = (LPWSTR)((LPBYTE)pDest+cbStruct+cbPointers+cb);

        cbUrl = ( wcslen( pSource->rgwszUrl[cCount] ) + 1 ) * sizeof( WCHAR );

        memcpy( pDest->rgwszUrl[cCount], pSource->rgwszUrl[cCount], cbUrl );

        cb += cbUrl;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetUrlArrayIndex
//
//  Synopsis:   get index of an URL in the URL array
//
//----------------------------------------------------------------------------
VOID WINAPI
GetUrlArrayIndex (
   IN PCRYPT_URL_ARRAY pUrlArray,
   IN LPWSTR pwszUrl,
   IN DWORD DefaultIndex,
   OUT DWORD* pUrlIndex,
   OUT BOOL* pfHintInArray
   )
{
    DWORD cCount;

    if ( pUrlIndex != NULL )
    {
        *pUrlIndex = DefaultIndex;
    }

    if ( pfHintInArray != NULL )
    {
        *pfHintInArray = FALSE;
    }

    if ( pwszUrl == NULL )
    {
        return;
    }

    for ( cCount = 0; cCount < pUrlArray->cUrl; cCount++ )
    {
        if ( wcscmp( pUrlArray->rgwszUrl[cCount], pwszUrl ) == 0 )
        {
            if ( pUrlIndex != NULL )
            {
                *pUrlIndex = cCount;
            }

            if ( pfHintInArray != NULL )
            {
                *pfHintInArray = TRUE;
            }

            break;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   GetUrlArrayAndInfoFromCrossCertDistPoint
//
//  Synopsis:   get URL data using decoded Cross Cert distribution point info
//
//----------------------------------------------------------------------------
BOOL WINAPI
GetUrlArrayAndInfoFromCrossCertDistPoint (
   IN DWORD cRawUrlData,
   IN PCRYPT_RAW_URL_DATA aRawUrlData,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo
   )
{
    BOOL                  fResult = FALSE;
    PCROSS_CERT_DIST_POINTS_INFO pDistPointsInfo;
    PCERT_ALT_NAME_INFO   rgDistPoint;
    PCERT_ALT_NAME_ENTRY  rgAltEntry;
    DWORD                 cRaw;
    DWORD                 cCount;
    DWORD                 cEntry;
    BOOL                  fAnyFound = FALSE;
    CCryptUrlArray        cua( 1, 5, fResult );

    DWORD                 dwSyncDeltaTime = 0;
    DWORD                 cMaxGroup = 0;
    DWORD                 cGroup = 0;
    DWORD                 *pcGroupEntry = NULL;
    DWORD                 cGroupEntry;
    DWORD                 cbUrlInfo;

    // Get maximum number of groups
    for ( cRaw = 0; cRaw < cRawUrlData; cRaw++ )
    {
        pDistPointsInfo =
            (PCROSS_CERT_DIST_POINTS_INFO)aRawUrlData[cRaw].pvData;
        if ( pDistPointsInfo != NULL )
        {
            cMaxGroup += pDistPointsInfo->cDistPoint;
        }
    }

    if (cMaxGroup > 0)
    {
        pcGroupEntry = new DWORD [cMaxGroup];
        if ( pcGroupEntry == NULL)
        {
            fResult = FALSE;
            SetLastError( (DWORD) E_OUTOFMEMORY );
        }
    }

    for ( cRaw = 0; ( fResult == TRUE ) && ( cRaw < cRawUrlData ); cRaw++ )
    {
        pDistPointsInfo =
            (PCROSS_CERT_DIST_POINTS_INFO)aRawUrlData[cRaw].pvData;
        if ( pDistPointsInfo != NULL )
        {
            if ( dwSyncDeltaTime == 0 )
            {
                dwSyncDeltaTime = pDistPointsInfo->dwSyncDeltaTime;
            }

            rgDistPoint = pDistPointsInfo->rgDistPoint;

            for ( cCount = 0;
                  ( cCount < pDistPointsInfo->cDistPoint ) &&
                  ( fResult == TRUE );
                  cCount++ )
            {
                rgAltEntry = rgDistPoint[cCount].rgAltEntry;
                cGroupEntry = 0;

                for ( cEntry = 0;
                      ( fResult == TRUE ) &&
                      ( cEntry < rgDistPoint[cCount].cAltEntry );
                      cEntry++ )
                {
                    switch (rgAltEntry[cEntry].dwAltNameChoice) {
                    case CERT_ALT_NAME_URL:
                        fResult = cua.AddUrl(
                                         rgAltEntry[cEntry].pwszURL,
                                         TRUE
                                         );
                        fAnyFound = TRUE;
                        cGroupEntry++;
                        break;
                    default:
                        break;
                    }
                }

                if ( cGroupEntry > 0 )
                {
                    if (cGroup < cMaxGroup)
                    {
                        pcGroupEntry[cGroup] = cGroupEntry;
                        cGroup++;
                    }
                    else
                    {
                        fResult = FALSE;
                        SetLastError( (DWORD) E_UNEXPECTED );
                    }
                }
            }
        }
    }

    if ( ( fAnyFound == FALSE ) && ( fResult == TRUE ) )
    {
        SetLastError( (DWORD) CRYPT_E_NOT_FOUND );
        fResult = FALSE;
    }

    if ( fResult == TRUE )
    {
        PCRYPT_URL_ARRAY* ppUrlArray = NULL;

        if ( pUrlArray != NULL )
        {
            ppUrlArray = &pUrlArray;
        }

        fResult = cua.GetArrayInSingleBufferEncodedForm(
                              ppUrlArray,
                              pcbUrlArray
                              );
    }

    if ( ( fResult == TRUE ) && ( pcbUrlInfo != NULL ) )
    {
        cbUrlInfo = sizeof( CRYPT_URL_INFO ) + cGroup * sizeof(DWORD);
        if ( pUrlInfo != NULL )
        {
            if (*pcbUrlInfo < cbUrlInfo)
            {
                fResult = FALSE;
                SetLastError( (DWORD) E_INVALIDARG );
            }
            else
            {
                pUrlInfo->cbSize = sizeof( CRYPT_URL_INFO );
                pUrlInfo->dwSyncDeltaTime = dwSyncDeltaTime;
                pUrlInfo->cGroup = cGroup;

                if ( cGroup > 0 )
                {
                    pUrlInfo->rgcGroupEntry = (DWORD *) &pUrlInfo[ 1 ];
                    memcpy(pUrlInfo->rgcGroupEntry, pcGroupEntry,
                        cGroup * sizeof(DWORD));
                }
                else
                {
                    pUrlInfo->rgcGroupEntry = NULL;
                }
            }
        }
        *pcbUrlInfo = cbUrlInfo;
    }

    cua.FreeArray( TRUE );
    if (pcGroupEntry)
    {
        delete pcGroupEntry;
    }
    return( fResult );
}


//+---------------------------------------------------------------------------
//
//  Function:   CertificateCrossCertDistPointGetObjectUrl
//
//  Synopsis:   get certificate cross certificate URL
//
//----------------------------------------------------------------------------
BOOL WINAPI
CertificateCrossCertDistPointGetObjectUrl(
           IN LPCSTR pszUrlOid,
           IN LPVOID pvPara,
           IN DWORD dwFlags,
           OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
           IN OUT DWORD* pcbUrlArray,
           OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
           IN OUT OPTIONAL DWORD* pcbUrlInfo,
           IN LPVOID pvReserved
           )
{
    BOOL               fResult = FALSE;
    CRYPT_RAW_URL_DATA RawData[MAX_RAW_URL_DATA];
    ULONG              cRawData = MAX_RAW_URL_DATA;

    fResult = ObjectContextGetRawUrlData(
                    CONTEXT_OID_CERTIFICATE,
                    pvPara,
                    (DWORD) -1L,                         // Index
                    dwFlags,
                    szOID_CROSS_CERT_DIST_POINTS,
                    RawData,
                    &cRawData
                    );

    if ( fResult == TRUE )
    {
        fResult = GetUrlArrayAndInfoFromCrossCertDistPoint(
                     cRawData,
                     RawData,
                     pUrlArray,
                     pcbUrlArray,
                     pUrlInfo,
                     pcbUrlInfo
                     );

        ObjectContextFreeRawUrlData( cRawData, RawData );
    }

    return( fResult );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\urlprov.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       urlprov.h
//
//  Contents:   CryptGetObjectUrl provider definitions
//
//  History:    16-Sep-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__URLPROV_H__)
#define __URLPROV_H__

#if defined(__cplusplus)
extern "C" {
#endif

//
// CryptGetObjectUrl provider prototypes
//

typedef BOOL (WINAPI *PFN_GET_OBJECT_URL_FUNC) (
                          IN LPCSTR pszUrlOid,
                          IN LPVOID pvPara,
                          IN DWORD dwFlags,
                          OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
                          IN OUT DWORD* pcbUrlArray,
                          OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
                          IN OUT OPTIONAL DWORD* pcbUrlInfo,
                          IN OPTIONAL LPVOID pvReserved
                          );

BOOL WINAPI
CertificateIssuerGetObjectUrl (
           IN LPCSTR pszUrlOid,
           IN LPVOID pvPara,
           IN DWORD dwFlags,
           OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
           IN OUT DWORD* pcbUrlArray,
           OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
           IN OUT OPTIONAL DWORD* pcbUrlInfo,
           IN OPTIONAL LPVOID pvReserved
           );

BOOL WINAPI
CertificateCrlDistPointGetObjectUrl (
           IN LPCSTR pszUrlOid,
           IN LPVOID pvPara,
           IN DWORD dwFlags,
           OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
           IN OUT DWORD* pcbUrlArray,
           OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
           IN OUT OPTIONAL DWORD* pcbUrlInfo,
           IN LPVOID pvReserved
           );

typedef struct _URL_OID_CTL_ISSUER_PARAM {

    PCCTL_CONTEXT pCtlContext;
    DWORD         SignerIndex;

} URL_OID_CTL_ISSUER_PARAM, *PURL_OID_CTL_ISSUER_PARAM;

BOOL WINAPI
CtlIssuerGetObjectUrl (
   IN LPCSTR pszUrlOid,
   IN LPVOID pvPara,
   IN DWORD dwFlags,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo,
   IN LPVOID pvReserved
   );

BOOL WINAPI
CtlNextUpdateGetObjectUrl (
   IN LPCSTR pszUrlOid,
   IN LPVOID pvPara,
   IN DWORD dwFlags,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo,
   IN LPVOID pvReserved
   );

BOOL WINAPI
CrlIssuerGetObjectUrl (
   IN LPCSTR pszUrlOid,
   IN LPVOID pvPara,
   IN DWORD dwFlags,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo,
   IN LPVOID pvReserved
   );

BOOL WINAPI
CertificateFreshestCrlGetObjectUrl(
           IN LPCSTR pszUrlOid,
           IN LPVOID pvPara,
           IN DWORD dwFlags,
           OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
           IN OUT DWORD* pcbUrlArray,
           OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
           IN OUT OPTIONAL DWORD* pcbUrlInfo,
           IN OPTIONAL LPVOID pvReserved
           );

BOOL WINAPI
CrlFreshestCrlGetObjectUrl(
           IN LPCSTR pszUrlOid,
           IN LPVOID pvPara,
           IN DWORD dwFlags,
           OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
           IN OUT DWORD* pcbUrlArray,
           OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
           IN OUT OPTIONAL DWORD* pcbUrlInfo,
           IN OPTIONAL LPVOID pvReserved
           );

BOOL WINAPI
CertificateCrossCertDistPointGetObjectUrl(
           IN LPCSTR pszUrlOid,
           IN LPVOID pvPara,
           IN DWORD dwFlags,
           OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
           IN OUT DWORD* pcbUrlArray,
           OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
           IN OUT OPTIONAL DWORD* pcbUrlInfo,
           IN LPVOID pvReserved
           );

//
// CryptGetObjectUrl helper function prototypes
//

BOOL WINAPI
ObjectContextUrlFromInfoAccess (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN DWORD Index,
      IN LPCSTR pszInfoAccessOid,
      IN DWORD dwFlags,
      IN LPCSTR pszAccessMethodOid,
      OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
      IN OUT DWORD* pcbUrlArray,
      OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
      IN OUT OPTIONAL DWORD* pcbUrlInfo,
      IN LPVOID pvReserved
      );

BOOL WINAPI
ObjectContextUrlFromCrlDistPoint (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN DWORD Index,
      IN DWORD dwFlags,
      IN LPCSTR pszSourceOid,
      OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
      IN OUT DWORD* pcbUrlArray,
      OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
      IN OUT OPTIONAL DWORD* pcbUrlInfo,
      IN LPVOID pvReserved
      );

BOOL WINAPI
ObjectContextUrlFromNextUpdateLocation (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN DWORD Index,
      IN DWORD dwFlags,
      OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
      IN OUT DWORD* pcbUrlArray,
      OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
      IN OUT OPTIONAL DWORD* pcbUrlInfo,
      IN LPVOID pvReserved
      );

VOID WINAPI
InitializeDefaultUrlInfo (
          OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
          IN OUT DWORD* pcbUrlInfo
          );

#define MAX_RAW_URL_DATA 4

typedef struct _CRYPT_RAW_URL_DATA {

    DWORD  dwFlags;
    LPVOID pvData;

} CRYPT_RAW_URL_DATA, *PCRYPT_RAW_URL_DATA;

BOOL WINAPI
ObjectContextGetRawUrlData (
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN DWORD Index,
      IN DWORD dwFlags,
      IN LPCSTR pszSourceOid,
      OUT PCRYPT_RAW_URL_DATA aRawUrlData,
      IN OUT DWORD* pcRawUrlData
      );

VOID WINAPI
ObjectContextFreeRawUrlData (
      IN DWORD cRawUrlData,
      IN PCRYPT_RAW_URL_DATA aRawUrlData
      );

BOOL WINAPI
GetUrlArrayAndInfoFromInfoAccess (
   IN DWORD cRawUrlData,
   IN PCRYPT_RAW_URL_DATA aRawUrlData,
   IN LPCSTR pszAccessMethodOid,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo
   );

BOOL WINAPI
GetUrlArrayAndInfoFromCrlDistPoint (
   IN DWORD cRawUrlData,
   IN PCRYPT_RAW_URL_DATA aRawUrlData,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo
   );

BOOL WINAPI
GetUrlArrayAndInfoFromNextUpdateLocation (
   IN DWORD cRawUrlData,
   IN PCRYPT_RAW_URL_DATA aRawUrlData,
   OUT OPTIONAL PCRYPT_URL_ARRAY pUrlArray,
   IN OUT DWORD* pcbUrlArray,
   OUT OPTIONAL PCRYPT_URL_INFO pUrlInfo,
   IN OUT OPTIONAL DWORD* pcbUrlInfo
   );

VOID WINAPI
CopyUrlArray (
    IN PCRYPT_URL_ARRAY pDest,
    IN PCRYPT_URL_ARRAY pSource,
    IN DWORD cbSource
    );

VOID WINAPI
GetUrlArrayIndex (
   IN PCRYPT_URL_ARRAY pUrlArray,
   IN LPWSTR pwszUrl,
   IN DWORD DefaultIndex,
   OUT DWORD* pUrlIndex,
   OUT BOOL* pfHintInArray
   );

//
// Provider table externs
//

extern HCRYPTOIDFUNCSET hGetObjectUrlFuncSet;

#if defined(__cplusplus)
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\rpor\tvo.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows NT Security
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       tvo.h
//
//  Contents:   Get Time Valid Object Definitions and Prototypes
//
//  History:    25-Sep-97    kirtd    Created
//
//----------------------------------------------------------------------------
#if !defined(__TVO_H__)
#define __TVO_H__

#include <origin.h>
#include <lrucache.h>
#include <offurl.h>

//
// CryptGetTimeValidObject provider prototypes
//

typedef BOOL (WINAPI *PFN_GET_TIME_VALID_OBJECT_FUNC) (
                          IN LPCSTR pszTimeValidOid,
                          IN LPVOID pvPara,
                          IN PCCERT_CONTEXT pIssuer,
                          IN LPFILETIME pftValidFor,
                          IN DWORD dwFlags,
                          IN DWORD dwTimeout,
                          OUT OPTIONAL LPVOID* ppvObject,
                          IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
                          IN OPTIONAL LPVOID pvReserved
                          );

BOOL WINAPI
CtlGetTimeValidObject (
   IN LPCSTR pszTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN LPFILETIME pftValidFor,
   IN DWORD dwFlags,
   IN DWORD dwTimeout,
   OUT OPTIONAL LPVOID* ppvObject,
   IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
   IN OPTIONAL LPVOID pvReserved
   );

BOOL WINAPI
CrlGetTimeValidObject (
   IN LPCSTR pszTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN LPFILETIME pftValidFor,
   IN DWORD dwFlags,
   IN DWORD dwTimeout,
   OUT OPTIONAL LPVOID* ppvObject,
   IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
   IN OPTIONAL LPVOID pvReserved
   );

BOOL WINAPI
CrlFromCertGetTimeValidObject (
   IN LPCSTR pszTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN LPFILETIME pftValidFor,
   IN DWORD dwFlags,
   IN DWORD dwTimeout,
   OUT OPTIONAL LPVOID* ppvObject,
   IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
   IN OPTIONAL LPVOID pvReserved
   );

BOOL WINAPI
FreshestCrlFromCertGetTimeValidObject (
   IN LPCSTR pszTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN LPFILETIME pftValidFor,
   IN DWORD dwFlags,
   IN DWORD dwTimeout,
   OUT OPTIONAL LPVOID* ppvObject,
   IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
   IN OPTIONAL LPVOID pvReserved
   );

BOOL WINAPI
FreshestCrlFromCrlGetTimeValidObject (
   IN LPCSTR pszTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN LPFILETIME pftValidFor,
   IN DWORD dwFlags,
   IN DWORD dwTimeout,
   OUT OPTIONAL LPVOID* ppvObject,
   IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
   IN OPTIONAL LPVOID pvReserved
   );

//
// CryptFlushTimeValidObject provider prototypes
//

typedef BOOL (WINAPI *PFN_FLUSH_TIME_VALID_OBJECT_FUNC) (
                          IN LPCSTR pszFlushTimeValidOid,
                          IN LPVOID pvPara,
                          IN PCCERT_CONTEXT pIssuer,
                          IN DWORD dwFlags,
                          IN LPVOID pvReserved
                          );

BOOL WINAPI
CtlFlushTimeValidObject (
   IN LPCSTR pszFlushTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN DWORD dwFlags,
   IN LPVOID pvReserved
   );

BOOL WINAPI
CrlFlushTimeValidObject (
   IN LPCSTR pszFlushTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN DWORD dwFlags,
   IN LPVOID pvReserved
   );

BOOL WINAPI
CrlFromCertFlushTimeValidObject (
   IN LPCSTR pszFlushTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN DWORD dwFlags,
   IN LPVOID pvReserved
   );

BOOL WINAPI
FreshestCrlFromCertFlushTimeValidObject (
   IN LPCSTR pszFlushTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN DWORD dwFlags,
   IN LPVOID pvReserved
   );

BOOL WINAPI
FreshestCrlFromCrlFlushTimeValidObject (
   IN LPCSTR pszFlushTimeValidOid,
   IN LPVOID pvPara,
   IN PCCERT_CONTEXT pIssuer,
   IN DWORD dwFlags,
   IN LPVOID pvReserved
   );

//
// Provider table externs
//

extern HCRYPTOIDFUNCSET hGetTimeValidObjectFuncSet;
extern HCRYPTOIDFUNCSET hFlushTimeValidObjectFuncSet;


//
// The TVO Cache.  This is a cache of time valid objects by origin identifier
// which is used to support the CryptGetTimeValidObject process.  It is
// used by a process wide TVO agent with each cache entry consisting of
// the following information:
//
// Object Origin Identifier
// Object Context Oid
// Object Context
// Object Retrieval URL
// Object Expire Time
// Object Offline URL Time Information
//

typedef struct _TVO_CACHE_ENTRY {

    CRYPT_ORIGIN_IDENTIFIER OriginIdentifier;
    LPCSTR                  pszContextOid;
    LPVOID                  pvContext;
    DWORD                   cbUrlArrayThis;
    PCRYPT_URL_ARRAY        pUrlArrayThis;
    DWORD                   UrlIndexThis;
    DWORD                   cbUrlArrayNext;
    PCRYPT_URL_ARRAY        pUrlArrayNext;
    DWORD                   UrlIndexNext;
    FILETIME                CreateTime;
    FILETIME                ExpireTime;
    HLRUENTRY               hLruEntry;
    OFFLINE_URL_TIME_INFO   OfflineUrlTimeInfo;
} TVO_CACHE_ENTRY, *PTVO_CACHE_ENTRY;

class CTVOCache
{
public:

    //
    // Construction
    //

    CTVOCache (
        DWORD cCacheBuckets,
        DWORD MaxCacheEntries,
        BOOL& rfResult
        );

    ~CTVOCache ();

    //
    // Direct cache entry manipulation
    //

    VOID InsertCacheEntry (PTVO_CACHE_ENTRY pEntry);

    VOID RemoveCacheEntry (PTVO_CACHE_ENTRY pEntry, BOOL fSuppressFree = FALSE);

    VOID TouchCacheEntry (PTVO_CACHE_ENTRY pEntry);

    //
    // Origin identifier based cache entry manipulation
    //
    // For CONTEXT_OID_CRL, pvSubject is the certificate that the CRL is
    // valid for. Skips CRL entries that aren't valid for the certificate.
    //

    PTVO_CACHE_ENTRY FindCacheEntry (
                         CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
                         LPCSTR pszContextOid,
                         LPVOID pvSubject
                         );

    //
    // Remove all cache entries
    //

    VOID RemoveAllCacheEntries ();

    //
    // Access to the cache handle
    //

    inline HLRUCACHE LruCacheHandle ();

private:

    //
    // Cache handle
    //

    HLRUCACHE m_hCache;
};

DWORD WINAPI TVOCacheHashOriginIdentifier (PCRYPT_DATA_BLOB pIdentifier);

VOID WINAPI TVOCacheOnRemoval (LPVOID pvData, LPVOID pvRemovalContext);


//
// The TVO Agent.  This per process service takes care of the retrieval of
// time valid CAPI2 objects.  It allows this to be done on-demand or with
// auto-update
//

class CTVOAgent
{
public:

    //
    // Construction
    //

    CTVOAgent (
        DWORD cCacheBuckets,
        DWORD MaxCacheEntries,
        BOOL& rfResult
        );

    ~CTVOAgent ();

    //
    // Get Time Valid Object methods
    //

    BOOL GetTimeValidObject (
            IN LPCSTR pszTimeValidOid,
            IN LPVOID pvPara,
            IN LPCSTR pszContextOid,
            IN PCCERT_CONTEXT pIssuer,
            IN LPFILETIME pftValidFor,
            IN DWORD dwFlags,
            IN DWORD dwTimeout,
            OUT OPTIONAL LPVOID* ppvObject,
            IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
            IN OPTIONAL LPVOID pvReserved
            );

    BOOL GetTimeValidObjectByUrl (
            IN DWORD cbUrlArray,
            IN PCRYPT_URL_ARRAY pUrlArray,
            IN DWORD PreferredUrlIndex,
            IN LPCSTR pszContextOid,
            IN PCCERT_CONTEXT pIssuer,
            IN LPVOID pvSubject,
            IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
            IN LPFILETIME pftValidFor,
            IN DWORD dwFlags,
            IN DWORD dwTimeout,
            OUT OPTIONAL LPVOID* ppvObject,
            IN OPTIONAL PCRYPT_CREDENTIALS pCredentials,
            IN OPTIONAL LPWSTR pwszUrlExtra,
            OUT BOOL* pfArrayOwned,
            IN OPTIONAL LPVOID pvReserved
            );

    BOOL FlushTimeValidObject (
              IN LPCSTR pszFlushTimeValidOid,
              IN LPVOID pvPara,
              IN LPCSTR pszFlushContextOid,
              IN PCCERT_CONTEXT pIssuer,
              IN DWORD dwFlags,
              IN LPVOID pvReserved
              );

private:

    //
    // Object lock
    //

    CRITICAL_SECTION m_Lock;

    //
    // TVO cache
    //

    CTVOCache        m_Cache;
};

//
// Utility functions
//

BOOL WINAPI
IsValidCreateOrExpireTime (
    IN BOOL fCheckFreshnessTime,
    IN LPFILETIME pftValidFor,
    IN LPFILETIME pftCreateTime,
    IN LPFILETIME pftExpireTime
    );

BOOL WINAPI
ObjectContextCreateTVOCacheEntry (
      IN HLRUCACHE hCache,
      IN LPCSTR pszContextOid,
      IN LPVOID pvContext,
      IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
      IN DWORD cbUrlArrayThis,
      IN PCRYPT_URL_ARRAY pUrlArrayThis,
      IN DWORD UrlIndexThis,
      IN PCCERT_CONTEXT pIssuer,
      OUT PTVO_CACHE_ENTRY* ppEntry
      );

VOID WINAPI
ObjectContextFreeTVOCacheEntry (
      IN PTVO_CACHE_ENTRY pEntry
      );


BOOL WINAPI
CertificateGetCrlDistPointUrl (
           IN LPCSTR pszUrlOid,
           IN LPVOID pvPara,
           IN LPWSTR pwszUrlHint,
           OUT PCRYPT_URL_ARRAY* ppUrlArray,
           OUT DWORD* pcbUrlArray,
           OUT DWORD* pPreferredUrlIndex,
           OUT BOOL* pfHintInArray
           );

BOOL WINAPI
RetrieveTimeValidObjectByUrl (
        IN LPWSTR pwszUrl,
        IN LPCSTR pszContextOid,
        IN LPFILETIME pftValidFor,
        IN DWORD dwFlags,
        IN DWORD dwTimeout,
        IN PCRYPT_CREDENTIALS pCredentials,
        IN PCCERT_CONTEXT pSigner,
        IN LPVOID pvSubject,
        IN CRYPT_ORIGIN_IDENTIFIER OriginIdentifier,
        OUT LPVOID* ppvObject
        );

#define TVO_KEY_NAME "Software\\Microsoft\\Cryptography\\TVO"
#define TVO_CACHE_BUCKETS_VALUE_NAME "DefaultProcessCacheBuckets"
#define TVO_MAX_CACHE_ENTRIES_VALUE_NAME "DefaultProcessMaxCacheEntries"

#define TVO_DEFAULT_CACHE_BUCKETS     32
#define TVO_DEFAULT_MAX_CACHE_ENTRIES 128

BOOL WINAPI
CreateProcessTVOAgent (
      OUT CTVOAgent** ppAgent
      );

//
// Extern for process global agent
//

extern CTVOAgent* g_pProcessTVOAgent;

//
// Inline functions
//

//+---------------------------------------------------------------------------
//
//  Member:     CTVOCache::LruCacheHandle, public
//
//  Synopsis:   return the HLRUCACHE
//
//----------------------------------------------------------------------------
inline HLRUCACHE
CTVOCache::LruCacheHandle ()
{
    return( m_hCache );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\setx509\x509.h ===
/* Copyright (C) Microsoft Corporation, 1996 - 1999 All rights reserved. */
/* ASN.1 definitions for SET X509 v3 certificates */

#ifndef _X509_Module_H_
#define _X509_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef ASN1intx_t HUGEINTEGER;

typedef ASN1bitstring_t BITSTRING;

typedef ASN1octetstring_t OCTETSTRING;

typedef ASN1open_t NOCOPYANY;

typedef ASN1charstring_t NUMERICSTRING;

typedef ASN1charstring_t PRINTABLESTRING;

typedef ASN1charstring_t TELETEXSTRING;

typedef ASN1charstring_t T61STRING;

typedef ASN1charstring_t VIDEOTEXSTRING;

typedef ASN1charstring_t IA5STRING;

typedef ASN1charstring_t GRAPHICSTRING;

typedef ASN1charstring_t VISIBLESTRING;

typedef ASN1charstring_t ISO646STRING;

typedef ASN1charstring_t GENERALSTRING;

typedef ASN1char32string_t UNIVERSALSTRING;

typedef ASN1char16string_t BMPSTRING;

typedef ASN1bool_t SETAccountAlias;
#define SETAccountAlias_PDU 0
#define SIZE_X509_Module_PDU_0 sizeof(SETAccountAlias)

typedef OCTETSTRING SETHashedRootKey;
#define SETHashedRootKey_PDU 1
#define SIZE_X509_Module_PDU_1 sizeof(SETHashedRootKey)

typedef BITSTRING SETCertificateType;
#define SETCertificateType_PDU 2
#define SIZE_X509_Module_PDU_2 sizeof(SETCertificateType)

typedef struct SETMerchantData {
    IA5STRING merID;
    NUMERICSTRING merAcquirerBIN;
    IA5STRING merTermID;
    IA5STRING merName;
    IA5STRING merCity;
    IA5STRING merStateProvince;
    IA5STRING merPostalCode;
    IA5STRING merCountry;
    IA5STRING merPhone;
    ASN1bool_t merPhoneRelease;
    ASN1bool_t merAuthFlag;
} SETMerchantData;
#define SETMerchantData_PDU 3
#define SIZE_X509_Module_PDU_3 sizeof(SETMerchantData)


extern ASN1module_t X509_Module;
extern void ASN1CALL X509_Module_Startup(void);
extern void ASN1CALL X509_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _X509_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\siphelp\sipfuncs.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       sipfuncs.cpp
//
//  Contents:   Microsoft Internet Security SIP Provider
//
//  Functions:  CryptSIPDllMain
//              CryptSIPPutSignedDataMsg
//              CryptSIPGetSignedDataMsg
//              CryptSIPRemoveSignedDataMsg
//              CryptSIPCreateIndirectData
//              CryptSIPVerifyIndirectData
//
//              *** local functions ***
//              _Guid2Sz
//              _LoadIsFuncs
//              _EnumOIDCallback
//
//  History:    01-Dec-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

HCRYPTOIDFUNCSET hPutFuncSet;
HCRYPTOIDFUNCSET hGetFuncSet;
HCRYPTOIDFUNCSET hRemoveFuncSet;
HCRYPTOIDFUNCSET hCreateFuncSet;
HCRYPTOIDFUNCSET hVerifyFuncSet;
HCRYPTOIDFUNCSET hIsMyFileFuncSet;
HCRYPTOIDFUNCSET hIsMyFileFuncSet2;

CRITICAL_SECTION SIP_CriticalSection;
BOOL             fLoadedIsFuncs = FALSE;

typedef struct ISFUNCREF_
{
    DWORD   cGuids;
    GUID    *pGuids;

} ISFUNCREF;

ISFUNCREF       sIsGuids;
ISFUNCREF       sIsGuids2;

void _LoadIsFuncs(void);
BOOL _CallIsMyFileType2(GUID *pgIn, WCHAR *pwszFile, GUID *pgOut);
BOOL _CallIsMyFileType(GUID *pgIn, HANDLE hFile, GUID *pgOut);

BOOL WINAPI _EnumOIDCallback(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID,
                             DWORD cValue, const DWORD rgdwValueType[], LPCWSTR const rgpwszValueName[],
                             const BYTE * const rgpbValueData[], const DWORD rgcbValueData[],
                             void *pvArg);

BOOL WINAPI CryptSIPDllMain(HMODULE hModule, DWORD  fdwReason, LPVOID lpReserved)
{
    BOOL    fRet;

    fRet = TRUE;

    switch (fdwReason)
    {
        case DLL_PROCESS_ATTACH:

            memset(&sIsGuids, 0x00, sizeof(ISFUNCREF));
            memset(&sIsGuids2, 0x00, sizeof(ISFUNCREF));

            if (!(hPutFuncSet = CryptInitOIDFunctionSet(SIPFUNC_PUTSIGNATURE, 0))) 
            {
                goto PutFuncSetFailed;
            }

            if (!(hGetFuncSet = CryptInitOIDFunctionSet(SIPFUNC_GETSIGNATURE, 0))) 
            {
                goto GetFuncSetFailed;
            }

            if (!(hRemoveFuncSet = CryptInitOIDFunctionSet(SIPFUNC_REMSIGNATURE, 0))) 
            {
                goto RemoveFuncSetFailed;
            }

            if (!(hCreateFuncSet = CryptInitOIDFunctionSet(SIPFUNC_CREATEINDIRECT, 0))) 
            {
                goto CreateFuncSetFailed;
            }

            if (!(hVerifyFuncSet = CryptInitOIDFunctionSet(SIPFUNC_VERIFYINDIRECT, 0))) 
            {
                goto VerifyFuncSetFailed;
            }
            
            if (!(hIsMyFileFuncSet = CryptInitOIDFunctionSet(SIPFUNC_ISMYTYPE, 0))) 
            {
                goto VerifyFuncSetFailed;
            }

            if (!(hIsMyFileFuncSet2 = CryptInitOIDFunctionSet(SIPFUNC_ISMYTYPE2, 0))) 
            {
                goto VerifyFuncSetFailed;
            }

            if (!Pki_InitializeCriticalSection(&SIP_CriticalSection))
            {
                goto InitCritSectionFailed;
            }

            break;

        case DLL_PROCESS_DETACH:
        
            if (fLoadedIsFuncs)
            {
                EnterCriticalSection(&SIP_CriticalSection);
                    DELETE_OBJECT(sIsGuids.pGuids);
                    DELETE_OBJECT(sIsGuids2.pGuids);
                    sIsGuids.cGuids = 0;
                    sIsGuids2.cGuids = 0;
                    fLoadedIsFuncs = FALSE;
                LeaveCriticalSection(&SIP_CriticalSection);
            }

            DeleteCriticalSection(&SIP_CriticalSection);
            break;
    }

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, InitCritSectionFailed);
    TRACE_ERROR_EX(DBG_SS, PutFuncSetFailed);
    TRACE_ERROR_EX(DBG_SS, GetFuncSetFailed);
    TRACE_ERROR_EX(DBG_SS, RemoveFuncSetFailed);
    TRACE_ERROR_EX(DBG_SS, CreateFuncSetFailed);
    TRACE_ERROR_EX(DBG_SS, VerifyFuncSetFailed);
}


BOOL WINAPI CryptSIPPutSignedDataMsg(SIP_SUBJECTINFO *pSubjectInfo,
                                     DWORD dwEncodingType,
                                     DWORD *pdwIndex,
                                     DWORD cbSignedDataMsg,
                                     BYTE *pbSignedDataMsg)
{
    BOOL    fRet;

    if (!(pSubjectInfo) ||
        !(pSubjectInfo->pgSubjectType))
    {
        goto InvalidParam;
    }

    HCRYPTOIDFUNCADDR           hPfn;
    pCryptSIPPutSignedDataMsg   pfn;
    char                        szGuid[REG_MAX_GUID_TEXT];

    if (!(_Guid2Sz(pSubjectInfo->pgSubjectType, &szGuid[0])))
    {
        goto GuidConvertFailed;
    }

    if (!(CryptGetOIDFunctionAddress(hPutFuncSet, 0, &szGuid[0], 0, (void **)&pfn, &hPfn)))
    {
        goto GetFuncAddrFailed;
    }

    fRet = pfn(pSubjectInfo, dwEncodingType, pdwIndex, cbSignedDataMsg, pbSignedDataMsg);

    CryptFreeOIDFunctionAddress(hPfn, 0);

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    SET_ERROR_VAR_EX(DBG_SS, GetFuncAddrFailed, TRUST_E_SUBJECT_FORM_UNKNOWN);
    SET_ERROR_VAR_EX(DBG_SS, GuidConvertFailed, TRUST_E_SUBJECT_FORM_UNKNOWN);

    SET_ERROR_VAR_EX(DBG_SS, InvalidParam,  ERROR_INVALID_PARAMETER);
}


BOOL WINAPI CryptSIPGetSignedDataMsg(SIP_SUBJECTINFO *pSubjectInfo,
                                     DWORD *pdwEncodingType,
                                     DWORD dwIndex,
                                     DWORD *pcbSignedDataMsg,
                                     BYTE *pbSignedDataMsg)
{
    BOOL    fRet;

    if (!(pSubjectInfo) ||
        !(pSubjectInfo->pgSubjectType))
    {
        goto InvalidParam;
    }

    HCRYPTOIDFUNCADDR           hPfn;
    pCryptSIPGetSignedDataMsg   pfn;
    char                        szGuid[REG_MAX_GUID_TEXT];

    if (!(_Guid2Sz(pSubjectInfo->pgSubjectType, &szGuid[0])))
    {
        goto GuidConvertFailed;
    }

    if (!(CryptGetOIDFunctionAddress(hGetFuncSet, 0, &szGuid[0], 0, (void **)&pfn, &hPfn)))
    {
        goto GetFuncAddrFailed;
    }

    fRet = pfn(pSubjectInfo, pdwEncodingType, dwIndex, pcbSignedDataMsg, pbSignedDataMsg);

    CryptFreeOIDFunctionAddress(hPfn, 0);

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    SET_ERROR_VAR_EX(DBG_SS, GetFuncAddrFailed, TRUST_E_SUBJECT_FORM_UNKNOWN);
    SET_ERROR_VAR_EX(DBG_SS, GuidConvertFailed, TRUST_E_SUBJECT_FORM_UNKNOWN);

    SET_ERROR_VAR_EX(DBG_SS, InvalidParam,  ERROR_INVALID_PARAMETER);
}

BOOL WINAPI CryptSIPRemoveSignedDataMsg(SIP_SUBJECTINFO *pSubjectInfo,
                                        DWORD dwIndex)
{
    BOOL    fRet;

    if (!(pSubjectInfo) ||
        !(pSubjectInfo->pgSubjectType))
    {
        goto InvalidParam;
    }

    HCRYPTOIDFUNCADDR           hPfn;
    pCryptSIPRemoveSignedDataMsg pfn;
    char                        szGuid[REG_MAX_GUID_TEXT];

    if (!(_Guid2Sz(pSubjectInfo->pgSubjectType, &szGuid[0])))
    {
        goto GuidConvertFailed;
    }

    if (!(CryptGetOIDFunctionAddress(hRemoveFuncSet, 0, &szGuid[0], 0, (void **)&pfn, &hPfn)))
    {
        goto GetFuncAddrFailed;
    }

    fRet = pfn(pSubjectInfo, dwIndex);

    CryptFreeOIDFunctionAddress(hPfn, 0);

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    SET_ERROR_VAR_EX(DBG_SS, GetFuncAddrFailed, TRUST_E_SUBJECT_FORM_UNKNOWN);
    SET_ERROR_VAR_EX(DBG_SS, GuidConvertFailed, TRUST_E_SUBJECT_FORM_UNKNOWN);

    SET_ERROR_VAR_EX(DBG_SS, InvalidParam,  ERROR_INVALID_PARAMETER);
}

BOOL WINAPI CryptSIPCreateIndirectData(SIP_SUBJECTINFO *pSubjectInfo,
                                       DWORD *pcbIndirectData,
                                       SIP_INDIRECT_DATA *pIndirectData)
{
    BOOL    fRet;

    if (!(pSubjectInfo) ||
        !(pSubjectInfo->pgSubjectType))
    {
        goto InvalidParam;
    }

    HCRYPTOIDFUNCADDR           hPfn;
    pCryptSIPCreateIndirectData pfn;
    char                        szGuid[REG_MAX_GUID_TEXT];

    if (!(_Guid2Sz(pSubjectInfo->pgSubjectType, &szGuid[0])))
    {
        goto GuidConvertFailed;
    }

    if (!(CryptGetOIDFunctionAddress(hCreateFuncSet, 0, &szGuid[0], 0, (void **)&pfn, &hPfn)))
    {
        goto GetFuncAddrFailed;
    }

    fRet = pfn(pSubjectInfo, pcbIndirectData, pIndirectData);

    CryptFreeOIDFunctionAddress(hPfn, 0);

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    SET_ERROR_VAR_EX(DBG_SS, GetFuncAddrFailed, TRUST_E_SUBJECT_FORM_UNKNOWN);
    SET_ERROR_VAR_EX(DBG_SS, GuidConvertFailed, TRUST_E_SUBJECT_FORM_UNKNOWN);

    SET_ERROR_VAR_EX(DBG_SS, InvalidParam,  ERROR_INVALID_PARAMETER);
}

BOOL WINAPI CryptSIPVerifyIndirectData(SIP_SUBJECTINFO *pSubjectInfo,
                                       SIP_INDIRECT_DATA *pIndirectData)
{
    BOOL    fRet;

    if (!(pSubjectInfo) ||
        !(pSubjectInfo->pgSubjectType))
    {
        goto InvalidParam;
    }

    HCRYPTOIDFUNCADDR           hPfn;
    pCryptSIPVerifyIndirectData pfn;
    char                        szGuid[REG_MAX_GUID_TEXT];

    if (!(_Guid2Sz(pSubjectInfo->pgSubjectType, &szGuid[0])))
    {
        goto GuidConvertFailed;
    }

    if (!(CryptGetOIDFunctionAddress(hVerifyFuncSet, 0, &szGuid[0], 0, (void **)&pfn, &hPfn)))
    {
        goto GetFuncAddrFailed;
    }

    fRet = pfn(pSubjectInfo, pIndirectData);

    CryptFreeOIDFunctionAddress(hPfn, 0);

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    SET_ERROR_VAR_EX(DBG_SS, GetFuncAddrFailed, TRUST_E_SUBJECT_FORM_UNKNOWN);
    SET_ERROR_VAR_EX(DBG_SS, GuidConvertFailed, TRUST_E_SUBJECT_FORM_UNKNOWN);

    SET_ERROR_VAR_EX(DBG_SS, InvalidParam,  ERROR_INVALID_PARAMETER);
}


BOOL _Guid2Sz(GUID *pgGuid, char *pszGuid)
{
    WCHAR wszGuid[REG_MAX_GUID_TEXT];

    if (!(guid2wstr(pgGuid, &wszGuid[0])))
    {
        return(FALSE);
    }

    if (WideCharToMultiByte(0, 0, &wszGuid[0], -1, pszGuid, REG_MAX_GUID_TEXT, NULL, NULL) == 0)
    {
        return(FALSE);
    }

    return(TRUE);
}

BOOL _QueryRegisteredIsMyFileType(HANDLE hFile, LPCWSTR pwszFile, GUID *pgSubject)
{
    if (!(fLoadedIsFuncs))
    {
        EnterCriticalSection(&SIP_CriticalSection);

            if (!(fLoadedIsFuncs))
            {
                CryptEnumOIDFunction(0, SIPFUNC_ISMYTYPE, NULL, 0, (void *)&sIsGuids, _EnumOIDCallback);
                CryptEnumOIDFunction(0, SIPFUNC_ISMYTYPE2, NULL, 0, (void *)&sIsGuids2, _EnumOIDCallback);
                fLoadedIsFuncs = TRUE;
            }

        LeaveCriticalSection(&SIP_CriticalSection);
    }


    DWORD       i;
    
    i = 0;
    while (i < sIsGuids.cGuids)
    {
        if (_CallIsMyFileType(&sIsGuids.pGuids[i], hFile, pgSubject))
        {
            return(TRUE);
        }

        i++;
    }
    
    i = 0;
    while (i < sIsGuids2.cGuids)
    {
        if (_CallIsMyFileType2(&sIsGuids2.pGuids[i], (WCHAR *)pwszFile, pgSubject))
        {
            return(TRUE);
        }

        i++;
    }

    return(FALSE);
}

BOOL _CallIsMyFileType(GUID *pgIn, HANDLE hFile, GUID *pgOut)
{
    BOOL    fRet;

    HCRYPTOIDFUNCADDR           hPfn;
    pfnIsFileSupported          pfn;
    char                        szGuid[REG_MAX_GUID_TEXT];

    if (!(_Guid2Sz(pgIn, &szGuid[0])))
    {
        goto GuidConvertFailed;
    }

    if (!(CryptGetOIDFunctionAddress(hIsMyFileFuncSet, 0, &szGuid[0], 0, (void **)&pfn, &hPfn)))
    {
        goto GetFuncAddrFailed;
    }

    fRet = pfn(hFile, pgOut);

    CryptFreeOIDFunctionAddress(hPfn, 0);

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, GetFuncAddrFailed);
    TRACE_ERROR_EX(DBG_SS, GuidConvertFailed);
}

BOOL _CallIsMyFileType2(GUID *pgIn, WCHAR *pwszFile, GUID *pgOut)
{
    BOOL                        fRet;

    HCRYPTOIDFUNCADDR           hPfn;
    pfnIsFileSupported          pfn;
    char                        szGuid[REG_MAX_GUID_TEXT];

    if (!(_Guid2Sz(pgIn, &szGuid[0])))
    {
        goto GuidConvertFailed;
    }

    if (!(CryptGetOIDFunctionAddress(hIsMyFileFuncSet2, 0, &szGuid[0], 0, (void **)&pfn, &hPfn)))
    {
        goto GetFuncAddrFailed;
    }

    fRet = pfn(pwszFile, pgOut);

    CryptFreeOIDFunctionAddress(hPfn, 0);

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, GetFuncAddrFailed);
    TRACE_ERROR_EX(DBG_SS, GuidConvertFailed);
}

void *SIPRealloc(void *pvOrg, size_t cb)
{
    void *pv;

    pv = (pvOrg) ? realloc(pvOrg, cb) : malloc(cb);

    if (!(pv))
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return(pv);
}


BOOL WINAPI _EnumOIDCallback(IN DWORD dwEncodingType,
                            IN LPCSTR pszFuncName,
                            IN LPCSTR pszOID,
                            IN DWORD cValue,
                            IN const DWORD rgdwValueType[],
                            IN LPCWSTR const rgpwszValueName[],
                            IN const BYTE * const rgpbValueData[],
                            IN const DWORD rgcbValueData[],
                            IN void *pvArg)
{
    WCHAR   wszGuid[REG_MAX_GUID_TEXT];
    GUID    g;

    wszGuid[0] = NULL;
    MultiByteToWideChar(0, 0, pszOID, -1, &wszGuid[0], REG_MAX_GUID_TEXT);

    if (wszGuid[0])
    {
        if (wstr2guid(&wszGuid[0], &g))
        {
            ISFUNCREF *pIsGuids;

            pIsGuids = (ISFUNCREF *)pvArg;

            if (!(pvArg))
            {
                return(TRUE);
            }
            
            pIsGuids->cGuids++;
            pIsGuids->pGuids = (GUID *)SIPRealloc(pIsGuids->pGuids, pIsGuids->cGuids * sizeof(GUID));

            if (!(pIsGuids->pGuids))
            {
                pIsGuids->cGuids = 0;
                return(FALSE);
            }

            memcpy(&pIsGuids->pGuids[pIsGuids->cGuids - 1], &g, sizeof(GUID));
        }
    }

    return(TRUE);   // keep going!
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\setx509\x509.c ===
/* Copyright (C) Microsoft Corporation, 1996 - 1999 All rights reserved. */
/* ASN.1 definitions for SET X509 v3 certificates */

#include <windows.h>
#include "x509.h"

ASN1module_t X509_Module = NULL;

static int ASN1CALL ASN1Enc_SETAccountAlias(ASN1encoding_t enc, ASN1uint32_t tag, SETAccountAlias *val);
static int ASN1CALL ASN1Enc_SETHashedRootKey(ASN1encoding_t enc, ASN1uint32_t tag, SETHashedRootKey *val);
static int ASN1CALL ASN1Enc_SETCertificateType(ASN1encoding_t enc, ASN1uint32_t tag, SETCertificateType *val);
static int ASN1CALL ASN1Enc_SETMerchantData(ASN1encoding_t enc, ASN1uint32_t tag, SETMerchantData *val);
static int ASN1CALL ASN1Dec_SETAccountAlias(ASN1decoding_t dec, ASN1uint32_t tag, SETAccountAlias *val);
static int ASN1CALL ASN1Dec_SETHashedRootKey(ASN1decoding_t dec, ASN1uint32_t tag, SETHashedRootKey *val);
static int ASN1CALL ASN1Dec_SETCertificateType(ASN1decoding_t dec, ASN1uint32_t tag, SETCertificateType *val);
static int ASN1CALL ASN1Dec_SETMerchantData(ASN1decoding_t dec, ASN1uint32_t tag, SETMerchantData *val);
static void ASN1CALL ASN1Free_SETHashedRootKey(SETHashedRootKey *val);
static void ASN1CALL ASN1Free_SETCertificateType(SETCertificateType *val);
static void ASN1CALL ASN1Free_SETMerchantData(SETMerchantData *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[4] = {
    (ASN1EncFun_t) ASN1Enc_SETAccountAlias,
    (ASN1EncFun_t) ASN1Enc_SETHashedRootKey,
    (ASN1EncFun_t) ASN1Enc_SETCertificateType,
    (ASN1EncFun_t) ASN1Enc_SETMerchantData,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[4] = {
    (ASN1DecFun_t) ASN1Dec_SETAccountAlias,
    (ASN1DecFun_t) ASN1Dec_SETHashedRootKey,
    (ASN1DecFun_t) ASN1Dec_SETCertificateType,
    (ASN1DecFun_t) ASN1Dec_SETMerchantData,
};
static const ASN1FreeFun_t freefntab[4] = {
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_SETHashedRootKey,
    (ASN1FreeFun_t) ASN1Free_SETCertificateType,
    (ASN1FreeFun_t) ASN1Free_SETMerchantData,
};
static const ULONG sizetab[4] = {
    SIZE_X509_Module_PDU_0,
    SIZE_X509_Module_PDU_1,
    SIZE_X509_Module_PDU_2,
    SIZE_X509_Module_PDU_3,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL X509_Module_Startup(void)
{
    X509_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 4, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x746573);
}

void ASN1CALL X509_Module_Cleanup(void)
{
    ASN1_CloseModule(X509_Module);
    X509_Module = NULL;
}

static int ASN1CALL ASN1Enc_SETAccountAlias(ASN1encoding_t enc, ASN1uint32_t tag, SETAccountAlias *val)
{
    if (!ASN1BEREncBool(enc, tag ? tag : 0x1, *val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SETAccountAlias(ASN1decoding_t dec, ASN1uint32_t tag, SETAccountAlias *val)
{
    if (!ASN1BERDecBool(dec, tag ? tag : 0x1, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_SETHashedRootKey(ASN1encoding_t enc, ASN1uint32_t tag, SETHashedRootKey *val)
{
    if (!ASN1DEREncOctetString(enc, tag ? tag : 0x4, (val)->length, (val)->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SETHashedRootKey(ASN1decoding_t dec, ASN1uint32_t tag, SETHashedRootKey *val)
{
    if (!ASN1BERDecOctetString2(dec, tag ? tag : 0x4, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SETHashedRootKey(SETHashedRootKey *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SETCertificateType(ASN1encoding_t enc, ASN1uint32_t tag, SETCertificateType *val)
{
    if (!ASN1DEREncBitString(enc, tag ? tag : 0x3, (val)->length, (val)->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SETCertificateType(ASN1decoding_t dec, ASN1uint32_t tag, SETCertificateType *val)
{
    if (!ASN1BERDecBitString2(dec, tag ? tag : 0x3, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SETCertificateType(SETCertificateType *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_SETMerchantData(ASN1encoding_t enc, ASN1uint32_t tag, SETMerchantData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x16, ((val)->merID).length, ((val)->merID).value))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x12, ((val)->merAcquirerBIN).length, ((val)->merAcquirerBIN).value))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x16, ((val)->merTermID).length, ((val)->merTermID).value))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x16, ((val)->merName).length, ((val)->merName).value))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x16, ((val)->merCity).length, ((val)->merCity).value))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x16, ((val)->merStateProvince).length, ((val)->merStateProvince).value))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x16, ((val)->merPostalCode).length, ((val)->merPostalCode).value))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x16, ((val)->merCountry).length, ((val)->merCountry).value))
	return 0;
    if (!ASN1DEREncCharString(enc, 0x16, ((val)->merPhone).length, ((val)->merPhone).value))
	return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->merPhoneRelease))
	return 0;
    if (!ASN1BEREncBool(enc, 0x1, (val)->merAuthFlag))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SETMerchantData(ASN1decoding_t dec, ASN1uint32_t tag, SETMerchantData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecCharString(dd, 0x16, &(val)->merID))
	return 0;
    if (!ASN1BERDecCharString(dd, 0x12, &(val)->merAcquirerBIN))
	return 0;
    if (!ASN1BERDecCharString(dd, 0x16, &(val)->merTermID))
	return 0;
    if (!ASN1BERDecCharString(dd, 0x16, &(val)->merName))
	return 0;
    if (!ASN1BERDecCharString(dd, 0x16, &(val)->merCity))
	return 0;
    if (!ASN1BERDecCharString(dd, 0x16, &(val)->merStateProvince))
	return 0;
    if (!ASN1BERDecCharString(dd, 0x16, &(val)->merPostalCode))
	return 0;
    if (!ASN1BERDecCharString(dd, 0x16, &(val)->merCountry))
	return 0;
    if (!ASN1BERDecCharString(dd, 0x16, &(val)->merPhone))
	return 0;
    if (!ASN1BERDecBool(dd, 0x1, &(val)->merPhoneRelease))
	return 0;
    if (!ASN1BERDecBool(dd, 0x1, &(val)->merAuthFlag))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SETMerchantData(SETMerchantData *val)
{
    if (val) {
	ASN1charstring_free(&(val)->merID);
	ASN1charstring_free(&(val)->merAcquirerBIN);
	ASN1charstring_free(&(val)->merTermID);
	ASN1charstring_free(&(val)->merName);
	ASN1charstring_free(&(val)->merCity);
	ASN1charstring_free(&(val)->merStateProvince);
	ASN1charstring_free(&(val)->merPostalCode);
	ASN1charstring_free(&(val)->merCountry);
	ASN1charstring_free(&(val)->merPhone);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\siphelp\sipadd.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       sipadd.cpp
//
//  Contents:   Microsoft Internet Security SIP Provider
//
//  Functions:  CryptSIPAddProvider
//
//              *** local functions ***
//              _RegisterSIPFunc
//
//  History:    04-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "cryptreg.h"
#include    "wintrust.h"
#include    "sipbase.h"

BOOL _RegisterSIPFunc(char *pszTag, char *pszGuid, WCHAR *pwszDll, WCHAR *pwszFunc);

BOOL WINAPI CryptSIPAddProvider(IN SIP_ADD_NEWPROVIDER *psNewProv)
{
    BOOL    fRet;
    char    szGuid[REG_MAX_GUID_TEXT];

    fRet = TRUE;

    if (!(psNewProv) ||
        !(WVT_ISINSTRUCT(SIP_ADD_NEWPROVIDER, psNewProv->cbStruct, pwszRemoveFuncName)) ||
        !(psNewProv->pwszDLLFileName) ||
        !(psNewProv->pwszGetFuncName) ||
        !(psNewProv->pwszPutFuncName) ||
        !(psNewProv->pwszCreateFuncName) ||
        !(psNewProv->pwszVerifyFuncName) ||
        !(psNewProv->pwszRemoveFuncName))
    {
        goto InvalidParam;
    }

    if (!(_Guid2Sz(psNewProv->pgSubject, &szGuid[0])))
    {
        goto GuidConvertFailed;
    }

    if (!(_RegisterSIPFunc(SIPFUNC_PUTSIGNATURE, &szGuid[0], 
                           psNewProv->pwszDLLFileName, psNewProv->pwszPutFuncName)))
    {
        goto RegisterPutFailed;
    }

    if (!(_RegisterSIPFunc(SIPFUNC_GETSIGNATURE, &szGuid[0],
                           psNewProv->pwszDLLFileName, psNewProv->pwszGetFuncName)))
    {
        goto RegisterGetFailed;
    }

    if (!(_RegisterSIPFunc(SIPFUNC_REMSIGNATURE, &szGuid[0],
                           psNewProv->pwszDLLFileName, psNewProv->pwszRemoveFuncName)))
    {
        goto RegisterRemoveFailed;
    }

    if (!(_RegisterSIPFunc(SIPFUNC_CREATEINDIRECT, &szGuid[0],
                           psNewProv->pwszDLLFileName, psNewProv->pwszCreateFuncName)))
    {
        goto RegisterCreateFailed;
    }

    if (!(_RegisterSIPFunc(SIPFUNC_VERIFYINDIRECT, &szGuid[0],
                           psNewProv->pwszDLLFileName, psNewProv->pwszVerifyFuncName)))
    {
        goto RegisterVerifyFailed;
    }

    if (psNewProv->pwszIsFunctionName)
    {
        if (!(_RegisterSIPFunc(SIPFUNC_ISMYTYPE, &szGuid[0],
                            psNewProv->pwszDLLFileName, psNewProv->pwszIsFunctionName)))
        {
            goto RegisterIsMyTypeFailed;
        }
    }

    if ((WVT_ISINSTRUCT(SIP_ADD_NEWPROVIDER, psNewProv->cbStruct, pwszIsFunctionNameFmt2)) &&
        (psNewProv->pwszIsFunctionNameFmt2))
    {
        if (!(_RegisterSIPFunc(SIPFUNC_ISMYTYPE2, &szGuid[0],
                            psNewProv->pwszDLLFileName, psNewProv->pwszIsFunctionNameFmt2)))
        {
            goto RegisterIsMyType2Failed;
        }
    }
    

    fRet = TRUE;

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, RegisterPutFailed);
    TRACE_ERROR_EX(DBG_SS, RegisterGetFailed);
    TRACE_ERROR_EX(DBG_SS, RegisterRemoveFailed);
    TRACE_ERROR_EX(DBG_SS, RegisterCreateFailed);
    TRACE_ERROR_EX(DBG_SS, RegisterVerifyFailed);
    TRACE_ERROR_EX(DBG_SS, RegisterIsMyTypeFailed);
    TRACE_ERROR_EX(DBG_SS, RegisterIsMyType2Failed);
    TRACE_ERROR_EX(DBG_SS, GuidConvertFailed);

    SET_ERROR_VAR_EX(DBG_SS, InvalidParam,  ERROR_INVALID_PARAMETER);
}

BOOL WINAPI CryptSIPRemoveProvider(GUID *pgProv)
{
    BOOL    fRet;
    char    szGuid[REG_MAX_GUID_TEXT];

    if (!(pgProv))
    {
        goto InvalidParam;
    }

    if (!(_Guid2Sz(pgProv, &szGuid[0])))
    {
        goto GuidConvertFailed;
    }

    fRet = TRUE;

    fRet &= CryptUnregisterOIDFunction(0, SIPFUNC_PUTSIGNATURE, &szGuid[0]);
    fRet &= CryptUnregisterOIDFunction(0, SIPFUNC_GETSIGNATURE, &szGuid[0]);
    fRet &= CryptUnregisterOIDFunction(0, SIPFUNC_REMSIGNATURE, &szGuid[0]);
    fRet &= CryptUnregisterOIDFunction(0, SIPFUNC_CREATEINDIRECT, &szGuid[0]);
    fRet &= CryptUnregisterOIDFunction(0, SIPFUNC_VERIFYINDIRECT, &szGuid[0]);
    fRet &= CryptUnregisterOIDFunction(0, SIPFUNC_ISMYTYPE, &szGuid[0]);
    fRet &= CryptUnregisterOIDFunction(0, SIPFUNC_ISMYTYPE2, &szGuid[0]);

CommonReturn:
    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    TRACE_ERROR_EX(DBG_SS, GuidConvertFailed);

    SET_ERROR_VAR_EX(DBG_SS, InvalidParam,  ERROR_INVALID_PARAMETER);
}

BOOL _RegisterSIPFunc(char *pszTag, char *pszGuid, WCHAR *pwszDll, WCHAR *pwszFunc)
{
    char    szFunc[REG_MAX_FUNC_NAME];

    WideCharToMultiByte(0, 0, pwszFunc, -1, &szFunc[0], REG_MAX_FUNC_NAME, NULL, NULL);

    return(CryptRegisterOIDFunction(0, pszTag, pszGuid, pwszDll, &szFunc[0]));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\siphelp\sipguid.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       sipguid.cpp
//
//  Contents:   Microsoft Internet Security SIP Provider
//
//  Functions:  CryptSIPRetrieveSubjectGuid
//
//              *** local functions ***
//              _DetermineWhichPE
//              _QueryLoadedIsMyFileType
//              _QueryRegisteredIsMyFileType
//
//  History:    03-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"
#include    "cryptreg.h"
#include    "sipbase.h"
#include    "mssip.h"
#include    "mscat.h"
#include    "sipguids.h"    // located in pki-mssip32

BOOL     _FindGuidFromMagicNumber(BYTE *pszMN, GUID *pgRet);
BOOL    _DetermineWhichPE(BYTE *pbFile, DWORD cbFile, GUID *pgRet);

static inline DWORD FourBToDWORD(BYTE rgb[])
{
    return  ((DWORD)rgb[0]<<24) |
            ((DWORD)rgb[1]<<16) |
            ((DWORD)rgb[2]<<8)  |
            ((DWORD)rgb[3]<<0);
}

static inline void DWORDToFourB(DWORD dwIn, BYTE *pszOut)
{
    pszOut[0] = (BYTE)((dwIn >> 24) & 0x000000FF);
    pszOut[1] = (BYTE)((dwIn >> 16) & 0x000000FF);
    pszOut[2] = (BYTE)((dwIn >>  8) & 0x000000FF);
    pszOut[3] = (BYTE)( dwIn        & 0x000000FF);
}


#define PE_EXE_HEADER_TAG       "MZ"
#define CAB_MAGIC_NUMBER        "MSCF"

BOOL WINAPI CryptSIPRetrieveSubjectGuid(IN LPCWSTR FileName, IN OPTIONAL HANDLE hFileIn, OUT GUID *pgSubject)
{
    BYTE    *pbFile;
    DWORD   cbFile;
    DWORD   dwCheck;
    HANDLE  hMappedFile;
    BOOL    bCloseFile;
    BOOL    fRet;
	DWORD			dwException=0;
    PCCTL_CONTEXT   pCTLContext=NULL;

    bCloseFile  = FALSE;
    pbFile      = NULL;
    fRet        = TRUE;

    if (!(pgSubject))
    {
        goto InvalidParameter;
    }

    memset(pgSubject, 0x00, sizeof(GUID));

    if ((hFileIn == NULL) || (hFileIn == INVALID_HANDLE_VALUE))
    {
        if (!(FileName))
        {
            goto InvalidParameter;
        }

        if ((hFileIn = CreateFileU(FileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                                   OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                                   NULL)) == INVALID_HANDLE_VALUE)
        {
            goto FileOpenError;
        }

        bCloseFile = TRUE;
    }

    hMappedFile = CreateFileMapping(hFileIn, NULL, PAGE_READONLY, 0, 0, NULL);

    if (!(hMappedFile) || (hMappedFile == INVALID_HANDLE_VALUE))
    {
        goto FileMapError;
    }

    pbFile = (BYTE *)MapViewOfFile(hMappedFile, FILE_MAP_READ, 0, 0, 0);

    CloseHandle(hMappedFile);

    cbFile = GetFileSize(hFileIn, NULL);


    if (cbFile < SIP_MAX_MAGIC_NUMBER)
    {
        goto FileSizeError;
    }

    //we need to check for the pbFile
    if(NULL == pbFile)
        goto FileMapError;

	//we need to handle the exception when we access the mapped file
	__try {

    //
    //  PE
    //
    if (memcmp(&pbFile[0], PE_EXE_HEADER_TAG, strlen(PE_EXE_HEADER_TAG)) == 0)
    {
        //
        //  if it is an Exe, Dll, Ocx, etc. make sure it is a 32 bit PE and set the
        //  "internal" magic number.
        //
        if (_DetermineWhichPE(pbFile, cbFile, pgSubject))
        {
            goto CommonReturn;
        }
    }

    //
    //  CAB
    //
    if (memcmp(&pbFile[0], CAB_MAGIC_NUMBER, strlen(CAB_MAGIC_NUMBER)) == 0)
    {
        GUID    gCAB    = CRYPT_SUBJTYPE_CABINET_IMAGE;

        memcpy(pgSubject, &gCAB, sizeof(GUID));

        goto CommonReturn;
    }

    //
    //  JAVA Class
    //
    dwCheck = FourBToDWORD(&pbFile[0]);

    if (dwCheck == 0xCAFEBABE)
    {
        GUID    gJClass = CRYPT_SUBJTYPE_JAVACLASS_IMAGE;

        memcpy(pgSubject, &gJClass, sizeof(GUID));

        goto CommonReturn;
    }


    //
    //  Catalog/CTL
    //
    if (pbFile[0] == 0x30)   // could be a PKCS#7!
    {
        //
        //  we could be a PKCS7....  check for CTL
        //

        pCTLContext = (PCCTL_CONTEXT) CertCreateContext(
            CERT_STORE_CTL_CONTEXT,
            PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
            pbFile,
            cbFile,
            CERT_CREATE_CONTEXT_NOCOPY_FLAG |
                CERT_CREATE_CONTEXT_NO_HCRYPTMSG_FLAG |
                CERT_CREATE_CONTEXT_NO_ENTRY_FLAG,
            NULL                                        // pCreatePara
            );

        if (pCTLContext)
        {
            if (pCTLContext->pCtlInfo->SubjectUsage.cUsageIdentifier)
            {
                char *pszCatalogListUsageOID = szOID_CATALOG_LIST;

                if (strcmp(pCTLContext->pCtlInfo->SubjectUsage.rgpszUsageIdentifier[0],
                            pszCatalogListUsageOID) == 0)
                {
                    GUID    gCat = CRYPT_SUBJTYPE_CATALOG_IMAGE;

                    memcpy(pgSubject, &gCat, sizeof(GUID));

                    CertFreeCTLContext(pCTLContext);
					pCTLContext=NULL;

                    goto CommonReturn;
                }
            }

            //
            //  otherwise, it is a CTL of some other type...
            //
            GUID    gCTL = CRYPT_SUBJTYPE_CTL_IMAGE;

            memcpy(pgSubject, &gCTL, sizeof(GUID));

            CertFreeCTLContext(pCTLContext);
            pCTLContext=NULL;

            goto CommonReturn;
        }
    }


    //we need to unmap the file
    if(pbFile)
    {
        UnmapViewOfFile(pbFile);
        pbFile=NULL;
    }
	
	//
    //  none that we know about...  Check the providers...
    //
    if (_QueryRegisteredIsMyFileType(hFileIn, FileName, pgSubject))
    {
        goto CommonReturn;
    }

	} __except(EXCEPTION_EXECUTE_HANDLER) {
			dwException = GetExceptionCode();
            goto ExceptionError;
	}

    //
    //  cant find any provider to support this file type...
    //
    goto NoSIPProviderFound;

CommonReturn:

	//we need to handle the exception when we access the mapped file
    if (pbFile)
    {
        UnmapViewOfFile(pbFile);
    }

	if(pCTLContext)
	{
        CertFreeCTLContext(pCTLContext);
	}

    if ((hFileIn) && (hFileIn != INVALID_HANDLE_VALUE))
    {
        if (bCloseFile)
        {
            CloseHandle(hFileIn);
        }
    }

    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    SET_ERROR_VAR_EX(DBG_SS, InvalidParameter,      ERROR_INVALID_PARAMETER);
    SET_ERROR_VAR_EX(DBG_SS, NoSIPProviderFound,    TRUST_E_SUBJECT_FORM_UNKNOWN);

    SET_ERROR_VAR_EX(DBG_SS, FileOpenError,         GetLastError());
    SET_ERROR_VAR_EX(DBG_SS, FileMapError,          GetLastError());
    SET_ERROR_VAR_EX(DBG_SS, FileSizeError,         ERROR_INVALID_PARAMETER);
	SET_ERROR_VAR_EX(DBG_SS, ExceptionError,		dwException);
}

BOOL _DetermineWhichPE(BYTE *pbFile, DWORD cbFile, GUID *pgRet)
{
    IMAGE_DOS_HEADER    *pDosHead;

    pDosHead        = (IMAGE_DOS_HEADER *)pbFile;

    if (pDosHead->e_magic == IMAGE_DOS_SIGNATURE)
    {
        if (cbFile >= sizeof(IMAGE_DOS_HEADER))
        {
            if (cbFile >= (sizeof(IMAGE_DOS_HEADER) + pDosHead->e_lfanew))
            {
                IMAGE_NT_HEADERS    *pNTHead;

                pNTHead = (IMAGE_NT_HEADERS *)((ULONG_PTR)pDosHead + pDosHead->e_lfanew);

                if (pNTHead->Signature == IMAGE_NT_SIGNATURE)
                {
                    GUID    gPE     = CRYPT_SUBJTYPE_PE_IMAGE;

                    memcpy(pgRet, &gPE, sizeof(GUID));

                    return(TRUE);
                }
            }
        }
    }

    return(FALSE);
}


BOOL WINAPI CryptSIPRetrieveSubjectGuidForCatalogFile(IN LPCWSTR FileName, IN OPTIONAL HANDLE hFileIn, OUT GUID *pgSubject)
{
    BYTE    *pbFile;
    DWORD   cbFile;
    HANDLE  hMappedFile;
    BOOL    bCloseFile;
    BOOL    fRet;
	DWORD   dwException = 0;
    GUID    gFlat       = CRYPT_SUBJTYPE_FLAT_IMAGE;
    
    bCloseFile  = FALSE;
    pbFile      = NULL;
    fRet        = TRUE;

    if (!(pgSubject))
    {
        goto InvalidParameter;
    }

    memset(pgSubject, 0x00, sizeof(GUID));

    if ((hFileIn == NULL) || (hFileIn == INVALID_HANDLE_VALUE))
    {
        if (!(FileName))
        {
            goto InvalidParameter;
        }

        if ((hFileIn = CreateFileU(FileName, GENERIC_READ, FILE_SHARE_READ, NULL,
                                   OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                                   NULL)) == INVALID_HANDLE_VALUE)
        {
            goto FileOpenError;
        }

        bCloseFile = TRUE;
    }

    hMappedFile = CreateFileMapping(hFileIn, NULL, PAGE_READONLY, 0, 0, NULL);

    if (!(hMappedFile) || (hMappedFile == INVALID_HANDLE_VALUE))
    {
        goto FileMapError;
    }

    pbFile = (BYTE *)MapViewOfFile(hMappedFile, FILE_MAP_READ, 0, 0, 0);

    CloseHandle(hMappedFile);

    cbFile = GetFileSize(hFileIn, NULL);


    if (cbFile < SIP_MAX_MAGIC_NUMBER)
    {
        goto FlatFile;
    }

    //we need to check for the pbFile
    if(NULL == pbFile)
        goto FileMapError;

	//we need to handle the exception when we access the mapped file
	__try {

    //
    //  PE
    //
    if (memcmp(&pbFile[0], PE_EXE_HEADER_TAG, strlen(PE_EXE_HEADER_TAG)) == 0)
    {
        //
        //  if it is an Exe, Dll, Ocx, etc. make sure it is a 32 bit PE and set the
        //  "internal" magic number.
        //
        if (_DetermineWhichPE(pbFile, cbFile, pgSubject))
        {
            goto CommonReturn;
        }
    }

    //
    //  CAB
    //
    if (memcmp(&pbFile[0], CAB_MAGIC_NUMBER, strlen(CAB_MAGIC_NUMBER)) == 0)
    {
        GUID    gCAB    = CRYPT_SUBJTYPE_CABINET_IMAGE;

        memcpy(pgSubject, &gCAB, sizeof(GUID));

        goto CommonReturn;
    }

    } __except(EXCEPTION_EXECUTE_HANDLER) {
			dwException = GetExceptionCode();
            goto ExceptionError;
	}

    //
    //  Not PE, so go for flat
    //
FlatFile:

    memcpy(pgSubject, &gFlat, sizeof(GUID));

CommonReturn:

	__try {
    if (pbFile)
    {
        UnmapViewOfFile(pbFile);
    }
    } __except(EXCEPTION_EXECUTE_HANDLER) {			
        // can't really do anything            
	}

	if ((hFileIn) && (hFileIn != INVALID_HANDLE_VALUE))
    {
        if (bCloseFile)
        {
            CloseHandle(hFileIn);
        }
    }

    return(fRet);

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

    SET_ERROR_VAR_EX(DBG_SS, InvalidParameter,      ERROR_INVALID_PARAMETER);

    SET_ERROR_VAR_EX(DBG_SS, FileOpenError,         GetLastError());
    SET_ERROR_VAR_EX(DBG_SS, FileMapError,          GetLastError());
	SET_ERROR_VAR_EX(DBG_SS, ExceptionError,		dwException);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\siphelp\sipload.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       sipload.cpp
//
//  Contents:   Microsoft Internet Security SIP Provider
//
//  Functions:  CryptLoadSip
//              CryptUnloadSips
//
//  History:    04-Jun-1997 pberkman   created
//
//--------------------------------------------------------------------------

#include    "global.hxx"

// backwords compatibility w/tools!
extern "C"
BOOL WINAPI CryptLoadSip(const GUID *pgSubject, DWORD dwFlags, SIP_DISPATCH_INFO *psSipTable)
{
    return(CryptSIPLoad(pgSubject, dwFlags, psSipTable));
}

BOOL WINAPI CryptSIPLoad(const GUID *pgSubject, DWORD dwFlags, SIP_DISPATCH_INFO *psSipTable)
{
    if (!(pgSubject) ||
        (dwFlags != 0) ||
        !(psSipTable))
    {
        SetLastError((DWORD) ERROR_INVALID_PARAMETER);
        return(FALSE);
    }


    HCRYPTOIDFUNCADDR           hPfn;
    pCryptSIPPutSignedDataMsg   pfn;
    char                        szGuid[REG_MAX_GUID_TEXT];

    if (!(_Guid2Sz((GUID *)pgSubject, &szGuid[0])))
    {
        SetLastError((DWORD) TRUST_E_SUBJECT_FORM_UNKNOWN);
        return(FALSE);
    }

    if (!(CryptGetOIDFunctionAddress(hPutFuncSet, 0, &szGuid[0], 0, (void **)&pfn, &hPfn)))
    {
        SetLastError((DWORD) TRUST_E_SUBJECT_FORM_UNKNOWN);
        return(FALSE);
    }

    CryptFreeOIDFunctionAddress(hPfn, 0);

    psSipTable->hSIP                = NULL;
    psSipTable->pfGet               = CryptSIPGetSignedDataMsg;
    psSipTable->pfPut               = CryptSIPPutSignedDataMsg;
    psSipTable->pfCreate            = CryptSIPCreateIndirectData;
    psSipTable->pfVerify            = CryptSIPVerifyIndirectData;
    psSipTable->pfRemove            = CryptSIPRemoveSignedDataMsg;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\setx509\setx509.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:	    setx509.cpp
//
//  Contents:   SET Certificate Extension Encode/Decode Functions
//
//              ASN.1 implementation uses the OSS compiler.
//
//  Functions:  DllRegisterServer
//              DllUnregisterServer
//              DllMain
//              SetAsn1AccountAliasEncode
//              SetAsn1AccountAliasDecode
//              SetAsn1HashedRootKeyEncode
//              SetAsn1HashedRootKeyDecode
//              SetAsn1CertificateTypeEncode
//              SetAsn1CertificateTypeDecode
//              SetAsn1MerchantDataEncode
//              SetAsn1MerchantDataDecode
//
//              CertDllVerifyRevocation
//
//  History:	21-Nov-96	philh   created
//
//--------------------------------------------------------------------------


#include "global.hxx"
#include <dbgdef.h>

// All the *pvInfo extra stuff needs to be aligned
#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

static HCRYPTASN1MODULE hAsn1Module;

// The following is for test purposes
#define TLS_TEST_COUNT 20
static HCRYPTTLS hTlsTest[TLS_TEST_COUNT];

static HMODULE hMyModule;

// Set to 1 via InterlockedExchange when installed. Only install the
// first time when changed from 0 to 1.
static LONG lInstallDecodeFunctions = 0;

static LONG lInstallRevFunctions = 0;

//+-------------------------------------------------------------------------
//  Function:  GetEncoder/GetDecoder
//
//  Synopsis:  Initialize thread local storage for the asn libs
//
//  Returns:   pointer to an initialized Asn1 encoder/decoder data
//             structures
//--------------------------------------------------------------------------
static ASN1encoding_t GetEncoder(void)
{
    // The following is for test purposes only
    for (DWORD i = 0; i < TLS_TEST_COUNT; i++) {
        DWORD_PTR dw = (DWORD_PTR) I_CryptGetTls(hTlsTest[i]);
        if (dw == 0)
            dw = i;
        else
            dw++;
        I_CryptSetTls(hTlsTest[i], (void *) dw);
    }

    return I_CryptGetAsn1Encoder(hAsn1Module);
}
static ASN1decoding_t GetDecoder(void)
{
    // The following is for test purposes only
    for (DWORD i = 0; i < TLS_TEST_COUNT; i++) {
        DWORD_PTR dw = (DWORD_PTR) I_CryptGetTls(hTlsTest[i]);
        if (dw == 0)
            dw = i;
        else
            dw++;
        I_CryptSetTls(hTlsTest[i], (void *) dw);
    }

    return I_CryptGetAsn1Decoder(hAsn1Module);
}


//+-------------------------------------------------------------------------
//  SetX509 allocation and free functions
//--------------------------------------------------------------------------
static void *SetX509Alloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError((DWORD) E_OUTOFMEMORY);
    return pv;
}
static void SetX509Free(
    IN void *pv
    )
{
    free(pv);
}

static HRESULT HError()
{
    DWORD dw = GetLastError();

    HRESULT hr;
    if ( dw <= 0xFFFF )
        hr = HRESULT_FROM_WIN32 ( dw );
    else
        hr = dw;

    if ( ! FAILED ( hr ) )
    {
        // somebody failed a call without properly setting an error condition

        hr = E_UNEXPECTED;
    }
    return hr;
}

//+-------------------------------------------------------------------------
//  OSS X509 v3 SET Private Extension ASN.1 Encode / Decode functions
//--------------------------------------------------------------------------
BOOL
WINAPI
SetAsn1AccountAliasEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BOOL *pbInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL
WINAPI
SetAsn1AccountAliasDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT BOOL *pbInfo,
        IN OUT DWORD *pcbInfo
        );
BOOL
WINAPI
SetAsn1HashedRootKeyEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BYTE rgbInfo[SET_HASHED_ROOT_LEN],
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL
WINAPI
SetAsn1HashedRootKeyDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT BYTE rgbInfo[SET_HASHED_ROOT_LEN],
        IN OUT DWORD *pcbInfo
        );
BOOL
WINAPI
SetAsn1CertificateTypeEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_BIT_BLOB pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL
WINAPI
SetAsn1CertificateTypeDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT DWORD *pcbInfo
        );
BOOL
WINAPI
SetAsn1MerchantDataEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSET_MERCHANT_DATA_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        );
BOOL
WINAPI
SetAsn1MerchantDataDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSET_MERCHANT_DATA_INFO pInfo,
        IN OUT DWORD *pcbInfo
        );

typedef struct _OID_REG_ENTRY {
    LPCSTR   pszOID;
    LPCSTR   pszOverrideFuncName;
} OID_REG_ENTRY, *POID_REG_ENTRY;

static const OID_REG_ENTRY RegEncodeBeforeTable[] = {
    szOID_SET_ACCOUNT_ALIAS, "SetAsn1AccountAliasEncode",
    szOID_SET_HASHED_ROOT_KEY, "SetAsn1HashedRootKeyEncode",

    X509_SET_ACCOUNT_ALIAS, "SetAsn1AccountAliasEncode",
    X509_SET_HASHED_ROOT_KEY, "SetAsn1HashedRootKeyEncode",
};
#define REG_ENCODE_BEFORE_COUNT (sizeof(RegEncodeBeforeTable) / sizeof(RegEncodeBeforeTable[0]))

static const OID_REG_ENTRY RegEncodeAfterTable[] = {
    szOID_SET_CERTIFICATE_TYPE, "SetAsn1CertificateTypeEncode",
    szOID_SET_MERCHANT_DATA, "SetAsn1MerchantDataEncode",

    X509_SET_CERTIFICATE_TYPE, "SetAsn1CertificateTypeEncode",
    X509_SET_MERCHANT_DATA, "SetAsn1MerchantDataEncode"
};
#define REG_ENCODE_AFTER_COUNT (sizeof(RegEncodeAfterTable) / sizeof(RegEncodeAfterTable[0]))

static const OID_REG_ENTRY RegDecodeTable[] = {
    szOID_SET_ACCOUNT_ALIAS, "SetAsn1AccountAliasDecode",
    szOID_SET_HASHED_ROOT_KEY, "SetAsn1HashedRootKeyDecode",
    szOID_SET_CERTIFICATE_TYPE, "SetAsn1CertificateTypeDecode",
    szOID_SET_MERCHANT_DATA, "SetAsn1MerchantDataDecode",

    X509_SET_ACCOUNT_ALIAS, "SetAsn1AccountAliasDecode",
    X509_SET_HASHED_ROOT_KEY, "SetAsn1HashedRootKeyDecode",
    X509_SET_CERTIFICATE_TYPE, "SetAsn1CertificateTypeDecode",
    X509_SET_MERCHANT_DATA, "SetAsn1MerchantDataDecode"
};
#define REG_DECODE_COUNT (sizeof(RegDecodeTable) / sizeof(RegDecodeTable[0]))

#define OID_INFO_LEN sizeof(CRYPT_OID_INFO)

// Ordered lists of acceptable RDN attribute value types. 0 terminates.
static const DWORD rgdwPrintableValueType[] = { CERT_RDN_PRINTABLE_STRING, 0 };
static const DWORD rgdwIA5ValueType[] = { CERT_RDN_IA5_STRING, 0 };
static const DWORD rgdwNumericValueType[] = { CERT_RDN_NUMERIC_STRING, 0 };

#define RDN_ATTR_ENTRY(pszOID, pwszName, rgdwValueType) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_RDN_ATTR_OID_GROUP_ID, 64, \
    sizeof(rgdwValueType), (BYTE *) rgdwValueType
#define DEFAULT_RDN_ATTR_ENTRY(pszOID, pwszName) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_RDN_ATTR_OID_GROUP_ID, 128, 0, NULL

#define EXT_ATTR_ENTRY(pszOID, pwszName) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_EXT_OR_ATTR_OID_GROUP_ID, 0, 0, NULL

#define PUBKEY_ALG_ENTRY(pszOID, pwszName, Algid) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_PUBKEY_ALG_OID_GROUP_ID, \
    Algid, 0, NULL
#define PUBKEY_EXTRA_ALG_ENTRY(pszOID, pwszName, Algid, dwFlags) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_PUBKEY_ALG_OID_GROUP_ID, \
    Algid, sizeof(dwFlags), (BYTE *) &dwFlags

static const DWORD dwDSSTestFlags = CRYPT_OID_USE_PUBKEY_PARA_FOR_PKCS7_FLAG;


static const DWORD rgdwTestRsaSign[] = {
    CALG_RSA_SIGN,
    0,
    PROV_RSA_FULL
};

#define TEST_SIGN_EXTRA_ALG_ENTRY(pszOID, pwszName, aiHash, rgdwExtra) \
    OID_INFO_LEN, pszOID, pwszName, CRYPT_SIGN_ALG_OID_GROUP_ID, aiHash, \
    sizeof(rgdwExtra), (BYTE *) rgdwExtra

#define TEST_RSA_SIGN_ALG_ENTRY(pszOID, pwszName, aiHash) \
    TEST_SIGN_EXTRA_ALG_ENTRY(pszOID, pwszName, aiHash, rgdwTestRsaSign)


static CCRYPT_OID_INFO OIDInfoAfterTable[] = {
    DEFAULT_RDN_ATTR_ENTRY("1.2.1", L"TestRDNAttr #1"),
    RDN_ATTR_ENTRY("1.2.2", L"TestRDNAttr #2", rgdwPrintableValueType),
    EXT_ATTR_ENTRY(szOID_SET_CERTIFICATE_TYPE, L"SETCertificateType"),
    EXT_ATTR_ENTRY(szOID_SET_HASHED_ROOT_KEY, L"SETHashedRootKey"),
};
#define OID_INFO_AFTER_CNT (sizeof(OIDInfoAfterTable) / \
                                        sizeof(OIDInfoAfterTable[0]))

static CCRYPT_OID_INFO OIDInfoBeforeTable[] = {
//    PUBKEY_EXTRA_ALG_ENTRY(szOID_OIWSEC_dsa, L"SETDSSTest", CALG_DSS_SIGN,
//        dwDSSTestFlags),
//    TEST_RSA_SIGN_ALG_ENTRY(szOID_RSA_SHA1RSA, L"sha1RSA", CALG_SHA1),
//    TEST_RSA_SIGN_ALG_ENTRY(szOID_RSA_MD5RSA, L"md5RSA", CALG_MD5),
    EXT_ATTR_ENTRY(szOID_SET_ACCOUNT_ALIAS, L"SETAccountAlias"),
    EXT_ATTR_ENTRY(szOID_SET_MERCHANT_DATA, L"SETMerchantData"),
};
#define OID_INFO_BEFORE_CNT (sizeof(OIDInfoBeforeTable) / \
                                        sizeof(OIDInfoBeforeTable[0]))

//+-------------------------------------------------------------------------
//  Localized Name Table
//--------------------------------------------------------------------------
typedef struct _LOCALIZED_NAME_INFO {
    LPCWSTR         pwszCryptName;
    LPCWSTR         pwszLocalizedName;
} LOCALIZED_NAME_INFO, *PLOCALIZED_NAME_INFO;


static LOCALIZED_NAME_INFO LocalizedNameTable[] = {
    L"Test",        L"*** Test ***",
    L"TestTrust",   L"### TestTrust ###",
};
#define LOCALIZED_NAME_CNT  (sizeof(LocalizedNameTable) / \
                                    sizeof(LocalizedNameTable[0]))

BOOL
WINAPI
CertDllVerifyRevocation(
    IN DWORD dwEncodingType,
    IN DWORD dwRevType,
    IN DWORD cContext,
    IN PVOID rgpvContext[],
    IN DWORD dwRevFlags,
    IN PVOID pvReserved,
    IN OUT PCERT_REVOCATION_STATUS pRevStatus
    );


STDAPI DllRegisterServer(void)
{
    int i;

    for (i = 0; i < REG_ENCODE_BEFORE_COUNT; i++) {
        DWORD dwFlags = CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG;
        if (!CryptRegisterOIDFunction(
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                RegEncodeBeforeTable[i].pszOID,
                L"setx509.dll",
                RegEncodeBeforeTable[i].pszOverrideFuncName
                ))
            return HError();
        if (!CryptSetOIDFunctionValue(
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                RegEncodeBeforeTable[i].pszOID,
                CRYPT_OID_REG_FLAGS_VALUE_NAME,
                REG_DWORD,
                (BYTE *) &dwFlags,
                sizeof(dwFlags)
                ))
            return HError();
    }
    for (i = 0; i < REG_ENCODE_AFTER_COUNT; i++)
        if (!CryptRegisterOIDFunction(
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                RegEncodeAfterTable[i].pszOID,
                L"setx509.dll",
                RegEncodeAfterTable[i].pszOverrideFuncName
                ))
            return HError();

    for (i = 0; i < REG_DECODE_COUNT; i++)
        if (!CryptRegisterOIDFunction(
                X509_ASN_ENCODING,
                CRYPT_OID_DECODE_OBJECT_FUNC,
                RegDecodeTable[i].pszOID,
                L"setx509.dll",
                RegDecodeTable[i].pszOverrideFuncName
                ))
            return HError();

    if (!CryptRegisterDefaultOIDFunction(
            X509_ASN_ENCODING,
            CRYPT_OID_VERIFY_REVOCATION_FUNC,
            CRYPT_REGISTER_LAST_INDEX,
            L"setx509.dll"
            )) {
        if (ERROR_FILE_EXISTS != GetLastError())
            return HError();
    }

    for (i = 0; i < OID_INFO_BEFORE_CNT; i++)
        if (!CryptRegisterOIDInfo(
                &OIDInfoBeforeTable[i],
                CRYPT_INSTALL_OID_INFO_BEFORE_FLAG
                ))
            return HError();
    for (i = 0; i < OID_INFO_AFTER_CNT; i++)
        if (!CryptRegisterOIDInfo(
                &OIDInfoAfterTable[i],
                0                           // dwFlags
                ))
            return HError();

    for (i = 0; i < LOCALIZED_NAME_CNT; i++)
        if (!CryptSetOIDFunctionValue(
                CRYPT_LOCALIZED_NAME_ENCODING_TYPE,
                CRYPT_OID_FIND_LOCALIZED_NAME_FUNC,
                CRYPT_LOCALIZED_NAME_OID,
                LocalizedNameTable[i].pwszCryptName,
                REG_SZ,
                (const BYTE *) LocalizedNameTable[i].pwszLocalizedName,
                (wcslen(LocalizedNameTable[i].pwszLocalizedName) + 1) *
                    sizeof(WCHAR)
                ))
            return HError();
    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr = S_OK;
    int i;

    for (i = 0; i < REG_ENCODE_BEFORE_COUNT; i++) {
        if (!CryptUnregisterOIDFunction(
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                RegEncodeBeforeTable[i].pszOID
                )) {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
                hr = HError();
        }
    }

    for (i = 0; i < REG_ENCODE_AFTER_COUNT; i++) {
        if (!CryptUnregisterOIDFunction(
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                RegEncodeAfterTable[i].pszOID
                )) {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
                hr = HError();
        }
    }

    for (i = 0; i < REG_DECODE_COUNT; i++) {
        if (!CryptUnregisterOIDFunction(
                X509_ASN_ENCODING,
                CRYPT_OID_DECODE_OBJECT_FUNC,
                RegDecodeTable[i].pszOID
                )) {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
                hr = HError();
        }
    }

    if (!CryptUnregisterDefaultOIDFunction(
            X509_ASN_ENCODING,
            CRYPT_OID_VERIFY_REVOCATION_FUNC,
            L"setx509.dll"
            )) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            hr = HError();
    }

    for (i = 0; i < OID_INFO_BEFORE_CNT; i++) {
        if (!CryptUnregisterOIDInfo(
                &OIDInfoBeforeTable[i]
                )) {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
                hr = HError();
        }
    }
    for (i = 0; i < OID_INFO_AFTER_CNT; i++) {
        if (!CryptUnregisterOIDInfo(
                &OIDInfoAfterTable[i]
                )) {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
                hr = HError();
        }
    }

    for (i = 0; i < LOCALIZED_NAME_CNT; i++)
        if (!CryptSetOIDFunctionValue(
                CRYPT_LOCALIZED_NAME_ENCODING_TYPE,
                CRYPT_OID_FIND_LOCALIZED_NAME_FUNC,
                CRYPT_LOCALIZED_NAME_OID,
                LocalizedNameTable[i].pwszCryptName,
                REG_SZ,
                NULL,
                0
                ))
            return HError();

    return hr;
}

static const CRYPT_OID_FUNC_ENTRY SetEncodeFuncTable[] = {
    szOID_SET_ACCOUNT_ALIAS, SetAsn1AccountAliasEncode,
    szOID_SET_HASHED_ROOT_KEY, SetAsn1HashedRootKeyEncode,
    szOID_SET_CERTIFICATE_TYPE, SetAsn1CertificateTypeEncode,
    szOID_SET_MERCHANT_DATA, SetAsn1MerchantDataEncode,

    X509_SET_ACCOUNT_ALIAS, SetAsn1AccountAliasEncode,
    X509_SET_HASHED_ROOT_KEY, SetAsn1HashedRootKeyEncode,
    X509_SET_CERTIFICATE_TYPE, SetAsn1CertificateTypeEncode,
    X509_SET_MERCHANT_DATA, SetAsn1MerchantDataEncode,
};

#define SET_ENCODE_FUNC_COUNT (sizeof(SetEncodeFuncTable) / \
                                    sizeof(SetEncodeFuncTable[0]))

static const CRYPT_OID_FUNC_ENTRY SetDecodeFuncTable[] = {
    szOID_SET_ACCOUNT_ALIAS, SetAsn1AccountAliasDecode,
    szOID_SET_HASHED_ROOT_KEY, SetAsn1HashedRootKeyDecode,
    szOID_SET_CERTIFICATE_TYPE, SetAsn1CertificateTypeDecode,
    szOID_SET_MERCHANT_DATA, SetAsn1MerchantDataDecode,

    X509_SET_ACCOUNT_ALIAS, SetAsn1AccountAliasDecode,
    X509_SET_HASHED_ROOT_KEY, SetAsn1HashedRootKeyDecode,
    X509_SET_CERTIFICATE_TYPE, SetAsn1CertificateTypeDecode,
    X509_SET_MERCHANT_DATA, SetAsn1MerchantDataDecode
};

#define SET_DECODE_FUNC_COUNT (sizeof(SetDecodeFuncTable) / \
                                    sizeof(SetDecodeFuncTable[0]))

static const CRYPT_OID_FUNC_ENTRY SetRevFuncTable[] = {
    CRYPT_DEFAULT_OID, CertDllVerifyRevocation
};

#define SET_REV_FUNC_COUNT (sizeof(SetRevFuncTable) / \
                                    sizeof(SetRevFuncTable[0]))

//+-------------------------------------------------------------------------
//  Dll initialization
//--------------------------------------------------------------------------
BOOL
WINAPI
DllMain(
        HMODULE hModule,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL    fRet;
    DWORD   i;
    DWORD_PTR dwTlsValue;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        //  The following is for test purposes only
        for (i = 0; i < TLS_TEST_COUNT; i++) {
            if (NULL == (hTlsTest[i] = I_CryptAllocTls()))
                goto CryptAllocTlsError;
        }

#ifdef OSS_CRYPT_ASN1
        if (0 == (hAsn1Module = I_CryptInstallAsn1Module(ossx509, 0, NULL)))
#else
        X509_Module_Startup();
        if (0 == (hAsn1Module = I_CryptInstallAsn1Module(
                X509_Module, 0, NULL)))
#endif  // OSS_CRYPT_ASN1
            goto CryptInstallAsn1ModuleError;

#if 0
        // For testing purposes not installed. Always want to call the
        // encode functions via dll load.
        if (!CryptInstallOIDFunctionAddress(
                hModule,
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                SET_ENCODE_FUNC_COUNT,
                SetEncodeFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;
#endif

#if 0
        // For testing purposes deferred until first Decode
        if (!CryptInstallOIDFunctionAddress(
                hModule,
                X509_ASN_ENCODING,
                CRYPT_OID_DECODE_OBJECT_FUNC,
                SET_DECODE_FUNC_COUNT,
                SetDecodeFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;
#endif
        hMyModule = hModule;
        break;

    case DLL_PROCESS_DETACH:
        I_CryptUninstallAsn1Module(hAsn1Module);
#ifndef OSS_CRYPT_ASN1
        X509_Module_Cleanup();
#endif  // OSS_CRYPT_ASN1

        //  The following is for test purposes only
        for (i = 0; i < TLS_TEST_COUNT; i++) {
            I_CryptFreeTls(hTlsTest[i], NULL);
        }
        break;

    case DLL_THREAD_DETACH:
        // The following is for test purposes only
        for (i = 0; i < TLS_TEST_COUNT; i++)
            dwTlsValue = (DWORD_PTR) I_CryptDetachTls(hTlsTest[i]);
        break;
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CryptAllocTlsError)
TRACE_ERROR(CryptInstallAsn1ModuleError)
#if 0
TRACE_ERROR(CryptInstallOIDFunctionAddressError)
#endif
}

// Defer installation until the first decode. Called by each of the decode
// functions.
//
// Do the InterlockedExchange to ensure a single installation
static void InstallDecodeFunctions()
{
#if 0
    if (0 == InterlockedExchange(&lInstallDecodeFunctions, 1)) {
        if (!CryptInstallOIDFunctionAddress(
                hMyModule,
                X509_ASN_ENCODING,
                CRYPT_OID_DECODE_OBJECT_FUNC,
                SET_DECODE_FUNC_COUNT,
                SetDecodeFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;
    }

CommonReturn:
    return;
ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(CryptInstallOIDFunctionAddressError)
#endif
}

// Defer installation until the first revocation.
//
// Do the InterlockedExchange to ensure a single installation
static void InstallRevFunctions()
{
    if (0 == InterlockedExchange(&lInstallRevFunctions, 1)) {
        if (!CryptInstallOIDFunctionAddress(
                hMyModule,
                X509_ASN_ENCODING,
                CRYPT_OID_VERIFY_REVOCATION_FUNC,
                SET_REV_FUNC_COUNT,
                SetRevFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError;
    }

CommonReturn:
    return;
ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(CryptInstallOIDFunctionAddressError)
}

BOOL
WINAPI
CertDllVerifyRevocation(
    IN DWORD dwEncodingType,
    IN DWORD dwRevType,
    IN DWORD cContext,
    IN PVOID rgpvContext[],
    IN DWORD dwRevFlags,
    IN PVOID pvReserved,
    IN OUT PCERT_REVOCATION_STATUS pRevStatus
    )
{
    BOOL fResult = FALSE;
    DWORD dwIndex = 0;
    DWORD dwError = 0;
    HCERTSTORE hStore = NULL;
    HCERTSTORE hLinkStore = NULL;

    InstallRevFunctions();

    if (GET_CERT_ENCODING_TYPE(dwEncodingType) != CRYPT_ASN_ENCODING)
        goto NoRevocationCheckForEncodingTypeError;
    if (dwRevType != CERT_CONTEXT_REVOCATION_TYPE)
        goto NoRevocationCheckForRevTypeError;

    hStore = CertOpenSystemStore(NULL, "Test");
    if (NULL == hStore)
        goto OpenTestStoreError;

    hLinkStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            0,                      // dwEncodingType
            0,                      // hCryptProv
            0,                      // dwFlags
            NULL                    // pvPara
            );
    if (NULL == hLinkStore)
        goto OpenLinkStoreError;

    for (dwIndex = 0; dwIndex < cContext; dwIndex++) {
        PCCERT_CONTEXT pCert = (PCCERT_CONTEXT) rgpvContext[dwIndex];
        PCERT_EXTENSION pExt;
        PCCERT_CONTEXT pIssuer;
        DWORD dwFlags;
        // Check that the certificate has a SET extension
        if (NULL == (pExt = CertFindExtension(szOID_SET_CERTIFICATE_TYPE,
                            pCert->pCertInfo->cExtension,
                            pCert->pCertInfo->rgExtension)))
            goto NoSETX509ExtensionError;

        // Attempt to get the certificate's issuer from the test store.
        // If found check signature and revocation.

        // For testing purposes: first found issuer.
        dwFlags = CERT_STORE_REVOCATION_FLAG | CERT_STORE_SIGNATURE_FLAG;
        if (NULL == (pIssuer = CertGetIssuerCertificateFromStore(
                hStore,
                pCert,
                NULL,   // pPrevIssuerContext,
                &dwFlags)))
            goto NoIssuerError;
        else {
            BOOL fLinkResult;
            DWORD dwLinkFlags =
                CERT_STORE_REVOCATION_FLAG | CERT_STORE_SIGNATURE_FLAG;
            PCCERT_CONTEXT pLinkIssuer = NULL;

            // Check that we get the same results if we put a link to the
            // issuer in a store and try to verify using the link.
            fLinkResult = CertAddCertificateLinkToStore(
                hLinkStore,
                pIssuer,
                CERT_STORE_ADD_ALWAYS,
                &pLinkIssuer
                );
            CertFreeCertificateContext(pIssuer);
            if (!fLinkResult)
                goto AddCertificateLinkError;

            if (!CertVerifySubjectCertificateContext(
                    pCert,
                    pLinkIssuer,
                    &dwLinkFlags
                    ))
                goto VerifySubjectCertificateContextError;

            if (dwLinkFlags != dwFlags)
                goto BadLinkVerifyResults;

            if (dwFlags & CERT_STORE_SIGNATURE_FLAG)
                goto BadCertificateSignatureError;
            if (dwFlags & CERT_STORE_NO_CRL_FLAG)
                goto NoCRLError;
            if (dwFlags & CERT_STORE_REVOCATION_FLAG) {
                pRevStatus->dwReason = CRL_REASON_KEY_COMPROMISE;
                goto CertificateRevocationError;
            }
            // else
            //  A checked certificate that hasn't been revoked.
            assert(dwFlags == 0);
        }
    }

    fResult = TRUE;
    dwIndex = 0;

CommonReturn:
    if (hStore)
        CertCloseStore(hStore, 0);
    if (hLinkStore)
        CertCloseStore(hLinkStore, CERT_CLOSE_STORE_FORCE_FLAG);
    pRevStatus->dwIndex = dwIndex;
    pRevStatus->dwError = dwError;
    return fResult;
ErrorReturn:
    dwError = GetLastError();
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenTestStoreError)
TRACE_ERROR(OpenLinkStoreError)
SET_ERROR(NoRevocationCheckForEncodingTypeError, CRYPT_E_NO_REVOCATION_CHECK)
SET_ERROR(NoRevocationCheckForRevTypeError, CRYPT_E_NO_REVOCATION_CHECK)
SET_ERROR(NoSETX509ExtensionError, CRYPT_E_NO_REVOCATION_CHECK)
TRACE_ERROR(NoIssuerError)
SET_ERROR(BadCertificateSignatureError, CRYPT_E_NO_REVOCATION_CHECK)
SET_ERROR(NoCRLError, CRYPT_E_NO_REVOCATION_CHECK)

SET_ERROR(CertificateRevocationError, CRYPT_E_REVOKED)
TRACE_ERROR(AddCertificateLinkError)
TRACE_ERROR(VerifySubjectCertificateContextError)
SET_ERROR(BadLinkVerifyResults, E_UNEXPECTED)
}

//+-------------------------------------------------------------------------
//  OSS X509 v3 ASN.1 Set / Get functions
//
//  Called by the OSS X509 encode/decode functions.
//
//  Assumption: all types are UNBOUNDED.
//
//  The Get functions decrement *plRemainExtra and advance
//  *ppbExtra. When *plRemainExtra becomes negative, the functions continue
//  with the length calculation but stop doing any copies.
//  The functions don't return an error for a negative *plRemainExtra.
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  Set/Get CRYPT_DATA_BLOB (Octet String)
//--------------------------------------------------------------------------
static inline void SetX509SetOctetString(
        IN PCRYPT_DATA_BLOB pInfo,
        OUT OCTETSTRING *pOss
        )
{
    pOss->value = pInfo->pbData;
    pOss->length = pInfo->cbData;
}
static inline void SetX509GetOctetString(
        IN OCTETSTRING *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetOctetString(pOss->length, pOss->value, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Set/Get CRYPT_BIT_BLOB
//--------------------------------------------------------------------------
static inline void SetX509SetBit(
        IN PCRYPT_BIT_BLOB pInfo,
        OUT BITSTRING *pOss
        )
{
    PkiAsn1SetBitString(pInfo, &pOss->length, &pOss->value);
}
static inline void SetX509GetBit(
        IN BITSTRING *pOss,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetBitString(pOss->length, pOss->value, dwFlags,
        pInfo, ppbExtra, plRemainExtra);
}


//+-------------------------------------------------------------------------
//  Set/Get LPSTR (IA5 String)
//--------------------------------------------------------------------------
static inline void SetX509SetIA5(
        IN LPSTR psz,
        OUT IA5STRING *pOss
        )
{
    pOss->value = psz;
    pOss->length = strlen(psz);
}
static inline void SetX509GetIA5(
        IN IA5STRING *pOss,
        IN DWORD dwFlags,
        OUT LPSTR *ppsz,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra
        )
{
    PkiAsn1GetIA5String(pOss->length, pOss->value, dwFlags,
        ppsz, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Encode an OSS formatted info structure
//
//  Called by the SetX509*Encode() functions.
//--------------------------------------------------------------------------
static BOOL SetAsn1Encode(
        IN int pdunum,
        IN void *pOssInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    return PkiAsn1EncodeInfo(
        GetEncoder(),
        pdunum,
        pOssInfo,
        pbEncoded,
        pcbEncoded);
}


//+-------------------------------------------------------------------------
//  Decode into an allocated, OSS formatted info structure
//
//  Called by the SetX509*Decode() functions.
//--------------------------------------------------------------------------
static BOOL SetAsn1DecodeAndAlloc(
        IN int pdunum,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        OUT void **ppOssInfo
        )
{
    // For testing purposes, defer installation of decode functions until
    // first decode which is loaded via being registered.
    InstallDecodeFunctions();

    return PkiAsn1DecodeAndAllocInfo(
        GetDecoder(),
        pdunum,
        pbEncoded,
        cbEncoded,
        ppOssInfo);
}

//+-------------------------------------------------------------------------
//  Free an allocated, OSS formatted info structure
//
//  Called by the SetX509*Decode() functions.
//--------------------------------------------------------------------------
static void SetAsn1Free(
        IN int pdunum,
        IN void *pOssInfo
        )
{
    if (pOssInfo) {
        DWORD dwErr = GetLastError();

        // TlsGetValue globbers LastError
        PkiAsn1FreeInfo(GetDecoder(), pdunum, pOssInfo);

        SetLastError(dwErr);
    }
}

//+-------------------------------------------------------------------------
//  SET Account Alias Private Extension Encode (OSS X509)
//--------------------------------------------------------------------------
BOOL
WINAPI
SetAsn1AccountAliasEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BOOL *pbInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    ossBoolean OssSETAccountAlias = (ossBoolean) *pbInfo;
    return SetAsn1Encode(
        SETAccountAlias_PDU,
        &OssSETAccountAlias,
        pbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  SET Account Alias Private Extension Decode (OSS X509)
//--------------------------------------------------------------------------
BOOL
WINAPI
SetAsn1AccountAliasDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT BOOL *pbInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    ossBoolean *pSETAccountAlias = NULL;

    if ((fResult = SetAsn1DecodeAndAlloc(
            SETAccountAlias_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pSETAccountAlias))) {
        if (*pcbInfo < sizeof(BOOL)) {
            if (pbInfo) {
                fResult = FALSE;
                SetLastError((DWORD) ERROR_MORE_DATA);
            }
        } else
            *pbInfo = (BOOL) *pSETAccountAlias;
        *pcbInfo = sizeof(BOOL);
    } else {
        if (*pcbInfo >= sizeof(BOOL))
            *pbInfo = FALSE;
        *pcbInfo = 0;
    }

    SetAsn1Free(SETAccountAlias_PDU, pSETAccountAlias);

    return fResult;
}

//+-------------------------------------------------------------------------
//  SET Hashed Root Private Extension Encode (OSS X509)
//--------------------------------------------------------------------------
BOOL
WINAPI
SetAsn1HashedRootKeyEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN BYTE rgbInfo[SET_HASHED_ROOT_LEN],
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    OCTETSTRING OssSETHashedRootKey;

    OssSETHashedRootKey.value = rgbInfo;
    OssSETHashedRootKey.length = SET_HASHED_ROOT_LEN;
    return SetAsn1Encode(
        SETHashedRootKey_PDU,
        &OssSETHashedRootKey,
        pbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  SET Hashed Root Private Extension Decode (OSS X509)
//--------------------------------------------------------------------------
BOOL
WINAPI
SetAsn1HashedRootKeyDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT BYTE rgbInfo[SET_HASHED_ROOT_LEN],
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    OCTETSTRING *pSETHashedRootKey = NULL;

    if ((fResult = SetAsn1DecodeAndAlloc(
            SETHashedRootKey_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pSETHashedRootKey))) {
        if (pSETHashedRootKey->length != SET_HASHED_ROOT_LEN) {
            fResult = FALSE;
            SetLastError((DWORD) CRYPT_E_BAD_ENCODE);
            *pcbInfo = 0;
        } else {
            if (*pcbInfo < SET_HASHED_ROOT_LEN) {
                if (rgbInfo) {
                    fResult = FALSE;
                    SetLastError((DWORD) ERROR_MORE_DATA);
                }
            } else
                memcpy(rgbInfo, pSETHashedRootKey->value, SET_HASHED_ROOT_LEN);
            *pcbInfo = SET_HASHED_ROOT_LEN;
        }
    } else
        *pcbInfo = 0;

    SetAsn1Free(SETHashedRootKey_PDU, pSETHashedRootKey);
    return fResult;
}

//+-------------------------------------------------------------------------
//  SET Certificate Type Private Extension Encode (OSS X509)
//--------------------------------------------------------------------------
BOOL
WINAPI
SetAsn1CertificateTypeEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PCRYPT_BIT_BLOB pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    BITSTRING OssSETCertificateType;

    SetX509SetBit(pInfo, &OssSETCertificateType);
    return SetAsn1Encode(
        SETCertificateType_PDU,
        &OssSETCertificateType,
        pbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  SET Certificate Type Private Extension Decode (OSS X509)
//--------------------------------------------------------------------------
BOOL
WINAPI
SetAsn1CertificateTypeDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCRYPT_BIT_BLOB pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    BITSTRING *pSETCertificateType = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (!SetAsn1DecodeAndAlloc(
            SETCertificateType_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pSETCertificateType))
        goto ErrorReturn;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(CRYPT_BIT_BLOB);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else
        pbExtra = (BYTE *) pInfo + sizeof(CRYPT_BIT_BLOB);

    SetX509GetBit(pSETCertificateType, dwFlags, pInfo, &pbExtra, &lRemainExtra);

    if (lRemainExtra >= 0)
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;
ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    SetAsn1Free(SETCertificateType_PDU, pSETCertificateType);
    return fResult;
}

//+-------------------------------------------------------------------------
//  SET Merchant Data Private Extension Encode (OSS X509)
//--------------------------------------------------------------------------
BOOL
WINAPI
SetAsn1MerchantDataEncode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN PSET_MERCHANT_DATA_INFO pInfo,
        OUT BYTE *pbEncoded,
        IN OUT DWORD *pcbEncoded
        )
{
    SETMerchantData OssSETMerchantData;
    HCRYPTOIDFUNCSET hX509EncodeFuncSet;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    SetX509SetIA5(pInfo->pszMerID, &OssSETMerchantData.merID);
    SetX509SetIA5(pInfo->pszMerAcquirerBIN,
        (IA5STRING *) &OssSETMerchantData.merAcquirerBIN);
    SetX509SetIA5(pInfo->pszMerTermID, &OssSETMerchantData.merTermID);
    SetX509SetIA5(pInfo->pszMerName, &OssSETMerchantData.merName);
    SetX509SetIA5(pInfo->pszMerCity, &OssSETMerchantData.merCity);
    SetX509SetIA5(pInfo->pszMerStateProvince,
        &OssSETMerchantData.merStateProvince);
    SetX509SetIA5(pInfo->pszMerPostalCode, &OssSETMerchantData.merPostalCode);
    SetX509SetIA5(pInfo->pszMerCountry, &OssSETMerchantData.merCountry);
    SetX509SetIA5(pInfo->pszMerPhone, &OssSETMerchantData.merPhone);
    OssSETMerchantData.merPhoneRelease = (pInfo->fMerPhoneRelease != 0);
    OssSETMerchantData.merAuthFlag = (pInfo->fMerAuthFlag != 0);

    // For testing purposes, verify that CryptGetOIDFunctionAddress fails
    // to find a pre-installed function
    if (NULL == (hX509EncodeFuncSet = CryptInitOIDFunctionSet(
            CRYPT_OID_ENCODE_OBJECT_FUNC,
            0)))
        goto CryptInitOIDFunctionSetError;
    if (CryptGetOIDFunctionAddress(
            hX509EncodeFuncSet,
            X509_ASN_ENCODING,
            szOID_SET_MERCHANT_DATA,
            CRYPT_GET_INSTALLED_OID_FUNC_FLAG,
            &pvFuncAddr,
            &hFuncAddr
            )) {
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
        goto GotUnexpectedPreinstalledFunction;
    }

    // Verify we get our registered address
    if (!CryptGetOIDFunctionAddress(
            hX509EncodeFuncSet,
            X509_ASN_ENCODING,
            szOID_SET_MERCHANT_DATA,
            0,                              // dwFlags
            &pvFuncAddr,
            &hFuncAddr
            ))
        goto DidNotGetRegisteredFunction;
    else
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);


    return SetAsn1Encode(
        SETMerchantData_PDU,
        &OssSETMerchantData,
        pbEncoded,
        pcbEncoded
        );

ErrorReturn:
    *pcbEncoded = 0;
    return FALSE;
TRACE_ERROR(CryptInitOIDFunctionSetError)
SET_ERROR(GotUnexpectedPreinstalledFunction, E_UNEXPECTED)
SET_ERROR(DidNotGetRegisteredFunction, E_UNEXPECTED)
}

//+-------------------------------------------------------------------------
//  SET Merchant Data Private Extension Decode (OSS X509)
//--------------------------------------------------------------------------
BOOL
WINAPI
SetAsn1MerchantDataDecode(
        IN DWORD dwCertEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PSET_MERCHANT_DATA_INFO pInfo,
        IN OUT DWORD *pcbInfo
        )
{
    BOOL fResult;
    SETMerchantData *pSETMerchantData = NULL;
    BYTE *pbExtra;
    LONG lRemainExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (!SetAsn1DecodeAndAlloc(
            SETMerchantData_PDU,
            pbEncoded,
            cbEncoded,
            (void **) &pSETMerchantData))
        goto ErrorReturn;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lRemainExtra = (LONG) *pcbInfo - sizeof(SET_MERCHANT_DATA_INFO);
    if (lRemainExtra < 0) {
        pbExtra = NULL;
    } else {
        // Update fields not needing extra memory after the
        // SET_MERCHANT_DATA_INFO
        pInfo->fMerPhoneRelease = pSETMerchantData->merPhoneRelease;
        pInfo->fMerAuthFlag = pSETMerchantData->merAuthFlag;
        pbExtra = (BYTE *) pInfo + sizeof(SET_MERCHANT_DATA_INFO);
    }

    SetX509GetIA5(&pSETMerchantData->merID, dwFlags, &pInfo->pszMerID,
        &pbExtra, &lRemainExtra);
    SetX509GetIA5((IA5STRING *) &pSETMerchantData->merAcquirerBIN, dwFlags,
        &pInfo->pszMerAcquirerBIN, &pbExtra, &lRemainExtra);
    SetX509GetIA5(&pSETMerchantData->merTermID, dwFlags, &pInfo->pszMerTermID,
        &pbExtra, &lRemainExtra);
    SetX509GetIA5(&pSETMerchantData->merName, dwFlags, &pInfo->pszMerName,
        &pbExtra, &lRemainExtra);
    SetX509GetIA5(&pSETMerchantData->merCity, dwFlags, &pInfo->pszMerCity,
        &pbExtra, &lRemainExtra);
    SetX509GetIA5(&pSETMerchantData->merStateProvince, dwFlags,
        &pInfo->pszMerStateProvince, &pbExtra, &lRemainExtra);
    SetX509GetIA5(&pSETMerchantData->merPostalCode, dwFlags,
        &pInfo->pszMerPostalCode, &pbExtra, &lRemainExtra);
    SetX509GetIA5(&pSETMerchantData->merCountry, dwFlags, &pInfo->pszMerCountry,
        &pbExtra, &lRemainExtra);
    SetX509GetIA5(&pSETMerchantData->merPhone, dwFlags, &pInfo->pszMerPhone,
        &pbExtra, &lRemainExtra);

    if (lRemainExtra >= 0)
        *pcbInfo = *pcbInfo - (DWORD) lRemainExtra;
    else {
        *pcbInfo = *pcbInfo + (DWORD) -lRemainExtra;
        if (pInfo) goto LengthError;
    }

    fResult = TRUE;
    goto CommonReturn;

LengthError:
    SetLastError((DWORD) ERROR_MORE_DATA);
    fResult = FALSE;
    goto CommonReturn;

ErrorReturn:
    *pcbInfo = 0;
    fResult = FALSE;
CommonReturn:
    SetAsn1Free(SETMerchantData_PDU, pSETMerchantData);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\sp3crmsg\sp3crmsg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       sp3crmsg.cpp
//
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  File:       sp3crmsg.cpp
//
//  Contents:   Installable OID functions providing backwards compatiblity
//              with the way the NT4.0 SP3 and IE 3.02 versions of crypt32.dll
//              encrypted the symmetric key in a PKCS #7 EnvelopedData message.
//
//              The SP3 version of crypt32.dll failed to byte reverse the
//              encrypted symmetric key. It also added zero salt instead
//              of no salt.
//
//  Functions:  DllMain
//              DllRegisterServer
//              DllUnregisterServer
//              SP3ImportEncryptKey
//              SP3GenEncryptKey
//              SP3ExportEncryptKey
#ifdef CMS_PKCS7
//              DllInstall
//              CryptMsgDllGenContentEncryptKey
//              CryptMsgDllExportKeyTrans
//              CryptMsgDllImportKeyTrans
//              NotImplCryptMsgDllImportKeyTrans
#endif  // CMS_PKCS7
//--------------------------------------------------------------------------

#define CMS_PKCS7       1
#include <windows.h>
#include <wincrypt.h>

#include "sp3crmsg.h"

// memory management
#define SP3Alloc(cb)                ((void*)LocalAlloc(LPTR, cb))
#define SP3Free(pv)                 (LocalFree((HLOCAL)pv))

// The Thread Local Storage (TLS) referenced by iSP3TLS has pointer of
// ((void *) 0x1) if SP3 compatible encryption is enabled. Otherwise, its 0.
static DWORD iSP3TLS = 0xFFFFFFFF;
#define SP3_TLS_POINTER             ((void *) 0x1)

typedef struct _SIMPLEBLOBHEADER {
    ALG_ID  aiEncAlg;
} SIMPLEBLOBHEADER, *PSIMPLEBLOBHEADER;

typedef struct _OID_REG_ENTRY {
    LPCSTR   pszOID;
    LPCSTR   pszOverrideFuncName;
} OID_REG_ENTRY, *POID_REG_ENTRY;

//+-------------------------------------------------------------------------
//  ImportEncryptKey OID Installable Functions
//--------------------------------------------------------------------------
static HCRYPTOIDFUNCSET hImportEncryptKeyFuncSet;
static PFN_CMSG_IMPORT_ENCRYPT_KEY pfnDefaultImportEncryptKey = NULL;

BOOL
WINAPI
SP3ImportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN DWORD                        dwKeySpec,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiPubKey,
    IN PBYTE                        pbEncodedKey,
    IN DWORD                        cbEncodedKey,
    OUT HCRYPTKEY                   *phEncryptKey);

static const CRYPT_OID_FUNC_ENTRY ImportEncryptKeyFuncTable[] = {
    szOID_OIWSEC_desCBC, SP3ImportEncryptKey,
    szOID_RSA_RC2CBC, SP3ImportEncryptKey,
    szOID_RSA_RC4, SP3ImportEncryptKey
};
#define IMPORT_ENCRYPT_KEY_FUNC_COUNT (sizeof(ImportEncryptKeyFuncTable) / \
                                        sizeof(ImportEncryptKeyFuncTable[0]))

static const OID_REG_ENTRY ImportEncryptKeyRegTable[] = {
    szOID_OIWSEC_desCBC, "SP3ImportEncryptKey",
    szOID_RSA_RC2CBC, "SP3ImportEncryptKey",
    szOID_RSA_RC4, "SP3ImportEncryptKey"
};
#define IMPORT_ENCRYPT_KEY_REG_COUNT (sizeof(ImportEncryptKeyRegTable) / \
                                        sizeof(ImportEncryptKeyRegTable[0]))

//+-------------------------------------------------------------------------
//  GenEncryptKey OID Installable Functions
//--------------------------------------------------------------------------
static HCRYPTOIDFUNCSET hGenEncryptKeyFuncSet;
static PFN_CMSG_GEN_ENCRYPT_KEY pfnDefaultGenEncryptKey = NULL;

BOOL
WINAPI
SP3GenEncryptKey(
    IN OUT HCRYPTPROV               *phCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PVOID                        pvEncryptAuxInfo,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    IN PFN_CMSG_ALLOC               pfnAlloc,
    OUT HCRYPTKEY                   *phEncryptKey,
    OUT PBYTE                       *ppbEncryptParameters,
    OUT PDWORD                      pcbEncryptParameters);

static const CRYPT_OID_FUNC_ENTRY GenEncryptKeyFuncTable[] = {
    szOID_OIWSEC_desCBC, SP3GenEncryptKey,
    szOID_RSA_RC2CBC, SP3GenEncryptKey,
    szOID_RSA_RC4, SP3GenEncryptKey
};
#define GEN_ENCRYPT_KEY_FUNC_COUNT (sizeof(GenEncryptKeyFuncTable) / \
                                        sizeof(GenEncryptKeyFuncTable[0]))

static const OID_REG_ENTRY GenEncryptKeyRegTable[] = {
    szOID_OIWSEC_desCBC, "SP3GenEncryptKey",
    szOID_RSA_RC2CBC, "SP3GenEncryptKey",
    szOID_RSA_RC4, "SP3GenEncryptKey"
};
#define GEN_ENCRYPT_KEY_REG_COUNT (sizeof(GenEncryptKeyRegTable) / \
                                        sizeof(GenEncryptKeyRegTable[0]))

//+-------------------------------------------------------------------------
//  ExportEncryptKey OID Installable Functions
//--------------------------------------------------------------------------
static HCRYPTOIDFUNCSET hExportEncryptKeyFuncSet;
static PFN_CMSG_EXPORT_ENCRYPT_KEY pfnDefaultExportEncryptKey = NULL;

BOOL
WINAPI
SP3ExportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    OUT PBYTE                       pbData,
    IN OUT PDWORD                   pcbData);

static const CRYPT_OID_FUNC_ENTRY ExportEncryptKeyFuncTable[] = {
    szOID_RSA_RSA, SP3ExportEncryptKey
};
#define EXPORT_ENCRYPT_KEY_FUNC_COUNT (sizeof(ExportEncryptKeyFuncTable) / \
                                        sizeof(ExportEncryptKeyFuncTable[0]))

static const OID_REG_ENTRY ExportEncryptKeyRegTable[] = {
    szOID_RSA_RSA, "SP3ExportEncryptKey"
};
#define EXPORT_ENCRYPT_KEY_REG_COUNT (sizeof(ExportEncryptKeyRegTable) / \
                                        sizeof(ExportEncryptKeyRegTable[0]))

static char szCrypt32[]="crypt32.dll";

// First post IE4.0 versions of crypt32.dll start with "5.101.1681.1"
static DWORD dwLowVersion    = (1681 << 16) | 1;
static DWORD dwHighVersion   = (5 << 16) | 101; 

static BOOL IsPostIE4Crypt32()
{
    BOOL fPostIE4 = FALSE;   // default to IE4
    DWORD dwHandle = 0;
    DWORD cbInfo;
    void *pvInfo = NULL;
	VS_FIXEDFILEINFO *pFixedFileInfo = NULL;   // not allocated
	UINT ccFixedFileInfo = 0;

    if (0 == (cbInfo = GetFileVersionInfoSizeA(szCrypt32, &dwHandle)))
        goto ErrorReturn;

    if (NULL == (pvInfo = SP3Alloc(cbInfo)))
        goto ErrorReturn;

    if (!GetFileVersionInfoA(
            szCrypt32,
            0,          // dwHandle, ignored
            cbInfo,
            pvInfo
            ))
        goto ErrorReturn;

    if (!VerQueryValueA(
            pvInfo,
            "\\",       // VS_FIXEDFILEINFO
            (void **) &pFixedFileInfo,
            &ccFixedFileInfo
            ))
        goto ErrorReturn;

    if (pFixedFileInfo->dwFileVersionMS > dwHighVersion ||
            (pFixedFileInfo->dwFileVersionMS == dwHighVersion &&
                pFixedFileInfo->dwFileVersionLS >= dwLowVersion))
        fPostIE4 = TRUE;

CommonReturn:
    if (pvInfo)
        SP3Free(pvInfo);
    return fPostIE4;
ErrorReturn:
    goto CommonReturn;
}

static HRESULT HError()
{
    DWORD dw = GetLastError();

    HRESULT hr;
    if ( dw <= 0xFFFF )
        hr = HRESULT_FROM_WIN32 ( dw );
    else
        hr = dw;

    if ( ! FAILED ( hr ) )
    {
        // somebody failed a call without properly setting an error condition

        hr = E_UNEXPECTED;
    }
    return hr;
}


STDAPI DllRegisterServer(void)
{
    int i;

    DWORD dwFlags = CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG;
    for (i = 0; i < IMPORT_ENCRYPT_KEY_REG_COUNT; i++) {
        if (!CryptRegisterOIDFunction(
                X509_ASN_ENCODING,
                CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC,
                ImportEncryptKeyRegTable[i].pszOID,
                L"sp3crmsg.dll",
                ImportEncryptKeyRegTable[i].pszOverrideFuncName
                ))
            return HError();

        if (!CryptSetOIDFunctionValue(
                X509_ASN_ENCODING,
                CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC,
                ImportEncryptKeyRegTable[i].pszOID,
                CRYPT_OID_REG_FLAGS_VALUE_NAME,
                REG_DWORD,
                (BYTE *) &dwFlags,
                sizeof(dwFlags)
                ))
            return HError();
    }

    for (i = 0; i < GEN_ENCRYPT_KEY_REG_COUNT; i++) {
        if (!CryptRegisterOIDFunction(
                X509_ASN_ENCODING,
                CMSG_OID_GEN_ENCRYPT_KEY_FUNC,
                GenEncryptKeyRegTable[i].pszOID,
                L"sp3crmsg.dll",
                GenEncryptKeyRegTable[i].pszOverrideFuncName
                ))
            return HError();

        if (!CryptSetOIDFunctionValue(
                X509_ASN_ENCODING,
                CMSG_OID_GEN_ENCRYPT_KEY_FUNC,
                GenEncryptKeyRegTable[i].pszOID,
                CRYPT_OID_REG_FLAGS_VALUE_NAME,
                REG_DWORD,
                (BYTE *) &dwFlags,
                sizeof(dwFlags)
                ))
            return HError();
    }

    for (i = 0; i < EXPORT_ENCRYPT_KEY_REG_COUNT; i++) {
        if (!CryptRegisterOIDFunction(
                X509_ASN_ENCODING,
                CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC,
                ExportEncryptKeyRegTable[i].pszOID,
                L"sp3crmsg.dll",
                ExportEncryptKeyRegTable[i].pszOverrideFuncName
                ))
            return HError();

        if (!CryptSetOIDFunctionValue(
                X509_ASN_ENCODING,
                CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC,
                ExportEncryptKeyRegTable[i].pszOID,
                CRYPT_OID_REG_FLAGS_VALUE_NAME,
                REG_DWORD,
                (BYTE *) &dwFlags,
                sizeof(dwFlags)
                ))
            return HError();
    }
    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    HRESULT hr = S_OK;
    int i;

    for (i = 0; i < IMPORT_ENCRYPT_KEY_REG_COUNT; i++) {
        if (!CryptUnregisterOIDFunction(
                X509_ASN_ENCODING,
                CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC,
                ImportEncryptKeyRegTable[i].pszOID
                )) {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
                hr = HError();
        }
    }

    for (i = 0; i < GEN_ENCRYPT_KEY_REG_COUNT; i++) {
        if (!CryptUnregisterOIDFunction(
                X509_ASN_ENCODING,
                CMSG_OID_GEN_ENCRYPT_KEY_FUNC,
                GenEncryptKeyRegTable[i].pszOID
                )) {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
                hr = HError();
        }
    }

    for (i = 0; i < EXPORT_ENCRYPT_KEY_REG_COUNT; i++) {
        if (!CryptUnregisterOIDFunction(
                X509_ASN_ENCODING,
                CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC,
                ExportEncryptKeyRegTable[i].pszOID
                )) {
            if (ERROR_FILE_NOT_FOUND != GetLastError())
                hr = HError();
        }
    }

#ifdef CMS_PKCS7
    if (!CryptUnregisterOIDFunction(
            X509_ASN_ENCODING,
            CMSG_OID_GEN_CONTENT_ENCRYPT_KEY_FUNC,
            szOID_RSA_RC2CBC
            )) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            hr = HError();
    }

    if (!CryptUnregisterOIDFunction(
            X509_ASN_ENCODING,
            CMSG_OID_EXPORT_KEY_TRANS_FUNC,
            szOID_RSA_RSA
            )) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            hr = HError();
    }

    if (!CryptUnregisterOIDFunction(
            X509_ASN_ENCODING,
            CMSG_OID_IMPORT_KEY_TRANS_FUNC,
            szOID_RSA_RSA "!" szOID_RSA_RC2CBC
            )) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            hr = HError();
    }

    if (!CryptUnregisterOIDFunction(
            X509_ASN_ENCODING,
            CMSG_OID_IMPORT_KEY_TRANS_FUNC,
            szOID_RSA_RC2CBC
            )) {
        if (ERROR_FILE_NOT_FOUND != GetLastError())
            hr = HError();
    }

#endif  // CMS_PKCS7

    return hr;
}

#ifdef CMS_PKCS7
//+---------------------------------------------------------------------------
//
//  Function:   DllInstall
//
//  Synopsis:   dll installation entry point
//
//----------------------------------------------------------------------------
STDAPI DllInstall (BOOL fRegister, LPCSTR pszCommand)
{
    if (!fRegister)
        return DllUnregisterServer();

    if (!CryptRegisterOIDFunction(
            X509_ASN_ENCODING,
            CMSG_OID_GEN_CONTENT_ENCRYPT_KEY_FUNC,
            szOID_RSA_RC2CBC,
            L"sp3crmsg.dll",
            NULL                                    // pszOverrideFuncName
            ))
        return HError();

    if (!CryptRegisterOIDFunction(
            X509_ASN_ENCODING,
            CMSG_OID_EXPORT_KEY_TRANS_FUNC,
            szOID_RSA_RSA,
            L"sp3crmsg.dll",
            NULL                                    // pszOverrideFuncName
            ))
        return HError();

    if (!CryptRegisterOIDFunction(
            X509_ASN_ENCODING,
            CMSG_OID_IMPORT_KEY_TRANS_FUNC,
            szOID_RSA_RSA "!" szOID_RSA_RC2CBC,
            L"sp3crmsg.dll",
            "NotImplCryptMsgDllImportKeyTrans"
            ))
        return HError();

    if (!CryptRegisterOIDFunction(
            X509_ASN_ENCODING,
            CMSG_OID_IMPORT_KEY_TRANS_FUNC,
            szOID_RSA_RC2CBC,
            L"sp3crmsg.dll",
            NULL                                    // pszOverrideFuncName
            ))
        return HError();

    return S_OK;
}
#endif  // CMS_PKCS7

//+-------------------------------------------------------------------------
//  Function:  DllMain
//
//  Synopsis:  Process/Thread attach/detach
//
//             At process attach install the SP3 compatible version of
//             CryptMsgDllImportEncryptKey, CryptMsgDllGenEncryptKey and
//             CryptMsgDllExportEncryptKey.
//--------------------------------------------------------------------------
BOOL
WINAPI
DllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL fResult;
    HCRYPTOIDFUNCADDR hFuncAddr;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
#if 0
        // Post IE 4.0 releases of crypt32.dll already have the SP3
        // backwards compatible fix.
        if (IsPostIE4Crypt32())
            return TRUE;
#endif

        if (NULL == (hImportEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC,
                0)))
            goto ErrorReturn;
        if (NULL == (hGenEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_GEN_ENCRYPT_KEY_FUNC,
                0)))
            goto ErrorReturn;
        if (NULL == (hExportEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC,
                0)))
            goto ErrorReturn;

        // Get the default import encrypt key function which we will call if
        // unable to do a successful import without byte reversing the
        // encrypted symmetric key.
        if (CryptGetOIDFunctionAddress(
                hImportEncryptKeyFuncSet,
                X509_ASN_ENCODING,
                szOID_RSA_RC2CBC,
                CRYPT_GET_INSTALLED_OID_FUNC_FLAG,
                (void **) &pfnDefaultImportEncryptKey,
                &hFuncAddr))
            CryptFreeOIDFunctionAddress(hFuncAddr, 0);

#if 0
        if (!CryptInstallOIDFunctionAddress(
                hInst,
                X509_ASN_ENCODING,
                CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC,
                IMPORT_ENCRYPT_KEY_FUNC_COUNT,
                ImportEncryptKeyFuncTable,
                CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG      // dwFlags
                ))
            goto ErrorReturn;
#endif

        // Get the default gen and export encrypt key functions which we will
        // call if pvEncryptionAuxInfo points to a
        // CMSG_SP3_COMPATIBLE_AUX_INFO data structure.
        if (CryptGetOIDFunctionAddress(
                hGenEncryptKeyFuncSet,
                X509_ASN_ENCODING,
                szOID_RSA_RC2CBC,
                CRYPT_GET_INSTALLED_OID_FUNC_FLAG,
                (void **) &pfnDefaultGenEncryptKey,
                &hFuncAddr))
            CryptFreeOIDFunctionAddress(hFuncAddr, 0);
        if (CryptGetOIDFunctionAddress(
                hExportEncryptKeyFuncSet,
                X509_ASN_ENCODING,
                szOID_RSA_RSA,
                CRYPT_GET_INSTALLED_OID_FUNC_FLAG,
                (void **) &pfnDefaultExportEncryptKey,
                &hFuncAddr))
            CryptFreeOIDFunctionAddress(hFuncAddr, 0);

#if 0
        if (!CryptInstallOIDFunctionAddress(
                hInst,
                X509_ASN_ENCODING,
                CMSG_OID_GEN_ENCRYPT_KEY_FUNC,
                GEN_ENCRYPT_KEY_FUNC_COUNT,
                GenEncryptKeyFuncTable,
                CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG      // dwFlags
                ))
            goto ErrorReturn;
        if (!CryptInstallOIDFunctionAddress(
                hInst,
                X509_ASN_ENCODING,
                CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC,
                EXPORT_ENCRYPT_KEY_FUNC_COUNT,
                ExportEncryptKeyFuncTable,
                CRYPT_INSTALL_OID_FUNC_BEFORE_FLAG      // dwFlags
                ))
            goto ErrorReturn;
#endif

        // Allocate TLS which contains a pointer of ((void *) 0x1) for SP3
        // compatible encryption. This pointer will be passed from
        // SP3GenEncryptKey() to SP3ExportEncryptKey().
        //
        // If not SP3 encryption, the pointer is NULL.
        if ((iSP3TLS = TlsAlloc()) == 0xFFFFFFFF)
            goto ErrorReturn;
        break;

    case DLL_PROCESS_DETACH:
        if (iSP3TLS != 0xFFFFFFFF) {
            TlsFree(iSP3TLS);
            iSP3TLS = 0xFFFFFFFF;
        }
        break;
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fResult = TRUE;
CommonReturn:
    return fResult;

ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;
}

//+-------------------------------------------------------------------------
//  SP3 import of the encryption key.
//
//  The SP3 version of crypt32.dll didn't include any parameters for the
//  encryption algorithm. Later versions of crypt32.dll do. Therefore, we only
//  need to attempt to import the key without byte reversal if there aren't
//  any parameters present.
//--------------------------------------------------------------------------
BOOL
WINAPI
SP3ImportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN DWORD                        dwKeySpec,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiPubKey,
    IN PBYTE                        pbEncodedKey,
    IN DWORD                        cbEncodedKey,
    OUT HCRYPTKEY                   *phEncryptKey
    )
{
    BOOL                    fResult;
    HCRYPTKEY               hEncryptKey = 0;
    HCRYPTKEY               hUserKey = 0;
    DWORD                   dwAlgIdEncrypt;
    DWORD                   dwAlgIdPubKey;
    PBYTE                   pbCspKey = NULL;
    DWORD                   cbCspKey;
    PUBLICKEYSTRUC          *ppks;
    PSIMPLEBLOBHEADER       psbh;
    PCCRYPT_OID_INFO        pOIDInfo;

    // Check if more than just the NULL parameters
    if (2 < paiEncrypt->Parameters.cbData) {
        fResult = FALSE;
        goto DefaultImport;
    }

    // Map the ASN algorithm identifier to the CSP ALG_ID.
    if (NULL == (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            paiEncrypt->pszObjId,
            CRYPT_ENCRYPT_ALG_OID_GROUP_ID)))
        goto GetEncryptAlgidError;
    dwAlgIdEncrypt = pOIDInfo->Algid;

    // Create the CSP encrypted symmetric key structure WITHOUT BYTE REVERSAL.
    dwAlgIdPubKey = CALG_RSA_KEYX;
    cbCspKey = cbEncodedKey + sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER);
    if (NULL == (pbCspKey = (PBYTE)SP3Alloc( cbCspKey)))
        goto OutOfMemory;
    ppks = (PUBLICKEYSTRUC *)pbCspKey;
    ppks->bType = SIMPLEBLOB;
    ppks->bVersion = CUR_BLOB_VERSION;
    ppks->reserved = 0;
    ppks->aiKeyAlg = dwAlgIdEncrypt;
    psbh = (PSIMPLEBLOBHEADER)(ppks + 1);
    psbh->aiEncAlg = dwAlgIdPubKey;
    // NO BYTE REVERSAL as done in SP3.
    memcpy( (PBYTE)(psbh+1), pbEncodedKey, cbEncodedKey);

    if (0 != dwKeySpec) {
        // Get private key to use.
        if (!CryptGetUserKey(
                hCryptProv,
                dwKeySpec,
                &hUserKey)) {
            hUserKey = 0;
            goto GetUserKeyFailed;
        }
    }

    // Try importing as an NT4.0 SP3 encypted key that wasn't byte
    // reversed and with zero salt.
    fResult = CryptImportKey(
        hCryptProv,
        pbCspKey,
        cbCspKey,
        hUserKey,
        0,          // dwFlags
        &hEncryptKey);
    if (!fResult && hUserKey) {
        // Try without using the specified user key.
        fResult = CryptImportKey(
            hCryptProv,
            pbCspKey,
            cbCspKey,
            0,          // hUserKey
            0,          // dwFlags
            &hEncryptKey);
    }

    if (!fResult)
        goto ImportKeyFailed;

    fResult = TRUE;
CommonReturn:
    if (pbCspKey)
        SP3Free(pbCspKey);
    if (hUserKey) {
        DWORD dwError = GetLastError();
        CryptDestroyKey(hUserKey);
        SetLastError(dwError);
    }

DefaultImport:
    if (!fResult && pfnDefaultImportEncryptKey)
        // Try importing using the default
        return pfnDefaultImportEncryptKey(
            hCryptProv,
            dwKeySpec,
            paiEncrypt,
            paiPubKey,
            pbEncodedKey,
            cbEncodedKey,
            phEncryptKey);
    else {
        *phEncryptKey = hEncryptKey;
        return fResult;
    }


GetEncryptAlgidError:
OutOfMemory:
GetUserKeyFailed:
ImportKeyFailed:
    hEncryptKey = 0;
    fResult = FALSE;
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  SP3 generation of the encryption key.
//
//  The SP3 version of crypt32.dll didn't include the IV octet string for the
//  encryption algorithm. Also, the encryption key had zero salt instead
//  of no salt.
//
//  For SP3 compatible generation, the caller must pass in a non-NULL
//  hCryptProv and set pvEncryptAuxInfo to point to a
//  CMSG_SP3_COMPATIBLE_AUX_INFO data structure with the
//  CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG set.
//--------------------------------------------------------------------------
BOOL
WINAPI
SP3GenEncryptKey(
    IN OUT HCRYPTPROV               *phCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PVOID                        pvEncryptAuxInfo,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    IN PFN_CMSG_ALLOC               pfnAlloc,
    OUT HCRYPTKEY                   *phEncryptKey,
    OUT PBYTE                       *ppbEncryptParameters,
    OUT PDWORD                      pcbEncryptParameters
    )
{
    HCRYPTPROV hCryptProv;
    PCMSG_SP3_COMPATIBLE_AUX_INFO pSP3AuxInfo =
        (PCMSG_SP3_COMPATIBLE_AUX_INFO) pvEncryptAuxInfo;
    PCCRYPT_OID_INFO pOIDInfo;
    DWORD dwAlgIdEncrypt;

    hCryptProv = *phCryptProv;
    if (0 == hCryptProv || NULL == pSP3AuxInfo ||
            sizeof(CMSG_SP3_COMPATIBLE_AUX_INFO) > pSP3AuxInfo->cbSize ||
            0 == (pSP3AuxInfo->dwFlags & CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG)) {

        // Let SP3ExportEncryptKey() know this will be a default export
        TlsSetValue(iSP3TLS, NULL);

        if (pfnDefaultGenEncryptKey)
            // Generate using the default
            return pfnDefaultGenEncryptKey(
                phCryptProv,
                paiEncrypt,
                pvEncryptAuxInfo,
                pPublicKeyInfo,
                pfnAlloc,
                phEncryptKey,
                ppbEncryptParameters,
                pcbEncryptParameters
                );
        else {
            // We don't have a default
            *phEncryptKey = 0;
            SetLastError((DWORD) E_UNEXPECTED);
            return FALSE;
        }
    }

    // Let SP3ExportEncryptKey() know this will be a SP3 compatible export.
    TlsSetValue(iSP3TLS, SP3_TLS_POINTER);

    // Map the ASN algorithm identifier to the CSP ALG_ID.
    if (NULL == (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            paiEncrypt->pszObjId,
            CRYPT_ENCRYPT_ALG_OID_GROUP_ID))) {
        *phEncryptKey = 0;
        return FALSE;
    }
    dwAlgIdEncrypt = pOIDInfo->Algid;

    // Since CRYPT_NO_SALT flag isn't set, uses zero salt
    if (!CryptGenKey(
            hCryptProv,
            dwAlgIdEncrypt,
            CRYPT_EXPORTABLE,
            phEncryptKey)) {
        *phEncryptKey = 0;    
        return FALSE;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//  SP3 export of the encryption key.
//
//  The SP3 version of crypt32.dll encoded the encrypted symmetric key as
//  little endian instead of as big endian.
//--------------------------------------------------------------------------
BOOL
WINAPI
SP3ExportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    OUT PBYTE                       pbData,
    IN OUT PDWORD                   pcbData
    )
{
    BOOL            fResult;
    DWORD           dwError = ERROR_SUCCESS;
    HCRYPTKEY       hPubKey = NULL;
    PBYTE           pb = NULL;
    DWORD           cb;

    if (SP3_TLS_POINTER != TlsGetValue(iSP3TLS)) {
        if (pfnDefaultExportEncryptKey)
            // Export using the default function
            return pfnDefaultExportEncryptKey(
                hCryptProv,
                hEncryptKey,
                pPublicKeyInfo,
                pbData,
                pcbData
                );
        else {
            // We don't have a default
            *pcbData = 0;
            SetLastError((DWORD) E_UNEXPECTED);
            return FALSE;
        }
    }

    // SP3 compatible export and encode


    if (!CryptImportPublicKeyInfo(
            hCryptProv,
            X509_ASN_ENCODING,
            pPublicKeyInfo,
            &hPubKey))
        goto ImportKeyError;
    if (!CryptExportKey(
            hEncryptKey,
            hPubKey,
            SIMPLEBLOB,
            0,                  // dwFlags
            NULL,
            &cb))
        goto ExportKeySizeError;
    if (NULL == (pb = (PBYTE) SP3Alloc(cb)))
        goto ExportKeyAllocError;
    if (!CryptExportKey(
            hEncryptKey,
            hPubKey,
            SIMPLEBLOB,
            0,                  // dwFlags
            pb,
            &cb))
        goto ExportKeyError;
    cb -= sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER);

    fResult = TRUE;
    if (pbData) {
        if (*pcbData < cb) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fResult = FALSE;
        } else if (0 < cb) {
            // Don't byte reverse
            memcpy(pbData,
                 pb + (sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER)), cb);
        }
    }

CommonReturn:
    *pcbData = cb;
    if (pb)
        SP3Free(pb);
    if (hPubKey)
        CryptDestroyKey(hPubKey);
    SetLastError(dwError);
    return fResult;

ImportKeyError:
ExportKeySizeError:
ExportKeyAllocError:
ExportKeyError:
    dwError = GetLastError();
    cb = 0;
    fResult = FALSE;
    goto CommonReturn;
}

#ifdef CMS_PKCS7

BOOL
WINAPI
CryptMsgDllGenContentEncryptKey(
    IN OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fResult;
    HCRYPTOIDFUNCSET hGenContentFuncSet;
    HCRYPTOIDFUNCADDR hFuncAddr;
    PFN_CMSG_GEN_CONTENT_ENCRYPT_KEY pfnDefaultGenContent;

    if (NULL == (hGenContentFuncSet = CryptInitOIDFunctionSet(
            CMSG_OID_GEN_CONTENT_ENCRYPT_KEY_FUNC, 0)))
        return FALSE;

    // Get the default gen content encrypt key function which we will call
    if (!CryptGetOIDFunctionAddress(
            hGenContentFuncSet,
            X509_ASN_ENCODING,
            CMSG_DEFAULT_INSTALLABLE_FUNC_OID,
            CRYPT_GET_INSTALLED_OID_FUNC_FLAG,
            (void **) &pfnDefaultGenContent,
            &hFuncAddr))
        return FALSE;

    fResult = pfnDefaultGenContent(
        pContentEncryptInfo,
        dwFlags,
        pvReserved
        );

    CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    return fResult;
}

BOOL
WINAPI
CryptMsgDllExportKeyTrans(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTransEncodeInfo,
    IN OUT PCMSG_KEY_TRANS_ENCRYPT_INFO pKeyTransEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fResult;
    HCRYPTOIDFUNCSET hExportKeyTransFuncSet;
    HCRYPTOIDFUNCADDR hFuncAddr;
    PFN_CMSG_EXPORT_KEY_TRANS pfnDefaultExportKeyTrans;

    if (NULL == (hExportKeyTransFuncSet = CryptInitOIDFunctionSet(
            CMSG_OID_EXPORT_KEY_TRANS_FUNC, 0)))
        return FALSE;

    // Get the default export key trans function which we will call
    if (!CryptGetOIDFunctionAddress(
            hExportKeyTransFuncSet,
            X509_ASN_ENCODING,
            CMSG_DEFAULT_INSTALLABLE_FUNC_OID,
            CRYPT_GET_INSTALLED_OID_FUNC_FLAG,
            (void **) &pfnDefaultExportKeyTrans,
            &hFuncAddr))
        return FALSE;

    fResult = pfnDefaultExportKeyTrans(
        pContentEncryptInfo,
        pKeyTransEncodeInfo,
        pKeyTransEncryptInfo,
        dwFlags,
        pvReserved
        );

    CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    return fResult;
}

BOOL
WINAPI
CryptMsgDllImportKeyTrans(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA pKeyTransDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    )
{
    BOOL fResult;
    HCRYPTOIDFUNCSET hImportKeyTransFuncSet;
    HCRYPTOIDFUNCADDR hFuncAddr;
    PFN_CMSG_IMPORT_KEY_TRANS pfnDefaultImportKeyTrans;

    if (NULL == (hImportKeyTransFuncSet = CryptInitOIDFunctionSet(
            CMSG_OID_IMPORT_KEY_TRANS_FUNC, 0)))
        return FALSE;

    // Get the default import key trans function which we will call
    if (!CryptGetOIDFunctionAddress(
            hImportKeyTransFuncSet,
            X509_ASN_ENCODING,
            CMSG_DEFAULT_INSTALLABLE_FUNC_OID,
            CRYPT_GET_INSTALLED_OID_FUNC_FLAG,
            (void **) &pfnDefaultImportKeyTrans,
            &hFuncAddr))
        return FALSE;

    fResult = pfnDefaultImportKeyTrans(
        pContentEncryptionAlgorithm,
        pKeyTransDecryptPara,
        dwFlags,
        pvReserved,
        phContentEncryptKey
        );

    CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    return fResult;
}

BOOL
WINAPI
NotImplCryptMsgDllImportKeyTrans(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA pKeyTransDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    )
{
    SetLastError((DWORD) E_NOTIMPL);
    return FALSE;
}

#endif  // CMS_PKCS7
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\sp3crmsg\sp3crmsg.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       sp3crmsg.h
//
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  File:       sp3crmsg.h
//
//  Contents:   Data structure for enabling NT 4.0 SP3 and IE 3.02 compatible
//              PKCS #7 EnvelopeData messages.
//
//              The SP3 version of crypt32.dll failed to byte reverse the
//              encrypted symmetric key. It also added zero salt instead
//              of no salt.
//--------------------------------------------------------------------------

#ifndef __SP3CRMSG_H__
#define __SP3CRMSG_H__

#include <wincrypt.h>

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  To enable SP3 compatible encryption, the pvEncryptionAuxInfo field in either
//  CMSG_ENVELOPED_ENCODE_INFO for CryptMsgOpenToEncode() or
//  CRYPT_ENCRYPT_MESSAGE_PARA for CryptSignAndEncryptMessage() or
//  CryptSignAndEncryptMessage() should point to the following
//  CMSG_SP3_COMPATIBLE_AUX_INFO data structure.
//--------------------------------------------------------------------------


// The following is defined in newer versions of wincrypt.h, starting with
// IE 4.01 and  NT 5.0 Beta 2

#ifndef CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG

//+-------------------------------------------------------------------------
//  CMSG_SP3_COMPATIBLE_AUX_INFO
//
//  AuxInfo for enabling SP3 compatible encryption.
//
//  The CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG is set in dwFlags to enable SP3
//  compatible encryption. When set, uses zero salt instead of no salt,
//  the encryption algorithm parameters are NULL instead of containing the
//  encoded RC2 parameters or encoded IV octet string and the encrypted
//  symmetric key is encoded little endian instead of big endian.
//--------------------------------------------------------------------------
typedef struct _CMSG_SP3_COMPATIBLE_AUX_INFO {
    DWORD                       cbSize;
    DWORD                       dwFlags;
} CMSG_SP3_COMPATIBLE_AUX_INFO, *PCMSG_SP3_COMPATIBLE_AUX_INFO;

#define CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG    0x80000000

#endif  // CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG

#ifdef __cplusplus
}       // Balance extern "C" above
#endif


#endif // __SP3CRMSG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\tools\642bin\642bin.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       fdecrypt.cpp
//
//  Contents:   File Decryption tool. Decrypts a file looking in the MY
//              system certificate store for private keys.
//
//--------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <wincrypt.h>

//+-------------------------------------------------------------------------
//  Display Bin264 usage.
//--------------------------------------------------------------------------
void
Usage(void)
{
    printf("Usage: 642bin <Base64 Encoded File> <Binary File> \n");
    exit(1);
}

//+-------------------------------------------------------------------------
//  Generalized error routine
//--------------------------------------------------------------------------
#define PRINTERROR(psz, err)	_PrintError((psz), (err), __LINE__)
void
_PrintError(char *pszMsg, DWORD err, DWORD line)
{
    printf("%s failed on line %u: (%x)\n", pszMsg, line, err);
}

//+-------------------------------------------------------------------------
//  Main program. Open a file to decyrpt,
//  decrypts it and then writes the clear text
//  file out.
//--------------------------------------------------------------------------
int __cdecl
main(int argc, char * argv[])
{

    DWORD		dwExitValue	    = 0;
    DWORD		err		    = ERROR_SUCCESS;
    DWORD		cbT		    = 0;

    HANDLE hFileOut                         = INVALID_HANDLE_VALUE;
    HANDLE hFile                            = INVALID_HANDLE_VALUE;
    DWORD  cbFile                           = 0;
    HANDLE hMap                             = NULL;
    PBYTE  pbFile                           = NULL;

    PBYTE  pb		    = NULL;
    DWORD  cb		    = 0;

    // must have the parameters
    if(argc != 3)
        Usage();

    // Read in the file.
    if(

        // open the file to decrypt
        (hFile =  CreateFileA(
            argv[1],	            // pointer to name of the file
            GENERIC_READ,	        // access (read-write) mode
            FILE_SHARE_READ,	    // share mode
            NULL,	                // pointer to security descriptor
            OPEN_EXISTING,	        // how to create
            FILE_ATTRIBUTE_NORMAL,	// file attributes
            NULL                    // handle to file with attributes to copy
            ))  == INVALID_HANDLE_VALUE     ||

        // create a file mapping object
        (hMap = CreateFileMapping(
            hFile,	                // handle to file to map
            NULL,	                // optional security attributes
            PAGE_READONLY,	        // protection for mapping object
            0,	                    // high-order 32 bits of object size
            0,	                    // low-order 32 bits of object size
            NULL 	                // name of file-mapping object
            ))  == NULL                     ||

        // Map the file into the address space
        (pbFile = (PBYTE) MapViewOfFileEx(
            hMap,	                // file-mapping object to map into address space
            FILE_MAP_READ,	        // access mode
            0,	                    // high-order 32 bits of file offset
            0,	                    // low-order 32 bits of file offset
            0,	                    // number of bytes to map
            NULL 	                // suggested starting address for mapped view
            )) == NULL
        )
    {

        PRINTERROR("File Open", GetLastError());
        goto ErrCleanUp;
    }

    // get the size of the file
    if( (cbFile = GetFileSize(
            hFile,	                // handle of file to get size of
            NULL 	                // address of high-order word for file size
            )) == 0
        )
    {
        printf("File %s has a 0 length.\n", argv[2]);
        goto ErrCleanUp;
    }

    // at this point we have a file mapping, base64 encode the file

    if(!CryptStringToBinaryA(
		(const char *) pbFile,
		cbFile,
                CRYPT_STRING_ANY,
		NULL,
		&cb,
                NULL,
                NULL)) {
        err = GetLastError();
	PRINTERROR("CryptStringToBinaryA", err);
	goto ErrCleanUp;
    }

    if( (pb = (PBYTE) malloc(cb)) == NULL ) {
	PRINTERROR("malloc", ERROR_OUTOFMEMORY);
	goto ErrCleanUp;
    }

    if(!CryptStringToBinaryA(
		(const char *) pbFile,
		cbFile,
                CRYPT_STRING_ANY,
		pb,
		&cb,
                NULL,
                NULL)) {
        err = GetLastError();
	PRINTERROR("CryptStringToBinaryA", err);
	goto ErrCleanUp;
    }

    // write out the clear text file
    if(

        // open the output file
        (hFileOut =  CreateFileA(
            argv[2],	            // pointer to name of the file
	        GENERIC_WRITE,	    // access (read-write) mode
            FILE_SHARE_READ,	    // share mode
    	    NULL,		    // pointer to security descriptor
    	    CREATE_ALWAYS,	    // how to create
    	    FILE_ATTRIBUTE_NORMAL,  //file attributes
            NULL                    // handle to file with attributes to copy
            ))  == INVALID_HANDLE_VALUE     ||

        //write to the decrypted data to the file
        !WriteFile(
            hFileOut,	            // handle to file to write to
    	    pb,		    // pointer to data to write to file
    	    cb,		    // number of bytes to write
    	    &cbT,		    // pointer to number of bytes written
    	    NULL		    // pointer to structure needed for overlapped I/O
            )
        )
     {
        PRINTERROR("File Write", GetLastError());
        goto ErrCleanUp;
     }


    CleanUp:

        if(hMap != NULL)
            CloseHandle(hMap);

        if(hFile != INVALID_HANDLE_VALUE && hFile != NULL)
            CloseHandle(hFile);

        if(hFileOut != INVALID_HANDLE_VALUE && hFile != NULL)
            CloseHandle(hFileOut);

	if(pb != NULL)
	    free(pb);

    return(dwExitValue);

    ErrCleanUp:
        dwExitValue = 1;
        goto CleanUp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\wincrmsg\msgasn1.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       msgasn1.cpp
//
//  Contents:   Conversion APIs to/from ASN.1 data structures
//
//  Functions:  ICM_Asn1ToAttribute
//              ICM_Asn1ToAlgorithmIdentifier
//              ICM_Asn1FromAlgorithmIdentifier
//
//  History:    16-Apr-96   kevinr   created
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <dbgdef.h>

void *ICM_Alloc( IN size_t cbBytes);
void ICM_Free( IN void *pv);

//+-------------------------------------------------------------------------
//  Convert an CRYPT_ATTRIBUTE to an ASN1 Attribute
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_Asn1ToAttribute(
    IN PCRYPT_ATTRIBUTE       patr,
    OUT Attribute       *poatr)
{
    BOOL        fRet;
    DWORD       i;
    Any         *pAny;
    PCRYPT_ATTR_BLOB  pblob;

    DWORD       cbValue;
    PBYTE       pbValue;

    for (i=patr->cValue, pblob=patr->rgValue, cbValue = 0;
            i>0;
            i--, pblob++) {
        cbValue += pblob->cbData;
    }

    poatr->attributeType.count = 16;
    if (!PkiAsn1ToObjectIdentifier(
            patr->pszObjId,
            &poatr->attributeType.count,
            poatr->attributeType.value))
        goto PkiAsn1ToObjectIdentifierError;
    poatr->attributeValue.value = (Any *)ICM_Alloc(
        patr->cValue * sizeof(Any) + cbValue);
    if (NULL == poatr->attributeValue.value)
        goto AttributeValueMallocError;
    poatr->attributeValue.count = patr->cValue;

    pbValue = (PBYTE) (poatr->attributeValue.value + patr->cValue);
    for (i=patr->cValue, pAny=poatr->attributeValue.value, pblob=patr->rgValue;
            i>0;
            i--, pAny++, pblob++) {
        DWORD cbData = pblob->cbData;

        if (cbData)
            memcpy(pbValue, pblob->pbData, cbData);
        pAny->length = cbData;
        pAny->value  = pbValue;
        pbValue += cbData;
    }

    assert(pbValue == ((PBYTE) (poatr->attributeValue.value + patr->cValue)) +
        cbValue);

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(PkiAsn1ToObjectIdentifierError,CRYPT_E_OID_FORMAT)
TRACE_ERROR(AttributeValueMallocError)  // error already set
}


//+-------------------------------------------------------------------------
//  Convert an CRYPT_ALGORITHM_IDENTIFIER to an ASN1 AlgorithmIdentifier
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_Asn1ToAlgorithmIdentifier(
    IN PCRYPT_ALGORITHM_IDENTIFIER pai,
    OUT AlgorithmIdentifier *pAsn1AlgId)
{
    BOOL    fRet;
    static BYTE abDerNULL[] = {5, 0};


    pAsn1AlgId->algorithm.count = 16;
    if (!PkiAsn1ToObjectIdentifier(
            pai->pszObjId,
            &pAsn1AlgId->algorithm.count,
            pAsn1AlgId->algorithm.value))
        goto PkiAsn1ToObjectIdentifierError;
    pAsn1AlgId->bit_mask = parameters_present;
    if (0 == pai->Parameters.cbData) {
        pAsn1AlgId->parameters.length = sizeof( abDerNULL);
        pAsn1AlgId->parameters.value = abDerNULL;
    } else {
        pAsn1AlgId->parameters.length = pai->Parameters.cbData;
        pAsn1AlgId->parameters.value = pai->Parameters.pbData;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(PkiAsn1ToObjectIdentifierError,CRYPT_E_OID_FORMAT)
}


//+-------------------------------------------------------------------------
//  Convert an ASN1 AlgorithmIdentifier to an CRYPT_ALGORITHM_IDENTIFIER
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_Asn1FromAlgorithmIdentifier(
    IN AlgorithmIdentifier *pAsn1AlgId,
    OUT PCRYPT_ALGORITHM_IDENTIFIER pai)
{
    DWORD   cbObjId;
    BOOL    fRet;

    cbObjId = 0;
    if (!PkiAsn1FromObjectIdentifier(
            pAsn1AlgId->algorithm.count,
            pAsn1AlgId->algorithm.value,
            NULL,
            &cbObjId))
        goto PkiAsn1FromObjectIdentifierSizeError;
    pai->pszObjId = (LPSTR)ICM_Alloc( cbObjId);
    if (!PkiAsn1FromObjectIdentifier(
            pAsn1AlgId->algorithm.count,
            pAsn1AlgId->algorithm.value,
            pai->pszObjId,
            &cbObjId))
        goto PkiAsn1FromObjectIdentifierError;
    if (pAsn1AlgId->bit_mask & parameters_present) {
        pai->Parameters.cbData = pAsn1AlgId->parameters.length;
        pai->Parameters.pbData = (PBYTE)pAsn1AlgId->parameters.value;
    } else {
        pai->Parameters.cbData = 0;
        pai->Parameters.pbData = NULL;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(PkiAsn1FromObjectIdentifierSizeError)
TRACE_ERROR(PkiAsn1FromObjectIdentifierError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\tools\bin264\bin264.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       fdecrypt.cpp
//
//  Contents:   File Decryption tool. Decrypts a file looking in the MY
//              system certificate store for private keys.
//
//--------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <wincrypt.h>

//+-------------------------------------------------------------------------
//  Display Bin264 usage.
//--------------------------------------------------------------------------
void
Usage(void)
{
    printf("Usage: Bin264 <Binary File> <Base64 Encoded File> \n");
    exit(1);
}

//+-------------------------------------------------------------------------
//  Generalized error routine
//--------------------------------------------------------------------------
#define PRINTERROR(psz, err)	_PrintError((psz), (err), __LINE__)
void
_PrintError(char *pszMsg, DWORD err, DWORD line)
{
    printf("%s failed on line %u: (%x)\n", pszMsg, line, err);
}

//+-------------------------------------------------------------------------
//  Main program. Open a file to decyrpt,
//  decrypts it and then writes the clear text
//  file out.
//--------------------------------------------------------------------------
int __cdecl
main(int argc, char * argv[])
{

    DWORD		dwExitValue	    = 0;
    DWORD		err		    = ERROR_SUCCESS;
    DWORD		cb		    = 0;

    HANDLE hFileOut                         = INVALID_HANDLE_VALUE;
    HANDLE hFile                            = INVALID_HANDLE_VALUE;
    DWORD  cbFile                           = 0;
    HANDLE hMap                             = NULL;
    PBYTE  pbFile                           = NULL;

    PBYTE  pbBase64			    = NULL;
    DWORD  cchBase64			    = 0;

    // must have the parameters
    if(argc != 3)
        Usage();

    // Read in the file.
    if(

        // open the file to decrypt
        (hFile =  CreateFileA(
            argv[1],	            // pointer to name of the file
            GENERIC_READ,	        // access (read-write) mode
            FILE_SHARE_READ,	    // share mode
            NULL,	                // pointer to security descriptor
            OPEN_EXISTING,	        // how to create
            FILE_ATTRIBUTE_NORMAL,	// file attributes
            NULL                    // handle to file with attributes to copy
            ))  == INVALID_HANDLE_VALUE     ||

        // create a file mapping object
        (hMap = CreateFileMapping(
            hFile,	                // handle to file to map
            NULL,	                // optional security attributes
            PAGE_READONLY,	        // protection for mapping object
            0,	                    // high-order 32 bits of object size
            0,	                    // low-order 32 bits of object size
            NULL 	                // name of file-mapping object
            ))  == NULL                     ||

        // Map the file into the address space
        (pbFile = (PBYTE) MapViewOfFileEx(
            hMap,	                // file-mapping object to map into address space
            FILE_MAP_READ,	        // access mode
            0,	                    // high-order 32 bits of file offset
            0,	                    // low-order 32 bits of file offset
            0,	                    // number of bytes to map
            NULL 	                // suggested starting address for mapped view
            )) == NULL
        )
    {

        PRINTERROR("File Open", GetLastError());
        goto ErrCleanUp;
    }

    // get the size of the file
    if( (cbFile = GetFileSize(
            hFile,	                // handle of file to get size of
            NULL 	                // address of high-order word for file size
            )) == 0
        )
    {
        printf("File %s has a 0 length.\n", argv[2]);
        goto ErrCleanUp;
    }

    // at this point we have a file mapping, base64 encode the file


    if(!CryptBinaryToStringA(
		pbFile,
		cbFile,
                CRYPT_STRING_BASE64,
		NULL,
		&cchBase64)) {
        err = GetLastError();
	PRINTERROR("CryptBinaryToStringA", err);
	goto ErrCleanUp;
    }


    if( (pbBase64 = (PBYTE) malloc(cchBase64 * sizeof(char))) == NULL ) {
	PRINTERROR("malloc", ERROR_OUTOFMEMORY);
	goto ErrCleanUp;
    }

    if(!CryptBinaryToStringA(
		pbFile,
		cbFile,
                CRYPT_STRING_BASE64,
		(char *) pbBase64,
		&cchBase64)) {
        err = GetLastError();
	PRINTERROR("CryptBinaryToStringA", err);
	goto ErrCleanUp;
    }

    // write out the clear text file
    if(

        // open the output file
        (hFileOut =  CreateFileA(
            argv[2],	            // pointer to name of the file
	    GENERIC_WRITE,	    // access (read-write) mode
            FILE_SHARE_READ,	    // share mode
	    NULL,		    // pointer to security descriptor
	    CREATE_ALWAYS,	    // how to create
	    FILE_ATTRIBUTE_NORMAL,  //file attributes
            NULL                    // handle to file with attributes to copy
            ))  == INVALID_HANDLE_VALUE     ||

        //write to the decrypted data to the file
        !WriteFile(
            hFileOut,	            // handle to file to write to
	    pbBase64,		    // pointer to data to write to file
	    cchBase64 * sizeof(char),// number of bytes to write
	    &cb,		    // pointer to number of bytes written
	    NULL		    // pointer to structure needed for overlapped I/O
            )
        )
     {
        PRINTERROR("File Write", GetLastError());
        goto ErrCleanUp;
     }


    CleanUp:

        if(hMap != NULL)
            CloseHandle(hMap);

        if(hFile != INVALID_HANDLE_VALUE && hFile != NULL)
            CloseHandle(hFile);

        if(hFileOut != INVALID_HANDLE_VALUE && hFile != NULL)
            CloseHandle(hFileOut);

	if(pbBase64 != NULL)
	    free(pbBase64);

    return(dwExitValue);

    ErrCleanUp:
        dwExitValue = 1;
        goto CleanUp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\tools\pesigmgr\pesigmgr.cxx ===
/*++

Copyright (C) 1995-96  Microsoft Corporation

Module Name:

    certify.cxx

Abstract:

    This is the command line tool to manipulate certificates on an executable image.

Author:  Robert Reichel (robertre)   Feb 12, 1996

Revision History:



--*/

//#define UNICODE 1
//#define _UNICODE 1


#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include <malloc.h>

//
// Private prototypes
//

LPWIN_CERTIFICATE
GetCertFromImage(
    LPCTSTR ImageName,
    DWORD Index
    );

SaveCertificate(
    LPCTSTR OutputFileName,
    LPCTSTR ImageName,
    DWORD CertIndex
    );

BOOL
RemoveCertificateFromImage(
    LPCTSTR ImageName,
    DWORD Index
    );

BOOL
AddCertificateToImage(
    LPCTSTR ImageName,
    LPCTSTR CertificateName,
    WORD CertificateType,
    PDWORD Index
    );

VOID
PrintCertificate(
    LPWIN_CERTIFICATE Certificate,
    DWORD Index
    );

BOOL
GetCertHeaderFromImage(
    IN LPCTSTR ImageName,
    IN DWORD Index,
    OUT LPWIN_CERTIFICATE CertificateHeader
    );

#define TYPE_X509  TEXT("X509")
#define TYPE_PKCS7 TEXT("PKCS7")
#define TYPE_UNKNOWN TEXT("Unknown")

//
// Globals
//

BOOL fVerbose = FALSE;

void
PrintUsage(
    VOID
    )
{
    fputs("Usage: PESIGMGR [switches] image-name \n"
          "            [-?] display this message\n"
          "            [-l] list the certificates in an image\n"
          "            [-a:<Filename>] add a certificate file to an image\n"
          "            [-r:<index>]    remove certificate <index> from an image\n"
          "            [-s:<Filename>] used with -r to save the removed certificate\n"
          "            [-t:<CertType>] used with -a to specify the type of the certificate\n"
          "            where CertType may be X509 or PKCS7 [default is X509]\n",
          stderr
         );
    exit(-1);
}

#if 0

PWSTR
GetArgAsUnicode(
    LPSTR s
    )
{
    ULONG n;
    PWSTR ps;

    n = strlen( s );
    ps = (PWSTR)HeapAlloc( GetProcessHeap(),
                    0,
                    (n + 1) * sizeof( WCHAR )
                  );
    if (ps == NULL) {
        printf( "Out of memory\n" );
        }

    if (MultiByteToWideChar( CP_ACP,
                             MB_PRECOMPOSED,
                             s,
                             n,
                             ps,
                             n
                           ) != (LONG)n
       ) {
        printf( "Unable to convert parameter '%s' to Unicode (%u)", (ULONG)s, GetLastError() );
        }

    ps[ n ] = UNICODE_NULL;
    return ps;
}

#endif


int __cdecl
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    BOOL AFlagSeen = FALSE;
    BOOL LFlagSeen = FALSE;
    BOOL RFlagSeen = FALSE;
    BOOL SFlagSeen = FALSE;
    BOOL TFlagSeen = FALSE;
    BOOL Result;

    DWORD Index;
    DWORD RFlag_CertIndex;
    WORD CertificateType = WIN_CERT_TYPE_PKCS_SIGNED_DATA;  // default

    char * CertificateName;
    char * ImageName = NULL;
    char * SFlag_CertificateFile;
    char c, *p;



    if (argc < 2) {
        PrintUsage();
    }

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            c = *++p;
            switch (toupper( c )) {
                case '?':
                    PrintUsage();
                    break;

                case 'A':  // Add Certificate to image
                    c = *++p;
                    if (c != ':') {
                        PrintUsage();
                    } else {

                        if (AFlagSeen == TRUE) {
                            PrintUsage();
                            return( 0 );
                        }

                        AFlagSeen = TRUE;
                        CertificateName = ++p;
                    }
                    break;
                case 'V':
                    {
                        fVerbose = TRUE;
                        break;
                    }

                case 'T':
                    {
                        //
                        // Specify the Type of the certificate
                        //
                        c = *++p;
                        if (c != ':') {
                            PrintUsage();
                        } else {

                            if (TFlagSeen == TRUE) {
                                PrintUsage();
                                return( 0 );
                            }

                            TFlagSeen = TRUE;
                            ++p;

                            if (_stricmp(p, TYPE_X509) == 0) {
                                CertificateType = WIN_CERT_TYPE_X509;
                                if (fVerbose) {
                                    printf("Certificate type = X509\n");
                                }
                            } else {
                                if (_stricmp(p, TYPE_PKCS7) == 0) {
                                    CertificateType = WIN_CERT_TYPE_PKCS_SIGNED_DATA;
                                    if (fVerbose) {
                                        printf("Certificate type = PKCS7\n");
                                    }
                                } else {
                                    if (fVerbose) {
                                        printf("Unrecognized Certificate type %s\n",p);
                                    }
                                    PrintUsage();
                                    return (0);
                                }
                            }
                        }
                        break;
                    }

                case 'L':  // List the certificates in an image.
                    {
                        if (LFlagSeen == TRUE) {
                            PrintUsage();
                            return( 0 );
                        }

                        LFlagSeen = TRUE;
    
                        break;
                    }

                case 'R': // Remove certificate from an image
                    {
                        c = *++p;
                        if (c != ':') {
                            PrintUsage();
                        } else {
    
                            if (RFlagSeen == TRUE) {
                                PrintUsage();
                                return( 0 );
                            }
    
                            RFlagSeen = TRUE;
    
                            //
                            // Save the index
                            //
    
                            RFlag_CertIndex = atoi(++p);
                        }
    
                        break;
                    }

                case 'G':
                    c = *++p;
                    if (c != ':') {
                        PrintUsage();
                    } else {
                        // Generate a certificate from an image.
                    }
                    break;

                case 'S': // Save the certificate
                    c = *++p;
                    if (c != ':') {
                        PrintUsage();
                    } else {

                        if (SFlagSeen == TRUE) {
                            PrintUsage();
                            return( 0 );
                        }

                        SFlagSeen = TRUE;

                        //
                        // Save the name of the file to put the cert into.
                        //

                        SFlag_CertificateFile = ++p;
                    }
                    break;

                default:
                    fprintf( stderr, "CERTIFY: Invalid switch - /%c\n", c );
                    PrintUsage();
                    break;
            }

        } else {

            //
            // Should only be a single image name here
            //

            if (ImageName != NULL) {
                PrintUsage();
                return( 0 );
            }

            ImageName = *argv;
        }
    }

    //
    // Finished processing parameters, let's do the work.
    //

    if (ImageName == NULL) {
        if (fVerbose) {
            printf("Image name not specified\n");
        }
        PrintUsage();
        return(0);
    }

    if (LFlagSeen) {

        int Index = 0;
		WIN_CERTIFICATE Certificate;

        if (SFlagSeen || RFlagSeen || AFlagSeen) {
            PrintUsage();
            return(0);
        }

        do {

            Result = GetCertHeaderFromImage( ImageName, Index, &Certificate );

            if (Result) {
                PrintCertificate( &Certificate, Index );
            }

            Index++;

        } while ( Result  );
		return( 1 );
    }

    if (AFlagSeen) {

        //
        // 'A' is not used in conjunction with R or S
        //

        if (SFlagSeen || RFlagSeen) {
            PrintUsage();
            return( 0 );
        }

        Result = AddCertificateToImage(
                     ImageName,
                     CertificateName,
                     CertificateType,
                     &Index
                     );

        if (Result) {
			if (fVerbose){
				printf("Certificate %d added\n",Index);
			}

            return( 1 );
        } else {

            if (fVerbose) {
                printf("Unable to add Certificate to %s, error = %d\n",ImageName,GetLastError());
            }
            return( 0 );
        }
    }

    if (RFlagSeen) {

        if (!SFlagSeen) {
            if (fVerbose) {
                fputs("-R requires -S\n",stderr);
            }
           PrintUsage();
           return(0);
        }

        //
        // Make sure we can save the certificate data before
        // we remove it from the image
        //

        Result = SaveCertificate(
                     SFlag_CertificateFile,
                     ImageName,
                     RFlag_CertIndex
                     );

        if (!Result) {
            if (fVerbose) {
                printf("Unable to save certificate to file %s, error = %d\n",SFlag_CertificateFile,GetLastError());
            }
            return(0);
        }

        //
        // Now that the certificate is safe, remove it from the image
        //

        Result = RemoveCertificateFromImage(
                    ImageName,
                    RFlag_CertIndex
                    );

        if (!Result) {
            if (fVerbose) {
                printf("Unable to remove certificate, error = %d\n",GetLastError());
            }
            return(0);
        }
    }

    if (SFlagSeen && !RFlagSeen) {
        PrintUsage();
        return( 0 );
    }

    return 0;
}


VOID
PrintCertificate(
    LPWIN_CERTIFICATE Certificate,
    DWORD Index
    )
{
    char * CertType;

    switch (Certificate->wCertificateType) {
        case WIN_CERT_TYPE_X509:
            {
                CertType = TYPE_X509;
                break;
            }
        case WIN_CERT_TYPE_PKCS_SIGNED_DATA:
            {

                CertType = TYPE_PKCS7;
                break;
            }
        default:
            {
                CertType = TYPE_UNKNOWN;
                break;
            }
    }

    printf("\nCertificate %3d Revision %1d Type %8s",Index,Certificate->wRevision, CertType);

    return;
}


BOOL
AddCertificateToImage(
    IN LPCTSTR ImageName,
    IN LPCTSTR CertificateName,
    IN WORD CertificateType,
    OUT PDWORD Index
    )
/*++

Routine Description:

    Adds a certificate to an image, and returns its index.

Arguments:

    ImageName - Provides the full name and path to the image to be 
        modified.

    CertificateName - Provides the full name and path to a file containing 
        the certificate to be added to the image.

    CertificateType - Provides the type of the certificate being added.  
        This type will be placed in the dwType field of the resulting 
        WIN_CERTIFICATE structure.

    Index - Returns the index of the certificate after it is placed in the 
        image.


Return Value:

    TRUE on success, FALSE on failure.  More information is available via 
        GetLastError().

--*/
{
    HANDLE CertificateHandle;
    DWORD CertificateFileSize;
    DWORD CertificateSize;
    LPWIN_CERTIFICATE Certificate = NULL;
    BOOL Result = FALSE;
    HANDLE ImageHandle;
    DWORD BytesRead;

    //
    // Attempt to open the certificate file
    //

    if ((CertificateHandle = CreateFile(CertificateName,
                                        GENERIC_READ,
                                        0,
                                        0,
                                        OPEN_EXISTING,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL)) == INVALID_HANDLE_VALUE)
    {
        if (fVerbose) {
            printf("Unable to open %s, error = %d\n",CertificateName,GetLastError());
        }
        goto ErrorReturn;
    }

    //
    // Read the certificate data into memory
    //

    CertificateFileSize = GetFileSize( CertificateHandle, NULL );
    CertificateSize = CertificateFileSize + (sizeof( WIN_CERTIFICATE ) - sizeof( BYTE ));

    //
    // Hack to make certs 8 byte aligned
    //

//    CertificateSize += (8 - (CertificateSize % 8));

    Certificate = (LPWIN_CERTIFICATE)malloc( CertificateSize );
    if (NULL == Certificate) {
        if (fVerbose) {
            printf("malloc failed\n");
        }
        goto ErrorReturn;
    }

    Certificate->dwLength = CertificateSize;
    Certificate->wRevision = WIN_CERT_REVISION_1_0;
    Certificate->wCertificateType = CertificateType;
    Result = ReadFile( CertificateHandle,
                       &Certificate->bCertificate,
                       CertificateFileSize,
                       &BytesRead,
                       NULL                // Overlapped
                       );

    if (!Result) {
        if (fVerbose) {
            printf("Unable to read Certificate file, error = %d\n",GetLastError());
        }
        goto ErrorReturn;
    }

    ImageHandle = CreateFile( ImageName,
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              0,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL
                              );

    if (ImageHandle == INVALID_HANDLE_VALUE) {
        if (fVerbose) {
            printf("Unable to open image file %s, error = %d\n",ImageName,GetLastError());
        }
        goto ErrorReturn;
    }

    Result = ImageAddCertificate( ImageHandle,
                                  Certificate,
                                  Index
                                  );

    if (!Result) {
        if (fVerbose) {
            printf("ImageAddCertificate failed, error = %d\n",GetLastError());
        }
        goto ErrorReturn;
    }

CommonReturn:
    if (Certificate)
        free(Certificate);

    return( Result );

ErrorReturn:
    Result = FALSE;
    goto CommonReturn;
}

BOOL
GetCertHeaderFromImage(
    IN LPCTSTR ImageName,
    IN DWORD Index,
    OUT LPWIN_CERTIFICATE CertificateHeader
    )
{
    HANDLE ImageHandle;
    BOOL Result;

    ImageHandle = CreateFile( ImageName,
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              0,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL
                              );

    if (ImageHandle == INVALID_HANDLE_VALUE) {
        if (fVerbose) {
            printf("Unable to open image file %s\n",ImageName);
        }
        return( FALSE );
    }

    Result = ImageGetCertificateHeader(
                 ImageHandle,
                 Index,
                 CertificateHeader
                 );

    CloseHandle( ImageHandle );

    if (!Result) {
        if (fVerbose) {
            printf("\nUnable to retrieve certificate header from %s, index=%d, error = %d\n",ImageName,Index,GetLastError());
        }
        return( FALSE );
    }

    return( TRUE );

}

LPWIN_CERTIFICATE
GetCertFromImage(
    IN LPCTSTR ImageName,
    IN DWORD Index
    )

/*++

Routine Description:

    Returns a copy of the specified certificate.

Arguments:

    ImageName - Provides the full path to the image file containing the 
        certificate.

    Index - Provides the index of the desired certificate in the image.

Return Value:

    NULL on failure.

    On Success, returns a pointer to a filled in WIN_CERTIFICATE 
        structure, which may be freed by called free().


--*/

{
    HANDLE ImageHandle;
    LPWIN_CERTIFICATE Certificate;
    DWORD RequiredLength = 0;
    BOOL Result;

    ImageHandle = CreateFile( ImageName,
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              0,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL
                              );

    if (ImageHandle == INVALID_HANDLE_VALUE) {
        if (fVerbose) {
            printf("Unable to open image file %s\n",ImageName);
        }
        return( NULL );
    }

    Result = ImageGetCertificateData(
                 ImageHandle,
                 Index,
                 NULL,
                 &RequiredLength
                 );

    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) {
        if (fVerbose) {
            printf("Unable to retrieve certificate data from %s, error = %d\n",ImageName,GetLastError());
        }
        return(NULL);
    }

    Certificate = (LPWIN_CERTIFICATE) malloc( RequiredLength );

    if (Certificate == NULL) {
        if (fVerbose) {
            printf("Out of memory in GetCertFromImage\n");
        }
        return( NULL );
    }

    Result = ImageGetCertificateData(
                 ImageHandle,
                 Index,
                 Certificate,
                 &RequiredLength
                 );

    CloseHandle( ImageHandle );

    if (!Result) {
        if (fVerbose) {
            printf("Unable to retrieve certificate from %s, error = %d\n",ImageName,GetLastError());
        }
        return( NULL );
    }

    return( Certificate );
}


BOOL
RemoveCertificateFromImage(
    LPCTSTR ImageName,
    DWORD Index
    )
{
    HANDLE ImageHandle;
    BOOL Result;

    if (fVerbose) {
        printf("Removing certificate index %d from %s\n",Index,ImageName);
    }

    ImageHandle = CreateFile( ImageName,
                              GENERIC_READ | GENERIC_WRITE,
                              0,
                              0,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL
                              );

    if (ImageHandle == INVALID_HANDLE_VALUE) {
        printf("Unable to open image file %s\n",ImageName);
        return( FALSE );
    }

    Result = ImageRemoveCertificate(
                 ImageHandle,
                 Index
                 );

    if (!Result) {
        printf("Unable to remove certificate from %s, error = %d\n",ImageName,GetLastError());
        return( FALSE );
    }

    CloseHandle( ImageHandle );

    return( TRUE );

}

BOOL
SaveCertificate(
    LPCTSTR OutputFileName,
    LPCTSTR ImageName,
    DWORD CertIndex
    )
{
    DWORD Length;
    BOOL Result;
    DWORD BytesWritten = 0;
    LPWIN_CERTIFICATE Certificate;
    HANDLE CertificateHandle;

    Certificate = GetCertFromImage( ImageName, CertIndex );

    if (Certificate == NULL) {
        if (fVerbose) {
            printf("Unable to retrieve certificate from %s, error = %d\n",ImageName,GetLastError());
        }
        return( FALSE );
    }

    Length = Certificate->dwLength - sizeof( WIN_CERTIFICATE ) + sizeof( BYTE );

    //
    // Attempt to open the certificate file
    //

    if ((CertificateHandle = CreateFile(OutputFileName,
                                        GENERIC_WRITE,
                                        0,
                                        0,
                                        CREATE_ALWAYS,
                                        FILE_ATTRIBUTE_NORMAL,
                                        NULL)) == INVALID_HANDLE_VALUE)
    {
        printf("Unable to create %s, error = %d\n",OutputFileName,GetLastError());
        return( FALSE );
    }

    Result = WriteFile( CertificateHandle,
                        &Certificate->bCertificate,
                        Length,
                        &BytesWritten,
                        NULL                // Overlapped
                        );

    if (!Result) {
        printf("Unable to save certificate to file %s, error = %d\n",OutputFileName,GetLastError());
        return( FALSE );
    }

    CloseHandle( CertificateHandle );

    free( Certificate );

    return( TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\tools\fdecrypt\fdecrypt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       fdecrypt.cpp
//
//  Contents:   File Decryption tool. Decrypts a file looking in the MY
//              system certificate store for private keys.
//
//--------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>
#include "wincrypt.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>

//+-------------------------------------------------------------------------
//  Helper function to allocated the output buffer 
//  and call CryptDecryptMessage.
//--------------------------------------------------------------------------
BOOL
WINAPI
MCryptDecryptMessage(
    IN PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
    IN const BYTE *pbEncryptedBlob,
    IN DWORD cbEncryptedBlob,
    OUT OPTIONAL BYTE ** ppbDecrypted,
    IN OUT OPTIONAL DWORD *pcbDecrypted,
    OUT OPTIONAL PCCERT_CONTEXT *ppXchgCert
    )
{
    
    assert(ppbDecrypted != NULL);
    *ppbDecrypted = NULL;

    assert(pcbDecrypted != NULL);
    *pcbDecrypted = 0;

    // get the size
    if(!CryptDecryptMessage(
            pDecryptPara,
            pbEncryptedBlob,
            cbEncryptedBlob,
            NULL,
            pcbDecrypted,
            NULL
            ))
        return(FALSE);
    
    // allocate the buffer
    if( (*ppbDecrypted = (BYTE *) malloc(*pcbDecrypted)) == NULL ) 
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }
    
    // Decrypt the data
    if(!CryptDecryptMessage(
            pDecryptPara,
            pbEncryptedBlob,
            cbEncryptedBlob,
            *ppbDecrypted,
            pcbDecrypted,
            ppXchgCert)) 
    {
        free(*ppbDecrypted);
        *ppbDecrypted = NULL;
        *pcbDecrypted = 0;
        return(FALSE);
    }
        
    return(TRUE);
}

//+-------------------------------------------------------------------------
//  Display FDecrypt usage.
//--------------------------------------------------------------------------
void
Usage(void)
{
    printf("Usage: FDecrypt [options] <EncryptedFileName> <ClearTextFileName> \n");
    printf("Options are:\n");
    printf("  -FIX          - Fix by loading sp3crmsg.dll\n");
    exit(1);
}

//+-------------------------------------------------------------------------
//  Generalized error routine
//--------------------------------------------------------------------------
#define PRINTERROR(psz, err)	_PrintError((psz), (err), __LINE__)
void
_PrintError(char *pszMsg, DWORD err, DWORD line)
{
    printf("%s failed on line %u: %u(%x)\n", pszMsg, line, err, err);
}

//+-------------------------------------------------------------------------
//  Main program. Open a file to decyrpt,
//  decrypts it and then writes the clear text
//  file out.
//--------------------------------------------------------------------------
int __cdecl
main(int argc, char * argv[])
{

    DWORD               dwExitValue         = 0;
    DWORD               i, j;
    
    HCERTSTORE          hMyStore            = NULL;
    
    HANDLE hFileOut                         = INVALID_HANDLE_VALUE;
    HANDLE hFile                            = INVALID_HANDLE_VALUE;
    DWORD  cbFile                           = 0;
    HANDLE hMap                             = NULL;
    PBYTE  pbFile                           = NULL;

    PBYTE  pbDecryptedBlob                  = NULL;
    DWORD  cbDecryptedBlob                  = 0;
    
    CRYPT_DECRYPT_MESSAGE_PARA    decryptInfo;
    DWORD               cb                  = 0;

    HMODULE hDll = NULL;
    BOOL fFix = FALSE;

    // Advance past fdencrypt.exe and check for leading options
    while (--argc > 0) {
        if (**++argv != '-')
            break;

        if (0 == _stricmp(argv[0], "-FIX"))
            fFix = TRUE;
        else {
            printf("Bad option: %s\n", argv[0]);
            Usage();
        }
    }
    
    // must have the parameters
    if(argc != 2)
        Usage();

    if (fFix) {
        if (NULL == (hDll = LoadLibraryA("sp3crmsg.dll"))) 
        {
            PRINTERROR("LoadLibraryA(sp3crmsg.dll)", GetLastError());
            goto ErrCleanUp;
        }
    }

    // Open the MY store
    if( (hMyStore = CertOpenSystemStore(NULL, "My")) == NULL ) 
    {
        PRINTERROR("CertOpenSystemStore", GetLastError());
        goto ErrCleanUp;
    }

    // Read in the file.
    if(
    
        // open the file to decrypt
        (hFile =  CreateFileA(
            argv[0],	            // pointer to name of the file 
            GENERIC_READ,	        // access (read-write) mode 
            FILE_SHARE_READ,	    // share mode 
            NULL,	                // pointer to security descriptor 
            OPEN_EXISTING,	        // how to create 
            FILE_ATTRIBUTE_NORMAL,	// file attributes 
            NULL                    // handle to file with attributes to copy
            ))  == INVALID_HANDLE_VALUE     ||

        // create a file mapping object         
        (hMap = CreateFileMapping(
            hFile,	                // handle to file to map 
            NULL,	                // optional security attributes 
            PAGE_READONLY,	        // protection for mapping object 
            0,	                    // high-order 32 bits of object size  
            0,	                    // low-order 32 bits of object size  
            NULL 	                // name of file-mapping object 
            ))  == NULL                     ||

        // Map the file into the address space
        (pbFile = (PBYTE) MapViewOfFileEx(
            hMap,	                // file-mapping object to map into address space  
            FILE_MAP_READ,	        // access mode 
            0,	                    // high-order 32 bits of file offset 
            0,	                    // low-order 32 bits of file offset 
            0,	                    // number of bytes to map 
            NULL 	                // suggested starting address for mapped view 
            )) == NULL                                 
        ) 
    {

        PRINTERROR("File Open", GetLastError());
        goto ErrCleanUp;
    }

    // get the size of the file         
    if( (cbFile = GetFileSize(
            hFile,	                // handle of file to get size of
            NULL 	                // address of high-order word for file size
            )) == 0 
        ) 
    {
        printf("File %s has a 0 length.\n", argv[0]);
        goto ErrCleanUp;
    }

    // at this point we have a file mapping, go ahead and decrypt the file
    
    // Initialize the decryption structure.
    // Since the MY store is the store with 
    // the private keys, only check the MY store
    memset(&decryptInfo, 0, sizeof(CRYPT_DECRYPT_MESSAGE_PARA));
    decryptInfo.cbSize = sizeof(CRYPT_DECRYPT_MESSAGE_PARA);
    decryptInfo.dwMsgAndCertEncodingType =
        PKCS_7_ASN_ENCODING | X509_ASN_ENCODING;
    decryptInfo.cCertStore                  = 1;
    decryptInfo.rghCertStore                = &hMyStore;

    // decrypt the data
    if(!MCryptDecryptMessage(
            &decryptInfo,
            pbFile,
            cbFile,
            &pbDecryptedBlob,
            &cbDecryptedBlob,
            NULL
            )
        )
    {
        PRINTERROR("MCryptEncryptMessage", GetLastError());
        goto ErrCleanUp;
    }

    // write out the clear text file
    if(
    
        // open the output file
        (hFileOut =  CreateFileA(
            argv[1],	            // pointer to name of the file 
            GENERIC_WRITE,	        // access (read-write) mode 
            FILE_SHARE_READ,	    // share mode 
            NULL,	                // pointer to security descriptor 
            CREATE_ALWAYS,	        // how to create 
            FILE_ATTRIBUTE_NORMAL,	// file attributes 
            NULL                    // handle to file with attributes to copy
            ))  == INVALID_HANDLE_VALUE     ||

        //write to the decrypted data to the file
        !WriteFile(
            hFileOut,	            // handle to file to write to 
            pbDecryptedBlob,	    // pointer to data to write to file 
            cbDecryptedBlob,	    // number of bytes to write 
            &cb,	                // pointer to number of bytes written 
            NULL 	                // pointer to structure needed for overlapped I/O
            )
        )
     {
        PRINTERROR("File Write", GetLastError());
        goto ErrCleanUp;
     }


    CleanUp:
        if(hDll)
            FreeLibrary(hDll);

        if(hMap != NULL)
            CloseHandle(hMap);
        
        if(hFile != INVALID_HANDLE_VALUE && hFile != NULL)
            CloseHandle(hFile);
            
        if(hFileOut != INVALID_HANDLE_VALUE && hFile != NULL)
            CloseHandle(hFileOut);

        if(hMyStore != NULL)
            CertCloseStore(hMyStore, 0);

        if(pbDecryptedBlob != NULL)
            free(pbDecryptedBlob);

    return(dwExitValue);

    ErrCleanUp:
        dwExitValue = 1;
        goto CleanUp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\wincrmsg\crmsgp.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       crmsgp.h
//
//  Contents:   Private Header for Cryptographic Message APIs
//
//  History:    12-Dec-96   kevinr    created
//
//--------------------------------------------------------------------------

#ifndef __WINCRMSG_P_INCLUDED__
#define __WINCRMSG_P_INCLUDED__

#if DBG
#define STATIC
#else
#define STATIC static
#endif

#ifndef OSS_CRYPT_ASN1
#define parameters_present AlgorithmIdentifier_parameters_present
#define unauthAttributes_present SignerInfo_unauthAttributes_present
#define certificates_present SignedData_certificates_present
#define crls_present SignedData_crls_present
#define date_present RecipientKeyIdentifier_date_present
#define other_present RecipientKeyIdentifier_other_present
#define content_present ContentInfo_content_present
#define authAttributes_present SignerInfoWithBlobs_authAttributes_present

#define issuerAndSerialNumber_chosen CertIdentifier_issuerAndSerialNumber_chosen
#define subjectKeyIdentifier_chosen CertIdentifier_subjectKeyIdentifier_chosen

#endif  // OSS_CRYPT_ASN1


#define INFO_LEN_ALIGN(Len)  ((Len + 7) & ~7)

#define STRUCT_CBSIZE(StructName, FieldName)   \
    (offsetof(StructName, FieldName) + sizeof(((StructName *) 0)->FieldName))

#define ICM_TAG_NULL            0x00
#define ICM_TAG_CONSTRUCTED     0x20
#define ICM_TAG_SEQ             0x30
#define ICM_TAG_SET             0x31
#define ICM_TAG_OCTETSTRING     0x04
#define ICM_TAG_NULL_OCTETS     0x05
#define ICM_TAG_CONTEXT_0       0x80
#define ICM_TAG_CONTEXT_1       0x81

#define ICM_TAG_CONSTRUCTED_CONTEXT_0     (ICM_TAG_CONSTRUCTED | ICM_TAG_CONTEXT_0)
#define ICM_TAG_CONSTRUCTED_CONTEXT_1     (ICM_TAG_CONSTRUCTED | ICM_TAG_CONTEXT_1)

#define ICM_LENGTH_INDEFINITE   0x80


// Streaming flags
#define ICMS_QUEUE_OUTPUT_FLAG  0x80000000


typedef struct _SIMPLEBLOBHEADER {
    ALG_ID  aiEncAlg;
} SIMPLEBLOBHEADER, *PSIMPLEBLOBHEADER;

#define SIZE_OSS_OID    16

extern ObjectID aoidMessages[];

extern const CRYPT_OBJID_TABLE aotSign[];
extern const DWORD COUNTOF_aotSign;

extern const LPSTR apszObjIdPKCS7[];
extern const DWORD COUNTOF_apszObjIdPKCS7;

extern const CRYPT_OBJID_TABLE aotContentEncryption[];
extern const DWORD COUNTOF_aotContentEncryption;

extern const LPSTR pszObjIdDataType;
extern const LPSTR pszObjIdContentType;
extern const LPSTR pszObjIdMessageDigest;

#define INVALID_ENCODING_SIZE (0xFFFFFFFE)

#define ZEROSTRUCT(arg) (memset( &arg, 0, sizeof(arg)))

typedef struct _ICM_BUFFER {
    PBYTE   pbData;
    DWORD   cbSize;
    DWORD   cbUsed;
    DWORD   cbDead;
} ICM_BUFFER, *PICM_BUFFER;

#define ICM_BUFFER_SIZE_INCR    1024

void *
WINAPI
ICM_Alloc(
    IN size_t cbBytes);

void *
WINAPI
ICM_AllocZero(
    IN size_t cb);

void *
WINAPI
ICM_ReAlloc(
    IN void     *pvOrg,
    IN size_t   cb);

void
WINAPI
ICM_Free(
    IN void *pv);

BOOL
WINAPI
ICM_AppendBlob(
    PCRYPT_DATA_BLOB    pblob,
    const BYTE          *pbIn,
    DWORD               cbIn);

BOOL
WINAPI
ICM_CopyOssObjectIdentifier(
    OUT ObjectID    *poiDst,
    IN  ObjectID    *poiSrc);


typedef struct _CONTENT_INFO {
    LPSTR           pszContentType;
    CRYPT_DATA_BLOB content;
} CONTENT_INFO, *PCONTENT_INFO;

class CHashList;
class CBlobList;
class CSignerList;
class COssDecodeInfoList;

#ifdef CMS_PKCS7
class CHashNode;
typedef struct _SIGNER_ENCODE_DATA_INFO {
    HCRYPTPROV          hCryptProv;
    DWORD               dwKeySpec;
    CHashNode           *pHashNode;
} SIGNER_ENCODE_DATA_INFO, *PSIGNER_ENCODE_DATA_INFO;
#endif  // CMS_PKCS7

typedef struct _SIGNED_DATA_INFO {
    int             version;
    CBlobList       *pAlgidList;
    PCONTENT_INFO   pci;
    CBlobList       *pCertificateList;
    CBlobList       *pCrlList;
    CSignerList     *pSignerList;
} SIGNED_DATA_INFO, *PSIGNED_DATA_INFO;

typedef struct _CRYPT_MSG_INFO {
    CRITICAL_SECTION    CriticalSection;
    LONG                lRefCnt;
    HCRYPTPROV          hCryptProv;             // decode
    BOOL                fDefaultCryptProv;      // decode
    DWORD               dwKeySpec;              // key to use in CryptSignHash
    DWORD               dwEncodingType;         // encode
    DWORD               dwMsgType;
    DWORD               dwFlags;
    VOID                *pvMsg;
    BOOL                fEncoding;
    DWORD               dwPhase;
    LPSTR               pszInnerContentObjID;
    // signed or signed-and-enveloped
    PSIGNED_DATA_INFO   psdi;
    // signed, digested or signed-and-enveloped
    BOOL                fDetached;
    CHashList           *pHashList;
#ifdef CMS_PKCS7
    // encode signed
    DWORD               cSignerEncodeDataInfo;
    PSIGNER_ENCODE_DATA_INFO rgSignerEncodeDataInfo;
#endif  // CMS_PKCS7
    // enveloped or signed-and-enveloped
    HCRYPTKEY           hkeyContentCrypt;
    HCRYPTPROV          hCryptProvContentCrypt;
    CRYPT_DATA_BLOB     Plaintext;
    DWORD               dwDecryptedRecipientIndex;
#ifdef CMS_PKCS7
    DWORD               dwDecryptedRecipientEncryptedKeyIndex;
#endif  // CMS_PKCS7
#ifndef CMS_PKCS7
    PBYTE               pbEncryptParameters;        // encoded and allocated
#endif  // CMS_PKCS7
    // streaming
    PCMSG_STREAM_INFO   pStreamInfo;
    DWORD               aflStream;
    DWORD               aflDecode;
    BOOL                fStreamCallbackOutput;
    BOOL                fStreamContentExtracted;
    ICM_BUFFER          bufDecode;
    ICM_BUFFER          bufEncode;
    ICM_BUFFER          bufOutput;
    ICM_BUFFER          bufCrypt;
    ICM_BUFFER          bufPendingCrypt;
    DWORD               cbBlockSize;
    BOOL                fBlockCipher;
    DWORD               cEndNullPairs;          // decode
    DWORD               cInnerNullPairs;        // decode
    DWORD               cLevelIndefiniteInner;  // decode
    DWORD               cbDefiniteRemain;       // decode
    DWORD               cbContentInfo;          // decode
    ObjectIdentifierType *pooid;                // decode
    DWORD               aflOuter;               // decode
    DWORD               aflInner;               // decode
    COssDecodeInfoList  *plDecodeInfo;          // decode

#ifdef CMS_PKCS7
    // Optional OriginatorInfo for decoded CMS EnvelopedData
    CBlobList           *pCertificateList;
    CBlobList           *pCrlList;

    // Misc allocations, such as, Algorithm parameters
    CBlobList           *pFreeList;
#endif  // CMS_PKCS7

} CRYPT_MSG_INFO, *PCRYPT_MSG_INFO;


//--------------------------------------------------------------------------
// Decoding progress flags
#define ICMS_DECODED_PREFIX                 0x00000001
#define ICMS_DECODED_CONTENT_START          0x00000002
#define ICMS_DECODED_CONTENT                0x00000004
#define ICMS_DECODED_SUFFIX                 0x00000008

#define ICMS_DECODED_CONTENTINFO_SEQ        0x00000010
#define ICMS_DECODED_CONTENTINFO_CONTENT    0x00000020
//#define ICMS_DECODED_                       0x00000040
//#define ICMS_DECODED_                       0x00000080

// Signed
#define ICMS_DECODED_SIGNED_SEQ             0x00000100
#define ICMS_DECODED_SIGNED_VERSION         0x00000200
#define ICMS_DECODED_SIGNED_DIGESTALGOS     0x00000400
#define ICMS_DECODED_SIGNED_CONTENTINFO     0x00000800
#define ICMS_DECODED_SIGNED_CERTIFICATES    0x00001000
#define ICMS_DECODED_SIGNED_CRLS            0x00002000
#define ICMS_DECODED_SIGNED_SIGNERINFOS     0x00004000
//#define ICMS_DECODED_                       0x00008000

// Enveloped
#define ICMS_DECODED_ENVELOPED_SEQ          0x00000100
#define ICMS_DECODED_ENVELOPED_VERSION      0x00000200
#define ICMS_DECODED_ENVELOPED_RECIPINFOS   0x00000400
#define ICMS_DECODED_ENVELOPED_ECISEQ       0x00000800
#define ICMS_DECODED_ENVELOPED_ECITYPE      0x00001000
#define ICMS_DECODED_ENVELOPED_ECIALGID     0x00002000
#define ICMS_DECODED_ENVELOPED_ECICONTENT   0x00004000
#ifdef CMS_PKCS7
#define ICMS_DECODED_ENVELOPED_ORIGINATOR   0x00008000
#define ICMS_DECODED_ENVELOPED_ATTR         0x00010000
#endif  // CMS_PKCS7
//#define ICMS_DECODED_                       0x00020000

// Misc flags
#define ICMS_INNER_OCTETSTRING              0x00100000
#define ICMS_FINAL                          0x00200000
#define ICMS_NONBARE                        0x00400000
#define ICMS_RAW_DATA                       0x00800000
#define ICMS_PROCESS_CONTENT_BEGUN          0x01000000
#define ICMS_PROCESS_CONTENT_DONE           0x02000000


// Used in streaming decode parsing
#define ICMS_TOKEN_INDEFINITE           1
#define ICMS_TOKEN_NULLPAIR             2
#define ICMS_TOKEN_DEFINITE             3
#define ICMS_TOKEN_INCOMPLETE           4


#if DBG
#define CMSGP_STREAM_CRYPT_BLOCK_COUNT         1
#else
#define CMSGP_STREAM_CRYPT_BLOCK_COUNT       128
#endif
#define CMSGP_STREAM_MAX_ENCRYPT_BUFFER     1024


typedef struct _OSS_DECODE_INFO {
    int         iPDU;
    PVOID       pvPDU;
} OSS_DECODE_INFO, *POSS_DECODE_INFO;

DEFINE_LIST_AND_NODE_CLASS( COssDecodeInfoList, COssDecodeInfoNode, OSS_DECODE_INFO);


DEFINE_LIST_AND_NODE_CLASS( CBlobList, CBlobNode, CRYPT_DATA_BLOB);


typedef struct _SIGNER_DATA_INFO {
    CRYPT_DATA_BLOB     blob;
    CBlobList           *pUnauthAttrList;
} SIGNER_DATA_INFO, *PSIGNER_DATA_INFO;

DEFINE_LIST_AND_NODE_CLASS( CSignerList, CSignerNode, SIGNER_DATA_INFO);

typedef struct _ICM_HASH_INFO {
#ifndef CMS_PKCS7
    HCRYPTPROV          hCryptProv;
#endif  // CMS_PKCS7
    DWORD               dwAlgoCAPI;
    HCRYPTHASH          hHash;
    CRYPT_HASH_BLOB     HashBlob;
} ICM_HASH_INFO, *PICM_HASH_INFO;

DEFINE_LIST_AND_NODE_CLASS( CHashList, CHashNode, ICM_HASH_INFO);


extern HCRYPTASN1MODULE  ICM_hAsn1Module;
__inline ASN1encoding_t ICM_GetEncoder(void)
{
    return I_CryptGetAsn1Encoder(ICM_hAsn1Module);
}
__inline ASN1decoding_t ICM_GetDecoder(void)
{
    return I_CryptGetAsn1Decoder(ICM_hAsn1Module);
}

BOOL
WINAPI
ICM_GetLengthOctets(
    IN DWORD            cbContent,
    OUT OPTIONAL PBYTE  pbOut,
    IN OUT PDWORD       pcbOut);

VOID
WINAPI
ICM_SetLastError(
    IN DWORD    dwError);

BOOL
WINAPI
ICM_GetCAPI(
    IN DWORD                        dwGroupId,
    IN PCRYPT_ALGORITHM_IDENTIFIER  pai,
    OUT PDWORD                      pdwAlgId);

LONG
WINAPI
ICM_ObjIdToIndex(
    IN ObjectID *poi);

BOOL
WINAPI
ICM_EqualObjectIDs(
    IN ObjectID     *poid1,
    IN ObjectID     *poid2);

BOOL
WINAPI
ICM_IsData(
    IN  LPSTR   pszContentType);

BOOL
WINAPI
ICM_InsertTailBlob(
    IN OUT CBlobList    *pBlobList,
    IN Any              *pAny);

BOOL
WINAPI
ICM_InsertTailSigner(
    IN OUT CSignerList  *pSignerList,
    IN Any              *pAny);

BOOL
WINAPI
ICM_CreateHashList(
    IN HCRYPTPROV       hCryptProv,
    IN OUT CHashList    **ppHashList,
    IN CBlobList        *pAlgidList);

BOOL
WINAPI
ICM_UpdateListDigest(
    IN CHashList    *pHashList,
    IN const BYTE   *pbData,
    IN DWORD        cbData);

#ifdef CMS_PKCS7
BOOL
WINAPI
ICM_IsDuplicateSignerEncodeHashAlgorithm(
    IN PCMSG_SIGNER_ENCODE_INFO rgSigners,
    IN PCMSG_SIGNER_ENCODE_INFO pNewSigner,
    OUT OPTIONAL DWORD *pdwPrevIndex = NULL
    );

BOOL
WINAPI
ICM_FillSignerEncodeEncryptedDigests(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fMaxLength);

#else

BOOL
WINAPI
ICM_FillSignerEncryptedDigest(
    IN SignerInfo   *psi,
    IN LPSTR        pszInnerContentObjID,
    IN CHashNode    *pnHash,
    IN DWORD        dwKeySpec,
    IN BOOL         fMaxLength);
#endif  // CMS_PKCS7

BOOL
WINAPI
ICM_GetKeyBlockSize(
    IN HCRYPTKEY        hkey,
    OUT PDWORD          pcbBlock,
    OUT OPTIONAL PBOOL  pfBlockCipher);

#ifdef CMS_PKCS7
BOOL
WINAPI
ICM_InitializeContentEncryptInfo(
    IN PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedEncodeInfo,
    OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo
    );

void
WINAPI
ICM_FreeContentEncryptInfo(
    IN PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedEncodeInfo,
    IN OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo
    );

BOOL
WINAPI
ICM_FillOssCmsRecipientInfos(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN OUT CmsRecipientInfos *poris,
#ifdef OSS_CRYPT_ASN1
    IN OUT int *pEnvelopedDataVersion
#else
    IN OUT ASN1int32_t *pEnvelopedDataVersion
#endif  // OSS_CRYPT_ASN1
    );
void
WINAPI
ICM_FreeOssCmsRecipientInfos(
    IN OUT CmsRecipientInfos *poris
    );

#else

//  rgcbEncryptParameters[1] is the dwEncryptFlags passed to
//  ICM_ExportEncryptKey
BOOL
WINAPI
ICM_GenEncryptKey(
    IN OUT HCRYPTPROV               *phCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PVOID                        pvEncryptAuxInfo,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    IN PFN_CMSG_ALLOC               pfnAlloc,
    OUT HCRYPTKEY                   *phEncryptKey,
    OUT PBYTE                       *ppbEncryptParameters,
    OUT DWORD                       rgcbEncryptParameters[2]);

// rgcbData[1] is the dwEncryptFlags passed from ICM_GenEncryptKey
BOOL
WINAPI
ICM_ExportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    OUT PBYTE                       pbData,
    IN OUT DWORD                    rgcbData[2]);

BOOL
WINAPI
ICM_ImportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN DWORD                        dwKeySpec,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiPubKey,
    IN PBYTE                        pbEncodedKey,
    IN DWORD                        cbEncodedKey,
    OUT HCRYPTKEY                   *phEncryptKey);

#endif  // CMS_PKCS7

BOOL
WINAPI
ICM_EncryptBuffer(
    IN HCRYPTKEY    hkeyEncrypt,
    HCRYPTHASH      hHash,
    IN const BYTE   *pbPlain,
    IN DWORD        cbPlain,
    OUT PBYTE       *ppbCipher,
    OUT PDWORD      pcbCipher);

BOOL
WINAPI
ICMS_SetDecryptKey(
    IN PCRYPT_MSG_INFO  pcmi,
    IN HCRYPTKEY        hkeyDecrypt);

BOOL
WINAPI
ICMS_ExtractContent(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbDER,
    IN DWORD            cbDER,
    OUT PDWORD          pcbContent,
    OUT const BYTE      **ppbContent);

BOOL
WINAPI
ICMS_OpenToEncodeData(
    IN PCRYPT_MSG_INFO          pcmi);

BOOL
WINAPI
ICMS_UpdateEncodingData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN PBYTE            pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal);

BOOL
WINAPI
ICMS_UpdateDecodingInner(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal);

BOOL
WINAPI
ICMS_UpdateDecoding(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal);

BOOL
WINAPI
ICMS_OpenToEncodeSignedData(
    IN PCRYPT_MSG_INFO          pcmi,
    IN PCMSG_SIGNED_ENCODE_INFO psmei);

BOOL
WINAPI
ICMS_UpdateEncodingSignedData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN PBYTE            pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal);

BOOL
WINAPI
ICMS_OpenToEncodeEnvelopedData(
    IN PCRYPT_MSG_INFO              pcmi,
    IN PCMSG_ENVELOPED_ENCODE_INFO  pemei);

BOOL
WINAPI
ICMS_UpdateEncodingEnvelopedData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbPlain,
    IN DWORD            cbPlain,
    IN BOOL             fFinal);

DWORD
WINAPI
ICM_LengthSigned(
    IN PCMSG_SIGNED_ENCODE_INFO psmei,
    IN DWORD                    dwFlags,
    IN LPSTR                    pszInnerContentObjID,
    IN DWORD                    cbData,
    OUT OPTIONAL PDWORD         pcbContent);

DWORD
WINAPI
ICM_LengthEnveloped(
    IN PCMSG_ENVELOPED_ENCODE_INFO  pemei,
    IN DWORD                        dwFlags,
    IN OPTIONAL LPSTR               pszInnerContentObjID,
    IN DWORD                        cbData,
    OUT OPTIONAL PDWORD             pcbContent);

// OCTET STRING callback, used for streaming
typedef BOOL (WINAPI *POSTRCALLBACK)(
        IN const void       *pvArg,
        IN OUT PICM_BUFFER  pbuf,
        IN OUT PDWORD       pcbPending,
        IN BOOL             fFinal);

BOOL
WINAPI
ICMS_HashContent(
    IN PCRYPT_MSG_INFO  pcmi,
    IN PBYTE            pbData,
    IN DWORD            cbData);


BOOL
WINAPI
ICM_GetSignerIdFromSignerEncodeInfo(
    IN PCMSG_SIGNER_ENCODE_INFO psei,
    OUT PCERT_ID                pSignerId);

#endif  // __WINCRMSG_P_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\tools\fencrypt\fencrypt.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       fencrypt.cpp
//
//  Contents:   File encryption tool. Encrypts a file looking in the MY
//              system certificate store for the specifed subject common name
//              with exchange private keys.
//
//--------------------------------------------------------------------------
#include <windows.h>
#include <assert.h>
#include "wincrypt.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>

//+-------------------------------------------------------------------------
//  Helper function to make MBCS from Unicode string
//--------------------------------------------------------------------------
BOOL WINAPI MkMBStr(PBYTE pbBuff, DWORD cbBuff, LPCWSTR wsz, char ** pszMB) {

    DWORD   cbConverted;

    assert(pszMB != NULL);
    *pszMB = NULL;
    if(wsz == NULL)
        return(TRUE);

    // how long is the mb string
    cbConverted = WideCharToMultiByte(  0,
                                        0,
                                        wsz,
                                        -1,
                                        NULL,
                                        0,
                                        NULL,
                                        NULL);

    // get a buffer long enough
    if(pbBuff != NULL  &&  cbConverted < cbBuff)
        *pszMB = (char *) pbBuff;
    else
        *pszMB = (char *) malloc(cbConverted);


    if(*pszMB == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        return(FALSE);
    }

    // now convert to MB
    WideCharToMultiByte(0,
                        0,
                        wsz,
                        -1,
                        *pszMB,
                        cbConverted,
                        NULL,
                        NULL);
    return(TRUE);
}

//+-------------------------------------------------------------------------
//  Frees string allocated by the above function
//--------------------------------------------------------------------------
void WINAPI FreeMBStr(PBYTE pbBuff, char * szMB) {

    if((szMB != NULL) &&  (pbBuff != (PBYTE)szMB))
        free(szMB);
}

//+-------------------------------------------------------------------------
//  Win95 only supports CryptAcquireContextA. This function converts the
//  unicode parameters to multibyte.
//--------------------------------------------------------------------------
BOOL WINAPI CryptAcquireContextU(
    HCRYPTPROV *phProv,
    LPCWSTR lpContainer,
    LPCWSTR lpProvider,
    DWORD dwProvType,
    DWORD dwFlags) {

    BYTE rgb1[_MAX_PATH];
    BYTE rgb2[_MAX_PATH];
    char *  szContainer = NULL;
    char *  szProvider = NULL;
    LONG    err;

    err = FALSE;
    if(
        MkMBStr(rgb1, _MAX_PATH, lpContainer, &szContainer)  &&
        MkMBStr(rgb2, _MAX_PATH, lpProvider, &szProvider)    )
        err = CryptAcquireContextA (
                phProv,
                szContainer,
                szProvider,
                dwProvType,
                dwFlags
               );

    FreeMBStr(rgb1, szContainer);
    FreeMBStr(rgb2, szProvider);

    return(err);
}

//+-------------------------------------------------------------------------
//  Helper function to allocated the output buffer 
//  and call CryptDecodeObject.
//--------------------------------------------------------------------------
BOOL
WINAPI
MDecodeObject(
    IN DWORD	    dwEncodingType,
    IN LPCSTR	    lpszStructureType,
    IN const PBYTE  pbEncoded,
    IN DWORD	    cbEncoded,
    OUT PVOID *	    ppvoid
    )
{
    DWORD cb = 0;
    
    assert(ppvoid != NULL);
    *ppvoid = NULL;

    // get the size
    if(!CryptDecodeObject(
        dwEncodingType,
        lpszStructureType,
        pbEncoded,
        cbEncoded,
        0,                  // dwFlags
        NULL,
        &cb
        ))
        return(FALSE);
    
    // allocate the buffer
    if( (*ppvoid = malloc(cb)) == NULL ) 
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }
    
    // Decode the data
    if(!CryptDecodeObject(
        dwEncodingType,
        lpszStructureType,
        pbEncoded,
        cbEncoded,
        0,                  // dwFlags
        *ppvoid,
        &cb
        )) 
    {

        free(*ppvoid);
        *ppvoid = NULL;
        return(FALSE);
    }
        
    return(TRUE);
}

//+-------------------------------------------------------------------------
//  Helper function to allocated the output buffer 
//  and call CertRDNValueToStr.
//--------------------------------------------------------------------------
DWORD
WINAPI
MCertRDNValueToStr(
    IN DWORD dwValueType,
    IN PCERT_RDN_VALUE_BLOB pValue,
    OUT OPTIONAL LPSTR * ppsz
    ) 
{

    DWORD cb = 0;
    
    assert(ppsz != NULL);
    *ppsz = NULL;

    // get the size
    cb = CertRDNValueToStrA(
        dwValueType,
        pValue,
        NULL,
        0);
    
    // allocate the buffer
    if( (*ppsz = (LPSTR) malloc(cb)) == NULL ) 
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(0);
    }

    // now convert the CERT_RDN Value to an 
    // ascii string based on the specified 
    // ASN value type.
    // This shouldn't fail.
    return(CertRDNValueToStrA(
        dwValueType,
        pValue,
        *ppsz,
        cb));
}


//+-------------------------------------------------------------------------
//  Helper function to get and allocate the exported public key info
//--------------------------------------------------------------------------
BOOL
WINAPI
MCryptExportPublicKeyInfo(
    HCRYPTPROV hProv,
    DWORD dwKeySpec,
    PCERT_PUBLIC_KEY_INFO *ppPubKeyInfo
    )
{
    DWORD cbPubKeyInfo;
    assert(ppPubKeyInfo != NULL);
    *ppPubKeyInfo = NULL;
    

    // get the size
    if(!CryptExportPublicKeyInfo(
            hProv,
            dwKeySpec,
            X509_ASN_ENCODING,
            NULL,                   // pPubKeyInfo
            &cbPubKeyInfo
            )
        )
        return(FALSE);
    
    // allocate the buffer
    if( (*ppPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) malloc(cbPubKeyInfo)) == NULL ) 
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }
    
    if(!CryptExportPublicKeyInfo(
            hProv,
            dwKeySpec,
            X509_ASN_ENCODING,
            *ppPubKeyInfo,
            &cbPubKeyInfo
            )
        ) 
    {
        free(*ppPubKeyInfo);
        *ppPubKeyInfo = NULL;
        
        return(FALSE);
    }
        
    return(TRUE);
}
//+-------------------------------------------------------------------------
//  Helper function to allocated the output buffer 
//  and call CertGetCertificateContextProperty.
//--------------------------------------------------------------------------
BOOL
WINAPI
MCertGetCertificateContextProperty(
    IN PCCERT_CONTEXT pCertContext,
    IN DWORD dwPropId,
    OUT void ** ppvData
    )
{

    DWORD cb = 0;
    
    assert(ppvData != NULL);
    *ppvData = NULL;

    // get the size
    if( !CertGetCertificateContextProperty(
            pCertContext,
            dwPropId,
            NULL,
            &cb))
        return(FALSE);
    
    // allocate the buffer
    if( (*ppvData = malloc(cb)) == NULL ) 
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }
    
    // Get the property out of the cert
    if( !CertGetCertificateContextProperty(
            pCertContext,
            dwPropId,
            *ppvData,
            &cb)) 
    {

        free(*ppvData);
        *ppvData = NULL;
        return(FALSE);
    }
        
    return(TRUE);
}

//+-------------------------------------------------------------------------
//  Helper function to allocated the output buffer 
//  and call CryptEncryptMessage.
//--------------------------------------------------------------------------
BOOL
WINAPI
MCryptEncryptMessage(
    IN PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
    IN DWORD cRecipientCert,
    IN PCCERT_CONTEXT rgpRecipientCert[],
    IN const BYTE *pbToBeEncrypted,
    IN DWORD cbToBeEncrypted,
    OUT BYTE **ppbEncryptedBlob,
    OUT DWORD *pcbEncryptedBlob
    )
{
    
    assert(ppbEncryptedBlob != NULL);
    *ppbEncryptedBlob = NULL;

    assert(pcbEncryptedBlob != NULL);
    *pcbEncryptedBlob = 0;

    // get the size
    if(!CryptEncryptMessage(
        pEncryptPara,
        cRecipientCert,
        rgpRecipientCert,
        pbToBeEncrypted,
        cbToBeEncrypted,
        NULL,
        pcbEncryptedBlob
        ))
        return(FALSE);
    
    // allocate the buffer
    if( (*ppbEncryptedBlob = (BYTE *) malloc(*pcbEncryptedBlob)) == NULL ) 
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }
    
    // encrypt the data
    if(!CryptEncryptMessage(
        pEncryptPara,
        cRecipientCert,
        rgpRecipientCert,
        pbToBeEncrypted,
        cbToBeEncrypted,
        *ppbEncryptedBlob,
        pcbEncryptedBlob)) 
    {
        free(*ppbEncryptedBlob);
        *ppbEncryptedBlob = NULL;
        *pcbEncryptedBlob = 0;
        return(FALSE);
    }
        
    return(TRUE);
}

//+-------------------------------------------------------------------------
//  Display FEncrypt usage.
//--------------------------------------------------------------------------
void
Usage(void)
{
    printf("Usage: FEncrypt [options] <SubjectName> <ClearTextFileName> <EncryptedFileName>\n");
    printf("Options are:\n");
    printf("  -RC2          - RC2 encryption\n");
    printf("  -RC4          - RC4 encryption\n");
    printf("  -SP3          - SP3 compatible encryption\n");
    printf("  -FIX          - Fix by loading sp3crmsg.dll\n");
    exit(1);
}

//+-------------------------------------------------------------------------
//  Generalized error routine
//--------------------------------------------------------------------------
#define PRINTERROR(psz, err)	_PrintError((psz), (err), __LINE__)
void
_PrintError(char *pszMsg, DWORD err, DWORD line)
{
    printf("%s failed on line %u: %u(%x)\n", pszMsg, line, err, err);
}

//+-------------------------------------------------------------------------
//  Grovels the cert store looking for a cert with the specified
//  subject common name. Then checks to see that there are private
//  and public exchange keys.
//--------------------------------------------------------------------------
PCCERT_CONTEXT GetSubjectCertFromStore(
    HCERTSTORE      hMyStore,
    const char *    szSubjectName,
    HCRYPTPROV *    phProv 
    )
{

    DWORD               i, j;
    PCCERT_CONTEXT      pCertContext        = NULL;
    PCCERT_CONTEXT      pCertContextLast    = NULL;
    PCERT_NAME_INFO          pNameInfo           = NULL;
    LPSTR               sz                  = NULL;
    PCRYPT_KEY_PROV_INFO      pProvInfo           = NULL;
    HCRYPTPROV          hProv               = NULL;
    PCERT_PUBLIC_KEY_INFO    pPubKeyInfo         = NULL;

    assert(hMyStore != NULL);
    assert(phProv != NULL);
    *phProv = NULL;
    
    // Enum all certs looking for the requested common 
    // subject name that has private keys (so we know we can decrypt)
    while(   hProv == NULL && 
            (pCertContext = CertEnumCertificatesInStore(
                                hMyStore, 
                                pCertContextLast)) != NULL) 
    {

        // decode the subject name into RDNs
        if(MDecodeObject(X509_ASN_ENCODING, X509_NAME,
                pCertContext->pCertInfo->Subject.pbData,
                pCertContext->pCertInfo->Subject.cbData,
                (void **) &pNameInfo)
            ) 
        {

            // loop thru looking for an CERT_RDN and COMMON Name that works
            for(i=0; i<pNameInfo->cRDN && hProv == NULL; i++) 
            {
                for(j=0; j<pNameInfo->rgRDN[i].cRDNAttr && hProv == NULL; j++) 
                {

                    // check to see if this is the common name
                    if( !strcmp(pNameInfo->rgRDN[i].rgRDNAttr[j].pszObjId, 
                                szOID_COMMON_NAME) ) 
                    {
                            
                        // convert the string to something I can read
                        MCertRDNValueToStr(
                            pNameInfo->rgRDN[i].rgRDNAttr[j].dwValueType,
                            &pNameInfo->rgRDN[i].rgRDNAttr[j].Value,
                            &sz);

                        // see if this is a viable certificate to use
                        if( sz == NULL              || 
                        
                            // see if it is the common name we are looking for
                            _stricmp(sz, szSubjectName)             ||

                            // see if there are associated private keys
                            // to ensure we can decrypt the data later
                            !MCertGetCertificateContextProperty(
                                pCertContext,
                                CERT_KEY_PROV_INFO_PROP_ID,
                                (void **) &pProvInfo)               ||

                            // Make sure it is an exchange key for encryption
                            pProvInfo->dwKeySpec != AT_KEYEXCHANGE  ||

                            // see if the keys are really there
                            !CryptAcquireContextU(
                                &hProv, 
                                pProvInfo->pwszContainerName,
                                pProvInfo->pwszProvName,
                                pProvInfo->dwProvType,
                                pProvInfo->dwFlags &
                                    ~CERT_SET_KEY_CONTEXT_PROP_ID)
                            ) 
                        {

                            // On an error we didn't find a valid
                            // key provider. Unfortunately, the CSP
                            // may not leave the prov handle NULL
                            // so clear it out
                            hProv = NULL;
                        }

                        
                        // Make sure the public keys in the
                        // CSP match the public key in the certificate
                        else if( 
                            // export the public key blob
                            !MCryptExportPublicKeyInfo(
                                hProv,
                                pProvInfo->dwKeySpec,
                                &pPubKeyInfo
                                )               ||

                            // see if the public keys compare with 
                            // what is in the certificate
                            !CertComparePublicKeyInfo(
                                X509_ASN_ENCODING,
                                &pCertContext->pCertInfo->SubjectPublicKeyInfo,
                                pPubKeyInfo
                                )
                            )
                        // if the keys didn't compare, then we don't
                        // want to use this ceritificate
                        {

                            // close the hProv, we didn't find a valid cert
                            assert(hProv != NULL);
                            CryptReleaseContext(hProv, 0);
                            hProv = NULL;
                        }

                        // free public key info
                        if(pPubKeyInfo != NULL)
                        {
                            free(pPubKeyInfo); 
                            pPubKeyInfo = NULL;
                        }

                        // clean up opened prov info
                        if(pProvInfo != NULL) 
                        {
                            free(pProvInfo);
                            pProvInfo = NULL;
                        }

                        // free the space for the ascii common name
                        if(sz != NULL) 
                        {
                            free(sz);
                            sz = NULL;
                        }
                    }
                }
            }
            
            // free the name info data
            if(pNameInfo != NULL) 
            {
                free(pNameInfo);
                pNameInfo = NULL;
            }
        }

        // go to the next certificate
        pCertContextLast = pCertContext;
    }

    assert(pProvInfo == NULL);
    assert(sz == NULL);
    assert(pNameInfo == NULL);

    // There is a good cert in the store, return it
    if(hProv != NULL)
    {
        *phProv = hProv;
        assert(pCertContext != NULL);
        return(pCertContext);
    }

    return(NULL);
}

//+-------------------------------------------------------------------------
//  Main program. Open a file to encrypt,
//  encrypts it and then writes the encrypted 
//  data to the output file.
//--------------------------------------------------------------------------
int __cdecl
main(int argc, char * argv[])
{

    DWORD               dwExitValue         = 0;
    
    HCERTSTORE          hMyStore            = NULL;
    PCCERT_CONTEXT      pCertContext        = NULL;
    HCRYPTPROV          hProv               = NULL;
    
    HANDLE hFileOut                         = INVALID_HANDLE_VALUE;
    HANDLE hFile                            = INVALID_HANDLE_VALUE;
    DWORD  cbFile                           = 0;
    HANDLE hMap                             = NULL;
    PBYTE  pbFile                           = NULL;

    BOOL fResult;
    HMODULE hDll = NULL;
    CMSG_SP3_COMPATIBLE_AUX_INFO SP3AuxInfo;
    BOOL fSP3 = FALSE;
    BOOL fFix = FALSE;
    
    CRYPT_ALGORITHM_IDENTIFIER    encryptAlgId        = {szOID_RSA_RC4, 0};
    CRYPT_ENCRYPT_MESSAGE_PARA    encryptInfo;
    PBYTE               pbEncryptedBlob     = NULL;
    DWORD               cbEncryptedBlob     = 0;
    DWORD               cb                  = 0;


    // Advance past fencrypt.exe and check for leading options
    while (--argc > 0) {
        if (**++argv != '-')
            break;

        if (0 == _stricmp(argv[0], "-RC2"))
            encryptAlgId.pszObjId = szOID_RSA_RC2CBC;
        else if (0 == _stricmp(argv[0], "-RC4"))
            encryptAlgId.pszObjId = szOID_RSA_RC4;
        else if (0 == _stricmp(argv[0], "-SP3"))
            fSP3 = TRUE;
        else if (0 == _stricmp(argv[0], "-FIX"))
            fFix = TRUE;
        else {
            printf("Bad option: %s\n", argv[0]);
            Usage();
        }
    }
        
    
    // must have the parameters
    if (argc != 3)
        Usage();

    if (fFix) {
        if (NULL == (hDll = LoadLibraryA("sp3crmsg.dll"))) 
        {
            PRINTERROR("LoadLibraryA(sp3crmsg.dll)", GetLastError());
            goto ErrCleanUp;
        }
    }

    // Open the MY store
    if( (hMyStore = CertOpenSystemStore(NULL, "My")) == NULL ) 
    {
        PRINTERROR("CertOpenSystemStore", GetLastError());
        goto ErrCleanUp;
    }

    // Find a certificate in the MY store that
    // matches the subject name and has private keys
    if( (pCertContext = GetSubjectCertFromStore(hMyStore, argv[0], &hProv)) == NULL)
    {
        printf("Unable to find certificate %s with valid keys.\n", argv[0]);
        goto ErrCleanUp;
    }
        
    // At this point we have a provider, Cert and a public key.
    // We should be able to encrypt

    // Read in the clear text file
    if(
    
        // read in the file to encrypt
        (hFile =  CreateFileA(
            argv[1],	            // pointer to name of the file 
            GENERIC_READ,	        // access (read-write) mode 
            FILE_SHARE_READ,	    // share mode 
            NULL,	                // pointer to security descriptor 
            OPEN_EXISTING,	        // how to create 
            FILE_ATTRIBUTE_NORMAL,	// file attributes 
            NULL                    // handle to file with attributes to copy
            ))  == INVALID_HANDLE_VALUE     ||

        // create a file mapping object         
        (hMap = CreateFileMapping(
            hFile,	                // handle to file to map 
            NULL,	                // optional security attributes 
            PAGE_READONLY,	        // protection for mapping object 
            0,	                    // high-order 32 bits of object size  
            0,	                    // low-order 32 bits of object size  
            NULL 	                // name of file-mapping object 
            ))  == NULL                     ||

        // Map the file into the address space
        (pbFile = (PBYTE) MapViewOfFileEx(
            hMap,	                // file-mapping object to map into address space  
            FILE_MAP_READ,	        // access mode 
            0,	                    // high-order 32 bits of file offset 
            0,	                    // low-order 32 bits of file offset 
            0,	                    // number of bytes to map 
            NULL 	                // suggested starting address for mapped view 
            )) == NULL                                 
        ) 
    {

        PRINTERROR("File Open", GetLastError());
        goto ErrCleanUp;
    }

    // get the size of the file         
    if( (cbFile = GetFileSize(
            hFile,	                // handle of file to get size of
            NULL 	                // address of high-order word for file size
            )) == 0 
        ) 
    {
        printf("File %s has a 0 length.\n", argv[1]);
        goto ErrCleanUp;
    }

    // at this point we have a file mapping, go ahead and encrypt the file
    
    // Do rc4 encryption
    memset(&encryptInfo, 0, sizeof(CRYPT_ENCRYPT_MESSAGE_PARA));
    encryptInfo.cbSize =
        sizeof(CRYPT_ENCRYPT_MESSAGE_PARA);
    encryptInfo.dwMsgEncodingType            = PKCS_7_ASN_ENCODING;
    encryptInfo.hCryptProv                   = hProv;
    encryptInfo.ContentEncryptionAlgorithm   = encryptAlgId;

    if (fSP3) {
        memset(&SP3AuxInfo, 0, sizeof(CMSG_SP3_COMPATIBLE_AUX_INFO));
        SP3AuxInfo.cbSize = sizeof(CMSG_SP3_COMPATIBLE_AUX_INFO);
        SP3AuxInfo.dwFlags = CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG;
        encryptInfo.pvEncryptionAuxInfo = &SP3AuxInfo;
    }

    // encrypt it
    fResult = MCryptEncryptMessage(
            &encryptInfo,
            1,
            &pCertContext,
            pbFile,
            cbFile,
            &pbEncryptedBlob,
            &cbEncryptedBlob
            );
    if (!fResult && fSP3 && (DWORD) E_INVALIDARG == GetLastError()) {
        printf(
            "Non-NULL pvEncryptionAuxInfo not supported in SP3 crypt32.dll\n");
    
        encryptInfo.pvEncryptionAuxInfo = NULL;
        fResult = MCryptEncryptMessage(
            &encryptInfo,
            1,
            &pCertContext,
            pbFile,
            cbFile,
            &pbEncryptedBlob,
            &cbEncryptedBlob
            );
    }
    if (!fResult) {
        PRINTERROR("MCryptEncryptMessage", GetLastError());
        goto ErrCleanUp;
    }

    // write the encrypted file out
    if(
    
        // open the output file
        (hFileOut =  CreateFileA(
            argv[2],	            // pointer to name of the file 
            GENERIC_WRITE,	        // access (read-write) mode 
            FILE_SHARE_READ,	    // share mode 
            NULL,	                // pointer to security descriptor 
            CREATE_ALWAYS,	        // how to create 
            FILE_ATTRIBUTE_NORMAL,	// file attributes 
            NULL                    // handle to file with attributes to copy
            ))  == INVALID_HANDLE_VALUE     ||

        //write to the file
        !WriteFile(
            hFileOut,	            // handle to file to write to 
            pbEncryptedBlob,	    // pointer to data to write to file 
            cbEncryptedBlob,	    // number of bytes to write 
            &cb,	                // pointer to number of bytes written 
            NULL 	                // pointer to structure needed for overlapped I/O
            )
        )
     {
        PRINTERROR("File Write", GetLastError());
        goto ErrCleanUp;
     }


    CleanUp:

        if(hDll)
            FreeLibrary(hDll);

        if(hMap != NULL)
            CloseHandle(hMap);
        
        if(hFile != INVALID_HANDLE_VALUE && hFile != NULL)
            CloseHandle(hFile);
            
        if(hFileOut != INVALID_HANDLE_VALUE && hFile != NULL)
            CloseHandle(hFileOut);

        if(pCertContext != NULL)
            CertFreeCertificateContext(pCertContext);   
            
        if(hProv != NULL)
            CryptReleaseContext(hProv, 0);

        if(hMyStore != NULL)
            CertCloseStore(hMyStore, 0);

        if(pbEncryptedBlob != NULL)
            free(pbEncryptedBlob);

    return(dwExitValue);

    ErrCleanUp:
        dwExitValue = 1;
        goto CleanUp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\wincrmsg\msgasn1.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       msgasn1.h
//
//  Contents:   Conversion APIs to/from ASN.1 data structures
//
//  Functions:  ICM_Asn1ToAttribute
//              ICM_Asn1ToAlgorithmIdentifier
//              ICM_Asn1FromAlgorithmIdentifier
//
//  History:    16-Apr-96   kevinr   created
//
//--------------------------------------------------------------------------

#ifndef __MSGASN1_H__
#define __MSGASN1_H__

#ifdef __cplusplus
extern "C" {
#endif

//+-------------------------------------------------------------------------
//  Convert an CRYPT_ATTRIBUTE to an ASN1 Attribute
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_Asn1ToAttribute(
    IN PCRYPT_ATTRIBUTE       patr,
    OUT Attribute       *pAsn1Attr);


//+-------------------------------------------------------------------------
//  Convert an CRYPT_ALGORITHM_IDENTIFIER to an ASN1 AlgorithmIdentifier
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_Asn1ToAlgorithmIdentifier(
    IN PCRYPT_ALGORITHM_IDENTIFIER pai,
    OUT AlgorithmIdentifier *pAsn1AlgId);


//+-------------------------------------------------------------------------
//  Convert an ASN1 AlgorithmIdentifier to an CRYPT_ALGORITHM_IDENTIFIER
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_Asn1FromAlgorithmIdentifier(
    IN AlgorithmIdentifier *pAsn1AlgId,
    OUT PCRYPT_ALGORITHM_IDENTIFIER pai);

#ifdef __cplusplus
}       // Balance extern "C" above
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\wincrmsg\msghlpr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       msghlpr.cpp
//
//  Contents:   Cryptographic Message Helper APIs
//
//  APIs:       CryptMsgGetAndVerifySigner
//              CryptMsgSignCTL
//              CryptMsgEncodeAndSignCTL
//
//  History:    02-May-97   philh    created
//--------------------------------------------------------------------------

#include "global.hxx"
#include "pkialloc.h"

void *ICM_AllocAndGetMsgParam(
    IN HCRYPTMSG hMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex
    )
{
    void *pvData;
    DWORD cbData;

    if (!CryptMsgGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            NULL,           // pvData
            &cbData) || 0 == cbData)
        goto GetParamError;
    if (NULL == (pvData = ICM_Alloc(cbData)))
        goto OutOfMemory;
    if (!CryptMsgGetParam(
            hMsg,
            dwParamType,
            dwIndex,
            pvData,
            &cbData)) {
        ICM_Free(pvData);
        goto GetParamError;
    }

CommonReturn:
    return pvData;
ErrorReturn:
    pvData = NULL;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(GetParamError)
}

#ifdef CMS_PKCS7

BOOL ICM_GetAndVerifySigner(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwSignerIndex,
    IN DWORD cSignerStore,
    IN OPTIONAL HCERTSTORE *rghSignerStore,
    IN DWORD dwFlags,
    OUT OPTIONAL PCCERT_CONTEXT *ppSigner
    )
{
    BOOL fResult;
    PCERT_INFO pSignerId = NULL;
    PCCERT_CONTEXT pSigner = NULL;
    DWORD dwCertEncodingType;
    DWORD dwVerifyErr = 0;
    HCERTSTORE hCollection = NULL;

    if (NULL == (pSignerId = (PCERT_INFO) ICM_AllocAndGetMsgParam(
            hCryptMsg,
            CMSG_SIGNER_CERT_INFO_PARAM,
            dwSignerIndex
            ))) goto GetSignerError;

    // If no CertEncodingType, then, use the MsgEncodingType
    dwCertEncodingType = ((PCRYPT_MSG_INFO) hCryptMsg)->dwEncodingType;
    if (0 == (dwCertEncodingType & CERT_ENCODING_TYPE_MASK))
        dwCertEncodingType =
            (dwCertEncodingType >> 16) & CERT_ENCODING_TYPE_MASK;


    if (NULL == (hCollection = CertOpenStore(
                CERT_STORE_PROV_COLLECTION,
                0,                      // dwEncodingType
                0,                      // hCryptProv
                0,                      // dwFlags
                NULL                    // pvPara
                )))
        goto OpenCollectionStoreError;

    if (0 == (dwFlags & CMSG_TRUSTED_SIGNER_FLAG)) {
        HCERTSTORE hMsgCertStore;

        // Open a cert store initialized with certs from the message
        // and add to collection
        if (hMsgCertStore = CertOpenStore(
                CERT_STORE_PROV_MSG,
                dwCertEncodingType,
                0,                      // hCryptProv
                0,                      // dwFlags
                hCryptMsg               // pvPara
                )) {
            CertAddStoreToCollection(
                    hCollection,
                    hMsgCertStore,
                    CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG,
                    0                       // dwPriority
                    );
            CertCloseStore(hMsgCertStore, 0);
        }
    }

    // Add all the signer stores to the collection
    for ( ; cSignerStore > 0; cSignerStore--, rghSignerStore++) {
        HCERTSTORE hSignerStore = *rghSignerStore;
        if (NULL == hSignerStore)
            continue;

        CertAddStoreToCollection(
                hCollection,
                hSignerStore,
                CERT_PHYSICAL_STORE_ADD_ENABLE_FLAG,
                0                       // dwPriority
                );
    }

    if (pSigner = CertGetSubjectCertificateFromStore(hCollection,
            dwCertEncodingType, pSignerId)) {
        CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA CtrlPara;

        if (dwFlags & CMSG_SIGNER_ONLY_FLAG)
            goto SuccessReturn;

        memset(&CtrlPara, 0, sizeof(CtrlPara));
        CtrlPara.cbSize = sizeof(CtrlPara);
        // CtrlPara.hCryptProv =
        CtrlPara.dwSignerIndex = dwSignerIndex;
        CtrlPara.dwSignerType = CMSG_VERIFY_SIGNER_CERT;
        CtrlPara.pvSigner = (void *) pSigner;

        if (CryptMsgControl(
                hCryptMsg,
                0,                  // dwFlags
                CMSG_CTRL_VERIFY_SIGNATURE_EX,
                &CtrlPara)) goto SuccessReturn;
        else {
            dwVerifyErr = GetLastError();

            if (CRYPT_E_MISSING_PUBKEY_PARA == dwVerifyErr) {
                PCCERT_CHAIN_CONTEXT pChainContext;
                CERT_CHAIN_PARA ChainPara;

                // Build a chain. Hopefully, the signer inherit's its public key
                // parameters from up the chain

                memset(&ChainPara, 0, sizeof(ChainPara));
                ChainPara.cbSize = sizeof(ChainPara);
                if (CertGetCertificateChain(
                        NULL,                   // hChainEngine
                        pSigner,
                        NULL,                   // pTime
                        hCollection,
                        &ChainPara,
                        CERT_CHAIN_CACHE_ONLY_URL_RETRIEVAL,
                        NULL,                   // pvReserved
                        &pChainContext
                        ))
                    CertFreeCertificateChain(pChainContext);


                // Try again. Hopefully the above chain building updated the
                // signer's context property with the missing public key
                // parameters
                if (CryptMsgControl(
                        hCryptMsg,
                        0,                  // dwFlags
                        CMSG_CTRL_VERIFY_SIGNATURE_EX,
                        &CtrlPara)) goto SuccessReturn;
            }
        }
        CertFreeCertificateContext(pSigner);
        pSigner = NULL;
    }

    if (dwVerifyErr)
        goto VerifySignatureError;
    else
        goto NoSignerError;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    if (hCollection)
        CertCloseStore(hCollection, 0);
    ICM_Free(pSignerId);
    if (ppSigner)
        *ppSigner = pSigner;
    else if (pSigner)
        CertFreeCertificateContext(pSigner);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(OpenCollectionStoreError)
TRACE_ERROR(GetSignerError)
SET_ERROR(NoSignerError, CRYPT_E_NO_TRUSTED_SIGNER)
SET_ERROR_VAR(VerifySignatureError, dwVerifyErr)
}

#else

BOOL ICM_GetAndVerifySigner(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwSignerIndex,
    IN DWORD cSignerStore,
    IN OPTIONAL HCERTSTORE *rghSignerStore,
    IN DWORD dwFlags,
    OUT OPTIONAL PCCERT_CONTEXT *ppSigner
    )
{
    BOOL fResult;
    PCERT_INFO pSignerId = NULL;
    PCCERT_CONTEXT pSigner = NULL;
    DWORD dwCertEncodingType;
    DWORD dwVerifyErr = 0;

    if (NULL == (pSignerId = (PCERT_INFO) ICM_AllocAndGetMsgParam(
            hCryptMsg,
            CMSG_SIGNER_CERT_INFO_PARAM,
            dwSignerIndex
            ))) goto GetSignerError;

    // If no CertEncodingType, then, use the MsgEncodingType
    dwCertEncodingType = ((PCRYPT_MSG_INFO) hCryptMsg)->dwEncodingType;
    if (0 == (dwCertEncodingType & CERT_ENCODING_TYPE_MASK))
        dwCertEncodingType =
            (dwCertEncodingType >> 16) & CERT_ENCODING_TYPE_MASK;

    if (0 == (dwFlags & CMSG_TRUSTED_SIGNER_FLAG)) {
        HCERTSTORE hMsgCertStore;

        // Open a cert store initialized with certs from the message
        if (hMsgCertStore = CertOpenStore(
                CERT_STORE_PROV_MSG,
                dwCertEncodingType,
                0,                      // hCryptProv
                0,                      // dwFlags
                hCryptMsg               // pvPara
                )) {
            pSigner = CertGetSubjectCertificateFromStore(hMsgCertStore,
                dwCertEncodingType, pSignerId);
            CertCloseStore(hMsgCertStore, 0);
        }

        if (pSigner) {
            if (dwFlags & CMSG_SIGNER_ONLY_FLAG)
                goto SuccessReturn;
            if (CryptMsgControl(
                    hCryptMsg,
                    0,                  // dwFlags
                    CMSG_CTRL_VERIFY_SIGNATURE,
                    pSigner->pCertInfo)) goto SuccessReturn;
            else
                dwVerifyErr = GetLastError();
            CertFreeCertificateContext(pSigner);
            pSigner = NULL;
        }
    }

    for ( ; cSignerStore > 0; cSignerStore--, rghSignerStore++) {
        HCERTSTORE hSignerStore = *rghSignerStore;
        if (NULL == hSignerStore)
            continue;
        if (pSigner = CertGetSubjectCertificateFromStore(hSignerStore,
                dwCertEncodingType, pSignerId)) {
            if (dwFlags & CMSG_SIGNER_ONLY_FLAG)
                goto SuccessReturn;
            if (CryptMsgControl(
                    hCryptMsg,
                    0,                  // dwFlags
                    CMSG_CTRL_VERIFY_SIGNATURE,
                    pSigner->pCertInfo)) goto SuccessReturn;
            else
                dwVerifyErr = GetLastError();
            CertFreeCertificateContext(pSigner);
            pSigner = NULL;
        }
    }

    if (dwVerifyErr)
        goto VerifySignatureError;
    else
        goto NoSignerError;

SuccessReturn:
    fResult = TRUE;
CommonReturn:
    ICM_Free(pSignerId);
    if (ppSigner)
        *ppSigner = pSigner;
    else if (pSigner)
        CertFreeCertificateContext(pSigner);
    return fResult;
ErrorReturn:
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetSignerError)
SET_ERROR(NoSignerError, CRYPT_E_NO_TRUSTED_SIGNER)
SET_ERROR_VAR(VerifySignatureError, dwVerifyErr)
}

#endif  // CMS_PKCS7

//+-------------------------------------------------------------------------
//  Get and verify the signer of a cryptographic message.
//
//  If CMSG_TRUSTED_SIGNER_FLAG is set, then, treat the Signer stores as being
//  trusted and only search them to find the certificate corresponding to the
//  signer's issuer and serial number.  Otherwise, the SignerStores are
//  optionally provided to supplement the message's store of certificates.
//  If a signer certificate is found, its public key is used to verify
//  the message signature. The CMSG_SIGNER_ONLY_FLAG can be set to
//  return the signer without doing the signature verify.
//
//  If CMSG_USE_SIGNER_INDEX_FLAG is set, then, only get the signer specified
//  by *pdwSignerIndex. Otherwise, iterate through all the signers
//  until a signer verifies or no more signers.
//
//  For a verified signature, *ppSigner is updated with certificate context
//  of the signer and *pdwSignerIndex is updated with the index of the signer.
//  ppSigner and/or pdwSignerIndex can be NULL, indicating the caller isn't
//  interested in getting the CertContext and/or index of the signer.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptMsgGetAndVerifySigner(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD cSignerStore,
    IN OPTIONAL HCERTSTORE *rghSignerStore,
    IN DWORD dwFlags,
    OUT OPTIONAL PCCERT_CONTEXT *ppSigner,
    IN OUT OPTIONAL DWORD *pdwSignerIndex
    )
{
    BOOL fResult = FALSE;
    DWORD dwSignerCount;
    DWORD dwSignerIndex;

    if (dwFlags & CMSG_USE_SIGNER_INDEX_FLAG) {
        dwSignerCount = 1;
        dwSignerIndex = *pdwSignerIndex;
    } else {
        DWORD cbData;

        dwSignerIndex = 0;
        if (pdwSignerIndex)
            *pdwSignerIndex = 0;
        cbData = sizeof(dwSignerCount);
        if (!CryptMsgGetParam(
                hCryptMsg,
                CMSG_SIGNER_COUNT_PARAM,
                0,                      // dwIndex
                &dwSignerCount,
                &cbData) || 0 == dwSignerCount)
            goto NoSignerError;
    }

    // Minimum of one iteration
    for ( ; dwSignerCount > 0; dwSignerCount--, dwSignerIndex++) {
        if (fResult = ICM_GetAndVerifySigner(
                hCryptMsg,
                dwSignerIndex,
                cSignerStore,
                rghSignerStore,
                dwFlags,
                ppSigner)) {
            if (pdwSignerIndex && 0 == (dwFlags & CMSG_USE_SIGNER_INDEX_FLAG))
                *pdwSignerIndex = dwSignerIndex;
            break;
        }
    }

CommonReturn:
    return fResult;
ErrorReturn:
    if (ppSigner)
        *ppSigner = NULL;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(NoSignerError, CRYPT_E_NO_TRUSTED_SIGNER)
}

//+-------------------------------------------------------------------------
//  Sign an encoded CTL.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptMsgSignCTL(
    IN DWORD dwMsgEncodingType,
    IN BYTE *pbCtlContent,
    IN DWORD cbCtlContent,
    IN PCMSG_SIGNED_ENCODE_INFO pSignInfo,
    IN DWORD dwFlags,
    OUT BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    HCRYPTMSG hMsg = NULL;

    DWORD dwMsgFlags;

#ifdef CMS_PKCS7
    if (dwFlags & CMSG_CMS_ENCAPSULATED_CTL_FLAG)
        dwMsgFlags = CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
    else
        dwMsgFlags = 0;
#else
    dwMsgFlags = 0;
#endif  // CMS_PKCS7

    if (NULL == pbEncoded) {
        if (0 == (*pcbEncoded = CryptMsgCalculateEncodedLength(
            dwMsgEncodingType,
            dwMsgFlags,
            CMSG_SIGNED,
            pSignInfo,
            szOID_CTL,
            cbCtlContent))) goto CalculateEncodedLengthError;
        fResult = TRUE;
    } else {
        if (NULL == (hMsg = CryptMsgOpenToEncode(
                dwMsgEncodingType,
                dwMsgFlags,
                CMSG_SIGNED,
                pSignInfo,
                szOID_CTL,
                NULL                        // pStreamInfo
                ))) goto OpenToEncodeError;
        if (!CryptMsgUpdate(
                hMsg,
                pbCtlContent,
                cbCtlContent,
                TRUE                        // fFinal
                )) goto UpdateError;

        fResult = CryptMsgGetParam(
            hMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            pbEncoded,
            pcbEncoded);
    }

CommonReturn:
    if (hMsg)
        CryptMsgClose(hMsg);
    return fResult;
ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;

TRACE_ERROR(CalculateEncodedLengthError)
TRACE_ERROR(OpenToEncodeError)
TRACE_ERROR(UpdateError)
}


//+-------------------------------------------------------------------------
//  Encode the CTL and create a signed message containing the encoded CTL.
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptMsgEncodeAndSignCTL(
    IN DWORD dwMsgEncodingType,
    IN PCTL_INFO pCtlInfo,
    IN PCMSG_SIGNED_ENCODE_INFO pSignInfo,
    IN DWORD dwFlags,
    OUT BYTE *pbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fResult;
    BYTE *pbContent = NULL;
    DWORD cbContent;
    DWORD dwEncodingType;
    LPCSTR lpszStructType;
    DWORD dwEncodeFlags;

    dwEncodingType = (dwMsgEncodingType >> 16) & CERT_ENCODING_TYPE_MASK;
    assert(dwEncodingType != 0);
    if (0 == dwEncodingType)
        goto InvalidArg;

    dwEncodeFlags = CRYPT_ENCODE_ALLOC_FLAG;
    if (dwFlags & CMSG_ENCODE_SORTED_CTL_FLAG) {
        lpszStructType = PKCS_SORTED_CTL;
        if (dwFlags & CMSG_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG)
            dwEncodeFlags |=
                CRYPT_SORTED_CTL_ENCODE_HASHED_SUBJECT_IDENTIFIER_FLAG;
    } else {
        lpszStructType = PKCS_CTL;
    }


    if (!CryptEncodeObjectEx(
            dwEncodingType,
            lpszStructType,
            pCtlInfo,
            dwEncodeFlags,
            &PkiEncodePara,
            (void *) &pbContent,
            &cbContent
            )) goto EncodeError;

    fResult = CryptMsgSignCTL(
        dwMsgEncodingType,
        pbContent,
        cbContent,
        pSignInfo,
        dwFlags,
        pbEncoded,
        pcbEncoded
        );

CommonReturn:
    PkiFree(pbContent);
    return fResult;

ErrorReturn:
    *pcbEncoded = 0;
    fResult = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(EncodeError)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\wincrmsg\msglen.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       msglen.cpp
//
//  Contents:   Cryptographic Message Length APIs
//
//  APIs:       CryptMsgCalculateEncodedLength
//
//  History:    12-Dec-96   kevinr    created
//
//--------------------------------------------------------------------------

#include "global.hxx"


//+-------------------------------------------------------------------------
//  Calculate the length of the OBJECT IDENTIFIER encoded blob.
//  We do this by doing the encode using OSS and throwing away the result.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthObjId(
    IN LPSTR   pszObjId)
{
    DWORD           cbSize;
    DWORD           cb;
    ASN1encodedOID_t eoid;       ZEROSTRUCT(eoid); 
    ASN1encoding_t  pEnc = ICM_GetEncoder();

    if (0 == PkiAsn1DotValToEncodedOid(pEnc, pszObjId, &eoid))
        goto DotValToEncodedOidError;

    ICM_GetLengthOctets( eoid.length, NULL, &cb);
    cbSize = 1 + cb + eoid.length;                  // OBJECT IDENTIFIER

    PkiAsn1FreeEncodedOid(pEnc, &eoid);

CommonReturn:
    return cbSize;
ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
SET_ERROR(DotValToEncodedOidError,CRYPT_E_OID_FORMAT)
}


//+-------------------------------------------------------------------------
//  Calculate the length of the AlgorithmIdentifier encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthAlgorithmIdentifier(
    IN PCRYPT_ALGORITHM_IDENTIFIER pai,
    IN BOOL fNoNullParameters = FALSE
    )
{
    DWORD           cbSize;
    DWORD           cb;

    if (INVALID_ENCODING_SIZE == (cbSize  = ICM_LengthObjId( pai->pszObjId)))
        goto CommonReturn;
    if (!fNoNullParameters)
        cbSize += max( 2, pai->Parameters.cbData);
    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += cb + 1;                       // AlgorithmIdentifier seq

CommonReturn:
    return cbSize;
}


//+-------------------------------------------------------------------------
//  Calculate the length of the ContentInfo encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthContentInfo(
    IN DWORD            dwFlags,
    IN OPTIONAL LPSTR   pszContentType,
    IN DWORD            cbData,
    OUT OPTIONAL PDWORD pcbContent)
{
    DWORD           cbSize;
    DWORD           cbTmp;
    DWORD           cb;

    if (INVALID_ENCODING_SIZE == (cbSize = ICM_LengthObjId(
                pszContentType ? pszContentType : pszObjIdDataType)))
        goto LengthContentTypeError;

    if (0 == (dwFlags & CMSG_DETACHED_FLAG)) {
        cbTmp = cbData;
        ICM_GetLengthOctets( cbTmp, NULL, &cb);

        if (NULL == pszContentType
#ifdef CMS_PKCS7
                || ((dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG) &&
                        !ICM_IsData(pszContentType))
#endif  // CMS_PKCS7
                ) {
            // data, not already encoded
            // Gets its own OCTET STRING wrapper.
            cbTmp += 1 + cb;            // OCTET STRING
            ICM_GetLengthOctets( cbTmp, NULL, &cb);
        }
        cbSize += 1 + cb + cbTmp;       // [0] EXPLICIT
    }

    if (pcbContent)
        *pcbContent = cbSize;

    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += 1 + cb;                   // ContentInfo seq

CommonReturn:
    return cbSize;
ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(LengthContentTypeError)     // error already set
}


//+-------------------------------------------------------------------------
//  Calculate the length of the EncryptedContentInfo encoded blob.
//
//  The return length assumes the encrypted content is
//  encapsulated.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthEncryptedContentInfo(
    IN HCRYPTKEY                    hEncryptKey,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiContentEncryption,
    IN OPTIONAL LPSTR               pszContentTypeOrg,
    IN DWORD                        cbData)
{
    DWORD       cbSize;
    DWORD       cb;
    DWORD       cbBlockSize;
    BOOL        fBlockCipher;
    DWORD       cbCipher;
    LPSTR       pszContentType = pszContentTypeOrg ? pszContentTypeOrg :
                                                     pszObjIdDataType;

    if (INVALID_ENCODING_SIZE == (cbSize = ICM_LengthObjId( pszContentType)))
        goto LengthContentTypeError;
    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAlgorithmIdentifier( paiContentEncryption)))
        goto LengthAlgorithmIdentifierError;
    cbSize += cb;

    cbCipher = cbData;
    if (0 < cbCipher) {
        if (!ICM_GetKeyBlockSize(
                hEncryptKey,
                &cbBlockSize,
                &fBlockCipher))
            goto GetEncryptBlockSizeError;

        if (fBlockCipher) {
            cbCipher += cbBlockSize;
            cbCipher -= cbCipher % cbBlockSize;
        }
    }

    ICM_GetLengthOctets( cbCipher, NULL, &cb);  // encryptedContent
    cbSize += 1 + cb + cbCipher;                // [0] IMPLICIT

    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += 1 + cb;                           // EncryptedContentInfo seq

CommonReturn:
    return cbSize;
ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(LengthContentTypeError)
TRACE_ERROR(LengthAlgorithmIdentifierError)
TRACE_ERROR(GetEncryptBlockSizeError)
}


#ifndef CMS_PKCS7
//+-------------------------------------------------------------------------
//  Calculate the length of the IssuerAndSerialNumber encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthIssuerAndSerialNumber(
    IN PCERT_INFO   pCertInfo)
{
    DWORD           cbSize;
    DWORD           cb;

    cbSize = pCertInfo->SerialNumber.cbData;
    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += cb + 1;                       // SerialNumber INTEGER
    cbSize += pCertInfo->Issuer.cbData;     // Issuer already encoded
    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += cb + 1;                       // IssuerAndSerialNumber seq

    return cbSize;
}
#endif  // CMS_PKCS7

//+-------------------------------------------------------------------------
//  Calculate the length of the CertId encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthCertId(
    IN PCERT_ID     pCertId)
{
    DWORD           cbSize;
    DWORD           cb;

    switch (pCertId->dwIdChoice) {
        case CERT_ID_ISSUER_SERIAL_NUMBER:
            cbSize = pCertId->IssuerSerialNumber.SerialNumber.cbData;
            ICM_GetLengthOctets( cbSize, NULL, &cb);
            cbSize += cb + 1;                   // SerialNumber INTEGER
            cbSize += pCertId->IssuerSerialNumber.Issuer.cbData; // Issuer ANY
            ICM_GetLengthOctets( cbSize, NULL, &cb);
            cbSize += cb + 1;                   // IssuerSerialNumber seq
            break;
        case CERT_ID_KEY_IDENTIFIER:
            cbSize = pCertId->KeyId.cbData;
            ICM_GetLengthOctets( cbSize, NULL, &cb);
            cbSize += cb + 1;                   // KeyId OCTET STRING
            break;
        default:
            goto InvalidCertIdChoice;
    };

CommonReturn:
    return cbSize;
ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
SET_ERROR(InvalidCertIdChoice, E_INVALIDARG)
}


//+-------------------------------------------------------------------------
//  Calculate the length of the EncryptedDigest encoded blob plus the
//  algorithm identifier
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthEncryptedDigestAndAlgorithm(
    IN HCRYPTPROV                   hCryptProv,
    IN DWORD                        dwKeySpec,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiDigest,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiDigestEncrypt)
{
    DWORD       dwError = ERROR_SUCCESS;
    DWORD       cbSignature;
    DWORD       cbSize = 0;
    DWORD       cb;
    HCRYPTHASH  hHash = NULL;
    PCCRYPT_OID_INFO pOIDInfo;
    DWORD       dwAlgIdDigest;
    DWORD       dwAlgIdPubKey;
    DWORD       dwAlgIdFlags;
    CRYPT_ALGORITHM_IDENTIFIER aiDigestEncrypt;
    BOOL        fNoNullParameters;

    dwAlgIdPubKey = 0;
    dwAlgIdFlags = 0;
    if (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            paiDigestEncrypt->pszObjId,
            CRYPT_PUBKEY_ALG_OID_GROUP_ID)) {
        dwAlgIdPubKey = pOIDInfo->Algid;
        if (1 <= pOIDInfo->ExtraInfo.cbData / sizeof(DWORD)) {
            DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;
            dwAlgIdFlags = pdwExtra[0];
        }

        // Check if more than just the NULL parameters
        if (2 < paiDigestEncrypt->Parameters.cbData) {
            // Check if we should use the public key parameters
            if (0 == (dwAlgIdFlags &
                    CRYPT_OID_USE_PUBKEY_PARA_FOR_PKCS7_FLAG)) {
                memset(&aiDigestEncrypt, 0, sizeof(aiDigestEncrypt));
                aiDigestEncrypt.pszObjId = paiDigestEncrypt->pszObjId;
                paiDigestEncrypt = &aiDigestEncrypt;
            }
        }
    } else if (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            paiDigestEncrypt->pszObjId,
            CRYPT_SIGN_ALG_OID_GROUP_ID)) {
        DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;

        if (1 <= pOIDInfo->ExtraInfo.cbData / sizeof(DWORD))
            dwAlgIdPubKey = pdwExtra[0];
        if (2 <= pOIDInfo->ExtraInfo.cbData / sizeof(DWORD))
            dwAlgIdFlags = pdwExtra[1];
    }


    if (CALG_DSS_SIGN == dwAlgIdPubKey &&
            0 == (dwAlgIdFlags & CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG))
        cbSignature = CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN;
    else {
        if (dwKeySpec == 0)
            dwKeySpec = AT_SIGNATURE;

        if (!(ICM_GetCAPI(
                CRYPT_HASH_ALG_OID_GROUP_ID,
                paiDigest,
                &dwAlgIdDigest) ||
              ICM_GetCAPI(
                CRYPT_SIGN_ALG_OID_GROUP_ID,
                paiDigest,
                &dwAlgIdDigest)))
            goto DigestGetCAPIError;
        if (!CryptCreateHash(
                hCryptProv,
                dwAlgIdDigest,
                NULL,               // hKey - optional for MAC
                0,                  // dwFlags
                &hHash))
            goto CreateHashError;
        if (!CryptHashData(
                hHash,
                (PBYTE)&cb,
                sizeof(DWORD),
                0))                 // dwFlags
            goto HashDataError;

        if (CALG_NO_SIGN == dwAlgIdPubKey) {
            if (!CryptGetHashParam(
                    hHash,
                    HP_HASHVAL,
                    NULL,               // pbHash
                    &cbSignature,
                    0))                 // dwFlags
                goto GetHashParamSizeError;
        } else {
            if (!CryptSignHash(
                    hHash,
                    dwKeySpec,
                    NULL,               // description
                    0,                  // dwFlags
                    NULL,               // pb
                    &cbSignature))
                goto SignHashSizeError;
        }
    }
    ICM_GetLengthOctets( cbSignature, NULL, &cb);
    cbSize += cbSignature + cb + 1;                       // OCTET STRING

    if (0 == paiDigestEncrypt->Parameters.cbData &&
            0 != (dwAlgIdFlags & CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG))
        fNoNullParameters = TRUE;
        // NO NULL parameters
    else
        fNoNullParameters = FALSE;

    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAlgorithmIdentifier(
            paiDigestEncrypt, fNoNullParameters)))
        goto SubjectPublicKeyInfoAlgorithmError;
    cbSize += cb;

CommonReturn:
    if (hHash)
        CryptDestroyHash(hHash);
    ICM_SetLastError(dwError);
    return cbSize;

ErrorReturn:
    dwError = GetLastError();
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
SET_ERROR(DigestGetCAPIError,CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(SubjectPublicKeyInfoAlgorithmError)
TRACE_ERROR(CreateHashError)
TRACE_ERROR(HashDataError)
TRACE_ERROR(GetHashParamSizeError)
TRACE_ERROR(SignHashSizeError)
}


//+-------------------------------------------------------------------------
//  Calculate the length of the Digest encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthDigest(
    IN HCRYPTPROV                   hCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiDigest)
{
    DWORD       dwError = ERROR_SUCCESS;
    DWORD       cbSize;
    DWORD       cb;
    DWORD       dwAlgIdDigest;
    HCRYPTHASH  hHash = NULL;

    if (0 == hCryptProv) {
        if (0 == (hCryptProv = I_CryptGetDefaultCryptProv(0)))
            goto GetDefaultCryptProvError;
    }

    if (!ICM_GetCAPI(
            CRYPT_HASH_ALG_OID_GROUP_ID,
            paiDigest,
            &dwAlgIdDigest))
        goto DigestGetCAPIError;
    if (!CryptCreateHash(
            hCryptProv,
            dwAlgIdDigest,
            NULL,               // hKey - optional for MAC
            0,                  // dwFlags
            &hHash))
        goto CreateHashError;
    if (!CryptHashData(
            hHash,
            (PBYTE)&cb,
            sizeof(DWORD),
            0))                 // dwFlags
        goto HashDataError;
    if (!CryptGetHashParam(
            hHash,
            HP_HASHVAL,
            NULL,               // pbHash
            &cbSize,
            0))                 // dwFlags
        goto GetHashParamSizeError;
    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += cb + 1;                       // OCTET STRING

CommonReturn:
    if (hHash)
        CryptDestroyHash(hHash);
    ICM_SetLastError(dwError);
    return cbSize;

ErrorReturn:
    dwError = GetLastError();
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(GetDefaultCryptProvError)
SET_ERROR(DigestGetCAPIError,CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(CreateHashError)
TRACE_ERROR(HashDataError)
TRACE_ERROR(GetHashParamSizeError)
}


//+-------------------------------------------------------------------------
//  Calculate the length of the Attributes encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthAttributes(
    IN HCRYPTPROV                   hCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiDigest,
    IN DWORD                        cAttr,
    IN PCRYPT_ATTRIBUTE             rgAttr,
    IN LPSTR                        pszInnerContentObjID,
    IN BOOL                         fAuthAttr)
{
    DWORD               cbSize = 0;
    DWORD               cbAttrS;
    DWORD               cbAttr;
    DWORD               cbTmp;
    DWORD               cb;
    PCRYPT_ATTRIBUTE    patr;
    PCRYPT_ATTR_BLOB    pblobAttr;
    DWORD               i;
    DWORD               j;
    BOOL                fDataType = !pszInnerContentObjID ||
                                    (0 == strcmp( pszInnerContentObjID, pszObjIdDataType));

    for (i=cAttr, patr=rgAttr, cbAttrS=0;
            i>0;
            i--, patr++) {
        if (0 == (cbAttr = ICM_LengthObjId( patr->pszObjId)))
            goto PatrLengthObjIdError;
        for (j=patr->cValue, pblobAttr=patr->rgValue, cbTmp=0;
                j>0;
                j--, pblobAttr++)
            cbTmp += pblobAttr->cbData;
        ICM_GetLengthOctets( cbTmp, NULL, &cb);
        cbAttr += cbTmp + cb + 1;       // AttributeSetValue set
        ICM_GetLengthOctets( cbAttr, NULL, &cb);
        cbAttrS += cbAttr + cb + 1;     // Attribute seq
    }

    if (fAuthAttr && (cAttr || !fDataType)) {
        // content type
        cbAttr = ICM_LengthObjId( szOID_RSA_contentType);
        if (INVALID_ENCODING_SIZE == (cbTmp = ICM_LengthObjId(
                        pszInnerContentObjID ?
                        pszInnerContentObjID : pszObjIdDataType)))
            goto InnerContentLengthObjIdError;
        ICM_GetLengthOctets( cbTmp, NULL, &cb);
        cbAttr += cbTmp + cb + 1;       // AttributeSetValue set
        ICM_GetLengthOctets( cbAttr, NULL, &cb);
        cbAttrS += cbAttr + cb + 1;     // Attribute seq

        // message digest
        cbAttr = ICM_LengthObjId( szOID_RSA_messageDigest);
        if (INVALID_ENCODING_SIZE == (cbTmp = ICM_LengthDigest( hCryptProv, paiDigest)))
            goto LengthDigestError;
        ICM_GetLengthOctets( cbTmp, NULL, &cb);
        cbAttr += cbTmp + cb + 1;       // AttributeSetValue set
        ICM_GetLengthOctets( cbAttr, NULL, &cb);
        cbAttrS += cbAttr + cb + 1;     // Attribute seq
    }

    if (cbAttrS) {
        ICM_GetLengthOctets( cbAttrS, NULL, &cb);
        cbSize = cbAttrS + cb + 1;          // Attributes set
    }

CommonReturn:
    return cbSize;

ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(PatrLengthObjIdError)           // error already set
TRACE_ERROR(InnerContentLengthObjIdError)   // error already set
TRACE_ERROR(LengthDigestError)              // error already set
}


//+-------------------------------------------------------------------------
//  Calculate the length of the SignerInfos encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthSignerInfos(
    IN DWORD                    cSigners,
    IN PCMSG_SIGNER_ENCODE_INFO rgSigners,
    IN LPSTR                    pszInnerContentObjID
#ifdef CMS_PKCS7
    ,
    OUT BOOL                    *pfHasCmsSignerId
#endif  // CMS_PKCS7
    )
{
    DWORD                       cbSize;
    DWORD                       cbSigner;
    DWORD                       cbSignerS;
    DWORD                       cb;
    PCMSG_SIGNER_ENCODE_INFO    psei;
    DWORD                       i;
    PCRYPT_ALGORITHM_IDENTIFIER paiDigestEncrypt;
    CERT_ID                     SignerId;

#ifdef CMS_PKCS7
    *pfHasCmsSignerId = FALSE;
#endif  // CMS_PKCS7

    for (i=cSigners, psei=rgSigners, cbSignerS=0;
            i>0;
            i--,
#ifdef CMS_PKCS7
            psei = (PCMSG_SIGNER_ENCODE_INFO) ((BYTE *) psei + psei->cbSize)) {
#else
            psei++) {
#endif  // CMS_PKCS7
        cbSigner = 1 + 1 + 1;               // version

        if (!ICM_GetSignerIdFromSignerEncodeInfo(psei, &SignerId))
            goto GetSignerIdError;
#ifdef CMS_PKCS7
        if (CERT_ID_ISSUER_SERIAL_NUMBER != SignerId.dwIdChoice)
            *pfHasCmsSignerId = TRUE;
#endif  // CMS_PKCS7
        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthCertId( &SignerId)))
            goto CertIdError;
        cbSigner += cb;
        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAlgorithmIdentifier( &psei->HashAlgorithm)))
            goto HashAlgorithmError;
        cbSigner += cb;
        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAttributes(
                            psei->hCryptProv,
                            &psei->HashAlgorithm,
                            psei->cAuthAttr,
                            psei->rgAuthAttr,
                            pszInnerContentObjID,
                            TRUE)))
            goto AuthAttributesError;
        cbSigner += cb;
#ifdef CMS_PKCS7
    if (STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO, HashEncryptionAlgorithm) <=
            psei->cbSize && psei->HashEncryptionAlgorithm.pszObjId)
        paiDigestEncrypt = &psei->HashEncryptionAlgorithm;
    else
#endif  // CMS_PKCS7
        paiDigestEncrypt = &psei->pCertInfo->SubjectPublicKeyInfo.Algorithm;

        if (INVALID_ENCODING_SIZE == (cb =
                        ICM_LengthEncryptedDigestAndAlgorithm(
                            psei->hCryptProv,
                            psei->dwKeySpec,
                            &psei->HashAlgorithm,
                            paiDigestEncrypt)))
            goto EncryptedDigestError;
        cbSigner += cb;
        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAttributes(
                            NULL,
                            NULL,
                            psei->cUnauthAttr,
                            psei->rgUnauthAttr,
                            NULL,
                            FALSE)))
            goto UnauthAttributesError;
        cbSigner += cb;
        ICM_GetLengthOctets( cbSigner, NULL, &cb);
        cbSignerS += cbSigner + cb + 1;     // SignerInfo seq
    }
    ICM_GetLengthOctets( cbSignerS, NULL, &cb);
    cbSize = cbSignerS + cb + 1;            // SignerInfo seq

CommonReturn:
    return cbSize;

ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(GetSignerIdError)                       // error already set
TRACE_ERROR(CertIdError)                            // error already set
TRACE_ERROR(HashAlgorithmError)                     // error already set
TRACE_ERROR(AuthAttributesError)                    // error already set
TRACE_ERROR(UnauthAttributesError)                  // error already set
TRACE_ERROR(EncryptedDigestError)                   // error already set
}


//+-------------------------------------------------------------------------
//  Calculate the length of the SignedData.digestAlgorithms encoded blob.
//
#ifndef CMS_PKCS7
//  Assumes no duplicate removal. OK for single-signer case, which
//  is only one currently supported.
#endif
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthSignedDigestAlgorithms(
    IN DWORD                    cSigners,
    IN PCMSG_SIGNER_ENCODE_INFO rgSigners)
{
    DWORD                       cbSize;
    DWORD                       cbAlgoS;
    DWORD                       cb;
    PCMSG_SIGNER_ENCODE_INFO    psei;
    DWORD                       i;

#ifdef CMS_PKCS7
    for (i=cSigners, psei=rgSigners, cbAlgoS=0; i>0;
            i--,
            psei = (PCMSG_SIGNER_ENCODE_INFO) ((BYTE *) psei + psei->cbSize)) {
        assert(STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO, rgUnauthAttr) <=
            psei->cbSize);
        if (ICM_IsDuplicateSignerEncodeHashAlgorithm(
                rgSigners,
                psei
                ))
            continue;

        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAlgorithmIdentifier( &psei->HashAlgorithm)))
            goto HashAlgorithmError;
        cbAlgoS += cb;
    }
#else
    for (i=cSigners, psei=rgSigners, cbAlgoS=0;
            i>0;
            i--, psei++) {
        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAlgorithmIdentifier( &psei->HashAlgorithm)))
            goto HashAlgorithmError;
        cbAlgoS += cb;
    }
#endif  // CMS_PKCS7
    ICM_GetLengthOctets( cbAlgoS, NULL, &cb);
    cbSize = cbAlgoS + cb + 1;            // digestAlgorithms set

CommonReturn:
    return cbSize;

ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(HashAlgorithmError)     // error already set
}

#ifdef CMS_PKCS7

//+-------------------------------------------------------------------------
//  Calculate the length of an enveloped message.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthEnveloped(
    IN PCMSG_ENVELOPED_ENCODE_INFO  pemei,
    IN DWORD                        dwFlags,
    IN OPTIONAL LPSTR               pszInnerContentObjID,
    IN DWORD                        cbData,
    OUT OPTIONAL PDWORD             pcbContent)
{
    DWORD dwError = ERROR_SUCCESS;
    DWORD cbSize;
    DWORD cb;

    CMSG_CONTENT_ENCRYPT_INFO ContentEncryptInfo;
        ZEROSTRUCT(ContentEncryptInfo);
    CmsRecipientInfos recipientInfos; ZEROSTRUCT(recipientInfos);
#ifdef OSS_CRYPT_ASN1
    int version = 0;
#else
    ASN1int32_t version = 0;
#endif  // OSS_CRYPT_ASN1

    ASN1error_e Asn1Err;
    ASN1encoding_t pEnc = ICM_GetEncoder();
    PBYTE pbEncoded = NULL;
    DWORD cbEncoded;

    assert(pemei->cbSize >= STRUCT_CBSIZE(CMSG_ENVELOPED_ENCODE_INFO,
        rgpRecipients));
#ifdef CMS_PKCS7
    if (pemei->cbSize <
                STRUCT_CBSIZE(CMSG_ENVELOPED_ENCODE_INFO, rgpRecipients))
#else
    assert(0 != pemei->cRecipients);
    if (pemei->cbSize <
                STRUCT_CBSIZE(CMSG_ENVELOPED_ENCODE_INFO, rgpRecipients) ||
            0 == pemei->cRecipients)
#endif  // CMS_PKCS7
        goto InvalidArg;

    // version
    cbSize = 1 + 1 + 1;

    // originatorInfo OPTIONAL
    //
    // unprotectedAttrs OPTIONAL
    if (pemei->cbSize >= sizeof(CMSG_ENVELOPED_ENCODE_INFO)) {
        DWORD cbOriginator = 0;
        DWORD cbTmp;
        DWORD i;
        PCERT_BLOB pCert;
        PCRL_BLOB pCrl;
        cbOriginator = 0;

        for (i = pemei->cCertEncoded, pCert = pemei->rgCertEncoded, cbTmp=0;
                i > 0;
                i--, pCert++)
            cbTmp += pCert->cbData;
        for (i = pemei->cAttrCertEncoded, pCert = pemei->rgAttrCertEncoded;
                i > 0;
                i--, pCert++)
            cbTmp += pCert->cbData;
        if (cbTmp) {
            ICM_GetLengthOctets(cbTmp, NULL, &cb);
            cbOriginator += 1 + cb + cbTmp;     // [0] IMPLICIT Certificates
        }

        for (i = pemei->cCrlEncoded, pCrl = pemei->rgCrlEncoded, cbTmp=0;
                i > 0;
                i--, pCrl++)
            cbTmp += pCrl->cbData;
        if (cbTmp) {
            ICM_GetLengthOctets(cbTmp, NULL, &cb);
            cbOriginator += 1 + cb + cbTmp;     // [1] IMPLICIT Crls
        }

        if (cbOriginator) {
            ICM_GetLengthOctets(cbOriginator, NULL, &cb);
            cbSize += 1 + cb + cbOriginator; // [0] IMPLICIT OriginatorInfo
        }

        if (0 < pemei->cUnprotectedAttr) {
            if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAttributes(
                                NULL,
                                NULL,
                                pemei->cUnprotectedAttr,
                                pemei->rgUnprotectedAttr,
                                NULL,
                                FALSE)))
                goto UnprotectedAttrError;
            cbSize += cb;
        }
    }

    // recipientInfos
    if (!ICM_InitializeContentEncryptInfo(pemei, &ContentEncryptInfo))
        goto InitializeContentEncryptInfoError;
    ContentEncryptInfo.dwEncryptFlags |=
        CMSG_CONTENT_ENCRYPT_PAD_ENCODED_LEN_FLAG;
    if (!ICM_FillOssCmsRecipientInfos(
            &ContentEncryptInfo,
            &recipientInfos,
            &version
            ))
        goto FillOssCmsRecipientInfosError;
    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            &recipientInfos,
            CmsRecipientInfos_PDU,
            &pbEncoded,
            &cbEncoded)))
        goto EncodeCmsRecipientInfosError;
    cbSize += cbEncoded;

    // encryptedContentInfo
    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthEncryptedContentInfo(
                    ContentEncryptInfo.hContentEncryptKey,
                    &ContentEncryptInfo.ContentEncryptionAlgorithm,
                    pszInnerContentObjID,
                    cbData)))
        goto LengthEncryptedContentInfoError;
    cbSize += cb;

    if (pcbContent)
        *pcbContent = cbSize;

    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += 1 + cb;                           // CmsEnvelopedData seq

CommonReturn:
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    ICM_FreeContentEncryptInfo(pemei, &ContentEncryptInfo);
    ICM_FreeOssCmsRecipientInfos(&recipientInfos);

    ICM_SetLastError(dwError);
    return cbSize;

ErrorReturn:
    dwError = GetLastError();
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
SET_ERROR(InvalidArg,E_INVALIDARG)
TRACE_ERROR(UnprotectedAttrError)
TRACE_ERROR(InitializeContentEncryptInfoError)
TRACE_ERROR(FillOssCmsRecipientInfosError)
SET_ERROR_VAR(EncodeCmsRecipientInfosError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(LengthEncryptedContentInfoError)
}
#else


//+-------------------------------------------------------------------------
//  Calculate the length of the EncryptedKey encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthEncryptedKey(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    IN DWORD                        dwEncryptFlags)
{
    DWORD cbSize;
    // rgcbEncryptedKey[1] contains dwEncryptFlags
    DWORD rgcbEncryptedKey[2];
    DWORD cb;

    rgcbEncryptedKey[1] = dwEncryptFlags;

    // Length only export calculation
    if (!ICM_ExportEncryptKey(
            hCryptProv,
            hEncryptKey,
            pPublicKeyInfo,
            NULL,               // pbData
            rgcbEncryptedKey) || 0 == rgcbEncryptedKey[0])
        goto ExportKeyError;

    // Add bytes for ASN.1 tag and length
    ICM_GetLengthOctets(rgcbEncryptedKey[0], NULL, &cb);
    cbSize = rgcbEncryptedKey[0] + cb + 1;       // OCTET STRING

CommonReturn:
    return cbSize;

ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(ExportKeyError)
}


//+-------------------------------------------------------------------------
//  Calculate the length of the RecipientInfos encoded blob.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthRecipientInfos(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN DWORD                        cRecipients,
    IN PCERT_INFO                   *rgpRecipients,
    IN DWORD                        dwEncryptFlags)
{
    DWORD       cbSize;
    DWORD       cbRecipient;
    DWORD       cbRecipientS;
    DWORD       cb;
    PCERT_INFO  *ppCertInfo;
    DWORD       i;

    for (i=cRecipients, ppCertInfo=rgpRecipients, cbRecipientS=0;
            i>0;
            i--, ppCertInfo++) {
        cbRecipient = 1 + 1 + 1;                // version
        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthIssuerAndSerialNumber( *ppCertInfo)))
            goto IssuerAndSerialNumberError;
        cbRecipient += cb;
        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAlgorithmIdentifier(
                            &(*ppCertInfo)->SubjectPublicKeyInfo.Algorithm)))
            goto SubjectPublicKeyInfoAlgorithmError;
        cbRecipient += cb;
        if (INVALID_ENCODING_SIZE == (cb = ICM_LengthEncryptedKey(
                            hCryptProv,
                            hEncryptKey,
                            &(*ppCertInfo)->SubjectPublicKeyInfo,
                            dwEncryptFlags)))
            goto EncryptedKeyError;
        cbRecipient += cb;
        ICM_GetLengthOctets( cbRecipient, NULL, &cb);
        cbRecipientS += cbRecipient + cb + 1;   // RecipientInfo
    }
    ICM_GetLengthOctets( cbRecipientS, NULL, &cb);
    cbSize = cbRecipientS + cb + 1;             // RecipientInfos seq

CommonReturn:
    return cbSize;

ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(IssuerAndSerialNumberError)             // error already set
TRACE_ERROR(SubjectPublicKeyInfoAlgorithmError)     // error already set
TRACE_ERROR(EncryptedKeyError)                      // error already set
}


//+-------------------------------------------------------------------------
//  Calculate the length of an enveloped message.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthEnveloped(
    IN PCMSG_ENVELOPED_ENCODE_INFO  pemei,
    IN DWORD                        dwFlags,
    IN OPTIONAL LPSTR               pszInnerContentObjID,
    IN DWORD                        cbData,
    OUT OPTIONAL PDWORD             pcbContent)
{
    DWORD       dwError = ERROR_SUCCESS;
    DWORD       cbSize;
    DWORD       cb;
    HCRYPTPROV  hCryptProv;
    HCRYPTKEY   hEncryptKey = NULL;

    CRYPT_ALGORITHM_IDENTIFIER  ContentEncryptionAlgorithm;
    PBYTE                       pbEncryptParameters = NULL;

    // rgcbEncryptParameters[1] contains dwEncryptFlags
    DWORD                       rgcbEncryptParameters[2];

    // version
    cbSize = 1 + 1 + 1;

    if (0 == pemei->cRecipients)
        goto InvalidArg;
    hCryptProv = pemei->hCryptProv;

    ContentEncryptionAlgorithm = pemei->ContentEncryptionAlgorithm;
    rgcbEncryptParameters[0] = 0;
    rgcbEncryptParameters[1] = 0;   // dwEncryptFlags
    if (!ICM_GenEncryptKey(
            &hCryptProv,
            &ContentEncryptionAlgorithm,
            pemei->pvEncryptionAuxInfo,
            &pemei->rgpRecipients[0]->SubjectPublicKeyInfo,
            ICM_Alloc,
            &hEncryptKey,
            &pbEncryptParameters,
            rgcbEncryptParameters))
        goto GenKeyError;
    if (rgcbEncryptParameters[0] && pbEncryptParameters) {
        ContentEncryptionAlgorithm.Parameters.pbData = pbEncryptParameters;
        ContentEncryptionAlgorithm.Parameters.cbData = rgcbEncryptParameters[0];
    }

    // recipientInfos
    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthRecipientInfos(
                    hCryptProv,
                    hEncryptKey,
                    pemei->cRecipients,
                    pemei->rgpRecipients,
                    rgcbEncryptParameters[1])))     // dwEncryptFlags
        goto LengthRecipientInfosError;
    cbSize += cb;

    // encryptedContentInfo
    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthEncryptedContentInfo(
                    hEncryptKey,
                    &ContentEncryptionAlgorithm,
                    pszInnerContentObjID,
                    cbData)))
        goto LengthEncryptedContentInfoError;
    cbSize += cb;

    if (pcbContent)
        *pcbContent = cbSize;

    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += 1 + cb;                           // EnvelopedData seq

CommonReturn:
    if (hEncryptKey)
        CryptDestroyKey(hEncryptKey);
    ICM_Free(pbEncryptParameters);
    ICM_SetLastError(dwError);
    return cbSize;

ErrorReturn:
    dwError = GetLastError();
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
SET_ERROR(InvalidArg,E_INVALIDARG)
TRACE_ERROR(GenKeyError)
TRACE_ERROR(LengthRecipientInfosError)
TRACE_ERROR(LengthEncryptedContentInfoError)
}

#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Calculate the length of a signed message.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthSigned(
    IN PCMSG_SIGNED_ENCODE_INFO psmei,
    IN DWORD                    dwFlags,
    IN OPTIONAL LPSTR           pszInnerContentObjID,
    IN DWORD                    cbData,
    OUT OPTIONAL PDWORD         pcbContent)
{
    DWORD                       cbSize;
    DWORD                       cbSignedData;
    DWORD                       cbTmp;
    DWORD                       cb;
    DWORD                       i;
    PCERT_BLOB                  pCert;
    PCRL_BLOB                   pCrl;

#ifdef CMS_PKCS7
    DWORD                       cAttrCertEncoded;
    BOOL                        fHasCmsSignerId = FALSE;
#endif  // CMS_PKCS7

    cbSignedData = 1 + 1 + 1;           // version

    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthSignedDigestAlgorithms(
                    psmei->cSigners,
                    psmei->rgSigners)))
        goto LengthSignedDigestAlgorithmsError;
    cbSignedData += cb;

#ifdef CMS_PKCS7
    if (psmei->cbSize >= STRUCT_CBSIZE(CMSG_SIGNED_ENCODE_INFO,
            rgAttrCertEncoded)) {
        cAttrCertEncoded = psmei->cAttrCertEncoded;

        if (cAttrCertEncoded)
            dwFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
    } else
        cAttrCertEncoded = 0;
#endif  // CMS_PKCS7

    // Do this before the ContentInfo. Need to know if we need to
    // encapsulate the content for KeyId Signers.
    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthSignerInfos(
                    psmei->cSigners,
                    psmei->rgSigners,
                    pszInnerContentObjID
#ifdef CMS_PKCS7
                    ,
                    &fHasCmsSignerId
#endif  // CMS_PKCS7
                    )))
        goto SignerInfosError;
    cbSignedData += cb;
#ifdef CMS_PKCS7
    if (fHasCmsSignerId)
        dwFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
#endif  // CMS_PKCS7

    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthContentInfo(
                    dwFlags,
                    pszInnerContentObjID,
                    cbData,
                    NULL)))
        goto LengthContentInfoError;
    cbSignedData += cb;

    for (i = psmei->cCertEncoded, pCert = psmei->rgCertEncoded, cbTmp=0;
            i > 0;
            i--, pCert++)
        cbTmp += pCert->cbData;

#ifdef CMS_PKCS7
    if (cAttrCertEncoded) {
        for (i = cAttrCertEncoded, pCert = psmei->rgAttrCertEncoded;
                i > 0;
                i--, pCert++)
            cbTmp += pCert->cbData;
    }
#endif  // CMS_PKCS7

    if (cbTmp) {
        ICM_GetLengthOctets( cbTmp, NULL, &cb);
        cbSignedData += 1 + cb + cbTmp;     // [0] IMPLICIT Certificates
    }

    for (i = psmei->cCrlEncoded, pCrl = psmei->rgCrlEncoded, cbTmp=0;
            i > 0;
            i--, pCrl++)
        cbTmp += pCrl->cbData;
    if (cbTmp) {
        ICM_GetLengthOctets( cbTmp, NULL, &cb);
        cbSignedData += 1 + cb + cbTmp;     // [1] IMPLICIT Crls
    }

    if (pcbContent)
        *pcbContent = cbSignedData;

    ICM_GetLengthOctets( cbSignedData, NULL, &cb);
    cbSize = 1 + cb + cbSignedData;     // SignedData seq

CommonReturn:
    return cbSize;

ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(LengthSignedDigestAlgorithmsError)  // error already set
TRACE_ERROR(LengthContentInfoError)             // error already set
TRACE_ERROR(SignerInfosError)                   // error already set
}


//+-------------------------------------------------------------------------
//  Calculate the length of a digested message.
//--------------------------------------------------------------------------
DWORD
WINAPI
ICM_LengthDigested(
    IN PCMSG_HASHED_ENCODE_INFO pdmei,
    IN DWORD                    dwFlags,
    IN OPTIONAL LPSTR           pszInnerContentObjID,
    IN DWORD                    cbData,
    OUT OPTIONAL PDWORD         pcbContent)
{
    DWORD       cbSize;
    DWORD       cb;

    cbSize = 1 + 1 + 1;             // version

    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthAlgorithmIdentifier( &pdmei->HashAlgorithm)))
        goto HashAlgorithmError;
    cbSize += cb;

    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthContentInfo(
                    dwFlags,
                    pszInnerContentObjID,
                    cbData,
                    NULL)))
        goto LengthContentInfoError;
    cbSize += cb;

    if (INVALID_ENCODING_SIZE == (cb = ICM_LengthDigest( pdmei->hCryptProv, &pdmei->HashAlgorithm)))
        goto DigestError;
    cbSize += cb;

    if (pcbContent)
        *pcbContent = cbSize;

    ICM_GetLengthOctets( cbSize, NULL, &cb);
    cbSize += 1 + cb;               // DigestedData seq

CommonReturn:
    return cbSize;

ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
TRACE_ERROR(HashAlgorithmError)     // error already set
TRACE_ERROR(LengthContentInfoError) // error already set
TRACE_ERROR(DigestError)            // error already set
}

//+-------------------------------------------------------------------------
//  Calculate the length of an encoded cryptographic message.
//
//  Calculates the length of the encoded message given the
//  message type, encoding parameters and total length of
//  the data to be updated. Note, this might not be the exact length.
//  However, it will always be greater than or equal to the actual length.
//--------------------------------------------------------------------------
DWORD
WINAPI
CryptMsgCalculateEncodedLength(
    IN DWORD            dwEncodingType,
    IN DWORD            dwFlags,
    IN DWORD            dwMsgType,
    IN void const       *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR   pszInnerContentObjID,
    IN DWORD            cbData)
{
    DWORD   cbSize = INVALID_ENCODING_SIZE;
    LPSTR   pszContentType = NULL;
    DWORD   cb;
    DWORD   cbContent = 0;

    if (GET_CMSG_ENCODING_TYPE(dwEncodingType) != PKCS_7_ASN_ENCODING)
        goto InvalidEncoding;

    switch (dwMsgType) {
    case CMSG_DATA:
        if (NULL != pvMsgEncodeInfo)
            goto InvalidEncodeInfo;
        cbContent = cbData;
        ICM_GetLengthOctets( cbData, NULL, &cb);
        cbSize = 1 + cb + cbData;       // OCTET STRING
        pszContentType = pszObjIdDataType;
        break;

    case CMSG_SIGNED:
        if (INVALID_ENCODING_SIZE == (cbSize = ICM_LengthSigned(
                                (PCMSG_SIGNED_ENCODE_INFO)pvMsgEncodeInfo,
                                dwFlags,
                                pszInnerContentObjID,
                                cbData,
                                &cbContent)))
            goto LengthSignedError;
        pszContentType = szOID_RSA_signedData;
        break;

    case CMSG_ENVELOPED:
        if (INVALID_ENCODING_SIZE == (cbSize = ICM_LengthEnveloped(
                                (PCMSG_ENVELOPED_ENCODE_INFO)pvMsgEncodeInfo,
                                dwFlags,
                                pszInnerContentObjID,
                                cbData,
                                &cbContent)))
            goto LengthEnvelopedError;
        pszContentType = szOID_RSA_envelopedData;
        break;

    case CMSG_HASHED:
        if (INVALID_ENCODING_SIZE == (cbSize = ICM_LengthDigested(
                                (PCMSG_HASHED_ENCODE_INFO)pvMsgEncodeInfo,
                                dwFlags,
                                pszInnerContentObjID,
                                cbData,
                                &cbContent)))
            goto LengthDigestedError;
        pszContentType = szOID_RSA_digestedData;
        break;

    case CMSG_SIGNED_AND_ENVELOPED:
    case CMSG_ENCRYPTED:
        goto MessageTypeNotSupportedYet;

    default:
        goto InvalidMsgType;
    }

    if (0 == (dwFlags & CMSG_BARE_CONTENT_FLAG)) {
        if (INVALID_ENCODING_SIZE == (cbSize = ICM_LengthContentInfo(
                            0,                      // dwFlags
                            pszContentType,
                            cbSize,
                            &cbContent)))
            goto LengthContentInfoError;
    }

CommonReturn:
    return (cbSize == INVALID_ENCODING_SIZE) ? 0 :
           ((dwFlags & CMSG_CONTENTS_OCTETS_FLAG) ? cbContent : cbSize);

ErrorReturn:
    cbSize = INVALID_ENCODING_SIZE;
    goto CommonReturn;
SET_ERROR(InvalidEncoding,E_INVALIDARG)
SET_ERROR(InvalidEncodeInfo,E_INVALIDARG)
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
TRACE_ERROR(LengthSignedError)              // error already set
TRACE_ERROR(LengthEnvelopedError)           // error already set
TRACE_ERROR(LengthDigestedError)            // error already set
TRACE_ERROR(LengthContentInfoError)         // error already set
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\wincrmsg\msgstrm.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       msgstrm.cpp
//
//  Contents:   Cryptographic Message Streaming API support
//
//  APIs:       
//
//  History:    20-Feb-97   kevinr    created
//
//--------------------------------------------------------------------------

#include "global.hxx"

#define ICMS_NOCRYPT 0

#if (DBG && ICMS_NOCRYPT)
#define CryptEncrypt ICMS_PlainEncrypt
#define CryptDecrypt ICMS_PlainDecrypt

//+-------------------------------------------------------------------------
//  Encrypt a buffer using a NOP algorithm, ie. ciphertext == plaintext
//  Assumes that all but the last block are a multiple of the block
//  size in length.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_PlainEncrypt(
    IN HCRYPTKEY    hkeyCrypt,
    IN HCRYPTHASH   hHash,
    IN BOOL         fFinal,
    IN DWORD        dwFlags,
    IN OUT PBYTE    pbData,
    IN OUT PDWORD   pcbData,
    IN DWORD        cbBuf)
{
    BOOL        fRet;
    DWORD       cbBlockLen;
    BOOL        fBlockCipher;
    DWORD       cbCipher;
    DWORD       cbPlain = *pcbData;
    DWORD       cbPad;
    DWORD       i;

    if (!fFinal)
        goto SuccessReturn;

    if (!ICM_GetKeyBlockSize( hkeyCrypt, &cbBlockLen, &fBlockCipher))
        goto GetKeyBlockSizeError;
    if (!fBlockCipher)
        goto SuccessReturn;             // if stream, cipher == plain

    cbCipher  = cbPlain;
    cbCipher += cbBlockLen;
    cbCipher -= cbCipher % cbBlockLen; // make a multiple of block size
    cbPad     = cbCipher - cbPlain;

    if (cbCipher > cbBuf)
        goto BufferTooSmallError;

    // pad the "ciphertext"
    FillMemory( pbData + cbPlain, cbPad, cbPad);
    *pcbData = cbCipher;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
	return fRet;

ErrorReturn:
	fRet = FALSE;
	goto CommonReturn;
TRACE_ERROR(GetKeyBlockSizeError)       // error already set
TRACE_ERROR(BufferTooSmallError)        // error already set
}


//+-------------------------------------------------------------------------
//  Decrypt a buffer using a NOP algorithm, ie. ciphertext == plaintext
//  Assumes all input sizes are multiples of the block size.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_PlainDecrypt(
    IN HCRYPTKEY    hkeyCrypt,
    IN HCRYPTHASH   hHash,
    IN BOOL         fFinal,
    IN DWORD        dwFlags,
    IN OUT PBYTE    pbData,
    IN OUT PDWORD   pcbData)
{
    BOOL        fRet;
    PBYTE       pb;
    DWORD       cbBlockLen;
    BOOL        fBlockCipher;
    DWORD       cbCipher = *pcbData;
    DWORD       cbPlain;
    DWORD       cbPad;

    if (!fFinal)
        goto SuccessReturn;

    if (!ICM_GetKeyBlockSize( hkeyCrypt, &cbBlockLen, &fBlockCipher))
        goto GetKeyBlockSizeError;
    if (!fBlockCipher)
        goto SuccessReturn;             // if stream, cipher == plain

    cbPad = (DWORD)(*(pbData + cbCipher - 1));  // check last byte

    if (cbCipher < cbPad)
        goto CipherTextTooSmallError;

    cbPlain = cbCipher - cbPad;
    *pcbData = cbPlain;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
	return fRet;

ErrorReturn:
	fRet = FALSE;
	goto CommonReturn;
TRACE_ERROR(GetKeyBlockSizeError)       // error already set
TRACE_ERROR(CipherTextTooSmallError)    // error already set
}
#endif  // (DBG && ICMS_NOCRYPT)


//+-------------------------------------------------------------------------
//  Do a CryptMsgGetParam to a buffer alloc'd by ICM_Alloc
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_AllocGetParam(
    IN HCRYPTMSG    hCryptMsg,
    IN DWORD        dwParamType,
    IN DWORD        dwIndex,
    OUT PBYTE       *ppbData,
    OUT DWORD       *pcbData)
{
    BOOL    fRet;
    DWORD   cb;
    PBYTE   pb = NULL;
    
    if (!CryptMsgGetParam(
            hCryptMsg,
            dwParamType,
            dwIndex,
            NULL,
            &cb))
        goto GetEncodedSizeError;
    if (NULL == (pb = (PBYTE)ICM_Alloc(cb)))
        goto AllocEncodedError;
    if (!CryptMsgGetParam(
            hCryptMsg,
            dwParamType,
            dwIndex,
            pb,
            &cb))
        goto GetEncodedError;

    fRet = TRUE;
CommonReturn:
    *ppbData = pb;
    *pcbData = cb;
	return fRet;

ErrorReturn:
    ICM_Free(pb);
    pb = NULL;
    cb = 0;
	fRet = FALSE;
	goto CommonReturn;
TRACE_ERROR(GetEncodedSizeError)
TRACE_ERROR(AllocEncodedError)
TRACE_ERROR(GetEncodedError)
}


//+-------------------------------------------------------------------------
//  Peel off the identifier and length octets.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_ExtractContent(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbDER,
    IN DWORD            cbDER,
    OUT PDWORD          pcbContent,
    OUT const BYTE      **ppbContent)
{
    BOOL        fRet;
    LONG        cbSkipped = 0;
    DWORD       cbEntireContent;

    if (!pcmi->fStreamContentExtracted) {
        if (0 > (cbSkipped = Asn1UtilExtractContent(
                                    pbDER,
                                    cbDER,
                                    &cbEntireContent,
                                    ppbContent)))
            goto ExtractContentError;
        pcmi->fStreamContentExtracted = TRUE;
    } else {
        *ppbContent = pbDER;
    }

    *pcbContent = cbDER - cbSkipped;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(ExtractContentError)        // error already set
}


//+-------------------------------------------------------------------------
//  Get the next token from the buffer.
//  If the encoding is definite-length, set *pcbContent to be the size of the
//  contents octets.
//
//  Here, a "token" is either identifier/length octets, or the double-NULL
//  terminating an indefinite-length encoding.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_GetToken(
    IN PICM_BUFFER      pbuf,
    OUT PDWORD          pdwToken,
    OUT OPTIONAL PDWORD pcbContent)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    DWORD       dwToken;
    LONG        lth;
    DWORD       cbContent = 0;
    const BYTE  *pbContent;
    PBYTE       pbData = pbuf->pbData + pbuf->cbDead;
    DWORD       cbData = pbuf->cbUsed - pbuf->cbDead;
    DWORD       cbConsumed = 0;

    if (2 > cbData) {
        dwToken = ICMS_TOKEN_INCOMPLETE;
    } else if (0 == pbData[0] && 0 == pbData[1]) {
        dwToken = ICMS_TOKEN_NULLPAIR;
        cbConsumed = 2;
    } else {
        if (0 > (lth = Asn1UtilExtractContent(
                            pbData,
                            cbData,
                            &cbContent,
                            &pbContent))) {
            if (ASN1UTIL_INSUFFICIENT_DATA != lth)
                goto ExtractContentError;
            dwToken = ICMS_TOKEN_INCOMPLETE;
        } else {
            dwToken = (CMSG_INDEFINITE_LENGTH == cbContent) ?
                      ICMS_TOKEN_INDEFINITE : ICMS_TOKEN_DEFINITE;
            cbConsumed = (DWORD)lth;
        }
    }

    if (ICMS_TOKEN_INCOMPLETE != dwToken)
        pbuf->cbDead += cbConsumed;

    fRet = TRUE;
CommonReturn:
    *pdwToken = dwToken;
    if (pcbContent)
        *pcbContent = cbContent;
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    dwToken   = 0;
    cbContent = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(ExtractContentError)            // error already set
}


//+-------------------------------------------------------------------------
//  Process incremental content data, for a string.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_ProcessStringContent(
    IN PICM_BUFFER      pbuf,
    IN OUT PDWORD       paflStream,
    IN OUT PDWORD       pcbPending,
    IN OUT PDWORD       pcLevelIndefiniteInner,
    IN POSTRCALLBACK    postrcbk,
    IN const void       *pvArg)
{
    BOOL        fRet;
    DWORD       dwToken;
    DWORD       cbContent;

    while (TRUE) {
        if (*pcbPending) {
            // *pcbPending bytes need to be processed, so we process
            // as many as possible from the buffer.
            if (!postrcbk( pvArg, pbuf, pcbPending, FALSE))
                goto CallbackError;
        }

        if (0 == *pcbPending) {
            // No bytes currently counted for processing. One of:
            // 1. first time through
            // 2. last time through
            // 3. nested within an indefinite-length encoding
            if (0 == *pcLevelIndefiniteInner) {
                // The first time through, and also when we have processed the
                // entire octet string, we get here. The flag is clear
                // the first time (so we set it after getting a token, which
                // either sets *pcbPending or bumps *pcLevelIndefiniteInner),
                // and set afterwards (so we mark done and bail).
                if (*paflStream & ICMS_PROCESS_CONTENT_BEGUN) {
                    // 2. last time through
                    if (!postrcbk( pvArg, pbuf, pcbPending, TRUE))
                        goto CallbackFinalError;
                    *paflStream |= ICMS_PROCESS_CONTENT_DONE;
                    goto SuccessReturn;                         // All done
                }
            }
            // One of:
            // 1. first time through
            // 3. nested within an indefinite-length encoding
            if (!ICMS_GetToken( pbuf, &dwToken, &cbContent))
                goto GetTokenError;
            switch(dwToken) {
            case ICMS_TOKEN_INDEFINITE: ++*pcLevelIndefiniteInner;  break;
            case ICMS_TOKEN_NULLPAIR:   --*pcLevelIndefiniteInner;  break;
            case ICMS_TOKEN_DEFINITE:   *pcbPending = cbContent;    break;
            case ICMS_TOKEN_INCOMPLETE: goto SuccessReturn;     // need input
            default:                    goto InvalidTokenError;
            }

            *paflStream |= ICMS_PROCESS_CONTENT_BEGUN;
        } else {
            // More definite-length data remains to be copied out, but it
            // is not yet in the buffer.
            break;
        }
    }

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(InvalidTokenError)                 // error already set
TRACE_ERROR(GetTokenError)                     // error already set
TRACE_ERROR(CallbackError)                     // error already set
TRACE_ERROR(CallbackFinalError)                // error already set
}


//+-------------------------------------------------------------------------
//  Queue data to the buffer.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_QueueToBuffer(
    IN PICM_BUFFER      pbuf,
    IN PBYTE            pbData,
    IN DWORD            cbData)
{
    BOOL            fRet;
    DWORD           cbNewSize;
    DWORD           cbNewUsed;

    if (0 == cbData)
        goto SuccessReturn;

    if (pbuf->pbData && pbuf->cbDead) {
        // Move the still-active bytes up to the front of the buffer.
        // NB- Might overlap, so use MoveMemory.
        MoveMemory(
                pbuf->pbData,
                pbuf->pbData + pbuf->cbDead,
                pbuf->cbUsed - pbuf->cbDead);
        pbuf->cbUsed -= pbuf->cbDead;
        pbuf->cbDead  = 0;
    }

    for (cbNewUsed=pbuf->cbUsed + cbData, cbNewSize=pbuf->cbSize;
            cbNewUsed > cbNewSize;
            cbNewSize += ICM_BUFFER_SIZE_INCR)
        ;
    if (cbNewSize > pbuf->cbSize) {
        if (NULL == (pbuf->pbData=(PBYTE)ICM_ReAlloc( pbuf->pbData, cbNewSize)))
            goto ReAllocBufferError;
        pbuf->cbSize = cbNewSize;
    }

    CopyMemory( pbuf->pbData + pbuf->cbUsed, pbData, cbData);
    pbuf->cbUsed += cbData;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(ReAllocBufferError)         // error already set
}


//+-------------------------------------------------------------------------
//  Copy out or queue some data eventually destined for the callback.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_Output(
    IN PCRYPT_MSG_INFO  pcmi,
    IN PBYTE            pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal)
{
    BOOL                    fRet;
    PCMSG_STREAM_INFO       pcsi            = pcmi->pStreamInfo;
    PFN_CMSG_STREAM_OUTPUT  pfnStreamOutput = pcsi->pfnStreamOutput;
    void                    *pvArg          = pcsi->pvArg;
    PICM_BUFFER             pbuf            = &pcmi->bufOutput;

    if (pcmi->fStreamCallbackOutput) {
        if (pbuf->cbUsed) {
            // Copy out the queued data
            if (!pfnStreamOutput( pvArg, pbuf->pbData, pbuf->cbUsed, FALSE))
                goto OutputBufferError;
            pbuf->cbUsed = 0;
        }
        if (cbData || fFinal) {
            if (!pfnStreamOutput( pvArg, pbData, cbData, fFinal))
                goto OutputError;
        }
    } else {
        if (!ICMS_QueueToBuffer( pbuf, pbData, cbData))
            goto QueueOutputError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutputBufferError)      // error already set
TRACE_ERROR(QueueOutputError)       // error already set
TRACE_ERROR(OutputError)            // error already set
}


//+-------------------------------------------------------------------------
//  Copy out the pair of NULLs following the contents octets of an indefinite-
//  length encoding.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_OutputNullPairs(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            cPairs,
    IN BOOL             fFinal)
{
    BOOL                fRet;
    BYTE                abNULL[8*2];    ZEROSTRUCT(abNULL);

    if (cPairs > (sizeof(abNULL)/2))
        goto CountOfNullPairsTooLargeError;

    if (!ICMS_Output( pcmi, abNULL, cPairs * 2, fFinal))
        goto OutputError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CountOfNullPairsTooLargeError)      // error already set
TRACE_ERROR(OutputError)                        // error already set
}


//+-------------------------------------------------------------------------
//  Copy out the part of the encoding preceding the contents octets.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_OutputEncodedPrefix(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BYTE             bTag,
    IN DWORD            cbData)
{
    BOOL                    fRet;
    DWORD                   dwError = ERROR_SUCCESS;
    BYTE                    abPrefix[6];
    DWORD                   cbPrefix;

    abPrefix[0] = bTag;
    if (CMSG_INDEFINITE_LENGTH == cbData) {
        abPrefix[1] = ICM_LENGTH_INDEFINITE;
        cbPrefix = 1;
    } else {
        cbPrefix = sizeof(abPrefix) - 1;
        ICM_GetLengthOctets( cbData, abPrefix + 1, &cbPrefix);
    }

    if (!ICMS_Output( pcmi, abPrefix, cbPrefix + 1, FALSE))
        goto OutputError;

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutputError)            // error already set
}


//+-------------------------------------------------------------------------
//  Copy out the part of the ContentInfo encoding preceding
//  the content's content.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_OutputEncodedPrefixContentInfo(
    IN PCRYPT_MSG_INFO  pcmi,
    IN LPSTR            pszContentType,
    IN DWORD            cbData,
    IN DWORD            dwFlags = 0)
{
    BOOL                    fRet;
    DWORD                   dwError = ERROR_SUCCESS;
    ASN1error_e             Asn1Err;
    ASN1encoding_t          pEnc = ICM_GetEncoder();
    PBYTE                   pbEncoded = NULL;
    DWORD                   cbEncoded;
    ObjectID                ossObjID;
    BYTE                    abContentInfo[6];
    DWORD                   cbContentInfo;
    BYTE                    abContent[6];
    DWORD                   cbContent = 0;
    BYTE                    abContentOctetString[6];
    DWORD                   cbContentOctetString = 0;
    DWORD                   cbSize = cbData;

    if (dwFlags & CMSG_DETACHED_FLAG) {
        // NoContent
        if (CMSG_INDEFINITE_LENGTH != cbData)
            cbSize = 0;
    } else {
        if (NULL == pszContentType
#ifdef CMS_PKCS7
                || (dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG)
#endif  // CMS_PKCS7
                ) {
            // The content is not already encoded, so encode it as an octet string.
            abContentOctetString[0] = ICM_TAG_OCTETSTRING;
            if (CMSG_INDEFINITE_LENGTH == cbData) {
                abContentOctetString[0] |= ICM_TAG_CONSTRUCTED;
                abContentOctetString[1] = ICM_LENGTH_INDEFINITE;
                cbContentOctetString = 1;
            } else {
                cbContentOctetString = sizeof(abContentOctetString) - 1;
                ICM_GetLengthOctets(
                            cbData,
                            abContentOctetString + 1,
                            &cbContentOctetString);
                cbSize += 1 + cbContentOctetString;
            }
        }

        // content, [0] EXPLICIT
        abContent[0] = ICM_TAG_CONSTRUCTED | ICM_TAG_CONTEXT_0;
        if (CMSG_INDEFINITE_LENGTH == cbData) {
            abContent[1] = ICM_LENGTH_INDEFINITE;
            cbContent = 1;
        } else {
            cbContent = sizeof(abContent) - 1;
            ICM_GetLengthOctets( cbSize, abContent + 1, &cbContent);
            cbSize += 1 + cbContent;
        }
    }

    // contentType
    ossObjID.count = SIZE_OSS_OID;
    if (!PkiAsn1ToObjectIdentifier(
            pszContentType ? pszContentType : pszObjIdDataType,
            &ossObjID.count,
            ossObjID.value))
        goto ConvToObjectIdentifierError;
    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            &ossObjID,
            ObjectIdentifierType_PDU,
            &pbEncoded,
            &cbEncoded)))
        goto EncodeObjectIdentifierError;
    cbSize += cbEncoded;

    abContentInfo[0] = ICM_TAG_SEQ;
    if (CMSG_INDEFINITE_LENGTH == cbData) {
        abContentInfo[1] = ICM_LENGTH_INDEFINITE;
        cbContentInfo = 1;
    } else {
        cbContentInfo = sizeof(abContentInfo) - 1;
        ICM_GetLengthOctets( cbSize, abContentInfo + 1, &cbContentInfo);
    }

    if (!ICMS_Output( pcmi, abContentInfo, cbContentInfo + 1, FALSE))
        goto OutputContentInfoError;
    if (!ICMS_Output( pcmi, pbEncoded, cbEncoded, FALSE))
        goto OutputContentTypeError;
    if (0 == (dwFlags & CMSG_DETACHED_FLAG)) {
        if (!ICMS_Output( pcmi, abContent, cbContent + 1, FALSE))
            goto OutputContentError;
        if (NULL == pszContentType
#ifdef CMS_PKCS7
                || (dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG)
#endif  // CMS_PKCS7
                ) {
            if (!ICMS_Output( 
                    pcmi,
                    abContentOctetString,
                    cbContentOctetString + 1,
                    FALSE))
                goto OutputContentOctetStringError;
        }
    }

    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(EncodeObjectIdentifierError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(ConvToObjectIdentifierError)        // error already set
TRACE_ERROR(OutputContentInfoError)             // error already set
TRACE_ERROR(OutputContentTypeError)             // error already set
TRACE_ERROR(OutputContentError)                 // error already set
TRACE_ERROR(OutputContentOctetStringError)      // error already set
}


//+-------------------------------------------------------------------------
//  Copy out the part of the EncryptedContentInfo encoding preceding
//  the content's content.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_OutputEncodedPrefixEncryptedContentInfo(
    IN PCRYPT_MSG_INFO      pcmi,
    IN LPSTR                pszContentType,
    IN AlgorithmIdentifier  *poaiContentEncryption,
    IN DWORD                cbData)
{
    BOOL                    fRet;
    DWORD                   dwError = ERROR_SUCCESS;
    ASN1error_e             Asn1Err;
    ASN1encoding_t          pEnc = ICM_GetEncoder();
    PBYTE                   pbEncodedContentType = NULL;
    DWORD                   cbEncodedContentType;
    PBYTE                   pbEncodedContentEncryptionAlgorithm = NULL;
    DWORD                   cbEncodedContentEncryptionAlgorithm;
    ObjectID                ossObjID;
    BYTE                    abEncryptedContentInfo[6];
    DWORD                   cbEncryptedContentInfo;
    BYTE                    abEncryptedContent[6];
    DWORD                   cbEncryptedContent;
    DWORD                   cbSize = 0;
    DWORD                   cbCipher = cbData;
    DWORD                   cbBlockSize = pcmi->cbBlockSize;

    if (pcmi->fBlockCipher && 0 < cbCipher) {
        cbCipher += cbBlockSize;
        cbCipher -= cbCipher % cbBlockSize;
    }

    // encryptedContent, [0] IMPLICIT
    abEncryptedContent[0] = ICM_TAG_CONTEXT_0;
    if (CMSG_INDEFINITE_LENGTH == cbData) {
        abEncryptedContent[0] |= ICM_TAG_CONSTRUCTED;
        abEncryptedContent[1] = ICM_LENGTH_INDEFINITE;
        cbEncryptedContent = 1;
    } else {
        // NOTE: for nonData, either encapsulated or the cbData excludes
        // the outer tag and length octets.
        cbEncryptedContent = sizeof(abEncryptedContent) - 1;
        ICM_GetLengthOctets( cbCipher, abEncryptedContent + 1, &cbEncryptedContent);
        cbSize = 1 + cbEncryptedContent + cbCipher;
    }

    // contentType
    ossObjID.count = SIZE_OSS_OID;
    if (!PkiAsn1ToObjectIdentifier(
            pszContentType ? pszContentType : pszObjIdDataType,
            &ossObjID.count,
            ossObjID.value))
        goto ConvToObjectIdentifierError;
    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            &ossObjID,
            ObjectIdentifierType_PDU,
            &pbEncodedContentType,
            &cbEncodedContentType)))
        goto EncodeObjectIdentifierError;
    cbSize += cbEncodedContentType;

    // contentEncryptionAlgorithm
    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            poaiContentEncryption,
            AlgorithmIdentifier_PDU,
            &pbEncodedContentEncryptionAlgorithm,
            &cbEncodedContentEncryptionAlgorithm)))
        goto EncodeContentEncryptionAlgorithmError;
    cbSize += cbEncodedContentEncryptionAlgorithm;

    // EncryptedContentInfo
    abEncryptedContentInfo[0] = ICM_TAG_SEQ;
    if (CMSG_INDEFINITE_LENGTH == cbData) {
        abEncryptedContentInfo[1] = ICM_LENGTH_INDEFINITE;
        cbEncryptedContentInfo = 1;
    } else {
        cbEncryptedContentInfo = sizeof(abEncryptedContentInfo) - 1;
        ICM_GetLengthOctets(
                cbSize,
                abEncryptedContentInfo + 1,
                &cbEncryptedContentInfo);
    }

    // Queue the encoded header
    if (!ICMS_Output(
                pcmi,
                abEncryptedContentInfo,
                cbEncryptedContentInfo + 1,
                FALSE))
        goto OutputContentInfoError;
    if (!ICMS_Output(
                pcmi,
                pbEncodedContentType,
                cbEncodedContentType,
                FALSE))
        goto OutputContentTypeError;
    if (!ICMS_Output(
                pcmi,
                pbEncodedContentEncryptionAlgorithm,
                cbEncodedContentEncryptionAlgorithm,
                FALSE))
        goto OutputContentEncryptionAlgorithmError;
    if (!ICMS_Output(
                pcmi,
                abEncryptedContent,
                cbEncryptedContent + 1,
                FALSE))
        goto OutputEncryptedContentError;

    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeEncoded(pEnc, pbEncodedContentType);
    PkiAsn1FreeEncoded(pEnc, pbEncodedContentEncryptionAlgorithm);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(EncodeObjectIdentifierError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(EncodeContentEncryptionAlgorithmError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(ConvToObjectIdentifierError)            // error already set
TRACE_ERROR(OutputContentInfoError)                 // error already set
TRACE_ERROR(OutputContentTypeError)                 // error already set
TRACE_ERROR(OutputContentEncryptionAlgorithmError)  // error already set
TRACE_ERROR(OutputEncryptedContentError)            // error already set
}


//+-------------------------------------------------------------------------
//  Copy out the encoding of an OSS type.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_OutputEncoded(
    IN PCRYPT_MSG_INFO  pcmi,
    IN int              iPDU,
    IN OPTIONAL BYTE    bTag,
    IN PVOID            pv,
    IN BOOL             fFinal)
{
    BOOL                    fRet;
    DWORD                   dwError = ERROR_SUCCESS;
    ASN1error_e             Asn1Err;
    ASN1encoding_t          pEnc = ICM_GetEncoder();
    PBYTE                   pbEncoded = NULL;
    DWORD                   cbEncoded;

    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            pv,
            iPDU,
            &pbEncoded,
            &cbEncoded)))
        goto EncodeError;

    if (bTag)
        pbEncoded[0] = bTag;         // poke in the right tag

    if (!ICMS_Output(pcmi, pbEncoded, cbEncoded, fFinal))
        goto OutputError;

    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(EncodeError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(OutputError)                // error already set
}


//+-------------------------------------------------------------------------
//  Create the buffer for an enveloped message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_CreateEnvelopedBuffer(
    IN PCRYPT_MSG_INFO  pcmi)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    PBYTE       pbBuffer = NULL;
    DWORD       cbBuffer;
    DWORD       cbAlloc;
    DWORD       cbBlockSize;
    BOOL        fBlockCipher;
    PICM_BUFFER pbuf = &pcmi->bufCrypt;

    if (!ICM_GetKeyBlockSize(
                pcmi->hkeyContentCrypt,
                &cbBlockSize,
                &fBlockCipher))
        goto GetEncryptBlockSizeError;

    pcmi->cbBlockSize  = cbBlockSize;
    pcmi->fBlockCipher = fBlockCipher;

    cbBuffer = min( cbBlockSize * CMSGP_STREAM_CRYPT_BLOCK_COUNT,
                    CMSGP_STREAM_MAX_ENCRYPT_BUFFER);
    if (fBlockCipher) {
        cbBuffer += cbBlockSize;
        cbBuffer -= cbBuffer % cbBlockSize; // make a multiple of block size
    }

    // Add one block for growth during encrypt, and to save during decrypt.
    cbAlloc = cbBuffer + 1 * cbBlockSize;
    // Block ciphers pad the ciphertext, and if the plaintext is a
    // multiple of the block size the padding is one block.
    if (NULL == (pbBuffer = (PBYTE)ICM_Alloc( cbAlloc)))
        goto AllocBufferError;
    pbuf->pbData = pbBuffer;
    pbuf->cbSize = cbBuffer;

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( pbBuffer);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetEncryptBlockSizeError)       // error already set
TRACE_ERROR(AllocBufferError)               // error already set
}




//+-------------------------------------------------------------------------
//  Encode and copy out the part of the data message up to the inner content.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_OpenToEncodeData(
    IN PCRYPT_MSG_INFO          pcmi)
{
    BOOL        fRet;
    DWORD       dwError = ERROR_SUCCESS;
    DWORD       cbData = pcmi->pStreamInfo->cbContent;

    if (pcmi->dwFlags & CMSG_BARE_CONTENT_FLAG) {
        BYTE bTag;

        if (CMSG_INDEFINITE_LENGTH == cbData)
            bTag = ICM_TAG_OCTETSTRING | ICM_TAG_CONSTRUCTED;
        else
            bTag = ICM_TAG_OCTETSTRING;

        // Output octet string
        if (!ICMS_OutputEncodedPrefix(
                    pcmi,
                    bTag,
                    cbData))
            goto OutputOctetStringError;
    } else {
        // Output ContentInfo
        if (!ICMS_OutputEncodedPrefixContentInfo(
                    pcmi,
                    NULL,
                    cbData))
            goto OutputContentInfoError;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutputContentInfoError)             // error already set
TRACE_ERROR(OutputOctetStringError)             // error already set
}


//+-------------------------------------------------------------------------
//  Encode and copy out the part of the data message after the inner content.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_UpdateEncodingData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN PBYTE            pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal)
{
    BOOL        fRet;
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fDefinite = (CMSG_INDEFINITE_LENGTH != pcmi->pStreamInfo->cbContent);
    DWORD       cNullPairs;

    pcmi->fStreamCallbackOutput = TRUE;                 // Enable the callback
    if (!fDefinite) {
        // The content is an indefinite-length octet string encoded by us,
        // so make each output chunk definite-length.
        if (!ICMS_OutputEncodedPrefix(
                    pcmi,
                    ICM_TAG_OCTETSTRING,
                    cbData))
            goto OutputOctetStringError;
    }
    if (!ICMS_Output( pcmi, pbData, cbData, fFinal && fDefinite))
        goto OutputError;
        
    if (fFinal && !fDefinite) {
        // End of indefinite-length encoding, so emit some NULL pairs
        cNullPairs = 1;                 // content
        if (0 == (pcmi->dwFlags & CMSG_BARE_CONTENT_FLAG))
            cNullPairs += 2;
        if (!ICMS_OutputNullPairs( pcmi, cNullPairs, TRUE))
            goto OutputNullPairsError;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutputOctetStringError)             // error already set
TRACE_ERROR(OutputError)                        // error already set
TRACE_ERROR(OutputNullPairsError)               // error already set
}


//+-------------------------------------------------------------------------
//  Encode and copy out the part of the signed message up to the inner content.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_OpenToEncodeSignedData(
    IN PCRYPT_MSG_INFO          pcmi,
    IN PCMSG_SIGNED_ENCODE_INFO psmei)
{
    BOOL        fRet;
    DWORD       dwError = ERROR_SUCCESS;
    SignedData  *psd = (SignedData *)pcmi->pvMsg;
    DWORD       cbData = pcmi->pStreamInfo->cbContent;
    LPSTR       pszInnerContentObjID = pcmi->pszInnerContentObjID;
    DWORD       cbSigned;
    DWORD       cbSignedDataContent;

    // Output ContentInfo, if appropriate
    if (CMSG_INDEFINITE_LENGTH == cbData) {
        cbSigned            = CMSG_INDEFINITE_LENGTH;
        cbSignedDataContent = CMSG_INDEFINITE_LENGTH;
    } else {
        if (INVALID_ENCODING_SIZE == (cbSigned = ICM_LengthSigned(
                psmei,
                pcmi->dwFlags,
                pszInnerContentObjID,
                cbData,
                &cbSignedDataContent)))
            goto LengthSignedError;
    }
    if (0 == (pcmi->dwFlags & CMSG_BARE_CONTENT_FLAG)) {
        if (!ICMS_OutputEncodedPrefixContentInfo(
                    pcmi,
                    szOID_RSA_signedData,
                    cbSigned))
            goto OutputContentInfoError;
    }
    if (!ICMS_OutputEncodedPrefix(
                pcmi,
                ICM_TAG_SEQ,
                cbSignedDataContent))
        goto OutputSignedDataError;

    // version
    if (!ICMS_OutputEncoded(
                pcmi,
                IntegerType_PDU,
                0,                          // bTag
                &psd->version,
                FALSE))
        goto OutputIntegerError;

    // digestAlgorithms
    if (!ICMS_OutputEncoded(
                pcmi,
                AlgorithmIdentifiers_PDU,
                0,                          // bTag
                &psd->digestAlgorithms,
                FALSE))
        goto OutputAlgorithmIdentifiersError;

    // contentInfo
    if (!ICMS_OutputEncodedPrefixContentInfo(
                pcmi,
                pcmi->pszInnerContentObjID,
                cbData,
                pcmi->dwFlags))
        goto OutputInnerContentInfoError;

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(LengthSignedError)                  // error already set
TRACE_ERROR(OutputContentInfoError)             // error already set
TRACE_ERROR(OutputSignedDataError)              // error already set
TRACE_ERROR(OutputIntegerError)                 // error already set
TRACE_ERROR(OutputAlgorithmIdentifiersError)    // error already set
TRACE_ERROR(OutputInnerContentInfoError)        // error already set
}


//+-------------------------------------------------------------------------
//  Encode and copy out the part of the signed message after the inner content.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_UpdateEncodingSignedData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN PBYTE            pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal)
{
    BOOL                fRet;
    DWORD               dwError = ERROR_SUCCESS;
    SignedData          *psd = (SignedData *)pcmi->pvMsg;
    PCMSG_STREAM_INFO   pcsi = pcmi->pStreamInfo;
    BOOL                fDefinite = (CMSG_INDEFINITE_LENGTH != pcsi->cbContent);
    DWORD               cNullPairs;

    if (pcmi->pszInnerContentObjID
#ifdef CMS_PKCS7
            && 0 == (pcmi->dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG)
#endif  // CMS_PKCS7
            ) {
        if (0 == (pcmi->aflStream & ICMS_PROCESS_CONTENT_DONE)) {
            if (!ICMS_HashContent( pcmi, pbData, cbData))
                goto HashContentError;
        }
    } else {
        if (!ICM_UpdateListDigest( pcmi->pHashList, pbData, cbData))
            goto UpdateDigestError;
    }

    pcmi->fStreamCallbackOutput = TRUE;             // Enable the callback
    if (0 == (pcmi->dwFlags & CMSG_DETACHED_FLAG)) {
        if (!fDefinite && (NULL == pcmi->pszInnerContentObjID
#ifdef CMS_PKCS7
                || (pcmi->dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG)
#endif  // CMS_PKCS7
                )) {
            // The content is an indefinite-length octet string encoded by us,
            // so make each output chunk definite-length.
            if (!ICMS_OutputEncodedPrefix(
                        pcmi,
                        ICM_TAG_OCTETSTRING,
                        cbData))
                goto OutputOctetStringError;
        }
        if (!ICMS_Output( pcmi, pbData, cbData, FALSE))
            goto OutputError;
    }
    // else
    //  detached => don't output the detached content to be hashed

    if (fFinal) {
        if (!fDefinite) {
            // End of indefinite-length encoding, so emit some NULL pairs
            cNullPairs = 1;                 // ContentInfo
            if (0 == (pcmi->dwFlags & CMSG_DETACHED_FLAG)) {
                cNullPairs++;               // [0] EXPLICIT
                if (NULL == pcmi->pszInnerContentObjID
#ifdef CMS_PKCS7
                        || (pcmi->dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG)
#endif  // CMS_PKCS7
                        )
                    cNullPairs++;       // We did the octet string encoding
            }
            // else
            //  detached => no content ([0] EXPLICIT)

            if (!ICMS_OutputNullPairs( pcmi, cNullPairs, FALSE))
                goto OutputNullPairsError;
        }

        if ((psd->bit_mask & certificates_present) &&
                    !ICMS_OutputEncoded(
                            pcmi,
                            SetOfAny_PDU,
                            ICM_TAG_CONSTRUCTED | ICM_TAG_CONTEXT_0,
                            &psd->certificates,
                            FALSE))
            goto OutputCertsError;

        if ((psd->bit_mask & crls_present) &&
                    !ICMS_OutputEncoded(
                            pcmi,
                            SetOfAny_PDU,
                            ICM_TAG_CONSTRUCTED | ICM_TAG_CONTEXT_1,
                            &psd->crls,
                            FALSE))
            goto OutputCrlsError;

#ifdef CMS_PKCS7
        if (pcmi->rgSignerEncodeDataInfo) {
            if (!ICM_FillSignerEncodeEncryptedDigests(
                            pcmi,
                            fDefinite))         // fMaxLength
                    goto FillSignerEncodeEncryptedDigestsError;
        }
#else
        if (pcmi->pHashList) {
            if (!ICM_FillSignerEncryptedDigest(
                            psd->signerInfos.value,
                            pcmi->pszInnerContentObjID,
                            pcmi->pHashList->Head(),
                            pcmi->dwKeySpec,
                            fDefinite))         // fMaxLength
                goto FillSignerEncryptedDigestError;
        }
#endif  // CMS_PKCS7

        if (!ICMS_OutputEncoded(
                            pcmi,
                            SignerInfos_PDU, 
                            0,                      // bTag
                            &psd->signerInfos,
                            fDefinite))
            goto OutputSignerInfosError;

        if (!fDefinite) {
            // End of indefinite-length encoding, so emit some NULL pairs
            cNullPairs = 1;         // SignedData
            if (0 == (pcmi->dwFlags & CMSG_BARE_CONTENT_FLAG))
                cNullPairs += 2;
            if (!ICMS_OutputNullPairs( pcmi, cNullPairs, TRUE))
                goto OutputNullPairsError;
        }
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(HashContentError)                   // error already set
TRACE_ERROR(UpdateDigestError)                  // error already set
TRACE_ERROR(OutputOctetStringError)             // error already set
TRACE_ERROR(OutputError)                        // error already set
TRACE_ERROR(OutputCertsError)                   // error already set
TRACE_ERROR(OutputCrlsError)                    // error already set
#ifdef CMS_PKCS7
TRACE_ERROR(FillSignerEncodeEncryptedDigestsError)  // error already set
#else
TRACE_ERROR(FillSignerEncryptedDigestError)     // error already set
#endif  // CMS_PKCS7
TRACE_ERROR(OutputSignerInfosError)             // error already set
TRACE_ERROR(OutputNullPairsError)               // error already set
}

//+-------------------------------------------------------------------------
//  Encode and copy out the part of the enveloped message up to the inner
//  content.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_OpenToEncodeEnvelopedData(
    IN PCRYPT_MSG_INFO              pcmi,
    IN PCMSG_ENVELOPED_ENCODE_INFO  pemei)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
#ifdef CMS_PKCS7
    CmsEnvelopedData   *ped = (CmsEnvelopedData *)pcmi->pvMsg;
#else
    EnvelopedData   *ped = (EnvelopedData *)pcmi->pvMsg;
#endif  // CMS_PKCS7
    DWORD           cbData = pcmi->pStreamInfo->cbContent;
    LPSTR           pszInnerContentObjID = pcmi->pszInnerContentObjID;
    DWORD           cbEnveloped;
    DWORD           cbEnvelopedDataContent;

    if (!ICMS_CreateEnvelopedBuffer( pcmi))
        goto CreateEnvelopedBufferError;

    // Output ContentInfo, if appropriate
    if (CMSG_INDEFINITE_LENGTH == cbData) {
        cbEnveloped            = CMSG_INDEFINITE_LENGTH;
        cbEnvelopedDataContent = CMSG_INDEFINITE_LENGTH;
    } else {
        // NOTE: for nonData, either encapsulated or cbData excludes the
        // outer tag and length octets.

        if (INVALID_ENCODING_SIZE == (cbEnveloped = ICM_LengthEnveloped(
                pemei,
                pcmi->dwFlags,
                pszInnerContentObjID,
                cbData,
                &cbEnvelopedDataContent)))
            goto LengthEnvelopedError;
    }
    if (0 == (pcmi->dwFlags & CMSG_BARE_CONTENT_FLAG)) {
        if (!ICMS_OutputEncodedPrefixContentInfo(
                    pcmi,
                    szOID_RSA_envelopedData,
                    cbEnveloped))
            goto OutputContentInfoError;
    }
    if (!ICMS_OutputEncodedPrefix(
                pcmi,
                ICM_TAG_SEQ,
                cbEnvelopedDataContent))
        goto OutputEnvelopedDataError;

    // version
    if (!ICMS_OutputEncoded(
                pcmi,
                IntegerType_PDU,
                0,                          // bTag
                &ped->version,
                FALSE))
        goto OutputIntegerError;

#ifdef CMS_PKCS7
    // originatorInfo OPTIONAL
    if (ped->bit_mask & originatorInfo_present) {
        if (!ICMS_OutputEncoded(
                pcmi,
                OriginatorInfo_PDU,
                ICM_TAG_CONSTRUCTED | ICM_TAG_CONTEXT_0,
                &ped->originatorInfo,
                FALSE))
            goto OutputOriginatorInfoError;
    }
#endif  // CMS_PKCS7

    // recipientInfos
    if (!ICMS_OutputEncoded(
                pcmi,
#ifdef CMS_PKCS7
                CmsRecipientInfos_PDU,
#else
                RecipientInfos_PDU,
#endif  // CMS_PKCS7
                0,                          // bTag
                &ped->recipientInfos,
                FALSE))
        goto OutputRecipientInfosError;

    // encryptedContentInfo
    if (!ICMS_OutputEncodedPrefixEncryptedContentInfo(
                pcmi,
                pcmi->pszInnerContentObjID,
                &ped->encryptedContentInfo.contentEncryptionAlgorithm,
                cbData))
        goto OutputInnerContentInfoError;

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CreateEnvelopedBufferError)     // error already set
TRACE_ERROR(LengthEnvelopedError)           // error already set
TRACE_ERROR(OutputContentInfoError)         // error already set
TRACE_ERROR(OutputEnvelopedDataError)       // error already set
TRACE_ERROR(OutputIntegerError)             // error already set
#ifdef CMS_PKCS7
TRACE_ERROR(OutputOriginatorInfoError)      // error already set
#endif  // CMS_PKCS7
TRACE_ERROR(OutputRecipientInfosError)      // error already set
TRACE_ERROR(OutputInnerContentInfoError)    // error already set
}

//+-------------------------------------------------------------------------
//  Encrypt and copy out some bytes.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_EncodeEncryptAndOutput(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbPlainOrg,
    IN DWORD            cbPlainOrg,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    BOOL        fDefinite = (CMSG_INDEFINITE_LENGTH != pcmi->pStreamInfo->cbContent);
    BOOL        fBlockCipher = pcmi->fBlockCipher;
    PICM_BUFFER pbufCrypt = &pcmi->bufCrypt;
    PBYTE       pbPlain;
    DWORD       cbPlainRemain;
    DWORD       cb;

    for (cbPlainRemain = cbPlainOrg, pbPlain = (PBYTE)pbPlainOrg;
            cbPlainRemain > 0;) {
        cb = min( cbPlainRemain, pbufCrypt->cbSize - pbufCrypt->cbUsed); // must fit
        CopyMemory(
                pbufCrypt->pbData  + pbufCrypt->cbUsed,
                pbPlain,
                cb);
        pbufCrypt->cbUsed  += cb;
        pbPlain            += cb;
        cbPlainRemain      -= cb;
        if (pbufCrypt->cbSize == pbufCrypt->cbUsed) {
            // Encrypt and copy out the buffer
            cb = pbufCrypt->cbSize;
            if (fBlockCipher) {
                // Leave the last block
                cb -= pcmi->cbBlockSize;
            }
            if (!CryptEncrypt(
                        pcmi->hkeyContentCrypt,
                        NULL,                           // hHash
                        FALSE,                          // fFinal
                        0,                              // dwFlags
                        pbufCrypt->pbData,
                        &cb,
                        pbufCrypt->cbSize + pcmi->cbBlockSize))
                goto EncryptError;
            if (!fDefinite) {
                // The ciphertext is indefinite-length, so make each
                // output chunk definite-length.
                if (!ICMS_OutputEncodedPrefix(
                            pcmi,
                            ICM_TAG_OCTETSTRING,
                            cb))
                    goto OutputOctetStringError;
            }
            if (!ICMS_Output(
                        pcmi,
                        pbufCrypt->pbData,
                        cb,
                        FALSE))                         // fFinal
                goto OutputError;

            if (fBlockCipher) {
                // Move the last block to the beginning of the buffer
                // and reset the count to start after this block.
                // Since we are sure the src and dst do not overlap,
                // use CopyMemory (faster than MoveMemory).
                cb = pbufCrypt->cbSize - pcmi->cbBlockSize;
                CopyMemory(
                    pbufCrypt->pbData,
                    pbufCrypt->pbData + cb,
                    pcmi->cbBlockSize);
                pbufCrypt->cbUsed = pcmi->cbBlockSize;
            } else {
                pbufCrypt->cbUsed = 0;
            }
        }
    }

    if (fFinal) {
#ifdef CMS_PKCS7
        CmsEnvelopedData *ped = (CmsEnvelopedData *)pcmi->pvMsg;
#else
        EnvelopedData *ped = (EnvelopedData *)pcmi->pvMsg;
#endif  // CMS_PKCS7

        if (cb = pbufCrypt->cbUsed) {
            if (!CryptEncrypt(
                        pcmi->hkeyContentCrypt,
                        NULL,                           // hHash
                        TRUE,                           // fFinal
                        0,                              // dwFlags
                        pbufCrypt->pbData,
                        &cb,
                        pbufCrypt->cbSize + pcmi->cbBlockSize))
                goto FinalEncryptError;
        }
        if (!fDefinite && cb) {
            // The ciphertext is indefinite-length, so make each
            // output chunk definite-length.
            if (!ICMS_OutputEncodedPrefix(
                        pcmi,
                        ICM_TAG_OCTETSTRING,
                        cb))
                goto OutputOctetStringError;
        }
        if (!ICMS_Output(
                    pcmi,
                    pbufCrypt->pbData,
                    cb,
                    fDefinite &&
                        0 == (ped->bit_mask & unprotectedAttrs_present) // fFinal
                    ))
            goto FinalOutputError;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EncryptError)           // error already set
TRACE_ERROR(FinalEncryptError)      // error already set
TRACE_ERROR(OutputOctetStringError) // error already set
TRACE_ERROR(OutputError)            // error already set
TRACE_ERROR(FinalOutputError)       // error already set
}


//+-------------------------------------------------------------------------
//  Encode encrypt callback for octet string.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_EncryptCallback(
    IN const void       *pvArg,
    IN OUT PICM_BUFFER  pbuf,
    IN OUT PDWORD       pcbPending,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    PBYTE       pbData = pbuf->pbData + pbuf->cbDead;
    DWORD       cbData = min( *pcbPending, pbuf->cbUsed - pbuf->cbDead);

    if (!ICMS_EncodeEncryptAndOutput(
                (PCRYPT_MSG_INFO)pvArg,
                pbData,
                cbData,
                fFinal))
        goto EncodeEncryptAndOutputError;

    pbuf->cbDead += cbData;
    *pcbPending  -= cbData;

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EncodeEncryptAndOutputError)        // error already set
}


//+-------------------------------------------------------------------------
//  Encode and copy out the part of the enveloped message after the inner content.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_UpdateEncodingEnvelopedData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbPlain,
    IN DWORD            cbPlain,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    BOOL        fDefinite = (CMSG_INDEFINITE_LENGTH != pcmi->pStreamInfo->cbContent);
    DWORD       cNullPairs;

    if (!pcmi->fStreamCallbackOutput) {
        pcmi->fStreamCallbackOutput = TRUE;             // Enable the callback
        if (!ICMS_Output( pcmi, NULL, 0, FALSE))        // Flush the header
            goto FlushOutputError;
    }

    if (pcmi->pszInnerContentObjID
#ifdef CMS_PKCS7
            && 0 == (pcmi->dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG)
#endif  // CMS_PKCS7
            ) {
        if (!ICMS_QueueToBuffer( &pcmi->bufEncode, (PBYTE)pbPlain, cbPlain))
            goto QueueToBufferError;

        if (!ICMS_ProcessStringContent(
                    &pcmi->bufEncode,
                    &pcmi->aflStream,
                    &pcmi->cbDefiniteRemain,
                    &pcmi->cLevelIndefiniteInner,
                    ICMS_EncryptCallback,
                    pcmi))
            goto ProcessContentError;
    } else {
        if (!ICMS_EncodeEncryptAndOutput(
                    pcmi,
                    pbPlain,
                    cbPlain,
                    fFinal))
            goto EncodeEncryptAndOutputError;
    }


    if (fFinal) {
#ifdef CMS_PKCS7
        CmsEnvelopedData *ped = (CmsEnvelopedData *)pcmi->pvMsg;
#else
        EnvelopedData *ped = (EnvelopedData *)pcmi->pvMsg;
#endif  // CMS_PKCS7

        if (!fDefinite) {
            // End of indefinite-length encoding, so emit some NULL pairs,
            // one each for encryptedContent, encryptedContentInfo
            if (!ICMS_OutputNullPairs( pcmi, 2, FALSE))
                goto OutputNullPairsError;
        }

        if (ped->bit_mask & unprotectedAttrs_present) {
#ifdef CMS_PKCS7
            if (!ICMS_OutputEncoded(
                    pcmi,
                    Attributes_PDU,
                    ICM_TAG_CONSTRUCTED | ICM_TAG_CONTEXT_1,
                    &ped->unprotectedAttrs,
                    fDefinite))         // fFinal
                goto OutputAttributesError;
#endif  // CMS_PKCS7
        }

        if (!fDefinite) {
            // End of indefinite-length encoding, so emit some NULL pairs
            cNullPairs = 1;         // EnvelopedData
            if (0 == (pcmi->dwFlags & CMSG_BARE_CONTENT_FLAG))
                cNullPairs += 2;
            if (!ICMS_OutputNullPairs( pcmi, cNullPairs, TRUE))
                goto OutputNullPairsError;
        }
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FlushOutputError)               // error already set
TRACE_ERROR(QueueToBufferError)             // error already set
TRACE_ERROR(ProcessContentError)            // error already set
TRACE_ERROR(EncodeEncryptAndOutputError)    // error already set
TRACE_ERROR(OutputNullPairsError)           // error already set
#ifdef CMS_PKCS7
TRACE_ERROR(OutputAttributesError)          // error already set
#endif  // CMS_PKCS7
}


//+-------------------------------------------------------------------------
//  Decode a PDU from the decode buffer.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodePDU(
    IN PCRYPT_MSG_INFO  pcmi,
    IN ASN1decoding_t   pDec,
    IN ASN1uint32_t     pdunum,
    OUT PVOID           *ppvPDU,
    OUT OPTIONAL PDWORD pcbConsumed = NULL)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    ASN1error_e         Asn1Err;
    PICM_BUFFER         pbuf = &pcmi->bufDecode;
    PVOID               pvPDU = NULL;
    DWORD               cbBufSizeOrg;
    PBYTE               pbData = pbuf->pbData + pbuf->cbDead;
    DWORD               cbData = pbuf->cbUsed - pbuf->cbDead;

#if DBG && defined(OSS_CRYPT_ASN1)
    DWORD   dwDecodingFlags;

    dwDecodingFlags = ossGetDecodingFlags((OssGlobal *) pDec);
    ossSetDecodingFlags( (OssGlobal *) pDec, RELAXBER); // turn off squirties
#endif

    cbBufSizeOrg = cbData;
    if (0 != (Asn1Err = PkiAsn1Decode2(
            pDec,
            &pvPDU,
            pdunum,
            &pbData,
            &cbData))) {
        if (ASN1_ERR_EOD != Asn1Err)
            goto DecodeError;
    }
#if DBG && defined(OSS_CRYPT_ASN1)
    ossSetDecodingFlags( (OssGlobal *) pDec, dwDecodingFlags);     // restore
#endif

    if (ASN1_ERR_EOD == Asn1Err ||
            (cbData > pbuf->cbUsed - pbuf->cbDead)) {
        PkiAsn1FreeInfo(pDec, pdunum, pvPDU);
        pvPDU = NULL;
        cbData = cbBufSizeOrg;
    }
    pbuf->cbDead += cbBufSizeOrg - cbData;
    if (pcbConsumed)
        *pcbConsumed = cbBufSizeOrg - cbData;

    fRet = TRUE;
CommonReturn:
    *ppvPDU = pvPDU;
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    if (pcbConsumed)
        *pcbConsumed = 0;
    pvPDU = NULL;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(DecodeError, PkiAsn1ErrToHr(Asn1Err))
}


//+-------------------------------------------------------------------------
//  Decode a ContentInfo prefix
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodePrefixContentInfo(
    IN PCRYPT_MSG_INFO      pcmi,
    OUT ObjectIdentifierType **ppooidContentType,
    IN OUT PDWORD           pcTrailingNullPairs,
    IN OUT PDWORD           pafl,
    OUT BOOL                *pfNoContent)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    DWORD                   dwToken;

    // ContentInfo sequence, step into it
    if (0 == (*pafl & ICMS_DECODED_CONTENTINFO_SEQ)) {
        if (!ICMS_GetToken( &pcmi->bufDecode, &dwToken, &pcmi->cbContentInfo))
            goto ContentInfoGetTokenError;
        switch (dwToken) {
        case ICMS_TOKEN_INDEFINITE:     ++*pcTrailingNullPairs; break;
        case ICMS_TOKEN_DEFINITE:                               break;
        case ICMS_TOKEN_INCOMPLETE:     goto SuccessReturn;
        default:                        goto InvalidTokenError;
        }
        *pafl |= ICMS_DECODED_CONTENTINFO_SEQ;
    }

    // contentType, decode it
    if (NULL == *ppooidContentType) {
        DWORD cbConsumed;

        if (!ICMS_DecodePDU(
                pcmi,
                pDec,
                ObjectIdentifierType_PDU,
                (void **)ppooidContentType,
                &cbConsumed))
            goto DecodeContentTypeError;

        if (NULL != *ppooidContentType &&
                CMSG_INDEFINITE_LENGTH != pcmi->cbContentInfo &&
                cbConsumed == pcmi->cbContentInfo) {
            // Only has contentType. The optional content has
            // been omitted.
            *pfNoContent = TRUE;
            *pafl |= ICMS_DECODED_CONTENTINFO_CONTENT;
            goto SuccessReturn;
        }
    }
    if (NULL == *ppooidContentType)
        goto SuccessReturn;         // not enough data

    // [0] EXPLICIT, step into it
    if (0 == (*pafl & ICMS_DECODED_CONTENTINFO_CONTENT)) {
        if (CMSG_INDEFINITE_LENGTH == pcmi->cbContentInfo) {
            PICM_BUFFER pbuf = &pcmi->bufDecode;

            if (pbuf->cbUsed > pbuf->cbDead) {
                // Check for trailing Null Pairs (00, 00)
                if (ICM_TAG_NULL == *(pbuf->pbData + pbuf->cbDead)) {
                    // Only has contentType. The optional content has
                    // been omitted.
                    *pfNoContent = TRUE;
                    *pafl |= ICMS_DECODED_CONTENTINFO_CONTENT;
                    goto SuccessReturn;
                }
            } else
                goto SuccessReturn;         // not enough data
        }

        
        if (!ICMS_GetToken( &pcmi->bufDecode, &dwToken, NULL))
            goto ContentGetTokenError;
        switch (dwToken) {
        case ICMS_TOKEN_INDEFINITE:     ++*pcTrailingNullPairs; break;
        case ICMS_TOKEN_DEFINITE:                               break;
        case ICMS_TOKEN_INCOMPLETE:     goto SuccessReturn;
        default:                        goto InvalidTokenError;
        }
        *pfNoContent = FALSE;
        *pafl |= ICMS_DECODED_CONTENTINFO_CONTENT;
    }

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecodeContentTypeError)             // error already set
TRACE_ERROR(ContentGetTokenError)               // error already set
TRACE_ERROR(InvalidTokenError)                  // error already set
TRACE_ERROR(ContentInfoGetTokenError)           // error already set
}


//+-------------------------------------------------------------------------
//  Consume the NULL pairs which terminate the indefinite-length encoding.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_ConsumeTrailingNulls(
    IN PCRYPT_MSG_INFO  pcmi,
    IN OUT PDWORD       pcNullPairs,
    IN BOOL             fFinal)
{
    BOOL        fRet;
    DWORD       dwToken;

    for (; *pcNullPairs; (*pcNullPairs)--) {
        if (!ICMS_GetToken( &pcmi->bufDecode, &dwToken, NULL))
            goto GetTokenError;
        if ((ICMS_TOKEN_INCOMPLETE == dwToken) && !fFinal)
            goto SuccessReturn;
        if (ICMS_TOKEN_NULLPAIR != dwToken)
            goto WrongTokenError;
    }

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetTokenError)                      // error already set
TRACE_ERROR(WrongTokenError)                    // error already set
}


//+-------------------------------------------------------------------------
//  Handle incremental suffix data to be decoded, for a data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeSuffixData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    BOOL                fRet;

    if (!ICMS_ConsumeTrailingNulls( pcmi, &pcmi->cEndNullPairs, fFinal))
        goto ConsumeTrailingNullsError;
    if (0 == pcmi->cEndNullPairs)
        pcmi->aflStream |= ICMS_DECODED_SUFFIX;

    if (fFinal && (pcmi->bufDecode.cbUsed > pcmi->bufDecode.cbDead))
        goto ExcessDataError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(ConsumeTrailingNullsError)          // error already set
TRACE_ERROR(ExcessDataError)                    // error already set
}


//+-------------------------------------------------------------------------
//  Handle incremental suffix data to be decoded, for a signed message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeSuffixSigned(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    PSIGNED_DATA_INFO   psdi = pcmi->psdi;
    PICM_BUFFER         pbuf = &pcmi->bufDecode;
    CertificatesNC      *pCertificates = NULL;
    CrlsNC              *pCrls = NULL;
    SignerInfosNC       *pSignerInfos = NULL;
    Any                 *pAny;
    DWORD               i;

    if (!ICMS_ConsumeTrailingNulls( pcmi, &pcmi->cInnerNullPairs, fFinal))
        goto ConsumeInnerNullsError;
    if (pcmi->cInnerNullPairs)
        goto SuccessReturn;

    // certificates
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_CERTIFICATES)) {
        if (pbuf->cbUsed > pbuf->cbDead) {
            if (ICM_TAG_CONSTRUCTED_CONTEXT_0 ==
                                    *(pbuf->pbData + pbuf->cbDead)) {
                // Detected the [0] IMPLICIT indicating certificates.
                // Change the identifier octet so it will decode properly.
                *(pbuf->pbData + pbuf->cbDead) = ICM_TAG_SET;
                if (!ICMS_DecodePDU(
                        pcmi,
                        pDec,
                        CertificatesNC_PDU,
                        (void **)&pCertificates))
                    goto DecodeCertificatesError;
                if (pCertificates) {
                    for (i=pCertificates->count,
#ifdef OSS_CRYPT_ASN1
                                pAny=pCertificates->certificates;
#else
                                pAny=pCertificates->value;
#endif  // OSS_CRYPT_ASN1
                            i>0;
                            i--, pAny++) {
                        if (!ICM_InsertTailBlob( psdi->pCertificateList, pAny))
                            goto CertInsertTailBlobError;
                    }
                    pcmi->aflDecode |= ICMS_DECODED_SIGNED_CERTIFICATES;
                } else {
                    // The decode failed, presumably due to insufficient data.
                    // Restore the original tag, so we will enter this block
                    // and try again on the next call.
                    *(pbuf->pbData + pbuf->cbDead) = ICM_TAG_CONSTRUCTED_CONTEXT_0;
                }
            } else {
                // Certificates not present. Mark them as decoded.
                pcmi->aflDecode |= ICMS_DECODED_SIGNED_CERTIFICATES;
            }
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_CERTIFICATES))
        goto SuccessReturn;


    // crls
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_CRLS)) {
        if (pbuf->cbUsed > pbuf->cbDead) {
            if (ICM_TAG_CONSTRUCTED_CONTEXT_1 ==
                                    *(pbuf->pbData + pbuf->cbDead)) {
                // Detected the [1] IMPLICIT indicating crls.
                // Change the identifier octet so it will decode properly.
                *(pbuf->pbData + pbuf->cbDead) = ICM_TAG_SET;
                if (!ICMS_DecodePDU(
                        pcmi,
                        pDec,
                        CrlsNC_PDU,
                        (void **)&pCrls))
                    goto DecodeCrlsError;
                if (pCrls) {
                    for (i=pCrls->count,
#ifdef OSS_CRYPT_ASN1
                                pAny=pCrls->crls;
#else
                                pAny=pCrls->value;
#endif  // OSS_CRYPT_ASN1
                            i>0;
                            i--, pAny++) {
                        if (!ICM_InsertTailBlob( psdi->pCrlList, pAny))
                            goto CrlInsertTailBlobError;
                    }
                    pcmi->aflDecode |= ICMS_DECODED_SIGNED_CRLS;
                } else {
                    // The decode failed, presumably due to insufficient data.
                    // Restore the original tag, so we will enter this block
                    // and try again on the next call.
                    *(pbuf->pbData + pbuf->cbDead) = ICM_TAG_CONSTRUCTED_CONTEXT_1;
                }
            } else {
                // Crls not present. Mark them as decoded.
                pcmi->aflDecode |= ICMS_DECODED_SIGNED_CRLS;
            }
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_CRLS))
        goto SuccessReturn;


    // signerInfos
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_SIGNERINFOS)) {
        if (!ICMS_DecodePDU(
                pcmi,
                pDec,
                SignerInfosNC_PDU,
                (void **)&pSignerInfos))
            goto DecodeSignerInfosError;
        if (pSignerInfos) {
            for (i=pSignerInfos->count, pAny=pSignerInfos->value;
                    i>0;
                    i--, pAny++) {
                if (!ICM_InsertTailSigner( psdi->pSignerList, pAny))
                    goto SignerInfoInsertTailBlobError;
            }
            pcmi->aflDecode |= ICMS_DECODED_SIGNED_SIGNERINFOS;
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_SIGNERINFOS))
        goto SuccessReturn;

    if (!ICMS_ConsumeTrailingNulls( pcmi, &pcmi->cEndNullPairs, fFinal))
        goto ConsumeEndNullsError;
    if (0 == pcmi->cEndNullPairs)
        pcmi->aflStream |= ICMS_DECODED_SUFFIX;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeInfo( pDec, CertificatesNC_PDU, pCertificates);
    PkiAsn1FreeInfo( pDec, CrlsNC_PDU, pCrls);
    PkiAsn1FreeInfo( pDec, SignerInfosNC_PDU, pSignerInfos);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(ConsumeInnerNullsError)            // error already set
TRACE_ERROR(DecodeCertificatesError)           // error already set
TRACE_ERROR(CertInsertTailBlobError)           // error already set
TRACE_ERROR(DecodeCrlsError)                   // error already set
TRACE_ERROR(CrlInsertTailBlobError)            // error already set
TRACE_ERROR(DecodeSignerInfosError)            // error already set
TRACE_ERROR(SignerInfoInsertTailBlobError)     // error already set
TRACE_ERROR(ConsumeEndNullsError)              // error already set
}


//+-------------------------------------------------------------------------
//  Handle incremental suffix data to be decoded, for an enveloped message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeSuffixEnveloped(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    BOOL                fRet;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    PICM_BUFFER         pbuf = &pcmi->bufDecode;
    Attributes          *pAttributes = NULL;
#ifdef CMS_PKCS7
    CmsEnvelopedData    *ped = (CmsEnvelopedData *)pcmi->pvMsg;
#endif  // CMS_PKCS7
    OSS_DECODE_INFO     odi;
    COssDecodeInfoNode  *pnOssDecodeInfo;

    if (!ICMS_ConsumeTrailingNulls( pcmi, &pcmi->cInnerNullPairs, fFinal))
        goto ConsumeInnerNullsError;
    if (pcmi->cInnerNullPairs)
        goto SuccessReturn;

    // unprotectedAttrs[1] IMPLICIT UnprotectedAttributes OPTIONAL
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ATTR)) {
        if (pbuf->cbUsed > pbuf->cbDead) {
            if (ICM_TAG_CONSTRUCTED_CONTEXT_1 ==
                                    *(pbuf->pbData + pbuf->cbDead)) {
                // Detected the [1] IMPLICIT indicating unprotectedAttrs.
                // Change the identifier octet so it will decode properly.
                *(pbuf->pbData + pbuf->cbDead) = ICM_TAG_SET;

                if (!ICMS_DecodePDU(
                        pcmi,
                        pDec,
                        Attributes_PDU,
                        (void **)&pAttributes))
                    goto DecodeAttributesError;
                if (pAttributes) {
#ifdef CMS_PKCS7
                    ped->unprotectedAttrs = *pAttributes;
                    ped->bit_mask |= unprotectedAttrs_present;
#endif  // CMS_PKCS7
                    odi.iPDU  = Attributes_PDU;
                    odi.pvPDU = pAttributes;
                    if (NULL == (pnOssDecodeInfo =
                            new COssDecodeInfoNode( &odi))) {
                        PkiAsn1FreeInfo( pDec, odi.iPDU, odi.pvPDU);
                        goto NewOssDecodeInfoNodeError;
                    }
                    pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ATTR;
                    pcmi->plDecodeInfo->InsertTail( pnOssDecodeInfo);
                } else {
                    // The decode failed, presumably due to insufficient data.
                    // Restore the original tag, so we will enter this block
                    // and try again on the next call.
                    *(pbuf->pbData + pbuf->cbDead) =
                        ICM_TAG_CONSTRUCTED_CONTEXT_1;
                }
            } else {
                // unprotectedAttrs not present. Mark them as decoded.
                pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ATTR;
            }
        } else if (fFinal)
            // unprotectedAttrs not present. Mark them as decoded.
            pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ATTR;

    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ATTR))
        goto SuccessReturn;


    if (!ICMS_ConsumeTrailingNulls( pcmi, &pcmi->cEndNullPairs, fFinal))
        goto ConsumeEndNullsError;
    if (0 == pcmi->cEndNullPairs)
        pcmi->aflStream |= ICMS_DECODED_SUFFIX;
SuccessReturn:
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(ConsumeInnerNullsError)            // error already set
TRACE_ERROR(DecodeAttributesError)             // error already set
TRACE_ERROR(NewOssDecodeInfoNodeError)         // error already set
TRACE_ERROR(ConsumeEndNullsError)              // error already set

}


//+-------------------------------------------------------------------------
//  Handle incremental suffix data to be decoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeSuffix(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;

    switch (pcmi->dwMsgType) {
    case CMSG_DATA:
        fRet = ICMS_DecodeSuffixData( pcmi, fFinal);
        break;
    case CMSG_SIGNED:
        fRet = ICMS_DecodeSuffixSigned( pcmi, fFinal);
        break;
    case CMSG_ENVELOPED:
        fRet = ICMS_DecodeSuffixEnveloped( pcmi, fFinal);
        break;
    case CMSG_HASHED:
        // fRet = ICMS_DecodeSuffixDigested( pcmi, fFinal);
        // break;
    case CMSG_SIGNED_AND_ENVELOPED:
    case CMSG_ENCRYPTED:
        goto MessageTypeNotSupportedYet;
    default:
        goto InvalidMsgType;
    }

    if (!fRet)
        goto ErrorReturn;

CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
TRACE_ERROR(InvalidMsgType)                     // error already set
}


//+-------------------------------------------------------------------------
//  Decrypt and output pending decode data.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeDecryptAndOutput(
    IN PCRYPT_MSG_INFO  pcmi,
    IN OUT PICM_BUFFER  pbufDecode,
    IN OUT PDWORD       pcbPending,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    BOOL        fBlockCipher = pcmi->fBlockCipher;
    PICM_BUFFER pbufCrypt  = &pcmi->bufCrypt;
    DWORD       cbCipher;
    DWORD       cb;

    for (cbCipher = min( *pcbPending, pbufDecode->cbUsed - pbufDecode->cbDead);
            cbCipher > 0;) {
        cb = min( cbCipher, pbufCrypt->cbSize - pbufCrypt->cbUsed); // must fit
        CopyMemory(
                pbufCrypt->pbData  + pbufCrypt->cbUsed,
                pbufDecode->pbData + pbufDecode->cbDead,
                cb);
        pbufCrypt->cbUsed  += cb;
        pbufDecode->cbDead += cb;
        *pcbPending        -= cb;
        cbCipher           -= cb;
        if (pbufCrypt->cbSize == pbufCrypt->cbUsed) {
            // Decrypt and copy out the buffer
            cb = pbufCrypt->cbSize;
            if (fBlockCipher) {
                // Keep the last block
                cb -= pcmi->cbBlockSize;
            }
            if (!CryptDecrypt(
                        pcmi->hkeyContentCrypt,
                        NULL,                           // hHash
                        FALSE,                          // fFinal
                        0,                              // dwFlags
                        pbufCrypt->pbData,
                        &cb))
                goto DecryptError;
            if (!ICMS_Output(
                        pcmi,
                        pbufCrypt->pbData,
                        cb,
                        FALSE))                         // fFinal
                goto OutputError;

            if (fBlockCipher) {
                // Move the last block to the beginning of the buffer
                // and reset the count to start after this block.
                // Since we are sure the src and dst do not overlap,
                // use CopyMemory (faster than MoveMemory).
                cb = pbufCrypt->cbSize - pcmi->cbBlockSize;
                CopyMemory(
                    pbufCrypt->pbData,
                    pbufCrypt->pbData + cb,
                    pcmi->cbBlockSize);
                pbufCrypt->cbUsed = pcmi->cbBlockSize;
            } else {
                pbufCrypt->cbUsed = 0;
            }
        }
    }

    if (fFinal) {
        if (cb = pbufCrypt->cbUsed) {
            if (!CryptDecrypt(
                        pcmi->hkeyContentCrypt,
                        NULL,                           // hHash
                        TRUE,                           // fFinal
                        0,                              // dwFlags
                        pbufCrypt->pbData,
                        &cb))
                goto FinalDecryptError;
        }
        if (!ICMS_Output(
                    pcmi,
                    pbufCrypt->pbData,
                    cb,
                    TRUE))                          // fFinal
            goto FinalOutputError;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecryptError)           // error already set
TRACE_ERROR(FinalDecryptError)      // error already set
TRACE_ERROR(OutputError)            // error already set
TRACE_ERROR(FinalOutputError)       // error already set
}

//+-------------------------------------------------------------------------
//  Given a key for decryption, prepare for the decryption to proceed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_SetDecryptKey(
    IN PCRYPT_MSG_INFO  pcmi,
    IN HCRYPTKEY        hkeyDecrypt)
{
    BOOL            fRet;
    DWORD           cbPending;
    PICM_BUFFER     pbufPendingCrypt  = &pcmi->bufPendingCrypt;

    if (pcmi->hkeyContentCrypt) {
        SetLastError((DWORD) CRYPT_E_ALREADY_DECRYPTED);
        return FALSE;
    }

    pcmi->hkeyContentCrypt = hkeyDecrypt;

    if (!ICMS_CreateEnvelopedBuffer( pcmi))
        goto CreateEnvelopedBufferError;
    pcmi->bufCrypt.cbSize += pcmi->cbBlockSize; // use whole thing for decode

    // Decrypt any pending ciphertext
    cbPending = pbufPendingCrypt->cbUsed - pbufPendingCrypt->cbDead;
    if (!ICMS_DecodeDecryptAndOutput(
            pcmi,
            pbufPendingCrypt,
            &cbPending,
            0 != (pcmi->aflStream & (ICMS_DECODED_CONTENT | ICMS_FINAL))))
        goto DecryptAndOutputError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    pcmi->hkeyContentCrypt = 0;             // caller closes hkeyDecrypt on
                                            // error
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CreateEnvelopedBufferError)     // error already set
TRACE_ERROR(DecryptAndOutputError)          // error already set
}


//+-------------------------------------------------------------------------
//  Decode callback.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeCallback(
    IN const void       *pvArg,
    IN OUT PICM_BUFFER  pbuf,
    IN OUT PDWORD       pcbPending,
    IN BOOL             fFinal)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
    PCRYPT_MSG_INFO pcmi = (PCRYPT_MSG_INFO)pvArg;
    PBYTE           pbData = pbuf->pbData + pbuf->cbDead;
    DWORD           cbData = min( *pcbPending, pbuf->cbUsed - pbuf->cbDead);

    if (CMSG_ENVELOPED == pcmi->dwMsgType) {
        if (NULL == pcmi->hkeyContentCrypt) {
            // Allow ciphertext to pile up until the decrypt key is set via
            // CryptMsgControl(... CMSG_CTRL_DECRYPT ...)
            if (!ICMS_QueueToBuffer(&pcmi->bufPendingCrypt, pbData, cbData))
                goto QueuePendingCryptError;

            pbuf->cbDead += cbData;
            *pcbPending  -= cbData;
        } else if (!ICMS_DecodeDecryptAndOutput(
                    pcmi,
                    pbuf,
                    pcbPending,
                    fFinal))
            goto DecryptAndOutputError;
    } else {
        if (cbData && pcmi->pHashList) {
            if (!ICM_UpdateListDigest( pcmi->pHashList, pbData, cbData))
                goto UpdateDigestError;
        }

        pbuf->cbDead += cbData;
        *pcbPending  -= cbData;
        if (!ICMS_Output( pcmi, pbData, cbData, fFinal))
            goto OutputError;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(QueuePendingCryptError)         // error already set
TRACE_ERROR(DecryptAndOutputError)          // error already set
TRACE_ERROR(UpdateDigestError)              // error already set
TRACE_ERROR(OutputError)                    // error already set
}


//+-------------------------------------------------------------------------
//  Hash callback.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_HashCallback(
    IN const void       *pvArg,
    IN OUT PICM_BUFFER  pbuf,
    IN OUT PDWORD       pcbPending,
    IN BOOL             fFinal)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
    PBYTE           pbData = pbuf->pbData + pbuf->cbDead;
    DWORD           cbData = min( *pcbPending, pbuf->cbUsed - pbuf->cbDead);

    if (pvArg) {
        if (!ICM_UpdateListDigest( (CHashList *)pvArg, pbData, cbData))
            goto UpdateDigestError;
    }

    pbuf->cbDead += cbData;
    *pcbPending  -= cbData;

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(UpdateDigestError)               // error already set
fFinal;
}


//+-------------------------------------------------------------------------
//  Hash incremental content data to be encoded, for an octet string.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_HashContent(
    IN PCRYPT_MSG_INFO  pcmi,
    IN PBYTE            pbData,
    IN DWORD            cbData)
{
    BOOL        fRet;

    if (!ICMS_QueueToBuffer( &pcmi->bufEncode, (PBYTE)pbData, cbData))
        goto QueueToBufferError;

    if (!ICMS_ProcessStringContent(
                &pcmi->bufEncode,
                &pcmi->aflStream,
                &pcmi->cbDefiniteRemain,
                &pcmi->cLevelIndefiniteInner,
                ICMS_HashCallback,
                pcmi->pHashList))
        goto ProcessStringContentError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(QueueToBufferError)                // error already set
TRACE_ERROR(ProcessStringContentError)         // error already set
}


//+-------------------------------------------------------------------------
//  Handle incremental content data to be decoded, for an octet string.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeContentOctetString(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    BOOL        fRet;

    if (!ICMS_ProcessStringContent(
                &pcmi->bufDecode,
                &pcmi->aflStream,
                &pcmi->cbDefiniteRemain,
                &pcmi->cLevelIndefiniteInner,
                ICMS_DecodeCallback,
                pcmi))
        goto ProcessStringContentError;

    if (pcmi->aflStream & ICMS_PROCESS_CONTENT_DONE)
        pcmi->aflStream |= ICMS_DECODED_CONTENT;

    if (fFinal &&
            (pcmi->cbDefiniteRemain ||
             pcmi->cLevelIndefiniteInner ||
             (0 == (pcmi->aflStream & ICMS_DECODED_CONTENT)))) {
        goto PrematureFinalError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(PrematureFinalError,CRYPT_E_STREAM_INSUFFICIENT_DATA)
TRACE_ERROR(ProcessStringContentError)         // error already set
}


//+-------------------------------------------------------------------------
//  Handle incremental content data to be decoded, for a sequence.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeContentSequence(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    BOOL        fRet;
    PICM_BUFFER pbuf = &pcmi->bufDecode;
    PBYTE       pbData = pbuf->pbData + pbuf->cbDead;
    DWORD       cbData = pbuf->cbUsed - pbuf->cbDead;
    LONG        lSkipped;
    DWORD       cbContent;
    const BYTE  *pbContent;

    if (pcmi->aflStream & ICMS_PROCESS_CONTENT_BEGUN)
        goto MultipleContentSequenceError;

    // Get the tag and length for the inner content
    if (0 > (lSkipped = Asn1UtilExtractContent(
                        pbData,
                        cbData,
                        &cbContent,
                        &pbContent))) {
        if (ASN1UTIL_INSUFFICIENT_DATA != lSkipped)
            goto ExtractContentError;
        else
            goto SuccessReturn;
    }

    if (CMSG_INDEFINITE_LENGTH == cbContent)
        goto IndefiniteLengthInnerContentNotImplemented;

    // Output the tag and length octets for the encoded inner content.
    // Note, not included in the content to be verified in a signature.
    if (!ICMS_Output( pcmi, pbData, (DWORD) lSkipped, FALSE))
        goto OutputError;

    pcmi->aflStream |= ICMS_INNER_OCTETSTRING;
    // Decode as an octet string. Will skip the tag and length octets
    fRet = ICMS_DecodeContentOctetString(pcmi, fFinal);

CommonReturn:
    return fRet;

SuccessReturn:
    fRet = TRUE;
    goto CommonReturn;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(MultipleContentSequenceError, CRYPT_E_MSG_ERROR)
TRACE_ERROR(ExtractContentError)
SET_ERROR(IndefiniteLengthInnerContentNotImplemented, E_NOTIMPL)
TRACE_ERROR(OutputError)
}


//+-------------------------------------------------------------------------
//  Handle incremental prefix data to be decoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodeContent(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    PICM_BUFFER pbuf = &pcmi->bufDecode;

    if (pcmi->aflStream & ICMS_RAW_DATA) {
        // Should be able to skip bufDecode for this case.
        if (!ICMS_Output(
                pcmi,
                pbuf->pbData + pbuf->cbDead,
                pbuf->cbUsed - pbuf->cbDead,
                fFinal))
            goto RawOutputError;
        pbuf->cbDead = pbuf->cbUsed;

        if (fFinal)
            pcmi->aflStream |= ICMS_DECODED_CONTENT | ICMS_DECODED_SUFFIX;

    } else if (pcmi->aflStream & ICMS_INNER_OCTETSTRING) {
        if (!ICMS_DecodeContentOctetString( pcmi, fFinal))
            goto DecodeContentOctetStringError;

    } else {
        if (!ICMS_DecodeContentSequence( pcmi, fFinal))
            goto DecodeContentSequenceError;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(RawOutputError)                     // error already set
TRACE_ERROR(DecodeContentOctetStringError)      // error already set
TRACE_ERROR(DecodeContentSequenceError)         // error already set
}


//+-------------------------------------------------------------------------
//  Handle incremental prefix data to be decoded, for a data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodePrefixData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    if (0 ==(pcmi->aflStream & ICMS_NONBARE))
        pcmi->aflStream |= ICMS_RAW_DATA;
    pcmi->aflStream |= ICMS_DECODED_PREFIX | ICMS_INNER_OCTETSTRING;
    return TRUE;
}


//+-------------------------------------------------------------------------
//  Handle incremental prefix data to be decoded, for a signed message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodePrefixSigned(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    DWORD                           dwError = ERROR_SUCCESS;
    BOOL                            fRet;
    ASN1decoding_t                  pDec = ICM_GetDecoder();
    PSIGNED_DATA_INFO               psdi = pcmi->psdi;
    DWORD                           dwToken;
    int                             *piVersion = NULL;
    DigestAlgorithmIdentifiersNC    *pDigestAlgorithms = NULL;
    Any                             *pAny;
    DWORD                           cb;
    DWORD                           i;
    BOOL                            fNoContent;

    if (NULL == psdi) {
        if (NULL == (psdi = (PSIGNED_DATA_INFO)ICM_AllocZero(
                                sizeof(SIGNED_DATA_INFO))))
            goto SdiAllocError;
        pcmi->psdi = psdi;

        if (NULL == (psdi->pAlgidList = new CBlobList))
            goto NewAlgidListError;
        if (NULL == (psdi->pCertificateList = new CBlobList))
            goto NewCertificateListError;
        if (NULL == (psdi->pCrlList = new CBlobList))
            goto NewCrlListError;
        if (NULL == (psdi->pSignerList = new CSignerList))
            goto NewSignerListError;
    }

    // SignedData sequence
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_SEQ)) {
        if (!ICMS_GetToken( &pcmi->bufDecode, &dwToken, NULL))
            goto GetTokenError;
        switch(dwToken) {
        case ICMS_TOKEN_INDEFINITE:     pcmi->cEndNullPairs++; break;
        case ICMS_TOKEN_DEFINITE:                              break;
        case ICMS_TOKEN_INCOMPLETE:     goto SuccessReturn;
        default:                        goto InvalidTokenError;
        }
        pcmi->aflDecode |= ICMS_DECODED_SIGNED_SEQ;
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_SEQ))
        goto SuccessReturn;


    // version
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_VERSION)) {
        if (!ICMS_DecodePDU(
                pcmi,
                pDec,
                IntegerType_PDU,
                (void **)&piVersion))
            goto DecodeVersionError;
        if (piVersion) {
            psdi->version = *piVersion;
            pcmi->aflDecode |= ICMS_DECODED_SIGNED_VERSION;
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_VERSION))
        goto SuccessReturn;


    // digestAlgorithms
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_DIGESTALGOS)) {
        if (!ICMS_DecodePDU(
                pcmi,
                pDec,
                DigestAlgorithmIdentifiersNC_PDU,
                (void **)&pDigestAlgorithms))
            goto DecodeDigestAlgorithmsError;
        if (pDigestAlgorithms) {
            for (i=pDigestAlgorithms->count, pAny=pDigestAlgorithms->value;
                    i>0;
                    i--, pAny++) {
                if (!ICM_InsertTailBlob( psdi->pAlgidList, pAny))
                    goto DigestAlgorithmInsertTailBlobError;
            }
            // We have the algorithms. Now create the hash handles.
            if (!ICM_CreateHashList(
                    pcmi->hCryptProv,
                    &pcmi->pHashList,
                    pcmi->psdi->pAlgidList))
                goto CreateHashListError;
            pcmi->aflDecode |= ICMS_DECODED_SIGNED_DIGESTALGOS;
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_DIGESTALGOS))
        goto SuccessReturn;


    // contentInfo
    if (0 == (pcmi->aflDecode & ICMS_DECODED_SIGNED_CONTENTINFO)) {
        if (!ICMS_DecodePrefixContentInfo(
                    pcmi,
                    &pcmi->pooid,
                    &pcmi->cInnerNullPairs,
                    &pcmi->aflInner,
                    &fNoContent))
            goto DecodePrefixSignedContentInfoError;
        if (pcmi->aflInner & ICMS_DECODED_CONTENTINFO_CONTENT) {
            // We cracked the whole header.
            // Translate the inner contentType oid into a string.
            if (!PkiAsn1FromObjectIdentifier(
                    pcmi->pooid->count,
                    pcmi->pooid->value,
                    NULL,
                    &cb))
                goto PkiAsn1FromObjectIdentifierSizeError;
            if (NULL == (psdi->pci = (PCONTENT_INFO)ICM_Alloc(
                                        cb + INFO_LEN_ALIGN(sizeof(CONTENT_INFO)))))
                goto AllocContentInfoError;
            psdi->pci->pszContentType = (LPSTR)(psdi->pci) +
                                        INFO_LEN_ALIGN(sizeof(CONTENT_INFO));
            psdi->pci->content.cbData = 0;
            psdi->pci->content.pbData = NULL;
            if (!PkiAsn1FromObjectIdentifier(
                    pcmi->pooid->count,
                    pcmi->pooid->value,
                    psdi->pci->pszContentType,
                    &cb))
                goto PkiAsn1FromObjectIdentifierError;
            PkiAsn1FreeDecoded(pDec, pcmi->pooid, ObjectIdentifierType_PDU);
            pcmi->pooid = NULL;
            pcmi->aflDecode |= ICMS_DECODED_SIGNED_CONTENTINFO;

            if (fNoContent) {
                // No content. Output final flag with no content.
                if (!ICMS_Output(pcmi, NULL, 0, TRUE))
                    goto OutputError;
                pcmi->aflStream |= ICMS_DECODED_CONTENT;
            } else {
                if (0 == strcmp( psdi->pci->pszContentType, pszObjIdDataType)
#ifdef CMS_PKCS7
                        || psdi->version >= CMSG_SIGNED_DATA_V3 
#endif  // CMS_PKCS7
                        )
                    pcmi->aflStream |= ICMS_INNER_OCTETSTRING;
            }
            pcmi->aflStream |= ICMS_DECODED_PREFIX;
        }
    }

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeInfo( pDec, IntegerType_PDU, piVersion);
    PkiAsn1FreeInfo( pDec, DigestAlgorithmIdentifiersNC_PDU, pDigestAlgorithms);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    // note, pcmi->psdi and pcmi->pooid are freed in CryptMsgClose
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SdiAllocError)                              // error already set
TRACE_ERROR(NewAlgidListError)                          // error already set
TRACE_ERROR(NewCertificateListError)                    // error already set
TRACE_ERROR(NewCrlListError)                            // error already set
TRACE_ERROR(NewSignerListError)                         // error already set
TRACE_ERROR(GetTokenError)                              // error already set
TRACE_ERROR(InvalidTokenError)                          // error already set
TRACE_ERROR(DecodeVersionError)                         // error already set
TRACE_ERROR(DecodeDigestAlgorithmsError)                // error already set
TRACE_ERROR(DigestAlgorithmInsertTailBlobError)         // error already set
TRACE_ERROR(CreateHashListError)                        // error already set
TRACE_ERROR(DecodePrefixSignedContentInfoError)         // error already set
TRACE_ERROR(PkiAsn1FromObjectIdentifierSizeError)       // error already set
TRACE_ERROR(AllocContentInfoError)                      // error already set
TRACE_ERROR(PkiAsn1FromObjectIdentifierError)           // error already set
TRACE_ERROR(OutputError)                                // error already set
}

//+-------------------------------------------------------------------------
//  Handle incremental prefix data to be decoded, for an enveloped message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodePrefixEnveloped(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    PICM_BUFFER         pbuf = &pcmi->bufDecode;
#ifdef CMS_PKCS7
    CmsEnvelopedData    *ped = (CmsEnvelopedData *)pcmi->pvMsg;
#else
    EnvelopedData       *ped = (EnvelopedData *)pcmi->pvMsg;
#endif  // CMS_PKCS7
    DWORD               dwToken;
    int                 *piVersion = NULL;
#ifdef CMS_PKCS7
    CmsRecipientInfos   *pRecipientInfos = NULL;
#else
    RecipientInfos      *pRecipientInfos = NULL;
#endif  // CMS_PKCS7
    ObjectIdentifierType *pooidContentType = NULL;
    AlgorithmIdentifier *poaidContentEncryption = NULL;
    COssDecodeInfoNode  *pnOssDecodeInfo;
    OSS_DECODE_INFO     odi;
    DWORD               cbConsumed;

#ifdef CMS_PKCS7
    OriginatorInfoNC    *pOriginatorInfo = NULL;
    Any                 *pAny;
    DWORD               i;
#endif  // CMS_PKCS7

    if (NULL == ped) {
#ifdef CMS_PKCS7
        if (NULL == (ped = (CmsEnvelopedData *)ICM_AllocZero(
                                sizeof(CmsEnvelopedData))))
#else
        if (NULL == (ped = (EnvelopedData *)ICM_AllocZero(
                                sizeof(EnvelopedData))))
#endif  // CMS_PKCS7
            goto AllocEnvelopedDataError;
        pcmi->pvMsg = ped;
        if (NULL == (pcmi->plDecodeInfo = new COssDecodeInfoList))
            goto NewCOssDecodeInfoListError;

#ifdef CMS_PKCS7
        if (NULL == (pcmi->pCertificateList = new CBlobList))
            goto NewCertificateListError;
        if (NULL == (pcmi->pCrlList = new CBlobList))
            goto NewCrlListError;
#endif  // CMS_PKCS7
    }

    // EnvelopedData SEQ
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_SEQ)) {
        if (!ICMS_GetToken( &pcmi->bufDecode, &dwToken, NULL))
            goto EnvelopedDataSeqGetTokenError;
        switch(dwToken) {
        case ICMS_TOKEN_INDEFINITE:     pcmi->cEndNullPairs++; break;
        case ICMS_TOKEN_DEFINITE:                              break;
        case ICMS_TOKEN_INCOMPLETE:     goto SuccessReturn;
        default:                        goto InvalidTokenError;
        }
        pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_SEQ;
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_SEQ))
        goto SuccessReturn;


    // version
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_VERSION)) {
        if (!ICMS_DecodePDU(
                pcmi,
                pDec,
                IntegerType_PDU,
                (void **)&piVersion))
            goto DecodeVersionError;
        if (piVersion) {
            ped->version = *piVersion;
            pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_VERSION;
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_VERSION))
        goto SuccessReturn;

#ifdef CMS_PKCS7
    // originatorInfo OPTIONAL
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ORIGINATOR)) {
        if (pbuf->cbUsed > pbuf->cbDead) {
            if (ICM_TAG_CONSTRUCTED_CONTEXT_0 ==
                                    *(pbuf->pbData + pbuf->cbDead)) {
                // Detected the [0] IMPLICIT indicating originatorInfo.
                // Change the identifier octet so it will decode properly.
                *(pbuf->pbData + pbuf->cbDead) = ICM_TAG_SEQ;
                if (!ICMS_DecodePDU(
                        pcmi,
                        pDec,
                        OriginatorInfoNC_PDU,
                        (void **)&pOriginatorInfo))
                    goto DecodeOriginatorInfoError;
                if (pOriginatorInfo) {
                    if (pOriginatorInfo->bit_mask & certificates_present) {
                        for (i=pOriginatorInfo->certificates.count,
#ifdef OSS_CRYPT_ASN1
                                pAny=pOriginatorInfo->certificates.certificates;
#else
                                pAny=pOriginatorInfo->certificates.value;
#endif  // OSS_CRYPT_ASN1
                                i>0;
                                i--, pAny++) {
                            if (!ICM_InsertTailBlob( pcmi->pCertificateList,
                                    pAny))
                                goto CertInsertTailBlobError;
                        }
                    }

                    if (pOriginatorInfo->bit_mask & crls_present) {
                        for (i=pOriginatorInfo->crls.count,
#ifdef OSS_CRYPT_ASN1
                                pAny=pOriginatorInfo->crls.crls;
#else
                                pAny=pOriginatorInfo->crls.value;
#endif  // OSS_CRYPT_ASN1
                                i>0;
                                i--, pAny++) {
                            if (!ICM_InsertTailBlob( pcmi->pCrlList, pAny))
                                goto CrlInsertTailBlobError;
                        }
                    }
                    pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ORIGINATOR;
                } else {
                    // The decode failed, presumably due to insufficient data.
                    // Restore the original tag, so we will enter this block
                    // and try again on the next call.
                    *(pbuf->pbData + pbuf->cbDead) =
                        ICM_TAG_CONSTRUCTED_CONTEXT_0;
                }
            } else {
                // originatorInfo not present. Mark as decoded.
                pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ORIGINATOR;
            }
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ORIGINATOR))
        goto SuccessReturn;
#endif  // CMS_PKCS7

    // recipientInfos
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_RECIPINFOS)) {
        if (!ICMS_DecodePDU(
                pcmi,
                pDec,
#ifdef CMS_PKCS7
                CmsRecipientInfos_PDU,
#else
                RecipientInfos_PDU,
#endif  // CMS_PKCS7
                (void **)&pRecipientInfos))
            goto DecodeRecipientInfosError;
        if (pRecipientInfos) {
            ped->recipientInfos = *pRecipientInfos;
#ifdef CMS_PKCS7
            odi.iPDU  = CmsRecipientInfos_PDU;
#else
            odi.iPDU  = RecipientInfos_PDU;
#endif  // CMS_PKCS7
            odi.pvPDU = pRecipientInfos;
            if (NULL == (pnOssDecodeInfo = new COssDecodeInfoNode( &odi))) {
                PkiAsn1FreeInfo( pDec, odi.iPDU, odi.pvPDU);
                goto NewOssDecodeInfoNodeError;
            }
            pcmi->plDecodeInfo->InsertTail( pnOssDecodeInfo);
            pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_RECIPINFOS;
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_RECIPINFOS))
        goto SuccessReturn;


    // encryptedContentInfo SEQ
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ECISEQ)) {
        if (!ICMS_GetToken( &pcmi->bufDecode, &dwToken, &pcmi->cbContentInfo))
            goto EncryptedContentInfoSeqGetTokenError;
        switch(dwToken) {
        case ICMS_TOKEN_INDEFINITE:     pcmi->cInnerNullPairs++; break;
        case ICMS_TOKEN_DEFINITE:                              break;
        case ICMS_TOKEN_INCOMPLETE:     goto SuccessReturn;
        default:                        goto InvalidTokenError;
        }
        pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ECISEQ;
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ECISEQ))
        goto SuccessReturn;


    // contentType
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ECITYPE)) {
        if (!ICMS_DecodePDU(
                pcmi,
                pDec,
                ObjectIdentifierType_PDU,
                (void **)&pooidContentType,
                &cbConsumed))
            goto DecodeContentTypeError;
        if (pooidContentType) {
            ICM_CopyOssObjectIdentifier(&ped->encryptedContentInfo.contentType,
                pooidContentType);
            // NB- Since ContentType is self-contained and we have saved
            // a copy, we can always free pooidContentType when this 
            // routine exits.
            pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ECITYPE;

            if (CMSG_INDEFINITE_LENGTH != pcmi->cbContentInfo) {
                if (cbConsumed > pcmi->cbContentInfo)
                    goto InvalidEncryptedContentInfoLength;
                pcmi->cbContentInfo -= cbConsumed;
            }
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ECITYPE))
        goto SuccessReturn;


    // contentEncryptionAlgorithm
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ECIALGID)) {
        if (!ICMS_DecodePDU(
                pcmi,
                pDec,
                AlgorithmIdentifier_PDU,
                (void **)&poaidContentEncryption,
                &cbConsumed))
            goto DecodeContentEncryptionAlgorithmError;
        if (poaidContentEncryption) {
            ped->encryptedContentInfo.contentEncryptionAlgorithm =
                                                    *poaidContentEncryption;
            odi.iPDU  = AlgorithmIdentifier_PDU;
            odi.pvPDU = poaidContentEncryption;
            if (NULL == (pnOssDecodeInfo = new COssDecodeInfoNode( &odi))) {
                PkiAsn1FreeInfo( pDec, AlgorithmIdentifier_PDU,
                    poaidContentEncryption);
                goto NewOssDecodeInfoNodeError;
            }
            pcmi->plDecodeInfo->InsertTail( pnOssDecodeInfo);
            pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ECIALGID;

            if (CMSG_INDEFINITE_LENGTH != pcmi->cbContentInfo &&
                    cbConsumed == pcmi->cbContentInfo) {
                // The encryptedContent has been omitted
                pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ECICONTENT;
                pcmi->aflStream |= ICMS_DECODED_PREFIX | ICMS_DECODED_CONTENT;

                if (pcmi->hkeyContentCrypt) {
                    if (!ICMS_Output(
                            pcmi,
                            NULL,                           // pbData
                            0,                              // cbData
                            TRUE))                          // fFinal
                        goto FinalOutputError;
                }
            }
        }
    }
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ECIALGID))
        goto SuccessReturn;


    // encryptedContent [0] IMPLICIT OPTIONAL
    //
    // Only support DATA or encapsulated encrypted content.
    if (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ECICONTENT)) {
        BOOL fNoEncryptedContent = FALSE;
        if (pbuf->cbUsed > pbuf->cbDead) {
            BYTE bTag = *(pbuf->pbData + pbuf->cbDead);
            if (ICM_TAG_CONTEXT_0 == (bTag & ~ICM_TAG_CONSTRUCTED)) {
                // Detected the [0] IMPLICIT indicating encryptedContent.
                // Change the identifier octet so it will decode properly.
                *(pbuf->pbData + pbuf->cbDead) = ICM_TAG_OCTETSTRING |
                    (bTag & ICM_TAG_CONSTRUCTED);

                pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ECICONTENT;
                // The inner type is always OCTET STRING
                pcmi->aflStream |= ICMS_DECODED_PREFIX | ICMS_INNER_OCTETSTRING;
            } else
                fNoEncryptedContent = TRUE;
        } else if (fFinal)
            fNoEncryptedContent = TRUE;

        if (fNoEncryptedContent) {
            // The encryptedContent has been omitted
            pcmi->aflDecode |= ICMS_DECODED_ENVELOPED_ECICONTENT;
            pcmi->aflStream |= ICMS_DECODED_PREFIX | ICMS_DECODED_CONTENT;

            if (pcmi->hkeyContentCrypt) {
                if (!ICMS_Output(
                        pcmi,
                        NULL,                           // pbData
                        0,                              // cbData
                        TRUE))                          // fFinal
                    goto FinalOutputError;
            }
        }
    }


SuccessReturn:
    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeInfo( pDec, IntegerType_PDU, piVersion);
#ifdef CMS_PKCS7
    PkiAsn1FreeInfo( pDec, OriginatorInfoNC_PDU, pOriginatorInfo);
#endif  // CMS_PKCS7
    PkiAsn1FreeInfo( pDec, ObjectIdentifierType_PDU, pooidContentType);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EnvelopedDataSeqGetTokenError)              // error already set
TRACE_ERROR(EncryptedContentInfoSeqGetTokenError)       // error already set
TRACE_ERROR(InvalidTokenError)                          // error already set
TRACE_ERROR(DecodeVersionError)                         // error already set
TRACE_ERROR(AllocEnvelopedDataError)                    // error already set
TRACE_ERROR(NewCOssDecodeInfoListError)                 // error already set
#ifdef CMS_PKCS7
TRACE_ERROR(NewCertificateListError)                    // error already set
TRACE_ERROR(NewCrlListError)                            // error already set
TRACE_ERROR(DecodeOriginatorInfoError)                  // error already set
TRACE_ERROR(CertInsertTailBlobError)                    // error already set
TRACE_ERROR(CrlInsertTailBlobError)                     // error already set
#endif  // CMS_PKCS7
TRACE_ERROR(DecodeRecipientInfosError)                  // error already set
TRACE_ERROR(DecodeContentTypeError)                     // error already set
SET_ERROR(InvalidEncryptedContentInfoLength, CRYPT_E_MSG_ERROR)
TRACE_ERROR(DecodeContentEncryptionAlgorithmError)      // error already set
TRACE_ERROR(NewOssDecodeInfoNodeError)                  // error already set
TRACE_ERROR(FinalOutputError)                           // error already set
}


//+-------------------------------------------------------------------------
//  Handle incremental prefix data to be decoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_DecodePrefix(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    LONG                lth;
    BOOL                fNoContent;

    if (0 == pcmi->dwMsgType) {
        pcmi->aflStream |= ICMS_NONBARE;
        if (!ICMS_DecodePrefixContentInfo(
                    pcmi,
                    &pcmi->pooid,
                    &pcmi->cEndNullPairs,
                    &pcmi->aflOuter,
                    &fNoContent))
            goto DecodePrefixContentInfoError;

        if (pcmi->aflOuter & ICMS_DECODED_CONTENTINFO_CONTENT) {
            // We cracked the whole header.
            // Translate the contentType oid into a message type.
            if (0 == (lth = ICM_ObjIdToIndex( pcmi->pooid)))
                goto UnknownContentTypeError;
            pcmi->dwMsgType = (DWORD)lth;
            PkiAsn1FreeDecoded(ICM_GetDecoder(), pcmi->pooid,
                ObjectIdentifierType_PDU);
            pcmi->pooid = NULL;


            // Address case of no content
        }
    }

    switch (pcmi->dwMsgType) {
    case 0:
        if (fFinal)
            goto FinalWithoutMessageTypeError;
        break;
    case CMSG_DATA:
        if (!ICMS_DecodePrefixData( pcmi, fFinal))
            goto DecodePrefixDataError;
        break;
    case CMSG_SIGNED:
        if (!ICMS_DecodePrefixSigned( pcmi, fFinal))
            goto DecodePrefixSignedError;
        break;
    case CMSG_ENVELOPED:
        if (!ICMS_DecodePrefixEnveloped( pcmi, fFinal))
            goto DecodePrefixEnvelopedError;
        break;
    case CMSG_HASHED:
        // if (!ICMS_DecodePrefixDigested( pcmi, fFinal))
        //     goto DecodePrefixDigestedError;
        // break;
    case CMSG_SIGNED_AND_ENVELOPED:
    case CMSG_ENCRYPTED:
        goto MessageTypeNotSupportedYet;
    default:
        goto InvalidMsgType;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(FinalWithoutMessageTypeError,CRYPT_E_STREAM_INSUFFICIENT_DATA)
TRACE_ERROR(UnknownContentTypeError)            // error already set
TRACE_ERROR(DecodePrefixContentInfoError)       // error already set
TRACE_ERROR(DecodePrefixDataError)              // error already set
TRACE_ERROR(DecodePrefixSignedError)            // error already set
TRACE_ERROR(DecodePrefixEnvelopedError)         // error already set
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
TRACE_ERROR(InvalidMsgType)                     // error already set
}


//+-------------------------------------------------------------------------
//  Handle incremental data to be decoded (work done here).
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_UpdateDecodingInner(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;

    if (0 == (pcmi->aflStream & ICMS_DECODED_PREFIX)) {
        if (!ICMS_DecodePrefix( pcmi, fFinal))
            goto DecodePrefixError;
    }
    if (0 == (pcmi->aflStream & ICMS_DECODED_PREFIX))
        goto SuccessReturn;


    if (0 == (pcmi->aflStream & ICMS_DECODED_CONTENT)) {
        if (!ICMS_DecodeContent( pcmi, fFinal))
            goto DecodeContentError; // NB- Do not trash err from callback!
    }
    if (0 == (pcmi->aflStream & ICMS_DECODED_CONTENT))
        goto SuccessReturn;


    if (0 == (pcmi->aflStream & ICMS_DECODED_SUFFIX)) {
        if (!ICMS_DecodeSuffix( pcmi, fFinal))
            goto DecodeSuffixError;
    }
    if (0 == (pcmi->aflStream & ICMS_DECODED_SUFFIX))
        goto SuccessReturn;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(DecodePrefixError)                      // error already set
TRACE_ERROR(DecodeContentError)                     // error already set
TRACE_ERROR(DecodeSuffixError)                      // error already set
}


//+-------------------------------------------------------------------------
//  Handle incremental data to be decoded.
//
//  Note, the buffer to be decoded may have some of its tags modified.
//  Therefore, we always need to copy to our own decode buffer.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_UpdateDecoding(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;

    pcmi->fStreamCallbackOutput = TRUE;

    if (!ICMS_QueueToBuffer( &pcmi->bufDecode, (PBYTE)pbData, cbData))
        goto QueueToBufferError;

    if (!ICMS_UpdateDecodingInner( pcmi, fFinal))
        goto UpdateDecodingInnerError;

    if (fFinal) {
        if (pcmi->bufDecode.cbUsed > pcmi->bufDecode.cbDead)
            goto ExcessDataError;
        pcmi->aflStream |= ICMS_FINAL;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(QueueToBufferError)                     // error already set
TRACE_ERROR(UpdateDecodingInnerError)               // error already set
SET_ERROR(ExcessDataError, CRYPT_E_MSG_ERROR)
}

#if 0
// When we fix the decoding of [0] Certificates and [1] Crls not to modify
// the encoded data we can replace the above with the following:

//+-------------------------------------------------------------------------
//  Handle incremental data to be decoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICMS_UpdateDecoding(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    PICM_BUFFER pbuf = &pcmi->bufDecode;
    BOOL        fNoCopy;

    pcmi->fStreamCallbackOutput = TRUE;
    if (fFinal && NULL == pbuf->pbData) {
        // We're able to use the input buffer without copying
        fNoCopy = TRUE;
        assert(0 == pbuf->cbSize && 0 == pbuf->cbUsed && 0 == pbuf->cbDead);
        pbuf->pbData = (PBYTE) pbData;
        pbuf->cbSize = cbData;
        pbuf->cbUsed = cbData;
        pbuf->cbDead = 0;
    } else {
        fNoCopy = FALSE;
        if (!ICMS_QueueToBuffer( pbuf, (PBYTE)pbData, cbData))
            goto QueueToBufferError;
    }

    if (!ICMS_UpdateDecodingInner( pcmi, fFinal))
        goto UpdateDecodingInnerError;

    if (fFinal) {
        if (pcmi->bufDecode.cbUsed > pcmi->bufDecode.cbDead)
            goto ExcessDataError;
        pcmi->aflStream |= ICMS_FINAL;
    }

    fRet = TRUE;
CommonReturn:
    if (fNoCopy)
        memset(pbuf, 0, sizeof(*pbuf));
        
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(QueueToBufferError)                     // error already set
TRACE_ERROR(UpdateDecodingInnerError)               // error already set
SET_ERROR(ExcessDataError, CRYPT_E_MSG_ERROR)
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\wincrmsg\pkcs.h ===
/* Copyright (C) Microsoft Corporation, 1996 - 1999 All rights reserved. */
/* ASN.1 definitions for GlobalDirectives */

#ifndef _PKCS_Module_H_
#define _PKCS_Module_H_

#include "msber.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef ASN1open_t SignerInfosNC_Set;

typedef ASN1open_t SetOfAny_Set;

typedef ASN1open_t AttributeSetValueNC_Set;

typedef ASN1open_t AttributeSetValue_Set;

typedef ASN1objectidentifier2_t ObjectID;
#define ObjectID_PDU 0
#define SIZE_PKCS_Module_PDU_0 sizeof(ObjectID)

typedef ASN1open_t Any;

typedef ObjectID ObjectIdentifierType;
#define ObjectIdentifierType_PDU 1
#define SIZE_PKCS_Module_PDU_1 sizeof(ObjectIdentifierType)

typedef ASN1octetstring_t OctetStringType;
#define OctetStringType_PDU 2
#define SIZE_PKCS_Module_PDU_2 sizeof(OctetStringType)

typedef ASN1int32_t IntegerType;
#define IntegerType_PDU 3
#define SIZE_PKCS_Module_PDU_3 sizeof(IntegerType)

typedef ASN1intx_t HugeIntegerType;
#define HugeIntegerType_PDU 4
#define SIZE_PKCS_Module_PDU_4 sizeof(HugeIntegerType)

typedef ASN1bitstring_t BitStringType;

typedef ASN1octetstring_t Digest;

typedef ASN1open_t CertificateRevocationList;

typedef ASN1open_t CertificateRevocationListNC;

typedef HugeIntegerType CertificateSerialNumber;

typedef ASN1open_t Name;

typedef ASN1open_t Certificate;

typedef ASN1open_t CertificateNC;

typedef ASN1open_t AlgorithmIdentifierNC;

typedef AlgorithmIdentifierNC DigestAlgorithmIdentifierNC;

typedef ASN1open_t AttributeNC;

typedef AlgorithmIdentifierNC ContentEncryptionAlgIdNC;

typedef ObjectID ContentType;

typedef ASN1octetstring_t Data;

typedef ASN1open_t DigestAlgorithmBlob;

typedef ASN1octetstring_t EncryptedDigest;

typedef ASN1octetstring_t EncryptedDigestNC;

typedef ASN1octetstring_t EncryptedContent;

typedef OctetStringType EncryptedKey;

typedef ASN1open_t CertIdentifierNC;

typedef OctetStringType SubjectKeyIdentifier;

typedef OctetStringType UserKeyingMaterial;

typedef struct AlgorithmIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID algorithm;
#   define AlgorithmIdentifier_parameters_present 0x80
    ASN1open_t parameters;
} AlgorithmIdentifier;
#define AlgorithmIdentifier_PDU 5
#define SIZE_PKCS_Module_PDU_5 sizeof(AlgorithmIdentifier)

typedef struct AlgorithmIdentifierNC2 {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID algorithm;
#   define AlgorithmIdentifierNC2_parameters_present 0x80
    ASN1open_t parameters;
} AlgorithmIdentifierNC2;
#define AlgorithmIdentifierNC2_PDU 6
#define SIZE_PKCS_Module_PDU_6 sizeof(AlgorithmIdentifierNC2)

typedef AlgorithmIdentifier DigestAlgorithmIdentifier;

typedef struct AlgorithmIdentifiers {
    ASN1uint32_t count;
    struct AlgorithmIdentifier *value;
} AlgorithmIdentifiers;
#define AlgorithmIdentifiers_PDU 7
#define SIZE_PKCS_Module_PDU_7 sizeof(AlgorithmIdentifiers)

typedef struct AttributeSetValue {
    ASN1uint32_t count;
    AttributeSetValue_Set *value;
} AttributeSetValue;
#define AttributeSetValue_PDU 8
#define SIZE_PKCS_Module_PDU_8 sizeof(AttributeSetValue)

typedef struct AttributeSetValueNC {
    ASN1uint32_t count;
    AttributeSetValueNC_Set *value;
} AttributeSetValueNC;
#define AttributeSetValueNC_PDU 9
#define SIZE_PKCS_Module_PDU_9 sizeof(AttributeSetValueNC)

typedef struct SetOfAny {
    ASN1uint32_t count;
    SetOfAny_Set *value;
} SetOfAny;
#define SetOfAny_PDU 10
#define SIZE_PKCS_Module_PDU_10 sizeof(SetOfAny)

typedef struct Attribute {
    ObjectID attributeType;
    AttributeSetValue attributeValue;
} Attribute;

typedef struct AttributeNC2 {
    ObjectID attributeType;
    AttributeSetValueNC attributeValue;
} AttributeNC2;
#define AttributeNC2_PDU 11
#define SIZE_PKCS_Module_PDU_11 sizeof(AttributeNC2)

typedef struct Attributes {
    ASN1uint32_t count;
    struct Attribute *value;
} Attributes;
#define Attributes_PDU 12
#define SIZE_PKCS_Module_PDU_12 sizeof(Attributes)

typedef struct AttributesNC {
    ASN1uint32_t count;
    AttributeNC *value;
} AttributesNC;
#define AttributesNC_PDU 13
#define SIZE_PKCS_Module_PDU_13 sizeof(AttributesNC)

typedef struct AttributesNC2 {
    ASN1uint32_t count;
    struct AttributeNC2 *value;
} AttributesNC2;
#define AttributesNC2_PDU 14
#define SIZE_PKCS_Module_PDU_14 sizeof(AttributesNC2)

typedef struct Crls {
    ASN1uint32_t count;
    CertificateRevocationList *value;
} Crls;

typedef struct CrlsNC {
    ASN1uint32_t count;
    CertificateRevocationListNC *value;
} CrlsNC;
#define CrlsNC_PDU 15
#define SIZE_PKCS_Module_PDU_15 sizeof(CrlsNC)

typedef AlgorithmIdentifier ContentEncryptionAlgId;

typedef AlgorithmIdentifier DigestEncryptionAlgId;

typedef AlgorithmIdentifierNC2 DigestEncryptionAlgIdNC;

typedef struct Certificates {
    ASN1uint32_t count;
    Certificate *value;
} Certificates;

typedef struct CertificatesNC {
    ASN1uint32_t count;
    CertificateNC *value;
} CertificatesNC;
#define CertificatesNC_PDU 16
#define SIZE_PKCS_Module_PDU_16 sizeof(CertificatesNC)

typedef struct IssuerAndSerialNumber {
    Name issuer;
    CertificateSerialNumber serialNumber;
} IssuerAndSerialNumber;
#define IssuerAndSerialNumber_PDU 17
#define SIZE_PKCS_Module_PDU_17 sizeof(IssuerAndSerialNumber)

typedef AlgorithmIdentifier KeyEncryptionAlgId;

typedef struct ContentInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentType;
#   define ContentInfo_content_present 0x80
    ASN1open_t content;
} ContentInfo;
#define ContentInfo_PDU 18
#define SIZE_PKCS_Module_PDU_18 sizeof(ContentInfo)

typedef struct ContentInfoNC {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentType;
#   define ContentInfoNC_content_present 0x80
    ASN1open_t content;
} ContentInfoNC;
#define ContentInfoNC_PDU 19
#define SIZE_PKCS_Module_PDU_19 sizeof(ContentInfoNC)

typedef struct DigestAlgorithmIdentifiers {
    ASN1uint32_t count;
    DigestAlgorithmIdentifier *value;
} DigestAlgorithmIdentifiers;

typedef struct DigestAlgorithmIdentifiersNC {
    ASN1uint32_t count;
    DigestAlgorithmIdentifierNC *value;
} DigestAlgorithmIdentifiersNC;
#define DigestAlgorithmIdentifiersNC_PDU 20
#define SIZE_PKCS_Module_PDU_20 sizeof(DigestAlgorithmIdentifiersNC)

typedef struct SignerInfos {
    ASN1uint32_t count;
    struct SignerInfo *value;
} SignerInfos;
#define SignerInfos_PDU 21
#define SIZE_PKCS_Module_PDU_21 sizeof(SignerInfos)

typedef struct DigestAlgorithmBlobs {
    ASN1uint32_t count;
    DigestAlgorithmBlob *value;
} DigestAlgorithmBlobs;
#define DigestAlgorithmBlobs_PDU 22
#define SIZE_PKCS_Module_PDU_22 sizeof(DigestAlgorithmBlobs)

typedef struct SignerInfosNC {
    ASN1uint32_t count;
    SignerInfosNC_Set *value;
} SignerInfosNC;
#define SignerInfosNC_PDU 23
#define SIZE_PKCS_Module_PDU_23 sizeof(SignerInfosNC)

typedef struct SignerInfoWithAABlobs {
    ASN1uint32_t count;
    struct SignerInfoWithAABlob *value;
} SignerInfoWithAABlobs;
#define SignerInfoWithAABlobs_PDU 24
#define SIZE_PKCS_Module_PDU_24 sizeof(SignerInfoWithAABlobs)

typedef struct SignerInfoWithAABlob {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1open_t version;
    ASN1open_t sid;
    ASN1open_t digestAlgorithm;
    ASN1open_t authenticatedAttributes;
    ASN1open_t digestEncryptionAlgorithm;
    ASN1open_t encryptedDigest;
#   define dummyUAAs_present 0x80
    AttributesNC dummyUAAs;
} SignerInfoWithAABlob;
#define SignerInfoWithAABlob_PDU 25
#define SIZE_PKCS_Module_PDU_25 sizeof(SignerInfoWithAABlob)

typedef struct SignerInfoWithAttrBlobs {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1open_t version;
    ASN1open_t sid;
    ASN1open_t digestAlgorithm;
#   define SignerInfoWithAttrBlobs_authAttributes_present 0x80
    AttributesNC authAttributes;
    DigestEncryptionAlgIdNC digestEncryptionAlgorithm;
    ASN1open_t encryptedDigest;
#   define SignerInfoWithAttrBlobs_unauthAttributes_present 0x40
    AttributesNC unauthAttributes;
} SignerInfoWithAttrBlobs;
#define SignerInfoWithAttrBlobs_PDU 26
#define SIZE_PKCS_Module_PDU_26 sizeof(SignerInfoWithAttrBlobs)

typedef struct SignerInfoWithBlobs {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    CertIdentifierNC sid;
    DigestAlgorithmIdentifierNC digestAlgorithm;
#   define SignerInfoWithBlobs_authAttributes_present 0x80
    AttributesNC2 authAttributes;
    DigestEncryptionAlgIdNC digestEncryptionAlgorithm;
    EncryptedDigestNC encryptedDigest;
#   define SignerInfoWithBlobs_unauthAttributes_present 0x40
    AttributesNC2 unauthAttributes;
} SignerInfoWithBlobs;
#define SignerInfoWithBlobs_PDU 27
#define SIZE_PKCS_Module_PDU_27 sizeof(SignerInfoWithBlobs)

typedef struct RecipientInfos {
    ASN1uint32_t count;
    struct RecipientInfo *value;
} RecipientInfos;
#define RecipientInfos_PDU 28
#define SIZE_PKCS_Module_PDU_28 sizeof(RecipientInfos)

typedef struct EncryptedContentInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ContentType contentType;
    ContentEncryptionAlgId contentEncryptionAlgorithm;
#   define encryptedContent_present 0x80
    EncryptedContent encryptedContent;
} EncryptedContentInfo;
#define EncryptedContentInfo_PDU 29
#define SIZE_PKCS_Module_PDU_29 sizeof(EncryptedContentInfo)

typedef struct RecipientInfo {
    ASN1int32_t version;
    IssuerAndSerialNumber issuerAndSerialNumber;
    KeyEncryptionAlgId keyEncryptionAlgorithm;
    EncryptedKey encryptedKey;
} RecipientInfo;
#define RecipientInfo_PDU 30
#define SIZE_PKCS_Module_PDU_30 sizeof(RecipientInfo)

typedef struct SignedAndEnvelopedData {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    RecipientInfos recipientInfos;
    DigestAlgorithmIdentifiers digestAlgorithms;
    EncryptedContentInfo encryptedContentInfo;
#   define SignedAndEnvelopedData_certificates_present 0x80
    Certificates certificates;
#   define SignedAndEnvelopedData_crls_present 0x40
    Crls crls;
    SignerInfos signerInfos;
} SignedAndEnvelopedData;
#define SignedAndEnvelopedData_PDU 31
#define SIZE_PKCS_Module_PDU_31 sizeof(SignedAndEnvelopedData)

typedef struct DigestedData {
    ASN1int32_t version;
    DigestAlgorithmIdentifier digestAlgorithm;
    ContentInfo contentInfo;
    Digest digest;
} DigestedData;
#define DigestedData_PDU 32
#define SIZE_PKCS_Module_PDU_32 sizeof(DigestedData)

typedef struct EncryptedData {
    ASN1int32_t version;
    EncryptedContentInfo encryptedContentInfo;
} EncryptedData;
#define EncryptedData_PDU 33
#define SIZE_PKCS_Module_PDU_33 sizeof(EncryptedData)

typedef struct CertIdentifier {
    ASN1choice_t choice;
    union {
#	define CertIdentifier_issuerAndSerialNumber_chosen 1
	IssuerAndSerialNumber issuerAndSerialNumber;
#	define CertIdentifier_subjectKeyIdentifier_chosen 2
	SubjectKeyIdentifier subjectKeyIdentifier;
    } u;
} CertIdentifier;
#define CertIdentifier_PDU 34
#define SIZE_PKCS_Module_PDU_34 sizeof(CertIdentifier)

typedef struct OriginatorInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define OriginatorInfo_certificates_present 0x80
    Certificates certificates;
#   define OriginatorInfo_crls_present 0x40
    Crls crls;
} OriginatorInfo;
#define OriginatorInfo_PDU 35
#define SIZE_PKCS_Module_PDU_35 sizeof(OriginatorInfo)

typedef struct OriginatorInfoNC {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
#   define OriginatorInfoNC_certificates_present 0x80
    CertificatesNC certificates;
#   define OriginatorInfoNC_crls_present 0x40
    CrlsNC crls;
} OriginatorInfoNC;
#define OriginatorInfoNC_PDU 36
#define SIZE_PKCS_Module_PDU_36 sizeof(OriginatorInfoNC)

typedef struct CmsRecipientInfos {
    ASN1uint32_t count;
    struct CmsRecipientInfo *value;
} CmsRecipientInfos;
#define CmsRecipientInfos_PDU 37
#define SIZE_PKCS_Module_PDU_37 sizeof(CmsRecipientInfos)

typedef struct KeyTransRecipientInfo {
    ASN1int32_t version;
    CertIdentifier rid;
    KeyEncryptionAlgId keyEncryptionAlgorithm;
    EncryptedKey encryptedKey;
} KeyTransRecipientInfo;
#define KeyTransRecipientInfo_PDU 38
#define SIZE_PKCS_Module_PDU_38 sizeof(KeyTransRecipientInfo)

typedef struct OriginatorPublicKey {
    AlgorithmIdentifier algorithm;
    BitStringType publicKey;
} OriginatorPublicKey;

typedef struct RecipientEncryptedKeys {
    ASN1uint32_t count;
    struct RecipientEncryptedKey *value;
} RecipientEncryptedKeys;

typedef struct OtherKeyAttribute {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ObjectID keyAttrId;
#   define keyAttr_present 0x80
    ASN1open_t keyAttr;
} OtherKeyAttribute;

typedef struct MailListKeyIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    OctetStringType kekIdentifier;
#   define MailListKeyIdentifier_date_present 0x80
    ASN1generalizedtime_t date;
#   define MailListKeyIdentifier_other_present 0x40
    OtherKeyAttribute other;
} MailListKeyIdentifier;

typedef struct DigestInfo {
    DigestAlgorithmIdentifier digestAlgorithm;
    Digest digest;
} DigestInfo;
#define DigestInfo_PDU 39
#define SIZE_PKCS_Module_PDU_39 sizeof(DigestInfo)

typedef struct SignedData {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    DigestAlgorithmIdentifiers digestAlgorithms;
    ContentInfo contentInfo;
#   define SignedData_certificates_present 0x80
    Certificates certificates;
#   define SignedData_crls_present 0x40
    Crls crls;
    SignerInfos signerInfos;
} SignedData;
#define SignedData_PDU 40
#define SIZE_PKCS_Module_PDU_40 sizeof(SignedData)

typedef struct SignerInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    CertIdentifier sid;
    DigestAlgorithmIdentifier digestAlgorithm;
#   define authenticatedAttributes_present 0x80
    Attributes authenticatedAttributes;
    DigestEncryptionAlgId digestEncryptionAlgorithm;
    EncryptedDigest encryptedDigest;
#   define SignerInfo_unauthAttributes_present 0x40
    Attributes unauthAttributes;
} SignerInfo;
#define SignerInfo_PDU 41
#define SIZE_PKCS_Module_PDU_41 sizeof(SignerInfo)

typedef struct SignedDataWithBlobs {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    DigestAlgorithmIdentifiersNC digestAlgorithms;
    ContentInfoNC contentInfo;
#   define SignedDataWithBlobs_certificates_present 0x80
    CertificatesNC certificates;
#   define SignedDataWithBlobs_crls_present 0x40
    CrlsNC crls;
    SignerInfosNC signerInfos;
} SignedDataWithBlobs;
#define SignedDataWithBlobs_PDU 42
#define SIZE_PKCS_Module_PDU_42 sizeof(SignedDataWithBlobs)

typedef struct EnvelopedData {
    ASN1int32_t version;
    RecipientInfos recipientInfos;
    EncryptedContentInfo encryptedContentInfo;
} EnvelopedData;
#define EnvelopedData_PDU 43
#define SIZE_PKCS_Module_PDU_43 sizeof(EnvelopedData)

typedef struct CmsEnvelopedData {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
#   define originatorInfo_present 0x80
    OriginatorInfo originatorInfo;
    CmsRecipientInfos recipientInfos;
    EncryptedContentInfo encryptedContentInfo;
#   define unprotectedAttrs_present 0x40
    Attributes unprotectedAttrs;
} CmsEnvelopedData;
#define CmsEnvelopedData_PDU 44
#define SIZE_PKCS_Module_PDU_44 sizeof(CmsEnvelopedData)

typedef struct OriginatorIdentifierOrKey {
    ASN1choice_t choice;
    union {
#	define OriginatorIdentifierOrKey_issuerAndSerialNumber_chosen 1
	IssuerAndSerialNumber issuerAndSerialNumber;
#	define OriginatorIdentifierOrKey_subjectKeyIdentifier_chosen 2
	SubjectKeyIdentifier subjectKeyIdentifier;
#	define originatorKey_chosen 3
	OriginatorPublicKey originatorKey;
    } u;
} OriginatorIdentifierOrKey;

typedef struct RecipientKeyIdentifier {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    SubjectKeyIdentifier subjectKeyIdentifier;
#   define RecipientKeyIdentifier_date_present 0x80
    ASN1generalizedtime_t date;
#   define RecipientKeyIdentifier_other_present 0x40
    OtherKeyAttribute other;
} RecipientKeyIdentifier;

typedef struct MailListRecipientInfo {
    ASN1int32_t version;
    MailListKeyIdentifier mlid;
    KeyEncryptionAlgId keyEncryptionAlgorithm;
    EncryptedKey encryptedKey;
} MailListRecipientInfo;
#define MailListRecipientInfo_PDU 45
#define SIZE_PKCS_Module_PDU_45 sizeof(MailListRecipientInfo)

typedef struct KeyAgreeRecipientInfo {
    union {
	ASN1uint16_t bit_mask;
	ASN1octet_t o[1];
    };
    ASN1int32_t version;
    OriginatorIdentifierOrKey originator;
#   define ukm_present 0x80
    UserKeyingMaterial ukm;
    KeyEncryptionAlgId keyEncryptionAlgorithm;
    RecipientEncryptedKeys recipientEncryptedKeys;
} KeyAgreeRecipientInfo;
#define KeyAgreeRecipientInfo_PDU 46
#define SIZE_PKCS_Module_PDU_46 sizeof(KeyAgreeRecipientInfo)

typedef struct RecipientIdentifier {
    ASN1choice_t choice;
    union {
#	define RecipientIdentifier_issuerAndSerialNumber_chosen 1
	IssuerAndSerialNumber issuerAndSerialNumber;
#	define rKeyId_chosen 2
	RecipientKeyIdentifier rKeyId;
    } u;
} RecipientIdentifier;

typedef struct CmsRecipientInfo {
    ASN1choice_t choice;
    union {
#	define keyTransRecipientInfo_chosen 1
	KeyTransRecipientInfo keyTransRecipientInfo;
#	define keyAgreeRecipientInfo_chosen 2
	KeyAgreeRecipientInfo keyAgreeRecipientInfo;
#	define mailListRecipientInfo_chosen 3
	MailListRecipientInfo mailListRecipientInfo;
    } u;
} CmsRecipientInfo;
#define CmsRecipientInfo_PDU 47
#define SIZE_PKCS_Module_PDU_47 sizeof(CmsRecipientInfo)

typedef struct RecipientEncryptedKey {
    RecipientIdentifier rid;
    EncryptedKey encryptedKey;
} RecipientEncryptedKey;


extern ASN1module_t PKCS_Module;
extern void ASN1CALL PKCS_Module_Startup(void);
extern void ASN1CALL PKCS_Module_Cleanup(void);

/* Prototypes of element functions for SEQUENCE OF and SET OF constructs */

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* _PKCS_Module_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\wincrmsg\pkcs.c ===
/* Copyright (C) Microsoft Corporation, 1996 - 1999 All rights reserved. */
/* ASN.1 definitions for GlobalDirectives */

#pragma warning(push,3)

#include <windows.h>
#include "pkcs.h"


#pragma warning (pop)

// unreferenced inline function has been removed
#pragma warning (disable: 4514)

// unreferenced formal parameter
#pragma warning (disable: 4100)

// assignment within conditional expression
#pragma warning (disable: 4706)

ASN1module_t PKCS_Module = NULL;

static int ASN1CALL ASN1Enc_ObjectID(ASN1encoding_t enc, ASN1uint32_t tag, ObjectID *val);
static int ASN1CALL ASN1Enc_ObjectIdentifierType(ASN1encoding_t enc, ASN1uint32_t tag, ObjectIdentifierType *val);
static int ASN1CALL ASN1Enc_OctetStringType(ASN1encoding_t enc, ASN1uint32_t tag, OctetStringType *val);
static int ASN1CALL ASN1Enc_IntegerType(ASN1encoding_t enc, ASN1uint32_t tag, IntegerType *val);
static int ASN1CALL ASN1Enc_HugeIntegerType(ASN1encoding_t enc, ASN1uint32_t tag, HugeIntegerType *val);
static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_AlgorithmIdentifierNC2(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifierNC2 *val);
static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifier *val);
static int ASN1CALL ASN1Enc_AlgorithmIdentifiers(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifiers *val);
static int ASN1CALL ASN1Enc_AttributeSetValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValue *val);
static int ASN1CALL ASN1Enc_AttributeSetValueNC(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValueNC *val);
static int ASN1CALL ASN1Enc_SetOfAny(ASN1encoding_t enc, ASN1uint32_t tag, SetOfAny *val);
static int ASN1CALL ASN1Enc_Attribute(ASN1encoding_t enc, ASN1uint32_t tag, Attribute *val);
static int ASN1CALL ASN1Enc_AttributeNC2(ASN1encoding_t enc, ASN1uint32_t tag, AttributeNC2 *val);
static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Enc_AttributesNC(ASN1encoding_t enc, ASN1uint32_t tag, AttributesNC *val);
static int ASN1CALL ASN1Enc_AttributesNC2(ASN1encoding_t enc, ASN1uint32_t tag, AttributesNC2 *val);
static int ASN1CALL ASN1Enc_Crls(ASN1encoding_t enc, ASN1uint32_t tag, Crls *val);
static int ASN1CALL ASN1Enc_CrlsNC(ASN1encoding_t enc, ASN1uint32_t tag, CrlsNC *val);
static int ASN1CALL ASN1Enc_ContentEncryptionAlgId(ASN1encoding_t enc, ASN1uint32_t tag, ContentEncryptionAlgId *val);
static int ASN1CALL ASN1Enc_DigestEncryptionAlgId(ASN1encoding_t enc, ASN1uint32_t tag, DigestEncryptionAlgId *val);
static int ASN1CALL ASN1Enc_DigestEncryptionAlgIdNC(ASN1encoding_t enc, ASN1uint32_t tag, DigestEncryptionAlgIdNC *val);
static int ASN1CALL ASN1Enc_Certificates(ASN1encoding_t enc, ASN1uint32_t tag, Certificates *val);
static int ASN1CALL ASN1Enc_CertificatesNC(ASN1encoding_t enc, ASN1uint32_t tag, CertificatesNC *val);
static int ASN1CALL ASN1Enc_IssuerAndSerialNumber(ASN1encoding_t enc, ASN1uint32_t tag, IssuerAndSerialNumber *val);
static int ASN1CALL ASN1Enc_KeyEncryptionAlgId(ASN1encoding_t enc, ASN1uint32_t tag, KeyEncryptionAlgId *val);
static int ASN1CALL ASN1Enc_ContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfo *val);
static int ASN1CALL ASN1Enc_ContentInfoNC(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfoNC *val);
static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifiers(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifiers *val);
static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifiersNC(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifiersNC *val);
static int ASN1CALL ASN1Enc_SignerInfos(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfos *val);
static int ASN1CALL ASN1Enc_DigestAlgorithmBlobs(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmBlobs *val);
static int ASN1CALL ASN1Enc_SignerInfosNC(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfosNC *val);
static int ASN1CALL ASN1Enc_SignerInfoWithAABlobs(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfoWithAABlobs *val);
static int ASN1CALL ASN1Enc_SignerInfoWithAABlob(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfoWithAABlob *val);
static int ASN1CALL ASN1Enc_SignerInfoWithAttrBlobs(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfoWithAttrBlobs *val);
static int ASN1CALL ASN1Enc_SignerInfoWithBlobs(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfoWithBlobs *val);
static int ASN1CALL ASN1Enc_RecipientInfos(ASN1encoding_t enc, ASN1uint32_t tag, RecipientInfos *val);
static int ASN1CALL ASN1Enc_EncryptedContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedContentInfo *val);
static int ASN1CALL ASN1Enc_RecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, RecipientInfo *val);
static int ASN1CALL ASN1Enc_SignedAndEnvelopedData(ASN1encoding_t enc, ASN1uint32_t tag, SignedAndEnvelopedData *val);
static int ASN1CALL ASN1Enc_DigestedData(ASN1encoding_t enc, ASN1uint32_t tag, DigestedData *val);
static int ASN1CALL ASN1Enc_EncryptedData(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedData *val);
static int ASN1CALL ASN1Enc_CertIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, CertIdentifier *val);
static int ASN1CALL ASN1Enc_OriginatorInfo(ASN1encoding_t enc, ASN1uint32_t tag, OriginatorInfo *val);
static int ASN1CALL ASN1Enc_OriginatorInfoNC(ASN1encoding_t enc, ASN1uint32_t tag, OriginatorInfoNC *val);
static int ASN1CALL ASN1Enc_CmsRecipientInfos(ASN1encoding_t enc, ASN1uint32_t tag, CmsRecipientInfos *val);
static int ASN1CALL ASN1Enc_KeyTransRecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, KeyTransRecipientInfo *val);
static int ASN1CALL ASN1Enc_OriginatorPublicKey(ASN1encoding_t enc, ASN1uint32_t tag, OriginatorPublicKey *val);
static int ASN1CALL ASN1Enc_RecipientEncryptedKeys(ASN1encoding_t enc, ASN1uint32_t tag, RecipientEncryptedKeys *val);
static int ASN1CALL ASN1Enc_OtherKeyAttribute(ASN1encoding_t enc, ASN1uint32_t tag, OtherKeyAttribute *val);
static int ASN1CALL ASN1Enc_MailListKeyIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, MailListKeyIdentifier *val);
static int ASN1CALL ASN1Enc_DigestInfo(ASN1encoding_t enc, ASN1uint32_t tag, DigestInfo *val);
static int ASN1CALL ASN1Enc_SignedData(ASN1encoding_t enc, ASN1uint32_t tag, SignedData *val);
static int ASN1CALL ASN1Enc_SignerInfo(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfo *val);
static int ASN1CALL ASN1Enc_SignedDataWithBlobs(ASN1encoding_t enc, ASN1uint32_t tag, SignedDataWithBlobs *val);
static int ASN1CALL ASN1Enc_EnvelopedData(ASN1encoding_t enc, ASN1uint32_t tag, EnvelopedData *val);
static int ASN1CALL ASN1Enc_CmsEnvelopedData(ASN1encoding_t enc, ASN1uint32_t tag, CmsEnvelopedData *val);
static int ASN1CALL ASN1Enc_OriginatorIdentifierOrKey(ASN1encoding_t enc, ASN1uint32_t tag, OriginatorIdentifierOrKey *val);
static int ASN1CALL ASN1Enc_RecipientKeyIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, RecipientKeyIdentifier *val);
static int ASN1CALL ASN1Enc_MailListRecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, MailListRecipientInfo *val);
static int ASN1CALL ASN1Enc_KeyAgreeRecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, KeyAgreeRecipientInfo *val);
static int ASN1CALL ASN1Enc_RecipientIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, RecipientIdentifier *val);
static int ASN1CALL ASN1Enc_CmsRecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, CmsRecipientInfo *val);
static int ASN1CALL ASN1Enc_RecipientEncryptedKey(ASN1encoding_t enc, ASN1uint32_t tag, RecipientEncryptedKey *val);
static int ASN1CALL ASN1Dec_ObjectID(ASN1decoding_t dec, ASN1uint32_t tag, ObjectID *val);
static int ASN1CALL ASN1Dec_ObjectIdentifierType(ASN1decoding_t dec, ASN1uint32_t tag, ObjectIdentifierType *val);
static int ASN1CALL ASN1Dec_OctetStringType(ASN1decoding_t dec, ASN1uint32_t tag, OctetStringType *val);
static int ASN1CALL ASN1Dec_IntegerType(ASN1decoding_t dec, ASN1uint32_t tag, IntegerType *val);
static int ASN1CALL ASN1Dec_HugeIntegerType(ASN1decoding_t dec, ASN1uint32_t tag, HugeIntegerType *val);
static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_AlgorithmIdentifierNC2(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifierNC2 *val);
static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifier *val);
static int ASN1CALL ASN1Dec_AlgorithmIdentifiers(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifiers *val);
static int ASN1CALL ASN1Dec_AttributeSetValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValue *val);
static int ASN1CALL ASN1Dec_AttributeSetValueNC(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValueNC *val);
static int ASN1CALL ASN1Dec_SetOfAny(ASN1decoding_t dec, ASN1uint32_t tag, SetOfAny *val);
static int ASN1CALL ASN1Dec_Attribute(ASN1decoding_t dec, ASN1uint32_t tag, Attribute *val);
static int ASN1CALL ASN1Dec_AttributeNC2(ASN1decoding_t dec, ASN1uint32_t tag, AttributeNC2 *val);
static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val);
static int ASN1CALL ASN1Dec_AttributesNC(ASN1decoding_t dec, ASN1uint32_t tag, AttributesNC *val);
static int ASN1CALL ASN1Dec_AttributesNC2(ASN1decoding_t dec, ASN1uint32_t tag, AttributesNC2 *val);
static int ASN1CALL ASN1Dec_Crls(ASN1decoding_t dec, ASN1uint32_t tag, Crls *val);
static int ASN1CALL ASN1Dec_CrlsNC(ASN1decoding_t dec, ASN1uint32_t tag, CrlsNC *val);
static int ASN1CALL ASN1Dec_ContentEncryptionAlgId(ASN1decoding_t dec, ASN1uint32_t tag, ContentEncryptionAlgId *val);
static int ASN1CALL ASN1Dec_DigestEncryptionAlgId(ASN1decoding_t dec, ASN1uint32_t tag, DigestEncryptionAlgId *val);
static int ASN1CALL ASN1Dec_DigestEncryptionAlgIdNC(ASN1decoding_t dec, ASN1uint32_t tag, DigestEncryptionAlgIdNC *val);
static int ASN1CALL ASN1Dec_Certificates(ASN1decoding_t dec, ASN1uint32_t tag, Certificates *val);
static int ASN1CALL ASN1Dec_CertificatesNC(ASN1decoding_t dec, ASN1uint32_t tag, CertificatesNC *val);
static int ASN1CALL ASN1Dec_IssuerAndSerialNumber(ASN1decoding_t dec, ASN1uint32_t tag, IssuerAndSerialNumber *val);
static int ASN1CALL ASN1Dec_KeyEncryptionAlgId(ASN1decoding_t dec, ASN1uint32_t tag, KeyEncryptionAlgId *val);
static int ASN1CALL ASN1Dec_ContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfo *val);
static int ASN1CALL ASN1Dec_ContentInfoNC(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfoNC *val);
static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifiers(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifiers *val);
static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifiersNC(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifiersNC *val);
static int ASN1CALL ASN1Dec_SignerInfos(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfos *val);
static int ASN1CALL ASN1Dec_DigestAlgorithmBlobs(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmBlobs *val);
static int ASN1CALL ASN1Dec_SignerInfosNC(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfosNC *val);
static int ASN1CALL ASN1Dec_SignerInfoWithAABlobs(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfoWithAABlobs *val);
static int ASN1CALL ASN1Dec_SignerInfoWithAABlob(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfoWithAABlob *val);
static int ASN1CALL ASN1Dec_SignerInfoWithAttrBlobs(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfoWithAttrBlobs *val);
static int ASN1CALL ASN1Dec_SignerInfoWithBlobs(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfoWithBlobs *val);
static int ASN1CALL ASN1Dec_RecipientInfos(ASN1decoding_t dec, ASN1uint32_t tag, RecipientInfos *val);
static int ASN1CALL ASN1Dec_EncryptedContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedContentInfo *val);
static int ASN1CALL ASN1Dec_RecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, RecipientInfo *val);
static int ASN1CALL ASN1Dec_SignedAndEnvelopedData(ASN1decoding_t dec, ASN1uint32_t tag, SignedAndEnvelopedData *val);
static int ASN1CALL ASN1Dec_DigestedData(ASN1decoding_t dec, ASN1uint32_t tag, DigestedData *val);
static int ASN1CALL ASN1Dec_EncryptedData(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedData *val);
static int ASN1CALL ASN1Dec_CertIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, CertIdentifier *val);
static int ASN1CALL ASN1Dec_OriginatorInfo(ASN1decoding_t dec, ASN1uint32_t tag, OriginatorInfo *val);
static int ASN1CALL ASN1Dec_OriginatorInfoNC(ASN1decoding_t dec, ASN1uint32_t tag, OriginatorInfoNC *val);
static int ASN1CALL ASN1Dec_CmsRecipientInfos(ASN1decoding_t dec, ASN1uint32_t tag, CmsRecipientInfos *val);
static int ASN1CALL ASN1Dec_KeyTransRecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, KeyTransRecipientInfo *val);
static int ASN1CALL ASN1Dec_OriginatorPublicKey(ASN1decoding_t dec, ASN1uint32_t tag, OriginatorPublicKey *val);
static int ASN1CALL ASN1Dec_RecipientEncryptedKeys(ASN1decoding_t dec, ASN1uint32_t tag, RecipientEncryptedKeys *val);
static int ASN1CALL ASN1Dec_OtherKeyAttribute(ASN1decoding_t dec, ASN1uint32_t tag, OtherKeyAttribute *val);
static int ASN1CALL ASN1Dec_MailListKeyIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, MailListKeyIdentifier *val);
static int ASN1CALL ASN1Dec_DigestInfo(ASN1decoding_t dec, ASN1uint32_t tag, DigestInfo *val);
static int ASN1CALL ASN1Dec_SignedData(ASN1decoding_t dec, ASN1uint32_t tag, SignedData *val);
static int ASN1CALL ASN1Dec_SignerInfo(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfo *val);
static int ASN1CALL ASN1Dec_SignedDataWithBlobs(ASN1decoding_t dec, ASN1uint32_t tag, SignedDataWithBlobs *val);
static int ASN1CALL ASN1Dec_EnvelopedData(ASN1decoding_t dec, ASN1uint32_t tag, EnvelopedData *val);
static int ASN1CALL ASN1Dec_CmsEnvelopedData(ASN1decoding_t dec, ASN1uint32_t tag, CmsEnvelopedData *val);
static int ASN1CALL ASN1Dec_OriginatorIdentifierOrKey(ASN1decoding_t dec, ASN1uint32_t tag, OriginatorIdentifierOrKey *val);
static int ASN1CALL ASN1Dec_RecipientKeyIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, RecipientKeyIdentifier *val);
static int ASN1CALL ASN1Dec_MailListRecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, MailListRecipientInfo *val);
static int ASN1CALL ASN1Dec_KeyAgreeRecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, KeyAgreeRecipientInfo *val);
static int ASN1CALL ASN1Dec_RecipientIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, RecipientIdentifier *val);
static int ASN1CALL ASN1Dec_CmsRecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, CmsRecipientInfo *val);
static int ASN1CALL ASN1Dec_RecipientEncryptedKey(ASN1decoding_t dec, ASN1uint32_t tag, RecipientEncryptedKey *val);
static void ASN1CALL ASN1Free_ObjectID(ObjectID *val);
static void ASN1CALL ASN1Free_ObjectIdentifierType(ObjectIdentifierType *val);
static void ASN1CALL ASN1Free_OctetStringType(OctetStringType *val);
static void ASN1CALL ASN1Free_HugeIntegerType(HugeIntegerType *val);
static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_AlgorithmIdentifierNC2(AlgorithmIdentifierNC2 *val);
static void ASN1CALL ASN1Free_DigestAlgorithmIdentifier(DigestAlgorithmIdentifier *val);
static void ASN1CALL ASN1Free_AlgorithmIdentifiers(AlgorithmIdentifiers *val);
static void ASN1CALL ASN1Free_AttributeSetValue(AttributeSetValue *val);
static void ASN1CALL ASN1Free_AttributeSetValueNC(AttributeSetValueNC *val);
static void ASN1CALL ASN1Free_SetOfAny(SetOfAny *val);
static void ASN1CALL ASN1Free_Attribute(Attribute *val);
static void ASN1CALL ASN1Free_AttributeNC2(AttributeNC2 *val);
static void ASN1CALL ASN1Free_Attributes(Attributes *val);
static void ASN1CALL ASN1Free_AttributesNC(AttributesNC *val);
static void ASN1CALL ASN1Free_AttributesNC2(AttributesNC2 *val);
static void ASN1CALL ASN1Free_Crls(Crls *val);
static void ASN1CALL ASN1Free_CrlsNC(CrlsNC *val);
static void ASN1CALL ASN1Free_ContentEncryptionAlgId(ContentEncryptionAlgId *val);
static void ASN1CALL ASN1Free_DigestEncryptionAlgId(DigestEncryptionAlgId *val);
static void ASN1CALL ASN1Free_DigestEncryptionAlgIdNC(DigestEncryptionAlgIdNC *val);
static void ASN1CALL ASN1Free_Certificates(Certificates *val);
static void ASN1CALL ASN1Free_CertificatesNC(CertificatesNC *val);
static void ASN1CALL ASN1Free_IssuerAndSerialNumber(IssuerAndSerialNumber *val);
static void ASN1CALL ASN1Free_KeyEncryptionAlgId(KeyEncryptionAlgId *val);
static void ASN1CALL ASN1Free_ContentInfo(ContentInfo *val);
static void ASN1CALL ASN1Free_ContentInfoNC(ContentInfoNC *val);
static void ASN1CALL ASN1Free_DigestAlgorithmIdentifiers(DigestAlgorithmIdentifiers *val);
static void ASN1CALL ASN1Free_DigestAlgorithmIdentifiersNC(DigestAlgorithmIdentifiersNC *val);
static void ASN1CALL ASN1Free_SignerInfos(SignerInfos *val);
static void ASN1CALL ASN1Free_DigestAlgorithmBlobs(DigestAlgorithmBlobs *val);
static void ASN1CALL ASN1Free_SignerInfosNC(SignerInfosNC *val);
static void ASN1CALL ASN1Free_SignerInfoWithAABlobs(SignerInfoWithAABlobs *val);
static void ASN1CALL ASN1Free_SignerInfoWithAABlob(SignerInfoWithAABlob *val);
static void ASN1CALL ASN1Free_SignerInfoWithAttrBlobs(SignerInfoWithAttrBlobs *val);
static void ASN1CALL ASN1Free_SignerInfoWithBlobs(SignerInfoWithBlobs *val);
static void ASN1CALL ASN1Free_RecipientInfos(RecipientInfos *val);
static void ASN1CALL ASN1Free_EncryptedContentInfo(EncryptedContentInfo *val);
static void ASN1CALL ASN1Free_RecipientInfo(RecipientInfo *val);
static void ASN1CALL ASN1Free_SignedAndEnvelopedData(SignedAndEnvelopedData *val);
static void ASN1CALL ASN1Free_DigestedData(DigestedData *val);
static void ASN1CALL ASN1Free_EncryptedData(EncryptedData *val);
static void ASN1CALL ASN1Free_CertIdentifier(CertIdentifier *val);
static void ASN1CALL ASN1Free_OriginatorInfo(OriginatorInfo *val);
static void ASN1CALL ASN1Free_OriginatorInfoNC(OriginatorInfoNC *val);
static void ASN1CALL ASN1Free_CmsRecipientInfos(CmsRecipientInfos *val);
static void ASN1CALL ASN1Free_KeyTransRecipientInfo(KeyTransRecipientInfo *val);
static void ASN1CALL ASN1Free_OriginatorPublicKey(OriginatorPublicKey *val);
static void ASN1CALL ASN1Free_RecipientEncryptedKeys(RecipientEncryptedKeys *val);
static void ASN1CALL ASN1Free_OtherKeyAttribute(OtherKeyAttribute *val);
static void ASN1CALL ASN1Free_MailListKeyIdentifier(MailListKeyIdentifier *val);
static void ASN1CALL ASN1Free_DigestInfo(DigestInfo *val);
static void ASN1CALL ASN1Free_SignedData(SignedData *val);
static void ASN1CALL ASN1Free_SignerInfo(SignerInfo *val);
static void ASN1CALL ASN1Free_SignedDataWithBlobs(SignedDataWithBlobs *val);
static void ASN1CALL ASN1Free_EnvelopedData(EnvelopedData *val);
static void ASN1CALL ASN1Free_CmsEnvelopedData(CmsEnvelopedData *val);
static void ASN1CALL ASN1Free_OriginatorIdentifierOrKey(OriginatorIdentifierOrKey *val);
static void ASN1CALL ASN1Free_RecipientKeyIdentifier(RecipientKeyIdentifier *val);
static void ASN1CALL ASN1Free_MailListRecipientInfo(MailListRecipientInfo *val);
static void ASN1CALL ASN1Free_KeyAgreeRecipientInfo(KeyAgreeRecipientInfo *val);
static void ASN1CALL ASN1Free_RecipientIdentifier(RecipientIdentifier *val);
static void ASN1CALL ASN1Free_CmsRecipientInfo(CmsRecipientInfo *val);
static void ASN1CALL ASN1Free_RecipientEncryptedKey(RecipientEncryptedKey *val);

typedef ASN1BerEncFun_t ASN1EncFun_t;
static const ASN1EncFun_t encfntab[48] = {
    (ASN1EncFun_t) ASN1Enc_ObjectID,
    (ASN1EncFun_t) ASN1Enc_ObjectIdentifierType,
    (ASN1EncFun_t) ASN1Enc_OctetStringType,
    (ASN1EncFun_t) ASN1Enc_IntegerType,
    (ASN1EncFun_t) ASN1Enc_HugeIntegerType,
    (ASN1EncFun_t) ASN1Enc_AlgorithmIdentifier,
    (ASN1EncFun_t) ASN1Enc_AlgorithmIdentifierNC2,
    (ASN1EncFun_t) ASN1Enc_AlgorithmIdentifiers,
    (ASN1EncFun_t) ASN1Enc_AttributeSetValue,
    (ASN1EncFun_t) ASN1Enc_AttributeSetValueNC,
    (ASN1EncFun_t) ASN1Enc_SetOfAny,
    (ASN1EncFun_t) ASN1Enc_AttributeNC2,
    (ASN1EncFun_t) ASN1Enc_Attributes,
    (ASN1EncFun_t) ASN1Enc_AttributesNC,
    (ASN1EncFun_t) ASN1Enc_AttributesNC2,
    (ASN1EncFun_t) ASN1Enc_CrlsNC,
    (ASN1EncFun_t) ASN1Enc_CertificatesNC,
    (ASN1EncFun_t) ASN1Enc_IssuerAndSerialNumber,
    (ASN1EncFun_t) ASN1Enc_ContentInfo,
    (ASN1EncFun_t) ASN1Enc_ContentInfoNC,
    (ASN1EncFun_t) ASN1Enc_DigestAlgorithmIdentifiersNC,
    (ASN1EncFun_t) ASN1Enc_SignerInfos,
    (ASN1EncFun_t) ASN1Enc_DigestAlgorithmBlobs,
    (ASN1EncFun_t) ASN1Enc_SignerInfosNC,
    (ASN1EncFun_t) ASN1Enc_SignerInfoWithAABlobs,
    (ASN1EncFun_t) ASN1Enc_SignerInfoWithAABlob,
    (ASN1EncFun_t) ASN1Enc_SignerInfoWithAttrBlobs,
    (ASN1EncFun_t) ASN1Enc_SignerInfoWithBlobs,
    (ASN1EncFun_t) ASN1Enc_RecipientInfos,
    (ASN1EncFun_t) ASN1Enc_EncryptedContentInfo,
    (ASN1EncFun_t) ASN1Enc_RecipientInfo,
    (ASN1EncFun_t) ASN1Enc_SignedAndEnvelopedData,
    (ASN1EncFun_t) ASN1Enc_DigestedData,
    (ASN1EncFun_t) ASN1Enc_EncryptedData,
    (ASN1EncFun_t) ASN1Enc_CertIdentifier,
    (ASN1EncFun_t) ASN1Enc_OriginatorInfo,
    (ASN1EncFun_t) ASN1Enc_OriginatorInfoNC,
    (ASN1EncFun_t) ASN1Enc_CmsRecipientInfos,
    (ASN1EncFun_t) ASN1Enc_KeyTransRecipientInfo,
    (ASN1EncFun_t) ASN1Enc_DigestInfo,
    (ASN1EncFun_t) ASN1Enc_SignedData,
    (ASN1EncFun_t) ASN1Enc_SignerInfo,
    (ASN1EncFun_t) ASN1Enc_SignedDataWithBlobs,
    (ASN1EncFun_t) ASN1Enc_EnvelopedData,
    (ASN1EncFun_t) ASN1Enc_CmsEnvelopedData,
    (ASN1EncFun_t) ASN1Enc_MailListRecipientInfo,
    (ASN1EncFun_t) ASN1Enc_KeyAgreeRecipientInfo,
    (ASN1EncFun_t) ASN1Enc_CmsRecipientInfo,
};
typedef ASN1BerDecFun_t ASN1DecFun_t;
static const ASN1DecFun_t decfntab[48] = {
    (ASN1DecFun_t) ASN1Dec_ObjectID,
    (ASN1DecFun_t) ASN1Dec_ObjectIdentifierType,
    (ASN1DecFun_t) ASN1Dec_OctetStringType,
    (ASN1DecFun_t) ASN1Dec_IntegerType,
    (ASN1DecFun_t) ASN1Dec_HugeIntegerType,
    (ASN1DecFun_t) ASN1Dec_AlgorithmIdentifier,
    (ASN1DecFun_t) ASN1Dec_AlgorithmIdentifierNC2,
    (ASN1DecFun_t) ASN1Dec_AlgorithmIdentifiers,
    (ASN1DecFun_t) ASN1Dec_AttributeSetValue,
    (ASN1DecFun_t) ASN1Dec_AttributeSetValueNC,
    (ASN1DecFun_t) ASN1Dec_SetOfAny,
    (ASN1DecFun_t) ASN1Dec_AttributeNC2,
    (ASN1DecFun_t) ASN1Dec_Attributes,
    (ASN1DecFun_t) ASN1Dec_AttributesNC,
    (ASN1DecFun_t) ASN1Dec_AttributesNC2,
    (ASN1DecFun_t) ASN1Dec_CrlsNC,
    (ASN1DecFun_t) ASN1Dec_CertificatesNC,
    (ASN1DecFun_t) ASN1Dec_IssuerAndSerialNumber,
    (ASN1DecFun_t) ASN1Dec_ContentInfo,
    (ASN1DecFun_t) ASN1Dec_ContentInfoNC,
    (ASN1DecFun_t) ASN1Dec_DigestAlgorithmIdentifiersNC,
    (ASN1DecFun_t) ASN1Dec_SignerInfos,
    (ASN1DecFun_t) ASN1Dec_DigestAlgorithmBlobs,
    (ASN1DecFun_t) ASN1Dec_SignerInfosNC,
    (ASN1DecFun_t) ASN1Dec_SignerInfoWithAABlobs,
    (ASN1DecFun_t) ASN1Dec_SignerInfoWithAABlob,
    (ASN1DecFun_t) ASN1Dec_SignerInfoWithAttrBlobs,
    (ASN1DecFun_t) ASN1Dec_SignerInfoWithBlobs,
    (ASN1DecFun_t) ASN1Dec_RecipientInfos,
    (ASN1DecFun_t) ASN1Dec_EncryptedContentInfo,
    (ASN1DecFun_t) ASN1Dec_RecipientInfo,
    (ASN1DecFun_t) ASN1Dec_SignedAndEnvelopedData,
    (ASN1DecFun_t) ASN1Dec_DigestedData,
    (ASN1DecFun_t) ASN1Dec_EncryptedData,
    (ASN1DecFun_t) ASN1Dec_CertIdentifier,
    (ASN1DecFun_t) ASN1Dec_OriginatorInfo,
    (ASN1DecFun_t) ASN1Dec_OriginatorInfoNC,
    (ASN1DecFun_t) ASN1Dec_CmsRecipientInfos,
    (ASN1DecFun_t) ASN1Dec_KeyTransRecipientInfo,
    (ASN1DecFun_t) ASN1Dec_DigestInfo,
    (ASN1DecFun_t) ASN1Dec_SignedData,
    (ASN1DecFun_t) ASN1Dec_SignerInfo,
    (ASN1DecFun_t) ASN1Dec_SignedDataWithBlobs,
    (ASN1DecFun_t) ASN1Dec_EnvelopedData,
    (ASN1DecFun_t) ASN1Dec_CmsEnvelopedData,
    (ASN1DecFun_t) ASN1Dec_MailListRecipientInfo,
    (ASN1DecFun_t) ASN1Dec_KeyAgreeRecipientInfo,
    (ASN1DecFun_t) ASN1Dec_CmsRecipientInfo,
};
static const ASN1FreeFun_t freefntab[48] = {
    (ASN1FreeFun_t) ASN1Free_ObjectID,
    (ASN1FreeFun_t) ASN1Free_ObjectIdentifierType,
    (ASN1FreeFun_t) ASN1Free_OctetStringType,
    (ASN1FreeFun_t) NULL,
    (ASN1FreeFun_t) ASN1Free_HugeIntegerType,
    (ASN1FreeFun_t) ASN1Free_AlgorithmIdentifier,
    (ASN1FreeFun_t) ASN1Free_AlgorithmIdentifierNC2,
    (ASN1FreeFun_t) ASN1Free_AlgorithmIdentifiers,
    (ASN1FreeFun_t) ASN1Free_AttributeSetValue,
    (ASN1FreeFun_t) ASN1Free_AttributeSetValueNC,
    (ASN1FreeFun_t) ASN1Free_SetOfAny,
    (ASN1FreeFun_t) ASN1Free_AttributeNC2,
    (ASN1FreeFun_t) ASN1Free_Attributes,
    (ASN1FreeFun_t) ASN1Free_AttributesNC,
    (ASN1FreeFun_t) ASN1Free_AttributesNC2,
    (ASN1FreeFun_t) ASN1Free_CrlsNC,
    (ASN1FreeFun_t) ASN1Free_CertificatesNC,
    (ASN1FreeFun_t) ASN1Free_IssuerAndSerialNumber,
    (ASN1FreeFun_t) ASN1Free_ContentInfo,
    (ASN1FreeFun_t) ASN1Free_ContentInfoNC,
    (ASN1FreeFun_t) ASN1Free_DigestAlgorithmIdentifiersNC,
    (ASN1FreeFun_t) ASN1Free_SignerInfos,
    (ASN1FreeFun_t) ASN1Free_DigestAlgorithmBlobs,
    (ASN1FreeFun_t) ASN1Free_SignerInfosNC,
    (ASN1FreeFun_t) ASN1Free_SignerInfoWithAABlobs,
    (ASN1FreeFun_t) ASN1Free_SignerInfoWithAABlob,
    (ASN1FreeFun_t) ASN1Free_SignerInfoWithAttrBlobs,
    (ASN1FreeFun_t) ASN1Free_SignerInfoWithBlobs,
    (ASN1FreeFun_t) ASN1Free_RecipientInfos,
    (ASN1FreeFun_t) ASN1Free_EncryptedContentInfo,
    (ASN1FreeFun_t) ASN1Free_RecipientInfo,
    (ASN1FreeFun_t) ASN1Free_SignedAndEnvelopedData,
    (ASN1FreeFun_t) ASN1Free_DigestedData,
    (ASN1FreeFun_t) ASN1Free_EncryptedData,
    (ASN1FreeFun_t) ASN1Free_CertIdentifier,
    (ASN1FreeFun_t) ASN1Free_OriginatorInfo,
    (ASN1FreeFun_t) ASN1Free_OriginatorInfoNC,
    (ASN1FreeFun_t) ASN1Free_CmsRecipientInfos,
    (ASN1FreeFun_t) ASN1Free_KeyTransRecipientInfo,
    (ASN1FreeFun_t) ASN1Free_DigestInfo,
    (ASN1FreeFun_t) ASN1Free_SignedData,
    (ASN1FreeFun_t) ASN1Free_SignerInfo,
    (ASN1FreeFun_t) ASN1Free_SignedDataWithBlobs,
    (ASN1FreeFun_t) ASN1Free_EnvelopedData,
    (ASN1FreeFun_t) ASN1Free_CmsEnvelopedData,
    (ASN1FreeFun_t) ASN1Free_MailListRecipientInfo,
    (ASN1FreeFun_t) ASN1Free_KeyAgreeRecipientInfo,
    (ASN1FreeFun_t) ASN1Free_CmsRecipientInfo,
};
static const ULONG sizetab[48] = {
    SIZE_PKCS_Module_PDU_0,
    SIZE_PKCS_Module_PDU_1,
    SIZE_PKCS_Module_PDU_2,
    SIZE_PKCS_Module_PDU_3,
    SIZE_PKCS_Module_PDU_4,
    SIZE_PKCS_Module_PDU_5,
    SIZE_PKCS_Module_PDU_6,
    SIZE_PKCS_Module_PDU_7,
    SIZE_PKCS_Module_PDU_8,
    SIZE_PKCS_Module_PDU_9,
    SIZE_PKCS_Module_PDU_10,
    SIZE_PKCS_Module_PDU_11,
    SIZE_PKCS_Module_PDU_12,
    SIZE_PKCS_Module_PDU_13,
    SIZE_PKCS_Module_PDU_14,
    SIZE_PKCS_Module_PDU_15,
    SIZE_PKCS_Module_PDU_16,
    SIZE_PKCS_Module_PDU_17,
    SIZE_PKCS_Module_PDU_18,
    SIZE_PKCS_Module_PDU_19,
    SIZE_PKCS_Module_PDU_20,
    SIZE_PKCS_Module_PDU_21,
    SIZE_PKCS_Module_PDU_22,
    SIZE_PKCS_Module_PDU_23,
    SIZE_PKCS_Module_PDU_24,
    SIZE_PKCS_Module_PDU_25,
    SIZE_PKCS_Module_PDU_26,
    SIZE_PKCS_Module_PDU_27,
    SIZE_PKCS_Module_PDU_28,
    SIZE_PKCS_Module_PDU_29,
    SIZE_PKCS_Module_PDU_30,
    SIZE_PKCS_Module_PDU_31,
    SIZE_PKCS_Module_PDU_32,
    SIZE_PKCS_Module_PDU_33,
    SIZE_PKCS_Module_PDU_34,
    SIZE_PKCS_Module_PDU_35,
    SIZE_PKCS_Module_PDU_36,
    SIZE_PKCS_Module_PDU_37,
    SIZE_PKCS_Module_PDU_38,
    SIZE_PKCS_Module_PDU_39,
    SIZE_PKCS_Module_PDU_40,
    SIZE_PKCS_Module_PDU_41,
    SIZE_PKCS_Module_PDU_42,
    SIZE_PKCS_Module_PDU_43,
    SIZE_PKCS_Module_PDU_44,
    SIZE_PKCS_Module_PDU_45,
    SIZE_PKCS_Module_PDU_46,
    SIZE_PKCS_Module_PDU_47,
};

/* forward declarations of values: */
/* definitions of value components: */
/* definitions of values: */

void ASN1CALL PKCS_Module_Startup(void)
{
    PKCS_Module = ASN1_CreateModule(0x10000, ASN1_BER_RULE_DER, ASN1FLAGS_NOASSERT, 48, (const ASN1GenericFun_t *) encfntab, (const ASN1GenericFun_t *) decfntab, freefntab, sizetab, 0x73636b70);
}

void ASN1CALL PKCS_Module_Cleanup(void)
{
    ASN1_CloseModule(PKCS_Module);
    PKCS_Module = NULL;
}

static int ASN1CALL ASN1Enc_ObjectID(ASN1encoding_t enc, ASN1uint32_t tag, ObjectID *val)
{
    if (!ASN1BEREncObjectIdentifier2(enc, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ObjectID(ASN1decoding_t dec, ASN1uint32_t tag, ObjectID *val)
{
    if (!ASN1BERDecObjectIdentifier2(dec, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ObjectID(ObjectID *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_ObjectIdentifierType(ASN1encoding_t enc, ASN1uint32_t tag, ObjectIdentifierType *val)
{
    if (!ASN1BEREncObjectIdentifier2(enc, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ObjectIdentifierType(ASN1decoding_t dec, ASN1uint32_t tag, ObjectIdentifierType *val)
{
    if (!ASN1BERDecObjectIdentifier2(dec, tag ? tag : 0x6, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ObjectIdentifierType(ObjectIdentifierType *val)
{
    if (val) {
    }
}

static int ASN1CALL ASN1Enc_OctetStringType(ASN1encoding_t enc, ASN1uint32_t tag, OctetStringType *val)
{
    if (!ASN1DEREncOctetString(enc, tag ? tag : 0x4, (val)->length, (val)->value))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OctetStringType(ASN1decoding_t dec, ASN1uint32_t tag, OctetStringType *val)
{
    if (!ASN1BERDecOctetString(dec, tag ? tag : 0x4, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OctetStringType(OctetStringType *val)
{
    if (val) {
	ASN1octetstring_free(val);
    }
}

static int ASN1CALL ASN1Enc_IntegerType(ASN1encoding_t enc, ASN1uint32_t tag, IntegerType *val)
{
    if (!ASN1BEREncS32(enc, tag ? tag : 0x2, *val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IntegerType(ASN1decoding_t dec, ASN1uint32_t tag, IntegerType *val)
{
    if (!ASN1BERDecS32Val(dec, tag ? tag : 0x2, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Enc_HugeIntegerType(ASN1encoding_t enc, ASN1uint32_t tag, HugeIntegerType *val)
{
    if (!ASN1BEREncSX(enc, tag ? tag : 0x2, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_HugeIntegerType(ASN1decoding_t dec, ASN1uint32_t tag, HugeIntegerType *val)
{
    if (!ASN1BERDecSXVal(dec, tag ? tag : 0x2, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_HugeIntegerType(HugeIntegerType *val)
{
    if (val) {
	ASN1intx_free(val);
    }
}

static int ASN1CALL ASN1Enc_AlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifier *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AlgorithmIdentifier(AlgorithmIdentifier *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1open_free(&(val)->parameters);
	}
    }
}

static int ASN1CALL ASN1Enc_AlgorithmIdentifierNC2(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifierNC2 *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->algorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlgorithmIdentifierNC2(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifierNC2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->algorithm))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType2(dd, &(val)->parameters))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AlgorithmIdentifierNC2(AlgorithmIdentifierNC2 *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifier *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifier *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestAlgorithmIdentifier(DigestAlgorithmIdentifier *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_AlgorithmIdentifiers(ASN1encoding_t enc, ASN1uint32_t tag, AlgorithmIdentifiers *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_AlgorithmIdentifier(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AlgorithmIdentifiers(ASN1decoding_t dec, ASN1uint32_t tag, AlgorithmIdentifiers *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (AlgorithmIdentifier *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AlgorithmIdentifiers(AlgorithmIdentifiers *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_AlgorithmIdentifier(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_AlgorithmIdentifier(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AttributeSetValue(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValue *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributeSetValue(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValue *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (AttributeSetValue_Set *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributeSetValue(AttributeSetValue *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1open_free(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1open_free(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AttributeSetValueNC(ASN1encoding_t enc, ASN1uint32_t tag, AttributeSetValueNC *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributeSetValueNC(ASN1decoding_t dec, ASN1uint32_t tag, AttributeSetValueNC *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (AttributeSetValueNC_Set *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributeSetValueNC(AttributeSetValueNC *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SetOfAny(ASN1encoding_t enc, ASN1uint32_t tag, SetOfAny *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SetOfAny(ASN1decoding_t dec, ASN1uint32_t tag, SetOfAny *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (SetOfAny_Set *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SetOfAny(SetOfAny *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1open_free(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1open_free(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_Attribute(ASN1encoding_t enc, ASN1uint32_t tag, Attribute *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->attributeType))
	return 0;
    if (!ASN1Enc_AttributeSetValue(enc, 0, &(val)->attributeValue))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attribute(ASN1decoding_t dec, ASN1uint32_t tag, Attribute *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->attributeType))
	return 0;
    if (!ASN1Dec_AttributeSetValue(dd, 0, &(val)->attributeValue))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attribute(Attribute *val)
{
    if (val) {
	ASN1Free_AttributeSetValue(&(val)->attributeValue);
    }
}

static int ASN1CALL ASN1Enc_AttributeNC2(ASN1encoding_t enc, ASN1uint32_t tag, AttributeNC2 *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->attributeType))
	return 0;
    if (!ASN1Enc_AttributeSetValueNC(enc, 0, &(val)->attributeValue))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributeNC2(ASN1decoding_t dec, ASN1uint32_t tag, AttributeNC2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->attributeType))
	return 0;
    if (!ASN1Dec_AttributeSetValueNC(dd, 0, &(val)->attributeValue))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributeNC2(AttributeNC2 *val)
{
    if (val) {
	ASN1Free_AttributeSetValueNC(&(val)->attributeValue);
    }
}

static int ASN1CALL ASN1Enc_Attributes(ASN1encoding_t enc, ASN1uint32_t tag, Attributes *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_Attribute(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Attributes(ASN1decoding_t dec, ASN1uint32_t tag, Attributes *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (Attribute *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_Attribute(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Attributes(Attributes *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_Attribute(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_Attribute(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AttributesNC(ASN1encoding_t enc, ASN1uint32_t tag, AttributesNC *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributesNC(ASN1decoding_t dec, ASN1uint32_t tag, AttributesNC *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (AttributeNC *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributesNC(AttributesNC *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_AttributesNC2(ASN1encoding_t enc, ASN1uint32_t tag, AttributesNC2 *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_AttributeNC2(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_AttributesNC2(ASN1decoding_t dec, ASN1uint32_t tag, AttributesNC2 *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (AttributeNC2 *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_AttributeNC2(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_AttributesNC2(AttributesNC2 *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_AttributeNC2(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_AttributeNC2(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_Crls(ASN1encoding_t enc, ASN1uint32_t tag, Crls *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Crls(ASN1decoding_t dec, ASN1uint32_t tag, Crls *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (CertificateRevocationList *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Crls(Crls *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1open_free(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1open_free(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CrlsNC(ASN1encoding_t enc, ASN1uint32_t tag, CrlsNC *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CrlsNC(ASN1decoding_t dec, ASN1uint32_t tag, CrlsNC *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (CertificateRevocationListNC *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CrlsNC(CrlsNC *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_ContentEncryptionAlgId(ASN1encoding_t enc, ASN1uint32_t tag, ContentEncryptionAlgId *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentEncryptionAlgId(ASN1decoding_t dec, ASN1uint32_t tag, ContentEncryptionAlgId *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentEncryptionAlgId(ContentEncryptionAlgId *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_DigestEncryptionAlgId(ASN1encoding_t enc, ASN1uint32_t tag, DigestEncryptionAlgId *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestEncryptionAlgId(ASN1decoding_t dec, ASN1uint32_t tag, DigestEncryptionAlgId *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestEncryptionAlgId(DigestEncryptionAlgId *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_DigestEncryptionAlgIdNC(ASN1encoding_t enc, ASN1uint32_t tag, DigestEncryptionAlgIdNC *val)
{
    if (!ASN1Enc_AlgorithmIdentifierNC2(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestEncryptionAlgIdNC(ASN1decoding_t dec, ASN1uint32_t tag, DigestEncryptionAlgIdNC *val)
{
    if (!ASN1Dec_AlgorithmIdentifierNC2(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestEncryptionAlgIdNC(DigestEncryptionAlgIdNC *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifierNC2(val);
    }
}

static int ASN1CALL ASN1Enc_Certificates(ASN1encoding_t enc, ASN1uint32_t tag, Certificates *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_Certificates(ASN1decoding_t dec, ASN1uint32_t tag, Certificates *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (Certificate *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_Certificates(Certificates *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1open_free(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1open_free(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_CertificatesNC(ASN1encoding_t enc, ASN1uint32_t tag, CertificatesNC *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CertificatesNC(ASN1decoding_t dec, ASN1uint32_t tag, CertificatesNC *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (CertificateNC *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CertificatesNC(CertificatesNC *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_IssuerAndSerialNumber(ASN1encoding_t enc, ASN1uint32_t tag, IssuerAndSerialNumber *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->issuer))
	return 0;
    if (!ASN1BEREncSX(enc, 0x2, &(val)->serialNumber))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_IssuerAndSerialNumber(ASN1decoding_t dec, ASN1uint32_t tag, IssuerAndSerialNumber *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecOpenType(dd, &(val)->issuer))
	return 0;
    if (!ASN1BERDecSXVal(dd, 0x2, &(val)->serialNumber))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_IssuerAndSerialNumber(IssuerAndSerialNumber *val)
{
    if (val) {
	ASN1open_free(&(val)->issuer);
	ASN1intx_free(&(val)->serialNumber);
    }
}

static int ASN1CALL ASN1Enc_KeyEncryptionAlgId(ASN1encoding_t enc, ASN1uint32_t tag, KeyEncryptionAlgId *val)
{
    if (!ASN1Enc_AlgorithmIdentifier(enc, tag, val))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeyEncryptionAlgId(ASN1decoding_t dec, ASN1uint32_t tag, KeyEncryptionAlgId *val)
{
    if (!ASN1Dec_AlgorithmIdentifier(dec, tag, val))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KeyEncryptionAlgId(KeyEncryptionAlgId *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(val);
    }
}

static int ASN1CALL ASN1Enc_ContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfo *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->contentType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->content))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->contentType))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	if (t == 0x80000000) {
	    (val)->o[0] |= 0x80;
	    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
		return 0;
	    if (!ASN1BERDecOpenType(dd0, &(val)->content))
		return 0;
	    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
		return 0;
	}
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentInfo(ContentInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1open_free(&(val)->content);
	}
    }
}

static int ASN1CALL ASN1Enc_ContentInfoNC(ASN1encoding_t enc, ASN1uint32_t tag, ContentInfoNC *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->contentType))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	    return 0;
	if (!ASN1BEREncOpenType(enc, &(val)->content))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_ContentInfoNC(ASN1decoding_t dec, ASN1uint32_t tag, ContentInfoNC *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->contentType))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	if (t == 0x80000000) {
	    (val)->o[0] |= 0x80;
	    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
		return 0;
	    if (!ASN1BERDecOpenType2(dd0, &(val)->content))
		return 0;
	    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
		return 0;
	}
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_ContentInfoNC(ContentInfoNC *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	}
    }
}

static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifiers(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifiers *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_DigestAlgorithmIdentifier(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifiers(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifiers *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (DigestAlgorithmIdentifier *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_DigestAlgorithmIdentifier(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestAlgorithmIdentifiers(DigestAlgorithmIdentifiers *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_DigestAlgorithmIdentifier(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_DigestAlgorithmIdentifier(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_DigestAlgorithmIdentifiersNC(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmIdentifiersNC *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestAlgorithmIdentifiersNC(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmIdentifiersNC *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (DigestAlgorithmIdentifierNC *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestAlgorithmIdentifiersNC(DigestAlgorithmIdentifiersNC *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SignerInfos(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfos *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_SignerInfo(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignerInfos(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfos *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (SignerInfo *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_SignerInfo(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignerInfos(SignerInfos *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_SignerInfo(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_SignerInfo(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_DigestAlgorithmBlobs(ASN1encoding_t enc, ASN1uint32_t tag, DigestAlgorithmBlobs *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestAlgorithmBlobs(ASN1decoding_t dec, ASN1uint32_t tag, DigestAlgorithmBlobs *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (DigestAlgorithmBlob *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestAlgorithmBlobs(DigestAlgorithmBlobs *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SignerInfosNC(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfosNC *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1BEREncOpenType(enc2, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignerInfosNC(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfosNC *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (SignerInfosNC_Set *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1BERDecOpenType2(dd, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignerInfosNC(SignerInfosNC *val)
{
    ASN1uint32_t i;
    if (val) {
	for (i = 1; i < (val)->count; i++) {
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SignerInfoWithAABlobs(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfoWithAABlobs *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_SignerInfoWithAABlob(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignerInfoWithAABlobs(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfoWithAABlobs *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (SignerInfoWithAABlob *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_SignerInfoWithAABlob(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignerInfoWithAABlobs(SignerInfoWithAABlobs *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_SignerInfoWithAABlob(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_SignerInfoWithAABlob(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_SignerInfoWithAABlob(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfoWithAABlob *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->version))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->sid))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->authenticatedAttributes))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->digestEncryptionAlgorithm))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->encryptedDigest))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_AttributesNC(enc, 0x80000001, &(val)->dummyUAAs))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignerInfoWithAABlob(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfoWithAABlob *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOpenType2(dd, &(val)->version))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->sid))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->authenticatedAttributes))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->digestEncryptionAlgorithm))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->encryptedDigest))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_AttributesNC(dd, 0x80000001, &(val)->dummyUAAs))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignerInfoWithAABlob(SignerInfoWithAABlob *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_AttributesNC(&(val)->dummyUAAs);
	}
    }
}

static int ASN1CALL ASN1Enc_SignerInfoWithAttrBlobs(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfoWithAttrBlobs *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->version))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->sid))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->digestAlgorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_AttributesNC(enc, 0x80000000, &(val)->authAttributes))
	    return 0;
    }
    if (!ASN1Enc_DigestEncryptionAlgIdNC(enc, 0, &(val)->digestEncryptionAlgorithm))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->encryptedDigest))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_AttributesNC(enc, 0x80000001, &(val)->unauthAttributes))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignerInfoWithAttrBlobs(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfoWithAttrBlobs *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOpenType2(dd, &(val)->version))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->sid))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->digestAlgorithm))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_AttributesNC(dd, 0x80000000, &(val)->authAttributes))
	    return 0;
    }
    if (!ASN1Dec_DigestEncryptionAlgIdNC(dd, 0, &(val)->digestEncryptionAlgorithm))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->encryptedDigest))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_AttributesNC(dd, 0x80000001, &(val)->unauthAttributes))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignerInfoWithAttrBlobs(SignerInfoWithAttrBlobs *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_AttributesNC(&(val)->authAttributes);
	}
	ASN1Free_DigestEncryptionAlgIdNC(&(val)->digestEncryptionAlgorithm);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_AttributesNC(&(val)->unauthAttributes);
	}
    }
}

static int ASN1CALL ASN1Enc_SignerInfoWithBlobs(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfoWithBlobs *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->sid))
	return 0;
    if (!ASN1BEREncOpenType(enc, &(val)->digestAlgorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_AttributesNC2(enc, 0x80000000, &(val)->authAttributes))
	    return 0;
    }
    if (!ASN1Enc_DigestEncryptionAlgIdNC(enc, 0, &(val)->digestEncryptionAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->encryptedDigest).length, ((val)->encryptedDigest).value))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_AttributesNC2(enc, 0x80000001, &(val)->unauthAttributes))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignerInfoWithBlobs(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfoWithBlobs *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->sid))
	return 0;
    if (!ASN1BERDecOpenType2(dd, &(val)->digestAlgorithm))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_AttributesNC2(dd, 0x80000000, &(val)->authAttributes))
	    return 0;
    }
    if (!ASN1Dec_DigestEncryptionAlgIdNC(dd, 0, &(val)->digestEncryptionAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString2(dd, 0x4, &(val)->encryptedDigest))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_AttributesNC2(dd, 0x80000001, &(val)->unauthAttributes))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignerInfoWithBlobs(SignerInfoWithBlobs *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_AttributesNC2(&(val)->authAttributes);
	}
	ASN1Free_DigestEncryptionAlgIdNC(&(val)->digestEncryptionAlgorithm);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_AttributesNC2(&(val)->unauthAttributes);
	}
    }
}

static int ASN1CALL ASN1Enc_RecipientInfos(ASN1encoding_t enc, ASN1uint32_t tag, RecipientInfos *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_RecipientInfo(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RecipientInfos(ASN1decoding_t dec, ASN1uint32_t tag, RecipientInfos *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (RecipientInfo *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_RecipientInfo(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RecipientInfos(RecipientInfos *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_RecipientInfo(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_RecipientInfo(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_EncryptedContentInfo(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedContentInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1Enc_ContentEncryptionAlgId(enc, 0, &(val)->contentEncryptionAlgorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->encryptedContent).length, ((val)->encryptedContent).value))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptedContentInfo(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedContentInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->contentType))
	return 0;
    if (!ASN1Dec_ContentEncryptionAlgId(dd, 0, &(val)->contentEncryptionAlgorithm))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOctetString(dd, 0x80000000, &(val)->encryptedContent))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptedContentInfo(EncryptedContentInfo *val)
{
    if (val) {
	ASN1Free_ContentEncryptionAlgId(&(val)->contentEncryptionAlgorithm);
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->encryptedContent);
	}
    }
}

static int ASN1CALL ASN1Enc_RecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, RecipientInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_IssuerAndSerialNumber(enc, 0, &(val)->issuerAndSerialNumber))
	return 0;
    if (!ASN1Enc_KeyEncryptionAlgId(enc, 0, &(val)->keyEncryptionAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->encryptedKey).length, ((val)->encryptedKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, RecipientInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_IssuerAndSerialNumber(dd, 0, &(val)->issuerAndSerialNumber))
	return 0;
    if (!ASN1Dec_KeyEncryptionAlgId(dd, 0, &(val)->keyEncryptionAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->encryptedKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RecipientInfo(RecipientInfo *val)
{
    if (val) {
	ASN1Free_IssuerAndSerialNumber(&(val)->issuerAndSerialNumber);
	ASN1Free_KeyEncryptionAlgId(&(val)->keyEncryptionAlgorithm);
	ASN1octetstring_free(&(val)->encryptedKey);
    }
}

static int ASN1CALL ASN1Enc_SignedAndEnvelopedData(ASN1encoding_t enc, ASN1uint32_t tag, SignedAndEnvelopedData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_RecipientInfos(enc, 0, &(val)->recipientInfos))
	return 0;
    if (!ASN1Enc_DigestAlgorithmIdentifiers(enc, 0, &(val)->digestAlgorithms))
	return 0;
    if (!ASN1Enc_EncryptedContentInfo(enc, 0, &(val)->encryptedContentInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Certificates(enc, 0x80000000, &(val)->certificates))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_Crls(enc, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1Enc_SignerInfos(enc, 0, &(val)->signerInfos))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignedAndEnvelopedData(ASN1decoding_t dec, ASN1uint32_t tag, SignedAndEnvelopedData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_RecipientInfos(dd, 0, &(val)->recipientInfos))
	return 0;
    if (!ASN1Dec_DigestAlgorithmIdentifiers(dd, 0, &(val)->digestAlgorithms))
	return 0;
    if (!ASN1Dec_EncryptedContentInfo(dd, 0, &(val)->encryptedContentInfo))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Certificates(dd, 0x80000000, &(val)->certificates))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_Crls(dd, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1Dec_SignerInfos(dd, 0, &(val)->signerInfos))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignedAndEnvelopedData(SignedAndEnvelopedData *val)
{
    if (val) {
	ASN1Free_RecipientInfos(&(val)->recipientInfos);
	ASN1Free_DigestAlgorithmIdentifiers(&(val)->digestAlgorithms);
	ASN1Free_EncryptedContentInfo(&(val)->encryptedContentInfo);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Certificates(&(val)->certificates);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Crls(&(val)->crls);
	}
	ASN1Free_SignerInfos(&(val)->signerInfos);
    }
}

static int ASN1CALL ASN1Enc_DigestedData(ASN1encoding_t enc, ASN1uint32_t tag, DigestedData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_DigestAlgorithmIdentifier(enc, 0, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1Enc_ContentInfo(enc, 0, &(val)->contentInfo))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->digest).length, ((val)->digest).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestedData(ASN1decoding_t dec, ASN1uint32_t tag, DigestedData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_DigestAlgorithmIdentifier(dd, 0, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1Dec_ContentInfo(dd, 0, &(val)->contentInfo))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->digest))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestedData(DigestedData *val)
{
    if (val) {
	ASN1Free_DigestAlgorithmIdentifier(&(val)->digestAlgorithm);
	ASN1Free_ContentInfo(&(val)->contentInfo);
	ASN1octetstring_free(&(val)->digest);
    }
}

static int ASN1CALL ASN1Enc_EncryptedData(ASN1encoding_t enc, ASN1uint32_t tag, EncryptedData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_EncryptedContentInfo(enc, 0, &(val)->encryptedContentInfo))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EncryptedData(ASN1decoding_t dec, ASN1uint32_t tag, EncryptedData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_EncryptedContentInfo(dd, 0, &(val)->encryptedContentInfo))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EncryptedData(EncryptedData *val)
{
    if (val) {
	ASN1Free_EncryptedContentInfo(&(val)->encryptedContentInfo);
    }
}

static int ASN1CALL ASN1Enc_CertIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, CertIdentifier *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_IssuerAndSerialNumber(enc, 0, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->u.subjectKeyIdentifier).length, ((val)->u.subjectKeyIdentifier).value))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CertIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, CertIdentifier *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x10:
	(val)->choice = 1;
	if (!ASN1Dec_IssuerAndSerialNumber(dec, 0, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    case 0x80000000:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000000, &(val)->u.subjectKeyIdentifier))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CertIdentifier(CertIdentifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_IssuerAndSerialNumber(&(val)->u.issuerAndSerialNumber);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.subjectKeyIdentifier);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_OriginatorInfo(ASN1encoding_t enc, ASN1uint32_t tag, OriginatorInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Certificates(enc, 0x80000000, &(val)->certificates))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_Crls(enc, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OriginatorInfo(ASN1decoding_t dec, ASN1uint32_t tag, OriginatorInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Certificates(dd, 0x80000000, &(val)->certificates))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_Crls(dd, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OriginatorInfo(OriginatorInfo *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Certificates(&(val)->certificates);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Crls(&(val)->crls);
	}
    }
}

static int ASN1CALL ASN1Enc_OriginatorInfoNC(ASN1encoding_t enc, ASN1uint32_t tag, OriginatorInfoNC *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CertificatesNC(enc, 0x80000000, &(val)->certificates))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_CrlsNC(enc, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OriginatorInfoNC(ASN1decoding_t dec, ASN1uint32_t tag, OriginatorInfoNC *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_CertificatesNC(dd, 0x80000000, &(val)->certificates))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_CrlsNC(dd, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OriginatorInfoNC(OriginatorInfoNC *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CertificatesNC(&(val)->certificates);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_CrlsNC(&(val)->crls);
	}
    }
}

static int ASN1CALL ASN1Enc_CmsRecipientInfos(ASN1encoding_t enc, ASN1uint32_t tag, CmsRecipientInfos *val)
{
    ASN1uint32_t nLenOff;
    void *pBlk;
    ASN1uint32_t i;
    ASN1encoding_t enc2;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x11, &nLenOff))
	return 0;
    if (!ASN1DEREncBeginBlk(enc, ASN1_DER_SET_OF_BLOCK, &pBlk))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1DEREncNewBlkElement(pBlk, &enc2))
	    return 0;
	if (!ASN1Enc_CmsRecipientInfo(enc2, 0, &((val)->value)[i]))
	    return 0;
	if (!ASN1DEREncFlushBlkElement(pBlk))
	    return 0;
    }
    if (!ASN1DEREncEndBlk(pBlk))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmsRecipientInfos(ASN1decoding_t dec, ASN1uint32_t tag, CmsRecipientInfos *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x11, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (CmsRecipientInfo *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_CmsRecipientInfo(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmsRecipientInfos(CmsRecipientInfos *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_CmsRecipientInfo(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_CmsRecipientInfo(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_KeyTransRecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, KeyTransRecipientInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_CertIdentifier(enc, 0, &(val)->rid))
	return 0;
    if (!ASN1Enc_KeyEncryptionAlgId(enc, 0, &(val)->keyEncryptionAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->encryptedKey).length, ((val)->encryptedKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeyTransRecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, KeyTransRecipientInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_CertIdentifier(dd, 0, &(val)->rid))
	return 0;
    if (!ASN1Dec_KeyEncryptionAlgId(dd, 0, &(val)->keyEncryptionAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->encryptedKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KeyTransRecipientInfo(KeyTransRecipientInfo *val)
{
    if (val) {
	ASN1Free_CertIdentifier(&(val)->rid);
	ASN1Free_KeyEncryptionAlgId(&(val)->keyEncryptionAlgorithm);
	ASN1octetstring_free(&(val)->encryptedKey);
    }
}

static int ASN1CALL ASN1Enc_OriginatorPublicKey(ASN1encoding_t enc, ASN1uint32_t tag, OriginatorPublicKey *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_AlgorithmIdentifier(enc, 0, &(val)->algorithm))
	return 0;
    if (!ASN1DEREncBitString(enc, 0x3, ((val)->publicKey).length, ((val)->publicKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OriginatorPublicKey(ASN1decoding_t dec, ASN1uint32_t tag, OriginatorPublicKey *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_AlgorithmIdentifier(dd, 0, &(val)->algorithm))
	return 0;
    if (!ASN1BERDecBitString(dd, 0x3, &(val)->publicKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OriginatorPublicKey(OriginatorPublicKey *val)
{
    if (val) {
	ASN1Free_AlgorithmIdentifier(&(val)->algorithm);
	ASN1bitstring_free(&(val)->publicKey);
    }
}

static int ASN1CALL ASN1Enc_RecipientEncryptedKeys(ASN1encoding_t enc, ASN1uint32_t tag, RecipientEncryptedKeys *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t i;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    for (i = 0; i < (val)->count; i++) {
	if (!ASN1Enc_RecipientEncryptedKey(enc, 0, &((val)->value)[i]))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RecipientEncryptedKeys(ASN1decoding_t dec, ASN1uint32_t tag, RecipientEncryptedKeys *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    ASN1uint32_t n;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    (val)->count = n = 0;
    (val)->value = NULL;
    while (ASN1BERDecNotEndOfContents(dd, di)) {
	if (!ASN1BERDecPeekTag(dd, &t))
	    return 0;
	if ((val)->count >= n) {
	    n = n ? (n << 1) : 16;
	    if (!((val)->value = (RecipientEncryptedKey *)ASN1DecRealloc(dd, (val)->value, n * sizeof(*(val)->value))))
		return 0;
	}
	if (!ASN1Dec_RecipientEncryptedKey(dd, 0, &((val)->value)[(val)->count]))
	    return 0;
	((val)->count)++;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RecipientEncryptedKeys(RecipientEncryptedKeys *val)
{
    ASN1uint32_t i;
    if (val) {
	ASN1Free_RecipientEncryptedKey(&(val)->value[0]);
	for (i = 1; i < (val)->count; i++) {
	    ASN1Free_RecipientEncryptedKey(&(val)->value[i]);
	}
	ASN1Free((val)->value);
    }
}

static int ASN1CALL ASN1Enc_OtherKeyAttribute(ASN1encoding_t enc, ASN1uint32_t tag, OtherKeyAttribute *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncObjectIdentifier2(enc, 0x6, &(val)->keyAttrId))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncOpenType(enc, &(val)->keyAttr))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_OtherKeyAttribute(ASN1decoding_t dec, ASN1uint32_t tag, OtherKeyAttribute *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecObjectIdentifier2(dd, 0x6, &(val)->keyAttrId))
	return 0;
    if (ASN1BERDecPeekTag(dd, &t)) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecOpenType(dd, &(val)->keyAttr))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_OtherKeyAttribute(OtherKeyAttribute *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1open_free(&(val)->keyAttr);
	}
    }
}

static int ASN1CALL ASN1Enc_MailListKeyIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, MailListKeyIdentifier *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->kekIdentifier).length, ((val)->kekIdentifier).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->date))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_OtherKeyAttribute(enc, 0, &(val)->other))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MailListKeyIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, MailListKeyIdentifier *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->kekIdentifier))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x18) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecGeneralizedTime(dd, 0x18, &(val)->date))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_OtherKeyAttribute(dd, 0, &(val)->other))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MailListKeyIdentifier(MailListKeyIdentifier *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->kekIdentifier);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_OtherKeyAttribute(&(val)->other);
	}
    }
}

static int ASN1CALL ASN1Enc_DigestInfo(ASN1encoding_t enc, ASN1uint32_t tag, DigestInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_DigestAlgorithmIdentifier(enc, 0, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->digest).length, ((val)->digest).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_DigestInfo(ASN1decoding_t dec, ASN1uint32_t tag, DigestInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_DigestAlgorithmIdentifier(dd, 0, &(val)->digestAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->digest))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_DigestInfo(DigestInfo *val)
{
    if (val) {
	ASN1Free_DigestAlgorithmIdentifier(&(val)->digestAlgorithm);
	ASN1octetstring_free(&(val)->digest);
    }
}

static int ASN1CALL ASN1Enc_SignedData(ASN1encoding_t enc, ASN1uint32_t tag, SignedData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_DigestAlgorithmIdentifiers(enc, 0, &(val)->digestAlgorithms))
	return 0;
    if (!ASN1Enc_ContentInfo(enc, 0, &(val)->contentInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Certificates(enc, 0x80000000, &(val)->certificates))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_Crls(enc, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1Enc_SignerInfos(enc, 0, &(val)->signerInfos))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignedData(ASN1decoding_t dec, ASN1uint32_t tag, SignedData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_DigestAlgorithmIdentifiers(dd, 0, &(val)->digestAlgorithms))
	return 0;
    if (!ASN1Dec_ContentInfo(dd, 0, &(val)->contentInfo))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Certificates(dd, 0x80000000, &(val)->certificates))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_Crls(dd, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1Dec_SignerInfos(dd, 0, &(val)->signerInfos))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignedData(SignedData *val)
{
    if (val) {
	ASN1Free_DigestAlgorithmIdentifiers(&(val)->digestAlgorithms);
	ASN1Free_ContentInfo(&(val)->contentInfo);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Certificates(&(val)->certificates);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Crls(&(val)->crls);
	}
	ASN1Free_SignerInfos(&(val)->signerInfos);
    }
}

static int ASN1CALL ASN1Enc_SignerInfo(ASN1encoding_t enc, ASN1uint32_t tag, SignerInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_CertIdentifier(enc, 0, &(val)->sid))
	return 0;
    if (!ASN1Enc_DigestAlgorithmIdentifier(enc, 0, &(val)->digestAlgorithm))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_Attributes(enc, 0x80000000, &(val)->authenticatedAttributes))
	    return 0;
    }
    if (!ASN1Enc_DigestEncryptionAlgId(enc, 0, &(val)->digestEncryptionAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->encryptedDigest).length, ((val)->encryptedDigest).value))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_Attributes(enc, 0x80000001, &(val)->unauthAttributes))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignerInfo(ASN1decoding_t dec, ASN1uint32_t tag, SignerInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_CertIdentifier(dd, 0, &(val)->sid))
	return 0;
    if (!ASN1Dec_DigestAlgorithmIdentifier(dd, 0, &(val)->digestAlgorithm))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_Attributes(dd, 0x80000000, &(val)->authenticatedAttributes))
	    return 0;
    }
    if (!ASN1Dec_DigestEncryptionAlgId(dd, 0, &(val)->digestEncryptionAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->encryptedDigest))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_Attributes(dd, 0x80000001, &(val)->unauthAttributes))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignerInfo(SignerInfo *val)
{
    if (val) {
	ASN1Free_CertIdentifier(&(val)->sid);
	ASN1Free_DigestAlgorithmIdentifier(&(val)->digestAlgorithm);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_Attributes(&(val)->authenticatedAttributes);
	}
	ASN1Free_DigestEncryptionAlgId(&(val)->digestEncryptionAlgorithm);
	ASN1octetstring_free(&(val)->encryptedDigest);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Attributes(&(val)->unauthAttributes);
	}
    }
}

static int ASN1CALL ASN1Enc_SignedDataWithBlobs(ASN1encoding_t enc, ASN1uint32_t tag, SignedDataWithBlobs *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_DigestAlgorithmIdentifiersNC(enc, 0, &(val)->digestAlgorithms))
	return 0;
    if (!ASN1Enc_ContentInfoNC(enc, 0, &(val)->contentInfo))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_CertificatesNC(enc, 0x80000000, &(val)->certificates))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_CrlsNC(enc, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1Enc_SignerInfosNC(enc, 0, &(val)->signerInfos))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_SignedDataWithBlobs(ASN1decoding_t dec, ASN1uint32_t tag, SignedDataWithBlobs *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_DigestAlgorithmIdentifiersNC(dd, 0, &(val)->digestAlgorithms))
	return 0;
    if (!ASN1Dec_ContentInfoNC(dd, 0, &(val)->contentInfo))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_CertificatesNC(dd, 0x80000000, &(val)->certificates))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_CrlsNC(dd, 0x80000001, &(val)->crls))
	    return 0;
    }
    if (!ASN1Dec_SignerInfosNC(dd, 0, &(val)->signerInfos))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_SignedDataWithBlobs(SignedDataWithBlobs *val)
{
    if (val) {
	ASN1Free_DigestAlgorithmIdentifiersNC(&(val)->digestAlgorithms);
	ASN1Free_ContentInfoNC(&(val)->contentInfo);
	if ((val)->o[0] & 0x80) {
	    ASN1Free_CertificatesNC(&(val)->certificates);
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_CrlsNC(&(val)->crls);
	}
	ASN1Free_SignerInfosNC(&(val)->signerInfos);
    }
}

static int ASN1CALL ASN1Enc_EnvelopedData(ASN1encoding_t enc, ASN1uint32_t tag, EnvelopedData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_RecipientInfos(enc, 0, &(val)->recipientInfos))
	return 0;
    if (!ASN1Enc_EncryptedContentInfo(enc, 0, &(val)->encryptedContentInfo))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_EnvelopedData(ASN1decoding_t dec, ASN1uint32_t tag, EnvelopedData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_RecipientInfos(dd, 0, &(val)->recipientInfos))
	return 0;
    if (!ASN1Dec_EncryptedContentInfo(dd, 0, &(val)->encryptedContentInfo))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_EnvelopedData(EnvelopedData *val)
{
    if (val) {
	ASN1Free_RecipientInfos(&(val)->recipientInfos);
	ASN1Free_EncryptedContentInfo(&(val)->encryptedContentInfo);
    }
}

static int ASN1CALL ASN1Enc_CmsEnvelopedData(ASN1encoding_t enc, ASN1uint32_t tag, CmsEnvelopedData *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1Enc_OriginatorInfo(enc, 0x80000000, &(val)->originatorInfo))
	    return 0;
    }
    if (!ASN1Enc_CmsRecipientInfos(enc, 0, &(val)->recipientInfos))
	return 0;
    if (!ASN1Enc_EncryptedContentInfo(enc, 0, &(val)->encryptedContentInfo))
	return 0;
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_Attributes(enc, 0x80000001, &(val)->unprotectedAttrs))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_CmsEnvelopedData(ASN1decoding_t dec, ASN1uint32_t tag, CmsEnvelopedData *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000000) {
	(val)->o[0] |= 0x80;
	if (!ASN1Dec_OriginatorInfo(dd, 0x80000000, &(val)->originatorInfo))
	    return 0;
    }
    if (!ASN1Dec_CmsRecipientInfos(dd, 0, &(val)->recipientInfos))
	return 0;
    if (!ASN1Dec_EncryptedContentInfo(dd, 0, &(val)->encryptedContentInfo))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_Attributes(dd, 0x80000001, &(val)->unprotectedAttrs))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_CmsEnvelopedData(CmsEnvelopedData *val)
{
    if (val) {
	if ((val)->o[0] & 0x80) {
	    ASN1Free_OriginatorInfo(&(val)->originatorInfo);
	}
	ASN1Free_CmsRecipientInfos(&(val)->recipientInfos);
	ASN1Free_EncryptedContentInfo(&(val)->encryptedContentInfo);
	if ((val)->o[0] & 0x40) {
	    ASN1Free_Attributes(&(val)->unprotectedAttrs);
	}
    }
}

static int ASN1CALL ASN1Enc_OriginatorIdentifierOrKey(ASN1encoding_t enc, ASN1uint32_t tag, OriginatorIdentifierOrKey *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_IssuerAndSerialNumber(enc, 0, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1DEREncOctetString(enc, 0x80000000, ((val)->u.subjectKeyIdentifier).length, ((val)->u.subjectKeyIdentifier).value))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_OriginatorPublicKey(enc, 0x80000001, &(val)->u.originatorKey))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_OriginatorIdentifierOrKey(ASN1decoding_t dec, ASN1uint32_t tag, OriginatorIdentifierOrKey *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x10:
	(val)->choice = 1;
	if (!ASN1Dec_IssuerAndSerialNumber(dec, 0, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    case 0x80000000:
	(val)->choice = 2;
	if (!ASN1BERDecOctetString(dec, 0x80000000, &(val)->u.subjectKeyIdentifier))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 3;
	if (!ASN1Dec_OriginatorPublicKey(dec, 0x80000001, &(val)->u.originatorKey))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_OriginatorIdentifierOrKey(OriginatorIdentifierOrKey *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_IssuerAndSerialNumber(&(val)->u.issuerAndSerialNumber);
	    break;
	case 2:
	    ASN1octetstring_free(&(val)->u.subjectKeyIdentifier);
	    break;
	case 3:
	    ASN1Free_OriginatorPublicKey(&(val)->u.originatorKey);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RecipientKeyIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, RecipientKeyIdentifier *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->subjectKeyIdentifier).length, ((val)->subjectKeyIdentifier).value))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1DEREncGeneralizedTime(enc, 0x18, &(val)->date))
	    return 0;
    }
    if ((val)->o[0] & 0x40) {
	if (!ASN1Enc_OtherKeyAttribute(enc, 0, &(val)->other))
	    return 0;
    }
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RecipientKeyIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, RecipientKeyIdentifier *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->subjectKeyIdentifier))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x18) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecGeneralizedTime(dd, 0x18, &(val)->date))
	    return 0;
    }
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x10) {
	(val)->o[0] |= 0x40;
	if (!ASN1Dec_OtherKeyAttribute(dd, 0, &(val)->other))
	    return 0;
    }
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RecipientKeyIdentifier(RecipientKeyIdentifier *val)
{
    if (val) {
	ASN1octetstring_free(&(val)->subjectKeyIdentifier);
	if ((val)->o[0] & 0x80) {
	}
	if ((val)->o[0] & 0x40) {
	    ASN1Free_OtherKeyAttribute(&(val)->other);
	}
    }
}

static int ASN1CALL ASN1Enc_MailListRecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, MailListRecipientInfo *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1Enc_MailListKeyIdentifier(enc, 0, &(val)->mlid))
	return 0;
    if (!ASN1Enc_KeyEncryptionAlgId(enc, 0, &(val)->keyEncryptionAlgorithm))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->encryptedKey).length, ((val)->encryptedKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_MailListRecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, MailListRecipientInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1Dec_MailListKeyIdentifier(dd, 0, &(val)->mlid))
	return 0;
    if (!ASN1Dec_KeyEncryptionAlgId(dd, 0, &(val)->keyEncryptionAlgorithm))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->encryptedKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_MailListRecipientInfo(MailListRecipientInfo *val)
{
    if (val) {
	ASN1Free_MailListKeyIdentifier(&(val)->mlid);
	ASN1Free_KeyEncryptionAlgId(&(val)->keyEncryptionAlgorithm);
	ASN1octetstring_free(&(val)->encryptedKey);
    }
}

static int ASN1CALL ASN1Enc_KeyAgreeRecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, KeyAgreeRecipientInfo *val)
{
    ASN1uint32_t nLenOff;
    ASN1uint32_t nLenOff0;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1BEREncS32(enc, 0x2, (val)->version))
	return 0;
    if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff0))
	return 0;
    if (!ASN1Enc_OriginatorIdentifierOrKey(enc, 0, &(val)->originator))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	return 0;
    if ((val)->o[0] & 0x80) {
	if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
	    return 0;
	if (!ASN1DEREncOctetString(enc, 0x4, ((val)->ukm).length, ((val)->ukm).value))
	    return 0;
	if (!ASN1BEREncEndOfContents(enc, nLenOff0))
	    return 0;
    }
    if (!ASN1Enc_KeyEncryptionAlgId(enc, 0, &(val)->keyEncryptionAlgorithm))
	return 0;
    if (!ASN1Enc_RecipientEncryptedKeys(enc, 0, &(val)->recipientEncryptedKeys))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_KeyAgreeRecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, KeyAgreeRecipientInfo *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1decoding_t dd0;
    ASN1octet_t *di0;
    ASN1uint32_t t;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    ZeroMemory((val)->o, 1);
    if (!ASN1BERDecS32Val(dd, 0x2, &(val)->version))
	return 0;
    if (!ASN1BERDecExplicitTag(dd, 0x80000000, &dd0, &di0))
	return 0;
    if (!ASN1Dec_OriginatorIdentifierOrKey(dd0, 0, &(val)->originator))
	return 0;
    if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	return 0;
    ASN1BERDecPeekTag(dd, &t);
    if (t == 0x80000001) {
	(val)->o[0] |= 0x80;
	if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd0, &di0))
	    return 0;
	if (!ASN1BERDecOctetString(dd0, 0x4, &(val)->ukm))
	    return 0;
	if (!ASN1BERDecEndOfContents(dd, dd0, di0))
	    return 0;
    }
    if (!ASN1Dec_KeyEncryptionAlgId(dd, 0, &(val)->keyEncryptionAlgorithm))
	return 0;
    if (!ASN1Dec_RecipientEncryptedKeys(dd, 0, &(val)->recipientEncryptedKeys))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_KeyAgreeRecipientInfo(KeyAgreeRecipientInfo *val)
{
    if (val) {
	ASN1Free_OriginatorIdentifierOrKey(&(val)->originator);
	if ((val)->o[0] & 0x80) {
	    ASN1octetstring_free(&(val)->ukm);
	}
	ASN1Free_KeyEncryptionAlgId(&(val)->keyEncryptionAlgorithm);
	ASN1Free_RecipientEncryptedKeys(&(val)->recipientEncryptedKeys);
    }
}

static int ASN1CALL ASN1Enc_RecipientIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, RecipientIdentifier *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_IssuerAndSerialNumber(enc, 0, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_RecipientKeyIdentifier(enc, 0x80000000, &(val)->u.rKeyId))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_RecipientIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, RecipientIdentifier *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x10:
	(val)->choice = 1;
	if (!ASN1Dec_IssuerAndSerialNumber(dec, 0, &(val)->u.issuerAndSerialNumber))
	    return 0;
	break;
    case 0x80000000:
	(val)->choice = 2;
	if (!ASN1Dec_RecipientKeyIdentifier(dec, 0x80000000, &(val)->u.rKeyId))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_RecipientIdentifier(RecipientIdentifier *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_IssuerAndSerialNumber(&(val)->u.issuerAndSerialNumber);
	    break;
	case 2:
	    ASN1Free_RecipientKeyIdentifier(&(val)->u.rKeyId);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_CmsRecipientInfo(ASN1encoding_t enc, ASN1uint32_t tag, CmsRecipientInfo *val)
{
    switch ((val)->choice) {
    case 1:
	if (!ASN1Enc_KeyTransRecipientInfo(enc, 0, &(val)->u.keyTransRecipientInfo))
	    return 0;
	break;
    case 2:
	if (!ASN1Enc_KeyAgreeRecipientInfo(enc, 0x80000001, &(val)->u.keyAgreeRecipientInfo))
	    return 0;
	break;
    case 3:
	if (!ASN1Enc_MailListRecipientInfo(enc, 0x80000002, &(val)->u.mailListRecipientInfo))
	    return 0;
	break;
    }
    return 1;
}

static int ASN1CALL ASN1Dec_CmsRecipientInfo(ASN1decoding_t dec, ASN1uint32_t tag, CmsRecipientInfo *val)
{
    ASN1uint32_t t;
    if (!ASN1BERDecPeekTag(dec, &t))
	return 0;
    switch (t) {
    case 0x10:
	(val)->choice = 1;
	if (!ASN1Dec_KeyTransRecipientInfo(dec, 0, &(val)->u.keyTransRecipientInfo))
	    return 0;
	break;
    case 0x80000001:
	(val)->choice = 2;
	if (!ASN1Dec_KeyAgreeRecipientInfo(dec, 0x80000001, &(val)->u.keyAgreeRecipientInfo))
	    return 0;
	break;
    case 0x80000002:
	(val)->choice = 3;
	if (!ASN1Dec_MailListRecipientInfo(dec, 0x80000002, &(val)->u.mailListRecipientInfo))
	    return 0;
	break;
    default:
	ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
	return 0;
    }
    return 1;
}

static void ASN1CALL ASN1Free_CmsRecipientInfo(CmsRecipientInfo *val)
{
    if (val) {
	switch ((val)->choice) {
	case 1:
	    ASN1Free_KeyTransRecipientInfo(&(val)->u.keyTransRecipientInfo);
	    break;
	case 2:
	    ASN1Free_KeyAgreeRecipientInfo(&(val)->u.keyAgreeRecipientInfo);
	    break;
	case 3:
	    ASN1Free_MailListRecipientInfo(&(val)->u.mailListRecipientInfo);
	    break;
	}
    }
}

static int ASN1CALL ASN1Enc_RecipientEncryptedKey(ASN1encoding_t enc, ASN1uint32_t tag, RecipientEncryptedKey *val)
{
    ASN1uint32_t nLenOff;
    if (!ASN1BEREncExplicitTag(enc, tag ? tag : 0x10, &nLenOff))
	return 0;
    if (!ASN1Enc_RecipientIdentifier(enc, 0, &(val)->rid))
	return 0;
    if (!ASN1DEREncOctetString(enc, 0x4, ((val)->encryptedKey).length, ((val)->encryptedKey).value))
	return 0;
    if (!ASN1BEREncEndOfContents(enc, nLenOff))
	return 0;
    return 1;
}

static int ASN1CALL ASN1Dec_RecipientEncryptedKey(ASN1decoding_t dec, ASN1uint32_t tag, RecipientEncryptedKey *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    if (!ASN1BERDecExplicitTag(dec, tag ? tag : 0x10, &dd, &di))
	return 0;
    if (!ASN1Dec_RecipientIdentifier(dd, 0, &(val)->rid))
	return 0;
    if (!ASN1BERDecOctetString(dd, 0x4, &(val)->encryptedKey))
	return 0;
    if (!ASN1BERDecEndOfContents(dec, dd, di))
	return 0;
    return 1;
}

static void ASN1CALL ASN1Free_RecipientEncryptedKey(RecipientEncryptedKey *val)
{
    if (val) {
	ASN1Free_RecipientIdentifier(&(val)->rid);
	ASN1octetstring_free(&(val)->encryptedKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\mssign32\dllmain.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       dllmain.cpp
//
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  Function:   DllRegisterServer
//
//  Synopsis:   Add registry entries for this library.
//
//  Returns:    HRESULT
//--------------------------------------------------------------------------

#include "global.hxx"

HINSTANCE hInstance = NULL;

/*extern HRESULT WINAPI SpcASNRegisterServer(LPCWSTR dllName);
extern HRESULT WINAPI SpcASNUnregisterServer();
extern HRESULT WINAPI OidASNRegisterServer(LPCWSTR pszDllName);
extern HRESULT WINAPI OidASNUnregisterServer(void);

extern BOOL AttributeInit(HMODULE hInst); */

STDAPI DllRegisterServer ( void )
{
    HRESULT hr = S_OK;
    return hr;
}


//+-------------------------------------------------------------------------
//  Function:   DllUnregisterServer
//
//  Synopsis:   Remove registry entries for this library.
//
//  Returns:    HRESULT
//--------------------------------------------------------------------------

STDAPI DllUnregisterServer ( void )
{
    HRESULT hr = S_OK;
    return hr;
}


BOOL WINAPI DllMain(
                HMODULE hInstDLL,
                DWORD fdwReason,
                LPVOID lpvReserved)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls((HINSTANCE)hInstDLL);

        hInstance = (HINSTANCE)hInstDLL;
    }

	return(TRUE);
}


HINSTANCE GetInstanceHandle()
{
    return hInstance;
}

/*
#if !DBG
int _cdecl main(int argc, char * argv[])
{
    return 0;
}
#endif
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\mssign32\httptran.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       httptran.cpp
//
//--------------------------------------------------------------------------


#include "global.hxx"

#include <windows.h>
#include <tchar.h>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>


#define REALLOCSIZE 4096

DWORD CHttpTran::Open(const TCHAR * tszURL, DWORD fOpenT) {

    TCHAR   tszDomanName[_MAX_PATH];
    TCHAR   tszPort[12];
    TCHAR * ptch;
    TCHAR * ptchT;
    DWORD   err;
    INTERNET_PORT dwPort = INTERNET_OPEN_TYPE_PRECONFIG;

    // did we get a flag?
    if(  (fOpenT & (GTREAD | GTWRITE)) == 0 )
        return(ERROR_INVALID_PARAMETER);

    // is it a readonly flag, then do gets
    fOpen = fOpenT;

    assert(tszURL != NULL);

    // we must have http://
    assert(_tcslen(tszURL) > 7);
    assert(_tcsnicmp(tszURL, TEXT("http://"), 7) == 0);

    // copy the Doman Name
    ptch = (TCHAR *) &tszURL[7];
    ptchT = tszDomanName;
    while(*ptch != _T('/')  && *ptch != _T(':') &&  *ptch != 0)
        *ptchT++ = *ptch++;
    *ptchT = 0;

    // parse out the port number
    tszPort[0] = 0;
    if(*ptch == _T(':')) {
        ptchT = tszPort;
        while(*ptch != _T('/') && *ptch != 0)
            *ptchT++ = *ptch++;
        *ptchT = 0;
    }

    // Note, we don't support port numbers
    if(tszPort[0] != 0) {
        assert(tszPort[0] == ':');
        dwPort = (INTERNET_PORT)atoi(&tszPort[1]);
    }

    // save away what to look up.
    tszPartURL = (TCHAR *) malloc(_tcslen(ptch) + 1);
    if(NULL == tszPartURL)
        return ERROR_OUTOFMEMORY;

    _tcscpy(tszPartURL, ptch);

    //                        INTERNET_OPEN_TYPE_DIRECT,
    if( (hIOpen = InternetOpen( TEXT("Transport"),
                            INTERNET_OPEN_TYPE_PRECONFIG,
                            NULL,
                            NULL,
                            0)) == NULL                 ||

        (hIConnect = InternetConnect(hIOpen,
                                    tszDomanName,
                                    dwPort,
                                    NULL,
                                    NULL,
                                    INTERNET_SERVICE_HTTP,
                                    0,
                                    0)) == NULL     ) {
        err = GetLastError();
        return(err);
    }

    // If this is a GET, do a dummy send
    if( fOpen == GTREAD  &&
        ((hIHttp = HttpOpenRequest(hIConnect,
                                    TEXT("GET"),
                                    tszPartURL,
                                    HTTP_VERSION,
                                    NULL,
                                    NULL,
                                    INTERNET_FLAG_DONT_CACHE,
                                    0)) == NULL     ||
        HttpSendRequest(hIHttp, TEXT("Accept: */*\r\n"), (DWORD) -1, NULL, 0) == FALSE) ) {
        err = GetLastError();
        return(err);
    }

    return(ERROR_SUCCESS);
}

DWORD CHttpTran::Send(DWORD dwEncodeType, DWORD cbSendBuff, const BYTE * pbSendBuff) {

    TCHAR       tszBuff[1024];
    DWORD       err;
    TCHAR *     tszContentType;


    if( pbRecBuf != NULL || (fOpen & GTWRITE) != GTWRITE)
        return(ERROR_INVALID_PARAMETER);

    switch( dwEncodeType ) {
        case ASN_ENCODING:
            tszContentType = TEXT("application/x-octet-stream-asn");
            break;
        case TLV_ENCODING:
            tszContentType = TEXT("application/x-octet-stream-tlv");
            break;
        case IDL_ENCODING:
            tszContentType = TEXT("application/x-octet-stream-idl");
            break;
        case OCTET_ENCODING:
            tszContentType = TEXT("application/octet-stream");
            break;
        default:
            tszContentType = TEXT("text/*");
            break;
    }

    // say how long the buffer is
    _stprintf(tszBuff, TEXT("Content-Type: %s\r\nContent-Length: %d\r\nAccept: %s\r\n"), tszContentType, cbSendBuff,tszContentType);

    if( (hIHttp = HttpOpenRequest(hIConnect,
                                    TEXT("POST"),
                                    tszPartURL,
                                    HTTP_VERSION,
                                    NULL,
                                    NULL,
                                    INTERNET_FLAG_DONT_CACHE,
                                    0)) == NULL ) {
        return(GetLastError());
    }

    // send of the request, this will wait for a response
    if( HttpSendRequest(hIHttp, tszBuff, (DWORD) -1, (LPVOID) pbSendBuff, cbSendBuff) == FALSE ) {

        err = GetLastError();
        // close out the handle
        assert(hIHttp != NULL);
        InternetCloseHandle(hIHttp);
        hIHttp = NULL;

        return(err);
    }

    return(ERROR_SUCCESS);
}

DWORD CHttpTran::Receive(DWORD * pdwEncodeType, DWORD * pcbReceiveBuff, BYTE ** ppbReceiveBuff) {

    TCHAR       tszBuff[1024];
    DWORD       cbBuff, cbBuffRead, cbBuffT;
    DWORD       err;


    assert(pcbReceiveBuff != NULL && ppbReceiveBuff != NULL);
    *ppbReceiveBuff = NULL;
    *pcbReceiveBuff = 0;

    if( pbRecBuf != NULL  || (fOpen & GTREAD) != GTREAD || hIHttp == NULL)
        return(ERROR_INVALID_PARAMETER);

    // get the content type
    if( pdwEncodeType != NULL) {

        cbBuff = sizeof(tszBuff);
        if(HttpQueryInfo(   hIHttp,
                            HTTP_QUERY_CONTENT_TYPE,
                            tszBuff,
                            &cbBuff,
                            NULL) == FALSE)
            return(GetLastError());

        assert(cbBuff > 0);

        // for now assert we have a content type of TLV_ENCODING
        if(!_tcscmp(TEXT("application/x-octet-stream-asn"), tszBuff))
            *pdwEncodeType = ASN_ENCODING;
        else if(!_tcscmp(TEXT("application/x-octet-stream-idl"), tszBuff))
            *pdwEncodeType = IDL_ENCODING;
        else if(!_tcscmp(TEXT("application/x-octet-stream-tlv"), tszBuff))
            *pdwEncodeType = TLV_ENCODING;
        else if(!_tcscmp(TEXT("application/octet-stream"), tszBuff))
            *pdwEncodeType = OCTET_ENCODING;
        else
            *pdwEncodeType = ASCII_ENCODING;

    }

    // allocate a buffer
    cbBuff = REALLOCSIZE;
    if( (pbRecBuf = (PBYTE) malloc(cbBuff)) == NULL )
	return(ERROR_NOT_ENOUGH_MEMORY);

    // read the data
    cbBuffRead = 0;
    cbBuffT = 1;
    while(cbBuffT != 0) {
	cbBuffT = 0;

	if((cbBuff - cbBuffRead) == 0) {
	    cbBuff += REALLOCSIZE;
	    pbRecBuf = (PBYTE) realloc(pbRecBuf, cbBuff);
	    if( pbRecBuf == NULL ) {
		free(pbRecBuf);
		InternetCloseHandle(hIHttp);
		return(ERROR_NOT_ENOUGH_MEMORY);
	    }
	}

        if(InternetReadFile(hIHttp, &pbRecBuf[cbBuffRead], (cbBuff - cbBuffRead), &cbBuffT)  == FALSE  ) {
            err = GetLastError();
	    free(pbRecBuf);
	    InternetCloseHandle(hIHttp);
            return(err);
        }
        cbBuffRead += cbBuffT;
    }

    // pass back the info
    *ppbReceiveBuff = pbRecBuf;
    *pcbReceiveBuff = cbBuffRead;
    return(ERROR_SUCCESS);
}

DWORD CHttpTran::Free(BYTE * pb) {
    assert(pb == pbRecBuf);
    free(pbRecBuf);
    pbRecBuf = NULL;
    return(ERROR_SUCCESS);
}

DWORD CHttpTran::Close(void) {

	// free any buffers
	if(pbRecBuf != NULL) {
	    free(pbRecBuf);
	    pbRecBuf = NULL;
	}

	if(tszPartURL != NULL) {
	    free(tszPartURL);
	    tszPartURL = NULL;
	}

	if(hIHttp != NULL) {
	    InternetCloseHandle(hIHttp);
	    hIHttp = NULL;
	}

	if(hIConnect != NULL) {
	    InternetCloseHandle(hIConnect);
	    hIConnect = NULL;
	}

	if(hIOpen != NULL) {
	    InternetCloseHandle(hIOpen);
	    hIOpen = NULL;
	}

    return(ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\mssign32\fileguid.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       fileguid.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include "sgnerror.h"

//+-----------------------------------------------------------------------
//  SignGetFileType
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//    E_INVALIDARG
//      Invalid arguement passed in (Requires a file name 
//                                   and pointer to a guid ptr)
//    See also:
//      GetFileInformationByHandle()
//      CreateFile()
//     
//------------------------------------------------------------------------



HRESULT SignGetFileType(HANDLE hFile,
                        const WCHAR *pwszFile,
                       GUID* pGuid)
// Answer as to the type as which we should sign this file
{
    if (!(pGuid) || !(hFile) || (hFile == INVALID_HANDLE_VALUE))
    {
        return(E_INVALIDARG);
    }

    if (!(CryptSIPRetrieveSubjectGuid(pwszFile, hFile, pGuid)))
    {
        return(GetLastError());
    }

    return(S_OK);

#   ifdef PCB_OLD
        // Java class files have a magic number at their start. They always begin
        //      0xCA 0xFE 0xBA 0xBE
        // CAB files begin 'M' 'S' 'C' 'F'
        //
        
        if(!pGuid || hFile == NULL || hFile == INVALID_HANDLE_VALUE) 
            return E_INVALIDARG;
        
        ZeroMemory(pGuid, sizeof(GUID));
        PKITRY { 
            static  BYTE rgbMagicJava[] = { 0xCA, 0xFE, 0xBA, 0xBE };
            static  BYTE rgbMagicCab [] = { 'M', 'S', 'C', 'F' };
            BYTE rgbRead[4];
            DWORD dwRead;
            
            if (ReadFile(hFile, rgbRead, 4, &dwRead, NULL) &&
                dwRead == 4) {
                if (memcmp(rgbRead, rgbMagicJava, 4)==0) 
                    *pGuid = JavaImage;
                else if (memcmp(rgbRead, rgbMagicCab, 4)==0)
                    *pGuid = CabImage;
                else 
                    *pGuid = PeImage;
            }
        
        
            // Rewind the file
            if(SetFilePointer(hFile, 0, 0, FILE_BEGIN) == 0xffffffff)
                PKITHROW(SignError());
        
        }
        PKICATCH(err) {
            hr = err.pkiError;
        } PKIEND;
        
        return hr;
#   endif // PCB_OLD
}

//Xiaohs: the following function is no longer necessary after auth2upd
/*HRESULT SignLoadSipFlags(GUID* pSubjectGuid,
                        DWORD *dwFlags)
{
    HRESULT hr = S_OK;
    GUID sSip;
    if(!dwFlags)
        return E_INVALIDARG;

    if (dwFlags)
    {
        *dwFlags = 0;
        sSip = PeImage;
        if(memcmp(&sSip, pSubjectGuid, sizeof(GUID)) == 0) 
        {
            *dwFlags = SPC_INC_PE_RESOURCES_FLAG | SPC_INC_PE_IMPORT_ADDR_TABLE_FLAG;
            return hr;
        }
    }
    return hr;
} */


//+-----------------------------------------------------------------------
//  FileToSubjectType
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//    E_INVALIDARG
//      Invalid arguement passed in (Requires a file name 
//                                   and pointer to a guid ptr)
//    TRUST_E_SUBJECT_FORM_UNKNOWN
//       Unknow file type
//    See also:
//      GetFileInformationByHandle()
//      CreateFile()
//     
//------------------------------------------------------------------------

HRESULT SignOpenFile(LPCWSTR  pwszFilename, 
                    HANDLE*  pFileHandle)
{
    HRESULT hr = S_OK;
    HANDLE hFile = NULL;
    BY_HANDLE_FILE_INFORMATION hFileInfo;
    
    if(!pwszFilename || !pFileHandle)
        return E_INVALIDARG;
    
    PKITRY {
        hFile = CreateFileU(pwszFilename,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ,
                            NULL,                   // lpsa
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);                 // hTemplateFile

        if(INVALID_HANDLE_VALUE == hFile) 
            PKITHROW(SignError());
    
        if(!GetFileInformationByHandle(hFile,
                                       &hFileInfo))
            PKITHROW(SignError());
        
        // Test to see if we have a directory or offline
		if(	(hFileInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)	||
			(hFileInfo.dwFileAttributes & FILE_ATTRIBUTE_OFFLINE) )
		{
            PKITHROW(TRUST_E_SUBJECT_FORM_UNKNOWN);
        }
    }
    PKICATCH(err) {
        hr = err.pkiError;
        CloseHandle(hFile);
        hFile = NULL;
    } PKIEND;

    *pFileHandle = hFile;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pki\wincrmsg\wincrmsg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       wincrmsg.cpp
//
//  Contents:   Cryptographic Message APIs
//
//  APIs:
//
//  History:    14-Feb-96   kevinr    created
//
//--------------------------------------------------------------------------

#include "global.hxx"

HCRYPTASN1MODULE  ICM_hAsn1Module;

COssDecodeInfoNode::~COssDecodeInfoNode()
{
    PkiAsn1FreeInfo( ICM_GetDecoder(), m_data.iPDU, m_data.pvPDU);
}

CBlobNode::~CBlobNode()
{
    ICM_Free( m_data.pbData);
}

CSignerNode::~CSignerNode()
{
    ICM_Free( m_data.blob.pbData);
    delete m_data.pUnauthAttrList;
}

CHashNode::~CHashNode()
{
    ICM_Free( m_data.HashBlob.pbData);
    if (m_data.hHash)
        CryptDestroyHash( m_data.hHash);
}

inline
BOOL
ICM_IsAddInnerContentOctetWrapper(
    IN PCRYPT_MSG_INFO  pcmi
    )
{
#ifdef CMS_PKCS7
    return NULL == pcmi->pszInnerContentObjID ||
        (pcmi->dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG);
#else
    return NULL == pcmi->pszInnerContentObjID;
#endif  // CMS_PKCS7
}


DWORD
ICM_GetTaggedBlobCount(
    IN CBlobList *pBlobList,
    IN BYTE bTag
    )
{
    DWORD dwCount = 0;
    CBlobNode *pBlobNode;

    for (pBlobNode=pBlobList->Head(); pBlobNode; pBlobNode=pBlobNode->Next()) {
        if (bTag == *(pBlobNode->Data()->pbData))
            dwCount++;
    }

    return dwCount;
}

// Advances index past other Tags
CBlobNode *
ICM_GetTaggedBlobAndAdvanceIndex(
    IN CBlobList *pBlobList,
    IN BYTE bTag,               // 0 => any
    IN OUT DWORD *pdwIndex
    )
{
    DWORD dwIndex = *pdwIndex;
    CBlobNode *pBlobNode;
    DWORD i;

    for (i=dwIndex, pBlobNode=pBlobList->Head();
            pBlobNode;
            pBlobNode=pBlobNode->Next()) {
        if (bTag && bTag != *(pBlobNode->Data()->pbData)) {
            // Advance index past other tags
            dwIndex++;
        } else {
            if (0 == i)
                break;
            else
                i--;
        }
    }

    *pdwIndex = dwIndex;
    return pBlobNode;
}


ObjectID aoidMessages[] = {
    { 7, {1,2,840,113549,1,7,1}}, // data
    { 7, {1,2,840,113549,1,7,2}}, // signed
    { 7, {1,2,840,113549,1,7,3}}, // enveloped
    { 7, {1,2,840,113549,1,7,4}}, // signed and enveloped
    { 7, {1,2,840,113549,1,7,5}}, // digested
    { 7, {1,2,840,113549,1,7,6}}, // encrypted
    { 7, {1,2,840,113549,1,7,7}}  // dual-signed
};
#define  COUNTOF_aoidMessages  (sizeof(aoidMessages)/sizeof(aoidMessages[0]))

ObjectID oidMessageDigest = { 7, {1,2,840,113549,1,9,4}};

const LPSTR apszObjIdPKCS7[] = {
    szOID_RSA_data              ,
    szOID_RSA_signedData        ,
    szOID_RSA_envelopedData     ,
    szOID_RSA_signEnvData       ,
    szOID_RSA_digestedData      ,
    szOID_RSA_encryptedData
};
const DWORD COUNTOF_apszObjIdPKCS7 = (sizeof(apszObjIdPKCS7)/sizeof(apszObjIdPKCS7[0]));
//#if  COUNTOF_apszObjIdPKCS7 - (sizeof(apszObjIdPKCS7)/sizeof(apszObjIdPKCS7[0]))
//#error COUNTOF_apszObjIdPKCS7 wrong
//#endif

const LPSTR pszObjIdDataType        = szOID_RSA_data;
const LPSTR pszObjIdContentType     = szOID_RSA_contentType;
const LPSTR pszObjIdMessageDigest   = szOID_RSA_messageDigest;


int aiPduNum[] = {
    OctetStringType_PDU,
    SignedData_PDU,
#ifdef CMS_PKCS7
    CmsEnvelopedData_PDU,
#else
    EnvelopedData_PDU,
#endif  // CMS_PKCS7
    SignedAndEnvelopedData_PDU,
    DigestedData_PDU,
    EncryptedData_PDU
};

/*
// Should be able to use aiPduNum, but first entry of aiPduNum
// seems to need to be 0. ????
int aiPduNum2[] = {
    OctetStringType_PDU,
    SignedData_PDU,
#ifdef CMS_PKCS7
    CmsEnvelopedData_PDU,
#else
    EnvelopedData_PDU,
#endif  // CMS_PKCS7
    SignedAndEnvelopedData_PDU,
    DigestedData_PDU,
    EncryptedData_PDU
};
*/

typedef struct _CRYPT_ABLOB {
    DWORD               cBlob;
    PCRYPT_DATA_BLOB    pBlob;
} CRYPT_ABLOB, *PCRYPT_ABLOB;


// Here is a table for keeping straight which phases are legal in which
// situations:
//
//          detached    !detached
//  encode  FO,FF       FF
//  decode  FF,SO,SF    FF
//
enum Phases {
    PHASE_FIRST_ONGOING     = 1,
    PHASE_FIRST_FINAL       = 2,
    PHASE_SECOND_ONGOING    = 3,
    PHASE_SECOND_FINAL      = 4
};


BOOL
WINAPI
ICM_GetAnyData(
    IN Any *pAny,
    OUT void *pvData,
    IN OUT DWORD *pcbData);


WINAPI
ICM_GetOssContentInfoData(
    IN ContentInfo *poci,
    OUT void *pvData,
    IN OUT DWORD *pcbData);

BOOL
WINAPI
ICM_GetSignerParamEncoding(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwIndex,
    IN DWORD            dwParamType,
    OUT PVOID           pvData,
    IN OUT PDWORD       pcbData);

BOOL
WINAPI
ICM_GetALGORITHM_IDENTIFIER(
    IN AlgorithmIdentifier *paiOss,
    OUT void *pvData,
    IN OUT DWORD *pcbData);

//+-------------------------------------------------------------------------
//  Lock and unlock HCRYPTMSG functions
//--------------------------------------------------------------------------
inline
void
ICM_Lock(
    IN PCRYPT_MSG_INFO  pcmi
    )
{
    EnterCriticalSection( &pcmi->CriticalSection);
}
inline
void
ICM_Unlock(
    IN PCRYPT_MSG_INFO  pcmi
    )
{
    LeaveCriticalSection( &pcmi->CriticalSection);
}


//+-------------------------------------------------------------------------
//  allocation and free routines
//--------------------------------------------------------------------------
void *
WINAPI
ICM_Alloc(
    IN size_t cb)
{
    void *pv;
    if (NULL == (pv = malloc(cb)))
        goto mallocError;
ErrorReturn:
    return pv;
SET_ERROR(mallocError,E_OUTOFMEMORY)
}

void *
WINAPI
ICM_AllocZero(
    IN size_t cb)
{
    void *pv;
    // Should map to LocalAlloc( ZERO_INIT).
    if (NULL != (pv = ICM_Alloc(cb)))
        memset( pv, 0, cb);
    return pv;
}

void *
WINAPI
ICM_ReAlloc(
    IN void     *pvOrg,
    IN size_t   cb)
{
    void *pv;
    if (NULL == (pv = pvOrg ? realloc( pvOrg, cb) : malloc( cb)))
        goto allocError;
ErrorReturn:
    return pv;
SET_ERROR(allocError,E_OUTOFMEMORY)
}

void
WINAPI
ICM_Free(
    IN void *pv)
{
    if (pv)
        free(pv);
}

// Stack allocations
// NB: Use heap allocs on DBG so we can more easily catch buffer over-runs, etc.
#if DBG
#define ICM_AllocA      ICM_Alloc
#define ICM_FreeA       ICM_Free
#else
#define ICM_AllocA      ICM_Alloc
#define ICM_FreeA       ICM_Free
// The following defines work fine on NT, but seem to have problems on Win95
// REASON: unknown
//#define ICM_AllocA(s)   alloca(((s)+7))
//#define ICM_FreeA(p)   
#endif

void *
WINAPI
ICM_AllocZeroA(
    IN size_t cbBytes)
{
    void *pv;
    if (NULL != (pv = ICM_AllocA(cbBytes)))
        memset( pv, 0, cbBytes);
    return pv;
}

void *ICM_DupMem(
    IN void     *pvIn,
    IN size_t   cb)
{
    void *pv = NULL;
    if (pvIn) {
        if (NULL != (pv = ICM_Alloc(cb)))
            memcpy( pv, pvIn, cb);
    } else {
        SetLastError((DWORD) E_INVALIDARG);
    }
    return pv;
}

size_t ICM_StrLen(const char *pszIn)
{
    return pszIn ? strlen(pszIn) : 0;
}


BOOL
WINAPI
ICM_AppendBlob(
    PCRYPT_DATA_BLOB    pblob,
    const BYTE          *pbIn,
    DWORD               cbIn)
{
    BOOL        fRet;
    PBYTE       pb = NULL;

    if (NULL == (pb = (PBYTE)ICM_ReAlloc(
                                pblob->pbData,
                                pblob->cbData + cbIn)))
        goto AllocError;
    memcpy( pb + pblob->cbData, pbIn, cbIn);
    pblob->pbData = pb;
    pblob->cbData += cbIn;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(AllocError)
}

#ifdef CMS_PKCS7
STATIC
BOOL
WINAPI
ICM_InsertMsgAlloc(
    IN PCRYPT_MSG_INFO pcmi,
    IN void *pv
    )
{
    BOOL                    fRet;
    CBlobNode               *pnBlob = NULL;
    CRYPT_DATA_BLOB         blob;

    if (NULL == pcmi->pFreeList) {
        if (NULL == (pcmi->pFreeList = new CBlobList))
            goto OutOfMemory;
    }

    if (NULL == (pnBlob = new CBlobNode))
        goto OutOfMemory;

    blob.cbData = 0;
    blob.pbData = (BYTE *) pv;
    pnBlob->SetData(&blob);
    pcmi->pFreeList->InsertTail(pnBlob);

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(OutOfMemory,E_OUTOFMEMORY)
}
#endif  // CMS_PKCS7

// Allocates algorithm parameters and inserts into the message's free
// list before doing the ICM_Asn1ToAlgorithmIdentifier
STATIC
BOOL
WINAPI
ICM_MsgAsn1ToAlgorithmIdentifier(
    IN PCRYPT_MSG_INFO pcmi,
    IN PCRYPT_ALGORITHM_IDENTIFIER pai,
    IN OUT AlgorithmIdentifier *pOssAlgId
    )
{
#ifdef CMS_PKCS7
    CRYPT_ALGORITHM_IDENTIFIER ai;

    if (pcmi && 0 < pai->Parameters.cbData) {
        ai = *pai;
        if (NULL == (ai.Parameters.pbData = (BYTE *) ICM_DupMem(
                ai.Parameters.pbData, ai.Parameters.cbData)))
            return FALSE;
        if (!ICM_InsertMsgAlloc(pcmi, ai.Parameters.pbData)) {
            ICM_Free(ai.Parameters.pbData);
            return FALSE;
        }
        pai = &ai;
    }
#endif  // CMS_PKCS7

    return ICM_Asn1ToAlgorithmIdentifier(pai, pOssAlgId);
}

//+-------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
STATIC BOOL WINAPI
ICM_PkcsSignerInfoEncode(
    IN DWORD                dwCertEncodingType,
    IN LPCSTR               lpszStructType,
    IN PCMSG_SIGNER_INFO    pInfo,
    OUT PBYTE               pbEncoded,
    IN OUT PDWORD           pcbEncoded);

STATIC BOOL WINAPI
ICM_PkcsSignerInfoDecode(
        IN DWORD dwEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCMSG_SIGNER_INFO pInfo,
        IN OUT DWORD *pcbInfo);

STATIC BOOL WINAPI
ICM_CmsSignerInfoEncode(
    IN DWORD                dwCertEncodingType,
    IN LPCSTR               lpszStructType,
    IN PCMSG_CMS_SIGNER_INFO pInfo,
    OUT PBYTE               pbEncoded,
    IN OUT PDWORD           pcbEncoded);

STATIC BOOL WINAPI
ICM_CmsSignerInfoDecode(
        IN DWORD dwEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCMSG_CMS_SIGNER_INFO pInfo,
        IN OUT DWORD *pcbInfo);

#ifdef OSS_CRYPT_ASN1
#define ASN1_OID_OFFSET         10000 +
#define ASN1_OID_PREFIX         "OssCryptAsn1."
#else
#define ASN1_OID_OFFSET
#define ASN1_OID_PREFIX
#endif  // OSS_CRYPT_ASN1

STATIC
const
CRYPT_OID_FUNC_ENTRY
ICM_EncodeFuncTable[] = {
    ASN1_OID_OFFSET PKCS7_SIGNER_INFO, ICM_PkcsSignerInfoEncode,
    ASN1_OID_OFFSET CMS_SIGNER_INFO, ICM_CmsSignerInfoEncode,
};

#define ICM_ENCODE_FUNC_COUNT \
    (sizeof(ICM_EncodeFuncTable) / sizeof(ICM_EncodeFuncTable[0]))

STATIC
const
CRYPT_OID_FUNC_ENTRY
ICM_DecodeFuncTable[] = {
    ASN1_OID_OFFSET PKCS7_SIGNER_INFO, ICM_PkcsSignerInfoDecode,
    ASN1_OID_OFFSET CMS_SIGNER_INFO, ICM_CmsSignerInfoDecode,
};

#define ICM_DECODE_FUNC_COUNT \
    (sizeof(ICM_DecodeFuncTable) / sizeof(ICM_DecodeFuncTable[0]))

#ifdef CMS_PKCS7

static HCRYPTOIDFUNCSET hOldStyleGenEncryptKeyFuncSet;
static HCRYPTOIDFUNCSET hOldStyleExportEncryptKeyFuncSet;
static HCRYPTOIDFUNCSET hOldStyleImportEncryptKeyFuncSet;

static HCRYPTOIDFUNCSET hGenContentEncryptKeyFuncSet;
static HCRYPTOIDFUNCSET hExportKeyTransFuncSet;
static HCRYPTOIDFUNCSET hExportKeyAgreeFuncSet;
static HCRYPTOIDFUNCSET hExportMailListFuncSet;
static HCRYPTOIDFUNCSET hImportKeyTransFuncSet;
static HCRYPTOIDFUNCSET hImportKeyAgreeFuncSet;
static HCRYPTOIDFUNCSET hImportMailListFuncSet;

//+-------------------------------------------------------------------------
//  GenContentEncryptKey OID Installable Functions
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultGenContentEncryptKey(
    IN OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    );
static const CRYPT_OID_FUNC_ENTRY GenContentEncryptKeyFuncTable[] = {
    CMSG_DEFAULT_INSTALLABLE_FUNC_OID, ICM_DefaultGenContentEncryptKey
};

//+-------------------------------------------------------------------------
//  ExportKeyTrans OID Installable Functions
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultExportKeyTrans(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTransEncodeInfo,
    IN OUT PCMSG_KEY_TRANS_ENCRYPT_INFO pKeyTransEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    );
static const CRYPT_OID_FUNC_ENTRY ExportKeyTransFuncTable[] = {
    CMSG_DEFAULT_INSTALLABLE_FUNC_OID, ICM_DefaultExportKeyTrans
};

//+-------------------------------------------------------------------------
//  ExportKeyAgree OID Installable Functions
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultExportKeyAgree(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pKeyAgreeEncodeInfo,
    IN OUT PCMSG_KEY_AGREE_ENCRYPT_INFO pKeyAgreeEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    );
static const CRYPT_OID_FUNC_ENTRY ExportKeyAgreeFuncTable[] = {
    CMSG_DEFAULT_INSTALLABLE_FUNC_OID, ICM_DefaultExportKeyAgree
};

//+-------------------------------------------------------------------------
//  ExportMailList OID Installable Functions
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultExportMailList(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO pMailListEncodeInfo,
    IN OUT PCMSG_MAIL_LIST_ENCRYPT_INFO pMailListEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    );
static const CRYPT_OID_FUNC_ENTRY ExportMailListFuncTable[] = {
    CMSG_DEFAULT_INSTALLABLE_FUNC_OID, ICM_DefaultExportMailList
};

//+-------------------------------------------------------------------------
//  ImportKeyTrans OID Installable Functions
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultImportKeyTrans(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA pKeyTransDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    );
static const CRYPT_OID_FUNC_ENTRY ImportKeyTransFuncTable[] = {
    CMSG_DEFAULT_INSTALLABLE_FUNC_OID, ICM_DefaultImportKeyTrans
};

//+-------------------------------------------------------------------------
//  ImportKeyAgree OID Installable Functions
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultImportKeyAgree(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA pKeyAgreeDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    );
static const CRYPT_OID_FUNC_ENTRY ImportKeyAgreeFuncTable[] = {
    CMSG_DEFAULT_INSTALLABLE_FUNC_OID, ICM_DefaultImportKeyAgree
};

//+-------------------------------------------------------------------------
//  ImportMailList OID Installable Functions
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultImportMailList(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA pMailListDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    );
static const CRYPT_OID_FUNC_ENTRY ImportMailListFuncTable[] = {
    CMSG_DEFAULT_INSTALLABLE_FUNC_OID, ICM_DefaultImportMailList
};

#else

static HCRYPTOIDFUNCSET hGenEncryptKeyFuncSet;
static HCRYPTOIDFUNCSET hExportEncryptKeyFuncSet;
static HCRYPTOIDFUNCSET hImportEncryptKeyFuncSet;

#endif  // CMS_PKCS7

//+-------------------------------------------------------------------------
//  GenEncryptKey OID Installable Functions (OldStyle)
//--------------------------------------------------------------------------

// rgcbEncryptParameters[1] contains the dwEncryptFlags passed to
// ICM_DefaultExportEncryptKey
BOOL
WINAPI
ICM_DefaultGenEncryptKey(
    IN OUT HCRYPTPROV               *phCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PVOID                        pvEncryptAuxInfo,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    IN PFN_CMSG_ALLOC               pfnAlloc,
    OUT HCRYPTKEY                   *phEncryptKey,
    OUT PBYTE                       *ppbEncryptParameters,
    OUT DWORD                       rgcbEncryptParameters[2]);

static const CRYPT_OID_FUNC_ENTRY GenEncryptKeyFuncTable[] = {
    szOID_OIWSEC_desCBC, ICM_DefaultGenEncryptKey,
    szOID_RSA_DES_EDE3_CBC, ICM_DefaultGenEncryptKey,
    szOID_RSA_RC2CBC, ICM_DefaultGenEncryptKey,
    szOID_RSA_RC4, ICM_DefaultGenEncryptKey
};
#define GEN_ENCRYPT_KEY_FUNC_COUNT (sizeof(GenEncryptKeyFuncTable) / \
                                        sizeof(GenEncryptKeyFuncTable[0]))

//+-------------------------------------------------------------------------
//  ExportEncryptKey OID Installable Functions (OldStyle)
//--------------------------------------------------------------------------

// rgcbData[1] is the dwEncryptFlags passed from ICM_DefaultGenEncryptKey
BOOL
WINAPI
ICM_DefaultExportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    OUT PBYTE                       pbData,
    IN OUT DWORD                    rgcbData[2]);

static const CRYPT_OID_FUNC_ENTRY ExportEncryptKeyFuncTable[] = {
    szOID_RSA_RSA, ICM_DefaultExportEncryptKey
};
#define EXPORT_ENCRYPT_KEY_FUNC_COUNT (sizeof(ExportEncryptKeyFuncTable) / \
                                        sizeof(ExportEncryptKeyFuncTable[0]))

//+-------------------------------------------------------------------------
//  ImportEncryptKey OID Installable Functions (OldStyle)
//--------------------------------------------------------------------------

BOOL
WINAPI
ICM_DefaultImportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN DWORD                        dwKeySpec,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiPubKey,
    IN PBYTE                        pbEncodedKey,
    IN DWORD                        cbEncodedKey,
    OUT HCRYPTKEY                   *phEncryptKey);

static const CRYPT_OID_FUNC_ENTRY ImportEncryptKeyFuncTable[] = {
    szOID_OIWSEC_desCBC, ICM_DefaultImportEncryptKey,
    szOID_RSA_DES_EDE3_CBC, ICM_DefaultImportEncryptKey,
    szOID_RSA_RC2CBC, ICM_DefaultImportEncryptKey,
    szOID_RSA_RC4, ICM_DefaultImportEncryptKey
};
#define IMPORT_ENCRYPT_KEY_FUNC_COUNT (sizeof(ImportEncryptKeyFuncTable) / \
                                        sizeof(ImportEncryptKeyFuncTable[0]))

#ifdef DEBUG_CRYPT_ASN1_MASTER
static HMODULE hOssCryptDll = NULL;
#endif  // DEBUG_CRYPT_ASN1_MASTER

#ifdef DEBUG_CRYPT_ASN1

#define DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG              0x010
#define DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG      0x020
#define DEBUG_OSS_CRYPT_ASN1_SAME_ENCRYPT_FLAG      0x100

static BOOL fGotDebugCryptAsn1Flags = FALSE;
static int iDebugCryptAsn1Flags = 0;

int
WINAPI
ICMTest_GetDebugCryptAsn1Flags();

#endif  // DEBUG_CRYPT_ASN1

//+-------------------------------------------------------------------------
//  Function:  CryptMsgDllMain
//
//  Synopsis:  Initialize the CryptMsg module
//
//  Returns:   FALSE iff failed
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptMsgDllMain(
        HMODULE hInst,
        ULONG  ulReason,
        LPVOID lpReserved)
{
    BOOL        fRet;

    switch (ulReason) {
    case DLL_PROCESS_ATTACH:
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_ENCODE_OBJECT_FUNC,
                ICM_ENCODE_FUNC_COUNT,
                ICM_EncodeFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CRYPT_OID_DECODE_OBJECT_FUNC,
                ICM_DECODE_FUNC_COUNT,
                ICM_DecodeFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 

#ifdef CMS_PKCS7
        if (NULL == (hOldStyleGenEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_GEN_ENCRYPT_KEY_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hOldStyleExportEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hOldStyleImportEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (NULL == (hGenContentEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_GEN_CONTENT_ENCRYPT_KEY_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (NULL == (hExportKeyTransFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_EXPORT_KEY_TRANS_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hExportKeyAgreeFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_EXPORT_KEY_AGREE_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hExportMailListFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_EXPORT_MAIL_LIST_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (NULL == (hImportKeyTransFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_IMPORT_KEY_TRANS_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hImportKeyAgreeFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_IMPORT_KEY_AGREE_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hImportMailListFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_IMPORT_MAIL_LIST_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_GEN_CONTENT_ENCRYPT_KEY_FUNC,
                1,
                GenContentEncryptKeyFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_EXPORT_KEY_TRANS_FUNC,
                1,
                ExportKeyTransFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_EXPORT_KEY_AGREE_FUNC,
                1,
                ExportKeyAgreeFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_EXPORT_MAIL_LIST_FUNC,
                1,
                ExportMailListFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_IMPORT_KEY_TRANS_FUNC,
                1,
                ImportKeyTransFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_IMPORT_KEY_AGREE_FUNC,
                1,
                ImportKeyAgreeFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_IMPORT_MAIL_LIST_FUNC,
                1,
                ImportMailListFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 
#else

        if (NULL == (hGenEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_GEN_ENCRYPT_KEY_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hExportEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
        if (NULL == (hImportEncryptKeyFuncSet = CryptInitOIDFunctionSet(
                CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC,
                0)))
            goto CryptInitOIDFunctionSetError;
#endif  // CMS_PKCS7

        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_GEN_ENCRYPT_KEY_FUNC,
                GEN_ENCRYPT_KEY_FUNC_COUNT,
                GenEncryptKeyFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_EXPORT_ENCRYPT_KEY_FUNC,
                EXPORT_ENCRYPT_KEY_FUNC_COUNT,
                ExportEncryptKeyFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 
        if (!CryptInstallOIDFunctionAddress(
                NULL,                       // hModule
                X509_ASN_ENCODING,
                CMSG_OID_IMPORT_ENCRYPT_KEY_FUNC,
                IMPORT_ENCRYPT_KEY_FUNC_COUNT,
                ImportEncryptKeyFuncTable,
                0))                         // dwFlags
            goto CryptInstallOIDFunctionAddressError; 

#ifdef OSS_CRYPT_ASN1
        if (0 == (ICM_hAsn1Module = I_CryptInstallAsn1Module(pkcs, 0, NULL)))
            goto CryptInstallAsn1ModuleError;
#else
        PKCS_Module_Startup();
        if (0 == (ICM_hAsn1Module = I_CryptInstallAsn1Module(
                PKCS_Module, 0, NULL))) {
            PKCS_Module_Cleanup();
            goto CryptInstallAsn1ModuleError;
        }
#endif  // OSS_CRYPT_ASN1

        break;

    case DLL_PROCESS_DETACH:
#ifdef DEBUG_CRYPT_ASN1_MASTER
        if (hOssCryptDll) {
            FreeLibrary(hOssCryptDll);
            hOssCryptDll = NULL;
        }
#endif  // DEBUG_CRYPT_ASN1_MASTER
        I_CryptUninstallAsn1Module(ICM_hAsn1Module);
#ifndef OSS_CRYPT_ASN1
        PKCS_Module_Cleanup();
#endif  // OSS_CRYPT_ASN1
    case DLL_THREAD_DETACH:
    default:
        break;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CryptInstallAsn1ModuleError)
TRACE_ERROR(CryptInstallOIDFunctionAddressError)
TRACE_ERROR(CryptInitOIDFunctionSetError)
lpReserved;
hInst;
}

//+-------------------------------------------------------------------------
//  Utility routines
//--------------------------------------------------------------------------
LONG
WINAPI
ICM_PszOidToIndex(
    IN LPSTR pszOID)
{
    LONG    i;

    for (i=COUNTOF_apszObjIdPKCS7; i>0; i--)
        if (0 == strcmp( apszObjIdPKCS7[i-1], pszOID))
            break;

    return i;
}


LONG
WINAPI
ICM_ObjIdToIndex(
    IN ObjectID *poi)
{
    LONG    i;
    LONG    j;

    for (i=COUNTOF_aoidMessages; i>0; i--) {
        if (aoidMessages[i-1].count == poi->count) {
            for (j=poi->count; j>0; j--)
                if (poi->value[j-1] != aoidMessages[i-1].value[j-1])
                    goto next;
            break;
        }
        next:
        ;
    }

    return i;
}


BOOL
WINAPI
ICM_CopyOssObjectIdentifier(
    OUT ObjectID    *poiDst,
    IN  ObjectID    *poiSrc)
{
    USHORT  i;
    ULONG   *pulDst;
    ULONG   *pulSrc;

    poiDst->count = poiSrc->count;
    for (i=poiSrc->count, pulDst=poiDst->value, pulSrc=poiSrc->value;
            i>0;
            i--, pulDst++, pulSrc++)
        *pulDst = *pulSrc;

    return TRUE;
}


BOOL
WINAPI
ICM_IsData(
    IN  LPSTR   pszContentType)
{
    return !pszContentType || (0 == strcmp( pszContentType, pszObjIdDataType));
}


BOOL
WINAPI
ICM_ReverseInPlace(
    IN OUT PBYTE    pbIn,
    IN const ULONG  cbIn)
{
    PBYTE   pbLo;
    PBYTE   pbHi;
    BYTE    bTmp;

    for (pbLo = pbIn, pbHi = pbIn + cbIn - 1; pbLo < pbHi; pbHi--, pbLo++) {
        bTmp = *pbHi;
        *pbHi = *pbLo;
        *pbLo = bTmp;
    }

    return TRUE;
}


BOOL
WINAPI
ICM_ReverseCopy(
    OUT PBYTE   pbOut,
    IN PBYTE    pbInOrg,
    IN ULONG    cbIn)
{
    PBYTE   pbIn = pbInOrg + cbIn - 1;

    while (cbIn-- > 0)
        *pbOut++ = *pbIn--;

    return TRUE;
}


//
// return FALSE iff equal
//
BOOL
WINAPI
ICM_ReverseCompare(
    IN PBYTE    pbInOrg1,
    IN PBYTE    pbInOrg2,
    IN ULONG    cb)
{
    PBYTE   pbIn1 = pbInOrg1;
    PBYTE   pbIn2 = pbInOrg2 + cb - 1;

    while (cb-- > 0)
        if (*pbIn1++ != *pbIn2--)
            return TRUE;

    return FALSE;
}


BOOL
WINAPI
ICM_CopyOut(
    IN PBYTE        pbData,
    IN DWORD        cbData,
    OUT PBYTE       pbOut,
    IN OUT PDWORD   pcbOut)
{
    BOOL            fRet = TRUE;

    if (pbOut) {
        if (*pcbOut < cbData) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fRet = FALSE;
        } else {
            memcpy(pbOut, pbData, cbData);
        }
    }
    *pcbOut = cbData;

    return fRet;
}


//+-------------------------------------------------------------------------
//  Copy out the encoding of the length octets for a specified content length.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetLengthOctets(
    IN DWORD            cbContent,
    OUT OPTIONAL PBYTE  pbOut,
    IN OUT PDWORD       pcbOut)
{
    BOOL            fRet;
    BYTE            rgbLength[5];
    DWORD           cbLength;

    if (cbContent < 0x80) {
        rgbLength[0] = (BYTE)cbContent;
        cbLength = 0;
    } else {
        if (cbContent > 0xffffff)
            cbLength = 4;
        else if (cbContent > 0xffff)
            cbLength = 3;
        else if (cbContent > 0xff)
            cbLength = 2;
        else
            cbLength = 1;
        if (pbOut) {
            rgbLength[0] = (BYTE)cbLength | 0x80;
            ICM_ReverseCopy( (PBYTE)(rgbLength+1), (PBYTE)&cbContent, cbLength);
        }
    }

    if (pbOut) {
        fRet = ICM_CopyOut( (PBYTE)rgbLength, cbLength+1, pbOut, pcbOut);
    } else {
        fRet = TRUE;
    }
    *pcbOut = cbLength + 1;

    assert(fRet);
    return fRet;
}


//+-------------------------------------------------------------------------
//  Copy out a buffer, prepending the identifier and length octets for a
//  DER encoding.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_CopyOutAddDERPrefix(
    IN PBYTE            pbContent,
    IN DWORD            cbContent,
    IN OPTIONAL BYTE    bTag,
    OUT PBYTE           pbOut,
    IN OUT PDWORD       pcbOut)
{
    BOOL            fRet;
    BYTE            rgbLength[5];
    DWORD           cbLength;
    DWORD           cbData;

    cbLength = sizeof(rgbLength);
    if (!ICM_GetLengthOctets( cbContent, (PBYTE)rgbLength, &cbLength))
        goto GetLengthOctetsError;

    fRet = TRUE;
    cbData = 1 + cbLength + cbContent;
    if (pbOut) {
        if (*pcbOut < cbData) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fRet = FALSE;
        } else {
            *pbOut++ = bTag;
            memcpy(pbOut, rgbLength, cbLength);
            pbOut += cbLength;
            memcpy(pbOut, pbContent, cbContent);
        }
    }

CommonReturn:
    *pcbOut = cbData;
    return fRet;

ErrorReturn:
    cbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetLengthOctetsError)    // error already set
}


BOOL
WINAPI
ICM_GetSizeFromExtra(
    IN LONG         lRemainExtra,
    OUT PVOID       pOut,
    IN OUT DWORD    *pcbOut)
{
    BOOL            fRet = TRUE;

    if ((lRemainExtra < 0) && pOut) {
        SetLastError((DWORD) ERROR_MORE_DATA);
        fRet = FALSE;
    }
    *pcbOut = (DWORD)((LONG)*pcbOut - lRemainExtra);

    return fRet;
}


VOID
WINAPI
ICM_SetLastError(
    IN DWORD    dwError)
{
    if (dwError != ERROR_SUCCESS)
        SetLastError( dwError);
}


//+-------------------------------------------------------------------------
//  Encode an OSS struct to a blob, internally allocated
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_Asn1Encode(
    ASN1uint32_t            pdunum,
    IN PVOID                pOssInfo,
    OUT PCRYPT_DATA_BLOB    pBlob)
{
    BOOL            fRet;
    PBYTE           pbEncoded = NULL;
    DWORD           cbEncoded;
    ASN1encoding_t  pEnc = ICM_GetEncoder();
    DWORD           dwError = ERROR_SUCCESS;

    if (!PkiAsn1EncodeInfo(
            pEnc,
            pdunum,
            pOssInfo,
            NULL,           // pbEncoded
            &cbEncoded))
        goto EncodeSizeError;
    if (NULL == (pbEncoded = (PBYTE)ICM_Alloc( cbEncoded)))
        goto AllocError;
    if (!PkiAsn1EncodeInfo(
            pEnc,
            pdunum,
            pOssInfo,
            pbEncoded,
            &cbEncoded))
        goto EncodeError;

    fRet = TRUE;
CommonReturn:
    pBlob->pbData = pbEncoded;
    pBlob->cbData = cbEncoded;
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free(pbEncoded);
    pbEncoded = NULL;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EncodeSizeError)    // error already set
TRACE_ERROR(AllocError)         // error already set
TRACE_ERROR(EncodeError)        // error already set
}

//+-------------------------------------------------------------------------
//  Given an OID, return the CAPI algorithm
//
//  Caller sets error.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetCAPIFromOID(
    IN DWORD                        dwGroupId,
    IN LPSTR                        pszObjId,
    OUT PDWORD                      pdwAlgId)
{
    BOOL            fRet;
    PCCRYPT_OID_INFO pOIDInfo;

    if (NULL == (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            pszObjId,
            dwGroupId))) goto NotFoundError;
    *pdwAlgId = pOIDInfo->Algid;
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    *pdwAlgId = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(NotFoundError)
}

//+-------------------------------------------------------------------------
//  Given an CRYPT_ALGORITHM_IDENTIFIER, return the CAPI algorithm
//
//  Caller sets error.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetCAPI(
    IN DWORD                        dwGroupId,
    IN PCRYPT_ALGORITHM_IDENTIFIER  pai,
    OUT PDWORD                      pdwAlgId)
{
    return ICM_GetCAPIFromOID(dwGroupId, pai->pszObjId, pdwAlgId);
}

//+-------------------------------------------------------------------------
//  Given an OSS AlgorithmIdentifier, return the OID Info
//
//  Caller sets error.
//--------------------------------------------------------------------------
PCCRYPT_OID_INFO
WINAPI
ICM_GetOssOIDInfo(
    IN DWORD                    dwGroupId,
    IN AlgorithmIdentifier      *poai)
{
    PCCRYPT_OID_INFO            pInfo;
    CRYPT_ALGORITHM_IDENTIFIER  ai;   ZEROSTRUCT( ai);

    if (!ICM_Asn1FromAlgorithmIdentifier( poai, &ai))
        goto Asn1FromAlgorithmIdentifierError;

    pInfo = CryptFindOIDInfo(
        CRYPT_OID_INFO_OID_KEY,
        ai.pszObjId,
        dwGroupId);
CommonReturn:
    ICM_Free( ai.pszObjId);
    return pInfo;

ErrorReturn:
    pInfo = NULL;
    goto CommonReturn;
TRACE_ERROR(Asn1FromAlgorithmIdentifierError)
}


//+-------------------------------------------------------------------------
//  Given an OSS AlgorithmIdentifier, return the CAPI algorithm
//
//  Caller sets error.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssCAPI(
    IN DWORD                    dwGroupId,
    IN AlgorithmIdentifier      *poai,
    OUT PDWORD                  pdwAlgId)
{
    BOOL                        fRet;
    CRYPT_ALGORITHM_IDENTIFIER  ai;   ZEROSTRUCT( ai);

    if (!ICM_Asn1FromAlgorithmIdentifier( poai, &ai))
        goto Asn1FromAlgorithmIdentifierError;

    fRet = ICM_GetCAPI( dwGroupId, &ai, pdwAlgId);
CommonReturn:
    ICM_Free( ai.pszObjId);
    return fRet;

ErrorReturn:
    *pdwAlgId = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(Asn1FromAlgorithmIdentifierError)
}

//+-------------------------------------------------------------------------
//  Allocate and NOCOPY decode
//--------------------------------------------------------------------------
PVOID
WINAPI
ICM_AllocAndDecodeObject(
    IN LPCSTR lpszStructType,
    IN const BYTE *pbEncoded,
    IN DWORD cbEncoded
    )
{
    void *pvStructInfo = NULL;
    DWORD cbStructInfo;
    
    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG,
            NULL,                   // pvStructInfo
            &cbStructInfo
            ) || 0 == cbStructInfo)
        goto DecodeError;
    if (NULL == (pvStructInfo = ICM_Alloc(cbStructInfo)))
        goto OutOfMemory;
    if (!CryptDecodeObject(
            X509_ASN_ENCODING,
            lpszStructType,
            pbEncoded,
            cbEncoded,
            CRYPT_DECODE_NOCOPY_FLAG,
            pvStructInfo,
            &cbStructInfo
            ))
        goto DecodeError;

CommonReturn:
    return pvStructInfo;
ErrorReturn:
    ICM_Free(pvStructInfo);
    pvStructInfo = NULL;
    goto CommonReturn;
TRACE_ERROR(DecodeError)
TRACE_ERROR(OutOfMemory)
}

PCRYPT_ALGORITHM_IDENTIFIER
WINAPI
ICM_AllocAndGetALGORITHM_IDENTIFIER(
    IN AlgorithmIdentifier *paiOss)
{
    PCRYPT_ALGORITHM_IDENTIFIER pai = NULL;
    DWORD cbData;

    if (!ICM_GetALGORITHM_IDENTIFIER(
            paiOss,
            NULL,               // pvData
            &cbData) || 0 == cbData)
        goto GetAlgorithmError;
    if (NULL == (pai = (PCRYPT_ALGORITHM_IDENTIFIER)ICM_Alloc(cbData)))
        goto OutOfMemory;;
    if (!ICM_GetALGORITHM_IDENTIFIER(
            paiOss,
            pai,
            &cbData))
        goto GetAlgorithmError;

CommonReturn:
    return pai;
ErrorReturn:
    ICM_Free(pai);
    pai = NULL;
    goto CommonReturn;
TRACE_ERROR(GetAlgorithmError);
TRACE_ERROR(OutOfMemory)

}

#ifdef CMS_PKCS7

void *
WINAPI
ICM_AllocAndGetParam(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT OPTIONAL DWORD *pcbData = NULL
    )
{
    void *pvData = NULL;
    DWORD cbData;

    if (!CryptMsgGetParam(
            (HCRYPTMSG) pcmi,
            dwParamType,
            dwIndex,
            NULL,                   // pvData
            &cbData))
        goto CryptMsgGetParamError;
    if (0 == cbData)
        goto NoParamData;
    if (NULL == (pvData = ICM_Alloc(cbData)))
        goto OutOfMemory;
    if (!CryptMsgGetParam(
            (HCRYPTMSG) pcmi,
            dwParamType,
            dwIndex,
            pvData,
            &cbData))
        goto CryptMsgGetParamError;

CommonReturn:
    if (pcbData)
        *pcbData = cbData;
    return pvData;
ErrorReturn:
    if (pvData) {
        ICM_Free(pvData);
        pvData = NULL;
    }
    cbData = 0;
    goto CommonReturn;
TRACE_ERROR(CryptMsgGetParamError)
TRACE_ERROR(OutOfMemory)
SET_ERROR(NoParamData, CRYPT_E_INVALID_MSG_TYPE)
}

#endif  // CMS_PKCS7

BOOL
WINAPI
ICM_RC2VersionToBitLength(
    IN DWORD        dwVersion,
    OUT PDWORD      pdwBitLen
    )
{
    BOOL fRet;
    DWORD dwBitLen;

    switch (dwVersion) {
        case CRYPT_RC2_40BIT_VERSION:
            dwBitLen = 40;
            break;
        case CRYPT_RC2_56BIT_VERSION:
            dwBitLen = 56;
            break;
        case CRYPT_RC2_64BIT_VERSION:
            dwBitLen = 64;
            break;
        case CRYPT_RC2_128BIT_VERSION:
            dwBitLen = 128;
            break;
        default:
            goto InvalidRC2VersionError;
    }

    fRet = TRUE;
CommonReturn:
    *pdwBitLen = dwBitLen;
    return fRet;

ErrorReturn:
    dwBitLen = 0;
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidRC2VersionError, CRYPT_E_BAD_ENCODE)
}

BOOL
WINAPI
ICM_BitLengthToRC2Version(
    IN DWORD        dwBitLen,
    OUT PDWORD      pdwVersion
    )
{
    BOOL fRet;
    DWORD dwVersion;

    switch (dwBitLen) {
        case 40:
            dwVersion = CRYPT_RC2_40BIT_VERSION;
            break;
        case 56:
            dwVersion = CRYPT_RC2_56BIT_VERSION;
            break;
        case 64:
            dwVersion = CRYPT_RC2_64BIT_VERSION;
            break;
        case 128:
            dwVersion = CRYPT_RC2_128BIT_VERSION;
            break;
        default:
            goto InvalidArg;
    }

    fRet = TRUE;
CommonReturn:
    *pdwVersion = dwVersion;
    return fRet;

ErrorReturn:
    dwVersion = 0xFFFFFFFF;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg, E_INVALIDARG)
}

#define IV_LENGTH                   8

// For RC4, the maximum salt length, (128 - 40)/8 = 11.
#define IV_MAX_LENGTH               11

#define AUX_INFO_BIT_LENGTH_MASK    0xFFFF

//+-------------------------------------------------------------------------
//  Get the CAPI ALG_ID corresponding to the encryption OID. If the
//  ASN.1 encryption algorithm has any parameters, decode to get IV and
//  key bit length.
//
//  Note, for RC4, the IV is its salt.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetEncryptParameters(
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    OUT PDWORD                      pdwAlgIdEncrypt,
    OUT PDWORD                      pdwBitLen,          // 0 => default length
    OUT BYTE                        rgbIV[IV_MAX_LENGTH],
    OUT PDWORD                      pcbIV
    )
{
    BOOL fRet;
    PCRYPT_DATA_BLOB pIVBlob = NULL;
    PCRYPT_RC2_CBC_PARAMETERS pRC2Para = NULL;

    *pdwBitLen = 0;
    *pcbIV = 0;

    if (!ICM_GetCAPI(
            CRYPT_ENCRYPT_ALG_OID_GROUP_ID,
            paiEncrypt,
            pdwAlgIdEncrypt))
        goto GetCAPIError;

    // Check if more than just the NULL parameters
    if (2 < paiEncrypt->Parameters.cbData) {
        PBYTE pbIV = NULL;
        DWORD cbIV = 0;
        PBYTE pbEncoded = paiEncrypt->Parameters.pbData;
        DWORD cbEncoded = paiEncrypt->Parameters.cbData;

        if (CALG_RC2 == *pdwAlgIdEncrypt) {
            // Try to decode as RC2_CBC parameters
            if (pRC2Para =
                    (PCRYPT_RC2_CBC_PARAMETERS) ICM_AllocAndDecodeObject(
                        PKCS_RC2_CBC_PARAMETERS,
                        pbEncoded,
                        cbEncoded)) {
                if (!ICM_RC2VersionToBitLength(pRC2Para->dwVersion, pdwBitLen))
                    goto RC2VersionToBitLengthError;
                if (pRC2Para->fIV) {
                    pbIV = pRC2Para->rgbIV;
                    cbIV = sizeof(pRC2Para->rgbIV);
                }
            }
        }

        if (NULL == pRC2Para) {
            // Try to decode as an OctetString containing the IV or the
            // salt for RC4
            if (pIVBlob = (PCRYPT_DATA_BLOB) ICM_AllocAndDecodeObject(
                    X509_OCTET_STRING,
                    pbEncoded,
                    cbEncoded)) {
                pbIV = pIVBlob->pbData;
                cbIV = pIVBlob->cbData;
            } else
                goto DecodeError;
        }

        if (0 != cbIV) {
            if (IV_LENGTH != cbIV &&
                    (CALG_RC4 != *pdwAlgIdEncrypt ||
                        IV_MAX_LENGTH < cbIV))
                goto InvalidIVLengthError;
            memcpy(rgbIV, pbIV, cbIV);
            *pcbIV = cbIV;
        }
    }
    fRet = TRUE;
CommonReturn:
    ICM_Free(pIVBlob);
    ICM_Free(pRC2Para);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(GetCAPIError, CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(DecodeError)
TRACE_ERROR(RC2VersionToBitLengthError)
SET_ERROR(InvalidIVLengthError, CRYPT_E_BAD_ENCODE)
}

#ifdef CMS_PKCS7

//+-------------------------------------------------------------------------
//  Get the CAPI ALG_ID corresponding to the encryption OID. Generate
//  default parameters for and encode. For RC2, encode as RC2_CBC parameters.
//  For all others encode as an IV octet string. The IV is initialized by
//  calling CryptGenRandom. For RC4, the IV is really its salt.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_CreateDefaultEncryptParameters(
    IN OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    OUT PDWORD pdwAlgIdEncrypt,
    OUT PDWORD pdwBitLen,          // 0 => default length
    OUT BYTE rgbIV[IV_MAX_LENGTH],
    OUT PDWORD pcbIV
    )
{
    BOOL fRet;
    HCRYPTPROV hCryptProv;      // doesn't need to be released
    CRYPT_RC2_CBC_PARAMETERS RC2Para;
    CRYPT_DATA_BLOB IVPara;
    void *pvPara;
    LPCSTR pszStructType;
    PCRYPT_ALGORITHM_IDENTIFIER paiEncrypt =
        &pContentEncryptInfo->ContentEncryptionAlgorithm;
    DWORD dwBitLen = 0;
    DWORD cbIV = IV_LENGTH;

    CRYPT_ENCODE_PARA EncodePara;

    // Get provider to use for generating the random IV or RC4 salt
    hCryptProv = I_CryptGetDefaultCryptProv(0);
    if (0 == hCryptProv)
        goto GetDefaultCryptProvError;

    if (!ICM_GetCAPI(
            CRYPT_ENCRYPT_ALG_OID_GROUP_ID,
            paiEncrypt,
            pdwAlgIdEncrypt))
        goto GetCAPIError;


    if (CALG_RC2 == *pdwAlgIdEncrypt) {
        PCMSG_RC2_AUX_INFO pAuxInfo =
            (PCMSG_RC2_AUX_INFO) pContentEncryptInfo->pvEncryptionAuxInfo;

        if (pAuxInfo && pAuxInfo->cbSize >= sizeof(CMSG_RC2_AUX_INFO)) {
            dwBitLen = pAuxInfo->dwBitLen & AUX_INFO_BIT_LENGTH_MASK;
            if (!ICM_BitLengthToRC2Version(dwBitLen, &RC2Para.dwVersion))
                goto BitLengthToRC2VersionError;
        } else {
            // Default to 40 bits;
            dwBitLen = 40;
            RC2Para.dwVersion = CRYPT_RC2_40BIT_VERSION;
        }

        // Generate the random IV.
        if (!CryptGenRandom(hCryptProv, IV_LENGTH, rgbIV))
            goto GenRandomError;

        // Encode as RC2_CBC parameters
        RC2Para.fIV = TRUE;
        assert(sizeof(RC2Para.rgbIV) == IV_LENGTH);
        memcpy(RC2Para.rgbIV, rgbIV, sizeof(RC2Para.rgbIV));

        pvPara = &RC2Para;
        pszStructType = PKCS_RC2_CBC_PARAMETERS;
    } else {
        if (CALG_RC4 == *pdwAlgIdEncrypt) {
            // For RC4, the IV is really the RC4 salt. There are
            // (128 - dwBitLen)/8 bytes of RC4 salt.

            PCMSG_RC4_AUX_INFO pAuxInfo =
                (PCMSG_RC4_AUX_INFO) pContentEncryptInfo->pvEncryptionAuxInfo;

            // Default to no salt
            cbIV = 0;

            if (pAuxInfo && pAuxInfo->cbSize >= sizeof(CMSG_RC4_AUX_INFO)) {
                dwBitLen = pAuxInfo->dwBitLen & AUX_INFO_BIT_LENGTH_MASK;
                if (0 == (pAuxInfo->dwBitLen & CMSG_RC4_NO_SALT_FLAG) &&
                        128 > dwBitLen) {
                    cbIV = (128 - dwBitLen)/ 8;
                    if (IV_MAX_LENGTH < cbIV)
                        cbIV = IV_MAX_LENGTH;
                }
            }

            if (0 == cbIV)
                // No salt
                goto SuccessReturn;
        }

        // Generate the random IV or RC4 salt
        assert(0 < cbIV && IV_MAX_LENGTH >= cbIV);
        if (!CryptGenRandom(hCryptProv, cbIV, rgbIV))
            goto GenRandomError;

        IVPara.pbData = rgbIV;
        IVPara.cbData = cbIV;
        pvPara = &IVPara;
        pszStructType = X509_OCTET_STRING;
    }


    ZEROSTRUCT(EncodePara);
    EncodePara.cbSize = sizeof(EncodePara);
    EncodePara.pfnAlloc = pContentEncryptInfo->pfnAlloc;
    EncodePara.pfnFree = pContentEncryptInfo->pfnFree;
    if (!CryptEncodeObjectEx(
            X509_ASN_ENCODING,
            pszStructType,
            pvPara,
            CRYPT_ENCODE_ALLOC_FLAG,
            &EncodePara,
            (void *) &paiEncrypt->Parameters.pbData,
            &paiEncrypt->Parameters.cbData
            )) goto EncodeError;
    pContentEncryptInfo->dwFlags |= CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    *pdwBitLen = dwBitLen;
    *pcbIV = cbIV;
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetDefaultCryptProvError)
SET_ERROR(GetCAPIError, CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(BitLengthToRC2VersionError)
TRACE_ERROR(GenRandomError)
TRACE_ERROR(EncodeError)
}


BOOL
WINAPI
ICM_IsSP3CompatibleEncrypt(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo
    )
{
    void *pvEncryptAuxInfo = pContentEncryptInfo->pvEncryptionAuxInfo;
    BOOL fSP3CompatibleEncrypt = FALSE;

    if (pvEncryptAuxInfo) {
        PCMSG_SP3_COMPATIBLE_AUX_INFO pSP3AuxInfo =
            (PCMSG_SP3_COMPATIBLE_AUX_INFO) pvEncryptAuxInfo;
        if (sizeof(CMSG_SP3_COMPATIBLE_AUX_INFO) <= pSP3AuxInfo->cbSize &&
                (pSP3AuxInfo->dwFlags & CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG)) {
            fSP3CompatibleEncrypt = TRUE;
        }
    }

    return fSP3CompatibleEncrypt;
}

//+-------------------------------------------------------------------------
//  Default generation of the encryption key using the ASN.1 Encryption
//  algorithm OID and optional parameters.
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1
ICMTest_DefaultGenContentEncryptKey(
#else
ICM_DefaultGenContentEncryptKey(
#endif
    IN OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fRet;
    PCRYPT_ALGORITHM_IDENTIFIER paiEncrypt =
        &pContentEncryptInfo->ContentEncryptionAlgorithm;
    DWORD dwAlgIdEncrypt;
    BYTE rgbIV[IV_MAX_LENGTH];
    DWORD cbIV;
    DWORD dwBitLen;
    HCRYPTPROV hCryptProv;
    DWORD dwGenFlags;

    BOOL fSP3CompatibleEncrypt;

    fSP3CompatibleEncrypt = ICM_IsSP3CompatibleEncrypt(pContentEncryptInfo);
    if (fSP3CompatibleEncrypt) {
        cbIV = 0;
        dwBitLen = 0;

        if (!ICM_GetCAPI(
                CRYPT_ENCRYPT_ALG_OID_GROUP_ID,
                paiEncrypt,
                &dwAlgIdEncrypt))
            goto GetCAPIError;

    } else if (0 == paiEncrypt->Parameters.cbData) {
        if (!ICM_CreateDefaultEncryptParameters(
                pContentEncryptInfo,
                &dwAlgIdEncrypt,
                &dwBitLen,
                rgbIV,
                &cbIV))
            goto CreateDefaultEncryptParametersError;
    } else {
        if (!ICM_GetEncryptParameters(
                paiEncrypt,
                &dwAlgIdEncrypt,
                &dwBitLen,
                rgbIV,
                &cbIV))
            goto GetEncryptParametersError;
    }

    hCryptProv = pContentEncryptInfo->hCryptProv;
    if (0 == hCryptProv) {
        DWORD dwAlgIdPubKey = 0;

        if (0 < pContentEncryptInfo->cRecipients) {
            PCMSG_RECIPIENT_ENCODE_INFO prei;
            PCRYPT_ALGORITHM_IDENTIFIER paiPubKey;

            // Get pointer to public key algorithm associated with the first
            // recipient
            prei = &pContentEncryptInfo->rgCmsRecipients[0];
            switch (prei->dwRecipientChoice) {
                case CMSG_KEY_TRANS_RECIPIENT:
                    paiPubKey = &prei->pKeyTrans->KeyEncryptionAlgorithm;
                    break;
                case CMSG_KEY_AGREE_RECIPIENT:
                    paiPubKey = &prei->pKeyAgree->KeyEncryptionAlgorithm;
                    break;
                case CMSG_MAIL_LIST_RECIPIENT:
                default:
                    paiPubKey = NULL;
            }

            if (paiPubKey)
                ICM_GetCAPI(
                    CRYPT_PUBKEY_ALG_OID_GROUP_ID,
                    paiPubKey,
                    &dwAlgIdPubKey);
        }

        hCryptProv = I_CryptGetDefaultCryptProvForEncrypt(
            dwAlgIdPubKey, dwAlgIdEncrypt, dwBitLen);
        if (0 == hCryptProv)
            goto GetDefaultCryptProvError;
        else
            pContentEncryptInfo->hCryptProv = hCryptProv;
    }

    if (fSP3CompatibleEncrypt)
        dwGenFlags = CRYPT_EXPORTABLE;
    else
        dwGenFlags = CRYPT_EXPORTABLE | CRYPT_NO_SALT;
    dwGenFlags |= dwBitLen << 16;

    fRet = CryptGenKey(
            hCryptProv,
            dwAlgIdEncrypt,
            dwGenFlags,
            &pContentEncryptInfo->hContentEncryptKey);

    if (!fRet) {
        // Only need to provide backwards compatibility for
        // key transport recipients
        if (0 < pContentEncryptInfo->cRecipients) {
            PCMSG_RECIPIENT_ENCODE_INFO prei;

            prei = &pContentEncryptInfo->rgCmsRecipients[0];
            if (CMSG_KEY_TRANS_RECIPIENT != prei->dwRecipientChoice)
                goto GenKeyError;
        }

        if (dwBitLen) {
            // Try without setting key length
            dwGenFlags &= 0xFFFF;
            fRet = CryptGenKey(
                    hCryptProv,
                    dwAlgIdEncrypt,
                    dwGenFlags,
                    &pContentEncryptInfo->hContentEncryptKey);
        }

        if (!fRet && NTE_BAD_FLAGS == GetLastError())
            // Previous versions didn't support CRYPT_NO_SALT flag
            fRet = CryptGenKey(
                    hCryptProv,
                    dwAlgIdEncrypt,
                    CRYPT_EXPORTABLE,       // dwFlags
                    &pContentEncryptInfo->hContentEncryptKey);
        if (!fRet) {
            pContentEncryptInfo->hContentEncryptKey = 0;
            goto GenKeyError;
        }
    }

    if (CALG_RC2 == dwAlgIdEncrypt && 0 != dwBitLen)
        // Silently ignore any errors. Not supported in earlier versions
        CryptSetKeyParam(
            pContentEncryptInfo->hContentEncryptKey,
            KP_EFFECTIVE_KEYLEN,
            (PBYTE) &dwBitLen,
            0);                 // dwFlags

    if (0 != cbIV) {
        if (CALG_RC4 == dwAlgIdEncrypt) {
            // For RC4, set the SALT, not the IV

            CRYPT_DATA_BLOB SaltBlob;
            SaltBlob.pbData = rgbIV;
            SaltBlob.cbData = cbIV;

            if (!CryptSetKeyParam(
                    pContentEncryptInfo->hContentEncryptKey,
                    KP_SALT_EX,
                    (PBYTE) &SaltBlob,
                    0))                 // dwFlags
                goto SetSaltExError;
        } else {
            if (!CryptSetKeyParam(
                    pContentEncryptInfo->hContentEncryptKey,
                    KP_IV,
                    rgbIV,
                    0))                 // dwFlags
                goto SetIVError;
        }
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(GetCAPIError, CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(CreateDefaultEncryptParametersError)
TRACE_ERROR(GetEncryptParametersError)
TRACE_ERROR(GetDefaultCryptProvError)
TRACE_ERROR(GenKeyError)
TRACE_ERROR(SetSaltExError)
TRACE_ERROR(SetIVError)
}


BOOL
WINAPI
ICM_GenContentEncryptKey(
    IN OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo
    )
{
    BOOL fRet;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr = NULL;

    LPCSTR pszContentEncryptOID =
        pContentEncryptInfo->ContentEncryptionAlgorithm.pszObjId;

    if (CryptGetOIDFunctionAddress(
            hGenContentEncryptKeyFuncSet,
            X509_ASN_ENCODING,
            pszContentEncryptOID,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fRet = ((PFN_CMSG_GEN_CONTENT_ENCRYPT_KEY) pvFuncAddr)(
            pContentEncryptInfo,
            0,                      // dwFlags
            NULL                    // pvReserved
            );
    } else {
        if (pContentEncryptInfo->cRecipients
                        &&
                CMSG_KEY_TRANS_RECIPIENT ==
                    pContentEncryptInfo->rgCmsRecipients[0].dwRecipientChoice
                        &&
                CryptGetOIDFunctionAddress(
                    hOldStyleGenEncryptKeyFuncSet,
                    X509_ASN_ENCODING,
                    pszContentEncryptOID,
                    0,                      // dwFlags
                    &pvFuncAddr,
                    &hFuncAddr)
                        &&
#ifdef DEBUG_CRYPT_ASN1
                0 == (ICMTest_GetDebugCryptAsn1Flags() &
                            DEBUG_OSS_CRYPT_ASN1_SAME_ENCRYPT_FLAG)
                        &&
#endif // DEBUG_CRYPT_ASN1
                (void *) ICM_DefaultGenEncryptKey != pvFuncAddr) {
            PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTrans =
                pContentEncryptInfo->rgCmsRecipients[0].pKeyTrans;
            CERT_PUBLIC_KEY_INFO PublicKeyInfo;
            PBYTE pbEncryptParameters = NULL;
            DWORD rgcbEncryptParameters[2] = {0, 0};

            PublicKeyInfo.Algorithm = pKeyTrans->KeyEncryptionAlgorithm;
            PublicKeyInfo.PublicKey = pKeyTrans->RecipientPublicKey;

            fRet = ((PFN_CMSG_GEN_ENCRYPT_KEY) pvFuncAddr)(
                &pContentEncryptInfo->hCryptProv,
                &pContentEncryptInfo->ContentEncryptionAlgorithm,
                pContentEncryptInfo->pvEncryptionAuxInfo,
                &PublicKeyInfo,
                pContentEncryptInfo->pfnAlloc,
                &pContentEncryptInfo->hContentEncryptKey,
                &pbEncryptParameters,
                rgcbEncryptParameters);
            if (pbEncryptParameters) {
                pContentEncryptInfo->ContentEncryptionAlgorithm.Parameters.pbData =
                    pbEncryptParameters;
                pContentEncryptInfo->ContentEncryptionAlgorithm.Parameters.cbData =
                    rgcbEncryptParameters[0];
                pContentEncryptInfo->dwFlags |=
                    CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG;
            }
        } else {
            fRet = ICM_DefaultGenContentEncryptKey(
                pContentEncryptInfo,
                0,                      // dwFlags
                NULL                    // pvReserved
                );
        }
    }

    if (hFuncAddr)
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    return fRet;
}

//+-------------------------------------------------------------------------
//  Default generation of the encryption key using the ASN.1 Encryption
//  algorithm OID and optional parameters.
//
//  rgcbEncryptParameters[1] is the dwEncryptFlags passed to
//  ICM_DefaultExportEncryptKey
//
//  OldStyle.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultGenEncryptKey(
    IN OUT HCRYPTPROV               *phCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PVOID                        pvEncryptAuxInfo,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    IN PFN_CMSG_ALLOC               pfnAlloc,
    OUT HCRYPTKEY                   *phEncryptKey,
    OUT PBYTE                       *ppbEncryptParameters,
    OUT DWORD                       rgcbEncryptParameters[2])
{
    BOOL fRet;

    CMSG_CONTENT_ENCRYPT_INFO ContentEncryptInfo;
        ZEROSTRUCT(ContentEncryptInfo);
    CMSG_RECIPIENT_ENCODE_INFO CmsRecipientEncodeInfo;
        ZEROSTRUCT(CmsRecipientEncodeInfo);
    CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO KeyTransEncodeInfo;
        ZEROSTRUCT(KeyTransEncodeInfo);

    ContentEncryptInfo.cbSize = sizeof(ContentEncryptInfo);
    ContentEncryptInfo.hCryptProv = *phCryptProv;
    ContentEncryptInfo.ContentEncryptionAlgorithm = *paiEncrypt;
    ContentEncryptInfo.pvEncryptionAuxInfo = pvEncryptAuxInfo;
    ContentEncryptInfo.cRecipients = 1;
    ContentEncryptInfo.rgCmsRecipients = &CmsRecipientEncodeInfo;
    ContentEncryptInfo.pfnAlloc = pfnAlloc;
    ContentEncryptInfo.pfnFree = ICM_Free;
    // ContentEncryptInfo.hContentEncryptKey =
    // ContentEncryptInfo.dwFlags =

    CmsRecipientEncodeInfo.dwRecipientChoice = CMSG_KEY_TRANS_RECIPIENT;
    CmsRecipientEncodeInfo.pKeyTrans = &KeyTransEncodeInfo;

    KeyTransEncodeInfo.cbSize = sizeof(KeyTransEncodeInfo);
    KeyTransEncodeInfo.KeyEncryptionAlgorithm = pPublicKeyInfo->Algorithm;
    // KeyTransEncodeInfo.pvKeyEncryptionAuxInfo =
    // KeyTransEncodeInfo.hCryptProv =
    KeyTransEncodeInfo.RecipientPublicKey = pPublicKeyInfo->PublicKey;
    // KeyTransEncodeInfo.RecipientId =

    // dwEncryptFlags
    if (ICM_IsSP3CompatibleEncrypt(&ContentEncryptInfo))
        rgcbEncryptParameters[1] = CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG;
    else
        rgcbEncryptParameters[1] = 0;

    fRet = ICM_DefaultGenContentEncryptKey(
        &ContentEncryptInfo,
        0,                      // dwFlags
        NULL                    // pvReserved
        );

    assert(0 == (ContentEncryptInfo.dwFlags &
         CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG));

    if (fRet) {
        if (ContentEncryptInfo.dwFlags & CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG) {
            *ppbEncryptParameters =
                ContentEncryptInfo.ContentEncryptionAlgorithm.Parameters.pbData;
            rgcbEncryptParameters[0] =
                ContentEncryptInfo.ContentEncryptionAlgorithm.Parameters.cbData;
        }

        *phCryptProv = ContentEncryptInfo.hCryptProv;
        *phEncryptKey = ContentEncryptInfo.hContentEncryptKey;
    } else {
        if (ContentEncryptInfo.dwFlags & CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG)
            ICM_Free(ContentEncryptInfo.ContentEncryptionAlgorithm.Parameters.pbData);
        if (ContentEncryptInfo.hContentEncryptKey) {
            DWORD dwErr = GetLastError();
            CryptDestroyKey(ContentEncryptInfo.hContentEncryptKey);
            SetLastError(dwErr);
        }
        *phEncryptKey = 0;
    }

    return fRet;
}

#else

//+-------------------------------------------------------------------------
//  Get the CAPI ALG_ID corresponding to the encryption OID. Generate
//  default parameters for and encode. For RC2, encode as RC2_CBC parameters.
//  For all others encode as an IV octet string. The IV is initialized by
//  calling CryptGenRandom.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_CreateDefaultEncryptParameters(
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PVOID                        pvEncryptAuxInfo,
    IN PFN_CMSG_ALLOC               pfnAlloc,
    OUT PBYTE                       *ppbEncryptParameters,
    OUT PDWORD                      pcbEncryptParameters,
    OUT PDWORD                      pdwAlgIdEncrypt,
    OUT PDWORD                      pdwBitLen,          // 0 => default length
    OUT BYTE                        rgbIV[IV_LENGTH],
    OUT PDWORD                      pcbIV
    )
{
    BOOL fRet;
    HCRYPTPROV hCryptProv;      // doesn't need to be released
    CRYPT_RC2_CBC_PARAMETERS RC2Para;
    CRYPT_DATA_BLOB IVPara;
    void *pvPara;
    LPCSTR pszStructType;

    *ppbEncryptParameters = NULL;
    *pcbEncryptParameters = 0;
    *pdwBitLen = 0;
    *pcbIV = IV_LENGTH;

    if (!ICM_GetCAPI(
            CRYPT_ENCRYPT_ALG_OID_GROUP_ID,
            paiEncrypt,
            pdwAlgIdEncrypt))
        goto GetCAPIError;

    // Generate the random IV.
    hCryptProv = I_CryptGetDefaultCryptProv(0);
    if (0 == hCryptProv)
        goto GetDefaultCryptProvError;
    if (!CryptGenRandom(hCryptProv, IV_LENGTH, rgbIV))
        goto GenRandomError;

    if (CALG_RC2 == *pdwAlgIdEncrypt) {
        PCMSG_RC2_AUX_INFO pAuxInfo = (PCMSG_RC2_AUX_INFO) pvEncryptAuxInfo;

        if (pAuxInfo && pAuxInfo->cbSize >= sizeof(CMSG_RC2_AUX_INFO)) {
            *pdwBitLen = pAuxInfo->dwBitLen & ~CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG;
            if (!ICM_BitLengthToRC2Version(*pdwBitLen, &RC2Para.dwVersion))
                goto BitLengthToRC2VersionError;
        } else {
            // Default to 40 bits;
            *pdwBitLen = 40;
            RC2Para.dwVersion = CRYPT_RC2_40BIT_VERSION;
        }

        // Encode as RC2_CBC parameters
        RC2Para.fIV = TRUE;
        assert(sizeof(RC2Para.rgbIV) == IV_LENGTH);
        memcpy(RC2Para.rgbIV, rgbIV, sizeof(RC2Para.rgbIV));

        pvPara = &RC2Para;
        pszStructType = PKCS_RC2_CBC_PARAMETERS;
    } else {
        IVPara.pbData = rgbIV;
        IVPara.cbData = IV_LENGTH;
        pvPara = &IVPara;
        pszStructType = X509_OCTET_STRING;
    }

    if (!CryptEncodeObject(
            X509_ASN_ENCODING,
            pszStructType,
            pvPara,
            NULL,                   // pbEncoded
            pcbEncryptParameters
            )) goto EncodeError;
    if (NULL == (*ppbEncryptParameters = (PBYTE) pfnAlloc(
            *pcbEncryptParameters)))
        goto OutOfMemory;
    if (!CryptEncodeObject(
            X509_ASN_ENCODING,
            pszStructType,
            pvPara,
            *ppbEncryptParameters,
            pcbEncryptParameters
            )) goto EncodeError;
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(GetCAPIError, CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(BitLengthToRC2VersionError)
TRACE_ERROR(GetDefaultCryptProvError)
TRACE_ERROR(GenRandomError)
TRACE_ERROR(EncodeError)
TRACE_ERROR(OutOfMemory)
}


//+-------------------------------------------------------------------------
//  Default generation of the encryption key using the ASN.1 Encryption
//  algorithm OID and optional parameters.
//
//  rgcbEncryptParameters[1] is the dwEncryptFlags passed to
//  ICM_DefaultExportEncryptKey
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultGenEncryptKey(
    IN OUT HCRYPTPROV               *phCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PVOID                        pvEncryptAuxInfo,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    IN PFN_CMSG_ALLOC               pfnAlloc,
    OUT HCRYPTKEY                   *phEncryptKey,
    OUT PBYTE                       *ppbEncryptParameters,
    OUT DWORD                       rgcbEncryptParameters[2])
{
    BOOL        fRet;
    DWORD       dwAlgIdEncrypt;
    HCRYPTPROV  hCryptProv;
    BYTE        rgbIV[IV_LENGTH];
    DWORD       cbIV;
    DWORD       dwBitLen;
    DWORD       dwEncryptFlags;

    *phEncryptKey = 0;

    dwEncryptFlags = 0;
    rgcbEncryptParameters[1] = 0;    // dwEncryptFlags
    if (pvEncryptAuxInfo) {
        PCMSG_SP3_COMPATIBLE_AUX_INFO pSP3AuxInfo =
            (PCMSG_SP3_COMPATIBLE_AUX_INFO) pvEncryptAuxInfo;
        if (sizeof(CMSG_SP3_COMPATIBLE_AUX_INFO) <= pSP3AuxInfo->cbSize &&
                (pSP3AuxInfo->dwFlags & CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG)) {
            dwEncryptFlags = CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG;
            rgcbEncryptParameters[1] = CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG;
        }
    }

    if (dwEncryptFlags & CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG) {
        cbIV = 0;
        dwBitLen = 0;

        if (!ICM_GetCAPI(
                CRYPT_ENCRYPT_ALG_OID_GROUP_ID,
                paiEncrypt,
                &dwAlgIdEncrypt))
            goto GetCAPIError;

    } else if (0 == paiEncrypt->Parameters.cbData) {
        if (!ICM_CreateDefaultEncryptParameters(
                paiEncrypt,
                pvEncryptAuxInfo,
                pfnAlloc,
                ppbEncryptParameters,
                rgcbEncryptParameters,
                &dwAlgIdEncrypt,
                &dwBitLen,
                rgbIV,
                &cbIV))
            goto CreateDefaultEncryptParametersError;
    } else {
        if (!ICM_GetEncryptParameters(
                paiEncrypt,
                &dwAlgIdEncrypt,
                &dwBitLen,
                rgbIV,
                &cbIV))
            goto GetEncryptParametersError;
    }

    hCryptProv = *phCryptProv;
    if (0 == hCryptProv) {
        DWORD dwAlgIdPubKey = 0;
        ICM_GetCAPI(
            CRYPT_PUBKEY_ALG_OID_GROUP_ID,
            &pPublicKeyInfo->Algorithm,
            &dwAlgIdPubKey);

        hCryptProv = I_CryptGetDefaultCryptProvForEncrypt(
            dwAlgIdPubKey, dwAlgIdEncrypt, dwBitLen);
        if (0 == hCryptProv)
            goto GetDefaultCryptProvError;
        else
            *phCryptProv = hCryptProv;
    }

    fRet = CryptGenKey(
            hCryptProv,
            dwAlgIdEncrypt,
            (dwEncryptFlags & CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG) ?
                CRYPT_EXPORTABLE :
                CRYPT_EXPORTABLE | CRYPT_NO_SALT,       // dwFlags
            phEncryptKey);
    if (!fRet) {
        if (NTE_BAD_FLAGS == GetLastError())
            // Previous versions didn't support CRYPT_NO_SALT flag
            fRet = CryptGenKey(
                    hCryptProv,
                    dwAlgIdEncrypt,
                    CRYPT_EXPORTABLE,       // dwFlags
                    phEncryptKey);
        if (!fRet) {
            *phEncryptKey = 0;    
            goto GenKeyError;
        }
    }

    if (CALG_RC2 == dwAlgIdEncrypt && 0 != dwBitLen)
        // Silently ignore any errors. Not supported in earlier versions
        CryptSetKeyParam(
            *phEncryptKey,
            KP_EFFECTIVE_KEYLEN,
            (PBYTE) &dwBitLen,
            0);                 // dwFlags

    if (0 != cbIV) {
        if (!CryptSetKeyParam(
                *phEncryptKey,
                KP_IV,
                rgbIV,
                0))                 // dwFlags
            goto SetKeyParamError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    if (*phEncryptKey) {
        DWORD dwErr = GetLastError();
        CryptDestroyKey(*phEncryptKey);
        *phEncryptKey = 0;
        SetLastError(dwErr);
    }
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(GetCAPIError, CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(CreateDefaultEncryptParametersError)
TRACE_ERROR(GetEncryptParametersError)
TRACE_ERROR(GetDefaultCryptProvError)
TRACE_ERROR(GenKeyError)
TRACE_ERROR(SetKeyParamError)
}

//+-------------------------------------------------------------------------
//  Get an hkey for content encryption for a particular algorithm
//
//  rgcbEncryptParameters[1] is the dwEncryptFlags passed to
//  ICM_ExportEncryptKey
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GenEncryptKey(
    IN OUT HCRYPTPROV               *phCryptProv,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PVOID                        pvEncryptAuxInfo,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    IN PFN_CMSG_ALLOC               pfnAlloc,
    OUT HCRYPTKEY                   *phEncryptKey,
    OUT PBYTE                       *ppbEncryptParameters,
    OUT DWORD                       rgcbEncryptParameters[2])
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    if (CryptGetOIDFunctionAddress(
            hGenEncryptKeyFuncSet,
            X509_ASN_ENCODING,
            paiEncrypt->pszObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fResult = ((PFN_CMSG_GEN_ENCRYPT_KEY) pvFuncAddr)(
            phCryptProv,
            paiEncrypt,
            pvEncryptAuxInfo,
            pPublicKeyInfo,
            pfnAlloc,
            phEncryptKey,
            ppbEncryptParameters,
            rgcbEncryptParameters);
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else
        fResult = ICM_DefaultGenEncryptKey(
            phCryptProv,
            paiEncrypt,
            pvEncryptAuxInfo,
            pPublicKeyInfo,
            pfnAlloc,
            phEncryptKey,
            ppbEncryptParameters,
            rgcbEncryptParameters);
    return fResult;
}

#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Advance the phase of a message
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_AdvanceMsgPhase(
    IN OUT PDWORD   pdwPhase,
    IN BOOL         fFinal)
{
    BOOL    fRet;
    DWORD   dwPhase = *pdwPhase;

    switch (dwPhase) {
    case PHASE_FIRST_ONGOING:
        dwPhase = fFinal ? PHASE_FIRST_FINAL : PHASE_FIRST_ONGOING;
        break;
    case PHASE_FIRST_FINAL:
        dwPhase = fFinal ? PHASE_SECOND_FINAL : PHASE_SECOND_ONGOING;
        break;
    case PHASE_SECOND_ONGOING:
        dwPhase = fFinal ? PHASE_SECOND_FINAL : PHASE_SECOND_ONGOING;
        break;
    case PHASE_SECOND_FINAL:
        goto TransitionFromSecondFinalError;
    default:
        goto InvalidPhaseError;
    }
    *pdwPhase = dwPhase;
    fRet = TRUE;

CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(TransitionFromSecondFinalError,CRYPT_E_MSG_ERROR)
SET_ERROR(InvalidPhaseError,CRYPT_E_MSG_ERROR)
}


//+-------------------------------------------------------------------------
//  Return the (cached) value of the hash
//
//  Returns FALSE iff conversion failed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetListHashValue(
    IN CHashNode    *pnHash,
    OUT DWORD       *pcbHash,
    OUT PBYTE       *ppbHash)
{
    BOOL            fRet;
    PICM_HASH_INFO  pHashInfo;

    pHashInfo = pnHash->Data();

    if (0 == pHashInfo->HashBlob.cbData) {
        pHashInfo->HashBlob.pbData = NULL;
        if (!CryptGetHashParam(
                pHashInfo->hHash,
                HP_HASHVAL,
                NULL,                   // pbHash
                &pHashInfo->HashBlob.cbData,
                0))                     // dwFlags
            goto GetHashParamSizeError;
        pHashInfo->HashBlob.pbData = (PBYTE)ICM_Alloc(
                    pHashInfo->HashBlob.cbData);
        if (NULL == pHashInfo->HashBlob.pbData)
            goto HashAllocError;
        if (!CryptGetHashParam(
                pHashInfo->hHash,
                HP_HASHVAL,
                pHashInfo->HashBlob.pbData,
                &pHashInfo->HashBlob.cbData,
                0))                     // dwFlags
            goto GetHashParamError;
    }
    *pcbHash = pHashInfo->HashBlob.cbData;
    *ppbHash = pHashInfo->HashBlob.pbData;
    fRet = TRUE;

CommonReturn:
    return fRet;

ErrorReturn:
    if(pHashInfo->HashBlob.pbData != NULL) {
        ICM_Free(pHashInfo->HashBlob.pbData);
        pHashInfo->HashBlob.pbData = NULL;
    }
    *pcbHash = 0;
#if DBG
    *ppbHash = NULL;
#endif
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetHashParamSizeError)  // error already set
TRACE_ERROR(HashAllocError)         // error already set
TRACE_ERROR(GetHashParamError)      // error already set
}


//+-------------------------------------------------------------------------
//  Return a new hash handle equivalent to the original
//
//  Returns FALSE iff creation failed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DupListHash(
    IN CHashNode    *pnHash,
    IN HCRYPTPROV   hCryptProv,
    OUT HCRYPTHASH  *phHash)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
    PICM_HASH_INFO  pHashInfo = pnHash->Data();
    HCRYPTHASH      hHash = NULL;
    DWORD           cbHash;
    PBYTE           pbHash;

    if (!ICM_GetListHashValue(
            pnHash,
            &cbHash,
            &pbHash))
        goto GetListHashValueError;
    if (!CryptCreateHash(
            hCryptProv,
            pHashInfo->dwAlgoCAPI,
            NULL,               // hKey - optional for MAC
            0,                  // dwFlags
            &hHash))
        goto CreateHashError;
    if (!CryptSetHashParam(
            hHash,
            HP_HASHVAL,
            pbHash,
            0))                     // dwFlags
        goto SetHashParamError;

    fRet = TRUE;
CommonReturn:
    *phHash = hHash;
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    if (hHash)
        CryptDestroyHash( hHash);
    hHash = NULL;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetListHashValueError)  // error already set
TRACE_ERROR(CreateHashError)        // error already set
TRACE_ERROR(SetHashParamError)      // error already set
}

#ifndef CMS_PKCS7
//+-------------------------------------------------------------------------
//  Set a DigestAlgorithmIdentifiers
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_SetAsnDigestAlgorithmIdentifiers(
    OUT DigestAlgorithmIdentifiers  *podais,
    OUT PCRYPT_ALGORITHM_IDENTIFIER pai,
    IN DWORD                        cSigners,
    IN PCMSG_SIGNER_ENCODE_INFO     rgSigners,
    OUT HCRYPTPROV                  *phCryptProv,
    OUT DWORD                       *pdwKeySpec)
{
    DWORD                       dwError = ERROR_SUCCESS;
    BOOL                        fRet;
    DWORD                       i;
    PCMSG_SIGNER_ENCODE_INFO    psei;
    DigestAlgorithmIdentifier   *podai;

    *phCryptProv = NULL;


    // This code does not remove duplicates from the list of
    // algorithms. It is not wrong, but the output message is
    // unnecessarily bulky.
    if (cSigners) {
        podai = (DigestAlgorithmIdentifier *)ICM_AllocZero(
                        cSigners * sizeof( DigestAlgorithmIdentifier));
        if (NULL == podai)
            goto DigestAlgorithmIdentifierAllocError;
    } else {
        podai = NULL;
    }
    podais->count = cSigners;
    podais->value = podai;
    for (i=cSigners, psei=rgSigners; i>0; i--, psei++, podai++) {
        assert( psei->cbSize >= STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO,
            rgUnauthAttr));
        assert( psei->pvHashAuxInfo == NULL);
        if (psei->cbSize <
                    STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO, rgUnauthAttr) ||
                psei->pvHashAuxInfo != NULL)
            goto InvalidArg;
        *phCryptProv = psei->hCryptProv; // s/b array, one for each algo
        *pdwKeySpec = psei->dwKeySpec; // s/b array, one for each algo
        *pai = psei->HashAlgorithm;    // s/b array, one for each algo
        if (!ICM_Asn1ToAlgorithmIdentifier( &psei->HashAlgorithm, podai))
            goto Asn1ToAlgorithmIdentifierError;
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( podai);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(DigestAlgorithmIdentifierAllocError)    // error already set
TRACE_ERROR(Asn1ToAlgorithmIdentifierError)      // error already set
SET_ERROR(InvalidArg,E_INVALIDARG)
}
#endif  // not defined CMS_PKCS7


//+-------------------------------------------------------------------------
//  Fill digestEncryptionAlgorithm
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
ICM_FillAsnDigestEncryptionAlgorithm(
    IN PCRYPT_MSG_INFO pcmi,
    IN PCRYPT_ALGORITHM_IDENTIFIER pDigestEncryptAlg,
    IN OUT DigestEncryptionAlgId *pdea
    )
{
    BOOL fRet;
    CRYPT_ALGORITHM_IDENTIFIER DigestEncryptAlg;
    DWORD dwFlags;
    PCCRYPT_OID_INFO pOIDInfo;

    dwFlags = 0;

    if (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            pDigestEncryptAlg->pszObjId,
            CRYPT_PUBKEY_ALG_OID_GROUP_ID)) {
        if (1 <= pOIDInfo->ExtraInfo.cbData / sizeof(DWORD)) {
            DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;
            dwFlags = pdwExtra[0];
        }

        // Check if more than just the NULL parameters
        if (2 < pDigestEncryptAlg->Parameters.cbData) {
            // Check if we should use the public key parameters
            if (0 == (dwFlags & CRYPT_OID_USE_PUBKEY_PARA_FOR_PKCS7_FLAG)) {
                memset(&DigestEncryptAlg, 0, sizeof(DigestEncryptAlg));
                DigestEncryptAlg.pszObjId = pDigestEncryptAlg->pszObjId;
                pDigestEncryptAlg = &DigestEncryptAlg;
            }
        }
    } else if (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            pDigestEncryptAlg->pszObjId,
            CRYPT_SIGN_ALG_OID_GROUP_ID)) {
        if (2 <= pOIDInfo->ExtraInfo.cbData / sizeof(DWORD)) {
            DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;
            dwFlags = pdwExtra[1];
        }
    }

    if (!ICM_MsgAsn1ToAlgorithmIdentifier(
            pcmi,
            pDigestEncryptAlg,
            pdea))
        goto DigestEncryptionAsn1ToAlgorithmIdentifierError;

    if (0 == pDigestEncryptAlg->Parameters.cbData &&
            0 != (dwFlags & CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG)) {
        // NO NULL parameters
        pdea->bit_mask &= ~parameters_present;
        pdea->parameters.length = 0;
        pdea->parameters.value = NULL;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(DigestEncryptionAsn1ToAlgorithmIdentifierError)  // error already set
}

void
WINAPI
ICM_GetCertIdFromCertInfo(
    IN PCERT_INFO               pCertInfo,
    OUT PCERT_ID                pCertId)
{
    if (Asn1UtilExtractKeyIdFromCertInfo(pCertInfo, &pCertId->KeyId)) {
        pCertId->dwIdChoice = CERT_ID_KEY_IDENTIFIER;
    } else {
        pCertId->dwIdChoice = CERT_ID_ISSUER_SERIAL_NUMBER;
        pCertId->IssuerSerialNumber.Issuer = pCertInfo->Issuer;
        pCertId->IssuerSerialNumber.SerialNumber = pCertInfo->SerialNumber;
    }
}

BOOL
WINAPI
ICM_GetSignerIdFromSignerEncodeInfo(
    IN PCMSG_SIGNER_ENCODE_INFO psei,
    OUT PCERT_ID                pSignerId)
{
    BOOL fRet;
    if (STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO, SignerId) <= psei->cbSize &&
            psei->SignerId.dwIdChoice) {
        *pSignerId = psei->SignerId;
        if (!(CERT_ID_ISSUER_SERIAL_NUMBER == pSignerId->dwIdChoice ||
                CERT_ID_KEY_IDENTIFIER == pSignerId->dwIdChoice))
            goto InvalidSignerIdChoice;
    } else
        ICM_GetCertIdFromCertInfo(psei->pCertInfo, pSignerId);

    fRet = TRUE;
CommonReturn:
    return fRet;
ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidSignerIdChoice, E_INVALIDARG)
}

BOOL
WINAPI
ICM_SetOssCertIdentifier(
    IN PCERT_ID pCertId,
    IN OUT CertIdentifier *pOssCertId
    );

void
WINAPI
ICM_FreeOssCertIdentifier(
    IN OUT CertIdentifier *pOssCertId
    );

//+-------------------------------------------------------------------------
//  Fill a single SignerInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillAsnSignerInfo(
    IN PCMSG_SIGNER_ENCODE_INFO psei,
    IN PCRYPT_MSG_INFO          pcmi,
    IN DWORD                    dwFlags,
    IN OPTIONAL LPSTR           pszInnerContentObjID,
    IN OUT SignerInfo           *psi,
    IN OUT Attribute            **ppAuthAttr,
    IN OUT Attribute            **ppUnauthAttr)
{
    BOOL                fRet;
    Attribute           *pAuthAttr;
    Attribute           *pUnauthAttr;
    int                 i;
    PCRYPT_ATTRIBUTE    patr;
    PCRYPT_ALGORITHM_IDENTIFIER pDigestEncryptAlg;
    CERT_ID             SignerId;

    // psi->bit_mask = 0;

    if (!ICM_GetSignerIdFromSignerEncodeInfo(psei, &SignerId))
        goto GetSignerIdError;

    // version
    if (CERT_ID_ISSUER_SERIAL_NUMBER == SignerId.dwIdChoice)
        psi->version = CMSG_SIGNER_INFO_PKCS_1_5_VERSION;
    else
        psi->version = CMSG_SIGNER_INFO_CMS_VERSION;

    // sid
    if (!ICM_SetOssCertIdentifier(
            &SignerId,
            &psi->sid
            ))
        goto SetOssCertIdentifierError;

    // digestAlgorithm
    if (!ICM_MsgAsn1ToAlgorithmIdentifier(
            pcmi,
            &psei->HashAlgorithm,
            &psi->digestAlgorithm))
        goto DigestAsn1ToAlgorithmIdentifierError;

    // authenticatedAttributes
    if (!ICM_IsData( pszInnerContentObjID) ||
            psei->cAuthAttr ||
            (dwFlags & CMSG_AUTHENTICATED_ATTRIBUTES_FLAG)) {
        psi->bit_mask |= authenticatedAttributes_present;
        // NB - The actual number of authenticated attributes will be
        //      2 larger than requested, because of the 2 required
        //      attributes (if authenticated attributes are present).
        //      Leave room at the beginning of the attribute array.
        pAuthAttr = *ppAuthAttr;
        psi->authenticatedAttributes.count = psei->cAuthAttr + 2;
        psi->authenticatedAttributes.value = pAuthAttr;
        for (i=psei->cAuthAttr, patr=psei->rgAuthAttr, pAuthAttr+=2;
                i>0;
                i--, patr++, pAuthAttr++) {
            if (!ICM_Asn1ToAttribute( patr, pAuthAttr))
                goto Asn1AuthenticatedAttributeError;
        }
        *ppAuthAttr = pAuthAttr;
    }

    // digestEncryptionAlgorithm
#ifdef CMS_PKCS7
    if (STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO, HashEncryptionAlgorithm) <=
            psei->cbSize && psei->HashEncryptionAlgorithm.pszObjId)
        pDigestEncryptAlg = &psei->HashEncryptionAlgorithm;
    else
#endif  // CMS_PKCS7
        pDigestEncryptAlg = &psei->pCertInfo->SubjectPublicKeyInfo.Algorithm;
    if (!ICM_FillAsnDigestEncryptionAlgorithm(
            pcmi, pDigestEncryptAlg, &psi->digestEncryptionAlgorithm))
        goto FillAsnDigestEncryptionAlgorithmError;

    // encryptedDigest is filled in later, when we see the content

    // unauthenticatedAttributes
    if (0 != psei->cUnauthAttr) {
        psi->bit_mask |= unauthAttributes_present;
        pUnauthAttr = *ppUnauthAttr;
        psi->unauthAttributes.count = psei->cUnauthAttr;
        psi->unauthAttributes.value = pUnauthAttr;
        for (i=psei->cUnauthAttr, patr=psei->rgUnauthAttr;
                i>0;
                i--, patr++, pUnauthAttr++) {
            if (!ICM_Asn1ToAttribute( patr, pUnauthAttr))
                goto Asn1UnauthenticatedAttributeError;
        }
        *ppUnauthAttr = pUnauthAttr;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetSignerIdError)
TRACE_ERROR(SetOssCertIdentifierError)
TRACE_ERROR(DigestAsn1ToAlgorithmIdentifierError)
TRACE_ERROR(Asn1AuthenticatedAttributeError)
TRACE_ERROR(FillAsnDigestEncryptionAlgorithmError)
TRACE_ERROR(Asn1UnauthenticatedAttributeError)
}

//+-------------------------------------------------------------------------
//  Free SignerInfo allocated memory
//--------------------------------------------------------------------------
void
WINAPI
ICM_FreeAsnSignerInfo(
    IN OUT SignerInfo           *psi)
{
    Attribute   *poatr;
    DWORD       i;

    ICM_Free(psi->encryptedDigest.value);
    ICM_FreeOssCertIdentifier(&psi->sid);

    for (i=psi->authenticatedAttributes.count,
            poatr = psi->authenticatedAttributes.value;
            i>0;
            i--, poatr++)
        ICM_Free(poatr->attributeValue.value);
    for (i=psi->unauthAttributes.count,
            poatr=psi->unauthAttributes.value;
            i>0;
            i--, poatr++)
        ICM_Free( poatr->attributeValue.value);
}


//+-------------------------------------------------------------------------
//  Set a SignerInfos
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_SetAsnSignerInfos(
    IN PCMSG_SIGNED_ENCODE_INFO psmei,
    IN PCRYPT_MSG_INFO          pcmi,
    IN DWORD                    dwFlags,
    IN OPTIONAL LPSTR           pszInnerContentObjID,
    OUT SignerInfos             *psis,
    OUT BOOL                    *pfHasCmsSignerId)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    DWORD               i;
    DWORD               cAuthAttr;
    DWORD               cUnauthAttr;
    PCMSG_SIGNER_ENCODE_INFO psei;
    SignerInfo          *psi = NULL;
    Attribute           *pAuthAttr;
    Attribute           *pUnauthAttr;
    DWORD               cSigners  = psmei->cSigners;
    PCMSG_SIGNER_ENCODE_INFO rgSigners = psmei->rgSigners;

    *pfHasCmsSignerId = FALSE;
    psis->value = NULL;
    psis->count = 0;
    if (0 == cSigners)
        goto SuccessReturn;
    // NB - Each SignerInfo gets a non-empty authenticatedAttributes
    //      if the inner contentType is not data (passed in) or if
    //      there are authenticated attributes passed in. In this case,
    //      we reserve two Attribute slots at the beginning of the array
    //      for the content-type and message-digest Attribute values.
    for (i=cSigners, psei=rgSigners, cAuthAttr=0, cUnauthAttr=0;
            i>0;
            i--,
#ifdef CMS_PKCS7
            psei = (PCMSG_SIGNER_ENCODE_INFO) ((BYTE *) psei + psei->cbSize)) {
#else
            psei++) {
#endif  // CMS_PKCS7
        if (!ICM_IsData( pszInnerContentObjID) ||
                psei->cAuthAttr ||
                (dwFlags & CMSG_AUTHENTICATED_ATTRIBUTES_FLAG))
            cAuthAttr += psei->cAuthAttr + 2;    // reserve 2
        cUnauthAttr += psei->cUnauthAttr;
    }
    psi = (SignerInfo *)ICM_AllocZero(  cSigners    * sizeof( SignerInfo) +
                                        cAuthAttr   * sizeof( Attribute) +
                                        cUnauthAttr * sizeof( Attribute)
                                     );
    if (NULL == psi)
        goto SignerInfoAllocError;
    psis->count = cSigners;
    psis->value = psi;
    pAuthAttr = (Attribute *)(psis->value + cSigners);
    pUnauthAttr = pAuthAttr + cAuthAttr;

    for (i=cSigners, psei=rgSigners, psi=psis->value; i>0; i--,
#ifdef CMS_PKCS7
            psei = (PCMSG_SIGNER_ENCODE_INFO) ((BYTE *) psei + psei->cbSize),
#else
            psei++,
#endif  // CMS_PKCS7
            psi++) {
        if (!ICM_FillAsnSignerInfo(
                psei,
                pcmi,
                dwFlags,
                pszInnerContentObjID,
                psi,
                &pAuthAttr,
                &pUnauthAttr))
            goto FillAsnSignerInfoError;

        if (CMSG_SIGNER_INFO_CMS_VERSION <= psi->version)
            *pfHasCmsSignerId = TRUE;
    }
SuccessReturn:
    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SignerInfoAllocError)       // error already set
TRACE_ERROR(FillAsnSignerInfoError)     // error already set
}

#ifdef CMS_PKCS7

BOOL
WINAPI
ICM_IsDuplicateSignerEncodeHashAlgorithm(
    IN PCMSG_SIGNER_ENCODE_INFO rgSigners,
    IN PCMSG_SIGNER_ENCODE_INFO pNewSigner,
    OUT OPTIONAL DWORD *pdwPrevIndex
    )
{
    PCRYPT_ALGORITHM_IDENTIFIER pNewHashAlg = &pNewSigner->HashAlgorithm;
    PCMSG_SIGNER_ENCODE_INFO pPrevSigner;
    DWORD dwPrevIndex;

    pPrevSigner = rgSigners;
    dwPrevIndex = 0;
    while (pPrevSigner < pNewSigner) {
        PCRYPT_ALGORITHM_IDENTIFIER pPrevHashAlg = &pPrevSigner->HashAlgorithm;
        if (0 == strcmp(pNewHashAlg->pszObjId, pPrevHashAlg->pszObjId)
                        &&
                pNewHashAlg->Parameters.cbData ==
                    pPrevHashAlg->Parameters.cbData
                        &&
                (0 == pNewHashAlg->Parameters.cbData ||
                    0 == memcmp(pNewHashAlg->Parameters.pbData,
                            pPrevHashAlg->Parameters.pbData,
                            pNewHashAlg->Parameters.cbData))) {
            break;
        }

        assert(STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO, rgUnauthAttr) <=
            pPrevSigner->cbSize);
        assert(pPrevSigner->cbSize == pNewSigner->cbSize);
        pPrevSigner = (PCMSG_SIGNER_ENCODE_INFO) ((BYTE *) pPrevSigner +
            pPrevSigner->cbSize);
        dwPrevIndex++;
    }

    if (pdwPrevIndex)
        *pdwPrevIndex = dwPrevIndex;
    return pPrevSigner < pNewSigner;
}

//+-------------------------------------------------------------------------
//  Set Signer DigestAlgorithmIdentifiers and create the SignerEncode and
//  Hash lists
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_SetAsnSignerDigestInfo(
    IN PCMSG_SIGNED_ENCODE_INFO psmei,
    IN OUT PCRYPT_MSG_INFO pcmi,
    IN OUT DigestAlgorithmIdentifiers *podais
    )
{
    BOOL fRet;
    DigestAlgorithmIdentifier *podai = NULL;
    DWORD cDigests = 0;
    DWORD cSigners = psmei->cSigners;

    if (cSigners) {
        DWORD i;
        PCMSG_SIGNER_ENCODE_INFO psei;
        PSIGNER_ENCODE_DATA_INFO rgSignerEncodeDataInfo;

        podai = (DigestAlgorithmIdentifier *) ICM_AllocZero(
            cSigners * sizeof(DigestAlgorithmIdentifier));
        if (NULL == podai)
            goto OutOfMemory;

        rgSignerEncodeDataInfo = (PSIGNER_ENCODE_DATA_INFO) ICM_AllocZero(
            cSigners * sizeof(SIGNER_ENCODE_DATA_INFO));
        if (NULL == rgSignerEncodeDataInfo)
            goto OutOfMemory;
        pcmi->cSignerEncodeDataInfo = cSigners;
        pcmi->rgSignerEncodeDataInfo = rgSignerEncodeDataInfo;

        if (NULL == (pcmi->pHashList = new CHashList))
            goto OutOfMemory;

        for (i = 0, psei = psmei->rgSigners; i < cSigners; i++,
                psei = (PCMSG_SIGNER_ENCODE_INFO) ((BYTE *) psei + psei->cbSize)) {
            DWORD dwPrevIndex;
            ICM_HASH_INFO HashInfo;     ZEROSTRUCT(HashInfo);
            CHashNode *pHashNode;

            assert(STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO, rgUnauthAttr) <=
                psei->cbSize);
            assert(psei->hCryptProv);
            if (STRUCT_CBSIZE(CMSG_SIGNER_ENCODE_INFO, rgUnauthAttr) >
                    psei->cbSize || 0 == psei->hCryptProv)
                goto InvalidArg;

            if (ICM_IsDuplicateSignerEncodeHashAlgorithm(
                    psmei->rgSigners,
                    psei,
                    &dwPrevIndex
                    )) {
                assert(dwPrevIndex < i);
                pHashNode = rgSignerEncodeDataInfo[dwPrevIndex].pHashNode;
            } else {
                if (!ICM_MsgAsn1ToAlgorithmIdentifier(
                        pcmi,
                        &psei->HashAlgorithm,
                        &podai[cDigests]))
                    goto MsgAsn1ToAlgorithmIdentifierError;
                cDigests++;

                if (!(ICM_GetCAPI(
                        CRYPT_HASH_ALG_OID_GROUP_ID,
                        &psei->HashAlgorithm,
                        &HashInfo.dwAlgoCAPI) ||
                      ICM_GetCAPI(
                        CRYPT_SIGN_ALG_OID_GROUP_ID,
                        &psei->HashAlgorithm,
                        &HashInfo.dwAlgoCAPI)))
                    goto GetCAPIError;
                if (!CryptCreateHash(
                                psei->hCryptProv,
                                HashInfo.dwAlgoCAPI,
                                NULL,               // hKey - optional for MAC
                                0,                  // dwFlags
                                &HashInfo.hHash))
                    goto CreateHashError;
                if (NULL == (pHashNode = new CHashNode)) {
                    DWORD dwErr = GetLastError();
                    CryptDestroyHash(HashInfo.hHash);
                    SetLastError(dwErr);
                    goto OutOfMemory;
                }
                pHashNode->SetData(&HashInfo);
                pcmi->pHashList->InsertTail(pHashNode);
            }

            rgSignerEncodeDataInfo[i].hCryptProv = psei->hCryptProv;
            rgSignerEncodeDataInfo[i].dwKeySpec = psei->dwKeySpec;
            rgSignerEncodeDataInfo[i].pHashNode = pHashNode;
        }
        assert(cDigests);
    }

    podais->count = cDigests;
    podais->value = podai;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    ICM_Free(podai);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(MsgAsn1ToAlgorithmIdentifierError)
SET_ERROR(InvalidArg, E_INVALIDARG)
SET_ERROR(GetCAPIError, CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(CreateHashError)
}

//+-------------------------------------------------------------------------
//  Open a signed message for encoding
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
ICM_OpenToEncodeSignedData(
    IN DWORD                        dwEncodingType,
    IN DWORD                        dwFlags,
    IN void const                   *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR               pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO   pStreamInfo)
{
    DWORD                       dwError = ERROR_SUCCESS;
    PCRYPT_MSG_INFO             pcmi = NULL;
    PCMSG_SIGNED_ENCODE_INFO    psmei;
    PCERT_BLOB                  pcert;
    PCRL_BLOB                   pcrl;
    SignedData                  *psd = NULL;
    Certificate                 *pOssCert;
    CertificateRevocationList   *pOssCrl;
    DWORD                       i;
    DWORD                       cbCert;
    PBYTE                       pbCert;
    DWORD                       cbCrl;
    PBYTE                       pbCrl;
    DWORD                       cAttrCertEncoded;
    BOOL                        fHasCmsSignerId;

    psmei = (PCMSG_SIGNED_ENCODE_INFO)pvMsgEncodeInfo;
    assert( psmei->cbSize >= STRUCT_CBSIZE(CMSG_SIGNED_ENCODE_INFO,
        rgCrlEncoded));
    if (psmei->cbSize < STRUCT_CBSIZE(CMSG_SIGNED_ENCODE_INFO, rgCrlEncoded))
        goto InvalidArg;

    for (i=psmei->cCertEncoded, pcert=psmei->rgCertEncoded, cbCert=0;
            i>0;
            i--, pcert++)
        cbCert += pcert->cbData;

    for (i=psmei->cCrlEncoded, pcrl=psmei->rgCrlEncoded, cbCrl=0;
            i>0;
            i--, pcrl++)
        cbCrl += pcrl->cbData;

    if (psmei->cbSize >= STRUCT_CBSIZE(CMSG_SIGNED_ENCODE_INFO,
            rgAttrCertEncoded)) {
        cAttrCertEncoded = psmei->cAttrCertEncoded;

        for (i=cAttrCertEncoded, pcert=psmei->rgAttrCertEncoded;
                i>0;
                i--, pcert++)
            cbCert += pcert->cbData;
    } else
        cAttrCertEncoded = 0;

    psd = (SignedData *)ICM_AllocZero(
                sizeof( SignedData) +
                psmei->cCertEncoded * sizeof( Certificate) +
                cAttrCertEncoded * sizeof( Certificate) +
                psmei->cCrlEncoded * sizeof( CertificateRevocationList) +
                cbCert +
                cbCrl);
    if (NULL == psd)
        goto SignedDataAllocError;

    // digest algorithms filled in as part of ICM_SetAsnSignerDigestInfo

    // contentInfo filled in later, when we see the content

    // certificates
    if (0 != psmei->cCertEncoded || 0 != cAttrCertEncoded) {
        psd->bit_mask |= certificates_present;
        psd->certificates.count = psmei->cCertEncoded;
        psd->certificates.count += cAttrCertEncoded;
#ifdef OSS_CRYPT_ASN1
        psd->certificates.certificates = (Certificate *)(psd + 1);
#else
        psd->certificates.value = (Certificate *)(psd + 1);
#endif  // OSS_CRYPT_ASN1
        pbCert = (PBYTE)psd +
                sizeof( SignedData) +
                psmei->cCertEncoded * sizeof( Certificate) +
                cAttrCertEncoded * sizeof( Certificate) +
                psmei->cCrlEncoded * sizeof( CertificateRevocationList);
        for (i=psmei->cCertEncoded, pcert=psmei->rgCertEncoded,
#ifdef OSS_CRYPT_ASN1
                    pOssCert=psd->certificates.certificates;
#else
                    pOssCert=psd->certificates.value;
#endif  // OSS_CRYPT_ASN1
                i>0;
                i--, pcert++, pOssCert++) {
            pOssCert->length = pcert->cbData;
            memcpy( pbCert, pcert->pbData, pcert->cbData);
            pOssCert->value = pbCert;
            pbCert += pcert->cbData;
        }

        for (i=cAttrCertEncoded, pcert=psmei->rgAttrCertEncoded;
                i>0;
                i--, pcert++, pOssCert++) {
            pOssCert->length = pcert->cbData;
            memcpy( pbCert, pcert->pbData, pcert->cbData);
            if (pcert->cbData)
                // Change tag from SEQUENCE to [1] IMPLICIT
                *pbCert = ICM_TAG_CONSTRUCTED_CONTEXT_1;
            pOssCert->value = pbCert;
            pbCert += pcert->cbData;
        }
    }

    // crls
    if (0 != psmei->cCrlEncoded) {
        psd->bit_mask |= crls_present;
        psd->crls.count = psmei->cCrlEncoded;
        if (0 != psmei->cCertEncoded || 0 != cAttrCertEncoded)
#ifdef OSS_CRYPT_ASN1
            psd->crls.crls  = (CertificateRevocationList *)
                                (psd->certificates.certificates +
#else
            psd->crls.value  = (CertificateRevocationList *)
                                (psd->certificates.value +
#endif  // OSS_CRYPT_ASN1
                                    (psmei->cCertEncoded + cAttrCertEncoded));
        else
#ifdef OSS_CRYPT_ASN1
            psd->crls.crls  = (CertificateRevocationList *) (psd + 1);
#else
            psd->crls.value  = (CertificateRevocationList *) (psd + 1);
#endif  // OSS_CRYPT_ASN1
        pbCrl = (PBYTE)psd +
                sizeof( SignedData) +
                psmei->cCertEncoded * sizeof( Certificate) +
                cAttrCertEncoded * sizeof( Certificate) +
                psmei->cCrlEncoded * sizeof( CertificateRevocationList) +
                cbCert;
#ifdef OSS_CRYPT_ASN1
        for (i=psmei->cCrlEncoded, pcrl=psmei->rgCrlEncoded, pOssCrl=psd->crls.crls;
#else
        for (i=psmei->cCrlEncoded, pcrl=psmei->rgCrlEncoded, pOssCrl=psd->crls.value;
#endif  // OSS_CRYPT_ASN1
                i>0;
                i--, pcrl++, pOssCrl++) {
            pOssCrl->length = pcrl->cbData;
            memcpy( pbCrl, pcrl->pbData, pcrl->cbData);
            pOssCrl->value = pbCrl;
            pbCrl += pcrl->cbData;
        }
    }


    if (NULL == (pcmi = (PCRYPT_MSG_INFO)ICM_AllocZero(
            sizeof( CRYPT_MSG_INFO))))
        goto OutOfMemory;

    // signerInfos
    if (!ICM_SetAsnSignerInfos(psmei, pcmi, dwFlags, pszInnerContentObjID,
            &psd->signerInfos, &fHasCmsSignerId))
        goto SetAsnSignerInfosError;

    // version
    if (0 < cAttrCertEncoded || fHasCmsSignerId) {
        if (ICM_IsData(pszInnerContentObjID))
            dwFlags &= ~CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
        else
            dwFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
    } else if (dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG) {
        if (ICM_IsData(pszInnerContentObjID))
            dwFlags &= ~CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
    }

    // If encapsulated other than id-data or has attribute certs or has
    // CMS signers, then, CMS version
    if ((dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG) ||
            0 < cAttrCertEncoded || fHasCmsSignerId)
        psd->version = CMSG_SIGNED_DATA_CMS_VERSION;
    else
        psd->version = CMSG_SIGNED_DATA_PKCS_1_5_VERSION;

    pcmi->dwEncodingType = dwEncodingType;
    pcmi->dwMsgType = CMSG_SIGNED;
    pcmi->dwFlags = dwFlags;
    pcmi->pvMsg = psd;
    pcmi->fEncoding = TRUE;
    pcmi->dwPhase = PHASE_FIRST_ONGOING;
    if (pszInnerContentObjID &&
            (NULL == (pcmi->pszInnerContentObjID = (LPSTR)ICM_DupMem(
                                    pszInnerContentObjID,
                                    ICM_StrLen(pszInnerContentObjID) + 1))))
        goto DupInnerContentObjIDError;
    if (pStreamInfo &&
            (NULL == (pcmi->pStreamInfo = (PCMSG_STREAM_INFO)ICM_DupMem(
                                    pStreamInfo,
                                    sizeof(*pStreamInfo)))))
        goto DupStreamInfoError;

    if (!ICM_SetAsnSignerDigestInfo(
            psmei,
            pcmi,
            &psd->digestAlgorithms
            ))
        goto SetAsnSignerDigestInfoError;

    if (pcmi->pStreamInfo && !ICMS_OpenToEncodeSignedData( pcmi, psmei))
        goto StreamOpenToEncodeSignedDataError;

CommonReturn:
    ICM_SetLastError(dwError);
    return (HCRYPTMSG)pcmi;

ErrorReturn:
    dwError = GetLastError();
    if (psd) {
        if (psd->signerInfos.value) {
            SignerInfo  *psi;

            for (i=psd->signerInfos.count, psi=psd->signerInfos.value;
                    i>0;
                    i--, psi++)
                ICM_FreeAsnSignerInfo(psi);
            ICM_Free(psd->signerInfos.value);
        }
        ICM_Free(psd);
    }
    if (pcmi) {
        if (pcmi->pFreeList)
            delete pcmi->pFreeList;
        if (pcmi->pHashList)
            delete pcmi->pHashList;
        ICM_Free(pcmi->rgSignerEncodeDataInfo);
        ICM_Free(pcmi->pszInnerContentObjID);
        ICM_Free(pcmi->pStreamInfo);
        ICM_Free(pcmi);
        pcmi = NULL;
    }
    goto CommonReturn;
SET_ERROR(InvalidArg,E_INVALIDARG)
TRACE_ERROR(DupInnerContentObjIDError)              // error already set
TRACE_ERROR(DupStreamInfoError)                     // error already set
TRACE_ERROR(SetAsnSignerInfosError)                 // error already set
TRACE_ERROR(SetAsnSignerDigestInfoError)            // error already set
TRACE_ERROR(SignedDataAllocError)                   // error already set
TRACE_ERROR(OutOfMemory)                            // error already set
TRACE_ERROR(StreamOpenToEncodeSignedDataError)      // error already set
}

#else

//+-------------------------------------------------------------------------
//  Open a signed message for encoding
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
ICM_OpenToEncodeSignedData(
    IN DWORD                        dwEncodingType,
    IN DWORD                        dwFlags,
    IN void const                   *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR               pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO   pStreamInfo)
{
    DWORD                       dwError = ERROR_SUCCESS;
    PCRYPT_MSG_INFO             pcmi = NULL;
    PCMSG_SIGNED_ENCODE_INFO    psmei;
    PCERT_BLOB                  pcert;
    PCRL_BLOB                   pcrl;
    SignedData                  *psd = NULL;
    Certificate                 *pOssCert;
    CertificateRevocationList   *pOssCrl;
    DWORD                       i;
    DWORD                       cDigestAlgorithms;
    HCRYPTPROV                  hCryptProv;
    DWORD                       dwKeySpec;
    CRYPT_ALGORITHM_IDENTIFIER  aiDigest;
    ICM_HASH_INFO               HashInfo;       ZEROSTRUCT(HashInfo);
    CHashNode                   *pHashNode;
    DWORD                       cbCert;
    PBYTE                       pbCert;
    DWORD                       cbCrl;
    PBYTE                       pbCrl;
    BOOL                        fHasCmsSignerId;

#ifdef CMS_PKCS7
    DWORD                       cAttrCertEncoded;
#endif  // CMS_PKCS7

    psmei = (PCMSG_SIGNED_ENCODE_INFO)pvMsgEncodeInfo;
    assert( 2 > psmei->cSigners);
    if (!( 2 > psmei->cSigners))
        goto TooManySignersError;
#ifdef CMS_PKCS7
    assert( psmei->cbSize >= offsetof(CMSG_SIGNED_ENCODE_INFO,
        cAttrCertEncoded));
    if (psmei->cbSize < offsetof(CMSG_SIGNED_ENCODE_INFO, cAttrCertEncoded))
#else
    assert( psmei->cbSize >= sizeof(CMSG_SIGNED_ENCODE_INFO));
    if (psmei->cbSize < sizeof(CMSG_SIGNED_ENCODE_INFO))
#endif
        goto InvalidArg;

    for (i=psmei->cCertEncoded, pcert=psmei->rgCertEncoded, cbCert=0;
            i>0;
            i--, pcert++)
        cbCert += pcert->cbData;

    for (i=psmei->cCrlEncoded, pcrl=psmei->rgCrlEncoded, cbCrl=0;
            i>0;
            i--, pcrl++)
        cbCrl += pcrl->cbData;

#ifdef CMS_PKCS7
    if (psmei->cbSize > offsetof(CMSG_SIGNED_ENCODE_INFO, rgAttrCertEncoded)) {
        cAttrCertEncoded = psmei->cAttrCertEncoded;

        for (i=cAttrCertEncoded, pcert=psmei->rgAttrCertEncoded;
                i>0;
                i--, pcert++)
            cbCert += pcert->cbData;
    } else
        cAttrCertEncoded = 0;
#endif  // CMS_PKCS7

    psd = (SignedData *)ICM_AllocZero(
                sizeof( SignedData) +
                psmei->cCertEncoded * sizeof( Certificate) +
#ifdef CMS_PKCS7
                cAttrCertEncoded * sizeof( Certificate) +
#endif  // CMS_PKCS7
                psmei->cCrlEncoded * sizeof( CertificateRevocationList) +
                cbCert +
                cbCrl);
    if (NULL == psd)
        goto SignedDataAllocError;
    psd->bit_mask = 0;
    psd->signerInfos.value = NULL;
    psd->contentInfo.content.value = NULL;

    // version
#ifdef CMS_PKCS7
    if (0 < cAttrCertEncoded) {
        if (ICM_IsData(pszInnerContentObjID))
            dwFlags &= ~CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
        else
            dwFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
    } else if (dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG) {
        if (ICM_IsData(pszInnerContentObjID))
            dwFlags &= ~CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
    }

    // If encapsulated other than id-data or has attribute certs, then,
    // version = 3
    if ((dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG) ||
            0 < cAttrCertEncoded)
        psd->version = CMSG_SIGNED_DATA_CMS_VERSION;
    else
        psd->version = CMSG_SIGNED_DATA_PKCS_1_5_VERSION;
#else
    psd->version = 1;
#endif  // CMS_PKCS7

    // digest algorithms
    if (!ICM_SetAsnDigestAlgorithmIdentifiers(
                &psd->digestAlgorithms,
                &aiDigest,
                psmei->cSigners,
                psmei->rgSigners,
                &hCryptProv,
                &dwKeySpec))
        goto SetAsnDigestAlgorithmIdentifiersError;

    // contentInfo filled in later, when we see the content

    // certificates
    if (0 != psmei->cCertEncoded
#ifdef CMS_PKCS7
            || 0 != cAttrCertEncoded
#endif  // CMS_PKCS7
            ) {
        psd->bit_mask |= certificates_present;
        psd->certificates.count = psmei->cCertEncoded;
#ifdef CMS_PKCS7
        psd->certificates.count += cAttrCertEncoded;
#endif  // CMS_PKCS7
#ifdef OSS_CRYPT_ASN1
        psd->certificates.certificates = (Certificate *)(psd + 1);
#else
        psd->certificates.value = (Certificate *)(psd + 1);
#endif  // OSS_CRYPT_ASN1
        pbCert = (PBYTE)psd +
                sizeof( SignedData) +
                psmei->cCertEncoded * sizeof( Certificate) +
#ifdef CMS_PKCS7
                cAttrCertEncoded * sizeof( Certificate) +
#endif  // CMS_PKCS7
                psmei->cCrlEncoded * sizeof( CertificateRevocationList);
        for (i=psmei->cCertEncoded, pcert=psmei->rgCertEncoded,
#ifdef OSS_CRYPT_ASN1
                    pOssCert=psd->certificates.certificates;
#else
                    pOssCert=psd->certificates.value;
#endif  // OSS_CRYPT_ASN1
                i>0;
                i--, pcert++, pOssCert++) {
            pOssCert->length = pcert->cbData;
            memcpy( pbCert, pcert->pbData, pcert->cbData);
            pOssCert->value = pbCert;
            pbCert += pcert->cbData;
        }

#ifdef CMS_PKCS7
        for (i=cAttrCertEncoded, pcert=psmei->rgAttrCertEncoded;
                i>0;
                i--, pcert++, pOssCert++) {
            pOssCert->length = pcert->cbData;
            memcpy( pbCert, pcert->pbData, pcert->cbData);
            if (pcert->cbData)
                // Change tag from SEQUENCE to [1] IMPLICIT
                *pbCert = ICM_TAG_CONSTRUCTED_CONTEXT_1;
            pOssCert->value = pbCert;
            pbCert += pcert->cbData;
        }
#endif  // CMS_PKCS7
    }

    // crls
    if (0 != psmei->cCrlEncoded) {
        psd->bit_mask |= crls_present;
        psd->crls.count = psmei->cCrlEncoded;
        if (0 != psmei->cCertEncoded
#ifdef CMS_PKCS7
                || 0 != cAttrCertEncoded
#endif  // CMS_PKCS7
                )
#ifdef OSS_CRYPT_ASN1
            psd->crls.crls  = (CertificateRevocationList *)
                                (psd->certificates.certificates +
#else
            psd->crls.value  = (CertificateRevocationList *)
                                (psd->certificates.value +
#endif  // OSS_CRYPT_ASN1
                                    (psmei->cCertEncoded
#ifdef CMS_PKCS7
                                        + cAttrCertEncoded
#endif  // CMS_PKCS7
                                    ));
        else
#ifdef OSS_CRYPT_ASN1
            psd->crls.crls  = (CertificateRevocationList *) (psd + 1);
#else
            psd->crls.value  = (CertificateRevocationList *) (psd + 1);
#endif  // OSS_CRYPT_ASN1
        pbCrl = (PBYTE)psd +
                sizeof( SignedData) +
                psmei->cCertEncoded * sizeof( Certificate) +
#ifdef CMS_PKCS7
                cAttrCertEncoded * sizeof( Certificate) +
#endif  // CMS_PKCS7
                psmei->cCrlEncoded * sizeof( CertificateRevocationList) +
                cbCert;
#ifdef OSS_CRYPT_ASN1
        for (i=psmei->cCrlEncoded, pcrl=psmei->rgCrlEncoded, pOssCrl=psd->crls.crls;
#else
        for (i=psmei->cCrlEncoded, pcrl=psmei->rgCrlEncoded, pOssCrl=psd->crls.value;
#endif  // OSS_CRYPT_ASN1
                i>0;
                i--, pcrl++, pOssCrl++) {
            pOssCrl->length = pcrl->cbData;
            memcpy( pbCrl, pcrl->pbData, pcrl->cbData);
            pOssCrl->value = pbCrl;
            pbCrl += pcrl->cbData;
        }
    }

    // signerInfos
    // psd->signerInfos.count = psmei->cSigners;
    // psd->signerInfos.value = (SignerInfo *)
    //                         (psd->crls.crls + psmei->cCrlEncoded);
    if (!ICM_SetAsnSignerInfos( psmei, pcmi, dwFlags, pszInnerContentObjID,
            &psd->signerInfos, &fHasCmsSignerId))
        goto SetAsnSignerInfosError;

    cDigestAlgorithms = psmei->cSigners;
    if (NULL == (pcmi = (PCRYPT_MSG_INFO)ICM_AllocZero( sizeof( CRYPT_MSG_INFO))))
        goto OutOfMemory;

    pcmi->hCryptProv = hCryptProv;
    if (0 == hCryptProv)
        pcmi->fDefaultCryptProv = TRUE;
    pcmi->dwKeySpec = dwKeySpec;
    pcmi->dwEncodingType = dwEncodingType;
    pcmi->dwMsgType = CMSG_SIGNED;
    pcmi->dwFlags = dwFlags;
    pcmi->pvMsg = psd;
    pcmi->fEncoding = TRUE;
    pcmi->dwPhase = PHASE_FIRST_ONGOING;
    if (pszInnerContentObjID &&
            (NULL == (pcmi->pszInnerContentObjID = (LPSTR)ICM_DupMem(
                                    pszInnerContentObjID,
                                    ICM_StrLen(pszInnerContentObjID) + 1))))
        goto DupInnerContentObjIDError;
    if (pStreamInfo &&
            (NULL == (pcmi->pStreamInfo = (PCMSG_STREAM_INFO)ICM_DupMem(
                                    pStreamInfo,
                                    sizeof(*pStreamInfo)))))
        goto DupStreamInfoError;

    if (psmei->cSigners) {
        if (!(ICM_GetCAPI(
                CRYPT_HASH_ALG_OID_GROUP_ID,
                &aiDigest,
                &HashInfo.dwAlgoCAPI) ||
              ICM_GetCAPI(
                CRYPT_SIGN_ALG_OID_GROUP_ID,
                &aiDigest,
                &HashInfo.dwAlgoCAPI)))
            goto GetCAPIError;
        HashInfo.hCryptProv = hCryptProv;
        if (!CryptCreateHash(
                        HashInfo.hCryptProv,
                        HashInfo.dwAlgoCAPI,
                        NULL,               // hKey - optional for MAC
                        0,                  // dwFlags
                        &HashInfo.hHash))
            goto CreateHashError;
        if (NULL == (pcmi->pHashList = new CHashList))
            goto NewHashListError;
        if (NULL == (pHashNode = new CHashNode))
            goto NewHashNodeError;
        pHashNode->SetData( &HashInfo);
        pcmi->pHashList->InsertTail( pHashNode);
    }

    if (pcmi->pStreamInfo && !ICMS_OpenToEncodeSignedData( pcmi, psmei))
        goto StreamOpenToEncodeSignedDataError;

CommonReturn:
    ICM_SetLastError(dwError);
    return (HCRYPTMSG)pcmi;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( psd);
    ICM_Free( pcmi);
    pcmi = NULL;
    goto CommonReturn;
SET_ERROR(TooManySignersError,E_INVALIDARG)
SET_ERROR(NewHashListError,E_OUTOFMEMORY)
SET_ERROR(NewHashNodeError,E_OUTOFMEMORY)
SET_ERROR(InvalidArg,E_INVALIDARG)
SET_ERROR(GetCAPIError,CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(DupInnerContentObjIDError)              // error already set
TRACE_ERROR(DupStreamInfoError)                     // error already set
TRACE_ERROR(SetAsnSignerInfosError)                 // error already set
TRACE_ERROR(SetAsnDigestAlgorithmIdentifiersError)  // error already set
TRACE_ERROR(SignedDataAllocError)                   // error already set
TRACE_ERROR(OutOfMemory)                            // error already set
TRACE_ERROR(CreateHashError)                        // error already set
TRACE_ERROR(StreamOpenToEncodeSignedDataError)      // error already set
}

#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Open a data message for encoding
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
ICM_OpenToEncodeData(
    IN DWORD                        dwEncodingType,
    IN DWORD                        dwFlags,
    IN void const                   *pvMsgEncodeInfo,
    IN OPTIONAL PCMSG_STREAM_INFO   pStreamInfo)
{
    DWORD                       dwError = ERROR_SUCCESS;
    PCRYPT_MSG_INFO             pcmi = NULL;
    OctetStringType             *poos = NULL;

    if (pvMsgEncodeInfo)
        goto EncodeInfoPresentError;

    if (NULL == (poos = (OctetStringType *)ICM_AllocZero( sizeof( OctetStringType))))
        goto AllocOctetStringTypeError;

    if (NULL == (pcmi = (PCRYPT_MSG_INFO)ICM_AllocZero( sizeof( CRYPT_MSG_INFO))))
        goto AllocMsgInfoError;

    pcmi->dwEncodingType    = dwEncodingType;
    pcmi->dwMsgType         = CMSG_DATA;
//  pcmi->hCryptProv        = 0;
    pcmi->fDefaultCryptProv = TRUE;
    pcmi->dwFlags           = dwFlags;
    pcmi->pvMsg             = poos;
    pcmi->fEncoding         = TRUE;
    pcmi->dwPhase           = PHASE_FIRST_ONGOING;
    pcmi->pStreamInfo       = (PCMSG_STREAM_INFO)ICM_DupMem(
                                    pStreamInfo,
                                    sizeof(*pStreamInfo));

    if (pcmi->pStreamInfo && !ICMS_OpenToEncodeData( pcmi))
        goto StreamOpenToEncodeDataError;

CommonReturn:
    ICM_SetLastError(dwError);
    return (HCRYPTMSG)pcmi;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( poos);
    if (pcmi) {
        ICM_Free(pcmi->pStreamInfo);
        ICM_Free( pcmi);
    }
    pcmi = NULL;
    goto CommonReturn;
SET_ERROR(EncodeInfoPresentError,E_INVALIDARG)
TRACE_ERROR(AllocMsgInfoError)                  // error already set
TRACE_ERROR(AllocOctetStringTypeError)          // error already set
TRACE_ERROR(StreamOpenToEncodeDataError)        // error already set
}


//+-------------------------------------------------------------------------
//  Open a digested message for encoding
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
ICM_OpenToEncodeDigestedData(
    IN DWORD dwEncodingType,
    IN DWORD dwFlags,
    IN void const *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo)
{
    DWORD                       dwError = ERROR_SUCCESS;
    PCRYPT_MSG_INFO             pcmi = NULL;
    PCMSG_HASHED_ENCODE_INFO     pdmei;
    DigestedData                *pdd = NULL;
    ICM_HASH_INFO               HashInfo;       ZEROSTRUCT(HashInfo);
    CHashNode                   *pHashNode;

    pdmei = (PCMSG_HASHED_ENCODE_INFO)pvMsgEncodeInfo;
    assert( pdmei->cbSize >= sizeof(CMSG_HASHED_ENCODE_INFO));
    assert( pdmei->pvHashAuxInfo == NULL);
    if (pdmei->cbSize < sizeof(CMSG_HASHED_ENCODE_INFO) ||
            pdmei->pvHashAuxInfo != NULL)
        goto InvalidArg;

    pcmi = (PCRYPT_MSG_INFO)ICM_AllocZero( sizeof( CRYPT_MSG_INFO));
    if (NULL == pcmi)
        goto OutOfMemory;

    pdd = (DigestedData *)ICM_AllocZero( sizeof( DigestedData));
    if (NULL == pdd)
        goto DigestedDataAllocError;

    // version
#ifdef CMS_PKCS7
    if (dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG) {
        if (ICM_IsData(pszInnerContentObjID))
            dwFlags &= ~CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
    }

    // If encapsulated other than id-data, then, version = 2
    if (dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG)
        pdd->version = CMSG_HASHED_DATA_V2;
    else
        pdd->version = CMSG_HASHED_DATA_V0;
#else
    pdd->version = 0;
#endif  // CMS_PKCS7

    // digest algorithm
    if (!ICM_MsgAsn1ToAlgorithmIdentifier(
            pcmi,
            &pdmei->HashAlgorithm,
            &pdd->digestAlgorithm))
        goto MsgAsn1ToAlgorithmIdentifierError;


    // contentInfo filled in later, when we see the content

    if (pdmei->hCryptProv)
        pcmi->hCryptProv        = pdmei->hCryptProv;
    else {
        pcmi->fDefaultCryptProv = TRUE;
        pcmi->hCryptProv = I_CryptGetDefaultCryptProv(0);
        if (0 == pcmi->hCryptProv)
            goto GetDefaultCryptProvError;
    }
    pcmi->dwEncodingType    = dwEncodingType;
    pcmi->dwMsgType         = CMSG_HASHED;
    pcmi->dwFlags           = dwFlags;
    pcmi->pvMsg             = pdd;
    pcmi->fEncoding         = TRUE;
    pcmi->dwPhase           = PHASE_FIRST_ONGOING;
    pcmi->pszInnerContentObjID = (LPSTR)ICM_DupMem(
                                    pszInnerContentObjID,
                                    ICM_StrLen(pszInnerContentObjID) + 1);
    pcmi->pStreamInfo = (PCMSG_STREAM_INFO)ICM_DupMem(
                                    pStreamInfo,
                                    sizeof(*pStreamInfo));

    if (!ICM_GetCAPI(
            CRYPT_HASH_ALG_OID_GROUP_ID,
            &pdmei->HashAlgorithm,
            &HashInfo.dwAlgoCAPI))
        goto GetCAPIError;
#ifndef CMS_PKCS7
    HashInfo.hCryptProv = pcmi->hCryptProv;
#endif  // CMS_PKCS7
    if (!CryptCreateHash(
                    pcmi->hCryptProv,
                    HashInfo.dwAlgoCAPI,
                    NULL,               // hKey - optional for MAC
                    0,                  // dwFlags
                    &HashInfo.hHash))
        goto CreateHashError;

    if (NULL == (pcmi->pHashList = new CHashList) ||
            NULL == (pHashNode = new CHashNode)) {
        DWORD dwErr = GetLastError();
        CryptDestroyHash(HashInfo.hHash);
        SetLastError(dwErr);
        goto NewHashListOrNodeError;
    }
    pHashNode->SetData( &HashInfo);
    pcmi->pHashList->InsertTail( pHashNode);

CommonReturn:
    ICM_SetLastError(dwError);
    return (HCRYPTMSG)pcmi;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( pdd);
    if (pcmi) {
#ifdef CMS_PKCS7
        if (pcmi->pFreeList)
            delete pcmi->pFreeList;
#endif  // CMS_PKCS7
        if (pcmi->pHashList)
            delete pcmi->pHashList;
        ICM_Free(pcmi->pszInnerContentObjID);
        ICM_Free(pcmi->pStreamInfo);
        ICM_Free( pcmi);
        pcmi = NULL;
    }
    goto CommonReturn;
SET_ERROR(InvalidArg,E_INVALIDARG)
TRACE_ERROR(GetDefaultCryptProvError)
SET_ERROR(GetCAPIError,CRYPT_E_UNKNOWN_ALGO)
SET_ERROR(NewHashListOrNodeError,E_OUTOFMEMORY)
TRACE_ERROR(MsgAsn1ToAlgorithmIdentifierError)       // error already set
TRACE_ERROR(DigestedDataAllocError)                     // error already set
TRACE_ERROR(CreateHashError)                            // error already set
TRACE_ERROR(OutOfMemory)                                // error already set
}

#ifdef CMS_PKCS7

//+-------------------------------------------------------------------------
//  Export the hContentEncryptKey from the ContentEncrypt
//  provider and import into the specified provider
//--------------------------------------------------------------------------
HCRYPTKEY
WINAPI
ICM_ExportContentEncryptKeyAndImport(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN HCRYPTPROV hImportProv
    )
{
    DWORD dwError = ERROR_SUCCESS;

    HCRYPTPROV hExportProv = pContentEncryptInfo->hCryptProv;
    HCRYPTHASH hHash = 0;
    HCRYPTKEY hDeriveKey = 0;
    HCRYPTKEY hImportContentEncryptKey = 0;
#define BASE_DATA_LENGTH    8
    BYTE rgbBaseData[BASE_DATA_LENGTH];
    PBYTE pbContentKey = NULL;
    DWORD cbContentKey = 0;

    DWORD dwImportFlags;
    DWORD dwAlgIdEncrypt;
    DWORD dwBitLen;
    BYTE rgbIV[IV_MAX_LENGTH];
    DWORD cbIV;
    const DWORD dw40BitLen = 40;

    // Generate derive key to use to encrypt and export the content encrypt key
    if (!CryptGenRandom(hExportProv, BASE_DATA_LENGTH, rgbBaseData))
        goto GenRandomError;
    if (!CryptCreateHash(hExportProv, CALG_SHA1, 0, 0, &hHash))
        goto ExportCreateHashError;
    if (!CryptHashData(hHash, rgbBaseData, BASE_DATA_LENGTH, 0))
        goto ExportHashDataError;
    if (!CryptDeriveKey(
            hExportProv,
            CALG_RC2,
            hHash,
            40 << 16,               // dwFlags, dwBitLen in upper WORD
            &hDeriveKey))
        goto ExportDeriveKeyError;

    CryptSetKeyParam(
        hDeriveKey,
        KP_EFFECTIVE_KEYLEN,
        (PBYTE) &dw40BitLen,
        0);                 // dwFlags

    // Export the content encrypt key
    if (!CryptExportKey(
            pContentEncryptInfo->hContentEncryptKey,
            hDeriveKey,
            SYMMETRICWRAPKEYBLOB,
            0,                                          // dwFlags
            NULL,
            &cbContentKey))
        goto ExportKeyError;
    if (NULL == (pbContentKey = (PBYTE) ICM_Alloc(cbContentKey)))
        goto AllocError;
    if (!CryptExportKey(
            pContentEncryptInfo->hContentEncryptKey,
            hDeriveKey,
            SYMMETRICWRAPKEYBLOB,
            0,                                          // dwFlags
            pbContentKey,
            &cbContentKey))
        goto ExportKeyError;

    // Generate derive key to use to decrypt and import the content encrypt key
    CryptDestroyKey(hDeriveKey);
    hDeriveKey = 0;
    CryptDestroyHash(hHash);
    hHash = 0;

    if (!CryptCreateHash(hImportProv, CALG_SHA1, 0, 0, &hHash))
        goto ImportCreateHashError;
    if (!CryptHashData(hHash, rgbBaseData, BASE_DATA_LENGTH, 0))
        goto ImportHashDataError;
    if (!CryptDeriveKey(
            hImportProv,
            CALG_RC2,
            hHash,
            40 << 16,               // dwFlags, dwBitLen in upper WORD
            &hDeriveKey))
        goto ImportDeriveKeyError;

    CryptSetKeyParam(
        hDeriveKey,
        KP_EFFECTIVE_KEYLEN,
        (PBYTE) &dw40BitLen,
        0);                 // dwFlags

    // Decrypt and import the content encrypt key
    dwImportFlags = CRYPT_EXPORTABLE;
    if (!ICM_IsSP3CompatibleEncrypt(pContentEncryptInfo))
        dwImportFlags |= CRYPT_NO_SALT;
    if (!CryptImportKey(
            hImportProv,
            pbContentKey,
            cbContentKey,
            hDeriveKey,
            dwImportFlags,
            &hImportContentEncryptKey))
        goto ImportKeyError;

    // Need to re-set effective key length and IV

    if (!ICM_GetEncryptParameters(
            &pContentEncryptInfo->ContentEncryptionAlgorithm,
            &dwAlgIdEncrypt,
            &dwBitLen,
            rgbIV,
            &cbIV))
        goto GetEncryptParametersError;

    if (CALG_RC2 == dwAlgIdEncrypt && 0 != dwBitLen)
        // Silently ignore any errors. Not supported in earlier versions
        CryptSetKeyParam(
            hImportContentEncryptKey,
            KP_EFFECTIVE_KEYLEN,
            (PBYTE) &dwBitLen,
            0);                 // dwFlags

    if (0 != cbIV) {
        if (CALG_RC4 == dwAlgIdEncrypt) {
            // For RC4, set the SALT, not the IV

            CRYPT_DATA_BLOB SaltBlob;
            SaltBlob.pbData = rgbIV;
            SaltBlob.cbData = cbIV;

            if (!CryptSetKeyParam(
                    hImportContentEncryptKey,
                    KP_SALT_EX,
                    (PBYTE) &SaltBlob,
                    0))                 // dwFlags
                goto SetSaltExError;
        } else {
            if (!CryptSetKeyParam(
                    hImportContentEncryptKey,
                    KP_IV,
                    rgbIV,
                    0))                 // dwFlags
                goto SetIVError;
        }
    }

CommonReturn:
    if (hDeriveKey)
        CryptDestroyKey(hDeriveKey);
    if (hHash)
        CryptDestroyHash(hHash);
    ICM_Free(pbContentKey);
    ICM_SetLastError(dwError);
    return hImportContentEncryptKey;
ErrorReturn:
    dwError = GetLastError();
    if (hImportContentEncryptKey) {
        CryptDestroyKey(hImportContentEncryptKey);
        hImportContentEncryptKey = 0;
    }
    goto CommonReturn;

TRACE_ERROR(GenRandomError)
TRACE_ERROR(ExportCreateHashError)
TRACE_ERROR(ExportHashDataError)
TRACE_ERROR(ExportDeriveKeyError)
TRACE_ERROR(ExportKeyError)
TRACE_ERROR(AllocError)
TRACE_ERROR(ImportCreateHashError)
TRACE_ERROR(ImportHashDataError)
TRACE_ERROR(ImportDeriveKeyError)
TRACE_ERROR(ImportKeyError)
TRACE_ERROR(GetEncryptParametersError)
TRACE_ERROR(SetSaltExError)
TRACE_ERROR(SetIVError)
}


//+-------------------------------------------------------------------------
//  Export the encrypted content encrypt key using the KeyTrans or KeyAgree
//  key.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ExportEncryptedKey(
    IN HCRYPTKEY hContentEncryptKey,
    IN HCRYPTKEY hPubKey,
    IN DWORD dwBlobType,
    IN BOOL fSP3CompatibleEncrypt,
    OUT PCRYPT_DATA_BLOB pEncryptedKey
    )
{
    BOOL fRet;
    PBYTE pbCspEncryptedKey = NULL;
    DWORD cbCspEncryptedKey;

    if (!CryptExportKey(
            hContentEncryptKey,
            hPubKey,
            dwBlobType,
            0,                  // dwFlags
            NULL,
            &cbCspEncryptedKey))
        goto ExportEncryptedKeyError;
    if (NULL == (pbCspEncryptedKey = (PBYTE) ICM_AllocA(cbCspEncryptedKey)))
        goto AllocError;
    if (!CryptExportKey(
            hContentEncryptKey,
            hPubKey,
            dwBlobType,
            0,                  // dwFlags
            pbCspEncryptedKey,
            &cbCspEncryptedKey))
        goto ExportEncryptedKeyError;
    assert(cbCspEncryptedKey >
        (sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER)));
    cbCspEncryptedKey -= sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER);

    if (NULL == (pEncryptedKey->pbData = (PBYTE) ICM_Alloc(cbCspEncryptedKey)))
        goto AllocError;
    pEncryptedKey->cbData = cbCspEncryptedKey;


    if (SYMMETRICWRAPKEYBLOB == dwBlobType || fSP3CompatibleEncrypt)
        // Don't byte reverse
        memcpy(pEncryptedKey->pbData,
            pbCspEncryptedKey +
                (sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER)),
            cbCspEncryptedKey);
    else
        ICM_ReverseCopy(pEncryptedKey->pbData,
            pbCspEncryptedKey +
                (sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER)),
            cbCspEncryptedKey);

    fRet = TRUE;

CommonReturn:
    ICM_FreeA(pbCspEncryptedKey);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(AllocError)
TRACE_ERROR(ExportEncryptedKeyError)
}

BOOL
WINAPI
ICM_IsSameRecipientPublicKeyAlgorithm(
    IN PCRYPT_ALGORITHM_IDENTIFIER paiPubKey1,
    IN PCRYPT_ALGORITHM_IDENTIFIER paiPubKey2
    )
{
    DWORD dwAlgIdPubKey1;
    DWORD dwAlgIdPubKey2;

    if (0 == strcmp(paiPubKey1->pszObjId, paiPubKey2->pszObjId))
        return TRUE;

    ICM_GetCAPI(
        CRYPT_PUBKEY_ALG_OID_GROUP_ID,
        paiPubKey1,
        &dwAlgIdPubKey1);
    ICM_GetCAPI(
        CRYPT_PUBKEY_ALG_OID_GROUP_ID,
        paiPubKey2,
        &dwAlgIdPubKey2);

    if (dwAlgIdPubKey1 == dwAlgIdPubKey2)
        return TRUE;

    // If we don't know about either public key, default to being the same.
    if (0 == dwAlgIdPubKey1 || 0 == dwAlgIdPubKey2)
        return TRUE;
    
    return FALSE;
}

//+-------------------------------------------------------------------------
//  Default export of the encryption key for key transport recipient
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1
ICMTest_DefaultExportKeyTrans(
#else
ICM_DefaultExportKeyTrans(
#endif
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTransEncodeInfo,
    IN OUT PCMSG_KEY_TRANS_ENCRYPT_INFO pKeyTransEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fRet;
    DWORD dwError = ERROR_SUCCESS;

    HCRYPTPROV hKeyTransProv = 0;
    HCRYPTKEY hContentEncryptKey = 0;
    CERT_PUBLIC_KEY_INFO PublicKeyInfo;
    HCRYPTKEY hPubKey = 0;

    hKeyTransProv = pKeyTransEncodeInfo->hCryptProv;

    if (0 == hKeyTransProv) {
        if (0 == pKeyTransEncryptInfo->dwRecipientIndex)
            hKeyTransProv = pContentEncryptInfo->hCryptProv;
        else {
            // Check if the type of and public key algorithm for this
            // recipient is the same as the first recipient's.

            PCMSG_RECIPIENT_ENCODE_INFO prei;

            prei = &pContentEncryptInfo->rgCmsRecipients[0];
            if (CMSG_KEY_TRANS_RECIPIENT == prei->dwRecipientChoice &&
                    ICM_IsSameRecipientPublicKeyAlgorithm(
                        &prei->pKeyTrans->KeyEncryptionAlgorithm,
                        &pKeyTransEncryptInfo->KeyEncryptionAlgorithm))
                hKeyTransProv = pContentEncryptInfo->hCryptProv;
            else {
                // Get default provider associated with the encryption
                // and public key algorithms

                DWORD dwAlgIdPubKey;
                DWORD dwAlgIdEncrypt;
                BYTE rgbIV[IV_MAX_LENGTH];
                DWORD cbIV;
                DWORD dwBitLen;

                if (!ICM_GetEncryptParameters(
                        &pContentEncryptInfo->ContentEncryptionAlgorithm,
                        &dwAlgIdEncrypt,
                        &dwBitLen,
                        rgbIV,
                        &cbIV))
                    goto GetEncryptParametersError;

                ICM_GetCAPI(
                    CRYPT_PUBKEY_ALG_OID_GROUP_ID,
                    &pKeyTransEncryptInfo->KeyEncryptionAlgorithm,
                    &dwAlgIdPubKey);

                hKeyTransProv = I_CryptGetDefaultCryptProvForEncrypt(
                    dwAlgIdPubKey, dwAlgIdEncrypt, dwBitLen);
                if (0 == hKeyTransProv)
                    goto GetDefaultCryptProvError;
            }
        }
    }

    if (hKeyTransProv != pContentEncryptInfo->hCryptProv) {
        // Need to export the hContentEncryptKey from the ContentEncrypt
        // provider and import into the KeyTrans provider
        hContentEncryptKey = ICM_ExportContentEncryptKeyAndImport(
            pContentEncryptInfo,
            hKeyTransProv);
        if (0 == hContentEncryptKey)
            goto ImportContentKeyError;
    } else
        hContentEncryptKey = pContentEncryptInfo->hContentEncryptKey;

    PublicKeyInfo.Algorithm = pKeyTransEncryptInfo->KeyEncryptionAlgorithm;
    PublicKeyInfo.PublicKey = pKeyTransEncodeInfo->RecipientPublicKey;

    if (!CryptImportPublicKeyInfo(
            hKeyTransProv,
            X509_ASN_ENCODING,
            &PublicKeyInfo,
            &hPubKey))
        goto ImportPubKeyError;

    if (!ICM_ExportEncryptedKey(
            hContentEncryptKey,
            hPubKey,
            SIMPLEBLOB,
            ICM_IsSP3CompatibleEncrypt(pContentEncryptInfo),
            &pKeyTransEncryptInfo->EncryptedKey))
        goto ExportEncryptedKeyError;

    fRet = TRUE;

CommonReturn:
    if (hKeyTransProv != pContentEncryptInfo->hCryptProv &&
            hContentEncryptKey)
            CryptDestroyKey(hContentEncryptKey);

    if (hPubKey)
        CryptDestroyKey(hPubKey);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetEncryptParametersError)
TRACE_ERROR(GetDefaultCryptProvError)
TRACE_ERROR(ImportContentKeyError)
TRACE_ERROR(ImportPubKeyError)
TRACE_ERROR(ExportEncryptedKeyError)
}

BOOL
WINAPI
ICM_ExportKeyTrans(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTransEncodeInfo,
    IN OUT PCMSG_KEY_TRANS_ENCRYPT_INFO pKeyTransEncryptInfo
    )
{
    BOOL fRet;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr = NULL;

    LPCSTR pszKeyEncryptOID =
        pKeyTransEncryptInfo->KeyEncryptionAlgorithm.pszObjId;

    if (CryptGetOIDFunctionAddress(
            hExportKeyTransFuncSet,
            X509_ASN_ENCODING,
            pszKeyEncryptOID,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fRet = ((PFN_CMSG_EXPORT_KEY_TRANS) pvFuncAddr)(
            pContentEncryptInfo,
            pKeyTransEncodeInfo,
            pKeyTransEncryptInfo,
            0,                      // dwFlags
            NULL                    // pvReserved
            );
    } else if ((NULL == pKeyTransEncodeInfo->hCryptProv ||
            pKeyTransEncodeInfo->hCryptProv ==
                pContentEncryptInfo->hCryptProv)
                        &&
            CryptGetOIDFunctionAddress(
                hOldStyleExportEncryptKeyFuncSet,
                X509_ASN_ENCODING,
                pszKeyEncryptOID,
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr)
                        &&
#ifdef DEBUG_CRYPT_ASN1
                0 == (ICMTest_GetDebugCryptAsn1Flags() &
                            DEBUG_OSS_CRYPT_ASN1_SAME_ENCRYPT_FLAG)
                        &&
#endif // DEBUG_CRYPT_ASN1
            (void *) ICM_DefaultExportEncryptKey != pvFuncAddr) {
        CERT_PUBLIC_KEY_INFO PublicKeyInfo;
        PBYTE pbData;
        DWORD rgcbData[2] = {0, 0};

        if (ICM_IsSP3CompatibleEncrypt(pContentEncryptInfo))
            rgcbData[1] = CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG;

        PublicKeyInfo.Algorithm = pKeyTransEncryptInfo->KeyEncryptionAlgorithm;
        PublicKeyInfo.PublicKey = pKeyTransEncodeInfo->RecipientPublicKey;
        fRet = ((PFN_CMSG_EXPORT_ENCRYPT_KEY) pvFuncAddr)(
            pContentEncryptInfo->hCryptProv,
            pContentEncryptInfo->hContentEncryptKey,
            &PublicKeyInfo,
            NULL,                       // pbData
            rgcbData);
        if (fRet) {
            if (NULL == (pbData = (PBYTE) ICM_Alloc(rgcbData[0])))
                fRet = FALSE;
            else {
                fRet = ((PFN_CMSG_EXPORT_ENCRYPT_KEY) pvFuncAddr)(
                    pContentEncryptInfo->hCryptProv,
                    pContentEncryptInfo->hContentEncryptKey,
                    &PublicKeyInfo,
                    pbData,
                    rgcbData);
                if (fRet) {
                    pKeyTransEncryptInfo->EncryptedKey.pbData = pbData;
                    pKeyTransEncryptInfo->EncryptedKey.cbData = rgcbData[0];
                } else
                    ICM_Free(pbData);
            }
        }
    } else
        fRet = ICM_DefaultExportKeyTrans(
            pContentEncryptInfo,
            pKeyTransEncodeInfo,
            pKeyTransEncryptInfo,
            0,                      // dwFlags
            NULL                    // pvReserved
            );

    if (hFuncAddr)
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    return fRet;
}


//+-------------------------------------------------------------------------
//  Get the CAPI ALG_ID corresponding to the wrap encryption OID.
//
//  For RC2, if the ASN.1 encryption algorithm has any parameters, decode to
//  get the key bit length.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetWrapEncryptParameters(
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    OUT PDWORD                      pdwAlgIdEncrypt,
    OUT PDWORD                      pdwBitLen           // 0 => default length
    )
{
    BOOL fRet;

    *pdwBitLen = 0;

    if (!ICM_GetCAPI(
            CRYPT_ENCRYPT_ALG_OID_GROUP_ID,
            paiEncrypt,
            pdwAlgIdEncrypt))
        goto GetCAPIError;

    if (CALG_RC2 == *pdwAlgIdEncrypt) {
        // Check if more than just the NULL parameters
        if (2 < paiEncrypt->Parameters.cbData) {
            PBYTE pbEncoded = paiEncrypt->Parameters.pbData;
            DWORD cbEncoded = paiEncrypt->Parameters.cbData;

            // Try to decode as an integer containing the RC2 version
            int iVersion = 0;
            DWORD cbStructInfo = sizeof(iVersion);

            if (!CryptDecodeObject(
                    X509_ASN_ENCODING,
                    X509_INTEGER,
                    pbEncoded,
                    cbEncoded,
                    0,                          // dwFlags
                    &iVersion,
                    &cbStructInfo))
                goto RC2VersionDecodeError;
            if (!ICM_RC2VersionToBitLength(iVersion, pdwBitLen))
                goto RC2VersionToBitLengthError;
        } else
            *pdwBitLen = 40;
    }
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(GetCAPIError, CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(RC2VersionDecodeError)
TRACE_ERROR(RC2VersionToBitLengthError)
}


//+-------------------------------------------------------------------------
//  Get the CAPI ALG_ID and bit length by decoding the DH Encryption Parameters
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetDhWrapEncryptParameters(
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    OUT LPSTR                       *ppszAllocWrapOID,
    OUT PDWORD                      pdwAlgIdWrap,
    OUT PDWORD                      pdwBitLen           // 0 => default length
    )
{
    DWORD dwError = ERROR_SUCCESS;
    BOOL fRet;
    ASN1error_e Asn1Err;
    ASN1decoding_t pDec = ICM_GetDecoder();
    AlgorithmIdentifier *poai = NULL;
    CRYPT_ALGORITHM_IDENTIFIER ai;   ZEROSTRUCT(ai);

    // Decode the DH KeyEncryption Parameters to get the Wrap Encryption
    // Algorithm
    if (0 == paiEncrypt->Parameters.cbData)
        goto NoDhWrapParametersError;

    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&poai,
            AlgorithmIdentifier_PDU,
            paiEncrypt->Parameters.pbData,
            paiEncrypt->Parameters.cbData)))
        goto Asn1DecodeAlgorithmIdentifierError;

    if (!ICM_Asn1FromAlgorithmIdentifier(poai, &ai))
        goto Asn1FromAlgorithmIdentifierError;

    if (!ICM_GetWrapEncryptParameters(&ai, pdwAlgIdWrap, pdwBitLen))
        goto GetWrapEncryptParametersError;
    *ppszAllocWrapOID = ai.pszObjId;
    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeInfo(pDec, AlgorithmIdentifier_PDU, poai);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free(ai.pszObjId);
    *ppszAllocWrapOID = NULL;
    *pdwBitLen = 0;
    *pdwAlgIdWrap = 0;
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(NoDhWrapParametersError, CRYPT_E_UNKNOWN_ALGO)
SET_ERROR_VAR(Asn1DecodeAlgorithmIdentifierError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(Asn1FromAlgorithmIdentifierError)
TRACE_ERROR(GetWrapEncryptParametersError)
}


//+-------------------------------------------------------------------------
//  Get the CAPI ALG_ID corresponding to the wrap encryption OID. Generate
//  default parameters for and encode. For RC2, encode as RC2ParameterVersion
//  integer.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_CreateDefaultWrapEncryptParameters(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN OUT PCRYPT_ALGORITHM_IDENTIFIER paiEncrypt,
    IN PVOID pvEncryptAuxInfo,
    OUT PDWORD pdwAlgIdEncrypt,
    OUT PDWORD pdwBitLen           // 0 => default length
    )
{
    BOOL fRet;

    assert(0 == paiEncrypt->Parameters.cbData);
    *pdwBitLen = 0;
    if (!ICM_GetCAPI(
            CRYPT_ENCRYPT_ALG_OID_GROUP_ID,
            paiEncrypt,
            pdwAlgIdEncrypt))
        goto GetCAPIError;

    if (CALG_RC2 == *pdwAlgIdEncrypt) {
        PCMSG_RC2_AUX_INFO pAuxInfo =
            (PCMSG_RC2_AUX_INFO) pvEncryptAuxInfo;
        CRYPT_ENCODE_PARA EncodePara;
        int iVersion;

        if (pAuxInfo && pAuxInfo->cbSize >= sizeof(CMSG_RC2_AUX_INFO)) {
            DWORD dwVersion;
            *pdwBitLen = pAuxInfo->dwBitLen & AUX_INFO_BIT_LENGTH_MASK;

            if (!ICM_BitLengthToRC2Version(*pdwBitLen, &dwVersion))
                goto BitLengthToRC2VersionError;
            iVersion = dwVersion;
        } else {
            iVersion = CRYPT_RC2_40BIT_VERSION;
            *pdwBitLen = 40;
        }

        ZEROSTRUCT(EncodePara);
        EncodePara.cbSize = sizeof(EncodePara);
        EncodePara.pfnAlloc = pContentEncryptInfo->pfnAlloc;
        EncodePara.pfnFree = pContentEncryptInfo->pfnFree;
        if (!CryptEncodeObjectEx(
                X509_ASN_ENCODING,
                X509_INTEGER,
                &iVersion,
                CRYPT_ENCODE_ALLOC_FLAG,
                &EncodePara,
                (void *) &paiEncrypt->Parameters.pbData,
                &paiEncrypt->Parameters.cbData
                )) goto EncodeError;
    }
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(GetCAPIError, CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(BitLengthToRC2VersionError)
TRACE_ERROR(EncodeError)
}

//+-------------------------------------------------------------------------
//  Get the CAPI ALG_ID corresponding to the wrap encryption OID. 
//  Encode the DH EncryptionAlgorithmIdentifier parameters which is the encoded
//  WrapAlgorithmIdentifier.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_CreateDefaultDhWrapEncryptParameters(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN OUT PCRYPT_ALGORITHM_IDENTIFIER paiEncrypt,
    IN PCRYPT_ALGORITHM_IDENTIFIER paiWrap,
    IN PVOID pvWrapAuxInfo,
    OUT PDWORD pdwAlgIdWrap,
    OUT PDWORD pdwBitLen           // 0 => default length
    )
{
    BOOL fRet;

    CRYPT_ALGORITHM_IDENTIFIER aiWrap;  ZEROSTRUCT(aiWrap);
    AlgorithmIdentifier oaiWrap;

    assert(0 == paiEncrypt->Parameters.cbData);

    if (0 == paiWrap->Parameters.cbData) {
        aiWrap = *paiWrap;
        if (!ICM_CreateDefaultWrapEncryptParameters(
                pContentEncryptInfo,
                &aiWrap,
                pvWrapAuxInfo,
                pdwAlgIdWrap,
                pdwBitLen))
            goto CreateDefaultWrapEncryptParametersError;
        paiWrap = &aiWrap;
    } else {
        if (!ICM_GetWrapEncryptParameters(
                paiWrap,
                pdwAlgIdWrap,
                pdwBitLen))
            goto GetWrapEncryptParametersError;
    }

    // Encode the Wrap Algorithm Identifier
    if (!ICM_Asn1ToAlgorithmIdentifier(
            paiWrap,
            &oaiWrap))
        goto Asn1ToAlgorithmIdentifierError;
    if (!ICM_Asn1Encode(
            AlgorithmIdentifier_PDU,
            &oaiWrap,
            &paiEncrypt->Parameters))
        goto EncodeAlgorithmIdentifierError;

    fRet = TRUE;
CommonReturn:
    ICM_Free(aiWrap.Parameters.pbData);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(CreateDefaultWrapEncryptParametersError)
TRACE_ERROR(GetWrapEncryptParametersError)
TRACE_ERROR(Asn1ToAlgorithmIdentifierError)
TRACE_ERROR(EncodeAlgorithmIdentifierError)
}

BOOL
WINAPI
ICM_PadEncodedOctets(
    IN DWORD cbMaxContents,
    IN OUT BYTE **ppbEncoded,
    IN OUT DWORD *pcbEncoded
    )
{
    BOOL fRet;
    DWORD cbEncoded = *pcbEncoded;
    DWORD cbMaxEncoded;
    DWORD cbLength;

    ICM_GetLengthOctets(cbMaxContents, NULL, &cbLength);
    cbMaxEncoded = 1 + cbLength + cbMaxContents;
    if (cbMaxEncoded > cbEncoded) {
        BYTE *pbMaxEncoded;
        BYTE *pbEncoded;

        if (NULL == (pbMaxEncoded = (BYTE *) ICM_Alloc(cbMaxEncoded)))
            goto OutOfMemory;

        pbEncoded = *ppbEncoded;
        memcpy(pbMaxEncoded, pbEncoded, cbEncoded);
        memset(pbMaxEncoded + cbEncoded, 0, cbMaxEncoded - cbEncoded);
        ICM_Free(pbEncoded);
        *ppbEncoded = pbMaxEncoded;
        *pcbEncoded = cbMaxEncoded;
    } else if (cbMaxEncoded < cbEncoded)
        goto InvalidMaxEncodedLength;

    fRet = TRUE;
CommonReturn:
    return fRet;
ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(OutOfMemory)
SET_ERROR(InvalidMaxEncodedLength, ERROR_INVALID_DATA)
}


#ifndef DH1
#define DH1 (((DWORD)'D'<<8)+((DWORD)'H'<<16)+((DWORD)'1'<<24))
#endif

HCRYPTKEY
WINAPI
ICM_GenerateEphemeralDh(
    IN HCRYPTPROV hProv,
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pKeyAgreeEncodeInfo,
    IN OUT PCMSG_KEY_AGREE_ENCRYPT_INFO pKeyAgreeEncryptInfo,
    OUT DWORD *pcbP
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HCRYPTKEY hEphemeralKey = 0;
    PCRYPT_ALGORITHM_IDENTIFIER paiEphemeral =
        pKeyAgreeEncodeInfo->pEphemeralAlgorithm;
    PCERT_PUBLIC_KEY_INFO pPubKeyInfo =
        &pKeyAgreeEncryptInfo->OriginatorPublicKeyInfo;
    PCERT_X942_DH_PARAMETERS pDhParameters = NULL;
    PUBLICKEYSTRUC *pPubKeyStruc = NULL;
    DWORD cbPubKeyStruc;
    BYTE *pbKeyBlob;
    DHPUBKEY *pCspPubKey;
    DWORD cbP;
    PCRYPT_UINT_BLOB pGBlob;
    BYTE *pbY;
    DWORD cbY;
    CRYPT_UINT_BLOB YBlob;
    CRYPT_ENCODE_PARA EncodePara;

    assert(CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE ==
        pKeyAgreeEncodeInfo->dwKeyChoice);
    if (NULL == (pDhParameters =
            (PCERT_X942_DH_PARAMETERS) ICM_AllocAndDecodeObject(
                X942_DH_PARAMETERS,
                paiEphemeral->Parameters.pbData,
                paiEphemeral->Parameters.cbData)))
        goto DhParametersDecodeError;

    cbP = pDhParameters->p.cbData;
    *pcbP = cbP;
    
    if (!CryptGenKey(
            hProv,
            CALG_DH_EPHEM,
            ((cbP * 8) << 16) | CRYPT_EXPORTABLE | CRYPT_PREGEN,
            &hEphemeralKey))
        goto GenEphemeralKeyError;

    if (!CryptSetKeyParam(
            hEphemeralKey,
            KP_P,
            (PBYTE) &pDhParameters->p,
            0))                 // dwFlags
        goto SetPError;

    // Note, the length of G can be less than length P. Pad with leading
    // zeroes in little endian form.
    if (pDhParameters->g.cbData >= cbP)
        pGBlob = &pDhParameters->g;
    else {
        DWORD cbG = pDhParameters->g.cbData;

        // We are done using P parameter. Overwrite with the G parameter and
        // pad with leading zeroes in little endian form.
        pGBlob = &pDhParameters->p;
        memcpy(pGBlob->pbData, pDhParameters->g.pbData, cbG);
        memset(pGBlob->pbData + cbG, 0, cbP - cbG);
    }
    if (!CryptSetKeyParam(
            hEphemeralKey,
            KP_G,
            (PBYTE) pGBlob,
            0))                 // dwFlags
        goto SetGError;

    if (0 < pDhParameters->q.cbData) {
        if (!CryptSetKeyParam(
                hEphemeralKey,
                KP_Q,
                (PBYTE) &pDhParameters->q,
                0))                 // dwFlags
            goto SetQError;
    }

    if (!CryptSetKeyParam(
            hEphemeralKey,
            KP_X,
            NULL,               // pbData
            0))                 // dwFlags
        goto SetXError;

    // Export the public key to get Y
    cbPubKeyStruc = 0;
    if (!CryptExportKey(
            hEphemeralKey,
            0,              // hPubKey
            PUBLICKEYBLOB,
            0,              // dwFlags
            NULL,           // pbData
            &cbPubKeyStruc
            ) || (cbPubKeyStruc == 0))
        goto ExportPublicKeyBlobError;
    if (NULL == (pPubKeyStruc = (PUBLICKEYSTRUC *) ICM_Alloc(cbPubKeyStruc)))
        goto OutOfMemory;
    if (!CryptExportKey(
            hEphemeralKey,
            0,              // hPubKey
            PUBLICKEYBLOB,
            0,              // dwFlags
            (BYTE *) pPubKeyStruc,
            &cbPubKeyStruc
            ))
        goto ExportPublicKeyBlobError;


    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - DHPUBKEY
    //  - rgbY[cbKey]
    pbKeyBlob = (BYTE *) pPubKeyStruc;
    pCspPubKey = (DHPUBKEY *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
    pbY = pbKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY);
    cbY = pCspPubKey->bitlen / 8;

    if (cbPubKeyStruc < sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY) + cbY)
        goto InvalidEphemeralKey;
    if (pPubKeyStruc->bType != PUBLICKEYBLOB)
        goto InvalidEphemeralKey;
    if (pCspPubKey->magic != DH1)
        goto InvalidEphemeralKey;
    if (cbY != cbP)
        goto InvalidEphemeralKey;

    ZEROSTRUCT(EncodePara);
    EncodePara.cbSize = sizeof(EncodePara);
    EncodePara.pfnAlloc = pContentEncryptInfo->pfnAlloc;
    EncodePara.pfnFree = pContentEncryptInfo->pfnFree;
    YBlob.pbData = pbY;
    YBlob.cbData = cbY;
    if (!CryptEncodeObjectEx(
            X509_ASN_ENCODING,
            X509_DH_PUBLICKEY,
            &YBlob,
            CRYPT_ENCODE_ALLOC_FLAG,
            &EncodePara,
            (void *) &pPubKeyInfo->PublicKey.pbData,
            &pPubKeyInfo->PublicKey.cbData
            ))
        goto EncodeDHPublicKeyError;

    pKeyAgreeEncryptInfo->dwOriginatorChoice =
        CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY;
    pPubKeyInfo->Algorithm.pszObjId = paiEphemeral->pszObjId;
    pKeyAgreeEncryptInfo->dwFlags |=
        CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_BITS_FLAG;

    if (pContentEncryptInfo->dwEncryptFlags &
            CMSG_CONTENT_ENCRYPT_PAD_ENCODED_LEN_FLAG) {
        if (!ICM_PadEncodedOctets(
                cbY + 1,
                &pPubKeyInfo->PublicKey.pbData,
                &pPubKeyInfo->PublicKey.cbData
                ))
            goto PadEncodedOctetsError;
    }


CommonReturn:
    ICM_Free(pDhParameters);
    ICM_Free(pPubKeyStruc);
    ICM_SetLastError(dwError);
    return hEphemeralKey;

ErrorReturn:
    dwError = GetLastError();
    if (hEphemeralKey) {
        CryptDestroyKey(hEphemeralKey);
        hEphemeralKey = 0;
    }
    goto CommonReturn;

TRACE_ERROR(DhParametersDecodeError)
TRACE_ERROR(GenEphemeralKeyError)
TRACE_ERROR(SetPError)
TRACE_ERROR(SetGError)
TRACE_ERROR(SetQError)
TRACE_ERROR(SetXError)
TRACE_ERROR(ExportPublicKeyBlobError)
SET_ERROR(InvalidEphemeralKey, NTE_BAD_PUBLIC_KEY)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(EncodeDHPublicKeyError)
TRACE_ERROR(PadEncodedOctetsError)
}

HCRYPTKEY
WINAPI
ICM_ImportDhAgreeKey(
    IN HCRYPTPROV hKeyAgreeProv,
    IN HCRYPTKEY hMyKey,
    IN DWORD cbP,
    IN PCRYPT_BIT_BLOB pPublicKey,
    IN LPSTR pszWrapOID,
    IN ALG_ID AlgidWrap,
    IN DWORD dwBitLen,
    IN PCRYPT_DATA_BLOB pUserKeyingMaterial
    )
{
    DWORD dwError = ERROR_SUCCESS;
    HCRYPTKEY hAgreeKey = 0;
    PCRYPT_UINT_BLOB pDhPubKey = NULL;
    PBYTE pbKeyBlob = NULL;
    DWORD cbKeyBlob;
    PUBLICKEYSTRUC *pPubKeyStruc;
    DHPUBKEY *pCspPubKey;
    DWORD cbY;
    PBYTE pbKey;

    CMS_DH_KEY_INFO CmsDhKeyInfo;    ZEROSTRUCT(CmsDhKeyInfo);

    if (NULL == (pDhPubKey = (PCRYPT_UINT_BLOB) ICM_AllocAndDecodeObject(
            X509_DH_PUBLICKEY,
            pPublicKey->pbData,
            pPublicKey->cbData)))
        goto DecodePubKeyError;

    // The CAPI public key representation consists of the following sequence:
    //  - PUBLICKEYSTRUC
    //  - DHPUBKEY
    //  - rgbY[cbP]

    cbY = pDhPubKey->cbData;
    if (0 == cbY || cbY > cbP)
        goto InvalidDhPubKeyError;
    cbKeyBlob = sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY) + cbP;
    if (NULL == (pbKeyBlob = (PBYTE) ICM_Alloc(cbKeyBlob)))
        goto OutOfMemory;

    pPubKeyStruc = (PUBLICKEYSTRUC *) pbKeyBlob;
    pCspPubKey = (DHPUBKEY *) (pbKeyBlob + sizeof(PUBLICKEYSTRUC));
    pbKey = pbKeyBlob + sizeof(PUBLICKEYSTRUC) + sizeof(DHPUBKEY);
    
    // PUBLICKEYSTRUC
    pPubKeyStruc->bType = PUBLICKEYBLOB;
    pPubKeyStruc->bVersion = CUR_BLOB_VERSION;
    pPubKeyStruc->reserved = 0;
    pPubKeyStruc->aiKeyAlg = CALG_DH_SF;
    // DHPUBKEY
    pCspPubKey->magic = DH1;
    pCspPubKey->bitlen = cbP * 8;
    // rgbY[cbP]
    memcpy(pbKey, pDhPubKey->pbData, cbY);
    if (cbP > cbY)
        memset(pbKey + cbY, 0, cbP - cbY);

    if (!CryptImportKey(
            hKeyAgreeProv,
            pbKeyBlob,
            cbKeyBlob,
            hMyKey,
            0,                      // dwFlags
            &hAgreeKey)) {
        hAgreeKey = 0;
        goto ImportKeyError;
    }

    CmsDhKeyInfo.dwVersion = sizeof(CmsDhKeyInfo);
    CmsDhKeyInfo.Algid = AlgidWrap;
    CmsDhKeyInfo.pszContentEncObjId = pszWrapOID;
    CmsDhKeyInfo.PubInfo = *pUserKeyingMaterial;
    // CmsDhKeyInfo.pReserved

    if (!CryptSetKeyParam(
            hAgreeKey,
            KP_CMS_DH_KEY_INFO,
            (PBYTE) &CmsDhKeyInfo,
            (CALG_RC2 == AlgidWrap) ? (dwBitLen << 16) : 0))     // dwFlags
        goto SetCmsDhKeyInfoError;

    if (CALG_RC2 == AlgidWrap && 0 != dwBitLen) {
        if (!CryptSetKeyParam(
                hAgreeKey,
                KP_EFFECTIVE_KEYLEN,
                (PBYTE) &dwBitLen,
                0))                     // dwFlags
            goto SetEffectiveKeyLenError;
    }

CommonReturn:
    ICM_Free(pDhPubKey);
    ICM_Free(pbKeyBlob);
    ICM_SetLastError(dwError);
    return hAgreeKey;

ErrorReturn:
    dwError = GetLastError();
    if (hAgreeKey) {
        CryptDestroyKey(hAgreeKey);
        hAgreeKey = 0;
    }
    goto CommonReturn;

TRACE_ERROR(DecodePubKeyError)
SET_ERROR(InvalidDhPubKeyError, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(ImportKeyError)
TRACE_ERROR(SetCmsDhKeyInfoError)
TRACE_ERROR(SetEffectiveKeyLenError)
}

BOOL
WINAPI
ICM_DefaultExportKeyAgree(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pKeyAgreeEncodeInfo,
    IN OUT PCMSG_KEY_AGREE_ENCRYPT_INFO pKeyAgreeEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fRet;
    DWORD dwError = ERROR_SUCCESS;
    HCRYPTPROV hKeyAgreeProv = 0;           // Doesn't need to be released
    HCRYPTKEY hContentEncryptKey = 0;
    HCRYPTKEY hEphemeralKey = 0;
    HCRYPTKEY hAgreeKey = 0;
    DWORD cbP;
    PCRYPT_ALGORITHM_IDENTIFIER paiEncrypt =
        &pKeyAgreeEncryptInfo->KeyEncryptionAlgorithm;
    LPSTR pszAllocWrapOID = NULL;
    LPSTR pszWrapOID;
    DWORD dwAlgIdWrap;
    DWORD dwBitLen;

    DWORD cRecipient;
    PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO *ppRecipientEncryptInfo;
    PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO *ppRecipientEncodeInfo;

    assert(CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE ==
        pKeyAgreeEncodeInfo->dwKeyChoice);
    if (CMSG_KEY_AGREE_EPHEMERAL_KEY_CHOICE != pKeyAgreeEncodeInfo->dwKeyChoice)
        goto InvalidKeyAgreeKeyChoice;

    if (0 == paiEncrypt->Parameters.cbData) {
        PCRYPT_ALGORITHM_IDENTIFIER paiWrap =
            &pKeyAgreeEncodeInfo->KeyWrapAlgorithm;

        if (!ICM_CreateDefaultDhWrapEncryptParameters(
                pContentEncryptInfo,
                paiEncrypt,
                paiWrap,
                pKeyAgreeEncodeInfo->pvKeyWrapAuxInfo,
                &dwAlgIdWrap,
                &dwBitLen))
            goto CreateDefaultDhWrapEncryptParametersError;
        assert(paiEncrypt->Parameters.cbData);
        pKeyAgreeEncryptInfo->dwFlags |= CMSG_KEY_AGREE_ENCRYPT_FREE_PARA_FLAG;
        pszWrapOID = paiWrap->pszObjId;
    } else {
        if (!ICM_GetDhWrapEncryptParameters(
                paiEncrypt,
                &pszAllocWrapOID,
                &dwAlgIdWrap,
                &dwBitLen))
            goto GetDhWrapEncryptParametersError;
        pszWrapOID = pszAllocWrapOID;
    }

    hKeyAgreeProv = pKeyAgreeEncodeInfo->hCryptProv;
    if (0 == hKeyAgreeProv) {
        if (0 == pKeyAgreeEncryptInfo->dwRecipientIndex)
            hKeyAgreeProv = pContentEncryptInfo->hCryptProv;
        else {
            // Check if the type of and public key algorithm for this
            // recipient is the same as the first recipient's.

            PCMSG_RECIPIENT_ENCODE_INFO prei;

            prei = &pContentEncryptInfo->rgCmsRecipients[0];
            if (CMSG_KEY_AGREE_RECIPIENT == prei->dwRecipientChoice &&
                    ICM_IsSameRecipientPublicKeyAlgorithm(
                        &prei->pKeyAgree->KeyEncryptionAlgorithm,
                        paiEncrypt))
                hKeyAgreeProv = pContentEncryptInfo->hCryptProv;
            else {
                // Get default provider associated with the
                // key encryption algorithm
                DWORD dwAlgIdPubKey;

                if (!ICM_GetCAPI(
                        CRYPT_PUBKEY_ALG_OID_GROUP_ID,
                        paiEncrypt,
                        &dwAlgIdPubKey))
                    goto GetPublicKeyAlgIdError;

                hKeyAgreeProv = I_CryptGetDefaultCryptProvForEncrypt(
                    dwAlgIdPubKey, dwAlgIdWrap, dwBitLen);
                if (0 == hKeyAgreeProv)
                    goto GetDefaultCryptProvError;
            }
        }
    }

    if (hKeyAgreeProv != pContentEncryptInfo->hCryptProv) {
        // Need to export the hContentEncryptKey from the ContentEncrypt
        // provider and import into the KeyAgree provider
        hContentEncryptKey = ICM_ExportContentEncryptKeyAndImport(
            pContentEncryptInfo,
            hKeyAgreeProv);
        if (0 == hContentEncryptKey)
            goto ImportContentKeyError;
    } else
        hContentEncryptKey = pContentEncryptInfo->hContentEncryptKey;

    if (0 == (hEphemeralKey = ICM_GenerateEphemeralDh(
            hKeyAgreeProv,
            pContentEncryptInfo,
            pKeyAgreeEncodeInfo,
            pKeyAgreeEncryptInfo,
            &cbP)))
        goto GenerateEphemeralDhError;

    cRecipient = pKeyAgreeEncryptInfo->cKeyAgreeKeyEncryptInfo;
    ppRecipientEncryptInfo = pKeyAgreeEncryptInfo->rgpKeyAgreeKeyEncryptInfo;
    ppRecipientEncodeInfo = pKeyAgreeEncodeInfo->rgpRecipientEncryptedKeys;
    for ( ; 0 < cRecipient;
                    cRecipient--,
                    ppRecipientEncryptInfo++,
                    ppRecipientEncodeInfo++) {
        if (0 == (hAgreeKey = ICM_ImportDhAgreeKey(
                hKeyAgreeProv,
                hEphemeralKey,
                cbP,
                &(*ppRecipientEncodeInfo)->RecipientPublicKey,
                pszWrapOID,
                dwAlgIdWrap,
                dwBitLen,
                &pKeyAgreeEncodeInfo->UserKeyingMaterial
                )))
            goto ImportDhAgreeKeyError;

        if (!ICM_ExportEncryptedKey(
                hContentEncryptKey,
                hAgreeKey,
                SYMMETRICWRAPKEYBLOB,
                FALSE,                  // fAllowSP3CompatibleEncrypt
                &(*ppRecipientEncryptInfo)->EncryptedKey))
            goto ExportEncryptedKeyError;

        CryptDestroyKey(hAgreeKey);
        hAgreeKey = 0;
    }

    fRet = TRUE;

CommonReturn:
    ICM_Free(pszAllocWrapOID);

    if (hKeyAgreeProv != pContentEncryptInfo->hCryptProv &&
            hContentEncryptKey)
        CryptDestroyKey(hContentEncryptKey);
    if (hAgreeKey)
        CryptDestroyKey(hAgreeKey);
    if (hEphemeralKey)
        CryptDestroyKey(hEphemeralKey);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidKeyAgreeKeyChoice, E_INVALIDARG)
TRACE_ERROR(CreateDefaultDhWrapEncryptParametersError)
TRACE_ERROR(GetDhWrapEncryptParametersError)
TRACE_ERROR(GetPublicKeyAlgIdError)
TRACE_ERROR(GetDefaultCryptProvError)
TRACE_ERROR(ImportContentKeyError)
TRACE_ERROR(GenerateEphemeralDhError)
TRACE_ERROR(ImportDhAgreeKeyError)
TRACE_ERROR(ExportEncryptedKeyError)
}

BOOL
WINAPI
ICM_ExportKeyAgree(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pKeyAgreeEncodeInfo,
    IN OUT PCMSG_KEY_AGREE_ENCRYPT_INFO pKeyAgreeEncryptInfo
    )
{
    BOOL fRet;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    if (CryptGetOIDFunctionAddress(
            hExportKeyAgreeFuncSet,
            X509_ASN_ENCODING,
            pKeyAgreeEncryptInfo->KeyEncryptionAlgorithm.pszObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fRet = ((PFN_CMSG_EXPORT_KEY_AGREE) pvFuncAddr)(
            pContentEncryptInfo,
            pKeyAgreeEncodeInfo,
            pKeyAgreeEncryptInfo,
            0,                      // dwFlags
            NULL                    // pvReserved
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else
        fRet = ICM_DefaultExportKeyAgree(
            pContentEncryptInfo,
            pKeyAgreeEncodeInfo,
            pKeyAgreeEncryptInfo,
            0,                      // dwFlags
            NULL                    // pvReserved
            );

    return fRet;
}

BOOL
WINAPI
ICM_DefaultExportMailList(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO pMailListEncodeInfo,
    IN OUT PCMSG_MAIL_LIST_ENCRYPT_INFO pMailListEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fRet;
    DWORD dwError = ERROR_SUCCESS;

    HCRYPTPROV hMailListProv = 0;           // not released
    HCRYPTKEY hContentEncryptKey = 0;       // destroy if exported/imported
    HCRYPTKEY hKeyEncryptionKey = 0;        // not destroyed
    PCRYPT_ALGORITHM_IDENTIFIER paiEncrypt =
        &pMailListEncryptInfo->KeyEncryptionAlgorithm;
    DWORD dwAlgIdEncrypt;
    DWORD dwBitLen;

    hMailListProv = pMailListEncodeInfo->hCryptProv;
    switch (pMailListEncodeInfo->dwKeyChoice) {
        case CMSG_MAIL_LIST_HANDLE_KEY_CHOICE:
            hKeyEncryptionKey = pMailListEncodeInfo->hKeyEncryptionKey;
            assert(hMailListProv && hKeyEncryptionKey);
            if (0 == hMailListProv || 0 == hKeyEncryptionKey)
                goto InvalidMailListHandleKeyPara;
            break;
        default:
            goto InvalidMailListKeyChoice;
    }

    if (0 == paiEncrypt->Parameters.cbData) {
        if (!ICM_CreateDefaultWrapEncryptParameters(
                pContentEncryptInfo,
                paiEncrypt,
                pMailListEncodeInfo->pvKeyEncryptionAuxInfo,
                &dwAlgIdEncrypt,
                &dwBitLen))
            goto CreateDefaultWrapEncryptParametersError;
        if (paiEncrypt->Parameters.cbData)
            pMailListEncryptInfo->dwFlags |=
                CMSG_MAIL_LIST_ENCRYPT_FREE_PARA_FLAG;
    } else {
        if (!ICM_GetWrapEncryptParameters(
                paiEncrypt,
                &dwAlgIdEncrypt,
                &dwBitLen))
            goto GetWrapEncryptParametersError;
    }


    if (hMailListProv != pContentEncryptInfo->hCryptProv) {
        // Need to export the hContentEncryptKey from the ContentEncrypt
        // provider and import into the MailList provider
        hContentEncryptKey = ICM_ExportContentEncryptKeyAndImport(
            pContentEncryptInfo,
            hMailListProv);
        if (0 == hContentEncryptKey)
            goto ImportContentKeyError;
    } else
        hContentEncryptKey = pContentEncryptInfo->hContentEncryptKey;

    if (CALG_RC2 == dwAlgIdEncrypt && 0 != dwBitLen)
        // Silently ignore any errors. Not supported in earlier versions
        CryptSetKeyParam(
            hKeyEncryptionKey,
            KP_EFFECTIVE_KEYLEN,
            (PBYTE) &dwBitLen,
            0);                 // dwFlags

    if (!ICM_ExportEncryptedKey(
            hContentEncryptKey,
            hKeyEncryptionKey,
            SYMMETRICWRAPKEYBLOB,
            FALSE,                  // fAllowSP3CompatibleEncrypt
            &pMailListEncryptInfo->EncryptedKey))
        goto ExportEncryptedKeyError;

    fRet = TRUE;

CommonReturn:
    if (hMailListProv != pContentEncryptInfo->hCryptProv &&
            hContentEncryptKey)
        CryptDestroyKey(hContentEncryptKey);

    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidMailListHandleKeyPara, E_INVALIDARG)
SET_ERROR(InvalidMailListKeyChoice, E_INVALIDARG)
TRACE_ERROR(CreateDefaultWrapEncryptParametersError)
TRACE_ERROR(GetWrapEncryptParametersError)
TRACE_ERROR(ImportContentKeyError)
TRACE_ERROR(ExportEncryptedKeyError)
}

BOOL
WINAPI
ICM_ExportMailList(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO pMailListEncodeInfo,
    IN OUT PCMSG_MAIL_LIST_ENCRYPT_INFO pMailListEncryptInfo
    )
{
    BOOL fRet;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    if (CryptGetOIDFunctionAddress(
            hExportMailListFuncSet,
            X509_ASN_ENCODING,
            pMailListEncryptInfo->KeyEncryptionAlgorithm.pszObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fRet = ((PFN_CMSG_EXPORT_MAIL_LIST) pvFuncAddr)(
            pContentEncryptInfo,
            pMailListEncodeInfo,
            pMailListEncryptInfo,
            0,                      // dwFlags
            NULL                    // pvReserved
            );
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else
        fRet = ICM_DefaultExportMailList(
            pContentEncryptInfo,
            pMailListEncodeInfo,
            pMailListEncryptInfo,
            0,                      // dwFlags
            NULL                    // pvReserved
            );

    return fRet;
}

//+-------------------------------------------------------------------------
//  Default export of the encryption key
//
//  Note, pcbData[1] contains dwEncryptFlags, where,
//  CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG may be set to disable the reversing
//  of the encoded, encrypted symmetric key.
//
//  rgcbData[1] is the dwEncryptFlags passed from ICM_DefaultGenEncryptKey
//
//  OldStyle
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultExportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    OUT PBYTE                       pbData,
    IN OUT DWORD                    rgcbData[2])
{
    BOOL            fRet;
    DWORD           dwError = ERROR_SUCCESS;
    HCRYPTKEY       hPubKey = NULL;
    CRYPT_DATA_BLOB EncryptedKey;       ZEROSTRUCT(EncryptedKey);
    DWORD           cb;

    if (!CryptImportPublicKeyInfo(
            hCryptProv,
            X509_ASN_ENCODING,
            pPublicKeyInfo,
            &hPubKey))
        goto ImportKeyError;

    if (!ICM_ExportEncryptedKey(
            hEncryptKey,
            hPubKey,
            SIMPLEBLOB,
            0 != (rgcbData[1] & CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG),
            &EncryptedKey))
        goto ExportEncryptedKeyError;

    fRet = TRUE;
    cb = EncryptedKey.cbData;
    if (pbData) {
        if (rgcbData[0] < cb) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fRet = FALSE;
        } else
            memcpy(pbData, EncryptedKey.pbData, cb);
    }

CommonReturn:
    rgcbData[0] = cb;
    ICM_Free(EncryptedKey.pbData);
    if (hPubKey)
        CryptDestroyKey(hPubKey);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    cb = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(ImportKeyError)
TRACE_ERROR(ExportEncryptedKeyError)
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
PCMSG_RECIPIENT_ENCODE_INFO
WINAPI
ICM_CreateCmsRecipientEncodeInfos(
    IN DWORD cRecipients,
    IN PCERT_INFO *rgpCertInfoRecipients
    )
{
    PCMSG_RECIPIENT_ENCODE_INFO rgCmsRecipients = NULL;
    PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO rgKeyTrans;
    DWORD cbCmsRecipients;
    DWORD i;

    assert(cRecipients && rgpCertInfoRecipients);
    cbCmsRecipients = sizeof(CMSG_RECIPIENT_ENCODE_INFO) * cRecipients +
        sizeof(CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO) * cRecipients;

    if (NULL == (rgCmsRecipients = (PCMSG_RECIPIENT_ENCODE_INFO) ICM_AllocZero(
            cbCmsRecipients)))
        return NULL;

    rgKeyTrans = (PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO)
        (((PBYTE) rgCmsRecipients) +
            sizeof(CMSG_RECIPIENT_ENCODE_INFO) * cRecipients);

    for (i = 0; i < cRecipients; i++) {
        rgCmsRecipients[i].dwRecipientChoice = CMSG_KEY_TRANS_RECIPIENT;
        rgCmsRecipients[i].pKeyTrans = &rgKeyTrans[i];
        rgKeyTrans[i].cbSize = sizeof(CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO);
        rgKeyTrans[i].KeyEncryptionAlgorithm =
            rgpCertInfoRecipients[i]->SubjectPublicKeyInfo.Algorithm;
        // rgKeyTrans[i].pvKeyEncryptionAuxInfo =
        // rgKeyTrans[i].hCryptProv =
        rgKeyTrans[i].RecipientPublicKey =
            rgpCertInfoRecipients[i]->SubjectPublicKeyInfo.PublicKey;

        ICM_GetCertIdFromCertInfo(rgpCertInfoRecipients[i],
            &rgKeyTrans[i].RecipientId);
    }

    return rgCmsRecipients;
}

void
WINAPI
ICM_FreeContentEncryptInfo(
    IN PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedEncodeInfo,
    IN OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo
    )
{
    DWORD dwErr = GetLastError();

    if (pEnvelopedEncodeInfo->rgpRecipients) {
        ICM_Free(pContentEncryptInfo->rgCmsRecipients);
        pContentEncryptInfo->rgCmsRecipients = NULL;
    }

    if (pContentEncryptInfo->hContentEncryptKey) {
        CryptDestroyKey(pContentEncryptInfo->hContentEncryptKey);
        pContentEncryptInfo->hContentEncryptKey = 0;
    }

    if (pContentEncryptInfo->dwFlags &
            CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG) {
        pContentEncryptInfo->dwFlags &=
            ~CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG;
        assert(pContentEncryptInfo->hCryptProv);
        CryptReleaseContext(pContentEncryptInfo->hCryptProv, 0);
        pContentEncryptInfo->hCryptProv = 0;
    }

    if (pContentEncryptInfo->dwFlags &
            CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG) {
        pContentEncryptInfo->dwFlags &=
            ~CMSG_CONTENT_ENCRYPT_FREE_PARA_FLAG;
        assert(
            pContentEncryptInfo->ContentEncryptionAlgorithm.Parameters.cbData
                &&
            pContentEncryptInfo->ContentEncryptionAlgorithm.Parameters.pbData);
        ICM_Free(
            pContentEncryptInfo->ContentEncryptionAlgorithm.Parameters.pbData);
        pContentEncryptInfo->ContentEncryptionAlgorithm.Parameters.cbData = 0;
        pContentEncryptInfo->ContentEncryptionAlgorithm.Parameters.pbData = NULL;
    }

    SetLastError(dwErr);
}



BOOL
WINAPI
ICM_InitializeContentEncryptInfo(
    IN PCMSG_ENVELOPED_ENCODE_INFO pEnvelopedEncodeInfo,
    OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo
    )
{
    BOOL fRet;
    DWORD cRecipients;

    memset(pContentEncryptInfo, 0, sizeof(*pContentEncryptInfo));
    pContentEncryptInfo->cbSize = sizeof(*pContentEncryptInfo);
    pContentEncryptInfo->hCryptProv =
        pEnvelopedEncodeInfo->hCryptProv;
    pContentEncryptInfo->ContentEncryptionAlgorithm =
        pEnvelopedEncodeInfo->ContentEncryptionAlgorithm;
    pContentEncryptInfo->pvEncryptionAuxInfo =
        pEnvelopedEncodeInfo->pvEncryptionAuxInfo;
    pContentEncryptInfo->pfnAlloc = ICM_Alloc;
    pContentEncryptInfo->pfnFree = ICM_Free;
    // pContentEncryptInfo->dwEncryptFlags =
    // pContentEncryptInfo->hContentEncryptKey =
    // pContentEncryptInfo->dwFlags =

    cRecipients = pEnvelopedEncodeInfo->cRecipients;
    pContentEncryptInfo->cRecipients = cRecipients;

    if (0 == cRecipients)
        ;
    else if (pEnvelopedEncodeInfo->rgpRecipients) {
        if (NULL == (pContentEncryptInfo->rgCmsRecipients =
                ICM_CreateCmsRecipientEncodeInfos(
                    cRecipients, pEnvelopedEncodeInfo->rgpRecipients)))
            goto CreateCmsRecipientEncodeInfosError;
    } else {
        if (sizeof(CMSG_ENVELOPED_ENCODE_INFO) > pEnvelopedEncodeInfo->cbSize)
            goto MissingCmsRecipients;
        pContentEncryptInfo->rgCmsRecipients =
            pEnvelopedEncodeInfo->rgCmsRecipients;
        if (NULL == pContentEncryptInfo->rgCmsRecipients)
            goto MissingCmsRecipients;
    }

    if (!ICM_GenContentEncryptKey(pContentEncryptInfo))
        goto GenContentEncryptKeyError;

    fRet = TRUE;

CommonReturn:
    return fRet;
ErrorReturn:
    ICM_FreeContentEncryptInfo(pEnvelopedEncodeInfo, pContentEncryptInfo);
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(MissingCmsRecipients, E_INVALIDARG)
TRACE_ERROR(CreateCmsRecipientEncodeInfosError)
TRACE_ERROR(GenContentEncryptKeyError)
}


//+-------------------------------------------------------------------------
//  Oss set/free functions
//
//  Assumption: upon entry to the set functions, the Oss data structure has
//  already been zeroed.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_SetOssAny(
    IN PCRYPT_DATA_BLOB pAny,
    IN OUT Any *pOssAny
    )
{
    if (NULL == (pOssAny->value =
            (unsigned char *) ICM_DupMem(pAny->pbData, pAny->cbData)))
        return FALSE;
    pOssAny->length = pAny->cbData;
    return TRUE;
}

void
WINAPI
ICM_FreeOssAny(
    IN OUT Any *pOssAny
    )
{
    if (pOssAny->value) {
        ICM_Free(pOssAny->value);
        pOssAny->value = NULL;
    }
}

BOOL
WINAPI
ICM_SetOssHugeInteger(
    IN PCRYPT_INTEGER_BLOB pHugeInteger,
    IN OUT HugeIntegerType *pOssHugeInteger
    )
{
    return PkiAsn1SetHugeInteger(
        pHugeInteger,
        &pOssHugeInteger->length,
        &pOssHugeInteger->value
        );
}

void
WINAPI
ICM_FreeOssHugeInteger(
    IN OUT HugeIntegerType *pOssHugeInteger
    )
{
    if (pOssHugeInteger->value) {
        PkiAsn1FreeHugeInteger(pOssHugeInteger->value);
        pOssHugeInteger->value = NULL;
    }
}

BOOL
WINAPI
ICM_SetOssOctetString(
    IN PCRYPT_DATA_BLOB pOctetString,
    IN OUT OctetStringType *pOssOctetString
    )
{
    if (NULL == (pOssOctetString->value =
            (unsigned char *) ICM_DupMem(
                pOctetString->pbData, pOctetString->cbData)))
        return FALSE;
    pOssOctetString->length = pOctetString->cbData;
    return TRUE;
}

void
WINAPI
ICM_FreeOssOctetString(
    IN OUT OctetStringType *pOssOctetString
    )
{
    if (pOssOctetString->value) {
        ICM_Free(pOssOctetString->value);
        pOssOctetString->value = NULL;
    }
}

BOOL
WINAPI
ICM_SetOssBitString(
    IN PCRYPT_BIT_BLOB pBitString,
    IN OUT BitStringType *pOssBitString
    )
{
    CRYPT_BIT_BLOB BitString = *pBitString;
    if (NULL == (BitString.pbData = (PBYTE) ICM_DupMem(
            BitString.pbData, BitString.cbData)))
        return FALSE;

    PkiAsn1SetBitString(&BitString, &pOssBitString->length,
        &pOssBitString->value);
    return TRUE;
}

void
WINAPI
ICM_FreeOssBitString(
    IN OUT BitStringType *pOssBitString
    )
{
    if (pOssBitString->value) {
        ICM_Free(pOssBitString->value);
        pOssBitString->value = NULL;
    }
}

static BYTE abDerNULL[] = {5, 0};

BOOL
WINAPI
ICM_SetOssAlgorithmIdentifier(
    IN PCRYPT_ALGORITHM_IDENTIFIER pai,
    IN OUT AlgorithmIdentifier *pOssAlgId
    )
{
    BOOL fRet;
    PBYTE pbData;
    DWORD cbData;

    pOssAlgId->algorithm.count = SIZE_OSS_OID;
    if (!PkiAsn1ToObjectIdentifier(
            pai->pszObjId,
            &pOssAlgId->algorithm.count,
            pOssAlgId->algorithm.value))
        goto PkiAsn1ToObjectIdentifierError;
    pOssAlgId->bit_mask = parameters_present;

    pbData = pai->Parameters.pbData;
    cbData = pai->Parameters.cbData;
    if (0 == cbData) {
        pOssAlgId->parameters.length = sizeof(abDerNULL);
        pOssAlgId->parameters.value = abDerNULL;
    } else {
        if (NULL == (pOssAlgId->parameters.value =
                (unsigned char *) ICM_DupMem(pbData, cbData)))
            goto OutOfMemory;
        pOssAlgId->parameters.length = cbData;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(PkiAsn1ToObjectIdentifierError, CRYPT_E_OID_FORMAT)
TRACE_ERROR(OutOfMemory)
}

void
WINAPI
ICM_FreeOssAlgorithmIdentifier(
    IN OUT AlgorithmIdentifier *pOssAlgId
    )
{
    unsigned char *value;

#ifdef OSS_CRYPT_ASN1
    value = pOssAlgId->parameters.value;
#else
    value = (unsigned char *) pOssAlgId->parameters.value;
#endif  // OSS_CRYPT_ASN1
    if (value && value != abDerNULL) {
        ICM_Free(value);
        pOssAlgId->parameters.value = NULL;
    }
}

BOOL
WINAPI
ICM_SetOssOtherKeyAttribute(
    IN PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr,
    IN OUT OtherKeyAttribute *pOssOtherAttr
    )
{
    BOOL fRet;

    pOssOtherAttr->keyAttrId.count = SIZE_OSS_OID;
    if (!PkiAsn1ToObjectIdentifier(
            pOtherAttr->pszObjId,
            &pOssOtherAttr->keyAttrId.count,
            pOssOtherAttr->keyAttrId.value))
        goto PkiAsn1ToObjectIdentifierError;

    if (pOtherAttr->Value.cbData) {
        if (!ICM_SetOssAny(&pOtherAttr->Value, &pOssOtherAttr->keyAttr))
            goto SetOssAnyError;

        pOssOtherAttr->bit_mask |= keyAttr_present;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(PkiAsn1ToObjectIdentifierError, CRYPT_E_OID_FORMAT)
TRACE_ERROR(SetOssAnyError)
}

void
WINAPI
ICM_FreeOssOtherKeyAttribute(
    OUT OtherKeyAttribute *pOssOtherAttr
    )
{
    ICM_FreeOssAny(&pOssOtherAttr->keyAttr);
}

void
WINAPI
ICM_FreeOssIssuerAndSerialNumber(
    IN OUT IssuerAndSerialNumber *pOssIssuerAndSerialNumber
    )
{
    ICM_FreeOssAny(&pOssIssuerAndSerialNumber->issuer);
    ICM_FreeOssHugeInteger(&pOssIssuerAndSerialNumber->serialNumber);
}

BOOL
WINAPI
ICM_SetOssIssuerAndSerialNumber(
    IN PCERT_ISSUER_SERIAL_NUMBER pIssuerAndSerialNumber,
    IN OUT IssuerAndSerialNumber *pOssIssuerAndSerialNumber
    )
{
    BOOL fRet;

    if (!ICM_SetOssAny(&pIssuerAndSerialNumber->Issuer,
            &pOssIssuerAndSerialNumber->issuer))
        goto SetOssAnyError;

    if (!ICM_SetOssHugeInteger(&pIssuerAndSerialNumber->SerialNumber,
            &pOssIssuerAndSerialNumber->serialNumber))
        goto SetOssHugeIntegerError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    ICM_FreeOssIssuerAndSerialNumber(pOssIssuerAndSerialNumber);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(SetOssAnyError)
TRACE_ERROR(SetOssHugeIntegerError)
}



BOOL
WINAPI
ICM_SetOssCertIdentifier(
    IN PCERT_ID pCertId,
    IN OUT CertIdentifier *pOssCertId
    )
{
    BOOL fRet;

    switch (pCertId->dwIdChoice) {
        case CERT_ID_ISSUER_SERIAL_NUMBER:
            if (!ICM_SetOssIssuerAndSerialNumber(
                    &pCertId->IssuerSerialNumber,
                    &pOssCertId->u.issuerAndSerialNumber
                    ))
                goto SetOssIssuerAndSerialNumberError;
            break;
        case CERT_ID_KEY_IDENTIFIER:
            if (!ICM_SetOssOctetString(
                    &pCertId->KeyId,
                    &pOssCertId->u.subjectKeyIdentifier
                    ))
                goto SetOssOctetStringError;
            break;
        default:
            goto InvalidIdChoice;
    }

    assert(CERT_ID_ISSUER_SERIAL_NUMBER == issuerAndSerialNumber_chosen);
    assert(CERT_ID_KEY_IDENTIFIER == subjectKeyIdentifier_chosen);

    pOssCertId->choice = (unsigned short) pCertId->dwIdChoice;

    fRet = TRUE;
CommonReturn:
    return fRet;
ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(SetOssIssuerAndSerialNumberError)
TRACE_ERROR(SetOssOctetStringError)
SET_ERROR(InvalidIdChoice, E_INVALIDARG)
}

void
WINAPI
ICM_FreeOssCertIdentifier(
    IN OUT CertIdentifier *pOssCertId
    )
{
    switch (pOssCertId->choice) {
        case issuerAndSerialNumber_chosen:
            ICM_FreeOssIssuerAndSerialNumber(
                &pOssCertId->u.issuerAndSerialNumber);
            break;
        case subjectKeyIdentifier_chosen:
            ICM_FreeOssOctetString(&pOssCertId->u.subjectKeyIdentifier);
            break;
        default:
            break;
    }
    pOssCertId->choice = 0;
}

void
WINAPI
ICM_FreeOssOriginatorCertIdentifierOrKey(
    IN OUT OriginatorIdentifierOrKey *pOssOriginator
    )
{
    switch (pOssOriginator->choice) {
        case issuerAndSerialNumber_chosen:
            ICM_FreeOssIssuerAndSerialNumber(
                &pOssOriginator->u.issuerAndSerialNumber);
            break;
        case subjectKeyIdentifier_chosen:
            ICM_FreeOssOctetString(
                &pOssOriginator->u.subjectKeyIdentifier);
            break;
        case originatorKey_chosen:
            ICM_FreeOssAlgorithmIdentifier(
                &pOssOriginator->u.originatorKey.algorithm);
            ICM_FreeOssBitString(
                &pOssOriginator->u.originatorKey.publicKey);
            break;
        default:
            break;
    }
    pOssOriginator->choice = 0;
}

BOOL
WINAPI
ICM_SetOssOriginatorCertIdentifier(
    IN PCERT_ID pCertId,
    IN OUT OriginatorIdentifierOrKey *pOssOriginator
    )
{
    BOOL fRet;

    switch (pCertId->dwIdChoice) {
        case CERT_ID_ISSUER_SERIAL_NUMBER:
            if (!ICM_SetOssIssuerAndSerialNumber(
                    &pCertId->IssuerSerialNumber,
                    &pOssOriginator->u.issuerAndSerialNumber
                    ))
                goto SetOssIssuerAndSerialNumberError;
            pOssOriginator->choice = issuerAndSerialNumber_chosen;
            break;
        case CERT_ID_KEY_IDENTIFIER:
            if (!ICM_SetOssOctetString(
                    &pCertId->KeyId,
                    &pOssOriginator->u.subjectKeyIdentifier
                    ))
                goto SetOssOctetStringError;
            pOssOriginator->choice = subjectKeyIdentifier_chosen;
            break;
        default:
            goto InvalidIdChoice;
    }


    fRet = TRUE;
CommonReturn:
    return fRet;
ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(SetOssIssuerAndSerialNumberError)
TRACE_ERROR(SetOssOctetStringError)
SET_ERROR(InvalidIdChoice, E_INVALIDARG)
}

BOOL
WINAPI
ICM_SetOssOriginatorPublicKey(
    IN PCERT_PUBLIC_KEY_INFO pPublicKeyInfo,
    IN OUT OriginatorIdentifierOrKey *pOssOriginator
    )
{
    BOOL fRet;
    PCRYPT_ALGORITHM_IDENTIFIER pai = &pPublicKeyInfo->Algorithm;
    AlgorithmIdentifier *pOssAlgId = &pOssOriginator->u.originatorKey.algorithm;

    pOssOriginator->choice = originatorKey_chosen;
    if (!ICM_SetOssAlgorithmIdentifier(
            pai,
            pOssAlgId
            ))
        goto SetOssAlgorithmIdentifierError;

    if (0 == pai->Parameters.cbData) {
        DWORD dwFlags;
        PCCRYPT_OID_INFO pOIDInfo;

        dwFlags = 0;
        if (pOIDInfo = CryptFindOIDInfo(
                CRYPT_OID_INFO_OID_KEY,
                pai->pszObjId,
                CRYPT_PUBKEY_ALG_OID_GROUP_ID)) {
            if (1 <= pOIDInfo->ExtraInfo.cbData / sizeof(DWORD)) {
                DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;
                dwFlags = pdwExtra[0];
            }
        }

        if (dwFlags & CRYPT_OID_NO_NULL_ALGORITHM_PARA_FLAG) {
            // NO NULL parameters

            pOssAlgId->bit_mask &= ~parameters_present;
            pOssAlgId->parameters.length = 0;
            pOssAlgId->parameters.value = NULL;
        }
    }

    if (!ICM_SetOssBitString(
            &pPublicKeyInfo->PublicKey,
            &pOssOriginator->u.originatorKey.publicKey
            ))
        goto SetOssBitStringError;

    fRet = TRUE;
CommonReturn:
    return fRet;
ErrorReturn:
    ICM_FreeOssOriginatorCertIdentifierOrKey(pOssOriginator);
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(SetOssAlgorithmIdentifierError)
TRACE_ERROR(SetOssBitStringError)
}

//+-------------------------------------------------------------------------
//  Free the Oss KeyTransRecipientInfo
//--------------------------------------------------------------------------
void
WINAPI
ICM_FreeOssKeyTransRecipientInfo(
    IN OUT KeyTransRecipientInfo *pori
    )
{
    ICM_FreeOssCertIdentifier(&pori->rid);
    ICM_FreeOssAlgorithmIdentifier(&pori->keyEncryptionAlgorithm);
    ICM_Free(pori->encryptedKey.value);
    pori->encryptedKey.value = NULL;
}

//+-------------------------------------------------------------------------
//  Fill the Oss KeyTransRecipientInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillOssKeyTransRecipientInfo(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTransEncodeInfo,
    IN DWORD dwRecipientIndex,
    IN OUT KeyTransRecipientInfo *pori,
#ifdef OSS_CRYPT_ASN1
    IN OUT int *pEnvelopedDataVersion
#else
    IN OUT ASN1int32_t *pEnvelopedDataVersion
#endif  // OSS_CRYPT_ASN1
    )
{
    BOOL fRet;
    CMSG_KEY_TRANS_ENCRYPT_INFO KeyTransEncryptInfo;

    memset(&KeyTransEncryptInfo, 0, sizeof(KeyTransEncryptInfo));
    KeyTransEncryptInfo.cbSize = sizeof(KeyTransEncryptInfo);
    KeyTransEncryptInfo.dwRecipientIndex = dwRecipientIndex;
    KeyTransEncryptInfo.KeyEncryptionAlgorithm =
        pKeyTransEncodeInfo->KeyEncryptionAlgorithm;
    // KeyTransEncryptInfo.EncryptedKey =
    // KeyTransEncryptInfo.dwFlags =

    if (!ICM_ExportKeyTrans(
            pContentEncryptInfo,
            pKeyTransEncodeInfo,
            &KeyTransEncryptInfo
            ))
        goto ExportKeyTransError;
    pori->encryptedKey.length = KeyTransEncryptInfo.EncryptedKey.cbData;
    pori->encryptedKey.value = KeyTransEncryptInfo.EncryptedKey.pbData;

    if (CERT_ID_ISSUER_SERIAL_NUMBER ==
            pKeyTransEncodeInfo->RecipientId.dwIdChoice)
        pori->version = CMSG_KEY_TRANS_PKCS_1_5_VERSION;
    else {
        pori->version = CMSG_KEY_TRANS_CMS_VERSION;
        *pEnvelopedDataVersion = CMSG_ENVELOPED_DATA_CMS_VERSION;
    }

    if (!ICM_SetOssCertIdentifier(
            &pKeyTransEncodeInfo->RecipientId,
            &pori->rid
            ))
        goto SetOssCertIdentifierError;

    if (!ICM_SetOssAlgorithmIdentifier(
            &KeyTransEncryptInfo.KeyEncryptionAlgorithm,
            &pori->keyEncryptionAlgorithm
            ))
        goto SetOssAlgorithmIdentifierError;

    fRet = TRUE;
CommonReturn:
    if (KeyTransEncryptInfo.dwFlags & CMSG_KEY_TRANS_ENCRYPT_FREE_PARA_FLAG)
        ICM_Free(KeyTransEncryptInfo.KeyEncryptionAlgorithm.Parameters.pbData);
    return fRet;

ErrorReturn:
    ICM_FreeOssKeyTransRecipientInfo(pori);
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(ExportKeyTransError)
TRACE_ERROR(SetOssCertIdentifierError)
TRACE_ERROR(SetOssAlgorithmIdentifierError)
}


//+-------------------------------------------------------------------------
//  Free the Oss KeyAgreeRecipientInfo
//--------------------------------------------------------------------------
void
WINAPI
ICM_FreeOssKeyAgreeRecipientInfo(
    IN OUT KeyAgreeRecipientInfo *pori
    )
{
    RecipientEncryptedKey *porek;
    unsigned int count;

    ICM_FreeOssOriginatorCertIdentifierOrKey(&pori->originator);
    ICM_FreeOssOctetString(&pori->ukm);
    ICM_FreeOssAlgorithmIdentifier(&pori->keyEncryptionAlgorithm);

    porek = pori->recipientEncryptedKeys.value;
    if (NULL == porek)
        return;

    for (count = pori->recipientEncryptedKeys.count;
                                                0 < count; count--, porek++) {
        switch (porek->rid.choice) {
            case issuerAndSerialNumber_chosen:
                ICM_FreeOssIssuerAndSerialNumber(
                    &porek->rid.u.issuerAndSerialNumber);
                break;
            case rKeyId_chosen:
                ICM_FreeOssOctetString(
                    &porek->rid.u.rKeyId.subjectKeyIdentifier);
                ICM_FreeOssOtherKeyAttribute(&porek->rid.u.rKeyId.other);
                break;
        }

        ICM_Free(porek->encryptedKey.value);
        porek->encryptedKey.value = NULL;
    }

    ICM_Free(pori->recipientEncryptedKeys.value);
}


//+-------------------------------------------------------------------------
//  Fill the Oss KeyAgreeRecipientInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillOssKeyAgreeRecipientInfo(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pKeyAgreeEncodeInfo,
    IN DWORD dwRecipientIndex,
    IN OUT KeyAgreeRecipientInfo *pori
    )
{
    BOOL fRet;
    DWORD i;
    CMSG_KEY_AGREE_ENCRYPT_INFO KeyAgreeEncryptInfo;
    DWORD cKeyAgreeKeyEncryptInfo;
    PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO *rgpKeyAgreeKeyEncryptInfo = NULL;
    PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO pKeyAgreeKeyEncryptInfo;

    RecipientEncryptedKey *porek;

    memset(&KeyAgreeEncryptInfo, 0, sizeof(KeyAgreeEncryptInfo));
    KeyAgreeEncryptInfo.cbSize = sizeof(KeyAgreeEncryptInfo);
    KeyAgreeEncryptInfo.dwRecipientIndex = dwRecipientIndex;
    KeyAgreeEncryptInfo.KeyEncryptionAlgorithm =
        pKeyAgreeEncodeInfo->KeyEncryptionAlgorithm;
    KeyAgreeEncryptInfo.UserKeyingMaterial =
        pKeyAgreeEncodeInfo->UserKeyingMaterial;
    // KeyAgreeEncryptInfo.dwOriginatorChoice =
    // union
    //    KeyAgreeEncryptInfo.OriginatorCertId =
    //    KeyAgreeEncryptInfo.OriginatorPublicKeyInfo =
    // KeyAgreeEncryptInfo.cKeyAgreeKeyEncryptInfo =
    // KeyAgreeEncryptInfo.rgpKeyAgreeKeyEncryptInfo =
    // KeyAgreeEncryptInfo.dwFlags =

    cKeyAgreeKeyEncryptInfo = pKeyAgreeEncodeInfo->cRecipientEncryptedKeys;
    if (0 == cKeyAgreeKeyEncryptInfo)
        goto NoKeyAgreeKeys;

    if (NULL == (pori->recipientEncryptedKeys.value =
            (RecipientEncryptedKey *) ICM_AllocZero(
                cKeyAgreeKeyEncryptInfo * sizeof(RecipientEncryptedKey))))
        goto OutOfMemory;
    pori->recipientEncryptedKeys.count = cKeyAgreeKeyEncryptInfo;

    if (NULL == (rgpKeyAgreeKeyEncryptInfo =
            (PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO *) ICM_AllocZero(
                cKeyAgreeKeyEncryptInfo *
                    sizeof(PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO) +
                cKeyAgreeKeyEncryptInfo *
                    sizeof(CMSG_KEY_AGREE_KEY_ENCRYPT_INFO))))
        goto OutOfMemory;

    pKeyAgreeKeyEncryptInfo =
        PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO (((PBYTE) rgpKeyAgreeKeyEncryptInfo) +
            cKeyAgreeKeyEncryptInfo * sizeof(PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO));
    for (i = 0; i < cKeyAgreeKeyEncryptInfo; i++, pKeyAgreeKeyEncryptInfo++) {
        rgpKeyAgreeKeyEncryptInfo[i] = pKeyAgreeKeyEncryptInfo;
        pKeyAgreeKeyEncryptInfo->cbSize =
            sizeof(CMSG_KEY_AGREE_KEY_ENCRYPT_INFO);
    }

    KeyAgreeEncryptInfo.cKeyAgreeKeyEncryptInfo = cKeyAgreeKeyEncryptInfo;
    KeyAgreeEncryptInfo.rgpKeyAgreeKeyEncryptInfo = rgpKeyAgreeKeyEncryptInfo;

    if (!ICM_ExportKeyAgree(
            pContentEncryptInfo,
            pKeyAgreeEncodeInfo,
            &KeyAgreeEncryptInfo
            ))
        goto ExportKeyAgreeError;

    for (i = 0, porek = pori->recipientEncryptedKeys.value;
                                 i < cKeyAgreeKeyEncryptInfo; i++, porek++) {
        porek->encryptedKey.length =
            rgpKeyAgreeKeyEncryptInfo[i]->EncryptedKey.cbData;
        porek->encryptedKey.value =
            rgpKeyAgreeKeyEncryptInfo[i]->EncryptedKey.pbData;
    }

    pori->version = CMSG_KEY_AGREE_VERSION;

    switch (KeyAgreeEncryptInfo.dwOriginatorChoice) {
        case CMSG_KEY_AGREE_ORIGINATOR_CERT:
            if (!ICM_SetOssOriginatorCertIdentifier(
                    &KeyAgreeEncryptInfo.OriginatorCertId,
                    &pori->originator
                    ))
                goto SetOssOriginatorCertIdentifierError;
            break;
        case CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY:
            if (!ICM_SetOssOriginatorPublicKey(
                    &KeyAgreeEncryptInfo.OriginatorPublicKeyInfo,
                    &pori->originator
                    ))
                goto SetOssOriginatorPublicKeyError;
            break;
        default:
            goto InvalidOriginatorChoice;
    }

    if (KeyAgreeEncryptInfo.UserKeyingMaterial.cbData) {
        if (!ICM_SetOssOctetString(
                &KeyAgreeEncryptInfo.UserKeyingMaterial,
                &pori->ukm
                ))
            goto SetOssUserKeyingMaterialError;
        pori->bit_mask |= ukm_present;
    }

    if (!ICM_SetOssAlgorithmIdentifier(
            &KeyAgreeEncryptInfo.KeyEncryptionAlgorithm,
            &pori->keyEncryptionAlgorithm
            ))
        goto SetOssAlgorithmIdentifierError;

    for (i = 0, porek = pori->recipientEncryptedKeys.value;
                                 i < cKeyAgreeKeyEncryptInfo; i++, porek++) {
        PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO pEncryptedKeyEncodeInfo =
            pKeyAgreeEncodeInfo->rgpRecipientEncryptedKeys[i];
            

        switch (pEncryptedKeyEncodeInfo->RecipientId.dwIdChoice) {
            case CERT_ID_ISSUER_SERIAL_NUMBER:
                if (!ICM_SetOssIssuerAndSerialNumber(
                        &pEncryptedKeyEncodeInfo->RecipientId.IssuerSerialNumber,
                        &porek->rid.u.issuerAndSerialNumber
                        ))
                    goto SetOssIssuerAndSerialNumberError;
                porek->rid.choice = issuerAndSerialNumber_chosen;
                break;
            case CERT_ID_KEY_IDENTIFIER:
                if (!ICM_SetOssOctetString(
                        &pEncryptedKeyEncodeInfo->RecipientId.KeyId,
                        &porek->rid.u.rKeyId.subjectKeyIdentifier
                        ))
                    goto SetOssOctetStringError;
                porek->rid.choice = rKeyId_chosen;

                if (pEncryptedKeyEncodeInfo->Date.dwLowDateTime ||
                        pEncryptedKeyEncodeInfo->Date.dwHighDateTime) {
                    if (!PkiAsn1ToGeneralizedTime(
                            &pEncryptedKeyEncodeInfo->Date,
                            &porek->rid.u.rKeyId.date
                            ))
                        goto ConvToGeneralizedTimeError;
                    porek->rid.u.rKeyId.bit_mask |= date_present;
                }

                if (pEncryptedKeyEncodeInfo->pOtherAttr) {
                    if (!ICM_SetOssOtherKeyAttribute(
                            pEncryptedKeyEncodeInfo->pOtherAttr,
                            &porek->rid.u.rKeyId.other
                            ))
                        goto SetOssOtherKeyAttributeError;
                    porek->rid.u.rKeyId.bit_mask |= other_present;
                }
                break;
            default:
                goto InvalidRecipientIdChoice;
        }
    }

    fRet = TRUE;
CommonReturn:
    ICM_Free(rgpKeyAgreeKeyEncryptInfo);

    if (KeyAgreeEncryptInfo.dwFlags & CMSG_KEY_AGREE_ENCRYPT_FREE_PARA_FLAG)
        ICM_Free(KeyAgreeEncryptInfo.KeyEncryptionAlgorithm.Parameters.pbData);
    if (KeyAgreeEncryptInfo.dwFlags &
            CMSG_KEY_AGREE_ENCRYPT_FREE_MATERIAL_FLAG)
        ICM_Free(KeyAgreeEncryptInfo.UserKeyingMaterial.pbData);
    if (KeyAgreeEncryptInfo.dwFlags & 
            CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_ALG_FLAG)
        ICM_Free(
            KeyAgreeEncryptInfo.OriginatorPublicKeyInfo.Algorithm.pszObjId);
    if (KeyAgreeEncryptInfo.dwFlags & 
            CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_PARA_FLAG)
        ICM_Free(
            KeyAgreeEncryptInfo.OriginatorPublicKeyInfo.Algorithm.Parameters.pbData);
    if (KeyAgreeEncryptInfo.dwFlags & 
            CMSG_KEY_AGREE_ENCRYPT_FREE_PUBKEY_BITS_FLAG)
        ICM_Free(KeyAgreeEncryptInfo.OriginatorPublicKeyInfo.PublicKey.pbData);

    return fRet;

ErrorReturn:
    ICM_FreeOssKeyAgreeRecipientInfo(pori);
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidOriginatorChoice, E_INVALIDARG)
SET_ERROR(NoKeyAgreeKeys, E_INVALIDARG)
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(ExportKeyAgreeError)
TRACE_ERROR(SetOssOriginatorCertIdentifierError)
TRACE_ERROR(SetOssOriginatorPublicKeyError)
TRACE_ERROR(SetOssUserKeyingMaterialError)
TRACE_ERROR(SetOssAlgorithmIdentifierError)
TRACE_ERROR(SetOssIssuerAndSerialNumberError)
TRACE_ERROR(SetOssOctetStringError)
TRACE_ERROR(ConvToGeneralizedTimeError)
TRACE_ERROR(SetOssOtherKeyAttributeError)
SET_ERROR(InvalidRecipientIdChoice, E_INVALIDARG)
}

//+-------------------------------------------------------------------------
//  Free the Oss MailListRecipientInfo
//--------------------------------------------------------------------------
void
WINAPI
ICM_FreeOssMailListRecipientInfo(
    IN OUT MailListRecipientInfo *pori
    )
{
    ICM_FreeOssOctetString(&pori->mlid.kekIdentifier);
    ICM_FreeOssOtherKeyAttribute(&pori->mlid.other);
    ICM_FreeOssAlgorithmIdentifier(&pori->keyEncryptionAlgorithm);
    ICM_Free(pori->encryptedKey.value);
    pori->encryptedKey.value = NULL;
}

//+-------------------------------------------------------------------------
//  Fill the Oss MailListRecipientInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillOssMailListRecipientInfo(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO pMailListEncodeInfo,
    IN DWORD dwRecipientIndex,
    IN OUT MailListRecipientInfo *pori
    )
{
    BOOL fRet;
    CMSG_MAIL_LIST_ENCRYPT_INFO MailListEncryptInfo;

    memset(&MailListEncryptInfo, 0, sizeof(MailListEncryptInfo));
    MailListEncryptInfo.cbSize = sizeof(MailListEncryptInfo);
    MailListEncryptInfo.dwRecipientIndex = dwRecipientIndex;
    MailListEncryptInfo.KeyEncryptionAlgorithm =
        pMailListEncodeInfo->KeyEncryptionAlgorithm;
    // MailListEncryptInfo.EncryptedKey =
    // MailListEncryptInfo.dwFlags =

    if (!ICM_ExportMailList(
            pContentEncryptInfo,
            pMailListEncodeInfo,
            &MailListEncryptInfo
            ))
        goto ExportMailListError;
    pori->encryptedKey.length = MailListEncryptInfo.EncryptedKey.cbData;
    pori->encryptedKey.value = MailListEncryptInfo.EncryptedKey.pbData;

    pori->version = CMSG_MAIL_LIST_VERSION;

    if (!ICM_SetOssOctetString(
            &pMailListEncodeInfo->KeyId,
            &pori->mlid.kekIdentifier
            ))
        goto SetOssOctetStringError;

    if (pMailListEncodeInfo->Date.dwLowDateTime ||
            pMailListEncodeInfo->Date.dwHighDateTime) {
        if (!PkiAsn1ToGeneralizedTime(
                &pMailListEncodeInfo->Date,
                &pori->mlid.date
                ))
            goto ConvToGeneralizedTimeError;
        pori->mlid.bit_mask |= date_present;
    }

    if (pMailListEncodeInfo->pOtherAttr) {
        if (!ICM_SetOssOtherKeyAttribute(
                pMailListEncodeInfo->pOtherAttr,
                &pori->mlid.other
                ))
            goto SetOssOtherKeyAttributeError;
        pori->mlid.bit_mask |= other_present;
    }

    if (!ICM_SetOssAlgorithmIdentifier(
            &MailListEncryptInfo.KeyEncryptionAlgorithm,
            &pori->keyEncryptionAlgorithm
            ))
        goto SetOssAlgorithmIdentifierError;

    fRet = TRUE;
CommonReturn:
    if (MailListEncryptInfo.dwFlags & CMSG_MAIL_LIST_ENCRYPT_FREE_PARA_FLAG)
        ICM_Free(MailListEncryptInfo.KeyEncryptionAlgorithm.Parameters.pbData);
    return fRet;

ErrorReturn:
    ICM_FreeOssMailListRecipientInfo(pori);
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(ExportMailListError)
TRACE_ERROR(SetOssOctetStringError)
TRACE_ERROR(ConvToGeneralizedTimeError)
TRACE_ERROR(SetOssOtherKeyAttributeError)
TRACE_ERROR(SetOssAlgorithmIdentifierError)
}

//+-------------------------------------------------------------------------
//  Free the Oss CmsRecipientInfos
//--------------------------------------------------------------------------
void
WINAPI
ICM_FreeOssCmsRecipientInfos(
    IN OUT CmsRecipientInfos *poris
    )
{
    DWORD i;
    CmsRecipientInfo *pori;

    if (NULL == poris->value)
        return;

    for (i = 0, pori = poris->value; i < poris->count; i++, pori++) {
        switch (pori->choice) {
            case keyTransRecipientInfo_chosen:
                ICM_FreeOssKeyTransRecipientInfo(
                    &pori->u.keyTransRecipientInfo);
                break;
            case keyAgreeRecipientInfo_chosen:
                ICM_FreeOssKeyAgreeRecipientInfo(
                    &pori->u.keyAgreeRecipientInfo);
                break;
            case mailListRecipientInfo_chosen:
                ICM_FreeOssMailListRecipientInfo(
                    &pori->u.mailListRecipientInfo);
                break;
            case 0:
            default:
                break;
        }
    }

    ICM_Free(poris->value);
    poris->value = NULL;
}


//+-------------------------------------------------------------------------
//  Fill the Oss CmsRecipientInfos
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillOssCmsRecipientInfos(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN OUT CmsRecipientInfos *poris,
#ifdef OSS_CRYPT_ASN1
    IN OUT int *pEnvelopedDataVersion
#else
    IN OUT ASN1int32_t *pEnvelopedDataVersion
#endif  // OSS_CRYPT_ASN1
    )
{
    BOOL fRet;
    DWORD cRecipients;
    PCMSG_RECIPIENT_ENCODE_INFO rgCmsRecipients;
    CmsRecipientInfo *pori = NULL;
    DWORD i;

    cRecipients = pContentEncryptInfo->cRecipients;
    if (0 == cRecipients)
        goto SuccessReturn;
    rgCmsRecipients = pContentEncryptInfo->rgCmsRecipients;
    assert(cRecipients && rgCmsRecipients);

    if (NULL == (poris->value = (CmsRecipientInfo *) ICM_AllocZero(
            cRecipients * sizeof(CmsRecipientInfo))))
        goto OutOfMemory;
    poris->count = cRecipients;

    for (i = 0, pori = poris->value; i < cRecipients; i++, pori++) {
        switch (rgCmsRecipients[i].dwRecipientChoice) {
            case CMSG_KEY_TRANS_RECIPIENT:
                if (!ICM_FillOssKeyTransRecipientInfo(
                        pContentEncryptInfo,
                        rgCmsRecipients[i].pKeyTrans,
                        i,
                        &pori->u.keyTransRecipientInfo,
                        pEnvelopedDataVersion
                        ))
                    goto FillOssKeyTransRecipientInfoError;
                pori->choice = keyTransRecipientInfo_chosen;
                break;
            case CMSG_KEY_AGREE_RECIPIENT:
                if (!ICM_FillOssKeyAgreeRecipientInfo(
                        pContentEncryptInfo,
                        rgCmsRecipients[i].pKeyAgree,
                        i,
                        &pori->u.keyAgreeRecipientInfo
                        ))
                    goto FillOssKeyAgreeRecipientInfoError;
                pori->choice = keyAgreeRecipientInfo_chosen;
                *pEnvelopedDataVersion = CMSG_ENVELOPED_DATA_CMS_VERSION;
                break;
            case CMSG_MAIL_LIST_RECIPIENT:
                if (!ICM_FillOssMailListRecipientInfo(
                        pContentEncryptInfo,
                        rgCmsRecipients[i].pMailList,
                        i,
                        &pori->u.mailListRecipientInfo
                        ))
                    goto FillOssMailLIstRecipientInfoError;
                pori->choice = mailListRecipientInfo_chosen;
                *pEnvelopedDataVersion = CMSG_ENVELOPED_DATA_CMS_VERSION;
                break;
            default:
                goto InvalidRecipientChoice;
        }
    }

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    ICM_FreeOssCmsRecipientInfos(poris);

    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(FillOssKeyTransRecipientInfoError)
TRACE_ERROR(FillOssKeyAgreeRecipientInfoError)
TRACE_ERROR(FillOssMailLIstRecipientInfoError)
SET_ERROR(InvalidRecipientChoice, E_INVALIDARG)
}


//+-------------------------------------------------------------------------
//  Open an enveloped message for encoding
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
ICM_OpenToEncodeEnvelopedData(
    IN DWORD dwEncodingType,
    IN DWORD dwFlags,
    IN void const *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo)
{
    DWORD                       dwError = ERROR_SUCCESS;
    PCRYPT_MSG_INFO             pcmi = NULL;
    PCMSG_ENVELOPED_ENCODE_INFO pemei =
        (PCMSG_ENVELOPED_ENCODE_INFO) pvMsgEncodeInfo;
    CmsEnvelopedData            *ped = NULL;
    EncryptedContentInfo        *peci;

    CMSG_CONTENT_ENCRYPT_INFO   ContentEncryptInfo;
        ZEROSTRUCT(ContentEncryptInfo);

    DWORD                       i;
    PCERT_BLOB                  pcert;
    PCRL_BLOB                   pcrl;
    Certificate                 *pOssCert;
    CertificateRevocationList   *pOssCrl;
    DWORD                       cbCert = 0;
    PBYTE                       pbCert;
    DWORD                       cbCrl;
    PBYTE                       pbCrl;
    DWORD                       cbOriginatorInfo;
    DWORD                       cUnprotectedAttr;

    assert(pemei->cbSize >= STRUCT_CBSIZE(CMSG_ENVELOPED_ENCODE_INFO,
        rgpRecipients));
    if (pemei->cbSize <
                STRUCT_CBSIZE(CMSG_ENVELOPED_ENCODE_INFO, rgpRecipients))
        goto InvalidArg;

    if (pemei->cbSize >= sizeof(CMSG_ENVELOPED_ENCODE_INFO)) {
        for (i=pemei->cCertEncoded, pcert=pemei->rgCertEncoded, cbCert=0;
                i>0;
                i--, pcert++)
            cbCert += pcert->cbData;

        for (i=pemei->cAttrCertEncoded, pcert=pemei->rgAttrCertEncoded;
                i>0;
                i--, pcert++)
            cbCert += pcert->cbData;

        for (i=pemei->cCrlEncoded, pcrl=pemei->rgCrlEncoded, cbCrl=0;
                i>0;
                i--, pcrl++)
            cbCrl += pcrl->cbData;

        cbOriginatorInfo =
                pemei->cCertEncoded * sizeof(Certificate) +
                pemei->cAttrCertEncoded * sizeof(Certificate) +
                pemei->cCrlEncoded * sizeof(CertificateRevocationList) +
                cbCert + cbCrl;

        cUnprotectedAttr = pemei->cUnprotectedAttr;
    } else {
        cbOriginatorInfo = 0;
        cUnprotectedAttr = 0;
    }

    ped = (CmsEnvelopedData *)ICM_AllocZero(
            sizeof(CmsEnvelopedData) + cbOriginatorInfo);
    if (NULL == ped)
        goto CmsEnvelopedDataAllocError;

    // pcmi
    pcmi = (PCRYPT_MSG_INFO)ICM_AllocZero(sizeof(CRYPT_MSG_INFO));
    if (NULL == pcmi)
        goto PcmiAllocError;

    // pcmi->hCryptProv
    // pcmi->fDefaultCryptProv
    pcmi->dwEncodingType = dwEncodingType;
    pcmi->dwMsgType = CMSG_ENVELOPED;
    pcmi->dwFlags = dwFlags;
    pcmi->pvMsg = ped;
    pcmi->fEncoding = TRUE;
    pcmi->dwPhase = PHASE_FIRST_ONGOING;
    if (pszInnerContentObjID &&
            (NULL == (pcmi->pszInnerContentObjID = (LPSTR)ICM_DupMem(
                                    pszInnerContentObjID,
                                    ICM_StrLen(pszInnerContentObjID) + 1))))
        goto DupInnerContentObjIDError;
    if (pStreamInfo &&
            (NULL == (pcmi->pStreamInfo = (PCMSG_STREAM_INFO)ICM_DupMem(
                                    pStreamInfo,
                                    sizeof(*pStreamInfo)))))
        goto DupStreamInfoError;

    // version
    if (0 < cbOriginatorInfo || 0 < cUnprotectedAttr)
        ped->version = CMSG_ENVELOPED_DATA_CMS_VERSION;
    else
        ped->version = CMSG_ENVELOPED_DATA_PKCS_1_5_VERSION;

    if (0 < cbOriginatorInfo) {
        OriginatorInfo *poi = &ped->originatorInfo;

        // originatorInfo
        ped->bit_mask |= originatorInfo_present;

        // certificates
        if (0 != pemei->cCertEncoded || 0 != pemei->cAttrCertEncoded) {
            poi->bit_mask |= certificates_present;
            poi->certificates.count = pemei->cCertEncoded +
                pemei->cAttrCertEncoded;
#ifdef OSS_CRYPT_ASN1
            poi->certificates.certificates = (Certificate *)(ped + 1);
#else
            poi->certificates.value = (Certificate *)(ped + 1);
#endif  // OSS_CRYPT_ASN1
            pbCert = (PBYTE)ped +
                    sizeof( CmsEnvelopedData) +
                    pemei->cCertEncoded * sizeof( Certificate) +
                    pemei->cAttrCertEncoded * sizeof( Certificate) +
                    pemei->cCrlEncoded * sizeof( CertificateRevocationList);
            for (i=pemei->cCertEncoded, pcert=pemei->rgCertEncoded,
#ifdef OSS_CRYPT_ASN1
                        pOssCert=poi->certificates.certificates;
#else
                        pOssCert=poi->certificates.value;
#endif  // OSS_CRYPT_ASN1
                    i>0;
                    i--, pcert++, pOssCert++) {
                pOssCert->length = pcert->cbData;
                memcpy( pbCert, pcert->pbData, pcert->cbData);
                pOssCert->value = pbCert;
                pbCert += pcert->cbData;
            }

            for (i=pemei->cAttrCertEncoded, pcert=pemei->rgAttrCertEncoded;
                    i>0;
                    i--, pcert++, pOssCert++) {
                pOssCert->length = pcert->cbData;
                memcpy( pbCert, pcert->pbData, pcert->cbData);
                if (pcert->cbData)
                    // Change tag from SEQUENCE to [1] IMPLICIT
                    *pbCert = ICM_TAG_CONSTRUCTED_CONTEXT_1;
                pOssCert->value = pbCert;
                pbCert += pcert->cbData;
            }
        }

        // crls
        if (0 != pemei->cCrlEncoded) {
            poi->bit_mask |= crls_present;
            poi->crls.count = pemei->cCrlEncoded;
            if (0 != pemei->cCertEncoded || 0 != pemei->cAttrCertEncoded)
#ifdef OSS_CRYPT_ASN1
                poi->crls.crls  = (CertificateRevocationList *)
                    (poi->certificates.certificates +
#else
                poi->crls.value  = (CertificateRevocationList *)
                    (poi->certificates.value +
#endif  // OSS_CRYPT_ASN1
                        (pemei->cCertEncoded + pemei->cAttrCertEncoded));
            else
#ifdef OSS_CRYPT_ASN1
                poi->crls.crls  = (CertificateRevocationList *) (ped + 1);
#else
                poi->crls.value  = (CertificateRevocationList *) (ped + 1);
#endif  // OSS_CRYPT_ASN1
            pbCrl = (PBYTE)ped +
                    sizeof( CmsEnvelopedData) +
                    pemei->cCertEncoded * sizeof( Certificate) +
                    pemei->cAttrCertEncoded * sizeof( Certificate) +
                    pemei->cCrlEncoded * sizeof( CertificateRevocationList) +
                    cbCert;
#ifdef OSS_CRYPT_ASN1
            for (i=pemei->cCrlEncoded, pcrl=pemei->rgCrlEncoded, pOssCrl=poi->crls.crls;
#else
            for (i=pemei->cCrlEncoded, pcrl=pemei->rgCrlEncoded, pOssCrl=poi->crls.value;
#endif  // OSS_CRYPT_ASN1
                    i>0;
                    i--, pcrl++, pOssCrl++) {
                pOssCrl->length = pcrl->cbData;
                memcpy( pbCrl, pcrl->pbData, pcrl->cbData);
                pOssCrl->value = pbCrl;
                pbCrl += pcrl->cbData;
            }
        }
    }

    if (0 < cUnprotectedAttr) {
        Attribute *poatr;
        PCRYPT_ATTRIBUTE patr;

        if (NULL == (poatr = (Attribute *) ICM_AllocZero(
                cUnprotectedAttr * sizeof(Attribute))))
            goto UnprotectedAttrsAllocError;
        ped->unprotectedAttrs.value = poatr;
        ped->unprotectedAttrs.count = cUnprotectedAttr;
        ped->bit_mask |= unprotectedAttrs_present;

        for (i=cUnprotectedAttr, patr=pemei->rgUnprotectedAttr;
                i>0;
                i--, patr++, poatr++) {
            if (!ICM_Asn1ToAttribute(patr, poatr))
                goto Asn1ToAttributeError;
        }
    }


    if (!ICM_InitializeContentEncryptInfo(pemei, &ContentEncryptInfo))
        goto InitializeContentEncryptInfoError;
//    assert(ContentEncryptInfo.hCryptProv);
    pcmi->hCryptProv = ContentEncryptInfo.hCryptProv;
    assert(ContentEncryptInfo.hContentEncryptKey);
    pcmi->hkeyContentCrypt = ContentEncryptInfo.hContentEncryptKey;

    if (pStreamInfo && CMSG_INDEFINITE_LENGTH != pStreamInfo->cbContent)
        ContentEncryptInfo.dwEncryptFlags |=
            CMSG_CONTENT_ENCRYPT_PAD_ENCODED_LEN_FLAG;

    if (!ICM_FillOssCmsRecipientInfos(
            &ContentEncryptInfo,
            &ped->recipientInfos,
            &ped->version
            ))
        goto FillOssCmsRecipientInfosError;

    // Is encryptedContent encapsulated ???
    if (ped->version > CMSG_ENVELOPED_DATA_PKCS_1_5_VERSION) {
        if (ICM_IsData(pszInnerContentObjID))
            pcmi->dwFlags &= ~CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
        else
            pcmi->dwFlags |= CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
    } else if (pcmi->dwFlags & CMSG_CMS_ENCAPSULATED_CONTENT_FLAG) {
        if (ICM_IsData(pszInnerContentObjID))
            pcmi->dwFlags &= ~CMSG_CMS_ENCAPSULATED_CONTENT_FLAG;
        else
            ped->version = CMSG_ENVELOPED_DATA_CMS_VERSION;
    }

    // encryptedContentInfo
    // (.encryptedContent filled in during update)
    peci = &ped->encryptedContentInfo;
    peci->bit_mask = encryptedContent_present;
    peci->contentType.count =
        sizeof(peci->contentType.value)/sizeof(peci->contentType.value[0]);
    if (!PkiAsn1ToObjectIdentifier(
            pszInnerContentObjID ? pszInnerContentObjID : pszObjIdDataType,
            &peci->contentType.count,
            peci->contentType.value))
        goto PkiAsn1ToObjectIdentifierError;

    if (!ICM_MsgAsn1ToAlgorithmIdentifier(
            pcmi,
            &ContentEncryptInfo.ContentEncryptionAlgorithm,
            &peci->contentEncryptionAlgorithm))
        goto MsgAsn1ToAlgorithmIdentifierError;

    if (pStreamInfo && !ICMS_OpenToEncodeEnvelopedData( pcmi, pemei))
        goto StreamOpenToEncodeEnvelopedDataError;

    // From here to CommonReturn, NO Errors
    if (ContentEncryptInfo.hCryptProv == pemei->hCryptProv) {
//        assert(ContentEncryptInfo.hCryptProv);
        assert(0 == (ContentEncryptInfo.dwFlags &
            CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG));
    } else {
        if (pcmi->dwFlags & CMSG_CRYPT_RELEASE_CONTEXT_FLAG) {
            pcmi->dwFlags &= ~CMSG_CRYPT_RELEASE_CONTEXT_FLAG;
            CryptReleaseContext(pemei->hCryptProv, 0);
        }
    }

    if (ContentEncryptInfo.dwFlags &
            CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG) {
        pcmi->dwFlags |= CMSG_CRYPT_RELEASE_CONTEXT_FLAG;
        ContentEncryptInfo.dwFlags &=
            ~CMSG_CONTENT_ENCRYPT_RELEASE_CONTEXT_FLAG;
    }

    ContentEncryptInfo.hContentEncryptKey = 0;

CommonReturn:
    ICM_FreeContentEncryptInfo(pemei, &ContentEncryptInfo);
    ICM_SetLastError(dwError);
    return (HCRYPTMSG) pcmi;

ErrorReturn:
    dwError = GetLastError();
    if (ped) {
        ICM_FreeOssCmsRecipientInfos(&ped->recipientInfos);

        if (ped->unprotectedAttrs.value) {
            Attribute *poatr;

            for (i=ped->unprotectedAttrs.count,
                    poatr=ped->unprotectedAttrs.value;
                    i>0;
                    i--, poatr++) {
                ICM_Free(poatr->attributeValue.value);
            }
            ICM_Free(ped->unprotectedAttrs.value);
        }

        ICM_Free(ped);
    }
    if (pcmi) {
        if (pcmi->pFreeList)
            delete pcmi->pFreeList;
        ICM_Free(pcmi->pszInnerContentObjID);
        ICM_Free(pcmi->pStreamInfo);
        ICM_Free(pcmi);
        pcmi = NULL;
    }
    goto CommonReturn;
SET_ERROR(InvalidArg,E_INVALIDARG)
SET_ERROR(PkiAsn1ToObjectIdentifierError,CRYPT_E_OID_FORMAT)
TRACE_ERROR(DupInnerContentObjIDError)
TRACE_ERROR(DupStreamInfoError)
TRACE_ERROR(CmsEnvelopedDataAllocError)
TRACE_ERROR(PcmiAllocError)
TRACE_ERROR(UnprotectedAttrsAllocError)
TRACE_ERROR(Asn1ToAttributeError)
TRACE_ERROR(InitializeContentEncryptInfoError)
TRACE_ERROR(FillOssCmsRecipientInfosError)
TRACE_ERROR(MsgAsn1ToAlgorithmIdentifierError)
TRACE_ERROR(StreamOpenToEncodeEnvelopedDataError)
}
#else

//+-------------------------------------------------------------------------
//  Default export of the encryption key
//
//  Note, pcbData[1] contains dwEncryptFlags, where,
//  CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG may be set to disable the reversing
//  of the encoded, encrypted symmetric key.
//
//  rgcbData[1] is the dwEncryptFlags passed from ICM_DefaultGenEncryptKey
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultExportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    OUT PBYTE                       pbData,
    IN OUT DWORD                    rgcbData[2])
{
    BOOL            fRet;
    DWORD           dwError = ERROR_SUCCESS;
    HCRYPTKEY       hPubKey = NULL;
    PBYTE           pb = NULL;
    DWORD           cb;

    if (!CryptImportPublicKeyInfo(
            hCryptProv,
            X509_ASN_ENCODING,
            pPublicKeyInfo,
            &hPubKey))
        goto ImportKeyError;
    if (!CryptExportKey(
            hEncryptKey,
            hPubKey,
            SIMPLEBLOB,
            0,                  // dwFlags
            NULL,
            &cb))
        goto ExportKeySizeError;
    if (NULL == (pb = (PBYTE)ICM_AllocA( cb)))
        goto ExportKeyAllocError;
    if (!CryptExportKey(
            hEncryptKey,
            hPubKey,
            SIMPLEBLOB,
            0,                  // dwFlags
            pb,
            &cb))
        goto ExportKeyError;
    assert( cb > (sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER)));
    cb -= sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER);

    fRet = TRUE;
    if (pbData) {
        if (rgcbData[0] < cb) {
            SetLastError((DWORD) ERROR_MORE_DATA);
            fRet = FALSE;
        } else if (0 < cb) {
            if (rgcbData[1] & CMSG_SP3_COMPATIBLE_ENCRYPT_FLAG)
                // Don't byte reverse
                memcpy(pbData,
                    pb + (sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER)),
                    cb);
            else
                ICM_ReverseCopy(pbData,
                    pb + (sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER)),
                    cb);
        }
    }

CommonReturn:
    rgcbData[0] = cb;
    ICM_FreeA(pb);
    if (hPubKey)
        CryptDestroyKey(hPubKey);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    cb = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(ImportKeyError)
TRACE_ERROR(ExportKeySizeError)
TRACE_ERROR(ExportKeyAllocError)
TRACE_ERROR(ExportKeyError)
}

//+-------------------------------------------------------------------------
//  Export of the encryption key
//
//  rgcbData[1] is the dwEncryptFlags passed from ICM_GenEncryptKey
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ExportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN HCRYPTKEY                    hEncryptKey,
    IN PCERT_PUBLIC_KEY_INFO        pPublicKeyInfo,
    OUT PBYTE                       pbData,
    IN OUT DWORD                    rgcbData[2])
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    if (CryptGetOIDFunctionAddress(
            hExportEncryptKeyFuncSet,
            X509_ASN_ENCODING,
            pPublicKeyInfo->Algorithm.pszObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fResult = ((PFN_CMSG_EXPORT_ENCRYPT_KEY) pvFuncAddr)(
            hCryptProv,
            hEncryptKey,
            pPublicKeyInfo,
            pbData,
            rgcbData);
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else
        fResult = ICM_DefaultExportEncryptKey(
            hCryptProv,
            hEncryptKey,
            pPublicKeyInfo,
            pbData,
            rgcbData);
    return fResult;
}

// This size is good up through a 2048 bit exchange key
#define EXPORT_ENCRYPT_KEY_LENGTH   256

//+-------------------------------------------------------------------------
//  Fill the RecipientInfos
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillRecipientInfos(
    IN HCRYPTPROV           hCryptProv,
    IN HCRYPTKEY            hKeyContent,
    IN DWORD                cRecipients,
    IN PCERT_INFO           *rgpRecipients,
    IN OUT RecipientInfos   *pris,
    IN DWORD                dwEncryptFlags)
{
    BOOL            fRet;
    PCERT_INFO      *ppci;
    RecipientInfo   *pri;
    PBYTE           pb = NULL;
    DWORD           rgcb[2];        // rgcb[1] is updated with dwEncryptFlags
    DWORD           cTryAgain;
    DWORD           i;
    PBYTE           pbSerialNumber;
    DWORD           cbSerialNumber = 0;

    for (i=cRecipients, ppci=rgpRecipients; i>0; i--, ppci++)
        cbSerialNumber += (*ppci)->SerialNumber.cbData;
    pris->value = (RecipientInfo *)ICM_AllocZero(
                cRecipients * sizeof( RecipientInfo) +
                cbSerialNumber);
    if (NULL == pris->value)
        goto RecipientInfoAllocError;
    pris->count = cRecipients;
    pbSerialNumber = (PBYTE)(pris->value + cRecipients);

    for (i=cRecipients, ppci=rgpRecipients, pri=pris->value;
            i>0;
            i--, ppci++, pri++) {
        // version
        pri->version = 0;

        // issuerAndSerialNumber
        pri->issuerAndSerialNumber.issuer.length = (*ppci)->Issuer.cbData;
        pri->issuerAndSerialNumber.issuer.value = (*ppci)->Issuer.pbData;
        pri->issuerAndSerialNumber.serialNumber.length = (*ppci)->SerialNumber.cbData;
        pb = pbSerialNumber;
        pbSerialNumber += (*ppci)->SerialNumber.cbData;
        ICM_ReverseCopy(
            pb,
            (*ppci)->SerialNumber.pbData,
            (*ppci)->SerialNumber.cbData);
        pri->issuerAndSerialNumber.serialNumber.value = pb;

        // keyEncryptionAlgorithm
        if (!ICM_Asn1ToAlgorithmIdentifier(
                &(*ppci)->SubjectPublicKeyInfo.Algorithm,
                &pri->keyEncryptionAlgorithm))
            goto Asn1ToAlgorithmIdentifierError;

        rgcb[0] = EXPORT_ENCRYPT_KEY_LENGTH;
        rgcb[1] = dwEncryptFlags;
        cTryAgain = 1;
        while (TRUE) {
            if (NULL == (pb = (PBYTE)ICM_Alloc(rgcb[0])))
                goto ExportKeyAllocError;
            if (ICM_ExportEncryptKey(
                    hCryptProv,
                    hKeyContent,
                    &(*ppci)->SubjectPublicKeyInfo,
                    pb,
                    rgcb))
                break;
            ICM_Free(pb);
            if (rgcb[0] && cTryAgain--)
                continue;
            else
                goto ExportKeyError;
        }

        pri->encryptedKey.length = rgcb[0];
        pri->encryptedKey.value = pb;
        pb = NULL;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
// Need to free EncrytedKey for each recipient
    ICM_Free( pris->value);

    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(RecipientInfoAllocError)
TRACE_ERROR(Asn1ToAlgorithmIdentifierError)
TRACE_ERROR(ExportKeyAllocError)
TRACE_ERROR(ExportKeyError)
}


//+-------------------------------------------------------------------------
//  Open an enveloped message for encoding
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
ICM_OpenToEncodeEnvelopedData(
    IN DWORD dwEncodingType,
    IN DWORD dwFlags,
    IN void const *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo)
{
    DWORD                       dwError = ERROR_SUCCESS;
    PCRYPT_MSG_INFO             pcmi = NULL;
    PCMSG_ENVELOPED_ENCODE_INFO pemei = (PCMSG_ENVELOPED_ENCODE_INFO)pvMsgEncodeInfo;
    EnvelopedData               *ped = NULL;
    EncryptedContentInfo        *peci;
    DWORD                       dwAlgoCAPI;
    CRYPT_ALGORITHM_IDENTIFIER  ContentEncryptionAlgorithm;
    PBYTE                       pbEncryptParameters = NULL;

    // rgcbEncryptParameters[1] contains dwEncryptFlags
    DWORD                       rgcbEncryptParameters[2];

    assert( pemei->cbSize >= sizeof(CMSG_ENVELOPED_ENCODE_INFO));
    assert( 0 != pemei->cRecipients);
    if (pemei->cbSize < sizeof(CMSG_ENVELOPED_ENCODE_INFO) ||
            0 == pemei->cRecipients)
        goto InvalidArg;

    ped = (EnvelopedData *)ICM_AllocZero( sizeof( EnvelopedData));
    if (NULL == ped)
        goto EnvelopedDataAllocError;

    // pcmi
    pcmi = (PCRYPT_MSG_INFO)ICM_AllocZero( sizeof( CRYPT_MSG_INFO));
    if (NULL == pcmi)
        goto PcmiAllocError;

    pcmi->hCryptProv = pemei->hCryptProv;
    if (0 == pcmi->hCryptProv)
        pcmi->fDefaultCryptProv = TRUE;
    pcmi->dwEncodingType = dwEncodingType;
    pcmi->dwMsgType = CMSG_ENVELOPED;
    pcmi->dwFlags = dwFlags;
    pcmi->pvMsg = ped;
    pcmi->fEncoding = TRUE;
    pcmi->dwPhase = PHASE_FIRST_ONGOING;
    if (pszInnerContentObjID &&
            (NULL == (pcmi->pszInnerContentObjID = (LPSTR)ICM_DupMem(
                                    pszInnerContentObjID,
                                    ICM_StrLen(pszInnerContentObjID) + 1))))
        goto DupInnerContentObjIDError;
    if (pStreamInfo &&
            (NULL == (pcmi->pStreamInfo = (PCMSG_STREAM_INFO)ICM_DupMem(
                                    pStreamInfo,
                                    sizeof(*pStreamInfo)))))
        goto DupStreamInfoError;

    // version
    ped->version = 0;

    // recipientInfos
    // Use first recipients public key info
    ContentEncryptionAlgorithm = pemei->ContentEncryptionAlgorithm;
    rgcbEncryptParameters[0] = 0;
    rgcbEncryptParameters[1] = 0;
    if (!ICM_GenEncryptKey(
            &pcmi->hCryptProv,
            &ContentEncryptionAlgorithm,
            pemei->pvEncryptionAuxInfo,
            &pemei->rgpRecipients[0]->SubjectPublicKeyInfo,
            ICM_Alloc,
            &pcmi->hkeyContentCrypt,    // not freed for an error
            &pbEncryptParameters,
            rgcbEncryptParameters))
        goto GenKeyError;
    if (rgcbEncryptParameters[0] && pbEncryptParameters) {
        pcmi->pbEncryptParameters = pbEncryptParameters;
        ContentEncryptionAlgorithm.Parameters.pbData = pbEncryptParameters;
        ContentEncryptionAlgorithm.Parameters.cbData = rgcbEncryptParameters[0];
    } else if (pbEncryptParameters) {
        ICM_Free(pbEncryptParameters);
        pbEncryptParameters = NULL;
    }

    if (!ICM_FillRecipientInfos(
                pcmi->hCryptProv,
                pcmi->hkeyContentCrypt,
                pemei->cRecipients,
                pemei->rgpRecipients,
                &ped->recipientInfos,
                rgcbEncryptParameters[1]))      // dwEncryptFlags
        goto FillRecipientInfosError;

    // encryptedContentInfo
    // (.encryptedContent filled in during update)
    peci = &ped->encryptedContentInfo;
    peci->bit_mask = encryptedContent_present;
    peci->contentType.count = sizeof(peci->contentType.value)/sizeof(peci->contentType.value[0]);
    if (!PkiAsn1ToObjectIdentifier(
            pszInnerContentObjID ? pszInnerContentObjID : pszObjIdDataType,
            &peci->contentType.count,
            peci->contentType.value))
        goto PkiAsn1ToObjectIdentifierError;

    if (!ICM_Asn1ToAlgorithmIdentifier(
            &ContentEncryptionAlgorithm,
            &peci->contentEncryptionAlgorithm))
        goto Asn1ToAlgorithmIdentifierError;

    if (pStreamInfo && !ICMS_OpenToEncodeEnvelopedData( pcmi, pemei))
        goto StreamOpenToEncodeEnvelopedDataError;

CommonReturn:
    ICM_SetLastError(dwError);
    return (HCRYPTMSG)pcmi;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( pbEncryptParameters);
    ICM_Free( ped);
    ICM_Free( pcmi);
    pcmi = NULL;
    goto CommonReturn;
SET_ERROR(PkiAsn1ToObjectIdentifierError,CRYPT_E_OID_FORMAT)
SET_ERROR(InvalidArg,E_INVALIDARG)
TRACE_ERROR(DupInnerContentObjIDError)              // error already set
TRACE_ERROR(DupStreamInfoError)                     // error already set
TRACE_ERROR(EnvelopedDataAllocError)                // error already set
TRACE_ERROR(PcmiAllocError)                         // error already set
TRACE_ERROR(GenKeyError)                            // error already set
TRACE_ERROR(FillRecipientInfosError)                // error already set
TRACE_ERROR(Asn1ToAlgorithmIdentifierError)      // error already set
TRACE_ERROR(StreamOpenToEncodeEnvelopedDataError)   // error already set
}

#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Open a signed and enveloped message for encoding
//--------------------------------------------------------------------------
#if 0
HCRYPTMSG
WINAPI
ICM_OpenToEncodeSignedAndEnvelopedData(
    IN DWORD dwEncodingType,
    IN DWORD dwFlags,
    IN void *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo)
{
    DWORD                       dwError = ERROR_SUCCESS;
    HCRYPTPROV                  hCryptProv;
    DWORD                       dwKeySpec;
    PCRYPT_MSG_INFO             pcmi = NULL;
    PCMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO  psemei;
    SignedAndEnvelopedData      *psed = NULL;
    ContentEncryptionAlgorithmIdentifier *pceai;
    DWORD                       dwVersion = 1;
    HCRYPTKEY                   hkeyContentEncryption;
    PCERT_BLOB                  pcert;
    PCRL_BLOB                   pcrl;
    DWORD                       i;
    CRYPT_ALGORITHM_IDENTIFIER        aiDigest;
    DWORD                       dwAlgoCAPISign;
    DWORD                       dwAlgoCAPIEncrypt;

    psemei = (PCMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO)pvMsgEncodeInfo;
    psed = new SignedAndEnvelopedData;

    assert( 1 == psemei->SignedInfo.cSigners);       // just for now
    assert( psemei->cbSize >= sizeof(CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO));
    if (psemei->cbSize < sizeof(CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO))
        goto InvalidArg;

    // version
    psed->version.Write( &dwVersion);

    // recipientInfos
    if (!ICM_GetCAPI(
            CRYPT_ENCRYPT_ALG_OID_GROUP_ID,
            &psemei->ContentEncryptionAlgorithm,
            &dwAlgoCAPIEncrypt))
        goto GetCAPIEncryptError;
    if (!CryptGenKey(
                psemei->EnvelopedInfo.hCryptProv,
                dwAlgoCAPIEncrypt,
                CRYPT_EXPORTABLE,       // dwFlags
                &hkeyContentEncryption))
        goto GenKeyError;
    if (!ICM_FillRecipientInfos(
                psemei->EnvelopedInfo.hCryptProv,
                hkeyContentEncryption,
                psemei->EnvelopedInfo.cRecipients,
                psemei->EnvelopedInfo.rgpRecipients,
                psed->recipientInfos,
                dwEncryptFlags))
        goto FillRecipientInfosError;

    // digestAlgorithms
    if (!ICM_SetAsnDigestAlgorithmIdentifiers(
                psed->digestAlgorithms,
                &aiDigest,
                psemei->SignedInfo.cSigners,
                psemei->SignedInfo.rgSigners,
                &hCryptProv,
                &dwKeySpec))
        goto SetAsnDigestAlgorithmIdentifiersError;

    // encryptedContentInfo.contentEncryptionAlgorithm
    // (.encryptedContent and .encryptedContent filled in during update)
    pceai = &psed->encryptedContentInfo.contentEncryptionAlgorithm;
    pceai->algorithm = psemei->EnvelopedInfo.ContentEncryptionAlgorithm.pszObjId;
    if (0 != psemei->EnvelopedInfo.ContentEncryptionAlgorithm.Parameters.cbData) {
        if (0 > pceai->parameters.Decode(
                psemei->EnvelopedInfo.ContentEncryptionAlgorithm.Parameters.pbData))
            goto ContentEncryptionAlgorithmParametersDecodeError;
    }

    // certificates
    for (i=psemei->SignedInfo.cCertEncoded, pcert=psemei->SignedInfo.rgCertEncoded;
            i>0;
            i--, pcert++) {
        if (0 > psed->certificates[ psed->certificates.Add()].Decode( pcert->pbData))
            goto BadParameter;
    }

    // crls
    for (i=psemei->SignedInfo.cCrlEncoded, pcrl=psemei->SignedInfo.rgCrlEncoded;
            i>0;
            i--, pcrl++) {
        if (0 > psed->crls[ psed->crls.Add()].Decode( pcrl->pbData))
            goto BadParameter;
    }

    // signerInfos
    if (!ICM_SetAsnSignerInfos(
            psed->signerInfos,
            dwFlags,
            psemei->SignedInfo.cSigners,
            psemei->SignedInfo.rgSigners))
        goto SetAsnSignerInfosError;

    // pcmi
    pcmi = (PCRYPT_MSG_INFO)ICM_AllocZero( sizeof( CRYPT_MSG_INFO));
    if (NULL == pcmi)
        goto OutOfMemory;

    pcmi->hCryptProv = hCryptProv;
    if (0 == hCryptProv)
        pcmi->fDefaultCryptProv = TRUE;
    pcmi->dwKeySpec = dwKeySpec;
    pcmi->dwEncodingType = dwEncodingType;
    pcmi->dwMsgType = CMSG_SIGNED_AND_ENVELOPED;
    pcmi->dwFlags = dwFlags;
    pcmi->pvMsg = psed;
    pcmi->fEncoding = TRUE;
    pcmi->dwPhase = PHASE_FIRST_ONGOING;
    pcmi->pszInnerContentObjID = ICM_DupMem(
                                    pszInnerContentObjID,
                                    ICM_StrLen(pszInnerContentObjID) + 1);
    pcmi->pStreamInfo = ICM_DupMem( pStreamInfo, sizeof(*pStreamInfo));
//    pcmi->cDigestAlgorithms = 1;                        // temp
    if (!(ICM_GetCAPI(
            CRYPT_HASH_ALG_OID_GROUP_ID,
            &aiDigest,
            &dwAlgoCAPISign) ||
          ICM_GetCAPI(
            CRYPT_SIGN_ALG_OID_GROUP_ID,
            &aiDigest,
            &dwAlgoCAPISign)))
        goto GetCAPISignError;
    pcmi->adwDigestAlgorithms[0] = dwAlgoCAPISign;
    pcmi->hkeyContentCrypt = hkeyContentEncryption;
    if (!CryptCreateHash(
                    hCryptProv,         // s/b various per array
                    dwAlgoCAPISign,     // s/b various per array
                    NULL,               // hKey - optional for MAC
                    0,                  // dwFlags
                    &pcmi->ahHash[0]))
        goto CreateHashError;

CommonReturn:
    ICM_SetLastError(dwError);
    return (HCRYPTMSG)pcmi;

ErrorReturn:
    dwError = GetLastError();
    if (psed)
        delete psed;
    ICM_Free( pcmi);
    pcmi = NULL;
    goto CommonReturn;
SET_ERROR(InvalidArg,E_INVALIDARG)
TRACE_ERROR(FillRecipientInfosError)                // error already set
TRACE_ERROR(SetAsnDigestAlgorithmIdentifiersError)  // error already set
TRACE_ERROR(OutOfMemory)                            // error already set
SET_ERROR(GetCAPIEncryptError,CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(GenKeyError)                            // error already set
TRACE_ERROR(BadParameter)
TRACE_ERROR(ContentEncryptionAlgorithmParametersDecodeError)
TRACE_ERROR(SetAsnSignerInfosError)
TRACE_ERROR(GetCAPISignError)
TRACE_ERROR(CreateHashError)
}
#endif


//+-------------------------------------------------------------------------
//  Open a cryptographic message for encoding
//
//  If CMSG_BARE_CONTENT_FLAG is specified for a streamed message,
//  the streamed output will not have an outer ContentInfo wrapper. This
//  makes it suitable to be streamed into an enclosing message.
//
//  The pStreamInfo parameter needs to be set to stream the encoded message
//  output.
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgOpenToEncode(
#else
CryptMsgOpenToEncode(
#endif
    IN DWORD dwEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN void const *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo)
{
    HCRYPTMSG   hcrmsg = NULL;

    if (GET_CMSG_ENCODING_TYPE(dwEncodingType) != PKCS_7_ASN_ENCODING)
        goto InvalidEncoding;

    switch (dwMsgType) {
    case CMSG_DATA:
        hcrmsg = ICM_OpenToEncodeData(
                            dwEncodingType,
                            dwFlags,
                            pvMsgEncodeInfo,
                            pStreamInfo);
        break;

    case CMSG_SIGNED:
        hcrmsg = ICM_OpenToEncodeSignedData(
                            dwEncodingType,
                            dwFlags,
                            pvMsgEncodeInfo,
                            pszInnerContentObjID,
                            pStreamInfo);
        break;

    case CMSG_ENVELOPED:
        hcrmsg = ICM_OpenToEncodeEnvelopedData(
                            dwEncodingType,
                            dwFlags,
                            pvMsgEncodeInfo,
                            pszInnerContentObjID,
                            pStreamInfo);
        break;

    case CMSG_SIGNED_AND_ENVELOPED:
#if 0
        hcrmsg = ICM_OpenToEncodeSignedAndEnvelopedData(
                            dwEncodingType,
                            dwFlags,
                            pvMsgEncodeInfo,
                            pszInnerContentObjID,
                            pStreamInfo);
        break;
#endif
        goto MessageTypeNotSupportedYet;

    case CMSG_HASHED:
        hcrmsg = ICM_OpenToEncodeDigestedData(
                            dwEncodingType,
                            dwFlags,
                            pvMsgEncodeInfo,
                            pszInnerContentObjID,
                            pStreamInfo);
        break;

    case CMSG_ENCRYPTED:
        goto MessageTypeNotSupportedYet;

    default:
        goto InvalidMsgType;
    }

CommonReturn:
    if (hcrmsg) {
        PCRYPT_MSG_INFO pcmi = (PCRYPT_MSG_INFO) hcrmsg;
        pcmi->lRefCnt = 1;
        if (!Pki_InitializeCriticalSection( &pcmi->CriticalSection)) {
            CryptMsgClose(hcrmsg);
            hcrmsg = NULL;
        }
    }
    return hcrmsg;

ErrorReturn:
    hcrmsg = NULL;
    goto CommonReturn;
SET_ERROR(InvalidEncoding,E_INVALIDARG)
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
}


//+-------------------------------------------------------------------------
//  Open a cryptographic message for decoding
//
//  hCryptProv specifies the crypto provider to use for hashing and/or
//  decrypting the message. If hCryptProv is NULL, a default crypt provider
//  is used.
//
//  Currently pRecipientInfo isn't used and should be set to NULL.
//
//  The pStreamInfo parameter needs to be set to stream the decoded content
//  output.
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgOpenToDecode(
#else
CryptMsgOpenToDecode(
#endif
    IN DWORD dwEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN HCRYPTPROV hCryptProv,
    IN PCERT_INFO pRecipientInfo,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo)
{
    DWORD                   dwError = ERROR_SUCCESS;
    HCRYPTMSG               hcrmsg;
    PCRYPT_MSG_INFO         pcmi = NULL;

    if (GET_CMSG_ENCODING_TYPE(dwEncodingType) != PKCS_7_ASN_ENCODING)
        goto InvalidEncodingTypeError;

    if (NULL != pRecipientInfo)
        goto RecipientInfoNotSupportedYet;

    if (NULL == (pcmi = (PCRYPT_MSG_INFO)ICM_AllocZero( sizeof( CRYPT_MSG_INFO))))
        goto AllocCmsgError;

    if (0 == hCryptProv) {
        pcmi->fDefaultCryptProv = TRUE;
        pcmi->hCryptProv = I_CryptGetDefaultCryptProv(0);
        if (0 == pcmi->hCryptProv)
            goto GetDefaultCryptProvError;
    } else
        pcmi->hCryptProv        = hCryptProv;

    pcmi->dwEncodingType    = dwEncodingType;
    pcmi->dwMsgType         = dwMsgType;
    pcmi->dwFlags           = dwFlags;
    pcmi->dwPhase           = PHASE_FIRST_ONGOING;
    if (pStreamInfo &&
            (NULL == (pcmi->pStreamInfo = (PCMSG_STREAM_INFO)ICM_DupMem(
                                            pStreamInfo,
                                            sizeof(*pStreamInfo)))))
        goto DupStreamInfoError;

    if (!Pki_InitializeCriticalSection( &pcmi->CriticalSection))
        goto InitializeCriticalSectionError;
    pcmi->lRefCnt = 1;
    hcrmsg = (HCRYPTMSG)pcmi;

CommonReturn:
    ICM_SetLastError(dwError);
    return hcrmsg;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( pcmi);
    hcrmsg = NULL;
    goto CommonReturn;
SET_ERROR(InvalidEncodingTypeError,E_INVALIDARG)
SET_ERROR(RecipientInfoNotSupportedYet,E_INVALIDARG)
TRACE_ERROR(AllocCmsgError)                         // error already set
TRACE_ERROR(GetDefaultCryptProvError)               // error already set
TRACE_ERROR(DupStreamInfoError)                     // error already set
TRACE_ERROR(InitializeCriticalSectionError)         // error already set
}

//+-------------------------------------------------------------------------
//  Duplicate a cryptographic message handle
//--------------------------------------------------------------------------
HCRYPTMSG
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgDuplicate(
#else
CryptMsgDuplicate(
#endif
    IN HCRYPTMSG hCryptMsg
    )
{
    PCRYPT_MSG_INFO     pcmi = (PCRYPT_MSG_INFO)hCryptMsg;
    if (pcmi)
        InterlockedIncrement(&pcmi->lRefCnt);
    return hCryptMsg;
}


//+-------------------------------------------------------------------------
//  Close a cryptographic message handle
//
//  NB- Must preserve LastError.
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgClose(
#else
CryptMsgClose(
#endif
    IN HCRYPTMSG hCryptMsg)
{
    DWORD               dwError;
    BOOL                fRet;
    PCRYPT_MSG_INFO     pcmi = (PCRYPT_MSG_INFO)hCryptMsg;
    PCMSG_STREAM_INFO   pcsi;

    if (NULL == hCryptMsg)
        return TRUE;
    if (0 != InterlockedDecrement(&pcmi->lRefCnt))
        return TRUE;

    // Preserve LastError
    dwError = GetLastError();

    pcsi = pcmi->pStreamInfo;

    switch (pcmi->dwMsgType) {
    case CMSG_DATA:
    {
        OctetStringType *poos = (OctetStringType *)pcmi->pvMsg;

        if (!poos)
            break;
        if (pcmi->fEncoding) {
            ICM_Free( poos->value);
            ICM_Free( poos);
        } else {
            PkiAsn1FreeInfo( ICM_GetDecoder(), OctetStringType_PDU, poos);
        }
        break;
    }
    case CMSG_SIGNED:
    {
        SignedData  *psd = (SignedData *)pcmi->pvMsg;

        if (!(psd || pcmi->psdi))
            break;
        if (pcmi->fEncoding) {
            if (psd->signerInfos.value) {
                SignerInfo  *psi;
                DWORD       i;

                for (i=psd->signerInfos.count, psi=psd->signerInfos.value;
                        i>0;
                        i--, psi++)
                    ICM_FreeAsnSignerInfo(psi);
                ICM_Free( psd->signerInfos.value);
            }

            if (ICM_IsAddInnerContentOctetWrapper(pcmi) &&
                    psd->contentInfo.content.length &&
                    psd->contentInfo.content.value)
                PkiAsn1FreeEncoded( ICM_GetEncoder(),
                    psd->contentInfo.content.value);
            if (psd->digestAlgorithms.count && psd->digestAlgorithms.value)
                ICM_Free( psd->digestAlgorithms.value);
            ICM_Free( psd);
            ICM_Free( pcmi->pszInnerContentObjID);

        } else {
            // decoding
            delete pcmi->psdi->pAlgidList;
            delete pcmi->psdi->pCertificateList;
            delete pcmi->psdi->pCrlList;
            delete pcmi->psdi->pSignerList;
            ICM_Free( pcmi->psdi->pci);
            ICM_Free( pcmi->psdi);
        }
        if (pcmi->pHashList)
            delete pcmi->pHashList;
#ifdef CMS_PKCS7
        if (pcmi->rgSignerEncodeDataInfo) {
            assert(pcmi->cSignerEncodeDataInfo);
            if (pcmi->dwFlags & CMSG_CRYPT_RELEASE_CONTEXT_FLAG) {
                DWORD       i;

                for (i = 0; i < pcmi->cSignerEncodeDataInfo; i++) {
                    if (pcmi->rgSignerEncodeDataInfo[i].hCryptProv)
                        CryptReleaseContext(
                            pcmi->rgSignerEncodeDataInfo[i].hCryptProv, 0);
                }
            }
            ICM_Free(pcmi->rgSignerEncodeDataInfo);
        }
#endif  // CMS_PKCS7
        break;
    }

    case CMSG_ENVELOPED:
    {
#ifdef CMS_PKCS7
        CmsEnvelopedData   *ped = (CmsEnvelopedData *)pcmi->pvMsg;
#else
        EnvelopedData   *ped = (EnvelopedData *)pcmi->pvMsg;
        RecipientInfo   *pri;
#endif  // CMS_PKCS7
        DWORD           i;

        if (pcmi->hkeyContentCrypt)
            CryptDestroyKey( pcmi->hkeyContentCrypt);
        ICM_Free( pcmi->Plaintext.pbData);
#ifndef CMS_PKCS7
        ICM_Free( pcmi->pbEncryptParameters);
#endif  // CMS_PKCS7
        if (pcmi->fEncoding) {
#ifdef CMS_PKCS7
            ICM_FreeOssCmsRecipientInfos(&ped->recipientInfos);

            if (ped->unprotectedAttrs.value) {
                Attribute *poatr;

                for (i=ped->unprotectedAttrs.count,
                        poatr=ped->unprotectedAttrs.value;
                        i>0;
                        i--, poatr++) {
                    ICM_Free(poatr->attributeValue.value);
                }
                ICM_Free(ped->unprotectedAttrs.value);
            }
    
#else
            for (i=ped->recipientInfos.count, pri=ped->recipientInfos.value;
                    i>0;
                    i--, pri++)
                ICM_Free( pri->encryptedKey.value);
            ICM_Free( ped->recipientInfos.value);
#endif  // CMS_PKCS7
            ICM_Free( ped->encryptedContentInfo.encryptedContent.value);
            ICM_Free( ped);
            ICM_Free( pcmi->pszInnerContentObjID);
        } else {
            // decoding
#ifdef CMS_PKCS7
            if (NULL != pcmi->pCertificateList)
                delete pcmi->pCertificateList;
            if (NULL != pcmi->pCrlList)
                delete pcmi->pCrlList;
#endif  // CMS_PKCS7
            if (pcsi) {
                ICM_Free( ped);
            } else {
#ifdef CMS_PKCS7
                PkiAsn1FreeInfo( ICM_GetDecoder(), CmsEnvelopedData_PDU, ped);
#else
                PkiAsn1FreeInfo( ICM_GetDecoder(), EnvelopedData_PDU, ped);
#endif  // CMS_PKCS7
            }
        }
        break;
    }

    case CMSG_HASHED:
    {
        DigestedData  *pdd = (DigestedData *)pcmi->pvMsg;
        if (pcmi->fEncoding) {
            if (ICM_IsAddInnerContentOctetWrapper(pcmi) &&
                    pdd->contentInfo.content.length &&
                    pdd->contentInfo.content.value)
                PkiAsn1FreeEncoded( ICM_GetEncoder(),
                    pdd->contentInfo.content.value);
            ICM_Free ((DigestedData *)pcmi->pvMsg);
            ICM_Free( pcmi->pszInnerContentObjID);
        } else {
            // decoding
            PkiAsn1FreeInfo( ICM_GetDecoder(), DigestedData_PDU,
                (DigestedData *)pcmi->pvMsg);
        }
        if (pcmi->pHashList)
            delete pcmi->pHashList;
        break;
    }

    case CMSG_SIGNED_AND_ENVELOPED:
    case CMSG_ENCRYPTED:
        goto MessageTypeNotSupportedYet;

    default:
        goto InvalidMsgType;
    }

    fRet = TRUE;
CommonReturn:
#ifdef CMS_PKCS7
    if (pcmi->pFreeList)
        delete pcmi->pFreeList;
#endif  // CMS_PKCS7
    if (pcmi->plDecodeInfo)
        delete pcmi->plDecodeInfo;
    ICM_Free( pcmi->pStreamInfo);
    ICM_Free( pcmi->bufOutput.pbData);
    ICM_Free( pcmi->bufCrypt.pbData);
    ICM_Free( pcmi->bufPendingCrypt.pbData);
    ICM_Free( pcmi->bufDecode.pbData);
    ICM_Free( pcmi->bufEncode.pbData);

    if (pcmi->pooid)
        PkiAsn1FreeDecoded(ICM_GetDecoder(), pcmi->pooid,
            ObjectIdentifierType_PDU);

    if ((pcmi->dwFlags & CMSG_CRYPT_RELEASE_CONTEXT_FLAG) &&
            !pcmi->fDefaultCryptProv && pcmi->hCryptProv)
        CryptReleaseContext(pcmi->hCryptProv, 0);
    if (pcmi->hCryptProvContentCrypt)
        CryptReleaseContext(pcmi->hCryptProvContentCrypt, 0);
    DeleteCriticalSection( &pcmi->CriticalSection);

    ICM_Free( hCryptMsg);
    SetLastError(dwError);              // Preserve LastError
    return fRet;

ErrorReturn:
    fRet = TRUE;
    goto CommonReturn;
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
TRACE_ERROR(InvalidMsgType)
}


//+-------------------------------------------------------------------------
// Since the encoding might be indefinite-length encoded,
// decode and re-encode as DER.
//
// Returns:    FALSE iff fails
//
// NB: The caller of this routine needs to call
//          PkiAsn1FreeEncoded( ICM_GetEncoder(), pbOut);
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ReEncodeAsOctetDER(
    IN PBYTE    pbIn,
    IN DWORD    cbIn,
    OUT PBYTE   *ppbOut,
    OUT DWORD   *pcbOut)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    ASN1error_e Asn1Err;
    ASN1decoding_t pDec = ICM_GetDecoder();
    PVOID       pvMsg = NULL;

    DWORD dwExceptionCode;

  // Handle MappedFile Exceptions
  __try {

    if (0 != (Asn1Err = PkiAsn1Decode(pDec, (void **)&pvMsg,
            OctetStringType_PDU, pbIn, cbIn)))
        goto DecodeInnerContentError;
    if (0 != (Asn1Err = PkiAsn1Encode(ICM_GetEncoder(), pvMsg,
             OctetStringType_PDU, ppbOut, pcbOut)))
        goto EncodeInnerContentError;
    fRet = TRUE;

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwExceptionCode = GetExceptionCode();
    goto ExceptionError;
  }

CommonReturn:
    PkiAsn1FreeInfo(pDec, OctetStringType_PDU, pvMsg);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    *ppbOut = NULL;
    *pcbOut = 0;
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(DecodeInnerContentError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(EncodeInnerContentError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}


//+-------------------------------------------------------------------------
//  Update the digest
//
//  Returns:
//          FALSE iff error
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateDigest(
    IN HCRYPTHASH hHash,
    IN const BYTE *pbData,
    IN DWORD cbData)
{
    BOOL    fRet;

    if (0 != cbData)
        fRet = CryptHashData(
                    hHash,
                    pbData,
                    cbData,
                    0);                     // dwFlags
    else
        fRet = TRUE;

    if (!fRet)
        goto HashDataError;

CommonReturn:
    return fRet;

ErrorReturn:
    goto CommonReturn;
TRACE_ERROR(HashDataError)      // error already set
}


//+-------------------------------------------------------------------------
//  Update the digests in a list
//
//  Returns:
//          FALSE iff error
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateListDigest(
    IN CHashList    *pHashList,
    IN const BYTE   *pbData,
    IN DWORD        cbData)
{
    BOOL        fRet;
    CHashNode   *pnHash;

    if (pHashList) {
        for (pnHash=pHashList->Head(); pnHash; pnHash=pnHash->Next()) {
            if (!ICM_UpdateDigest( pnHash->Data()->hHash, pbData, cbData))
                goto UpdateDigestError;
        }
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(UpdateDigestError)  // error already set
}


//+-------------------------------------------------------------------------
//  Alloc and sign a hash.
//
//  Returns:    FALSE iff failed
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_AllocAndSignHash(
    IN HCRYPTHASH   hHash,
    IN DWORD        dwKeySpec,
    IN DWORD        dwAlgIdPubKey,
    IN DWORD        dwPubKeyFlags,
    IN BOOL         fMaxLength,
    OUT PBYTE       *ppbSignature,
    OUT DWORD       *pcbSignature)
{
    DWORD   dwError = ERROR_SUCCESS;
    BOOL    fRet;
    PBYTE   pbSignature = NULL;
    DWORD   cbSignature = 0;

    if (dwKeySpec == 0)
        dwKeySpec = AT_SIGNATURE;

    if (CALG_NO_SIGN == dwAlgIdPubKey) {
        if (!CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                NULL,
                &cbSignature,
                0))                     // dwFlags
            goto GetHashParamSizeError;
        if (NULL == (pbSignature = (PBYTE)ICM_Alloc( cbSignature)))
            goto AllocHashParamError;
        if (!CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                pbSignature,
                &cbSignature,
                0))                     // dwFlags
            goto GetHashParamError;
    } else if (CALG_DSS_SIGN == dwAlgIdPubKey &&
            0 == (dwPubKeyFlags & CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG)) {
        DWORD cbData;
        BYTE rgbDssSignature[CERT_DSS_SIGNATURE_LEN];

        cbData = sizeof(rgbDssSignature);
        if (!CryptSignHash(
                hHash,
                dwKeySpec,
                NULL,               // sDescription
                0,                  // dwFlags
                rgbDssSignature,
                &cbData
                )) goto SignHashError;
        assert(cbData == sizeof(rgbDssSignature));

        if (NULL == (pbSignature = (PBYTE)ICM_Alloc(
                CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN)))
            goto AllocSignatureError;
        // Convert from the CSP signature format to an ASN.1 sequence of
        // two integers
        cbSignature = CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN;
        if (!CryptEncodeObject(
                X509_ASN_ENCODING,
                X509_DSS_SIGNATURE,
                rgbDssSignature,
                pbSignature,
                &cbSignature
                )) goto EncodeDssSignatureError;
        if (fMaxLength) {
            int cbRemain;
            assert(CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN >= cbSignature);
            cbRemain = CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN - cbSignature;
            if (cbRemain > 0) {
                memset(pbSignature + cbSignature, 0, cbRemain);
                cbSignature = CERT_MAX_ASN_ENCODED_DSS_SIGNATURE_LEN;
            }
        }
    } else {
        if (!CryptSignHash(
                hHash,
                dwKeySpec,
                NULL,               // description ?
                0,                  // dwFlags
                NULL,               // pbSignature
                &cbSignature))
            goto SignHashSizeError;
        if (NULL == (pbSignature = (PBYTE)ICM_Alloc( cbSignature)))
            goto AllocSignatureError;
        if (!CryptSignHash(
                hHash,
                dwKeySpec,
                NULL,               // description ?
                0,                  // dwFlags
                pbSignature,
                &cbSignature))
            goto SignHashError;
        ICM_ReverseInPlace( pbSignature, cbSignature);
    }

    fRet = TRUE;
CommonReturn:
    *ppbSignature = pbSignature;
    *pcbSignature = cbSignature;
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( pbSignature);
    pbSignature = NULL;
    cbSignature = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetHashParamSizeError)  // error already set
TRACE_ERROR(AllocHashParamError)    // error already set
TRACE_ERROR(GetHashParamError)      // error already set
TRACE_ERROR(SignHashSizeError)      // error already set
TRACE_ERROR(AllocSignatureError)    // error already set
TRACE_ERROR(SignHashError)          // error already set
TRACE_ERROR(EncodeDssSignatureError) // error already set
}


//+-------------------------------------------------------------------------
//  Get the hash of a blob.
//
//  Returns:    FALSE iff failed
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetBlobHash(
    IN HCRYPTPROV       hCryptProv,
    IN DWORD            dwDigestAlgorithm,
    IN PBYTE            pb,
    IN DWORD            cb,
    OUT HCRYPTHASH      *phHash)
{
    BOOL                fRet;
    HCRYPTHASH          hHash;

    if (!CryptCreateHash(
            hCryptProv,
            dwDigestAlgorithm,
            NULL,               // hKey - optional for MAC
            0,                  // dwFlags
            &hHash))
        goto CreateHashError;
    if (!ICM_UpdateDigest( hHash, pb, cb))
        goto UpdateDigestError;

    fRet = TRUE;
CommonReturn:
    *phHash = hHash;
    return fRet;

ErrorReturn:
    hHash = NULL;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CreateHashError)    // error already set
TRACE_ERROR(UpdateDigestError)  // error already set
}


//+-------------------------------------------------------------------------
//  Get the hash of an OSS Attributes. This is used to hash the authenticated
//  attributes for a Signed or SignedAndEnveloped message.
//
//  Returns:    FALSE iff failed
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetAttrsHash(
    IN DWORD            dwDigestAlgorithm,
    IN HCRYPTPROV       hCryptProv,
    IN Attributes       *possAttrs,
    OUT HCRYPTHASH      *phHash)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    ASN1error_e         Asn1Err;
    ASN1encoding_t      pEnc = ICM_GetEncoder();
    PBYTE               pbEncoded = NULL;
    DWORD               cbEncoded;
    HCRYPTHASH          hHash;

    if (!CryptCreateHash(
            hCryptProv,
            dwDigestAlgorithm,
            NULL,               // hKey - optional for MAC
            0,                  // dwFlags
            &hHash))
        goto CreateHashError;
    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            possAttrs,
            Attributes_PDU,
            &pbEncoded,
            &cbEncoded)))
        goto EncodeAttributesError;
    if (!ICM_UpdateDigest(
            hHash,
            pbEncoded,
            cbEncoded))
        goto UpdateDigestAttributesError;

    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    *phHash = hHash;
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    hHash = NULL;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(EncodeAttributesError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(CreateHashError)                // error already set
TRACE_ERROR(UpdateDigestAttributesError)    // error already set
}


//+-------------------------------------------------------------------------
//  Compare 2 OSS object id's.
//
//  Returns:    FALSE iff !equal
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_EqualObjectIDs(
    IN ObjectID     *poid1,
    IN ObjectID     *poid2)
{
    BOOL        fRet;
    DWORD       i;
    PDWORD      pdw1;
    PDWORD      pdw2;

    if (poid1->count != poid2->count)
        goto Unequal;
    for (i=poid1->count, pdw1=poid1->value, pdw2=poid2->value;
            (i>0) && (*pdw1==*pdw2);
            i--, pdw1++, pdw2++)
        ;
    if (i>0)
        goto Unequal;

    fRet = TRUE;        // equal
CommonReturn:
    return fRet;

Unequal:
    fRet = FALSE;       // !equal
    goto CommonReturn;
}


//+-------------------------------------------------------------------------
//  Get the value of an Attribute of a given type.
//
//  Returns:    FALSE iff fails
//
//  NB- Does not set error
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetAttrValue(
    IN Attributes   *poatrs,
    IN ObjectID     *poid,
    OUT Any         *panyValue)
{
    BOOL        fRet;
    DWORD       i;
    Attribute   *poatr;

    for (i=poatrs->count, poatr=poatrs->value; i>0; i--, poatr++) {
        if (ICM_EqualObjectIDs( &poatr->attributeType, poid))
            break;
    }
    if (0 == i)
        goto AttributeNotFoundError;

    *panyValue = *poatr->attributeValue.value;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    panyValue->length = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(AttributeNotFoundError)
}


//+-------------------------------------------------------------------------
//  Fill in the content-type and message-digest authenticated attributes,
//  which are required in a SignedData or SignedAndEnvelopedData message.
//
//  Returns:    FALSE iff failed
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillReqAuthAttrs(
    IN OPTIONAL LPSTR   pszInnerContentObjID,
    IN CHashNode        *pnHash,
    IN OUT Attribute    *possAttr)
{
    BOOL                fRet;
    CRYPT_ATTRIBUTE     atr;
    CRYPT_ATTR_BLOB     atrblob;
    ASN1error_e         Asn1Err;
    ASN1encoding_t      pEnc = ICM_GetEncoder();
    PBYTE               pbEncoded;
    DWORD               cbEncoded;
    ObjectID            ossObjID;
    OctetStringType     ost;

    // NB - When psi->authenticatedAttributes was created,
    //      the first 2 slots were reserved for the
    //      content-type and message-digest attributes.

    // content-type attribute
    ossObjID.count = sizeof(ossObjID.value)/sizeof(ossObjID.value[0]);
    if (!PkiAsn1ToObjectIdentifier(
            pszInnerContentObjID ? pszInnerContentObjID : pszObjIdDataType,
            &ossObjID.count,
            ossObjID.value))
        goto ConvToObjectIdentifierError;
    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            &ossObjID,
            ObjectIdentifierType_PDU,
            &pbEncoded,
            &cbEncoded)))
        goto EncodeObjectIdentifierError;
    atr.pszObjId = pszObjIdContentType;
    atr.cValue = 1;
    atr.rgValue = &atrblob;
    atrblob.cbData = cbEncoded;
    atrblob.pbData = pbEncoded;
    fRet = ICM_Asn1ToAttribute( &atr, possAttr);
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    if (!fRet)
        goto ContentTypeAsn1ToAttributeError;

    // message-digest attribute
    if (!ICM_GetListHashValue( pnHash, (DWORD*)&ost.length, &ost.value))
        goto GetHashValueError;
    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            &ost,
            OctetStringType_PDU,
            &pbEncoded,
            &cbEncoded)))
        goto EncodeOctetStringError;
    atr.pszObjId = pszObjIdMessageDigest;
    atr.cValue = 1;
    atr.rgValue = &atrblob;
    atrblob.cbData = cbEncoded;
    atrblob.pbData = pbEncoded;
    fRet = ICM_Asn1ToAttribute( &atr, possAttr + 1);
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    if (!fRet)
        goto MsgDigestAsn1ToAttributeError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(EncodeObjectIdentifierError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(EncodeOctetStringError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(ConvToObjectIdentifierError,CRYPT_E_OID_FORMAT)
TRACE_ERROR(ContentTypeAsn1ToAttributeError)     // error already set
TRACE_ERROR(GetHashValueError)                      // error already set
TRACE_ERROR(MsgDigestAsn1ToAttributeError)       // error already set
}


//+-------------------------------------------------------------------------
//  Fill the inner ContentInfo.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillInnerContentInfo(
    OUT ContentInfo     *pci,
    IN OPTIONAL LPSTR   pszInnerID,
    IN DWORD            cbData,
    IN const BYTE       *pbData,
    IN BOOL             fAddInnerContentOctetWrapper    // CMS_PKCS7
    )
{
    BOOL                fRet;
    ASN1error_e         Asn1Err;
    PBYTE               pbEncoded;
    DWORD               cbEncoded;
    OctetStringType     ost;

    pci->contentType.count = sizeof(pci->contentType.value)/sizeof(pci->contentType.value[0]);
    if (!PkiAsn1ToObjectIdentifier(
            pszInnerID ? pszInnerID : pszObjIdDataType,
            &pci->contentType.count,
            pci->contentType.value))
        goto PkiAsn1ToObjectIdentifierError;
    if (0 != cbData) {
        pci->bit_mask |= content_present;
        if (!fAddInnerContentOctetWrapper) {
            pci->content.length = cbData;
            pci->content.value  = (PBYTE)pbData;
        } else {
            ost.length = cbData;
            ost.value  = (PBYTE)pbData;
            if (0 != (Asn1Err = PkiAsn1Encode(
                    ICM_GetEncoder(),
                    &ost,
                    OctetStringType_PDU,
                    &pbEncoded,
                    &cbEncoded)))
                goto EncodeOctetStringError;
            pci->content.length = cbEncoded;
            pci->content.value  = pbEncoded;
        }
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(PkiAsn1ToObjectIdentifierError,CRYPT_E_OID_FORMAT)
SET_ERROR_VAR(EncodeOctetStringError, PkiAsn1ErrToHr(Asn1Err))
}

#ifdef CMS_PKCS7

//+-------------------------------------------------------------------------
//  Fill in the encrypted digest in a signer info.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillSignerEncryptedDigest(
    IN SignerInfo       *psi,
    IN OPTIONAL LPSTR   pszInnerContentObjID,
    IN PSIGNER_ENCODE_DATA_INFO pSignerEncodeDataInfo,
    IN BOOL             fMaxLength)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
    HCRYPTHASH      hHash;
    HCRYPTHASH      hHashAttr = NULL;
    HCRYPTHASH      hHashDup = NULL;
    PBYTE           pbSignature = NULL;
    DWORD           cbSignature;
    CHashNode       *pnHash = pSignerEncodeDataInfo->pHashNode;
    PICM_HASH_INFO  pHashInfo = pnHash->Data();

    PCCRYPT_OID_INFO pOIDInfo;
    DWORD           dwAlgIdPubKey;
    DWORD           dwPubKeyFlags;

    if (psi->bit_mask & authenticatedAttributes_present) {
        if (!ICM_FillReqAuthAttrs(
                pszInnerContentObjID,
                pSignerEncodeDataInfo->pHashNode,
                psi->authenticatedAttributes.value))
            goto FillReqAuthAttrsError;
        if (!ICM_GetAttrsHash(
                pHashInfo->dwAlgoCAPI,
                pSignerEncodeDataInfo->hCryptProv,
                &psi->authenticatedAttributes,
                &hHashAttr))
            goto GetAuthAttrsHashError;
        hHash = hHashAttr;
    } else {
        if (!ICM_DupListHash( pnHash, pSignerEncodeDataInfo->hCryptProv,
                &hHashDup))
            goto DupListHashError;
        hHash = hHashDup;
    }

    dwAlgIdPubKey = 0;
    dwPubKeyFlags = 0;
    if (pOIDInfo = ICM_GetOssOIDInfo(CRYPT_PUBKEY_ALG_OID_GROUP_ID,
            &psi->digestEncryptionAlgorithm)) {
        dwAlgIdPubKey = pOIDInfo->Algid;
        if (1 <= pOIDInfo->ExtraInfo.cbData / sizeof(DWORD)) {
            DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;
            dwPubKeyFlags = pdwExtra[0];
        }
    } else if (pOIDInfo = ICM_GetOssOIDInfo(CRYPT_SIGN_ALG_OID_GROUP_ID,
            &psi->digestEncryptionAlgorithm)) {
        DWORD cExtra = pOIDInfo->ExtraInfo.cbData / sizeof(DWORD);
        DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;

        if (1 <= cExtra) {
            dwAlgIdPubKey = pdwExtra[0];
            if (2 <= cExtra)
                dwPubKeyFlags = pdwExtra[1];
        }
    }

    if (!ICM_AllocAndSignHash( hHash, pSignerEncodeDataInfo->dwKeySpec,
            dwAlgIdPubKey, dwPubKeyFlags, fMaxLength,
            &pbSignature, &cbSignature))
        goto AllocAndSignHashError;
    psi->encryptedDigest.length = cbSignature;
    psi->encryptedDigest.value  = pbSignature;
    pbSignature = NULL;

    fRet = TRUE;
CommonReturn:
    if (hHashAttr)
        CryptDestroyHash( hHashAttr);
    if (hHashDup)
        CryptDestroyHash( hHashDup);
    ICM_Free(pbSignature);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FillReqAuthAttrsError)      // error already set
TRACE_ERROR(GetAuthAttrsHashError)      // error already set
TRACE_ERROR(DupListHashError)           // error already set
TRACE_ERROR(AllocAndSignHashError)      // error already set
}

BOOL
WINAPI
ICM_FillSignerEncodeEncryptedDigests(
    IN PCRYPT_MSG_INFO  pcmi,
    IN BOOL             fMaxLength)
{
    LPSTR pszInnerContentObjID = pcmi->pszInnerContentObjID;
    DWORD cSignerEncodeDataInfo = pcmi->cSignerEncodeDataInfo;
    PSIGNER_ENCODE_DATA_INFO pSignerEncodeDataInfo =
        pcmi->rgSignerEncodeDataInfo;
    SignedData *psd = (SignedData *)pcmi->pvMsg;
    SignerInfo *psi = psd->signerInfos.value;

    assert(psd->signerInfos.count == cSignerEncodeDataInfo);

    for ( ; 0 < cSignerEncodeDataInfo;
                                cSignerEncodeDataInfo--,
                                pSignerEncodeDataInfo++,
                                psi++) {
        if (!ICM_FillSignerEncryptedDigest(
                psi,
                pszInnerContentObjID,
                pSignerEncodeDataInfo,
                fMaxLength))
            return FALSE;
    }

    return TRUE;
}
#else

//+-------------------------------------------------------------------------
//  Fill in the encrypted digest in a signer info.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FillSignerEncryptedDigest(
    IN SignerInfo       *psi,
    IN OPTIONAL LPSTR   pszInnerContentObjID,
    IN CHashNode        *pnHash,
    IN DWORD            dwKeySpec,
    IN BOOL             fMaxLength)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
    HCRYPTHASH      hHash;
    HCRYPTHASH      hHashAttr = NULL;
    HCRYPTHASH      hHashDup = NULL;
    PBYTE           pbSignature = NULL;
    DWORD           cbSignature;
    PICM_HASH_INFO  pHashInfo = pnHash->Data();

    PCCRYPT_OID_INFO pOIDInfo;
    DWORD           dwAlgIdPubKey;
    DWORD           dwPubKeyFlags;

    if (psi->bit_mask & authenticatedAttributes_present) {
        if (!ICM_FillReqAuthAttrs(
                pszInnerContentObjID,
                pnHash,
                psi->authenticatedAttributes.value))
            goto FillReqAuthAttrsError;
        if (!ICM_GetAttrsHash(
                pHashInfo->dwAlgoCAPI,
                pHashInfo->hCryptProv,
                &psi->authenticatedAttributes,
                &hHashAttr))
            goto GetAuthAttrsHashError;
        hHash = hHashAttr;
    } else {
        if (!ICM_DupListHash( pnHash, pHashInfo->hCryptProv, &hHashDup))
            goto DupListHashError;
        hHash = hHashDup;
    }

    dwAlgIdPubKey = 0;
    dwPubKeyFlags = 0;
    if (pOIDInfo = ICM_GetOssOIDInfo(CRYPT_PUBKEY_ALG_OID_GROUP_ID,
            &psi->digestEncryptionAlgorithm)) {
        dwAlgIdPubKey = pOIDInfo->Algid;
        if (1 <= pOIDInfo->ExtraInfo.cbData / sizeof(DWORD)) {
            DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;
            dwPubKeyFlags = pdwExtra[0];
        }
    }

    if (!ICM_AllocAndSignHash( hHash, dwKeySpec,
            dwAlgIdPubKey, dwPubKeyFlags, fMaxLength,
            &pbSignature, &cbSignature))
        goto AllocAndSignHashError;
    psi->encryptedDigest.length = cbSignature;
    psi->encryptedDigest.value  = pbSignature;
    pbSignature = NULL;

    fRet = TRUE;
CommonReturn:
    if (hHashAttr)
        CryptDestroyHash( hHashAttr);
    if (hHashDup)
        CryptDestroyHash( hHashDup);
    ICM_Free(pbSignature);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FillReqAuthAttrsError)      // error already set
TRACE_ERROR(GetAuthAttrsHashError)      // error already set
TRACE_ERROR(DupListHashError)           // error already set
TRACE_ERROR(AllocAndSignHashError)      // error already set
}
#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Update the content of a signed message.
//
//  Assume all more-deeply-nested messages are DER-encoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateEncodingSignedData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal)
{
    BOOL                fRet;
    SignedData          *psd = (SignedData *)pcmi->pvMsg;
    LPSTR               pszInnerContentObjID = pcmi->pszInnerContentObjID;
    PBYTE               pb;
    DWORD               cb;
    PCMSG_STREAM_INFO   pcsi = pcmi->pStreamInfo;

    BOOL                fAddInnerContentOctetWrapper;   // CMS_PKCS7

    if (pcsi) {
        if (!ICMS_UpdateEncodingSignedData( pcmi, (PBYTE)pbData, cbData, fFinal))
            goto StreamUpdateEncodingSignedDataError;
    } else {
        psd->contentInfo.bit_mask = 0;

        fAddInnerContentOctetWrapper = ICM_IsAddInnerContentOctetWrapper(pcmi);
        if (0 == (pcmi->dwFlags & CMSG_DETACHED_FLAG) &&
                !fAddInnerContentOctetWrapper && pbData) {
            // must be encoded, hash only the contents octets
            if (0 > Asn1UtilExtractContent(
                        (PBYTE)pbData,
                        cbData,
                        &cb,
                        (const BYTE **)&pb))
                goto ExtractContentError;
        } else {
            cb = cbData;
            pb = (PBYTE)pbData;
        }
        if (!ICM_UpdateListDigest( pcmi->pHashList, pb, cb))
            goto UpdateDigestError;

        if (fFinal) {
            if (pcmi->dwFlags & CMSG_DETACHED_FLAG) {
                if (!ICM_FillInnerContentInfo(
                        &psd->contentInfo,
                        pszInnerContentObjID,
                        0,                      // cbData
                        NULL,                   // pbData
                        FALSE))                 // fAddInnerContentOctetWrapper
                    goto DetachedFillInnerContentInfoError;
            } else {
                if (!ICM_FillInnerContentInfo(
                        &psd->contentInfo,
                        pszInnerContentObjID,
                        cbData,
                        (PBYTE)pbData,
                        fAddInnerContentOctetWrapper
                        ))
                    goto FillInnerContentInfoError;
            }

#ifdef CMS_PKCS7
            if (pcmi->rgSignerEncodeDataInfo) {
                BOOL fMaxLength =
                    (0 != (pcmi->dwFlags & CMSG_MAX_LENGTH_FLAG));
                if (!ICM_FillSignerEncodeEncryptedDigests(
                        pcmi,
                        fMaxLength))
                    goto FillSignerEncodeEncryptedDigestsError;
            }
#else
            if (pcmi->pHashList) {
                BOOL fMaxLength =
                    (0 != (pcmi->dwFlags & CMSG_MAX_LENGTH_FLAG));
                if (!ICM_FillSignerEncryptedDigest(
                                psd->signerInfos.value,
                                pszInnerContentObjID,
                                pcmi->pHashList->Head(),
                                pcmi->dwKeySpec,
                                fMaxLength))
                    goto FillSignerEncryptedDigestError;
            }
#endif  // CMS_PKCS7
        }
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
TRACE_ERROR(UpdateDigestError)                      // error already set
TRACE_ERROR(DetachedFillInnerContentInfoError)      // error already set
TRACE_ERROR(FillInnerContentInfoError)              // error already set
TRACE_ERROR(StreamUpdateEncodingSignedDataError)    // error already set
#ifdef CMS_PKCS7
TRACE_ERROR(FillSignerEncodeEncryptedDigestsError)  // error already set
#else
TRACE_ERROR(FillSignerEncryptedDigestError)         // error already set
#endif  // CMS_PKCS7
}


//+-------------------------------------------------------------------------
//  Update the content of a data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateEncodingData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbData,
    IN DWORD            cbData,
    IN BOOL             fFinal)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    OctetStringType     *poos = (OctetStringType *)pcmi->pvMsg;
    PCMSG_STREAM_INFO   pcsi = pcmi->pStreamInfo;

    if (!pcsi) {
        if (!fFinal)
            goto NotFinalNotSupportedError;

        poos->length = cbData;
        if (NULL == (poos->value = (PBYTE)ICM_DupMem( (PBYTE)pbData, cbData)))
            goto AllocOctetStringError;
    }

    if (pcsi && !ICMS_UpdateEncodingData( pcmi, (PBYTE)pbData, cbData, fFinal))
        goto StreamUpdateEncodingDataError;

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( poos->value);
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(NotFinalNotSupportedError,E_INVALIDARG)
TRACE_ERROR(AllocOctetStringError)                  // error already set
TRACE_ERROR(StreamUpdateEncodingDataError)          // error already set
}


//+-------------------------------------------------------------------------
//  Update the content of a digested message.
//
//  Assume all more-deeply-nested messages are DER-encoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateEncodingDigestedData(
    IN PCRYPT_MSG_INFO pcmi,
    IN const BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal)
{
    BOOL                fRet;
    DigestedData        *pdd = (DigestedData *)pcmi->pvMsg;
    PBYTE               pb;
    DWORD               cb;
    LPSTR               pszInnerContentObjID = pcmi->pszInnerContentObjID;
    BOOL                fAddInnerContentOctetWrapper;   // CMS_PKCS7

    pdd->contentInfo.bit_mask = 0;
    if (pcmi->dwFlags & CMSG_DETACHED_FLAG) {
        // must be non-encoded
        if (!ICM_UpdateListDigest( pcmi->pHashList, pbData, cbData))
            goto DetachedUpdateDigestError;
        if (!ICM_FillInnerContentInfo(
                &pdd->contentInfo,
                pszInnerContentObjID,
                0,                      // cbData
                NULL,                   // pbData
                FALSE                   // fAddInnerContentOctetWrapper
                ))
            goto DetachedFillInnerContentInfoError;
    } else {
        fAddInnerContentOctetWrapper = ICM_IsAddInnerContentOctetWrapper(pcmi);
        if (!fAddInnerContentOctetWrapper && pbData) {
            // must be encoded, hash only the contents octets
            if (0 > Asn1UtilExtractContent( (PBYTE)pbData, cbData, &cb,
                    (const BYTE **)&pb))
                goto ExtractContentError;
        } else {
            cb = cbData;
            pb = (PBYTE)pbData;
        }
        if (!ICM_UpdateListDigest( pcmi->pHashList, pb, cb))
            goto UpdateDigestError;
        if (!ICM_FillInnerContentInfo(
                &pdd->contentInfo,
                pszInnerContentObjID,
                cbData,
                (PBYTE)pbData,
                fAddInnerContentOctetWrapper
                ))
            goto FillInnerContentInfoError;
    }
    if (PHASE_FIRST_FINAL == pcmi->dwPhase) {
        if (!ICM_GetListHashValue(
                pcmi->pHashList->Head(),
                (DWORD*)&pdd->digest.length,
                &pdd->digest.value))
            goto GetHashValueError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
TRACE_ERROR(DetachedUpdateDigestError)          // error already set
TRACE_ERROR(UpdateDigestError)                  // error already set
TRACE_ERROR(DetachedFillInnerContentInfoError)  // error already set
TRACE_ERROR(FillInnerContentInfoError)          // error already set
TRACE_ERROR(GetHashValueError)                  // error already set
fFinal;
}


//+-------------------------------------------------------------------------
//  Get the block size for an encryption algorithm
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetKeyBlockSize(
    IN HCRYPTKEY        hkeyEncrypt,
    OUT PDWORD          pcbBlockSize,
    OUT OPTIONAL PBOOL  pfBlockCipher)
{
    BOOL            fRet;
    BOOL            fBlockCipher;
    DWORD           cbBlockSize;
    DWORD           cbKeyParamLen;

    // Get key's blocksize.
    // Encryption will pad the output data to be blocksize aligned,
    // in the case of a block cipher.
    cbBlockSize = 0;
    cbKeyParamLen = sizeof( cbBlockSize);
    if (!CryptGetKeyParam(
            hkeyEncrypt,
            KP_BLOCKLEN,
            (PBYTE)&cbBlockSize,
            &cbKeyParamLen,
            0))                     // dwFlags
        goto GetKeyParamError;

    if (0 == cbBlockSize) {
        // stream cipher
        fBlockCipher = FALSE;
        cbBlockSize  = 8;       // convenient size
    } else {
        // block cipher
        fBlockCipher = TRUE;
        cbBlockSize /= 8;       // convert from bits to bytes
    }

    fRet = TRUE;
CommonReturn:
    *pcbBlockSize = cbBlockSize;
    if (pfBlockCipher)
        *pfBlockCipher = fBlockCipher;
    return fRet;

ErrorReturn:
    cbBlockSize = 0;
    fBlockCipher = FALSE;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetKeyParamError)   // error already set
}


//+-------------------------------------------------------------------------
//  Encrypt a buffer
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_EncryptBuffer(
    IN HCRYPTKEY hkeyEncrypt,
    HCRYPTHASH   hHash,
    IN const BYTE *pbPlain,
    IN DWORD    cbPlain,
    OUT PBYTE   *ppbCipher,
    OUT PDWORD  pcbCipher)
{
    BOOL            fRet;
    const BYTE      *pbIn;
    DWORD           cbIn;
    PBYTE           pbOut;
    DWORD           cbOut;
    PBYTE           pbOutBuf = NULL;
    DWORD           cbPlainRemain;
    DWORD           cbBufRemain;
    DWORD           cbBlockLen;
    BOOL            fBlockCipher;

    if (!ICM_GetKeyBlockSize( hkeyEncrypt, &cbBlockLen, &fBlockCipher))
        goto GetKeyBlockSizeError;

    // encrypt
    cbBufRemain = cbPlain;
    if (fBlockCipher) {
        cbBufRemain += cbBlockLen;
        cbBufRemain -= cbBufRemain % cbBlockLen;
    }
    if (NULL == (pbOutBuf = (PBYTE)ICM_Alloc( cbBufRemain)))
        goto OutOfMemory;
    for (pbIn=pbPlain, pbOut=pbOutBuf, cbPlainRemain=cbPlain;
            (cbIn = min( cbBlockLen, cbPlainRemain)) > 0;
            pbIn += cbIn, pbOut += cbOut,
                cbPlainRemain -= cbIn, cbBufRemain -= cbOut) {

        memcpy( pbOut, pbIn, cbIn);
        cbOut = cbIn;
        if (!CryptEncrypt(
                    hkeyEncrypt,
                    hHash,
                    cbPlainRemain <= cbBlockLen,    // fFinal
                    0,                              // dwFlags
                    pbOut,
                    &cbOut,
                    cbBufRemain))
            goto EncryptError;
    }

    *ppbCipher = pbOutBuf;
    *pcbCipher = (DWORD)(pbOut - pbOutBuf);

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    if(NULL != pbOutBuf)
        ICM_Free(pbOutBuf);
    *ppbCipher = NULL;
    *pcbCipher = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetKeyBlockSizeError)       // error already set
TRACE_ERROR(EncryptError)               // error already set
TRACE_ERROR(OutOfMemory)                // error already set
}


//+-------------------------------------------------------------------------
//  Encrypt and store the content of a message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_EncryptContent(
    IN HCRYPTKEY                hkeyContentEncryption,
    HCRYPTHASH                  hHash,
    OUT EncryptedContentInfo    *peci,
    IN const BYTE               *pbPlain,
    IN DWORD                    cbPlain)
{
    BOOL    fRet;
    PBYTE   pbCipher = NULL;
    DWORD   cbCipher;

    if (!ICM_EncryptBuffer(
            hkeyContentEncryption,
            hHash,
            pbPlain,
            cbPlain,
            &pbCipher,
            &cbCipher))
        goto EncryptBufferError;

    if (0 != cbCipher) {
        peci->bit_mask |= encryptedContent_present;
        peci->encryptedContent.length = cbCipher;
        peci->encryptedContent.value = pbCipher;
    } else
        ICM_Free(pbCipher);

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EncryptBufferError)     // error already set
}


//+-------------------------------------------------------------------------
//  Update the content of a signed and enveloped message.
//
//  Assume all more-deeply-nested messages are DER-encoded.
//--------------------------------------------------------------------------
#if 0
BOOL
WINAPI
ICM_UpdateEncodingSignedAndEnvelopedData(
    IN PCRYPT_MSG_INFO pcmi,
    IN const BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    EncryptedContentInfo    *peci;
    SignedAndEnvelopedData  *psed;
    DWORD                   i;
    DWORD                   iMax;
    PBYTE                   pbSignature;
    DWORD                   cbSignature;
    PBYTE                   pbEncryptedSignature;
    DWORD                   cbEncryptedSignature;

    psed = (SignedAndEnvelopedData *)(pcmi->pvMsg);
    peci = &psed->encryptedContentInfo;

    // Require inner type to be Data for now
    peci->contentType = aoidMessages[ CMSG_DATA - 1];

    // Alloc a bigger buffer with padding and copy input to it

    // encrypt the content and store it
    if (!ICM_EncryptContent(
            pcmi->hkeyContentCrypt,
            pcmi->ahHash[0],        // select the right hHash
            peci,
            pbData,
            cbData))
        goto EncryptError;

    assert( 1 == psed->signerInfos.Count());
    for (i=0, iMax=psed->signerInfos.Count(); i<iMax; i++) {
        // Should use a stack buffer, unless it is too small
        if (!CryptSignHash(
                pcmi->ahHash[i],
                (pcmi->dwKeySpec == 0) ? AT_SIGNATURE : pcmi->dwKeySpec,
                NULL,               // description ?
                0,                  // dwFlags
                NULL,               // pbSignature
                &cbSignature))
            goto GetSignatureSizeError;
        pbSignature = (PBYTE)ICM_AllocA( cbSignature);
        if (NULL == pbSignature)
            goto AllocSignatureError;
        if (!CryptSignHash(
                pcmi->ahHash[i],
                (pcmi->dwKeySpec == 0) ? AT_SIGNATURE : pcmi->dwKeySpec,
                NULL,               // description ?
                0,                  // dwFlags
                pbSignature,
                &cbSignature))
            goto SignHashError;
        // encrypt the signature
        if (!ICM_EncryptBuffer(
                pcmi->hkeyContentCrypt,
                NULL,
                pbSignature,
                cbSignature,
                &pbEncryptedSignature,
                &cbEncryptedSignature))
            goto EncryptError;
        ICM_FreeA( pbSignature);
        pbSignature = NULL;
        if (0 > psed->signerInfos[i].encryptedDigest.Write(
                pbEncryptedSignature,
                cbEncryptedSignature))
            goto EncryptedDigestWriteError;
        ICM_Free( pbEncryptedSignature);
        pbEncryptedSignature = NULL;
    }

    fRet = TRUE;
CommonReturn:
    ICM_FreeA( pbSignature);
    ICM_Free( pbEncryptedSignature);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EncryptError)
TRACE_ERROR(GetSignatureSizeError)
TRACE_ERROR(AllocSignatureError)
TRACE_ERROR(SignHashError)
TRACE_ERROR(EncryptedDigestWriteError)
}
#endif


//+-------------------------------------------------------------------------
//  Update the content of an enveloped message.
//
//  Assume all more-deeply-nested messages are DER-encoded.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateEncodingEnvelopedData(
    IN PCRYPT_MSG_INFO pcmi,
    IN const BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal)
{
    BOOL                    fRet;
    PBYTE                   pb;
    DWORD                   cb;
#ifdef CMS_PKCS7
    EncryptedContentInfo    *peci = &((CmsEnvelopedData *)pcmi->pvMsg)->encryptedContentInfo;
#else
    EncryptedContentInfo    *peci = &((EnvelopedData *)pcmi->pvMsg)->encryptedContentInfo;
#endif  // CMS_PKCS7
    PCMSG_STREAM_INFO       pcsi = pcmi->pStreamInfo;

    if (pcsi) {
        if (!ICMS_UpdateEncodingEnvelopedData(
                            pcmi,
                            pbData,
                            cbData,
                            fFinal))
            goto StreamUpdateEncodingEnvelopedDataError;
    } else {
        if (!fFinal)
            goto InvalidArg;

        // encrypt the content
        if (!ICM_IsAddInnerContentOctetWrapper(pcmi)) {
            if (0 > Asn1UtilExtractContent( (PBYTE)pbData, cbData, &cb, (const BYTE **)&pb))
                goto ExtractContentError;
        } else {
            pb = (PBYTE)pbData;
            cb = cbData;
        }

        if (!ICM_EncryptContent(
                pcmi->hkeyContentCrypt,
                NULL,           // hHash
                peci,
                pb,
                cb))
            goto EncryptError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg,E_INVALIDARG)
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
TRACE_ERROR(EncryptError)                               // error already set
TRACE_ERROR(StreamUpdateEncodingEnvelopedDataError)     // error already set
}


//+-------------------------------------------------------------------------
//  Convert Any to blob and insert at the tail of a blob list
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_InsertTailBlob(
    IN OUT CBlobList    *pBlobList,
    IN Any              *pAny)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    CBlobNode               *pnBlob = NULL;
    PBYTE                   pb = NULL;
    DWORD                   cb;
    CRYPT_DATA_BLOB         blob;

    if (NULL == (pnBlob = new CBlobNode))
        goto NewCBlobNodeError;
    cb = pAny->length;
    if (NULL == (pb = (PBYTE)ICM_Alloc( cb)))
        goto AllocError;
    memcpy( pb, pAny->value, cb);
    blob.cbData = cb;
    blob.pbData = pb;
    pnBlob->SetData( &blob);
    pBlobList->InsertTail( pnBlob);

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    ICM_Free( pb);
    goto CommonReturn;
SET_ERROR(NewCBlobNodeError,E_OUTOFMEMORY)
TRACE_ERROR(AllocError)                 // error already set
}


//+-------------------------------------------------------------------------
//  Use a 0-based index to delete a blob from a list
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DelBlobByIndex(
    IN OUT CBlobList    *pBlobList,
    IN DWORD            dwIndex)
{
    BOOL                fRet;
    CBlobNode           *pnBlob = pBlobList->Nth( dwIndex);

    if (NULL == pnBlob)
        goto IndexTooLargeError;

    pBlobList->Remove( pnBlob);
    delete pnBlob;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(IndexTooLargeError,CRYPT_E_INVALID_INDEX)
}


//+-------------------------------------------------------------------------
//  Convert Any to blob and insert at the tail of a signer list
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_InsertTailSigner(
    IN OUT CSignerList  *pSignerList,
    IN Any              *pAny)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    CSignerNode             *pnSigner = NULL;
    PBYTE                   pb = NULL;
    DWORD                   cb;
    SIGNER_DATA_INFO        sdi;    ZEROSTRUCT(sdi);

    if (NULL == (pnSigner = new CSignerNode))
        goto NewCSignerNodeError;
    cb = pAny->length;
    if (NULL == (pb = (PBYTE)ICM_Alloc( cb)))
        goto AllocError;
    memcpy( pb, pAny->value, cb);
    sdi.blob.cbData = cb;
    sdi.blob.pbData = pb;
    pnSigner->SetData( &sdi);
    pSignerList->InsertTail( pnSigner);

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free( pb);
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(NewCSignerNodeError,E_OUTOFMEMORY)
TRACE_ERROR(AllocError)                 // error already set
}


//+-------------------------------------------------------------------------
//  Convert a signed message to list form
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetListSignedData(
    IN OUT PCRYPT_MSG_INFO pcmi,
    IN SignedDataWithBlobs *psdb)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    Any                 *pAny;
    DWORD               cb;
    DWORD               i;
    PSIGNED_DATA_INFO   psdi = NULL;

    if (NULL == (psdi = (PSIGNED_DATA_INFO)ICM_AllocZero(
                            sizeof(SIGNED_DATA_INFO))))
        goto SdiAllocError;

    if (NULL == (psdi->pAlgidList = new CBlobList))
        goto NewAlgidListError;
    if (NULL == (psdi->pCertificateList = new CBlobList))
        goto NewCertificateListError;
    if (NULL == (psdi->pCrlList = new CBlobList))
        goto NewCrlListError;
    if (NULL == (psdi->pSignerList = new CSignerList))
        goto NewSignerListError;

    // version
    psdi->version = psdb->version;

    // digestAlgorithms
    for (i=psdb->digestAlgorithms.count, pAny=psdb->digestAlgorithms.value;
            i>0;
            i--, pAny++) {
        if (!ICM_InsertTailBlob( psdi->pAlgidList, pAny))
            goto DigestAlgorithmInsertTailBlobError;
    }

    // contentInfo
    cb = 0;
    ICM_GetOssContentInfoData(
            (ContentInfo *)&psdb->contentInfo,  // same, except for NOCOPY
            NULL,
            &cb);
    if (cb == 0)
        goto GetContentInfoDataSizeError;
    if (NULL == (psdi->pci = (PCONTENT_INFO)ICM_Alloc(cb)))
        goto AllocContentInfoError;
    if (!ICM_GetOssContentInfoData(
            (ContentInfo *)&psdb->contentInfo,  // same, except for NOCOPY
            psdi->pci,
            &cb))
        goto GetContentInfoDataError;

    // certificates
    if (psdb->bit_mask & certificates_present) {
#ifdef OSS_CRYPT_ASN1
        for (i=psdb->certificates.count, pAny=psdb->certificates.certificates;
#else
        for (i=psdb->certificates.count, pAny=psdb->certificates.value;
#endif  // OSS_CRYPT_ASN1
                i>0;
                i--, pAny++) {
            if (!ICM_InsertTailBlob( psdi->pCertificateList, pAny))
                goto CertInsertTailBlobError;
        }
    }

    // crls
    if (psdb->bit_mask & crls_present) {
#ifdef OSS_CRYPT_ASN1
        for (i=psdb->crls.count, pAny=psdb->crls.crls;
#else
        for (i=psdb->crls.count, pAny=psdb->crls.value;
#endif  // OSS_CRYPT_ASN1
                i>0;
                i--, pAny++) {
            if (!ICM_InsertTailBlob( psdi->pCrlList, pAny))
                goto CrlInsertTailBlobError;
        }
    }

    // signerInfos
    for (i=psdb->signerInfos.count, pAny=psdb->signerInfos.value;
            i>0;
            i--, pAny++) {
        if (!ICM_InsertTailSigner( psdi->pSignerList, pAny))
            goto SignerInfoInsertTailBlobError;
    }

    fRet = TRUE;
CommonReturn:
    pcmi->psdi = psdi;
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();

    if(NULL != psdi->pSignerList)
        delete psdi->pSignerList;

    if(NULL != psdi->pCrlList)
        delete psdi->pCrlList;

    if(NULL != psdi->pCertificateList)
        delete psdi->pCertificateList;

    if(NULL != psdi->pAlgidList)
        delete psdi->pAlgidList;

    ICM_Free( psdi);
    psdi = NULL;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(DigestAlgorithmInsertTailBlobError)     // error already set
TRACE_ERROR(GetContentInfoDataSizeError)            // error already set
TRACE_ERROR(AllocContentInfoError)                  // error already set
TRACE_ERROR(GetContentInfoDataError)                // error already set
TRACE_ERROR(CertInsertTailBlobError)                // error already set
TRACE_ERROR(CrlInsertTailBlobError)                 // error already set
TRACE_ERROR(SignerInfoInsertTailBlobError)          // error already set
SET_ERROR(NewSignerListError,E_OUTOFMEMORY)
SET_ERROR(NewCrlListError,E_OUTOFMEMORY)
SET_ERROR(NewCertificateListError,E_OUTOFMEMORY)
SET_ERROR(NewAlgidListError,E_OUTOFMEMORY)
SET_ERROR(SdiAllocError,E_OUTOFMEMORY)
}


//+-------------------------------------------------------------------------
//  Get the CAPI algid from an encoded AlgidBlob
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetCapiFromAlgidBlob(
    IN PCRYPT_DATA_BLOB pAlgidBlob,
    OUT PDWORD          pdwAlgidCapi)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    AlgorithmIdentifier *poai = NULL;

    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&poai,
            AlgorithmIdentifier_PDU,
            pAlgidBlob->pbData,
            pAlgidBlob->cbData)))
        goto Asn1DecodeAlgorithmIdentifierError;
    if (!(ICM_GetOssCAPI( CRYPT_HASH_ALG_OID_GROUP_ID, poai, pdwAlgidCapi) ||
            ICM_GetOssCAPI( CRYPT_SIGN_ALG_OID_GROUP_ID, poai, pdwAlgidCapi)))
        goto GetCAPIError;

    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeInfo(pDec, AlgorithmIdentifier_PDU, poai);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    *pdwAlgidCapi = 0;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeAlgorithmIdentifierError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(GetCAPIError,CRYPT_E_UNKNOWN_ALGO)
}


//+-------------------------------------------------------------------------
//  Create a hash list from a list of hash algid's
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_CreateHashList(
    IN HCRYPTPROV       hCryptProv,
    IN OUT CHashList    **ppHashList,
    IN CBlobList        *pAlgidList)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
    CHashList       *pHashList;
    CBlobNode       *pBlobNode;
    CHashNode       *pHashNode;
    ICM_HASH_INFO   HashInfo;       ZEROSTRUCT(HashInfo);

    if (NULL == (pHashList = new CHashList))
        goto NewHashListError;
    if (hCryptProv) {
        for (pBlobNode=pAlgidList->Head();
                pBlobNode;
                pBlobNode=pBlobNode->Next()) {
            if (!ICM_GetCapiFromAlgidBlob(
                    pBlobNode->Data(),
                    &HashInfo.dwAlgoCAPI))
                goto GetCAPIError;
#ifndef CMS_PKCS7
            HashInfo.hCryptProv = hCryptProv;
#endif  // CMS_PKCS7
            if (!CryptCreateHash(
                            hCryptProv,
                            HashInfo.dwAlgoCAPI,
                            NULL,               // hKey - optional for MAC
                            0,                  // dwFlags
                            &HashInfo.hHash))
                goto CreateHashError;
            if (NULL == (pHashNode = new CHashNode))
                goto NewHashNodeError;
            pHashNode->SetData( &HashInfo);
            pHashList->InsertTail( pHashNode);
        }
    }

    fRet = TRUE;
CommonReturn:
    *ppHashList = pHashList;
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    pHashList = NULL;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(NewHashListError,E_OUTOFMEMORY)
SET_ERROR(NewHashNodeError,E_OUTOFMEMORY)
TRACE_ERROR(GetCAPIError)                           // error already set
TRACE_ERROR(CreateHashError)                        // error already set
}


//+-------------------------------------------------------------------------
//  Update for decoding a signed message
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateDecodingSignedData(
    IN OUT PCRYPT_MSG_INFO pcmi,
    IN const BYTE *pbData,
    IN DWORD cbData)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    SignedDataWithBlobs *psdb = NULL;
    PBYTE               pb = NULL;
    DWORD               cb;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    PBYTE               pbDER = NULL;
    DWORD               cbDER;
    ICM_HASH_INFO       HashInfo;       ZEROSTRUCT(HashInfo);

    DWORD dwExceptionCode;

  // Handle MappedFile Exceptions
  __try {

    if (PHASE_FIRST_FINAL == pcmi->dwPhase) {
        if (0 != (Asn1Err = PkiAsn1Decode(
                pDec,
                (void **)&psdb,
                SignedDataWithBlobs_PDU,
                pbData,
                cbData)))
            goto Asn1DecodeSignedDataError;
        if (!ICM_GetListSignedData( pcmi, psdb))
            goto GetListSignedDataError;
        if (!ICM_CreateHashList(
                pcmi->hCryptProv,
                &pcmi->pHashList,
                pcmi->psdi->pAlgidList))
            goto CreateHashListError;
        if (pcmi->psdi->pci->content.cbData) {
            // Get the address & count of the contents octets of the DER
            // encoding of the content. Since the content might be
            // indefinite-length encoded, decode and re-encode as DER.
            pb = pcmi->psdi->pci->content.pbData;
            cb = pcmi->psdi->pci->content.cbData;

            if (0 == strcmp(pszObjIdDataType,
                        pcmi->psdi->pci->pszContentType)
#ifdef CMS_PKCS7
                    ||  pcmi->psdi->version >= CMSG_SIGNED_DATA_CMS_VERSION 
#endif  // CMS_PKCS7
                    ) {
                if (!ICM_ReEncodeAsOctetDER(
                        pb,
                        cb,
                        &pbDER,
                        &cbDER
                        ))
                    goto ReEncodeAsOctetDERError;
                if (pbDER) {
                    pb = pbDER;
                    cb = cbDER;
                }
            }
            if (0 > Asn1UtilExtractContent( pb, cb, &cb, (const BYTE **)&pb))
                goto ExtractContentError;
        } else {
            cb = 0;
        }
    } else {
        assert (pcmi->dwFlags & CMSG_DETACHED_FLAG);
        if (!(pcmi->dwFlags & CMSG_DETACHED_FLAG))
            goto NonFinalNotDetachedError;
        pb = (PBYTE)pbData;
        cb = cbData;
    }

    if (!ICM_UpdateListDigest( pcmi->pHashList, pb, cb))
        goto UpdateDigestError;

    fRet = TRUE;

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwExceptionCode = GetExceptionCode();
    goto ExceptionError;
  }

CommonReturn:
    PkiAsn1FreeEncoded(ICM_GetEncoder(), pbDER);
    PkiAsn1FreeInfo(pDec, SignedDataWithBlobs_PDU, psdb);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeSignedDataError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
SET_ERROR(NonFinalNotDetachedError,CRYPT_E_MSG_ERROR)
TRACE_ERROR(GetListSignedDataError)                 // error already set
TRACE_ERROR(CreateHashListError)                    // error already set
TRACE_ERROR(ReEncodeAsOctetDERError)                // error already set
TRACE_ERROR(UpdateDigestError)                      // error already set
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}

#ifdef CMS_PKCS7

//+-------------------------------------------------------------------------
//  Update for decoding an enveloped message
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateDecodingEnvelopedData(
    IN PCRYPT_MSG_INFO pcmi,
    IN const BYTE *pbData,
    IN DWORD cbData)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    CmsEnvelopedData    *ped = NULL;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();

    assert (PHASE_FIRST_FINAL == pcmi->dwPhase);
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **) &ped,
            CmsEnvelopedData_PDU,
            pbData,
            cbData)))
        goto Asn1DecodeError;
    pcmi->pvMsg = ped;

    if (NULL == (pcmi->pCertificateList = new CBlobList))
        goto NewCertificateListError;
    if (NULL == (pcmi->pCrlList = new CBlobList))
        goto NewCrlListError;

    if (ped->bit_mask & originatorInfo_present) {
        OriginatorInfo *poi = &ped->originatorInfo;
        DWORD i;
        Any *pAny;

        // certificates
        if (poi->bit_mask & certificates_present) {
#ifdef OSS_CRYPT_ASN1
            for (i=poi->certificates.count, pAny=poi->certificates.certificates;
#else
            for (i=poi->certificates.count, pAny=poi->certificates.value;
#endif  // OSS_CRYPT_ASN1
                    i>0;
                    i--, pAny++) {
                if (!ICM_InsertTailBlob( pcmi->pCertificateList, pAny))
                    goto CertInsertTailBlobError;
            }
        }

        // crls
        if (poi->bit_mask & crls_present) {
#ifdef OSS_CRYPT_ASN1
            for (i=poi->crls.count, pAny=poi->crls.crls;
#else
            for (i=poi->crls.count, pAny=poi->crls.value;
#endif  // OSS_CRYPT_ASN1
                    i>0;
                    i--, pAny++) {
                if (!ICM_InsertTailBlob( pcmi->pCrlList, pAny))
                    goto CrlInsertTailBlobError;
            }
        }
    }

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;

    if (NULL != pcmi->pCertificateList) {
        delete pcmi->pCertificateList;
        pcmi->pCertificateList = NULL;
    }

    if (NULL != pcmi->pCrlList) {
        delete pcmi->pCrlList;
        pcmi->pCrlList = NULL;
    }

    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(NewCertificateListError,E_OUTOFMEMORY)
SET_ERROR(NewCrlListError,E_OUTOFMEMORY)
TRACE_ERROR(CertInsertTailBlobError)
TRACE_ERROR(CrlInsertTailBlobError)
}

#else

//+-------------------------------------------------------------------------
//  Update for decoding an enveloped message
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateDecodingEnvelopedData(
    IN PCRYPT_MSG_INFO pcmi,
    IN const BYTE *pbData,
    IN DWORD cbData)
{
    BOOL                fRet;
    EnvelopedData       *ped = NULL;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();

    assert (PHASE_FIRST_FINAL == pcmi->dwPhase);
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&ped,
            EnvelopedData_PDU,
            pbData,
            cbData)))
        goto Asn1DecodeError;
    pcmi->pvMsg = ped;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeError, PkiAsn1ErrToHr(Asn1Err))
}

#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Find the HashNode corresponding to a CAPI Algid
//
// NB- Does not fail.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FindHashNodeFromCapiAlgid(
    IN CHashList    *pHashList,
    IN DWORD        dwAlgoCAPI,
    OUT CHashNode   **ppnHash)
{
    CHashNode   *pnHash;

    for (pnHash=pHashList->Head(); pnHash; pnHash=pnHash->Next()) {
        if (dwAlgoCAPI == pnHash->Data()->dwAlgoCAPI)
            break;
    }

    *ppnHash = pnHash;

    if(pnHash == NULL) {
        SetLastError((DWORD) CRYPT_E_UNKNOWN_ALGO);
        return FALSE;
    }
    
    return TRUE;
}


//+-------------------------------------------------------------------------
//  Find the HashNode corresponding to an encoded Algid
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FindHashNodeFromEncodedAlgo(
    IN CHashList            *pHashList,
    IN PCRYPT_DATA_BLOB     pblobEncodedAlgorithm,
    OUT CHashNode           **ppnHash)
{
    BOOL        fRet;
    DWORD       dwAlgoCAPI;

    if (!ICM_GetCapiFromAlgidBlob(
            pblobEncodedAlgorithm,
            &dwAlgoCAPI))
        goto GetCAPIError;
    fRet = ICM_FindHashNodeFromCapiAlgid( pHashList, dwAlgoCAPI, ppnHash);

CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    *ppnHash = NULL;
    goto CommonReturn;
TRACE_ERROR(GetCAPIError)       // error already set
}


//+-------------------------------------------------------------------------
//  Update for decoding a digested message
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateDecodingDigestedData(
    IN PCRYPT_MSG_INFO pcmi,
    IN const BYTE *pbData,
    IN DWORD cbData)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    DigestedData        *pdd = NULL;
    PBYTE               pb = NULL;
    DWORD               cb;
    PBYTE               pbDER = NULL;
    DWORD               cbDER;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    ICM_HASH_INFO       HashInfo;       ZEROSTRUCT(HashInfo);
    CHashNode           *pHashNode;

    if (PHASE_FIRST_FINAL == pcmi->dwPhase) {
        if (0 != (Asn1Err = PkiAsn1Decode(
                pDec,
                (void **)&pdd,
                DigestedData_PDU,
                pbData,
                cbData)))
            goto Asn1DecodeError;
        pcmi->pvMsg = pdd;
        if (!ICM_GetOssCAPI(
                CRYPT_HASH_ALG_OID_GROUP_ID,
                &pdd->digestAlgorithm,
                &HashInfo.dwAlgoCAPI))
            goto GetCAPIError;
#ifndef CMS_PKCS7
        HashInfo.hCryptProv = pcmi->hCryptProv;
#endif  // CMS_PKCS7
        if (!CryptCreateHash(
                        pcmi->hCryptProv,
                        HashInfo.dwAlgoCAPI,
                        NULL,               // hKey - optional for MAC
                        0,                  // dwFlags
                        &HashInfo.hHash))
            goto CreateHashError;
        if (NULL == (pcmi->pHashList = new CHashList))
            goto NewHashListError;
        if (NULL == (pHashNode = new CHashNode))
            goto NewHashNodeError;
        pHashNode->SetData( &HashInfo);
        pcmi->pHashList->InsertTail( pHashNode);
        if (pdd->contentInfo.bit_mask & content_present) {
            // Get the address & count of the contents octets of the DER
            // encoding of the content. Since the content might be
            // indefinite-length encoded, decode and re-encode as DER.
            pb = (PBYTE)pdd->contentInfo.content.value;
            cb = (DWORD)pdd->contentInfo.content.length;

            if (ICM_EqualObjectIDs(
                        &pdd->contentInfo.contentType,
                        &aoidMessages[ CMSG_DATA - 1])
#ifdef CMS_PKCS7
                    || pdd->version >= CMSG_HASHED_DATA_V2 
#endif  // CMS_PKCS7
                    ) {
                if (!ICM_ReEncodeAsOctetDER(
                        pb,
                        cb,
                        &pbDER,
                        &cbDER
                        ))
                    goto ReEncodeAsOctetDERError;
                if (pbDER) {
                    pb = pbDER;
                    cb = cbDER;
                }
            }
            if (0 > Asn1UtilExtractContent( pb, cb, &cb, (const BYTE **)&pb))
                goto ExtractContentError;
        } else {
            cb = 0;
        }
    } else {
        assert (pcmi->dwFlags & CMSG_DETACHED_FLAG);
        if (!(pcmi->dwFlags & CMSG_DETACHED_FLAG))
            goto NonFinalNotDetachedError;
        pb = (PBYTE)pbData;
        cb = cbData;
    }
    if (!ICM_UpdateListDigest( pcmi->pHashList, pb, cb))
        goto UpdateDigestError;

    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeEncoded(ICM_GetEncoder(), pbDER);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    PkiAsn1FreeInfo(pDec, DigestedData_PDU, pdd);
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(GetCAPIError,CRYPT_E_UNKNOWN_ALGO)
SET_ERROR(NewHashListError,E_OUTOFMEMORY)
SET_ERROR(NewHashNodeError,E_OUTOFMEMORY)
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
SET_ERROR(NonFinalNotDetachedError,CRYPT_E_MSG_ERROR)
TRACE_ERROR(CreateHashError)                // error already set
TRACE_ERROR(UpdateDigestError)              // error already set
TRACE_ERROR(ReEncodeAsOctetDERError)        // error already set
}


//+-------------------------------------------------------------------------
//  Update for decoding a data message
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_UpdateDecodingData(
    IN PCRYPT_MSG_INFO  pcmi,
    IN const BYTE       *pbData,
    IN DWORD            cbData)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    OctetStringType     *poos = NULL;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();

    if (PHASE_FIRST_FINAL != pcmi->dwPhase)
        goto NonFirstFinalError;

    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&poos,
            OctetStringType_PDU,
            pbData,
            cbData)))
        goto Asn1DecodeError;
    pcmi->pvMsg = poos;

    fRet = TRUE;
CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    PkiAsn1FreeInfo(pDec, OctetStringType_PDU, poos);
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(NonFirstFinalError,CRYPT_E_MSG_ERROR)
}


//+-------------------------------------------------------------------------
//  Write a buffer to a file
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_WriteBufToFile(
    LPCSTR      pszFileName,
    PBYTE       pbData,
    DWORD       cbData)
{
    BOOL        fRet;
    HANDLE      hFile;
    DWORD       cbWritten;

    if( INVALID_HANDLE_VALUE == (hFile = CreateFile( pszFileName, GENERIC_WRITE,
            0, NULL, CREATE_ALWAYS, 0, NULL))) {
        goto CreateFileError;
    }

    if (!WriteFile( hFile, pbData, cbData, &cbWritten, NULL) ||
            (cbWritten != cbData)) {
        goto WriteFileError;
    }

    CloseHandle( hFile);
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(CreateFileError)
TRACE_ERROR(WriteFileError)
}


//+-------------------------------------------------------------------------
//  Update the content of a cryptographic message. Depending on how the
//  message was opened, the content is either encoded or decoded.
//
//  This function is repetitively called to append to the message content.
//  fFinal is set to identify the last update. On fFinal, the encode/decode
//  is completed. The encoded/decoded content and the decoded parameters
//  are valid until the open and all duplicated handles are closed.
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgUpdate(
#else
CryptMsgUpdate(
#endif
    IN HCRYPTMSG    hCryptMsg,
    IN const BYTE   *pbData,
    IN DWORD        cbData,
    IN BOOL         fFinal)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    PCRYPT_MSG_INFO     pcmi = (PCRYPT_MSG_INFO)hCryptMsg;
    ContentInfo         *pci = NULL;
    ASN1error_e         Asn1Err;
    PCMSG_STREAM_INFO   pcsi = pcmi->pStreamInfo;

    DWORD dwExceptionCode;

    ICM_Lock( pcmi);        // Single thread access to HCRYPTMSG

  // Handle MappedFile Exceptions
  __try {

    if (!ICM_AdvanceMsgPhase( &pcmi->dwPhase, fFinal))
        goto AdvancePhaseError;

    if (pcmi->fEncoding) {
        if (!(((pcmi->dwFlags & CMSG_DETACHED_FLAG) &&
                    (PHASE_FIRST_ONGOING == pcmi->dwPhase)) ||
                (pcsi && (pcmi->dwPhase < PHASE_SECOND_ONGOING)) ||
                (PHASE_FIRST_FINAL == pcmi->dwPhase)))
            goto EncodingPhaseError;

        switch (pcmi->dwMsgType) {
        case CMSG_DATA:
            fRet = ICM_UpdateEncodingData(
                                pcmi,
                                pbData,
                                cbData,
                                fFinal);
            break;
        case CMSG_SIGNED:
            fRet = ICM_UpdateEncodingSignedData(
                                pcmi,
                                pbData,
                                cbData,
                                fFinal);
            break;
        case CMSG_ENVELOPED:
            fRet = ICM_UpdateEncodingEnvelopedData(
                                pcmi,
                                pbData,
                                cbData,
                                fFinal);
            break;
        case CMSG_HASHED:
            fRet = ICM_UpdateEncodingDigestedData(
                                pcmi,
                                pbData,
                                cbData,
                                fFinal);
            break;
        case CMSG_SIGNED_AND_ENVELOPED:
#if 0
            fRet = ICM_UpdateEncodingSignedAndEnvelopedData(
                                pcmi,
                                pbData,
                                cbData,
                                fFinal);
            break;
#endif
        case CMSG_ENCRYPTED:
            goto MessageTypeNotSupportedYet;
        default:
            goto InvalidMsgType;
        }
    } else {
        // decode
        ASN1decoding_t  pDec = ICM_GetDecoder();
        LONG            lth;
        PBYTE           pb;
        DWORD           cb;

        if (pcsi) {
            if (pcmi->dwPhase < PHASE_SECOND_ONGOING) {
                fRet = ICMS_UpdateDecoding( pcmi, pbData, cbData, fFinal);
                if (fRet)
                    goto CommonReturn;
                else
                    goto ErrorReturn;
            }
            // else
            //  streaming detached
        }

        if (PHASE_FIRST_ONGOING == pcmi->dwPhase)
            goto FirstOngoingDecodeError;

        if ((0 == (pcmi->dwFlags & CMSG_DETACHED_FLAG)) &&
                (PHASE_FIRST_FINAL != pcmi->dwPhase))
            goto SecondOngoingNonDetachedError;

        if ((PHASE_FIRST_FINAL == pcmi->dwPhase) &&
                (0 == pcmi->dwMsgType)) {
            if (0 != (Asn1Err = PkiAsn1Decode(
                    pDec,
                    (void **)&pci,
                    ContentInfoNC_PDU,
                    pbData,
                    cbData)))
                goto Asn1DecodeContentInfoError;
            if (0 == (lth = ICM_ObjIdToIndex( &pci->contentType)))
                goto InvalidMsgType;
            pcmi->dwMsgType = (DWORD)lth;
            pb = (PBYTE)pci->content.value;
            cb = pci->content.length;
        } else {
            pb = (PBYTE)pbData;
            cb = cbData;
        }
        switch (pcmi->dwMsgType) {
        case CMSG_DATA:
            fRet = ICM_UpdateDecodingData( pcmi, pb, cb);
            break;
        case CMSG_SIGNED:
            fRet = ICM_UpdateDecodingSignedData( pcmi, pb, cb);
            break;
        case CMSG_ENVELOPED:
            fRet = ICM_UpdateDecodingEnvelopedData( pcmi, pb, cb);
            break;
        case CMSG_HASHED:
            fRet = ICM_UpdateDecodingDigestedData( pcmi, pb, cb);
            break;
        case CMSG_SIGNED_AND_ENVELOPED:
        case CMSG_ENCRYPTED:
            goto MessageTypeNotSupportedYet;
        default:
            goto InvalidMsgType;
        }
    }

    if (!fRet)
        goto ErrorReturn;

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwExceptionCode = GetExceptionCode();
    goto ExceptionError;
  }

CommonReturn:
    if (pci)
        PkiAsn1FreeInfo(ICM_GetDecoder(), ContentInfoNC_PDU, pci);

    ICM_Unlock( pcmi);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(EncodingPhaseError,CRYPT_E_MSG_ERROR)
SET_ERROR(FirstOngoingDecodeError,CRYPT_E_MSG_ERROR)
SET_ERROR(SecondOngoingNonDetachedError,CRYPT_E_MSG_ERROR)
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR_VAR(Asn1DecodeContentInfoError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(AdvancePhaseError)              // error already set
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}


BOOL
WINAPI
ICM_VerifySignature(
    IN HCRYPTHASH       hHash,
    IN HCRYPTKEY        hPubKey,
    IN DWORD            dwPubKeyAlgId,
    IN DWORD            dwPubKeyFlags,
    IN PBYTE            pbEncryptedDigest,
    IN DWORD            cbEncryptedDigest)
{
    BOOL fRet;
    BYTE rgbDssSignature[CERT_DSS_SIGNATURE_LEN];
    PBYTE pb = NULL;

    if (CALG_NO_SIGN == dwPubKeyAlgId) {
        DWORD cbData;

        // The encrypted digest isn't signed. It should be the same as
        // the calculated hash

        if (!CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                NULL,
                &cbData,
                0))                     // dwFlags
            goto GetHashParamSizeError;
        if (NULL == (pb = (PBYTE)ICM_AllocA( cbData)))
            goto AllocHashParamError;
        if (!CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                pb,
                &cbData,
                0))                     // dwFlags
            goto GetHashParamError;

        // Compare the calculated hash with the "encrypted digest"
        if (cbData != cbEncryptedDigest ||
                0 != memcmp(pb, pbEncryptedDigest, cbData))
            goto NoSignHashCompareError;

        fRet = TRUE;
        goto CommonReturn;
    }

    if (CALG_DSS_SIGN == dwPubKeyAlgId &&
            0 == (dwPubKeyFlags & CRYPT_OID_INHIBIT_SIGNATURE_FORMAT_FLAG)) {
        DWORD cbData;

        // Convert from ASN.1 sequence of two integers to the CSP signature
        // format.
        cbData = sizeof(rgbDssSignature);
        if (!CryptDecodeObject(
                X509_ASN_ENCODING,
                X509_DSS_SIGNATURE,
                pbEncryptedDigest,
                cbEncryptedDigest,
                0,                                  // dwFlags
                rgbDssSignature,
                &cbData
                ))
            goto DecodeError;
        pbEncryptedDigest = rgbDssSignature;
        assert(cbData == sizeof(rgbDssSignature));
        cbEncryptedDigest = sizeof(rgbDssSignature);
    } else {
        if (NULL == (pb = (PBYTE)ICM_AllocA( cbEncryptedDigest)))
            goto AllocError;
        ICM_ReverseCopy( pb, pbEncryptedDigest, cbEncryptedDigest);
        pbEncryptedDigest = pb;
    }

    fRet = CryptVerifySignature(
                hHash,
                pbEncryptedDigest,
                cbEncryptedDigest,
                hPubKey,
                NULL,           // pwszDescription
                0);             // dwFlags
CommonReturn:
    ICM_FreeA(pb);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetHashParamSizeError)
TRACE_ERROR(AllocHashParamError)
TRACE_ERROR(GetHashParamError)
SET_ERROR(NoSignHashCompareError, NTE_BAD_SIGNATURE)
TRACE_ERROR(DecodeError)
TRACE_ERROR(AllocError)
}


//+-------------------------------------------------------------------------
//  Verify a signature using the authenticated attributes blob
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_VerifySignatureAuthAttrBlob(
    IN PCRYPT_MSG_INFO  pcmi,
    IN CSignerNode      *pSignerNode,
    IN HCRYPTPROV       hCryptProv,
    IN HCRYPTKEY        hPubKey,
    IN DWORD            dwDigestAlgorithm,
    IN DWORD            dwPubKeyAlgorithm,
    IN DWORD            dwPubKeyFlags,
    IN PBYTE            pbEncryptedDigest,
    IN DWORD            cbEncryptedDigest)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    SignerInfoWithAABlob    *psiaab = NULL;
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    CRYPT_DATA_BLOB         DataBlob;
    HCRYPTHASH              hHashAttrBlob = NULL;
    PBYTE                   pb = NULL;
    DWORD                   cb;

    DataBlob = pSignerNode->Data()->blob;
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&psiaab,
            SignerInfoWithAABlob_PDU,
            DataBlob.pbData,
            DataBlob.cbData)))
        goto Asn1DecodeSignerInfoWithAABlobError;

    cb = psiaab->authenticatedAttributes.length;
    if (NULL == (pb = (PBYTE)ICM_AllocA(cb)))
        goto AuthenticatedAttributesAllocError;
    memcpy( pb, psiaab->authenticatedAttributes.value, cb);
    // The encoded blob should contain 0xa0 ([0] IMPLICIT) as the tag,
    // but the tag needs to be 0x31 (SET OF) for the hash computation.
    if (*pb != (ICM_TAG_CONTEXT_0 | ICM_TAG_CONSTRUCTED))   // [0] IMPLICIT
        goto AuthAttrsTagError;
    *pb = ICM_TAG_SET;          // SET OF

    if (!ICM_GetBlobHash(
            hCryptProv,
            dwDigestAlgorithm,
            pb,
            cb,
            &hHashAttrBlob))
        goto HashAttrBlobError;

    if (!ICM_VerifySignature(
            hHashAttrBlob,
            hPubKey,
            dwPubKeyAlgorithm,
            dwPubKeyFlags,
            pbEncryptedDigest,
            cbEncryptedDigest))
        goto VerifySignatureError;
    fRet = TRUE;

CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfoWithAABlob_PDU, psiaab);
    if (hHashAttrBlob)
        CryptDestroyHash( hHashAttrBlob);
    ICM_FreeA(pb);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeSignerInfoWithAABlobError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(AuthAttrsTagError,CRYPT_E_BAD_ENCODE)
TRACE_ERROR(AuthenticatedAttributesAllocError)      // error already set
TRACE_ERROR(HashAttrBlobError)                      // error already set
TRACE_ERROR(VerifySignatureError)                   // error already set
}


#ifdef CMS_PKCS7

BOOL
WINAPI
ICM_GetVerifySignatureStuff(
    IN DWORD            dwSignerType,
    void                *pvSigner,
    IN OUT HCRYPTPROV   *phCryptProv,
    OUT HCRYPTKEY       *phPubKey,
    OUT DWORD           *pdwPubKeyAlgId,
    OUT DWORD           *pdwPubKeyFlags)
{
    BOOL                    fRet;
    PCCRYPT_OID_INFO        pOIDInfo;
    HCRYPTPROV              hCryptProv;

    PCERT_PUBLIC_KEY_INFO   pPubKeyInfo = NULL;    // not allocated
    CERT_PUBLIC_KEY_INFO    PubKeyInfo;
    BYTE                    *pbAllocPubKeyPara = NULL;

    *pdwPubKeyAlgId = 0;
    *pdwPubKeyFlags = 0;

    switch (dwSignerType) {
        case CMSG_VERIFY_SIGNER_PUBKEY:
            pPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) pvSigner;
            break;
        case CMSG_VERIFY_SIGNER_CHAIN:
            {
                PCCERT_CHAIN_CONTEXT pChain = (PCCERT_CHAIN_CONTEXT) pvSigner;

                // All chains have at least the leaf certificate context
                assert(pChain->cChain && pChain->rgpChain[0]->cElement);
                pvSigner =
                    (void *) pChain->rgpChain[0]->rgpElement[0]->pCertContext;
                dwSignerType = CMSG_VERIFY_SIGNER_CERT;
            }
            // fall through
        case CMSG_VERIFY_SIGNER_CERT:
            {
                PCCERT_CONTEXT pSigner = (PCCERT_CONTEXT) pvSigner;
                PCRYPT_OBJID_BLOB pPara;

                pPubKeyInfo = &pSigner->pCertInfo->SubjectPublicKeyInfo;
                pPara = &pPubKeyInfo->Algorithm.Parameters;

                // Check if the public key parameters were omitted
                // from the encoded certificate. If omitted, try
                // to use the certificate's CERT_PUBKEY_ALG_PARA_PROP_ID
                // property.
                if (0 == pPara->cbData ||
                        ICM_TAG_NULL_OCTETS == *pPara->pbData) {
                    DWORD cbData;

                    if (CertGetCertificateContextProperty(
                            pSigner,
                            CERT_PUBKEY_ALG_PARA_PROP_ID,
                            NULL,                       // pvData
                            &cbData) && 0 < cbData
                                    &&
                        (pbAllocPubKeyPara = (BYTE *) ICM_Alloc(
                            cbData))
                                    &&
                        CertGetCertificateContextProperty(
                            pSigner,
                            CERT_PUBKEY_ALG_PARA_PROP_ID,
                            pbAllocPubKeyPara,
                            &cbData)) {

                        PubKeyInfo = *pPubKeyInfo;
                        PubKeyInfo.Algorithm.Parameters.pbData =
                            pbAllocPubKeyPara;
                        PubKeyInfo.Algorithm.Parameters.cbData = cbData;
                        pPubKeyInfo = &PubKeyInfo;
                    }
                }
            }
            break;
        case CMSG_VERIFY_SIGNER_NULL:
            break;
        default:
            goto InvalidSignerType;
    }

    if (CMSG_VERIFY_SIGNER_NULL == dwSignerType)
        ;
    else if (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            pPubKeyInfo->Algorithm.pszObjId,
            CRYPT_PUBKEY_ALG_OID_GROUP_ID
            )) {
        DWORD cExtra = pOIDInfo->ExtraInfo.cbData / sizeof(DWORD);
        DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;

        *pdwPubKeyAlgId = pOIDInfo->Algid;
        if (1 <= cExtra)
            *pdwPubKeyFlags = pdwExtra[0];
    }

    hCryptProv = *phCryptProv;
    if (0 == hCryptProv) {
        hCryptProv = I_CryptGetDefaultCryptProv(*pdwPubKeyAlgId);
        if (0 == hCryptProv)
            goto GetDefaultCryptProvError;
        *phCryptProv = hCryptProv;
    }

    if (CMSG_VERIFY_SIGNER_NULL == dwSignerType) {
        // The signature is simply the hash octets
        *pdwPubKeyAlgId = CALG_NO_SIGN;
        *phPubKey = NULL;

        // import the signer's public key
    } else if (!CryptImportPublicKeyInfo(
            hCryptProv,
            X509_ASN_ENCODING,
            pPubKeyInfo,
            phPubKey))
        goto ImportKeyFailed;
    fRet = TRUE;
CommonReturn:
    ICM_Free(pbAllocPubKeyPara);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    *phPubKey = 0;
    goto CommonReturn;
SET_ERROR(InvalidSignerType, E_INVALIDARG)
TRACE_ERROR(GetDefaultCryptProvError)           // error already set
TRACE_ERROR(ImportKeyFailed)                    // error already set
}

BOOL
WINAPI
ICM_FindSignerInfo(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwIndex,
    OUT PVOID           *ppv);


//+-------------------------------------------------------------------------
//  Verify a signature
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlVerifySignatureEx(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwFlags,
    IN PCMSG_CTRL_VERIFY_SIGNATURE_EX_PARA pPara
    )
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    SignerInfoWithBlobs     *psib = NULL;
    CSignerNode             *pSignerNode = NULL;
    HCRYPTHASH              hHashAttr = NULL;
    HCRYPTHASH              hHashDup = NULL;
    HCRYPTHASH              hHash = NULL;
    HCRYPTKEY               hPubKey = NULL;
    HCRYPTPROV              hCryptProv;         // doen't need to be released
    DWORD                   dwPubKeyAlgId;
    DWORD                   dwPubKeyFlags;
    PBYTE                   pbHash;
    ULONG                   cb;
    Any                     anyValue;
    DWORD                   cbMessageDigest;
    PBYTE                   pbMessageDigest;
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    CRYPT_DATA_BLOB         DataBlob;
    CHashNode               *pnHash;
    PICM_HASH_INFO          pHashInfo;

    if (!ICM_FindSignerInfo(pcmi, pPara->dwSignerIndex, (PVOID *)&pSignerNode))
        goto FindSignerInfoError;

    DataBlob = pSignerNode->Data()->blob;
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&psib,
            SignerInfoWithBlobs_PDU,
            DataBlob.pbData,
            DataBlob.cbData)))
        goto DecodeSignerInfoWithBlobsError;

    if (!ICM_FindHashNodeFromEncodedAlgo(
            pcmi->pHashList,
            (PCRYPT_DATA_BLOB)&psib->digestAlgorithm,
            &pnHash))
        goto GetHashNodeFromEncodedAlgoError;
    pHashInfo = pnHash->Data();

    if (pPara->hCryptProv)
        hCryptProv = pPara->hCryptProv;
    else if (pcmi->fDefaultCryptProv)
        hCryptProv = 0;
    else
        hCryptProv = pcmi->hCryptProv;

    if (!ICM_GetVerifySignatureStuff(
            pPara->dwSignerType,
            pPara->pvSigner,
            &hCryptProv,
            &hPubKey,
            &dwPubKeyAlgId,
            &dwPubKeyFlags)) goto GetSignatureStuffError;

    if (psib->bit_mask & authAttributes_present) {
        // find the message digest attr value
        if (!ICM_GetAttrValue(
                (Attributes *)&psib->authAttributes,    // same, except for NOCOPY
                &oidMessageDigest,
                &anyValue))
            goto FindAttrError;
        // find the message digest octets
        if (!Asn1UtilExtractContent(
#ifdef OSS_CRYPT_ASN1
                anyValue.value,
#else
                (const BYTE *) anyValue.value,
#endif  // OSS_CRYPT_ASN1
                anyValue.length,
                &cbMessageDigest,
                (const BYTE **)&pbMessageDigest))
            goto ExtractContentError;
        // get the hash value computed on the data
        if (!ICM_GetListHashValue( pnHash, &cb, &pbHash))
            goto GetHashValueError;
        // hash sizes equal?
        if (cb != cbMessageDigest)
            goto HashCompareSizeError;
        // hash octets equal?
        if (memcmp( pbMessageDigest, pbHash, cb))
            goto HashCompareValueError;
        // Now that we have verified the message digest octets,
        // get the hash of the authenticated attributes.
        // Should check the content type attribute as well.
        if (!ICM_GetAttrsHash(
                pHashInfo->dwAlgoCAPI,
                hCryptProv,
                (Attributes *)&psib->authAttributes,    // same, except for NOCOPY
                &hHashAttr))
            goto GetAuthAttrsHashError;
        hHash = hHashAttr;
    } else {
        if (!ICM_DupListHash( pnHash, hCryptProv, &hHashDup))
            goto DupListHashError;
        hHash = hHashDup;
    }

    // verify the hash, signature, and public key are consistent
    fRet = ICM_VerifySignature(
                hHash,
                hPubKey,
                dwPubKeyAlgId,
                dwPubKeyFlags,
                psib->encryptedDigest.value,
                psib->encryptedDigest.length);

    if (!fRet && hHashAttr) {
        // The hash of the authenticated attributes failed.
        // Maybe they hashed incorrectly-DER-encoded authenticated attributes
        // and gave us that encoding. Hash and verify the actual encoding of
        // the authattrs that they gave us. There is a bug in IE3.0 which hits
        // this path, due to a bug in the then-current OSS libraries.
        fRet = ICM_VerifySignatureAuthAttrBlob(
                        pcmi,
                        pSignerNode,
                        hCryptProv,
                        hPubKey,
                        pHashInfo->dwAlgoCAPI,
                        dwPubKeyAlgId,
                        dwPubKeyFlags,
                        psib->encryptedDigest.value,
                        psib->encryptedDigest.length);
    }
    if (!fRet)
        goto VerifySignatureError;

CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, psib);

    if (hPubKey)
        CryptDestroyKey(hPubKey);
    if (hHashAttr)
        CryptDestroyHash( hHashAttr);
    if (hHashDup)
        CryptDestroyHash( hHashDup);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
//    if (hHash && (0 == (pcmi->dwFlags & CMSG_DETACHED_FLAG)))
//        CryptDestroyHash( hHash);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FindSignerInfoError)            // error already set

SET_ERROR(FindAttrError,CRYPT_E_AUTH_ATTR_MISSING)
SET_ERROR(HashCompareSizeError,CRYPT_E_HASH_VALUE)
SET_ERROR(HashCompareValueError,CRYPT_E_HASH_VALUE)
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
SET_ERROR_VAR(DecodeSignerInfoWithBlobsError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(GetHashValueError)                  // error already set
TRACE_ERROR(GetAuthAttrsHashError)              // error already set
TRACE_ERROR(GetSignatureStuffError)             // error already set
TRACE_ERROR(GetHashNodeFromEncodedAlgoError)    // error already set
TRACE_ERROR(DupListHashError)                   // error already set
TRACE_ERROR(VerifySignatureError)               // error already set
dwFlags;
}

//+-------------------------------------------------------------------------
//  Verify a signature
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlVerifySignature(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwFlags,
    IN PCERT_INFO pci)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    SignerInfoWithBlobs     *psib = NULL;
    CSignerNode             *pSignerNode = NULL;
    ULONG                   cbIssuer;
    PBYTE                   pb = NULL;
    ULONG                   cb;
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    CRYPT_DATA_BLOB         DataBlob;
    CertIdentifier          *pOssCertId = NULL;
    IssuerAndSerialNumber   *pisn;              // not allocated
    DWORD                   dwSignerIndex;
    CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA ExPara;

    ZEROSTRUCT(ExPara);
    ExPara.cbSize = sizeof(ExPara);
    // ExPara.hCryptProv = 
    // ExPara.dwSignerIndex =
    ExPara.dwSignerType = CMSG_VERIFY_SIGNER_PUBKEY;
    ExPara.pvSigner = (void *) &pci->SubjectPublicKeyInfo;

    cb = pci->SerialNumber.cbData;
    if (NULL == (pb = (PBYTE)ICM_AllocA( cb)))
        goto SerialNumberAllocError;
    cbIssuer = pci->Issuer.cbData;

    switch (pcmi->dwMsgType) {
    case CMSG_SIGNED:
        {
            for (pSignerNode=pcmi->psdi->pSignerList->Head(), dwSignerIndex = 0;
                    pSignerNode;
                    pSignerNode = pSignerNode->Next(), dwSignerIndex++) {
                PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, psib);
                psib = NULL;
                PkiAsn1FreeInfo(pDec, CertIdentifier_PDU, pOssCertId);
                pOssCertId = NULL;
                DataBlob = pSignerNode->Data()->blob;
                if (0 != (Asn1Err = PkiAsn1Decode(
                        pDec,
                        (void **)&psib,
                        SignerInfoWithBlobs_PDU,
                        DataBlob.pbData,
                        DataBlob.cbData)))
                    goto DecodeSignerInfoWithBlobsError;
                if (0 != (Asn1Err = PkiAsn1Decode(
                        pDec,
                        (void **)&pOssCertId,
                        CertIdentifier_PDU,
                        (BYTE *) psib->sid.value,
                        psib->sid.length)))
                    goto DecodeCertIdentifierError;

                switch (pOssCertId->choice) {
                    case issuerAndSerialNumber_chosen:
                        pisn = &pOssCertId->u.issuerAndSerialNumber;
                        if (pisn->issuer.length != cbIssuer)
                            break;
                        if (0 != memcmp( pci->Issuer.pbData,
                                pisn->issuer.value, cbIssuer))
                            break;
                        // We need to add an integer method to compare
                        // big-endian internal to a little-endian external
                        // value.
                        if (pisn->serialNumber.length != cb)
                            break;
                        ICM_ReverseCopy( pb, pisn->serialNumber.value, cb);
                        if (0 == memcmp( pb, pci->SerialNumber.pbData, cb))
                            goto VerifyFoundSigner;
                        break;
                    case subjectKeyIdentifier_chosen:
                        // Go for it. See if we are able to verify using
                        // the public key for this signer
                        ExPara.dwSignerIndex = dwSignerIndex;
                        fRet = ICM_ControlVerifySignatureEx(
                            pcmi,
                            dwFlags,
                            &ExPara
                            );
                        if (fRet)
                            goto CommonReturn;
                        break;
                }
            }
            // No signer was found
            break;
        }

    case CMSG_SIGNED_AND_ENVELOPED:
        goto MessageTypeNotSupportedYet;

    default:
        goto InvalidMsgType;
    }

    assert(NULL == pSignerNode);
    goto SignerNotFound;

VerifyFoundSigner:
    ExPara.dwSignerIndex = dwSignerIndex;
    fRet = ICM_ControlVerifySignatureEx(
        pcmi,
        dwFlags,
        &ExPara
        );
    if (!fRet)
        goto ErrorReturn;

CommonReturn:
    ICM_FreeA( pb);
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, psib);
    PkiAsn1FreeInfo(pDec, CertIdentifier_PDU, pOssCertId);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR_VAR(DecodeCertIdentifierError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(DecodeSignerInfoWithBlobsError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(SignerNotFound,CRYPT_E_SIGNER_NOT_FOUND)
TRACE_ERROR(SerialNumberAllocError)             // error already set
}

#else

BOOL
WINAPI
ICM_GetVerifySignatureStuff(
    IN PCERT_INFO       pci,
    IN OUT HCRYPTPROV   *phCryptProv,
    OUT HCRYPTKEY       *phPubKey,
    OUT DWORD           *pdwPubKeyAlgId,
    OUT DWORD           *pdwPubKeyFlags)
{
    BOOL                    fRet;
    PCCRYPT_OID_INFO        pOIDInfo;
    HCRYPTPROV              hCryptProv;

    *pdwPubKeyAlgId = 0;
    *pdwPubKeyFlags = 0;
    if (pOIDInfo = CryptFindOIDInfo(
            CRYPT_OID_INFO_OID_KEY,
            pci->SubjectPublicKeyInfo.Algorithm.pszObjId,
            CRYPT_PUBKEY_ALG_OID_GROUP_ID
            )) {
        DWORD cExtra = pOIDInfo->ExtraInfo.cbData / sizeof(DWORD);
        DWORD *pdwExtra = (DWORD *) pOIDInfo->ExtraInfo.pbData;

        *pdwPubKeyAlgId = pOIDInfo->Algid;
        if (1 <= cExtra)
            *pdwPubKeyFlags = pdwExtra[0];
    }

    hCryptProv = *phCryptProv;
    if (0 == hCryptProv) {
        hCryptProv = I_CryptGetDefaultCryptProv(*pdwPubKeyAlgId);
        if (0 == hCryptProv)
            goto GetDefaultCryptProvError;
        *phCryptProv = hCryptProv;
    }

    // import the signer's public key
    if (!CryptImportPublicKeyInfo(
            hCryptProv,
            X509_ASN_ENCODING,
            &pci->SubjectPublicKeyInfo,
            phPubKey))
        goto ImportKeyFailed;
    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    *phPubKey = 0;
    goto CommonReturn;
TRACE_ERROR(GetDefaultCryptProvError)           // error already set
TRACE_ERROR(ImportKeyFailed)                    // error already set
}


//+-------------------------------------------------------------------------
//  Verify a signature
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlVerifySignature(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwFlags,
    IN PCERT_INFO pci)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    SignerInfoWithBlobs     *psib = NULL;
    CSignerNode             *pSignerNode = NULL;
    SignerInfo              *psi = NULL;
    Any                     *pc;            // &content
    HCRYPTHASH              hHashAttr = NULL;
    HCRYPTHASH              hHashDup = NULL;
    HCRYPTHASH              hHash = NULL;
    HCRYPTKEY               hPubKey = NULL;

    HCRYPTPROV              hCryptProv;
    DWORD                   dwPubKeyAlgId;
    DWORD                   dwPubKeyFlags;

    ULONG                   cbIssuer;
    PBYTE                   pbHash;
    PBYTE                   pb = NULL;
    ULONG                   cb;
    Any                     anyValue;
    DWORD                   cbMessageDigest;
    PBYTE                   pbMessageDigest;
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    CRYPT_DATA_BLOB         DataBlob;
    IssuerAndSerialNumber   *pisn = NULL;
    CHashNode               *pnHash;
    PICM_HASH_INFO          pHashInfo;


    switch (pcmi->dwMsgType) {
    case CMSG_SIGNED:
        {
            pc = (Any *)&pcmi->psdi->pci->content;
            cb = pci->SerialNumber.cbData;
            if (NULL == (pb = (PBYTE)ICM_AllocA( cb)))
                goto SerialNumberAllocError;
            cbIssuer = pci->Issuer.cbData;
            for (pSignerNode=pcmi->psdi->pSignerList->Head();
                    pSignerNode;
                    pSignerNode = pSignerNode->Next()) {
                PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, psib);
                psib = NULL;
                PkiAsn1FreeInfo(pDec, IssuerAndSerialNumber_PDU, pisn);
                pisn = NULL;

                DataBlob = pSignerNode->Data()->blob;
                if (0 != (Asn1Err = PkiAsn1Decode(
                        pDec,
                        (void **)&psib,
                        SignerInfoWithBlobs_PDU,
                        DataBlob.pbData,
                        DataBlob.cbData)))
                    goto DecodeSignerInfoWithBlobsError;
                if (0 != (Asn1Err = PkiAsn1Decode(
                        pDec,
                        (void **)&pisn,
                        IssuerAndSerialNumber_PDU,
                        (BYTE *) psib->issuerAndSerialNumber.value,
                        psib->issuerAndSerialNumber.length)))
                    goto DecodeIssuerAndSerialNumberError;
                if (pisn->issuer.length != cbIssuer)
                    continue;
                if (0 != memcmp( pci->Issuer.pbData, pisn->issuer.value, cbIssuer))
                    continue;
                // We need to add an integer method to compare big-endian
                // internal to a little-endian external value.
                if (pisn->serialNumber.length != cb)
                    continue;
                ICM_ReverseCopy( pb, pisn->serialNumber.value, cb);
                if (0 != memcmp( pb, pci->SerialNumber.pbData, cb))
                    continue;
                break;
            }
            // The matching signer (if found) is in psib
            // If no signer found, pSignerNode == NULL
            ICM_FreeA( pb);
            pb = NULL;
            break;
        }

    case CMSG_SIGNED_AND_ENVELOPED:
        goto MessageTypeNotSupportedYet;

    default:
        goto InvalidMsgType;
    }

    if (NULL == pSignerNode)
        goto SignerNotFound;
    if (!ICM_FindHashNodeFromEncodedAlgo(
            pcmi->pHashList,
            (PCRYPT_DATA_BLOB)&psib->digestAlgorithm,
            &pnHash))
        goto GetHashNodeFromEncodedAlgoError;
    pHashInfo = pnHash->Data();


    if (pcmi->fDefaultCryptProv)
        hCryptProv = 0;
    else
        hCryptProv = pcmi->hCryptProv;
    if (!ICM_GetVerifySignatureStuff(
            pci,
            &hCryptProv,
            &hPubKey,
            &dwPubKeyAlgId,
            &dwPubKeyFlags)) goto GetSignatureStuffError;

    if (psib->bit_mask & authAttributes_present) {
        // find the message digest attr value
        if (!ICM_GetAttrValue(
                (Attributes *)&psib->authAttributes,    // same, except for NOCOPY
                &oidMessageDigest,
                &anyValue))
            goto FindAttrError;
        // find the message digest octets
        if (!Asn1UtilExtractContent(
                (BYTE *) anyValue.value,
                anyValue.length,
                &cbMessageDigest,
                (const BYTE **)&pbMessageDigest))
            goto ExtractContentError;
        // get the hash value computed on the data
        if (!ICM_GetListHashValue( pnHash, &cb, &pbHash))
            goto GetHashValueError;
        // hash sizes equal?
        if (cb != cbMessageDigest)
            goto HashCompareSizeError;
        // hash octets equal?
        if (memcmp( pbMessageDigest, pbHash, cb))
            goto HashCompareValueError;
        // Now that we have verified the message digest octets,
        // get the hash of the authenticated attributes.
        // Should check the content type attribute as well.
        if (!ICM_GetAttrsHash(
                pHashInfo->dwAlgoCAPI,
                hCryptProv,
                (Attributes *)&psib->authAttributes,    // same, except for NOCOPY
                &hHashAttr))
            goto GetAuthAttrsHashError;
        hHash = hHashAttr;
    } else {
        if (!ICM_DupListHash( pnHash, hCryptProv, &hHashDup))
            goto DupListHashError;
        hHash = hHashDup;
    }

    // verify the hash, signature, and public key are consistent
    fRet = ICM_VerifySignature(
                hHash,
                hPubKey,
                dwPubKeyAlgId,
                dwPubKeyFlags,
                psib->encryptedDigest.value,
                psib->encryptedDigest.length);

    if (!fRet && hHashAttr) {
        // The hash of the authenticated attributes failed.
        // Maybe they hashed incorrectly-DER-encoded authenticated attributes
        // and gave us that encoding. Hash and verify the actual encoding of
        // the authattrs that they gave us. There is a bug in IE3.0 which hits
        // this path, due to a bug in the then-current OSS libraries.
        fRet = ICM_VerifySignatureAuthAttrBlob(
                        pcmi,
                        pSignerNode,
                        hCryptProv,
                        hPubKey,
                        pHashInfo->dwAlgoCAPI,
                        dwPubKeyAlgId,
                        dwPubKeyFlags,
                        psib->encryptedDigest.value,
                        psib->encryptedDigest.length);
    }
    if (!fRet)
        goto VerifySignatureError;

CommonReturn:
    ICM_FreeA( pb);
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, psib);
    PkiAsn1FreeInfo(pDec, IssuerAndSerialNumber_PDU, pisn);
    if (hPubKey)
        CryptDestroyKey(hPubKey);
    if (hHashAttr)
        CryptDestroyHash( hHashAttr);
    if (hHashDup)
        CryptDestroyHash( hHashDup);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
//    if (hHash && (0 == (pcmi->dwFlags & CMSG_DETACHED_FLAG)))
//        CryptDestroyHash( hHash);
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(FindAttrError,CRYPT_E_AUTH_ATTR_MISSING)
SET_ERROR(HashCompareSizeError,CRYPT_E_HASH_VALUE)
SET_ERROR(HashCompareValueError,CRYPT_E_HASH_VALUE)
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
SET_ERROR_VAR(DecodeSignerInfoWithBlobsError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(DecodeIssuerAndSerialNumberError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(SignerNotFound,CRYPT_E_SIGNER_NOT_FOUND)
TRACE_ERROR(SerialNumberAllocError)             // error already set
TRACE_ERROR(GetHashValueError)                  // error already set
TRACE_ERROR(GetAuthAttrsHashError)              // error already set
TRACE_ERROR(GetSignatureStuffError)             // error already set
TRACE_ERROR(GetHashNodeFromEncodedAlgoError)    // error already set
TRACE_ERROR(DupListHashError)                   // error already set
TRACE_ERROR(VerifySignatureError)               // error already set
dwFlags;
}
#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Verify a digest
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlVerifyDigest(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwFlags)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
    BYTE            *pbComputedDigest = NULL;
    DWORD           cbComputedDigest = 0;
    BYTE            *pbDigest = NULL;
    DWORD           cbDigest = 0;

    if (CMSG_HASHED != pcmi->dwMsgType)
        goto InvalidMsgTypeError;

    // get the computed digest
    CryptMsgGetParam(
                    (HCRYPTMSG)pcmi,
                    CMSG_COMPUTED_HASH_PARAM,
                    0,                      // dwIndex
                    NULL,                   // pvData
                    &cbComputedDigest);
    if (0 == cbComputedDigest)
        goto EmptyComputedDigestError;
    if (NULL == (pbComputedDigest = (PBYTE)ICM_AllocA( cbComputedDigest)))
        goto ComputedDigestAllocError;
    if (!CryptMsgGetParam(
                    (HCRYPTMSG)pcmi,
                    CMSG_COMPUTED_HASH_PARAM,
                    0,                      // dwIndex
                    pbComputedDigest,
                    &cbComputedDigest))
        goto GetComputedDigestError;

    // get the digest from the message
    CryptMsgGetParam(
                    (HCRYPTMSG)pcmi,
                    CMSG_HASH_DATA_PARAM,
                    0,                      // dwIndex
                    NULL,                   // pvData
                    &cbDigest);
    if (0 == cbDigest)
        goto EmptyDigestError;
    if (NULL == (pbDigest = (PBYTE)ICM_AllocA( cbDigest)))
        goto DigestAllocError;
    if (!CryptMsgGetParam(
                    (HCRYPTMSG)pcmi,
                    CMSG_HASH_DATA_PARAM,
                    0,                      // dwIndex
                    pbDigest,
                    &cbDigest))
        goto GetDigestError;

    // compare the computed digest to the digest from the message
    if (cbComputedDigest != cbDigest)
        goto DigestSizesUnequalError;
    if (0 != memcmp( pbDigest, pbComputedDigest, cbDigest))
        goto DigestsDifferError;

    fRet = TRUE;

CommonReturn:
    ICM_FreeA( pbComputedDigest);
    ICM_FreeA( pbDigest);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EmptyComputedDigestError)   // error already set
TRACE_ERROR(ComputedDigestAllocError)   // error already set
TRACE_ERROR(GetComputedDigestError)     // error already set
TRACE_ERROR(EmptyDigestError)           // error already set
TRACE_ERROR(DigestAllocError)           // error already set
TRACE_ERROR(GetDigestError)             // error already set
SET_ERROR(DigestSizesUnequalError,CRYPT_E_HASH_VALUE)
SET_ERROR(DigestsDifferError,CRYPT_E_HASH_VALUE)
SET_ERROR(InvalidMsgTypeError,CRYPT_E_INVALID_MSG_TYPE)
dwFlags;
}

#ifdef CMS_PKCS7

CmsRecipientInfos *
WINAPI
ICM_GetDecodedCmsRecipientInfos(
    IN PCRYPT_MSG_INFO pcmi
    )
{
    PCMSG_STREAM_INFO pcsi = pcmi->pStreamInfo;
    CmsRecipientInfos *pris = NULL;

    if (pcmi->fEncoding)
        goto InvalidMsgType;
    if (pcsi && (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_RECIPINFOS)))
        goto StreamMsgNotReadyError;
    if (NULL == pcmi->pvMsg)
        goto NotUpdated;

    switch (pcmi->dwMsgType) {
        case CMSG_ENVELOPED:
            pris = &((CmsEnvelopedData *)pcmi->pvMsg)->recipientInfos;
            break;

        case CMSG_SIGNED_AND_ENVELOPED:
            goto MessageTypeNotSupportedYet;

        default:
            goto InvalidMsgType;
    }

CommonReturn:
    return pris;

ErrorReturn:
    goto CommonReturn;

SET_ERROR(InvalidMsgType, CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(NotUpdated, CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(StreamMsgNotReadyError, CRYPT_E_STREAM_MSG_NOT_READY)
SET_ERROR(MessageTypeNotSupportedYet, CRYPT_E_INVALID_MSG_TYPE)
}

BOOL
WINAPI
ICM_ConvertPkcsToCmsRecipientIndex(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwPkcsIndex,
    OUT DWORD *pdwCmsIndex
    )
{
    BOOL fRet;
    CmsRecipientInfos *pris;
    CmsRecipientInfo *pri;
    DWORD dwCount;
    DWORD dwCmsIndex;
    DWORD i;

    if (NULL == (pris = ICM_GetDecodedCmsRecipientInfos(pcmi)))
        goto GetDecodedCmsRecipientsError;

    dwCount = pris->count;
    pri = pris->value;
    dwCmsIndex = dwPkcsIndex;
    i = 0;
    for ( ; 0 < dwCount; dwCount--, pri++) {
        if (keyTransRecipientInfo_chosen != pri->choice) {
            // Advance past non KeyTrans recipients
            dwCmsIndex++;
        } else {
            if (i == dwPkcsIndex)
                goto SuccessReturn;
            else
                i++;
        }
    }

    goto IndexTooBig;

SuccessReturn:
    fRet = TRUE;
CommonReturn:
    *pdwCmsIndex = dwCmsIndex;
    return fRet;

ErrorReturn:
    fRet = FALSE;
    dwCmsIndex = 0xFFFFFFFF;
    goto CommonReturn;
TRACE_ERROR(GetDecodedCmsRecipientsError)
SET_ERROR(IndexTooBig, CRYPT_E_INVALID_INDEX)
}

BOOL
WINAPI
ICM_ConvertCmsToPkcsRecipientIndex(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwCmsIndex,
    OUT DWORD *pdwPkcsIndex
    )
{
    BOOL fRet;
    CmsRecipientInfos *pris;
    CmsRecipientInfo *pri;
    DWORD dwCount;
    DWORD dwPkcsIndex;
    DWORD i;

    if (NULL == (pris = ICM_GetDecodedCmsRecipientInfos(pcmi)))
        goto GetDecodedCmsRecipientsError;

    dwCount = pris->count;
    if (dwCmsIndex >= dwCount)
        goto InvalidCmsIndex;
    pri = &pris->value[dwCmsIndex];
    if (keyTransRecipientInfo_chosen != pri->choice)
        goto InvalidPkcsIndex;

    pri = pris->value;
    dwPkcsIndex = 0;
    for (i = 0; i < dwCmsIndex; i++, pri++) {
        if (keyTransRecipientInfo_chosen == pri->choice)
            dwPkcsIndex++;
    }

    fRet = TRUE;
CommonReturn:
    *pdwPkcsIndex = dwPkcsIndex;
    return fRet;

ErrorReturn:
    fRet = FALSE;
    dwPkcsIndex = 0xFFFFFFFF;
    goto CommonReturn;

TRACE_ERROR(GetDecodedCmsRecipientsError)
SET_ERROR(InvalidCmsIndex, CRYPT_E_INVALID_INDEX)
SET_ERROR(InvalidPkcsIndex, CRYPT_E_INVALID_INDEX)
}

BOOL
WINAPI
ICM_GetPkcsRecipientCount(
    IN PCRYPT_MSG_INFO pcmi,
    OUT DWORD *pdwPkcsCount
    )
{
    BOOL fRet;
    CmsRecipientInfos *pris;
    CmsRecipientInfo *pri;
    DWORD dwCount;
    DWORD dwPkcsCount;

    if (NULL == (pris = ICM_GetDecodedCmsRecipientInfos(pcmi)))
        goto GetDecodedCmsRecipientsError;

    dwCount = pris->count;
    pri = pris->value;
    dwPkcsCount = 0;
    for ( ; 0 < dwCount; dwCount--, pri++) {
        if (keyTransRecipientInfo_chosen == pri->choice)
            dwPkcsCount++;
    }

    fRet = TRUE;
CommonReturn:
    *pdwPkcsCount = dwPkcsCount;
    return fRet;

ErrorReturn:
    dwPkcsCount = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetDecodedCmsRecipientsError)
}


typedef BOOL (WINAPI *PFN_ICM_IMPORT_CONTENT_ENCRYPT_KEY) (
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN void *pvDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    );

BOOL
WINAPI
ICM_ImportContentEncryptKey(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN void *pvDecryptPara,
    IN HCRYPTOIDFUNCADDR hImportContentEncryptKeyFuncSet,
    IN LPSTR pszKeyEncryptionOID,
    IN PFN_ICM_IMPORT_CONTENT_ENCRYPT_KEY pDefaultImportContentEncryptKey,
    OUT HCRYPTKEY *phContentEncryptKey
    )
{

    BOOL fRet;
    DWORD i;

#define IMPORT_CONTENT_ENCRYPT_OID_CNT  3
    LPSTR rgpszOID[IMPORT_CONTENT_ENCRYPT_OID_CNT] = {
        NULL,                       // pszKeyEncryptOID!pszContentEncryptOID
        pszKeyEncryptionOID,
        pContentEncryptionAlgorithm->pszObjId
    };

    DWORD cch;
    LPSTR psz;

    cch = strlen(rgpszOID[1]) + 1 + strlen(rgpszOID[2]) + 1;

    if (NULL == (psz = (LPSTR) ICM_Alloc(cch))) {
        *phContentEncryptKey = 0;
        return FALSE;
    }
    strcpy(psz, rgpszOID[1]);
    strcat(psz, "!");
    strcat(psz, rgpszOID[2]);
    rgpszOID[0] = psz;

    for (i = 0; i < IMPORT_CONTENT_ENCRYPT_OID_CNT; i++) {
        void *pvFuncAddr;
        HCRYPTOIDFUNCADDR hFuncAddr;

        if (CryptGetOIDFunctionAddress(
                hImportContentEncryptKeyFuncSet,
                X509_ASN_ENCODING,
                rgpszOID[i],
                0,                      // dwFlags
                &pvFuncAddr,
                &hFuncAddr)) {
            fRet = ((PFN_ICM_IMPORT_CONTENT_ENCRYPT_KEY) pvFuncAddr)(
                pContentEncryptionAlgorithm,
                pvDecryptPara,
                0,                              // dwFlags
                NULL,                           // pvReserved
                phContentEncryptKey
                );
            CryptFreeOIDFunctionAddress(hFuncAddr, 0);

            if (fRet || E_NOTIMPL != GetLastError())
                goto CommonReturn;
        }
    }

    fRet = pDefaultImportContentEncryptKey(
        pContentEncryptionAlgorithm,
        pvDecryptPara,
        0,                              // dwFlags
        NULL,                           // pvReserved
        phContentEncryptKey
        );

CommonReturn:
    ICM_Free(rgpszOID[0]);
    return fRet;
}

HCRYPTKEY
WINAPI
ICM_ImportEncryptedKey(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN HCRYPTPROV hCryptProv,
    IN HCRYPTKEY hUserKey,
    IN ALG_ID aiEncAlg,
    IN BYTE bType,
    IN PCRYPT_DATA_BLOB pEncryptedKey
    )
{
    BOOL fRet;
    DWORD dwError;
    HCRYPTKEY hEncryptKey = 0;
    DWORD dwAlgIdEncrypt;
    DWORD dwBitLen;
    BYTE rgbIV[IV_MAX_LENGTH];
    DWORD cbIV;

    PBYTE pbCspKey = NULL;
    DWORD cbCspKey;
    PUBLICKEYSTRUC *ppks;
    PSIMPLEBLOBHEADER psbh;

    if (!ICM_GetEncryptParameters(
            pContentEncryptionAlgorithm,
            &dwAlgIdEncrypt,
            &dwBitLen,
            rgbIV,
            &cbIV))
        goto GetEncryptParametersError;

    cbCspKey = sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER) +
        pEncryptedKey->cbData;
    if (NULL == (pbCspKey = (PBYTE)ICM_AllocA( cbCspKey)))
        goto CspKeyAllocError;
    ppks = (PUBLICKEYSTRUC *)pbCspKey;
    ppks->bType = bType;
    ppks->bVersion = CUR_BLOB_VERSION;
    ppks->reserved = 0;
    ppks->aiKeyAlg = dwAlgIdEncrypt;
    psbh = (PSIMPLEBLOBHEADER)(ppks + 1);
    psbh->aiEncAlg = aiEncAlg;
    if (SYMMETRICWRAPKEYBLOB == bType)
        memcpy( (PBYTE)(psbh+1), pEncryptedKey->pbData,
            pEncryptedKey->cbData);
    else
        ICM_ReverseCopy( (PBYTE)(psbh+1), pEncryptedKey->pbData,
            pEncryptedKey->cbData);

    fRet = CryptImportKey(
            hCryptProv,
            pbCspKey,
            cbCspKey,
            hUserKey,
            CRYPT_NO_SALT,       // dwFlags
            &hEncryptKey);

    if (!fRet) {
        hEncryptKey = 0;
        goto ImportKeyFailed;
    }

    if (CALG_RC2 == dwAlgIdEncrypt && 0 != dwBitLen)
        // Silently ignore any errors. Not supported in earlier versions
        CryptSetKeyParam(
            hEncryptKey,
            KP_EFFECTIVE_KEYLEN,
            (PBYTE) &dwBitLen,
            0);                 // dwFlags

    if (0 != cbIV) {
        if (CALG_RC4 == dwAlgIdEncrypt) {
            // For RC4, set the SALT, not the IV
            BOOL fRC4Salt = TRUE;

            if (IV_LENGTH == cbIV) {
                // Old implementations of 40 bit or 128 bit RC4 set the
                // IV which was ignored and didn't set the salt.

                // Get the bit length of the imported key and don't
                // set the salt for 40 or 128 bit RC4.

                DWORD dwRC4BitLen;
                DWORD cbKeyParamLen;

                dwRC4BitLen = 0;
                cbKeyParamLen = sizeof(dwRC4BitLen);
                if (!CryptGetKeyParam(
                        hEncryptKey,
                        KP_KEYLEN,
                        (PBYTE) &dwRC4BitLen,
                        &cbKeyParamLen,
                        0                       // dwFlags
                        ) || 40 == dwRC4BitLen || 128 == dwRC4BitLen)
                    fRC4Salt = FALSE;
            }

            if (fRC4Salt) {
                CRYPT_DATA_BLOB SaltBlob;
                SaltBlob.pbData = rgbIV;
                SaltBlob.cbData = cbIV;

                if (!CryptSetKeyParam(
                        hEncryptKey,
                        KP_SALT_EX,
                        (PBYTE) &SaltBlob,
                        0))                 // dwFlags
                    goto SetSaltExError;
            }
        } else {
            if (!CryptSetKeyParam(
                    hEncryptKey,
                    KP_IV,
                    rgbIV,
                    0))                 // dwFlags
                goto SetIVError;
        }
    }

CommonReturn:
    ICM_FreeA(pbCspKey);
    return hEncryptKey;

ErrorReturn:
    if (hEncryptKey) {
        dwError = GetLastError();
        CryptDestroyKey(hEncryptKey);
        SetLastError(dwError);
        hEncryptKey = 0;
    }
    goto CommonReturn;
TRACE_ERROR(GetEncryptParametersError)
TRACE_ERROR(ImportKeyFailed)
TRACE_ERROR(CspKeyAllocError)
TRACE_ERROR(SetSaltExError)
TRACE_ERROR(SetIVError)
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1
ICMTest_DefaultImportKeyTrans(
#else
ICM_DefaultImportKeyTrans(
#endif
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA pKeyTransDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    )
{
    DWORD dwError = ERROR_SUCCESS;
    BOOL fRet;
    HCRYPTKEY hUserKey = 0;
    PCMSG_KEY_TRANS_RECIPIENT_INFO pri = pKeyTransDecryptPara->pKeyTrans;
    HCRYPTPROV hCryptProv = pKeyTransDecryptPara->hCryptProv;

    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    if (CryptGetOIDFunctionAddress(
            hOldStyleImportEncryptKeyFuncSet,
            X509_ASN_ENCODING,
            pContentEncryptionAlgorithm->pszObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        if ((void *) ICM_DefaultImportEncryptKey == pvFuncAddr)
            fRet = FALSE;
#ifdef DEBUG_CRYPT_ASN1
        else if (0 == (ICMTest_GetDebugCryptAsn1Flags() &
                            DEBUG_OSS_CRYPT_ASN1_SAME_ENCRYPT_FLAG))
            fRet = FALSE;
#endif // DEBUG_CRYPT_ASN1
        else
            fRet = ((PFN_CMSG_IMPORT_ENCRYPT_KEY) pvFuncAddr)(
                hCryptProv,
                pKeyTransDecryptPara->dwKeySpec,
                pContentEncryptionAlgorithm,
                &pri->KeyEncryptionAlgorithm,
                pri->EncryptedKey.pbData,
                pri->EncryptedKey.cbData,
                phContentEncryptKey);
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);

        if (fRet)
            return TRUE;
    }

    if (0 != pKeyTransDecryptPara->dwKeySpec) {
        // Get private key to use.
        if (!CryptGetUserKey(
                hCryptProv,
                pKeyTransDecryptPara->dwKeySpec,
                &hUserKey)) {
            hUserKey = 0;
            goto GetUserKeyFailed;
        }
    }
    // else
    //  Use the provider's default private key for decrypting

    if (0 == (*phContentEncryptKey = ICM_ImportEncryptedKey(
            pContentEncryptionAlgorithm,
            hCryptProv,
            hUserKey,
            CALG_RSA_KEYX,
            SIMPLEBLOB,
            &pri->EncryptedKey
            )))
        goto ImportEncryptedKeyError;

    fRet = TRUE;
CommonReturn:
    if (hUserKey)
        CryptDestroyKey(hUserKey);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetUserKeyFailed)
TRACE_ERROR(ImportEncryptedKeyError)
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultImportKeyAgree(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA pKeyAgreeDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    )
{
    BOOL fRet;
    DWORD dwError = ERROR_SUCCESS;
    HCRYPTPROV hKeyAgreeProv = 0;           // Doesn't need to be released
    HCRYPTKEY hMyKey = 0;
    HCRYPTKEY hAgreeKey = 0;
    DWORD cbP;
    DWORD dwKeySpec;
    LPSTR pszWrapOID = NULL;
    DWORD dwAlgIdWrap;
    DWORD dwBitLen;
    PCMSG_KEY_AGREE_RECIPIENT_INFO pri = pKeyAgreeDecryptPara->pKeyAgree;

    hKeyAgreeProv = pKeyAgreeDecryptPara->hCryptProv;

    dwKeySpec = pKeyAgreeDecryptPara->dwKeySpec;
    if (0 == dwKeySpec)
        dwKeySpec = AT_KEYEXCHANGE;

    // Get my private Diffie Hellman key
    if (!CryptGetUserKey(
            hKeyAgreeProv,
            pKeyAgreeDecryptPara->dwKeySpec,
            &hMyKey)) {
        hMyKey = 0;
        goto GetMyKeyFailed;
    }

    // Get the length of P
    cbP = 0;
    if (!CryptGetKeyParam(
            hMyKey,
            KP_P,
            NULL,               // pbData
            &cbP,
            0                   // dwFlags
            ) || 0 == cbP)
        goto GetPLengthError;

    if (!ICM_GetDhWrapEncryptParameters(
            &pri->KeyEncryptionAlgorithm,
            &pszWrapOID,                    // allocated
            &dwAlgIdWrap,
            &dwBitLen))
        goto GetDhWrapEncryptParametersError;

    if (0 == (hAgreeKey = ICM_ImportDhAgreeKey(
            hKeyAgreeProv,
            hMyKey,
            cbP,
            &pKeyAgreeDecryptPara->OriginatorPublicKey,
            pszWrapOID,
            dwAlgIdWrap,
            dwBitLen,
            &pri->UserKeyingMaterial
            )))
        goto ImportDhAgreeKeyError;

    if (0 == (*phContentEncryptKey = ICM_ImportEncryptedKey(
            pContentEncryptionAlgorithm,
            hKeyAgreeProv,
            hAgreeKey,
            dwAlgIdWrap,
            SYMMETRICWRAPKEYBLOB,
            &pri->rgpRecipientEncryptedKeys[
                pKeyAgreeDecryptPara->dwRecipientEncryptedKeyIndex]->EncryptedKey
            )))
        goto ImportEncryptedKeyError;

    fRet = TRUE;
CommonReturn:
    ICM_Free(pszWrapOID);
    if (hAgreeKey)
        CryptDestroyKey(hAgreeKey);
    if (hMyKey)
        CryptDestroyKey(hMyKey);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetMyKeyFailed)
TRACE_ERROR(GetPLengthError)
TRACE_ERROR(GetDhWrapEncryptParametersError)
TRACE_ERROR(ImportDhAgreeKeyError)
TRACE_ERROR(ImportEncryptedKeyError)
}

//+-------------------------------------------------------------------------
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultImportMailList(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA pMailListDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    )
{
    BOOL fRet;
    DWORD dwError = ERROR_SUCCESS;

    HCRYPTPROV hMailListProv = 0;           // not released
    HCRYPTKEY hKeyEncryptionKey = 0;        // not destroyed
    PCMSG_MAIL_LIST_RECIPIENT_INFO pri = pMailListDecryptPara->pMailList;

    DWORD dwAlgIdEncrypt;
    DWORD dwBitLen;

    hMailListProv = pMailListDecryptPara->hCryptProv;
    switch (pMailListDecryptPara->dwKeyChoice) {
        case CMSG_MAIL_LIST_HANDLE_KEY_CHOICE:
            hKeyEncryptionKey = pMailListDecryptPara->hKeyEncryptionKey;
            assert(hMailListProv && hKeyEncryptionKey);
            if (0 == hMailListProv || 0 == hKeyEncryptionKey)
                goto InvalidMailListHandleKeyPara;
            break;
        default:
            goto InvalidMailListKeyChoice;
    }

    if (!ICM_GetWrapEncryptParameters(
            &pri->KeyEncryptionAlgorithm,
            &dwAlgIdEncrypt,
            &dwBitLen))
        goto GetWrapEncryptParametersError;

    if (CALG_RC2 == dwAlgIdEncrypt && 0 != dwBitLen)
        // Silently ignore any errors. Not supported in earlier versions
        CryptSetKeyParam(
            hKeyEncryptionKey,
            KP_EFFECTIVE_KEYLEN,
            (PBYTE) &dwBitLen,
            0);                 // dwFlags

    if (0 == (*phContentEncryptKey = ICM_ImportEncryptedKey(
            pContentEncryptionAlgorithm,
            hMailListProv,
            hKeyEncryptionKey,
            dwAlgIdEncrypt,
            SYMMETRICWRAPKEYBLOB,
            &pri->EncryptedKey
            )))
        goto ImportEncryptedKeyError;

    fRet = TRUE;

CommonReturn:
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidMailListHandleKeyPara, E_INVALIDARG)
SET_ERROR(InvalidMailListKeyChoice, E_INVALIDARG)
TRACE_ERROR(GetWrapEncryptParametersError)
TRACE_ERROR(ImportEncryptedKeyError)
}

//+-------------------------------------------------------------------------
//  Default import of the encryption key (OldStyle)
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultImportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN DWORD                        dwKeySpec,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiPubKey,
    IN PBYTE                        pbEncodedKey,
    IN DWORD                        cbEncodedKey,
    OUT HCRYPTKEY                   *phEncryptKey)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    HCRYPTKEY               hUserKey = 0;
    CRYPT_DATA_BLOB         EncryptedKey;

    if (0 != dwKeySpec) {
        // Get private key to use.
        if (!CryptGetUserKey(
                hCryptProv,
                dwKeySpec,
                &hUserKey)) {
            hUserKey = 0;
            goto GetUserKeyFailed;
        }
    }
    // else
    //  Use the provider's default private key for decrypting

    EncryptedKey.cbData = cbEncodedKey;
    EncryptedKey.pbData = pbEncodedKey;
    if (0 == (*phEncryptKey = ICM_ImportEncryptedKey(
            paiEncrypt,
            hCryptProv,
            hUserKey,
            CALG_RSA_KEYX,
            SIMPLEBLOB,
            &EncryptedKey
            )))
        goto ImportEncryptedKeyError;

    fRet = TRUE;
CommonReturn:
    if (hUserKey)
        CryptDestroyKey(hUserKey);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetUserKeyFailed)
TRACE_ERROR(ImportEncryptedKeyError)
}


//+-------------------------------------------------------------------------
//  Decrypt the content using any CMS recipient type
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlCmsDecrypt(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwFlags,
    IN void *pvDecryptPara,
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwRecipientIndex,
    IN HCRYPTOIDFUNCADDR hImportContentEncryptKeyFuncSet,
    IN LPSTR pszKeyEncryptionOID,
    IN PFN_ICM_IMPORT_CONTENT_ENCRYPT_KEY pDefaultImportContentEncryptKey
    )
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    EncryptedContentInfo    *peci = NULL;
    HCRYPTKEY               hkeySeal = NULL;
    PBYTE                   pbData = NULL;
    LONG                    cbData;
    AlgorithmIdentifier     *paiOssContentEncryption;
    PCRYPT_ALGORITHM_IDENTIFIER paiContentEncryption = NULL;
    PCMSG_STREAM_INFO       pcsi = pcmi->pStreamInfo;

    if( pcmi->Plaintext.pbData)
        goto MessageAlreadyDecrypted;

    switch (pcmi->dwMsgType) {
    case CMSG_ENVELOPED:
        {
            CmsEnvelopedData   *ped;

            ped = (CmsEnvelopedData *)pcmi->pvMsg;
            if (NULL == ped)
                goto NotUpdated;
            if (dwRecipientIndex >= ped->recipientInfos.count)
                goto RecipientIndexTooLarge;
            peci = &ped->encryptedContentInfo;
            paiOssContentEncryption =
                    &ped->encryptedContentInfo.contentEncryptionAlgorithm;
            break;
        }
    case CMSG_SIGNED_AND_ENVELOPED:
        goto MessageTypeNotSupportedYet;

    default:
        goto InvalidMsgType;
    }

    if (NULL == (paiContentEncryption = ICM_AllocAndGetALGORITHM_IDENTIFIER(
            paiOssContentEncryption)))
        goto GetEncryptAlgorithmError;

    if (!ICM_ImportContentEncryptKey(
            paiContentEncryption,
            pvDecryptPara,
            hImportContentEncryptKeyFuncSet,
            pszKeyEncryptionOID,
            pDefaultImportContentEncryptKey,
            &hkeySeal))
        goto ImportKeyError;

    if (pcsi) {
        if (!ICMS_SetDecryptKey( pcmi, hkeySeal))
            goto SetDecryptKeyError; // NB- Do not trash err from callback!
        hkeySeal = NULL;
    } else {
        // NB- For common bulk encryption algos,
        // sizeof(plaintext)<=sizeof(ciphertext)
        if (peci->bit_mask & encryptedContent_present)
            cbData = peci->encryptedContent.length;
        else
            cbData = 0;
        if (NULL == (pbData = (PBYTE)ICM_Alloc( cbData)))
            goto EncryptedContentAllocError;
        if (cbData ) {
            memcpy( pbData, peci->encryptedContent.value, cbData);
            if (!CryptDecrypt(
                    hkeySeal,
                    NULL,
                    TRUE,               // fFinal
                    0,                  // dwFlags
                    pbData,
                    (PDWORD)&cbData))
                goto DecryptError;
        }
        CryptDestroyKey( hkeySeal);
        hkeySeal = NULL;

        pcmi->Plaintext.cbData = cbData;
        pcmi->Plaintext.pbData = pbData;
        pbData = NULL;
    }

    if (dwFlags & CMSG_CRYPT_RELEASE_CONTEXT_FLAG)
        pcmi->hCryptProvContentCrypt = hCryptProv;
    pcmi->dwDecryptedRecipientIndex = dwRecipientIndex;

    fRet = TRUE;
CommonReturn:
    ICM_Free(paiContentEncryption);
    ICM_Free(pbData);
    if (hkeySeal)
        CryptDestroyKey( hkeySeal);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(MessageAlreadyDecrypted,CRYPT_E_ALREADY_DECRYPTED)
SET_ERROR(RecipientIndexTooLarge, CRYPT_E_INVALID_INDEX)
SET_ERROR(NotUpdated, CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType, CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
TRACE_ERROR(GetEncryptAlgorithmError)
TRACE_ERROR(ImportKeyError)
TRACE_ERROR(EncryptedContentAllocError)
TRACE_ERROR(SetDecryptKeyError)
TRACE_ERROR(DecryptError)
}


//+-------------------------------------------------------------------------
//  Decrypt the content using only a PKCS 1.5 recipient type
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlPkcsDecrypt(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwFlags,
    IN PCMSG_CTRL_DECRYPT_PARA pmcdp
    )
{
    BOOL fRet;
    CMSG_CTRL_KEY_TRANS_DECRYPT_PARA KeyTransDecryptPara;
    PCMSG_CMS_RECIPIENT_INFO pRecipientInfo = NULL;
    DWORD dwCmsIndex;

    assert( pmcdp->cbSize >= sizeof(*pmcdp));
    if (pmcdp->cbSize < sizeof(*pmcdp))
        goto InvalidArg;

    if (!ICM_ConvertPkcsToCmsRecipientIndex(
            pcmi, pmcdp->dwRecipientIndex, &dwCmsIndex))
        goto ConvertPkcsToCmsRecipientIndexError;

    if (NULL == (pRecipientInfo =
        (PCMSG_CMS_RECIPIENT_INFO) ICM_AllocAndGetParam(
            pcmi, CMSG_CMS_RECIPIENT_INFO_PARAM, dwCmsIndex)))
        goto GetCmsRecipientInfoParamError;

    assert(CMSG_KEY_TRANS_RECIPIENT == pRecipientInfo->dwRecipientChoice);

    memset(&KeyTransDecryptPara, 0, sizeof(KeyTransDecryptPara));
    KeyTransDecryptPara.cbSize = sizeof(KeyTransDecryptPara);
    KeyTransDecryptPara.hCryptProv = pmcdp->hCryptProv;
    KeyTransDecryptPara.dwKeySpec = pmcdp->dwKeySpec;
    KeyTransDecryptPara.pKeyTrans = pRecipientInfo->pKeyTrans;
    KeyTransDecryptPara.dwRecipientIndex = dwCmsIndex;

    fRet = ICM_ControlCmsDecrypt(
        pcmi,
        dwFlags,
        &KeyTransDecryptPara,
        KeyTransDecryptPara.hCryptProv,
        dwCmsIndex,
        hImportKeyTransFuncSet,
        KeyTransDecryptPara.pKeyTrans->KeyEncryptionAlgorithm.pszObjId,
        (PFN_ICM_IMPORT_CONTENT_ENCRYPT_KEY) ICM_DefaultImportKeyTrans
        );

CommonReturn:
    ICM_Free(pRecipientInfo);
    return fRet;
ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

SET_ERROR(InvalidArg, E_INVALIDARG)
TRACE_ERROR(ConvertPkcsToCmsRecipientIndexError)
TRACE_ERROR(GetCmsRecipientInfoParamError)
}

#else
//+-------------------------------------------------------------------------
//  Default import of the encryption key
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_DefaultImportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN DWORD                        dwKeySpec,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiPubKey,
    IN PBYTE                        pbEncodedKey,
    IN DWORD                        cbEncodedKey,
    OUT HCRYPTKEY                   *phEncryptKey)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    HCRYPTKEY               hEncryptKey = 0;
    HCRYPTKEY               hUserKey = 0;
    DWORD                   dwAlgIdEncrypt;
    DWORD                   dwAlgIdPubKey;
    PBYTE                   pbCspKey = NULL;
    DWORD                   cbCspKey;
    PUBLICKEYSTRUC          *ppks;
    PSIMPLEBLOBHEADER       psbh;

    BYTE                    rgbIV[IV_LENGTH];
    DWORD                   cbIV;
    DWORD                   dwBitLen;

    if (!ICM_GetEncryptParameters(
            paiEncrypt,
            &dwAlgIdEncrypt,
            &dwBitLen,
            rgbIV,
            &cbIV))
        goto GetEncryptParametersError;
#if 0
    if (!ICM_GetOssCAPI(
            CRYPT_PUBKEY_ALG_OID_GROUP_ID,
            paiPubKey,
            &dwAlgIdPubKey))
        goto PubKeyGetCAPIError;
#else
    // We have no idea what the right values are for the alg id's here.
    dwAlgIdPubKey = CALG_RSA_KEYX;
#endif
    cbCspKey = cbEncodedKey + sizeof(PUBLICKEYSTRUC) + sizeof(SIMPLEBLOBHEADER);
    if (NULL == (pbCspKey = (PBYTE)ICM_AllocA( cbCspKey)))
        goto CspKeyAllocError;
    ppks = (PUBLICKEYSTRUC *)pbCspKey;
    ppks->bType = SIMPLEBLOB;
    ppks->bVersion = CUR_BLOB_VERSION;
    ppks->reserved = 0;
    ppks->aiKeyAlg = dwAlgIdEncrypt;
    psbh = (PSIMPLEBLOBHEADER)(ppks + 1);
    psbh->aiEncAlg = dwAlgIdPubKey;
    ICM_ReverseCopy( (PBYTE)(psbh+1), pbEncodedKey, cbEncodedKey);

    if (0 != dwKeySpec) {
        // Get private key to use.
        if (!CryptGetUserKey(
                hCryptProv,
                dwKeySpec,
                &hUserKey)) {
            hUserKey = 0;
            goto GetUserKeyFailed;
        }
    }
    // else
    //  Use the provider's default private key for decrypting

    fRet = CryptImportKey(
            hCryptProv,
            pbCspKey,
            cbCspKey,
            hUserKey,
            CRYPT_NO_SALT,       // dwFlags
            &hEncryptKey);
    if (!fRet) {
        dwError = GetLastError();
        if (hUserKey) {
            if (NTE_BAD_FLAGS == dwError)
                // Try without salt. Previous versions didn't support
                // CRYPT_NO_SALT flag
                fRet = CryptImportKey(
                    hCryptProv,
                    pbCspKey,
                    cbCspKey,
                    hUserKey,
                    0,       // dwFlags
                    &hEncryptKey);
            if (!fRet) {
                // Try without using the specified user key. Many versions of
                // the CSP don't allow a non-null hUserKey parameter.
                fRet = CryptImportKey(
                    hCryptProv,
                    pbCspKey,
                    cbCspKey,
                    0,                  // hUserKey
                    CRYPT_NO_SALT,      // dwFlags
                    &hEncryptKey);
                if (!fRet)
                    dwError = GetLastError();

            }
        }

        if (!fRet && NTE_BAD_FLAGS == dwError)
            // Try without user key and without CRYPT_NO_SALT flag
            fRet = CryptImportKey(
                hCryptProv,
                pbCspKey,
                cbCspKey,
                0,          // hUserKey
                0,          // dwFlags
                &hEncryptKey);

        if (!fRet && 2 >= paiEncrypt->Parameters.cbData) {
            // Try importing as an NT4.0 SP3 encypted key that wasn't byte
            // reversed and with zero salt.
            memcpy( (PBYTE)(psbh+1), pbEncodedKey, cbEncodedKey);
            fRet = CryptImportKey(
                hCryptProv,
                pbCspKey,
                cbCspKey,
                hUserKey,
                0,          // dwFlags
                &hEncryptKey);
            if (!fRet && hUserKey) {
                // Try without using the specified user key.
                fRet = CryptImportKey(
                    hCryptProv,
                    pbCspKey,
                    cbCspKey,
                    0,          // hUserKey
                    0,          // dwFlags
                    &hEncryptKey);
            }
        }

        if (!fRet) {
            hEncryptKey = 0;
            goto ImportKeyFailed;
        }
    }

    if (CALG_RC2 == dwAlgIdEncrypt && 0 != dwBitLen)
        // Silently ignore any errors. Not supported in earlier versions
        CryptSetKeyParam(
            hEncryptKey,
            KP_EFFECTIVE_KEYLEN,
            (PBYTE) &dwBitLen,
            0);                 // dwFlags

    if (0 != cbIV) {
        if (!CryptSetKeyParam(
                hEncryptKey,
                KP_IV,
                rgbIV,
                0))                 // dwFlags
            goto SetKeyParamError;
    }

    fRet = TRUE;
CommonReturn:
    ICM_FreeA(pbCspKey);
    if (hUserKey)
        CryptDestroyKey(hUserKey);
    ICM_SetLastError(dwError);
    *phEncryptKey = hEncryptKey;
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    if (hEncryptKey) {
        CryptDestroyKey(hEncryptKey);
        hEncryptKey = 0;
    }
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetEncryptParametersError)
//SET_ERROR(PubKeyGetCAPIError,CRYPT_E_UNKNOWN_ALGO)
TRACE_ERROR(GetUserKeyFailed)
TRACE_ERROR(ImportKeyFailed)
TRACE_ERROR(CspKeyAllocError)
TRACE_ERROR(SetKeyParamError)
}


//+-------------------------------------------------------------------------
//  Import the encryption key
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ImportEncryptKey(
    IN HCRYPTPROV                   hCryptProv,
    IN DWORD                        dwKeySpec,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiEncrypt,
    IN PCRYPT_ALGORITHM_IDENTIFIER  paiPubKey,
    IN PBYTE                        pbEncodedKey,
    IN DWORD                        cbEncodedKey,
    OUT HCRYPTKEY                   *phEncryptKey)
{
    BOOL fResult;
    void *pvFuncAddr;
    HCRYPTOIDFUNCADDR hFuncAddr;

    if (CryptGetOIDFunctionAddress(
            hImportEncryptKeyFuncSet,
            X509_ASN_ENCODING,
            paiEncrypt->pszObjId,
            0,                      // dwFlags
            &pvFuncAddr,
            &hFuncAddr)) {
        fResult = ((PFN_CMSG_IMPORT_ENCRYPT_KEY) pvFuncAddr)(
            hCryptProv,
            dwKeySpec,
            paiEncrypt,
            paiPubKey,
            pbEncodedKey,
            cbEncodedKey,
            phEncryptKey);
        CryptFreeOIDFunctionAddress(hFuncAddr, 0);
    } else
        fResult = ICM_DefaultImportEncryptKey(
            hCryptProv,
            dwKeySpec,
            paiEncrypt,
            paiPubKey,
            pbEncodedKey,
            cbEncodedKey,
            phEncryptKey);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Decrypt the content
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlDecrypt(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwFlags,
    IN void *pvCtrlPara)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    PCMSG_CTRL_DECRYPT_PARA  pmcdp;
    RecipientInfo           *pri = NULL;
    EncryptedContentInfo    *peci = NULL;
    HCRYPTKEY               hkeySeal = NULL;
    PBYTE                   pbData = NULL;
    LONG                    cbData;
    AlgorithmIdentifier     *paiOssContentEncryption;
    PCRYPT_ALGORITHM_IDENTIFIER paiContentEncryption = NULL;
    AlgorithmIdentifier     *paiOssKeyEncryption;
    PCRYPT_ALGORITHM_IDENTIFIER paiKeyEncryption = NULL;
    PCMSG_STREAM_INFO       pcsi = pcmi->pStreamInfo;

    pmcdp = (PCMSG_CTRL_DECRYPT_PARA)pvCtrlPara;
    assert( pmcdp->cbSize >= sizeof(CMSG_CTRL_DECRYPT_PARA));
    if (pmcdp->cbSize < sizeof(CMSG_CTRL_DECRYPT_PARA))
        goto InvalidArg;

    if (dwFlags & CMSG_CRYPT_RELEASE_CONTEXT_FLAG)
        pcmi->hCryptProvContentCrypt = pmcdp->hCryptProv;

    if( pcmi->Plaintext.pbData)
        goto MessageAlreadyDecrypted;

    switch (pcmi->dwMsgType) {
    case CMSG_ENVELOPED:
        {
            EnvelopedData   *ped;

            ped = (EnvelopedData *)pcmi->pvMsg;
            peci = &ped->encryptedContentInfo;
            if (pmcdp->dwRecipientIndex >= ped->recipientInfos.count)
                goto RecipientIndexTooLarge;
            pri = ped->recipientInfos.value + pmcdp->dwRecipientIndex;
            paiOssContentEncryption =
                    &ped->encryptedContentInfo.contentEncryptionAlgorithm;
            paiOssKeyEncryption = &pri->keyEncryptionAlgorithm;
            break;
        }
    case CMSG_SIGNED_AND_ENVELOPED:
        goto MessageTypeNotSupportedYet;

    default:
        goto InvalidMsgType;
    }

    if (NULL == pri)
        goto RecipientNotFound;         // really NULL if not found?

    if (NULL == (paiContentEncryption = ICM_AllocAndGetALGORITHM_IDENTIFIER(
            paiOssContentEncryption)))
        goto GetEncryptAlgorithmError;
    if (NULL == (paiKeyEncryption = ICM_AllocAndGetALGORITHM_IDENTIFIER(
            paiOssKeyEncryption)))
        goto GetKeyAlgorithmError;
    if (!ICM_ImportEncryptKey(
            pmcdp->hCryptProv,
            pmcdp->dwKeySpec,
            paiContentEncryption,
            paiKeyEncryption,
            pri->encryptedKey.value,
            pri->encryptedKey.length,
            &hkeySeal))
        goto ImportKeyError;

    if (pcsi) {
        if (!ICMS_SetDecryptKey( pcmi, hkeySeal))
            goto SetDecryptKeyError; // NB- Do not trash err from callback!
        hkeySeal = NULL;
    } else {
        // NB- For common bulk encryption algos,
        // sizeof(plaintext)<=sizeof(ciphertext)
        cbData = peci->encryptedContent.length;
        if (NULL == (pbData = (PBYTE)ICM_Alloc( cbData)))
            goto EncryptedContentAllocError;
        memcpy( pbData, peci->encryptedContent.value, cbData);
        if (!CryptDecrypt(
                hkeySeal,
                NULL,
                TRUE,               // fFinal
                0,                  // dwFlags
                pbData,
                (PDWORD)&cbData))
            goto DecryptError;
        CryptDestroyKey( hkeySeal);
        hkeySeal = NULL;

        pcmi->Plaintext.cbData = cbData;
        pcmi->Plaintext.pbData = pbData;
        pbData = NULL;
    }

    pcmi->dwDecryptedRecipientIndex = pmcdp->dwRecipientIndex;

    fRet = TRUE;
CommonReturn:
    ICM_Free(paiContentEncryption);
    ICM_Free(paiKeyEncryption);
    ICM_Free( pbData);
    if (hkeySeal)
        CryptDestroyKey( hkeySeal);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidArg,E_INVALIDARG)
SET_ERROR(MessageAlreadyDecrypted,CRYPT_E_ALREADY_DECRYPTED)
SET_ERROR(RecipientIndexTooLarge,CRYPT_E_INVALID_INDEX)
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(RecipientNotFound,CRYPT_E_RECIPIENT_NOT_FOUND)
TRACE_ERROR(GetEncryptAlgorithmError)
TRACE_ERROR(GetKeyAlgorithmError)
TRACE_ERROR(ImportKeyError)
TRACE_ERROR(EncryptedContentAllocError)
TRACE_ERROR(SetDecryptKeyError)
TRACE_ERROR(DecryptError)
}

#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Hash the content of a message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_HashContent(
    IN PCRYPT_MSG_INFO  pcmi,
    IN OUT HCRYPTHASH   hHash)
{
    DWORD       dwError = ERROR_SUCCESS;
    BOOL        fRet;
    HCRYPTMSG   hCryptMsg = (HCRYPTMSG)pcmi;
    PBYTE       pbAllocData = NULL;
    PBYTE       pbData;
    DWORD       cbData;

    cbData = 0;
    CryptMsgGetParam(
            hCryptMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            NULL,
            &cbData);
    if (0 == cbData)
        goto GetContentSizeError;
    if (NULL == (pbAllocData = (PBYTE)ICM_Alloc(cbData)))
        goto AllocContentError;
    if (!CryptMsgGetParam(
            hCryptMsg,
            CMSG_CONTENT_PARAM,
            0,                      // dwIndex
            pbAllocData,
            &cbData))
        goto GetContentError;

    pbData = pbAllocData;

    if (0 != strcmp(pszObjIdDataType, pcmi->psdi->pci->pszContentType)
#ifdef CMS_PKCS7
            &&  pcmi->psdi->version < CMSG_SIGNED_DATA_CMS_VERSION 
#endif  // CMS_PKCS7
                ) {
        // Leading tag and length octets aren't included in the digest
        if (0 > Asn1UtilExtractContent( pbData, cbData, &cbData,
                    (const BYTE **)&pbData))
            goto ExtractContentError;
    }

    if (!ICM_UpdateDigest( hHash, pbData, cbData))
        goto UpdateDigestError;

    fRet = TRUE;
CommonReturn:
    ICM_Free( pbAllocData);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetContentSizeError)    // error already set
TRACE_ERROR(AllocContentError)      // error already set
TRACE_ERROR(GetContentError)        // error already set
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
TRACE_ERROR(UpdateDigestError)      // error already set
}


//+-------------------------------------------------------------------------
//  Add a signer to a signed-data or signed-and-enveloped-data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlAddSigner(
    IN OUT PCRYPT_MSG_INFO      pcmi,
    IN DWORD                    dwFlags,
    IN PCMSG_SIGNER_ENCODE_INFO psei)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    CHashNode           *pnHash;
    CSignerNode         *pnSigner;
    DWORD               dwAlgoCAPI;
    SignerInfo          *psi = NULL;
    Attribute           *pAuthAttr;
    DWORD               cAuthAttr;
    Attribute           *pUnauthAttr;
    DWORD               cUnauthAttr;
    LPSTR               pszInnerContentObjID;
    ICM_HASH_INFO       HashInfo;               ZEROSTRUCT(HashInfo);
    AlgorithmIdentifier oaiHash;
    CBlobNode           *pnBlob;
    CRYPT_DATA_BLOB     blobHashAlgo;           ZEROSTRUCT(blobHashAlgo);
    SIGNER_DATA_INFO    sdi;                    ZEROSTRUCT(sdi);

#ifdef CMS_PKCS7
    SIGNER_ENCODE_DATA_INFO SignerEncodeDataInfo;
#endif  // CMS_PKCS7

    // if the hash algorithm matches one of the ones already in use,
    //      get that hash and encrypt it
    // else
    //      hash the data again and add hash algo to top-level list
    //      [NB- must access data again]

    // Search for a hash node with a matching hash algorithm
    if (!(ICM_GetCAPI(
            CRYPT_HASH_ALG_OID_GROUP_ID,
            &psei->HashAlgorithm,
            &dwAlgoCAPI) ||
          ICM_GetCAPI(
            CRYPT_SIGN_ALG_OID_GROUP_ID,
            &psei->HashAlgorithm,
            &dwAlgoCAPI)))
        goto GetCAPIError;

    // before, this could have never failed, but now it can
    // only create a hash node if the hash didn't exists.
    if (!ICM_FindHashNodeFromCapiAlgid( pcmi->pHashList, dwAlgoCAPI, &pnHash)  &&
        GetLastError() != CRYPT_E_UNKNOWN_ALGO)
        goto FindHashNodeFromCapiAlgidError;

    if (!pnHash) {
        // New hash.
        // 1. Create hash node
        // 2. Hash the data
        // 3. Add hash node to pcmi->pHashList
        // 4. Encode this hash algo and add to pcmi->psdi->pAlgidList
        HashInfo.dwAlgoCAPI = dwAlgoCAPI;
#ifndef CMS_PKCS7
        HashInfo.hCryptProv = psei->hCryptProv;
#endif  // CMS_PKCS7
        if (!CryptCreateHash(
                        psei->hCryptProv,
                        HashInfo.dwAlgoCAPI,
                        NULL,               // hKey - optional for MAC
                        0,                  // dwFlags
                        &HashInfo.hHash))
            goto CreateHashError;
        if (!ICM_HashContent( pcmi, HashInfo.hHash))    // hash content
            goto HashContentError;
        if (NULL == (pnHash = new CHashNode))
            goto NewHashNodeError;
        pnHash->SetData( &HashInfo);
        pcmi->pHashList->InsertTail( pnHash);

        // Convert the hash algorithm to a blob and
        // add to pcmi->psdi->pAlgidList.
        if (!ICM_MsgAsn1ToAlgorithmIdentifier(
                pcmi,
                &psei->HashAlgorithm,
                &oaiHash))
            goto MsgAsn1ToAlgorithmIdentifierError;
        if (!ICM_Asn1Encode(
                AlgorithmIdentifier_PDU,
                &oaiHash,
                &blobHashAlgo))
            goto EncodeHashAlgorithmError;
        if (NULL == (pnBlob = new CBlobNode))
            goto NewBlobNodeError;
        pnBlob->SetData( &blobHashAlgo);
        pcmi->psdi->pAlgidList->InsertTail( pnBlob);
    }

    // Alloc and fill in a SignerInfo

    pszInnerContentObjID = pcmi->psdi->pci->pszContentType;
    if (!strcmp( pszInnerContentObjID, pszObjIdDataType))
        pszInnerContentObjID = NULL;

    // NB - Each SignerInfo gets a non-empty authenticatedAttributes
    //      if the inner contentType is not data (passed in) or if
    //      there are authenticated attributes passed in. In this case,
    //      we reserve two Attribute slots at the beginning of the array
    //      for the content-type and message-digest Attribute values.
    cAuthAttr = 0;
    if (pszInnerContentObjID ||
            psei->cAuthAttr ||
            (dwFlags & CMSG_AUTHENTICATED_ATTRIBUTES_FLAG)) {
        cAuthAttr = psei->cAuthAttr + 2;        // reserve 2
    }
    cUnauthAttr = psei->cUnauthAttr;
    psi = (SignerInfo *)ICM_AllocZero(                sizeof( SignerInfo) +
                                        cAuthAttr   * sizeof( Attribute) +
                                        cUnauthAttr * sizeof( Attribute)
                                     );
    if (NULL == psi)
        goto SignerInfoAllocError;
    pAuthAttr = (Attribute *)(psi + 1);
    pUnauthAttr = pAuthAttr + cAuthAttr;

    if (!ICM_FillAsnSignerInfo(
            psei,
            pcmi,
            dwFlags,
            pszInnerContentObjID,
            psi,
            &pAuthAttr,
            &pUnauthAttr))
        goto FillAsnSignerInfoError;

#ifdef CMS_PKCS7
    SignerEncodeDataInfo.hCryptProv = psei->hCryptProv;
    SignerEncodeDataInfo.dwKeySpec = psei->dwKeySpec;
    SignerEncodeDataInfo.pHashNode = pnHash;
    if (!ICM_FillSignerEncryptedDigest(
            psi,
            pszInnerContentObjID,
            &SignerEncodeDataInfo,
            FALSE))             // fMaxLength
        goto FillSignerEncryptedDigestError;
#else
    if (!ICM_FillSignerEncryptedDigest(
            psi,
            pszInnerContentObjID,
            pnHash,
            psei->dwKeySpec,
            FALSE))             // fMaxLength
        goto FillSignerEncryptedDigestError;
#endif  // CMS_PKCS7

    // Encode the signer and add to pcmi->psdi->pSignerList.
    if (!ICM_Asn1Encode(
            SignerInfo_PDU,
            psi,
            &sdi.blob))
        goto EncodeSignerInfoError;
    if (NULL == (pnSigner = new CSignerNode))
        goto NewSignerInfoBlobNodeError;
    pnSigner->SetData( &sdi);
    pcmi->psdi->pSignerList->InsertTail( pnSigner);

    fRet = TRUE;
CommonReturn:
    if (psi) {
        ICM_FreeAsnSignerInfo(psi);
        ICM_Free(psi);
    }
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    ICM_Free(blobHashAlgo.pbData);
    ICM_Free(sdi.blob.pbData);
    if (HashInfo.hHash)
        CryptDestroyHash(HashInfo.hHash);
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(GetCAPIError,CRYPT_E_UNKNOWN_ALGO)
SET_ERROR(NewHashNodeError,E_OUTOFMEMORY)
SET_ERROR(NewBlobNodeError,E_OUTOFMEMORY)
SET_ERROR(NewSignerInfoBlobNodeError,E_OUTOFMEMORY)
TRACE_ERROR(FindHashNodeFromCapiAlgidError)     // error already set
TRACE_ERROR(CreateHashError)                    // error already set
TRACE_ERROR(HashContentError)                   // error already set
TRACE_ERROR(MsgAsn1ToAlgorithmIdentifierError) // error already set
TRACE_ERROR(EncodeHashAlgorithmError)           // error already set
TRACE_ERROR(SignerInfoAllocError)               // error already set
TRACE_ERROR(FillAsnSignerInfoError)             // error already set
TRACE_ERROR(FillSignerEncryptedDigestError)     // error already set
TRACE_ERROR(EncodeSignerInfoError)              // error already set
}

//+-------------------------------------------------------------------------
//  Add a CMS signer info to a signed-data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlAddCmsSignerInfo(
    IN OUT PCRYPT_MSG_INFO      pcmi,
    IN DWORD                    dwFlags,
    IN PCMSG_CMS_SIGNER_INFO    psi)
{
    BOOL                fRet;
    CSignerNode         *pnSigner;
    SIGNER_DATA_INFO    sdi;                    ZEROSTRUCT(sdi);


    // Encode the signer
    if (!ICM_CmsSignerInfoEncode(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            CMS_SIGNER_INFO,
            psi,
            NULL,               // pbEncoded
            &sdi.blob.cbData
            ))
        goto EncodeSignerInfoError;
    if (NULL == (sdi.blob.pbData = (PBYTE) ICM_Alloc(sdi.blob.cbData)))
        goto OutOfMemory;
    if (!ICM_CmsSignerInfoEncode(
            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
            CMS_SIGNER_INFO,
            psi,
            sdi.blob.pbData,
            &sdi.blob.cbData
            ))
        goto EncodeSignerInfoError;

    // Add to pcmi->psdi->pSignerList.
    if (NULL == (pnSigner = new CSignerNode))
        goto NewSignerInfoBlobNodeError;
    pnSigner->SetData( &sdi);
    pcmi->psdi->pSignerList->InsertTail( pnSigner);

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    ICM_Free(sdi.blob.pbData);
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(OutOfMemory)
TRACE_ERROR(EncodeSignerInfoError)
SET_ERROR(NewSignerInfoBlobNodeError,E_OUTOFMEMORY)
}

//+-------------------------------------------------------------------------
//  Remove a signer from a signed-data or signed-and-enveloped-data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlDelSigner(
    IN OUT PCRYPT_MSG_INFO      pcmi,
    IN DWORD                    dwFlags,
    IN DWORD                    dwIndex)
{
    BOOL                fRet;
    CSignerNode         *pnSigner = pcmi->psdi->pSignerList->Nth( dwIndex);

    if (NULL == pnSigner)
        goto IndexTooLargeError;

    pcmi->psdi->pSignerList->Remove( pnSigner);
    delete pnSigner;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(IndexTooLargeError,CRYPT_E_INVALID_INDEX)
dwFlags;
}


//+-------------------------------------------------------------------------
//  Initialize the unauthenticated attributes list. Called before doing an
//  add or delete.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_InitUnauthAttrList(
    IN CSignerNode          *pnSigner
    )
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    CBlobList               *plBlob = NULL;
    DWORD                   i;
    SIGNER_DATA_INFO        sdi;
    SignerInfoWithAttrBlobs *posib = NULL;
    Any                     *pAny;
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();

    assert(pnSigner);
    sdi = *pnSigner->Data();
    if (NULL == sdi.pUnauthAttrList) {
        if (NULL == (plBlob = new CBlobList))
            goto NewUnauthAttrListError;
        if (0 != (Asn1Err = PkiAsn1Decode(
                pDec,
                (void **)&posib,
                SignerInfoWithAttrBlobs_PDU,
                sdi.blob.pbData,
                sdi.blob.cbData)))
            goto DecodeSignerInfoError;
        if (posib->bit_mask & unauthAttributes_present) {
            for (i=posib->unauthAttributes.count, pAny=posib->unauthAttributes.value;
                    i>0;
                    i--, pAny++)
                if (!ICM_InsertTailBlob( plBlob, pAny))
                    goto InsertOldUnauthAttrBlobError;
        }
        sdi.pUnauthAttrList = plBlob;

        pnSigner->SetData( &sdi);
    }

    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfoWithAttrBlobs_PDU, posib);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    if (plBlob)
        delete plBlob;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(NewUnauthAttrListError,E_OUTOFMEMORY)
TRACE_ERROR(InsertOldUnauthAttrBlobError)   // error already set
}

//+-------------------------------------------------------------------------
//  Add an unauthenticated attribute to a SignerInfo of a signed-data or
//  signed-and-enveloped-data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlAddUnauthAttr(
    IN PCRYPT_MSG_INFO      pcmi,
    IN DWORD                dwFlags,
    IN PCMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA pmcasuap)
{
    BOOL                    fRet;
    CSignerNode             *pnSigner;
    DWORD                   i;

    for (i=pmcasuap->dwSignerIndex,
                pnSigner=pcmi->psdi->pSignerList->Head();
            (i>0) && pnSigner;
            i--, pnSigner = pnSigner->Next())
        ;
    if (NULL == pnSigner)
        goto IndexTooLargeError;

    if (!ICM_InitUnauthAttrList(pnSigner))
        goto InitUnauthAttrListError;

    assert(pnSigner->Data()->pUnauthAttrList);
    if (!ICM_InsertTailBlob( pnSigner->Data()->pUnauthAttrList,
            (Any *)&pmcasuap->blob))
        goto InsertUnauthAttrBlobError;


    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(IndexTooLargeError,CRYPT_E_INVALID_INDEX)
TRACE_ERROR(InitUnauthAttrListError)        // error already set
TRACE_ERROR(InsertUnauthAttrBlobError)      // error already set
dwFlags;
}


//+-------------------------------------------------------------------------
//  Delete an unauthenticated attribute from a SignerInfo of a signed-data or
//  signed-and-enveloped-data message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_ControlDelUnauthAttr(
    IN PCRYPT_MSG_INFO      pcmi,
    IN DWORD                dwFlags,
    IN PCMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA pmcdsuap)
{
    BOOL                    fRet;
    CSignerNode             *pnSigner;
    DWORD                   i;

    for (i=pmcdsuap->dwSignerIndex,
                pnSigner=pcmi->psdi->pSignerList->Head();
            (i>0) && pnSigner;
            i--, pnSigner = pnSigner->Next())
        ;
    if (NULL == pnSigner)
        goto IndexTooLargeError;

    if (!ICM_InitUnauthAttrList(pnSigner))
        goto InitUnauthAttrListError;

    assert(pnSigner->Data()->pUnauthAttrList);
    if (!ICM_DelBlobByIndex(
            pnSigner->Data()->pUnauthAttrList,
            pmcdsuap->dwUnauthAttrIndex))
        goto DelBlobByIndexError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(IndexTooLargeError,CRYPT_E_INVALID_INDEX)
TRACE_ERROR(InitUnauthAttrListError)        // error already set
TRACE_ERROR(DelBlobByIndexError)            // error already set
dwFlags;
}


//+-------------------------------------------------------------------------
//  Perform a special "control" function after the final CryptMsgUpdate of a
//  encoded/decoded cryptographic message.
//
//  The dwCtrlType parameter specifies the type of operation to be performed.
//
//  The pvCtrlPara definition depends on the dwCtrlType value.
//
//  See below for a list of the control operations and their pvCtrlPara
//  type definition.
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgControl(
#else
CryptMsgControl(
#endif
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwFlags,
    IN DWORD dwCtrlType,
    IN void const *pvCtrlPara)
{
    BOOL                fRet;
    PCRYPT_MSG_INFO     pcmi = (PCRYPT_MSG_INFO)hCryptMsg;

    ICM_Lock( pcmi);    // Single thread access to HCRYPTMSG

    // Only support control for decoding
    if (pcmi->fEncoding)
        goto ControlForEncodingNotSupported;

    switch (dwCtrlType) {
    case CMSG_CTRL_VERIFY_SIGNATURE:
        fRet = ICM_ControlVerifySignature(
                        pcmi,
                        dwFlags,
                        (PCERT_INFO)pvCtrlPara);
        break;

#ifdef CMS_PKCS7
    case CMSG_CTRL_VERIFY_SIGNATURE_EX:
        fRet = ICM_ControlVerifySignatureEx(
                        pcmi,
                        dwFlags,
                        (PCMSG_CTRL_VERIFY_SIGNATURE_EX_PARA)pvCtrlPara);
        break;
#endif  // CMS_PKCS7

    case CMSG_CTRL_DECRYPT:
#ifdef CMS_PKCS7
        fRet = ICM_ControlPkcsDecrypt(
#else
        fRet = ICM_ControlDecrypt(
#endif  // CMS_PKCS7
                        pcmi,
                        dwFlags,
                        (PCMSG_CTRL_DECRYPT_PARA) pvCtrlPara);
        break;
    case CMSG_CTRL_VERIFY_HASH:
        fRet = ICM_ControlVerifyDigest(
                        pcmi,
                        dwFlags);
        break;
    case CMSG_CTRL_ADD_SIGNER:
        fRet = ICM_ControlAddSigner(
                        pcmi,
                        dwFlags,
                        (PCMSG_SIGNER_ENCODE_INFO)pvCtrlPara);
        break;
    case CMSG_CTRL_ADD_CMS_SIGNER_INFO:
        fRet = ICM_ControlAddCmsSignerInfo(
                        pcmi,
                        dwFlags,
                        (PCMSG_CMS_SIGNER_INFO)pvCtrlPara);
        break;
    case CMSG_CTRL_DEL_SIGNER:
        fRet = ICM_ControlDelSigner(
                        pcmi,
                        dwFlags,
                        *(PDWORD)pvCtrlPara);
        break;
    case CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR:
        fRet = ICM_ControlAddUnauthAttr(
                        pcmi,
                        dwFlags,
                        (PCMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA)pvCtrlPara);
        break;
    case CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR:
        fRet = ICM_ControlDelUnauthAttr(
                        pcmi,
                        dwFlags,
                        (PCMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA)pvCtrlPara);
        break;
    case CMSG_CTRL_ADD_CERT:
        fRet = ICM_InsertTailBlob(
                        pcmi->psdi->pCertificateList,
                        (Any *)pvCtrlPara);
        break;
    case CMSG_CTRL_DEL_CERT:
        {
            DWORD dwIndex = *(PDWORD)pvCtrlPara;
#ifdef CMS_PKCS7
            if (pcmi->psdi->version >= CMSG_SIGNED_DATA_CMS_VERSION)
                // Advance index past attribute certs.
                ICM_GetTaggedBlobAndAdvanceIndex(
                    pcmi->psdi->pCertificateList,
                    ICM_TAG_SEQ,
                    &dwIndex
                    );
#endif  // CMS_PKCS7
            fRet = ICM_DelBlobByIndex(
                        pcmi->psdi->pCertificateList,
                        dwIndex);
        }
        break;

#ifdef CMS_PKCS7
    case CMSG_CTRL_ADD_ATTR_CERT:
        {
            Any *pAny = (Any *) pvCtrlPara;
            Any AnyAttrCert;
            BOOL fV3;

            fV3 = (pcmi->psdi->version >= CMSG_SIGNED_DATA_CMS_VERSION);
            if (!(fV3 || 0 != strcmp(pszObjIdDataType,
                    pcmi->psdi->pci->pszContentType)))
                goto InvalidMsgTypeToAddAttrCert;
            
            AnyAttrCert.length = pAny->length;
            if (0 == AnyAttrCert.length)
                goto InvalidParamError;
            if (NULL == (AnyAttrCert.value = (unsigned char*) ICM_Alloc(
                    AnyAttrCert.length)))
                goto AllocError;
            memcpy(AnyAttrCert.value, pAny->value, AnyAttrCert.length);
#ifdef OSS_CRYPT_ASN1
            *AnyAttrCert.value = ICM_TAG_CONSTRUCTED_CONTEXT_1;
#else
            *((BYTE *) AnyAttrCert.value) = ICM_TAG_CONSTRUCTED_CONTEXT_1;
#endif  // OSS_CRYPT_ASN1
            fRet = ICM_InsertTailBlob(
                        pcmi->psdi->pCertificateList,
                        &AnyAttrCert);
            if (fRet && !fV3)
                pcmi->psdi->version = CMSG_SIGNED_DATA_CMS_VERSION;
            ICM_Free(AnyAttrCert.value);
        }
        break;
    case CMSG_CTRL_DEL_ATTR_CERT:
        if (pcmi->psdi->version < CMSG_SIGNED_DATA_CMS_VERSION)
            goto NoAttrCerts;
        else {
            DWORD dwIndex = *(PDWORD)pvCtrlPara;

            // Advance index past certs.
            ICM_GetTaggedBlobAndAdvanceIndex(
                pcmi->psdi->pCertificateList,
                ICM_TAG_CONSTRUCTED_CONTEXT_1,
                &dwIndex
                );

            fRet = ICM_DelBlobByIndex(
                        pcmi->psdi->pCertificateList,
                        dwIndex);
        }
        break;
#endif  // CMS_PKCS7

    case CMSG_CTRL_ADD_CRL:
        fRet = ICM_InsertTailBlob(
                        pcmi->psdi->pCrlList,
                        (Any *)pvCtrlPara);
        break;
    case CMSG_CTRL_DEL_CRL:
        fRet = ICM_DelBlobByIndex(
                        pcmi->psdi->pCrlList,
                        *(PDWORD)pvCtrlPara);
        break;

#ifdef CMS_PKCS7
    case CMSG_CTRL_KEY_TRANS_DECRYPT:
        {
            PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA pmcdp =
                (PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA) pvCtrlPara;

            assert(pmcdp->cbSize >= sizeof(*pmcdp));
            if (pmcdp->cbSize < sizeof(*pmcdp))
                goto InvalidArg;

            fRet = ICM_ControlCmsDecrypt(
                    pcmi,
                    dwFlags,
                    pmcdp,
                    pmcdp->hCryptProv,
                    pmcdp->dwRecipientIndex,
                    hImportKeyTransFuncSet,
                    pmcdp->pKeyTrans->KeyEncryptionAlgorithm.pszObjId,
                    (PFN_ICM_IMPORT_CONTENT_ENCRYPT_KEY) ICM_DefaultImportKeyTrans
                    );
        }
        break;
    case CMSG_CTRL_KEY_AGREE_DECRYPT:
        {
            PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA pmcdp =
                (PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA) pvCtrlPara;

            assert(pmcdp->cbSize >= sizeof(*pmcdp));
            if (pmcdp->cbSize < sizeof(*pmcdp))
                goto InvalidArg;

            fRet = ICM_ControlCmsDecrypt(
                    pcmi,
                    dwFlags,
                    pmcdp,
                    pmcdp->hCryptProv,
                    pmcdp->dwRecipientIndex,
                    hImportKeyAgreeFuncSet,
                    pmcdp->pKeyAgree->KeyEncryptionAlgorithm.pszObjId,
                    (PFN_ICM_IMPORT_CONTENT_ENCRYPT_KEY) ICM_DefaultImportKeyAgree
                    );
            if (fRet)
                pcmi->dwDecryptedRecipientEncryptedKeyIndex =
                    pmcdp->dwRecipientEncryptedKeyIndex;
        }
        break;
    case CMSG_CTRL_MAIL_LIST_DECRYPT:
        {
            PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA pmcdp =
                (PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA) pvCtrlPara;

            assert(pmcdp->cbSize >= sizeof(*pmcdp));
            if (pmcdp->cbSize < sizeof(*pmcdp))
                goto InvalidArg;

            fRet = ICM_ControlCmsDecrypt(
                    pcmi,
                    dwFlags,
                    pmcdp,
                    pmcdp->hCryptProv,
                    pmcdp->dwRecipientIndex,
                    hImportMailListFuncSet,
                    pmcdp->pMailList->KeyEncryptionAlgorithm.pszObjId,
                    (PFN_ICM_IMPORT_CONTENT_ENCRYPT_KEY) ICM_DefaultImportMailList
                    );
        }
        break;
#endif  // CMS_PKCS7

    default:
        goto InvalidCtrlType;
    }

CommonReturn:
    ICM_Unlock( pcmi);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(ControlForEncodingNotSupported,E_INVALIDARG)
SET_ERROR(InvalidCtrlType,CRYPT_E_CONTROL_TYPE)
#ifdef CMS_PKCS7
SET_ERROR(InvalidMsgTypeToAddAttrCert,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidParamError,E_INVALIDARG)
TRACE_ERROR(AllocError)
SET_ERROR(NoAttrCerts,CRYPT_E_INVALID_INDEX)
SET_ERROR(InvalidArg,E_INVALIDARG)
#endif  // CMS_PKCS7
}


//+-------------------------------------------------------------------------
//  Copy out a DWORD
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetDWORD(
    IN DWORD dwValue,
    OUT void *pvData,
    IN OUT DWORD *pcbData)
{
    return ICM_CopyOut(
                (PBYTE)&dwValue,
                sizeof(DWORD),
                (PBYTE)pvData,
                pcbData);
}


//+-------------------------------------------------------------------------
//  Get Any
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssAny(
        IN Any          *pany,
        OUT PCRYPT_DATA_BLOB pInfo,
        IN OUT BYTE     **ppbExtra,
        IN OUT LONG     *plRemainExtra)
{
    BOOL fResult = TRUE;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lData;
    BOOL fNULL = FALSE;
    PBYTE pbValue;

    pbValue = (PBYTE) pany->value;
    if ((pany->length == 2) &&
            (pbValue[0] == 0x05) &&
            (pbValue[1] == 0x00)) {
        // Detected NULL encoding. Map to NULL blob.
        fNULL = TRUE;
    }

    lData = fNULL ? 0 : pany->length;
    lAlignExtra = INFO_LEN_ALIGN(lData);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if ((lData > 0) && !fNULL) {
            pInfo->pbData = pbExtra;
            pInfo->cbData = (DWORD) lData;
            memcpy( pbExtra, pany->value, lData);
        } else {
            memset(pInfo, 0, sizeof(*pInfo));
        }
        pbExtra += lAlignExtra;
    }

    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;

    return fResult;
}


//+-------------------------------------------------------------------------
//  Get the data for an Attributes
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetAnyData(
        IN Any *pAny,
        OUT void *pvData,
        IN OUT DWORD *pcbData)
{
    BOOL        fRet;
    LONG        lData;
    LONG        lRemainExtra;
    PBYTE       pbExtra;
    PCRYPT_DATA_BLOB pBlob = (PCRYPT_DATA_BLOB)pvData;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CRYPT_DATA_BLOB));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        pBlob = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)pBlob + lData;
    }
    if (!ICM_GetOssAny( pAny, pBlob, &pbExtra, &lRemainExtra))
        goto GetOssAnyError;
    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssAnyError)         // error already set
}


//+-------------------------------------------------------------------------
//  Get Object Identifier string
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssObjId(
        IN ObjectID *poi,
        OUT LPSTR   *ppszObjId,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    BOOL fRet;
    LONG lRemainExtra = *plRemainExtra;
    BYTE *pbExtra = *ppbExtra;
    LONG lAlignExtra;
    LONG lObjId;

    if (!PkiAsn1FromObjectIdentifier(
            poi->count,
            poi->value,
            NULL,
            (PDWORD)&lObjId))
        goto PkiAsn1FromObjectIdentifierSizeError;
    lAlignExtra = INFO_LEN_ALIGN(lObjId);
    lRemainExtra -= lAlignExtra;
    if (lRemainExtra >= 0) {
        if(lObjId > 0) {
            *ppszObjId = (LPSTR) pbExtra;
            if (!PkiAsn1FromObjectIdentifier(
                    poi->count,
                    poi->value,
                    (LPSTR)pbExtra,
                    (PDWORD)&lObjId))
                goto PkiAsn1FromObjectIdentifierError;
        } else
            *ppszObjId = NULL;
        pbExtra += lAlignExtra;
    }
    fRet = TRUE;

CommonReturn:
    *plRemainExtra = lRemainExtra;
    *ppbExtra = pbExtra;
    return fRet;

ErrorReturn:
    *ppszObjId = NULL;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(PkiAsn1FromObjectIdentifierSizeError,CRYPT_E_OID_FORMAT)
SET_ERROR(PkiAsn1FromObjectIdentifierError,CRYPT_E_OID_FORMAT)
}



//+-------------------------------------------------------------------------
//  Get Oss HugeInteger
//--------------------------------------------------------------------------
void
inline
WINAPI
ICM_GetOssHugeInteger(
    IN HugeIntegerType *pOssHugeInteger,
    OUT PCRYPT_INTEGER_BLOB pHugeInteger,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    PkiAsn1GetHugeInteger(pOssHugeInteger->length, pOssHugeInteger->value, 0,
        pHugeInteger, ppbExtra, plRemainExtra);
}


//+-------------------------------------------------------------------------
//  Get an Attribute
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssAttribute(
        IN Attribute *poatr,
        OUT PCRYPT_ATTRIBUTE patr,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    BOOL        fRet;
    LONG        lData;
    DWORD       i;
    Any         *pAny;
    PCRYPT_ATTR_BLOB  patrbl = NULL;

    if (!ICM_GetOssObjId(&poatr->attributeType, &patr->pszObjId,
            ppbExtra, plRemainExtra))
        goto GetOssObjIdError;

    lData = INFO_LEN_ALIGN( poatr->attributeValue.count * sizeof(CRYPT_ATTR_BLOB));
    *plRemainExtra -= lData;
    if (0 < *plRemainExtra) {
        patr->cValue = poatr->attributeValue.count;
        patr->rgValue = patrbl = (PCRYPT_ATTR_BLOB)*ppbExtra;
        *ppbExtra += lData;
    }
    for (i=poatr->attributeValue.count, pAny=poatr->attributeValue.value;
            i>0;
            i--, pAny++, patrbl++) {
        if (!ICM_GetOssAny(pAny, patrbl, ppbExtra, plRemainExtra))
            goto GetOssAnyError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssObjIdError)   // error already set
TRACE_ERROR(GetOssAnyError)     // error already set
}


//+-------------------------------------------------------------------------
//  Get an CRYPT_ATTRIBUTE
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetATTRIBUTE(
        IN Attribute *poatr,
        OUT void *pvData,
        IN OUT DWORD *pcbData)
{
    BOOL        fRet;
    LONG        lData;
    LONG        lRemainExtra;
    PBYTE       pbExtra;
    PCRYPT_ATTRIBUTE  patr = (PCRYPT_ATTRIBUTE)pvData;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CRYPT_ATTRIBUTE));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        patr = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)patr + lData;
    }
    if (!ICM_GetOssAttribute( poatr, patr, &pbExtra, &lRemainExtra))
        goto GetOssAttributeError;
    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssAttributeError)   // error already set
}


//+-------------------------------------------------------------------------
//  Get an Attributes
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssAttributes(
        IN Attributes *poatrs,
        OUT PCRYPT_ATTRIBUTES patrs,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    BOOL        fRet;
    LONG        lData;
    DWORD       i;
    Attribute   *poatr;
    PCRYPT_ATTRIBUTE  patr;

    lData = INFO_LEN_ALIGN( poatrs->count * sizeof(CRYPT_ATTRIBUTE));
    *plRemainExtra -= lData;
    if (0 < *plRemainExtra) {
        patrs->cAttr = poatrs->count;
        patrs->rgAttr = patr = (PCRYPT_ATTRIBUTE)*ppbExtra;
        *ppbExtra += lData;
    } else {
        patr = NULL;
    }
    for (i=poatrs->count, poatr=poatrs->value;
            i>0;
            i--, poatr++, patr++) {
        if (!ICM_GetOssAttribute( poatr, patr, ppbExtra, plRemainExtra))
            goto GetOssAttributeError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssAttributeError)   // error already set
}


//+-------------------------------------------------------------------------
//  Get from an Attributes in CList form
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetCListAttributes(
        IN CBlobList *pBlobList,
        OUT PCRYPT_ATTRIBUTES patrs,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    LONG                lData;
    CBlobNode           *pBlobNode;
    AttributeNC2        *poatr = NULL;
    PCRYPT_ATTRIBUTE    patr;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    PCRYPT_DATA_BLOB    pDataBlob;

    lData = INFO_LEN_ALIGN( pBlobList->Length() * sizeof(CRYPT_ATTRIBUTE));
    *plRemainExtra -= lData;
    if (0 < *plRemainExtra) {
        patrs->cAttr = pBlobList->Length();
        patrs->rgAttr = patr = (PCRYPT_ATTRIBUTE)*ppbExtra;
        *ppbExtra += lData;
    } else {
        patr = NULL;
    }
    for (pBlobNode=pBlobList->Head();
            pBlobNode;
            pBlobNode=pBlobNode->Next(), patr++) {
        poatr = NULL;
        pDataBlob = pBlobNode->Data();
        if (0 != (Asn1Err = PkiAsn1Decode(
                pDec,
                (void **)&poatr,
                AttributeNC2_PDU,
                pDataBlob->pbData,
                pDataBlob->cbData)))
            goto DecodeAttributeNC2Error;
        if (!ICM_GetOssAttribute(
                (Attribute *)poatr,     // same, except for NOCOPY
                patr,
                ppbExtra,
                plRemainExtra))
            goto GetOssAttributeError;
        PkiAsn1FreeDecoded(pDec, poatr, AttributeNC2_PDU);
        poatr = NULL;
    }

    fRet = TRUE;
CommonReturn:
    PkiAsn1FreeInfo(pDec, AttributeNC2_PDU, poatr);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(DecodeAttributeNC2Error, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(GetOssAttributeError)       // error already set
}


//+-------------------------------------------------------------------------
//  Get the data for an Attributes
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetAttributesData(
        IN Attributes *poatrs,
        OUT void *pvData,
        IN OUT DWORD *pcbData)
{
    BOOL        fRet;
    LONG        lData;
    LONG        lRemainExtra;
    PBYTE       pbExtra;
    PCRYPT_ATTRIBUTES patrs = (PCRYPT_ATTRIBUTES)pvData;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CRYPT_ATTRIBUTES));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        patrs = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)patrs + lData;
    }
    if (!ICM_GetOssAttributes( poatrs, patrs, &pbExtra, &lRemainExtra))
        goto GetOssAttributesError;
    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssAttributesError)      // error already set
}


//+-------------------------------------------------------------------------
//  Get an OSS Algorithm
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssAlgorithm(
        IN AlgorithmIdentifier *pai,
        OUT PCRYPT_ALGORITHM_IDENTIFIER pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    if (!ICM_GetOssObjId(&pai->algorithm, &pInfo->pszObjId,
            ppbExtra, plRemainExtra))
        return FALSE;
    
    if (pai->bit_mask & parameters_present) {
        if (!ICM_GetOssAny(&pai->parameters, &pInfo->Parameters,
                ppbExtra, plRemainExtra))
            return FALSE;
    } else if (*plRemainExtra >= 0) {
        memset(&pInfo->Parameters, 0, sizeof(pInfo->Parameters));
    }
    return TRUE;
}


//+-------------------------------------------------------------------------
//  Get a ContentInfo (internal)
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssContentInfo(
        IN ContentInfo *poci,
        OUT PCONTENT_INFO pInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    if (!ICM_GetOssObjId(&poci->contentType, &pInfo->pszContentType,
            ppbExtra, plRemainExtra))
        return FALSE;
    if (poci->bit_mask & content_present) {
        if (!ICM_GetOssAny(&poci->content, &pInfo->content,
                ppbExtra, plRemainExtra))
            return FALSE;
    } else {
        if (pInfo) {
            pInfo->content.cbData = 0;
            pInfo->content.pbData = 0;
        }
    }
    return TRUE;
}


//+-------------------------------------------------------------------------
//  Get a ContentInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssContentInfoData(
        IN ContentInfo *poci,
        OUT void *pvData,
        IN OUT DWORD *pcbData)
{
    BOOL        fRet;
    LONG        lData;
    LONG        lRemainExtra;
    PBYTE       pbExtra;
    PCONTENT_INFO pci = (PCONTENT_INFO)pvData;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CONTENT_INFO));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        pci = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)pci + lData;
    }
    if (!ICM_GetOssContentInfo( poci, pci, &pbExtra, &lRemainExtra))
        goto GetContentInfoError;
    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetContentInfoError)        // error already set
}


BOOL
WINAPI
ICM_GetOssIssuerAndSerialNumberFromCertId(
        IN CertIdentifier *pOssCertId,
        OUT PCERT_NAME_BLOB pIssuer,
        OUT PCRYPT_INTEGER_BLOB pSerialNumber,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra);

//+-------------------------------------------------------------------------
//  Get an Special Issuer and SerialNumber from a KeyId.
//
//  Converts the KeyId to a special encoded Issuer name having a RDN with
//  the szOID_KEYID_RDN OID and a CERT_RDN_OCTET_STRING value containing
//  the KeyId. The SerialNumber is set to 0.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssIssuerAndSerialNumberFromKeyId(
	    IN SubjectKeyIdentifier *pOssKeyId,
        OUT PCERT_NAME_BLOB pIssuer,
        OUT PCRYPT_INTEGER_BLOB pSerialNumber,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    BOOL fRet;

    CertIdentifier OssCertId;
    ASN1octet_t SerialNumber;
    CERT_RDN_ATTR KeyIdAttr;
    CERT_RDN KeyIdRDN;
    CERT_NAME_INFO IssuerInfo;
    BYTE *pbEncodedIssuer = NULL;
    DWORD cbEncodedIssuer;

    KeyIdAttr.pszObjId = szOID_KEYID_RDN;
    KeyIdAttr.dwValueType = CERT_RDN_OCTET_STRING;
    KeyIdAttr.Value.pbData = pOssKeyId->value;
    KeyIdAttr.Value.cbData = pOssKeyId->length;
    KeyIdRDN.cRDNAttr = 1;
    KeyIdRDN.rgRDNAttr = &KeyIdAttr;
    IssuerInfo.cRDN = 1;
    IssuerInfo.rgRDN = &KeyIdRDN;

    // Encode the special Issuer Name containing the KeyId
    if (!CryptEncodeObjectEx(
            X509_ASN_ENCODING,
            X509_NAME,
            &IssuerInfo,
            CRYPT_ENCODE_ALLOC_FLAG,
            &PkiEncodePara,
            (void *) &pbEncodedIssuer,
            &cbEncodedIssuer
            ))
        goto EncodeError;

    OssCertId.choice = issuerAndSerialNumber_chosen;
    OssCertId.u.issuerAndSerialNumber.serialNumber.length = 1;
    OssCertId.u.issuerAndSerialNumber.serialNumber.value = &SerialNumber;
    SerialNumber = 0;
    OssCertId.u.issuerAndSerialNumber.issuer.length = cbEncodedIssuer;
    OssCertId.u.issuerAndSerialNumber.issuer.value = pbEncodedIssuer;

    fRet = ICM_GetOssIssuerAndSerialNumberFromCertId(
        &OssCertId,
        pIssuer,
        pSerialNumber,
        ppbExtra,
        plRemainExtra
        );

CommonReturn:
    PkiFree(pbEncodedIssuer);
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EncodeError)
}

//+-------------------------------------------------------------------------
//  Get an Issuer and SerialNumber from a CertIdentifier.
//
//  Converts a KEYID choice to a special encoded Issuer name having a RDN with
//  the szOID_KEYID_RDN OID and a CERT_RDN_OCTET_STRING value containing
//  the KeyId. The SerialNumber is set to 0.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssIssuerAndSerialNumberFromCertId(
        IN CertIdentifier *pOssCertId,
        OUT PCERT_NAME_BLOB pIssuer,
        OUT PCRYPT_INTEGER_BLOB pSerialNumber,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    BOOL fRet;

    switch (pOssCertId->choice) {
        case issuerAndSerialNumber_chosen:
            ICM_GetOssHugeInteger(
                &pOssCertId->u.issuerAndSerialNumber.serialNumber,
                pSerialNumber, ppbExtra, plRemainExtra);
            if (!ICM_GetOssAny(&pOssCertId->u.issuerAndSerialNumber.issuer,
                    pIssuer, ppbExtra, plRemainExtra))
                goto GetIssuerError;
            break;
        case subjectKeyIdentifier_chosen:
            if (!ICM_GetOssIssuerAndSerialNumberFromKeyId(
                    &pOssCertId->u.subjectKeyIdentifier,
                    pIssuer, pSerialNumber, ppbExtra, plRemainExtra))
                goto GetKeyIdError;
            break;
        default:
            goto InvalidCertIdChoice;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetIssuerError)
TRACE_ERROR(GetKeyIdError)
SET_ERROR(InvalidCertIdChoice, CRYPT_E_BAD_ENCODE)
}

BOOL
WINAPI
ICM_GetOssIssuerAndSerialNumberForCertInfo(
        IN CertIdentifier *pOssCertId,
        OUT PCERT_INFO pCertInfo,
        IN OUT BYTE **ppbExtra,
        IN OUT LONG *plRemainExtra)
{
    return ICM_GetOssIssuerAndSerialNumberFromCertId(
        pOssCertId,
        &pCertInfo->Issuer,
        &pCertInfo->SerialNumber,
        ppbExtra,
        plRemainExtra
        );
}


//+-------------------------------------------------------------------------
//  Get an CertInfo with an updated IssuerAndSerialNumber
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetCertInfoIssuerAndSerialNumber(
    IN CertIdentifier *pOssCertIdentifier,
    OUT void *pvData,
    IN OUT DWORD *pcbData)
{
    BOOL         fRet;
    LONG         lData;
    PCERT_INFO   pci = (PCERT_INFO)pvData;
    PBYTE        pbExtra;
    LONG         lRemainExtra;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CERT_INFO));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        pci = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)pci + lData;
    }
    if (!ICM_GetOssIssuerAndSerialNumberForCertInfo(pOssCertIdentifier,
            pci, &pbExtra, &lRemainExtra))
        goto GetOssIssuerAndSerialNumberError;
    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssIssuerAndSerialNumberError)   // error already set
}

BOOL
WINAPI
ICM_GetOssCertIdentifier(
    IN CertIdentifier *pOssCertId,
    OUT PCERT_ID pCertId,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    );

BOOL
WINAPI
ICM_GetCertId(
    IN CertIdentifier *pOssCertIdentifier,
    OUT void *pvData,
    IN OUT DWORD *pcbData)
{
    BOOL         fRet;
    LONG         lData;
    PCERT_ID     pid = (PCERT_ID)pvData;
    PBYTE        pbExtra;
    LONG         lRemainExtra;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CERT_ID));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        pid = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)pid + lData;
    }
    if (!ICM_GetOssCertIdentifier(pOssCertIdentifier,
            pid, &pbExtra, &lRemainExtra))
        goto GetOssCertIdentifierError;
    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssCertIdentifierError)   // error already set
}


//+-------------------------------------------------------------------------
//  Copy out an CRYPT_ALGORITHM_IDENTIFIER
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetALGORITHM_IDENTIFIER(
    IN AlgorithmIdentifier *paiOss,
    OUT void *pvData,
    IN OUT DWORD *pcbData)
{
    BOOL                    fRet;
    LONG                    lData;
    PCRYPT_ALGORITHM_IDENTIFIER   pai = (PCRYPT_ALGORITHM_IDENTIFIER)pvData;
    PBYTE                   pbExtra;
    LONG                    lRemainExtra;

    if (NULL == pvData)
        *pcbData = 0;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CRYPT_ALGORITHM_IDENTIFIER));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        pai = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)pai + lData;
    }
    if (!ICM_GetOssAlgorithm( paiOss, pai, &pbExtra, &lRemainExtra))
        goto GetOssAlgorithmError;
    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssAlgorithmError)       // error already set
}


//+-------------------------------------------------------------------------
//  Get the digest in a DIGESTED message.
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetDigestDataParam(
    IN PCRYPT_MSG_INFO pcmi,
    OUT void *pvData,
    IN OUT DWORD *pcbData)
{
    BOOL            fRet;
    DigestedData    *pdd;

    if (CMSG_HASHED != pcmi->dwMsgType)
        goto InvalidMsgType;
    pdd = (DigestedData *)pcmi->pvMsg;
    fRet = ICM_CopyOut(
                (PBYTE)pdd->digest.value,
                (DWORD)pdd->digest.length,
                (PBYTE)pvData,
                pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
}

#ifdef CMS_PKCS7

HCRYPTHASH
WINAPI
ICM_GetEncodedSignerHash(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwSignerIndex
    )
{
    HCRYPTHASH hHash = NULL;
    SignerInfo *psi;
    PSIGNER_ENCODE_DATA_INFO pSignerEncodeDataInfo;
    CHashNode *pnHash;
    PICM_HASH_INFO pHashInfo;

    if (dwSignerIndex >= ((SignedData *)pcmi->pvMsg)->signerInfos.count)
        goto IndexTooBig;
    psi = ((SignedData *)pcmi->pvMsg)->signerInfos.value + dwSignerIndex;
    pSignerEncodeDataInfo = pcmi->rgSignerEncodeDataInfo + dwSignerIndex;
    pnHash = pSignerEncodeDataInfo->pHashNode;
    pHashInfo = pnHash->Data();

    if (psi->bit_mask & authenticatedAttributes_present) {
        if (!ICM_GetAttrsHash(
                pHashInfo->dwAlgoCAPI,
                pSignerEncodeDataInfo->hCryptProv,
                &psi->authenticatedAttributes,
                &hHash))
            goto GetAuthAttrsHashError;
    } else {
        if (!ICM_DupListHash( pnHash, pSignerEncodeDataInfo->hCryptProv,
                &hHash))
            goto DupListHashError;
    }

CommonReturn:
    return hHash;

ErrorReturn:
    hHash = NULL;
    goto CommonReturn;

SET_ERROR(IndexTooBig,CRYPT_E_INVALID_INDEX)
TRACE_ERROR(GetAuthAttrsHashError)      // error already set
TRACE_ERROR(DupListHashError)           // error already set
}


HCRYPTHASH
WINAPI
ICM_GetDecodedSignerHash(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwSignerIndex
    )
{
    HCRYPTHASH              hHash = NULL;
    DWORD                   dwError = ERROR_SUCCESS;
    SignerInfoWithBlobs     *psib = NULL;
    CSignerNode             *pSignerNode = NULL;
    HCRYPTPROV              hCryptProv;         // doen't need to be released
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    CRYPT_DATA_BLOB         DataBlob;
    CHashNode               *pnHash;
    PICM_HASH_INFO          pHashInfo;

    if (!ICM_FindSignerInfo(pcmi, dwSignerIndex, (PVOID *)&pSignerNode))
        goto FindSignerInfoError;

    DataBlob = pSignerNode->Data()->blob;
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&psib,
            SignerInfoWithBlobs_PDU,
            DataBlob.pbData,
            DataBlob.cbData)))
        goto DecodeSignerInfoWithBlobsError;

    if (!ICM_FindHashNodeFromEncodedAlgo(
            pcmi->pHashList,
            (PCRYPT_DATA_BLOB)&psib->digestAlgorithm,
            &pnHash))
        goto GetHashNodeFromEncodedAlgoError;
    pHashInfo = pnHash->Data();

    if (pcmi->fDefaultCryptProv)
        hCryptProv = 0;
    else
        hCryptProv = pcmi->hCryptProv;
    if (0 == hCryptProv) {
        hCryptProv = I_CryptGetDefaultCryptProv(0);
        if (0 == hCryptProv)
            goto GetDefaultCryptProvError;
    }

    if (psib->bit_mask & authAttributes_present) {
        if (!ICM_GetAttrsHash(
                pHashInfo->dwAlgoCAPI,
                hCryptProv,
                (Attributes *)&psib->authAttributes,    // same, except for NOCOPY
                &hHash))
            goto GetAuthAttrsHashError;
    } else {
        if (!ICM_DupListHash( pnHash, hCryptProv, &hHash))
            goto DupListHashError;
    }

CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, psib);
    ICM_SetLastError(dwError);
    return hHash;

ErrorReturn:
    dwError = GetLastError();
    hHash = NULL;
    goto CommonReturn;

TRACE_ERROR(FindSignerInfoError)                // error already set
SET_ERROR_VAR(DecodeSignerInfoWithBlobsError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(GetHashNodeFromEncodedAlgoError)    // error already set
TRACE_ERROR(GetDefaultCryptProvError)           // error already set
TRACE_ERROR(GetAuthAttrsHashError)              // error already set
TRACE_ERROR(DupListHashError)                   // error already set
}

#endif  // CMS_PKCS7

//+-------------------------------------------------------------------------
//  Get the digest of the content in a DIGESTED message or for one of
//  the signers in a SIGNED message
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetComputedDigestParam(
    IN PCRYPT_MSG_INFO pcmi,
    IN DWORD dwIndex,
    OUT void *pvData,
    IN OUT DWORD *pcbData)
{
    BOOL                fRet;
    DWORD               dwError = ERROR_SUCCESS;
    HCRYPTHASH          hHash = NULL;
    PBYTE               pbAllocHash = NULL;
    DWORD               cbHash;
    PBYTE               pbHash;

    switch (pcmi->dwMsgType) {
    case CMSG_HASHED:
        if (!ICM_GetListHashValue(
                pcmi->pHashList->Head(),
                &cbHash,
                &pbHash))
            goto GetHashValueError;
        break;
#ifdef CMS_PKCS7
    case CMSG_SIGNED:
        if (pcmi->fEncoding)
            hHash = ICM_GetEncodedSignerHash(pcmi, dwIndex);
        else
            hHash = ICM_GetDecodedSignerHash(pcmi, dwIndex);
        if (NULL == hHash)
            goto GetSignerHashError;

        if (!CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                NULL,
                &cbHash,
                0))                     // dwFlags
            goto GetHashParamSizeError;
        if (NULL == (pbAllocHash = (PBYTE)ICM_AllocA(cbHash)))
            goto AllocHashParamError;
        pbHash = pbAllocHash;
        if (!CryptGetHashParam(
                hHash,
                HP_HASHVAL,
                pbHash,
                &cbHash,
                0))                     // dwFlags
            goto GetHashParamError;
        break;
#endif  // CMS_PKCS7
    default:
        goto InvalidMsgType;
    }

    fRet = ICM_CopyOut(
                pbHash,
                cbHash,
                (PBYTE)pvData,
                pcbData);
    if (!fRet)
        dwError = GetLastError();

CommonReturn:
    if (hHash)
        CryptDestroyHash(hHash);
    ICM_FreeA(pbAllocHash);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
TRACE_ERROR(GetHashValueError)
TRACE_ERROR(GetSignerHashError)
TRACE_ERROR(GetHashParamSizeError)
TRACE_ERROR(AllocHashParamError)
TRACE_ERROR(GetHashParamError)
}


//+-------------------------------------------------------------------------
//  Find the SignerInfo by index, if the message type permits and if the
//  index value is in range.
//
//  Returns:    FALSE iff fails
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_FindSignerInfo(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwIndex,
    OUT PVOID           *ppv)
{
    BOOL        fRet;
    PVOID       pv;
    SignerInfo  *psi = NULL;
    CSignerNode *pSignerNode = NULL;
    DWORD       i;

    if (pcmi->fEncoding) {

        switch (pcmi->dwMsgType) {
        case CMSG_SIGNED:
            if (dwIndex >= ((SignedData *)pcmi->pvMsg)->signerInfos.count)
                goto IndexTooBig;
            psi = ((SignedData *)pcmi->pvMsg)->signerInfos.value + dwIndex;
            break;
        case CMSG_SIGNED_AND_ENVELOPED:
            goto MessageTypeNotSupportedYet;
        default:
            goto InvalidMsgType;
        }

        pv = psi;

    } else {

        switch (pcmi->dwMsgType) {
        case CMSG_SIGNED:
            if (NULL == pcmi->psdi)
                goto InvalidSignedMessageError;
            for (i=dwIndex, pSignerNode=pcmi->psdi->pSignerList->Head();
                    (i>0) && pSignerNode;
                    i--, pSignerNode=pSignerNode->Next())
                ;
            if (NULL == pSignerNode)
                goto IndexTooBig;
            break;
        case CMSG_SIGNED_AND_ENVELOPED:
            goto MessageTypeNotSupportedYet;
        default:
            goto InvalidMsgType;
        }

        pv = pSignerNode;
    }

    fRet = TRUE;
CommonReturn:
    *ppv = pv;
    return fRet;

ErrorReturn:
    pv = NULL;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidSignedMessageError, ERROR_INVALID_DATA)
SET_ERROR(IndexTooBig,CRYPT_E_INVALID_INDEX)
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
}


//+-------------------------------------------------------------------------
//  Countersign an already-existing signature, output an encoded attribute
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgCountersignEncoded(
#else
CryptMsgCountersignEncoded(
#endif
    IN DWORD                    dwEncodingType,
    IN PBYTE                    pbSignerInfo,
    IN DWORD                    cbSignerInfo,
    IN DWORD                    cCountersigners,
    IN PCMSG_SIGNER_ENCODE_INFO rgCountersigners,
    OUT PBYTE                   pbCountersignatureAttribute,
    IN OUT PDWORD               pcbCountersignatureAttribute)
{
    DWORD                       dwError = ERROR_SUCCESS;
    BOOL                        fRet;
    HCRYPTMSG                   hCryptMsgCountersign = NULL;
    CMSG_SIGNED_ENCODE_INFO     EncodeInfo;     ZEROSTRUCT(EncodeInfo);
    EncodeInfo.cbSize = sizeof(EncodeInfo);
    CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA   UnauthAttrPara; ZEROSTRUCT(UnauthAttrPara);
    UnauthAttrPara.cbSize = sizeof(UnauthAttrPara);
    Attribute                   oatrCountersignature;   ZEROSTRUCT(oatrCountersignature);
    ASN1error_e                 Asn1Err;
    ASN1decoding_t              pDec = ICM_GetDecoder();
    ASN1encoding_t              pEnc = ICM_GetEncoder();
    PBYTE                       pbEncoded = NULL;
    DWORD                       cbEncoded;
    SignerInfoWithBlobs         *posib = NULL;
    DWORD                       i;
    Any                         *pAny;
    DWORD                       dwFlags;

    if (GET_CMSG_ENCODING_TYPE(dwEncodingType) != PKCS_7_ASN_ENCODING)
        goto InvalidEncodingTypeError;

    // crack the SignerInfo being countersigned
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posib,
            SignerInfoWithBlobs_PDU,
            pbSignerInfo,
            cbSignerInfo)))
        goto DecodeSignerInfoError;

    // create a new message
    EncodeInfo.cSigners  = cCountersigners;
    EncodeInfo.rgSigners = rgCountersigners;
    dwFlags = CMSG_AUTHENTICATED_ATTRIBUTES_FLAG;
    if (NULL == pbCountersignatureAttribute ||
            0 == *pcbCountersignatureAttribute)
        dwFlags |= CMSG_MAX_LENGTH_FLAG;
    if (NULL == (hCryptMsgCountersign = CryptMsgOpenToEncode(
            PKCS_7_ASN_ENCODING,
            dwFlags,
            CMSG_SIGNED,
            &EncodeInfo,
            NULL,                       // pszInnerContentObjID
            NULL)))                     // pStreamInfo
        goto OpenToEncodeError;

    // feed encrypted digest into the new message
    if (!CryptMsgUpdate(
            hCryptMsgCountersign,
            posib->encryptedDigest.value,
            posib->encryptedDigest.length,
            TRUE))                      // fFinal
        goto UpdateError;

    oatrCountersignature.attributeType.count = SIZE_OSS_OID;
    if (!PkiAsn1ToObjectIdentifier(
            szOID_RSA_counterSign,
            &oatrCountersignature.attributeType.count,
            oatrCountersignature.attributeType.value))
        goto PkiAsn1ToObjectIdentifierError;
    oatrCountersignature.attributeValue.count = cCountersigners;
    if (NULL == (oatrCountersignature.attributeValue.value = (Any *)ICM_AllocA(
            cCountersigners * sizeof(Any))))
        goto AllocCountersignersError;

    // extract encoded SignerInfo's, and store
    for (i=0, pAny=oatrCountersignature.attributeValue.value;
            i<cCountersigners;
            i++, pAny++) {
        cbSignerInfo = 0;
        CryptMsgGetParam(
                hCryptMsgCountersign,
                CMSG_ENCODED_SIGNER,
                i,
                NULL,
                &cbSignerInfo);
        if (cbSignerInfo == 0)
            goto GetSignerInfoSizeError;
        if (NULL == (pbSignerInfo = (PBYTE)ICM_AllocA( cbSignerInfo)))
            goto AllocSignerInfoError;
        if (!CryptMsgGetParam(
                hCryptMsgCountersign,
                CMSG_ENCODED_SIGNER,
                i,
                pbSignerInfo,
                &cbSignerInfo))
            goto GetSignerInfoError;
        pAny->length = cbSignerInfo;
        pAny->value  = pbSignerInfo;
    }

    // encode the Countersignature attribute
    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            &oatrCountersignature,
            AttributeNC2_PDU,
            &pbEncoded,
            &cbEncoded)))
        goto Asn1EncodeAttributeError;

    // copy out the Countersignature attribute
    fRet = ICM_CopyOut(
                    pbEncoded,
                    cbEncoded,
                    pbCountersignatureAttribute,
                    pcbCountersignatureAttribute);
    if (!fRet)
        dwError = GetLastError();

CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, posib);
    CryptMsgClose( hCryptMsgCountersign);
    if (oatrCountersignature.attributeValue.value) {
        for (i=cCountersigners, pAny=oatrCountersignature.attributeValue.value;
                i>0;
                i--, pAny++)
            ICM_FreeA( pAny->value);
        ICM_FreeA( oatrCountersignature.attributeValue.value);
    }
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidEncodingTypeError,E_INVALIDARG)
SET_ERROR_VAR(DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(PkiAsn1ToObjectIdentifierError,CRYPT_E_OID_FORMAT)
SET_ERROR_VAR(Asn1EncodeAttributeError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(OpenToEncodeError)                  // error already set
TRACE_ERROR(UpdateError)                        // error already set
TRACE_ERROR(AllocCountersignersError)           // error already set
TRACE_ERROR(GetSignerInfoSizeError)             // error already set
TRACE_ERROR(AllocSignerInfoError)               // error already set
TRACE_ERROR(GetSignerInfoError)                 // error already set
}


//+-------------------------------------------------------------------------
//  Countersign an already-existing signature in a message
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgCountersign(
#else
CryptMsgCountersign(
#endif
    IN OUT HCRYPTMSG            hCryptMsg,
    IN DWORD                    dwIndex,
    IN DWORD                    cCountersigners,
    IN PCMSG_SIGNER_ENCODE_INFO rgCountersigners)
{
    DWORD                       dwError = ERROR_SUCCESS;
    BOOL                        fRet;
    PBYTE                       pbCountersignatureAttribute = NULL;
    DWORD                       cbCountersignatureAttribute;
    PBYTE                       pbSignerInfo = NULL;
    DWORD                       cbSignerInfo;
    CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA   UnauthAttrPara; ZEROSTRUCT(UnauthAttrPara);
    UnauthAttrPara.cbSize = sizeof(UnauthAttrPara);

    if (((PCRYPT_MSG_INFO)hCryptMsg)->fEncoding)
        goto EncodingCountersignNotSupportedError;

    // extract encoded SignerInfo being countersigned from the message
    cbSignerInfo = 0;
    CryptMsgGetParam(
            hCryptMsg,
            CMSG_ENCODED_SIGNER,
            dwIndex,
            NULL,
            &cbSignerInfo);
    if (cbSignerInfo == 0)
        goto GetEncodedSignerSizeError;
    if (NULL == (pbSignerInfo = (PBYTE)ICM_AllocA( cbSignerInfo)))
        goto AllocEncodedSignerError;
    if (!CryptMsgGetParam(
            hCryptMsg,
            CMSG_ENCODED_SIGNER,
            dwIndex,
            pbSignerInfo,
            &cbSignerInfo))
        goto GetEncodedSignerError;

    // create the countersignature blob
    cbCountersignatureAttribute = 0;
    CryptMsgCountersignEncoded(
            PKCS_7_ASN_ENCODING,
            pbSignerInfo,
            cbSignerInfo,
            cCountersigners,
            rgCountersigners,
            NULL,
            &cbCountersignatureAttribute);
    if (cbCountersignatureAttribute == 0)
        goto GetCountersignatureAttributeSizeError;
    if (NULL == (pbCountersignatureAttribute = (PBYTE)ICM_AllocA( cbCountersignatureAttribute)))
        goto AllocCountersignatureAttributeError;
    if (!CryptMsgCountersignEncoded(
            PKCS_7_ASN_ENCODING,
            pbSignerInfo,
            cbSignerInfo,
            cCountersigners,
            rgCountersigners,
            pbCountersignatureAttribute,
            &cbCountersignatureAttribute))
        goto GetCountersignatureAttributeError;

    // add encoded Countersignature attribute to unauth attrs
    UnauthAttrPara.dwSignerIndex = dwIndex;
    UnauthAttrPara.blob.cbData = cbCountersignatureAttribute;
    UnauthAttrPara.blob.pbData = pbCountersignatureAttribute;
    if (!CryptMsgControl(
            hCryptMsg,
            0,                          // dwFlags
            CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR,
            &UnauthAttrPara))
        goto AddUnauthAttrError;

    fRet = TRUE;
CommonReturn:
    ICM_FreeA( pbSignerInfo);
    ICM_FreeA( pbCountersignatureAttribute);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(EncodingCountersignNotSupportedError)   // error already set
TRACE_ERROR(GetEncodedSignerSizeError)              // error already set
TRACE_ERROR(AllocEncodedSignerError)                // error already set
TRACE_ERROR(GetEncodedSignerError)                  // error already set
TRACE_ERROR(GetCountersignatureAttributeSizeError)  // error already set
TRACE_ERROR(AllocCountersignatureAttributeError)    // error already set
TRACE_ERROR(GetCountersignatureAttributeError)      // error already set
TRACE_ERROR(AddUnauthAttrError)                     // error already set
}

#ifdef CMS_PKCS7

//+-------------------------------------------------------------------------
//  Verify a countersignature, at the SignerInfo level.
//  ie. verify that pbSignerInfoCountersignature contains the encrypted
//  hash of the encryptedDigest field of pbSignerInfo.
//
//  hCryptProv is used to hash the encryptedDigest field of pbSignerInfo.
//
//  The signer can be a CERT_PUBLIC_KEY_INFO, certificate context or a
//  chain context. 
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgVerifyCountersignatureEncodedEx(
#else
CryptMsgVerifyCountersignatureEncodedEx(
#endif
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwEncodingType,
    IN PBYTE        pbSignerInfo,
    IN DWORD        cbSignerInfo,
    IN PBYTE        pbSignerInfoCountersignature,
    IN DWORD        cbSignerInfoCountersignature,
    IN DWORD        dwSignerType,
    IN void         *pvSigner,
    IN DWORD        dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    SignerInfoWithBlobs     *posib = NULL;
    SignerInfoWithBlobs     *posibCS = NULL;
    Any                     anyValue;
    DWORD                   cbMessageDigest;
    PBYTE                   pbMessageDigest;
    DWORD                   dwDigestAlgoCAPI;
    DWORD                   dwPubKeyAlgId;
    DWORD                   dwPubKeyFlags;
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    HCRYPTKEY               hPubKey = NULL;
    HCRYPTHASH              hHashRaw = NULL;
    HCRYPTHASH              hHashAttr = NULL;
    PBYTE                   pbHash = NULL;
    DWORD                   cbHash;

    if (GET_CMSG_ENCODING_TYPE(dwEncodingType) != PKCS_7_ASN_ENCODING)
        goto InvalidEncodingTypeError;

    // crack the SignerInfo being countersigned
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posib,
            SignerInfoWithBlobs_PDU,
            pbSignerInfo,
            cbSignerInfo)))
        goto DecodeSignerInfoError;

    // crack the SignerInfo doing the countersigning
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posibCS,
            SignerInfoWithBlobs_PDU,
            pbSignerInfoCountersignature,
            cbSignerInfoCountersignature)))
        goto DecodeSignerInfoCSError;

    if (!ICM_GetVerifySignatureStuff(
            dwSignerType,
            pvSigner,
            &hCryptProv,
            &hPubKey,
            &dwPubKeyAlgId,
            &dwPubKeyFlags)) goto GetSignatureStuffError;

    // hash the encrypted digest
    if (!ICM_GetCapiFromAlgidBlob(
            (PCRYPT_DATA_BLOB)&posibCS->digestAlgorithm,
            &dwDigestAlgoCAPI))
        goto GetCapiFromAlgidBlobError;
    if (!CryptCreateHash(
            hCryptProv,
            dwDigestAlgoCAPI,
            NULL,               // hKey - optional for MAC
            0,                  // dwFlags
            &hHashRaw))
        goto CreateHashError;
    if (!ICM_UpdateDigest(
            hHashRaw,
            posib->encryptedDigest.value,
            posib->encryptedDigest.length))
        goto HashDataError;

    if (0 == (posibCS->bit_mask & authAttributes_present))
        goto CountersignerAuthAttributesMissingError;

    // check that the message digest attr matches the hashed encrypted digest
    if (!CryptGetHashParam(
            hHashRaw,
            HP_HASHVAL,
            NULL,
            &cbHash,
            0))                     // dwFlags
        goto GetHashParamSizeError;
    if (NULL == (pbHash = (PBYTE)ICM_AllocA( cbHash)))
        goto AllocHashParamError;
    if (!CryptGetHashParam(
            hHashRaw,
            HP_HASHVAL,
            pbHash,
            &cbHash,
            0))                     // dwFlags
        goto GetHashParamError;
    // find the message digest attr value
    if (!ICM_GetAttrValue(
            (Attributes *)&posibCS->authAttributes, // same, except for NOCOPY
            &oidMessageDigest,
            &anyValue))
        goto FindAttrError;
    // find the message digest octets
    if (!Asn1UtilExtractContent(
#ifdef OSS_CRYPT_ASN1
            anyValue.value,
#else
            (const BYTE *) anyValue.value,
#endif  // OSS_CRYPT_ASN1
            anyValue.length,
            &cbMessageDigest,
            (const BYTE **)&pbMessageDigest))
        goto ExtractContentError;
    // hash sizes equal?
    if (cbHash != cbMessageDigest)
        goto HashCompareSizeError;
    // hash octets equal?
    if (memcmp( pbMessageDigest, pbHash, cbHash))
        goto HashCompareValueError;
    // Now that we have verified the message digest octets,
    // get the hash of the authenticated attributes.
    if (!ICM_GetAttrsHash(
            dwDigestAlgoCAPI,
            hCryptProv,
            (Attributes *)&posibCS->authAttributes, // same, except for NOCOPY
            &hHashAttr))
        goto GetAuthAttrsHashError;

    // verify the hash, signature, and public key are consistent
    if (!ICM_VerifySignature(
            hHashAttr,
            hPubKey,
            dwPubKeyAlgId,
            dwPubKeyFlags,
            posibCS->encryptedDigest.value,
            posibCS->encryptedDigest.length))
        goto VerifySignatureError;

    fRet = TRUE;

CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, posib);
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, posibCS);
    if (hHashRaw)
        CryptDestroyHash( hHashRaw);
    if (hHashAttr)
        CryptDestroyHash( hHashAttr);
    if (hPubKey)
        CryptDestroyKey( hPubKey);
    ICM_FreeA( pbHash);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidEncodingTypeError,E_INVALIDARG)
SET_ERROR_VAR(DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(DecodeSignerInfoCSError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(CountersignerAuthAttributesMissingError,CRYPT_E_AUTH_ATTR_MISSING)
SET_ERROR(FindAttrError,CRYPT_E_AUTH_ATTR_MISSING)
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
SET_ERROR(HashCompareSizeError,CRYPT_E_HASH_VALUE)
SET_ERROR(HashCompareValueError,CRYPT_E_HASH_VALUE)
TRACE_ERROR(GetCapiFromAlgidBlobError)      // error already set
TRACE_ERROR(CreateHashError)                // error already set
TRACE_ERROR(HashDataError)                  // error already set
TRACE_ERROR(GetHashParamSizeError)          // error already set
TRACE_ERROR(AllocHashParamError)            // error already set
TRACE_ERROR(GetHashParamError)              // error already set
TRACE_ERROR(GetAuthAttrsHashError)          // error already set
TRACE_ERROR(GetSignatureStuffError)         // error already set
TRACE_ERROR(VerifySignatureError)           // error already set
}

//+-------------------------------------------------------------------------
//  Verify a countersignature, at the SignerInfo level
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptMsgVerifyCountersignatureEncoded(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwEncodingType,
    IN PBYTE        pbSignerInfo,
    IN DWORD        cbSignerInfo,
    IN PBYTE        pbSignerInfoCountersignature,
    IN DWORD        cbSignerInfoCountersignature,
    IN PCERT_INFO   pciCountersigner)
{
    return CryptMsgVerifyCountersignatureEncodedEx(
        hCryptProv,
        dwEncodingType,
        pbSignerInfo,
        cbSignerInfo,
        pbSignerInfoCountersignature,
        cbSignerInfoCountersignature,
        CMSG_VERIFY_SIGNER_PUBKEY,
        (void *) &pciCountersigner->SubjectPublicKeyInfo,
        0,                                                  // dwFlags
        NULL                                                // pvReserved
        );
}


#else


//+-------------------------------------------------------------------------
//  Verify a countersignature, at the SignerInfo level
//--------------------------------------------------------------------------
BOOL
WINAPI
CryptMsgVerifyCountersignatureEncoded(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwEncodingType,
    IN PBYTE        pbSignerInfo,
    IN DWORD        cbSignerInfo,
    IN PBYTE        pbSignerInfoCountersignature,
    IN DWORD        cbSignerInfoCountersignature,
    IN PCERT_INFO   pciCountersigner)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    SignerInfoWithBlobs     *posib = NULL;
    SignerInfoWithBlobs     *posibCS = NULL;
    Any                     anyValue;
    DWORD                   cbMessageDigest;
    PBYTE                   pbMessageDigest;
    DWORD                   dwDigestAlgoCAPI;
    DWORD                   dwPubKeyAlgId;
    DWORD                   dwPubKeyFlags;
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    IssuerAndSerialNumber   *pisn = NULL;
    HCRYPTKEY               hPubKey = NULL;
    HCRYPTHASH              hHashRaw = NULL;
    HCRYPTHASH              hHashAttr = NULL;
    PBYTE                   pbHash = NULL;
    DWORD                   cbHash;

    if (GET_CMSG_ENCODING_TYPE(dwEncodingType) != PKCS_7_ASN_ENCODING)
        goto InvalidEncodingTypeError;

    // crack the SignerInfo being countersigned
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posib,
            SignerInfoWithBlobs_PDU,
            pbSignerInfo,
            cbSignerInfo)))
        goto DecodeSignerInfoError;

    // crack the SignerInfo doing the countersigning
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posibCS,
            SignerInfoWithBlobs_PDU,
            pbSignerInfoCountersignature,
            cbSignerInfoCountersignature)))
        goto DecodeSignerInfoCSError;

    // verify that the countersignature SignerInfo and the cert info are consistent
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&pisn,
            IssuerAndSerialNumber_PDU,
            (BYTE *) posibCS->issuerAndSerialNumber.value,
            posibCS->issuerAndSerialNumber.length)))
        goto DecodeIssuerAndSerialNumberError;
    if (pisn->issuer.length != pciCountersigner->Issuer.cbData)
        goto IssuerSizeMismatchError;
    if (0 != memcmp(
            pciCountersigner->Issuer.pbData,
            pisn->issuer.value,
            pciCountersigner->Issuer.cbData))
        goto IssuerValueMismatchError;
    if (pisn->serialNumber.length != pciCountersigner->SerialNumber.cbData)
        goto SerialNumberSizeMismatchError;
    if (ICM_ReverseCompare(
            pisn->serialNumber.value,
            pciCountersigner->SerialNumber.pbData,
            pciCountersigner->SerialNumber.cbData))
        goto SerialNumberValueMismatchError;

    if (!ICM_GetVerifySignatureStuff(
            pciCountersigner,
            &hCryptProv,
            &hPubKey,
            &dwPubKeyAlgId,
            &dwPubKeyFlags)) goto GetSignatureStuffError;

    // hash the encrypted digest
    if (!ICM_GetCapiFromAlgidBlob(
            (PCRYPT_DATA_BLOB)&posibCS->digestAlgorithm,
            &dwDigestAlgoCAPI))
        goto GetCapiFromAlgidBlobError;
    if (!CryptCreateHash(
            hCryptProv,
            dwDigestAlgoCAPI,
            NULL,               // hKey - optional for MAC
            0,                  // dwFlags
            &hHashRaw))
        goto CreateHashError;
    if (!ICM_UpdateDigest(
            hHashRaw,
            posib->encryptedDigest.value,
            posib->encryptedDigest.length))
        goto HashDataError;

    if (0 == (posibCS->bit_mask & authAttributes_present))
        goto CountersignerAuthAttributesMissingError;

    // check that the message digest attr matches the hashed encrypted digest
    if (!CryptGetHashParam(
            hHashRaw,
            HP_HASHVAL,
            NULL,
            &cbHash,
            0))                     // dwFlags
        goto GetHashParamSizeError;
    if (NULL == (pbHash = (PBYTE)ICM_AllocA( cbHash)))
        goto AllocHashParamError;
    if (!CryptGetHashParam(
            hHashRaw,
            HP_HASHVAL,
            pbHash,
            &cbHash,
            0))                     // dwFlags
        goto GetHashParamError;
    // find the message digest attr value
    if (!ICM_GetAttrValue(
            (Attributes *)&posibCS->authAttributes, // same, except for NOCOPY
            &oidMessageDigest,
            &anyValue))
        goto FindAttrError;
    // find the message digest octets
    if (!Asn1UtilExtractContent(
            (BYTE *) anyValue.value,
            anyValue.length,
            &cbMessageDigest,
            (const BYTE **)&pbMessageDigest))
        goto ExtractContentError;
    // hash sizes equal?
    if (cbHash != cbMessageDigest)
        goto HashCompareSizeError;
    // hash octets equal?
    if (memcmp( pbMessageDigest, pbHash, cbHash))
        goto HashCompareValueError;
    // Now that we have verified the message digest octets,
    // get the hash of the authenticated attributes.
    if (!ICM_GetAttrsHash(
            dwDigestAlgoCAPI,
            hCryptProv,
            (Attributes *)&posibCS->authAttributes, // same, except for NOCOPY
            &hHashAttr))
        goto GetAuthAttrsHashError;

    // verify the hash, signature, and public key are consistent
    if (!ICM_VerifySignature(
            hHashAttr,
            hPubKey,
            dwPubKeyAlgId,
            dwPubKeyFlags,
            posibCS->encryptedDigest.value,
            posibCS->encryptedDigest.length))
        goto VerifySignatureError;

    fRet = TRUE;

CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, posib);
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, posibCS);
    PkiAsn1FreeInfo(pDec, IssuerAndSerialNumber_PDU, pisn);
    if (hHashRaw)
        CryptDestroyHash( hHashRaw);
    if (hHashAttr)
        CryptDestroyHash( hHashAttr);
    if (hPubKey)
        CryptDestroyKey( hPubKey);
    ICM_FreeA( pbHash);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidEncodingTypeError,E_INVALIDARG)
SET_ERROR_VAR(DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(DecodeSignerInfoCSError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(DecodeIssuerAndSerialNumberError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(IssuerSizeMismatchError,CRYPT_E_ISSUER_SERIALNUMBER)
SET_ERROR(IssuerValueMismatchError,CRYPT_E_ISSUER_SERIALNUMBER)
SET_ERROR(SerialNumberSizeMismatchError,CRYPT_E_ISSUER_SERIALNUMBER)
SET_ERROR(SerialNumberValueMismatchError,CRYPT_E_ISSUER_SERIALNUMBER)
SET_ERROR(CountersignerAuthAttributesMissingError,CRYPT_E_AUTH_ATTR_MISSING)
SET_ERROR(FindAttrError,CRYPT_E_AUTH_ATTR_MISSING)
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
SET_ERROR(HashCompareSizeError,CRYPT_E_HASH_VALUE)
SET_ERROR(HashCompareValueError,CRYPT_E_HASH_VALUE)
TRACE_ERROR(GetCapiFromAlgidBlobError)      // error already set
TRACE_ERROR(CreateHashError)                // error already set
TRACE_ERROR(HashDataError)                  // error already set
TRACE_ERROR(GetHashParamSizeError)          // error already set
TRACE_ERROR(AllocHashParamError)            // error already set
TRACE_ERROR(GetHashParamError)              // error already set
TRACE_ERROR(GetAuthAttrsHashError)          // error already set
TRACE_ERROR(GetSignatureStuffError)         // error already set
TRACE_ERROR(VerifySignatureError)           // error already set
}
#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Set an OSS Any
//--------------------------------------------------------------------------
void
WINAPI
ICM_SetOssAny(
        IN PCRYPT_OBJID_BLOB pInfo,
        OUT OpenType *pOss
        )
{
    memset(pOss, 0, sizeof(*pOss));
    pOss->encoded = pInfo->pbData;
    pOss->length = pInfo->cbData;
}


//+-------------------------------------------------------------------------
//  Encode a CMS SignerInfo
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
ICM_CmsSignerInfoEncode(
    IN DWORD                    dwEncodingType,
    IN LPCSTR                   lpszStructType,
    IN PCMSG_CMS_SIGNER_INFO    pInfo,
    OUT PBYTE                   pbEncoded,
    IN OUT PDWORD               pcbEncoded)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    SignerInfo          osi;        ZEROSTRUCT(osi);
    PCMSG_CMS_SIGNER_INFO psi = pInfo;
    DWORD               i;
    Attribute           *poatrAuth = NULL;
    Attribute           *poatrUnauth = NULL;
    Attribute           *poatr;
    PCRYPT_ATTRIBUTE    patr;

    if (GET_CMSG_ENCODING_TYPE(dwEncodingType) != PKCS_7_ASN_ENCODING)
        goto InvalidEncodingTypeError;

    // version
    osi.version = psi->dwVersion;

    // sid
    if (!ICM_SetOssCertIdentifier(
            &psi->SignerId,
            &osi.sid
            ))
        goto SetOssCertIdentifierError;

    // digestAlgorithm
    if (!ICM_Asn1ToAlgorithmIdentifier(
            &psi->HashAlgorithm,
            &osi.digestAlgorithm))
        goto DigestAsn1ToAlgorithmIdentifierError;

    // authenticatedAttributes
    if (psi->AuthAttrs.cAttr) {
        osi.bit_mask |= authenticatedAttributes_present;
        osi.authenticatedAttributes.count = psi->AuthAttrs.cAttr;
        if (NULL == (poatrAuth = (Attribute *)ICM_AllocA(
                psi->AuthAttrs.cAttr * sizeof(Attribute))))
            goto AllocAuthAttrsError;
        osi.authenticatedAttributes.value = poatrAuth;
        for (i=psi->AuthAttrs.cAttr, patr=psi->AuthAttrs.rgAttr, poatr=poatrAuth;
                i>0;
                i--, patr++, poatr++) {
            if (!ICM_Asn1ToAttribute( patr, poatr))
                goto Asn1AuthenticatedAttributeError;
        }
    }

    // digestEncryptionAlgorithm
    if (!ICM_FillAsnDigestEncryptionAlgorithm(
            NULL,                           // pcmi
            &psi->HashEncryptionAlgorithm,
            &osi.digestEncryptionAlgorithm))
        goto FillAsnDigestEncryptionAlgorithmError;

    // encryptedDigest
    osi.encryptedDigest.length = psi->EncryptedHash.cbData;
    osi.encryptedDigest.value  = psi->EncryptedHash.pbData;

    // unauthenticatedAttributes
    if (psi->UnauthAttrs.cAttr) {
        osi.bit_mask |= unauthAttributes_present;
        osi.unauthAttributes.count = psi->UnauthAttrs.cAttr;
        if (NULL == (poatrUnauth = (Attribute *)ICM_AllocA(
                psi->UnauthAttrs.cAttr * sizeof(Attribute))))
            goto AllocUnauthAttrsError;
        osi.unauthAttributes.value = poatrUnauth;
        for (i=psi->UnauthAttrs.cAttr, patr=psi->UnauthAttrs.rgAttr, poatr=poatrUnauth;
                i>0;
                i--, patr++, poatr++) {
            if (!ICM_Asn1ToAttribute( patr, poatr))
                goto Asn1UnauthenticatedAttributeError;
        }
    }

    fRet = PkiAsn1EncodeInfo(
                    ICM_GetEncoder(),
                    SignerInfo_PDU,
                    &osi,
                    pbEncoded,
                    pcbEncoded);
    if (!fRet)
        dwError = GetLastError();

CommonReturn:
    ICM_FreeOssCertIdentifier(&osi.sid);

    if (poatrAuth) {
        for (i=psi->AuthAttrs.cAttr, poatr=poatrAuth;
                i>0;
                i--, poatr++)
            ICM_Free( poatr->attributeValue.value);
    }
    if (poatrUnauth) {
        for (i=psi->UnauthAttrs.cAttr, poatr=poatrUnauth;
                i>0;
                i--, poatr++)
            ICM_Free( poatr->attributeValue.value);
    }
    ICM_FreeA( poatrAuth);
    ICM_FreeA( poatrUnauth);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    *pcbEncoded = 0;
    goto CommonReturn;
SET_ERROR(InvalidEncodingTypeError,E_INVALIDARG)
TRACE_ERROR(SetOssCertIdentifierError)               // error already set
TRACE_ERROR(DigestAsn1ToAlgorithmIdentifierError)    // error already set
TRACE_ERROR(AllocAuthAttrsError)                        // error already set
TRACE_ERROR(Asn1AuthenticatedAttributeError)         // error already set
TRACE_ERROR(FillAsnDigestEncryptionAlgorithmError)      // error already set
TRACE_ERROR(AllocUnauthAttrsError)                      // error already set
TRACE_ERROR(Asn1UnauthenticatedAttributeError)       // error already set
lpszStructType;
}

//+-------------------------------------------------------------------------
//  Encode a Pkcs SignerInfo
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
ICM_PkcsSignerInfoEncode(
    IN DWORD                    dwEncodingType,
    IN LPCSTR                   lpszStructType,
    IN PCMSG_SIGNER_INFO        pInfo,
    OUT PBYTE                   pbEncoded,
    IN OUT PDWORD               pcbEncoded)
{
    CMSG_CMS_SIGNER_INFO csi;
    CERT_INFO CertInfo;

    csi.dwVersion = pInfo->dwVersion;

    CertInfo.Issuer = pInfo->Issuer;
    CertInfo.SerialNumber = pInfo->SerialNumber;
    ICM_GetCertIdFromCertInfo(&CertInfo, &csi.SignerId);

    csi.HashAlgorithm = pInfo->HashAlgorithm;
    csi.HashEncryptionAlgorithm = pInfo->HashEncryptionAlgorithm;
    csi.EncryptedHash = pInfo->EncryptedHash;
    csi.AuthAttrs = pInfo->AuthAttrs;
    csi.UnauthAttrs = pInfo->UnauthAttrs;

    return ICM_CmsSignerInfoEncode(
        dwEncodingType,
        lpszStructType,
        &csi,
        pbEncoded,
        pcbEncoded
        );
}

//+-------------------------------------------------------------------------
//  Get fields shared by PKCS and CMS SignerInfos
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssSharedSignerInfo(
    IN SignerInfo                   *posi,
    IN CBlobList                    *pUnauthAttrList,
    OUT PCRYPT_ALGORITHM_IDENTIFIER  pHashAlgorithm,
    OUT PCRYPT_ALGORITHM_IDENTIFIER  pHashEncryptionAlgorithm,
    OUT PCRYPT_DATA_BLOB             pEncryptedHash,
    OUT PCRYPT_ATTRIBUTES            pAuthAttrs,
    OUT PCRYPT_ATTRIBUTES            pUnauthAttrs,
    IN OUT PBYTE                    *ppbExtra,
    IN OUT LONG                     *plRemainExtra)
{
    BOOL        fRet;

    if (!ICM_GetOssAlgorithm( &posi->digestAlgorithm,
            pHashAlgorithm, ppbExtra, plRemainExtra))
        goto GetOssHashAlgorithmError;
    if (!ICM_GetOssAlgorithm( &posi->digestEncryptionAlgorithm,
            pHashEncryptionAlgorithm, ppbExtra, plRemainExtra))
        goto GetOssHashEncryptionAlgorithmError;
    if (!ICM_GetOssAny( (Any *)&posi->encryptedDigest,
            pEncryptedHash, ppbExtra, plRemainExtra))
        goto GetOssEncryptedHashError;
    if (posi->bit_mask & authenticatedAttributes_present) {
        if (!ICM_GetOssAttributes( &posi->authenticatedAttributes,
                pAuthAttrs, ppbExtra, plRemainExtra))
            goto GetOssAuthAttrsError;
    } else if (0 <= *plRemainExtra)
        pAuthAttrs->cAttr = 0;

    if (posi->bit_mask & unauthAttributes_present || pUnauthAttrList) {
        if (pUnauthAttrList) {
            if (!ICM_GetCListAttributes( pUnauthAttrList,
                    pUnauthAttrs, ppbExtra, plRemainExtra))
                goto GetCListUnauthAttrsError;
        } else {
            if (!ICM_GetOssAttributes( &posi->unauthAttributes,
                    pUnauthAttrs, ppbExtra, plRemainExtra))
                goto GetOssUnauthAttrsError;
        }
    } else if (0 <= *plRemainExtra)
        pUnauthAttrs->cAttr = 0;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssHashAlgorithmError)               // error already set
TRACE_ERROR(GetOssHashEncryptionAlgorithmError)     // error already set
TRACE_ERROR(GetOssEncryptedHashError)               // error already set
TRACE_ERROR(GetOssAuthAttrsError)                   // error already set
TRACE_ERROR(GetCListUnauthAttrsError)               // error already set
TRACE_ERROR(GetOssUnauthAttrsError)                 // error already set
}

//+-------------------------------------------------------------------------
//  Get a CMS SignerInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssCmsSignerInfo(
    IN SignerInfo   *posi,
    IN CBlobList    *pUnauthAttrList,
    OUT PCMSG_CMS_SIGNER_INFO psi,
    IN OUT PBYTE    *ppbExtra,
    IN OUT LONG     *plRemainExtra)
{
    BOOL        fRet;

    if (0 <= *plRemainExtra)
        psi->dwVersion = posi->version;

    if (!ICM_GetOssCertIdentifier(&posi->sid, &psi->SignerId,
            ppbExtra, plRemainExtra))
        goto GetOssCertIdentifierError;

    if (!ICM_GetOssSharedSignerInfo(
            posi,
            pUnauthAttrList,
            &psi->HashAlgorithm,
            &psi->HashEncryptionAlgorithm,
            &psi->EncryptedHash,
            &psi->AuthAttrs,
            &psi->UnauthAttrs,
            ppbExtra,
            plRemainExtra))
        goto GetOssSharedSignerInfoError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssCertIdentifierError)              // error already set
TRACE_ERROR(GetOssSharedSignerInfoError)            // error already set
}


//+-------------------------------------------------------------------------
//  Get a PKCS SignerInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssPkcsSignerInfo(
    IN SignerInfo   *posi,
    IN CBlobList    *pUnauthAttrList,
    OUT PCMSG_SIGNER_INFO psi,
    IN OUT PBYTE    *ppbExtra,
    IN OUT LONG     *plRemainExtra)
{
    BOOL        fRet;

    if (0 <= *plRemainExtra)
        psi->dwVersion = posi->version;

    if (!ICM_GetOssIssuerAndSerialNumberFromCertId(&posi->sid,
            &psi->Issuer, &psi->SerialNumber, ppbExtra, plRemainExtra))
        goto GetOssIssuerAndSerialNumberError;

    if (!ICM_GetOssSharedSignerInfo(
            posi,
            pUnauthAttrList,
            &psi->HashAlgorithm,
            &psi->HashEncryptionAlgorithm,
            &psi->EncryptedHash,
            &psi->AuthAttrs,
            &psi->UnauthAttrs,
            ppbExtra,
            plRemainExtra))
        goto GetOssSharedSignerInfoError;

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssIssuerAndSerialNumberError)       // error already set
TRACE_ERROR(GetOssSharedSignerInfoError)            // error already set
}


//+-------------------------------------------------------------------------
//  Decode a PKCS SignerInfo blob.
//
//  Returns:    FALSE iff fails
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
ICM_PkcsSignerInfoDecode(
        IN DWORD dwEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCMSG_SIGNER_INFO pInfo,
        IN OUT DWORD *pcbInfo)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    LONG                lData;
    SignerInfo          *posi = NULL;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    PCMSG_SIGNER_INFO   psi = pInfo;
    LONG                lRemainExtra;
    PBYTE               pbExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posi,
            SignerInfo_PDU,
            pbEncoded,
            cbEncoded)))
        goto Asn1DecodeSignerInfoError;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CMSG_SIGNER_INFO));
    lRemainExtra = (LONG)*pcbInfo - lData;
    if (0 > lRemainExtra) {
        psi = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)psi + lData;
    }
    if (!ICM_GetOssPkcsSignerInfo(
            posi,
            NULL,       // pUnauthAttrList
            psi, &pbExtra, &lRemainExtra))
        goto GetOssSignerInfoError;

    fRet = ICM_GetSizeFromExtra( lRemainExtra, pInfo, pcbInfo);

    if (!fRet)
        dwError = GetLastError();
CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfo_PDU, posi);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    *pcbInfo = 0;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(GetOssSignerInfoError)      // error already set
dwFlags;
lpszStructType;
}


//+-------------------------------------------------------------------------
//  Find the Pkcs SignerInfo by index, if the message type permits and if the
//  index value is in range.
//
//  Returns:    FALSE iff fails
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetPkcsSignerInfo(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwIndex,
    OUT PVOID           pvData,
    IN OUT PDWORD       pcbData)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    LONG                lData;
    CSignerNode         *pSignerNode;
    SignerInfo          *posi = NULL;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    CRYPT_DATA_BLOB     DataBlob;
    PCMSG_SIGNER_INFO   psi = (PCMSG_SIGNER_INFO)pvData;
    LONG                lRemainExtra;
    PBYTE               pbExtra;

    if (!ICM_FindSignerInfo( pcmi, dwIndex, (PVOID *)&pSignerNode))
        goto FindSignerInfoError;

    DataBlob = pSignerNode->Data()->blob;
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posi,
            SignerInfo_PDU,
            DataBlob.pbData,
            DataBlob.cbData)))
        goto Asn1DecodeSignerInfoError;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CMSG_SIGNER_INFO));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        psi = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)psi + lData;
    }
    if (!ICM_GetOssPkcsSignerInfo( posi, pSignerNode->Data()->pUnauthAttrList,
                psi, &pbExtra, &lRemainExtra))
        goto GetOssSignerInfoError;

    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

    if (!fRet)
        dwError = GetLastError();
CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfo_PDU, posi);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(FindSignerInfoError)            // error already set
TRACE_ERROR(GetOssSignerInfoError)          // error already set
}

//+-------------------------------------------------------------------------
//  Decode a CMS SignerInfo blob.
//
//  Returns:    FALSE iff fails
//--------------------------------------------------------------------------
STATIC
BOOL
WINAPI
ICM_CmsSignerInfoDecode(
        IN DWORD dwEncodingType,
        IN LPCSTR lpszStructType,
        IN const BYTE *pbEncoded,
        IN DWORD cbEncoded,
        IN DWORD dwFlags,
        OUT PCMSG_CMS_SIGNER_INFO pInfo,
        IN OUT DWORD *pcbInfo)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    LONG                lData;
    SignerInfo          *posi = NULL;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    PCMSG_CMS_SIGNER_INFO psi = pInfo;
    LONG                lRemainExtra;
    PBYTE               pbExtra;

    if (pInfo == NULL)
        *pcbInfo = 0;

    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posi,
            SignerInfo_PDU,
            pbEncoded,
            cbEncoded)))
        goto Asn1DecodeSignerInfoError;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CMSG_CMS_SIGNER_INFO));
    lRemainExtra = (LONG)*pcbInfo - lData;
    if (0 > lRemainExtra) {
        psi = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)psi + lData;
    }
    if (!ICM_GetOssCmsSignerInfo(
            posi,
            NULL,       // pUnauthAttrList
            psi, &pbExtra, &lRemainExtra))
        goto GetOssSignerInfoError;

    fRet = ICM_GetSizeFromExtra( lRemainExtra, pInfo, pcbInfo);

    if (!fRet)
        dwError = GetLastError();
CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfo_PDU, posi);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    *pcbInfo = 0;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(GetOssSignerInfoError)      // error already set
dwFlags;
lpszStructType;
}


//+-------------------------------------------------------------------------
//  Find the CMS SignerInfo by index, if the message type permits and if the
//  index value is in range.
//
//  Returns:    FALSE iff fails
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetCmsSignerInfo(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwIndex,
    OUT PVOID           pvData,
    IN OUT PDWORD       pcbData)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    LONG                lData;
    CSignerNode         *pSignerNode;
    SignerInfo          *posi = NULL;
    ASN1error_e         Asn1Err;
    ASN1decoding_t      pDec = ICM_GetDecoder();
    CRYPT_DATA_BLOB     DataBlob;
    PCMSG_CMS_SIGNER_INFO psi = (PCMSG_CMS_SIGNER_INFO)pvData;
    LONG                lRemainExtra;
    PBYTE               pbExtra;

    if (!ICM_FindSignerInfo( pcmi, dwIndex, (PVOID *)&pSignerNode))
        goto FindSignerInfoError;

    DataBlob = pSignerNode->Data()->blob;
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posi,
            SignerInfo_PDU,
            DataBlob.pbData,
            DataBlob.cbData)))
        goto Asn1DecodeSignerInfoError;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN( sizeof(CMSG_CMS_SIGNER_INFO));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        psi = NULL;
        pbExtra = NULL;
    } else {
        pbExtra = (PBYTE)psi + lData;
    }
    if (!ICM_GetOssCmsSignerInfo( posi, pSignerNode->Data()->pUnauthAttrList,
                psi, &pbExtra, &lRemainExtra))
        goto GetOssSignerInfoError;

    fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);

    if (!fRet)
        dwError = GetLastError();
CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfo_PDU, posi);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(Asn1DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(FindSignerInfoError)            // error already set
TRACE_ERROR(GetOssSignerInfoError)          // error already set
}


//+-------------------------------------------------------------------------
//  Get the data for a field in a Signer, while encoding a message
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetSignerParamEncoding(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwIndex,
    IN DWORD            dwParamType,
    OUT PVOID           pvData,
    IN OUT PDWORD       pcbData)
{
    DWORD           dwError = ERROR_SUCCESS;
    BOOL            fRet;
    ASN1error_e     Asn1Err;
    ASN1encoding_t  pEnc = ICM_GetEncoder();
    PBYTE           pbEncoded = NULL;
    DWORD           cbEncoded;
    SignerInfo      *posi = NULL;


    if (!ICM_FindSignerInfo( pcmi, dwIndex, (PVOID *)&posi))
        goto FindSignerInfoError;

    switch (dwParamType) {

    case CMSG_ENCODED_SIGNER:
        if (0 != (Asn1Err = PkiAsn1Encode(
                pEnc,
                posi,
                SignerInfo_PDU,
                &pbEncoded,
                &cbEncoded)))
            goto EncodeSignerInfoError;
        break;

    default:
        goto InvalidParamError;
    }

    fRet = ICM_CopyOut(
                pbEncoded,
                cbEncoded,
                (PBYTE)pvData,
                pcbData);
    if (!fRet)
        dwError = GetLastError();
CommonReturn:
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(FindSignerInfoError)        // error already set
SET_ERROR_VAR(EncodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(InvalidParamError,E_INVALIDARG)
}


//+-------------------------------------------------------------------------
//  Get the data for a field in a Signer
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetSignerParam(
    IN PCRYPT_MSG_INFO  pcmi,
    IN DWORD            dwIndex,
    IN DWORD            dwParamType,
    OUT PVOID           pvData,
    IN OUT PDWORD       pcbData)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    CRYPT_DATA_BLOB         DataBlob;
    ASN1uint32_t            pdunumRef = 0;      // invalid
    SignerInfoWithBlobs     *posib = NULL;
    PVOID                   pv = NULL;
    CSignerNode             *pSignerNode;

    if (!ICM_FindSignerInfo( pcmi, dwIndex, (PVOID *)&pSignerNode))
        goto FindSignerInfoError;

    DataBlob = pSignerNode->Data()->blob;
    if (0 != (Asn1Err = PkiAsn1Decode(
            pDec,
            (void **)&posib,
            SignerInfoWithBlobs_PDU,
            DataBlob.pbData,
            DataBlob.cbData)))
        goto DecodeSignerInfoError;

    switch (dwParamType) {

    case CMSG_SIGNER_INFO_PARAM:
        fRet = ICM_GetPkcsSignerInfo( pcmi, dwIndex, pvData, pcbData);
        break;
    case CMSG_CMS_SIGNER_INFO_PARAM:
        fRet = ICM_GetCmsSignerInfo( pcmi, dwIndex, pvData, pcbData);
        break;

    case CMSG_ENCRYPTED_DIGEST:
        fRet = ICM_CopyOut(
                    (PBYTE)posib->encryptedDigest.value,
                    (DWORD)posib->encryptedDigest.length,
                    (PBYTE)pvData,
                    pcbData);
        break;

    case CMSG_ENCODED_SIGNER:
        if (pSignerNode->Data()->pUnauthAttrList) {
            // Need to re-encode with new unauth attrs
            goto ReEncodedSignerNotImplementedError;
        } else {
            fRet = ICM_CopyOut(
                        pSignerNode->Data()->blob.pbData,
                        pSignerNode->Data()->blob.cbData,
                        (PBYTE)pvData,
                        pcbData);
        }
        break;

    case CMSG_SIGNER_CERT_INFO_PARAM:
    case CMSG_SIGNER_CERT_ID_PARAM:
        pdunumRef = CertIdentifier_PDU;
        if (0 != (Asn1Err = PkiAsn1Decode(
                pDec,
                &pv,
                pdunumRef,
                (BYTE *) posib->sid.value,
                posib->sid.length)))
            goto DecodeCertIdentifierError;
        if (CMSG_SIGNER_CERT_INFO_PARAM == dwParamType)
            fRet = ICM_GetCertInfoIssuerAndSerialNumber(
                    (CertIdentifier *)pv,
                    pvData,
                    pcbData);
        else
            fRet = ICM_GetCertId(
                    (CertIdentifier *)pv,
                    pvData,
                    pcbData);
        break;

    case CMSG_SIGNER_HASH_ALGORITHM_PARAM:
        pdunumRef = AlgorithmIdentifierNC2_PDU;
        if (0 != (Asn1Err = PkiAsn1Decode(
                pDec,
                &pv,
                pdunumRef,
                (BYTE *) posib->digestAlgorithm.value,
                posib->digestAlgorithm.length)))
            goto DecodeAlgorithmIdentifierNC2Error;
        fRet = ICM_GetALGORITHM_IDENTIFIER(
                (AlgorithmIdentifier *)pv,
                pvData,
                pcbData);
        break;

    case CMSG_SIGNER_AUTH_ATTR_PARAM:
        if (posib->bit_mask & authAttributes_present)
            fRet = ICM_GetAttributesData(
                        (Attributes *)&posib->authAttributes,
                        pvData,
                        pcbData);
        else
            goto AuthAttrMissingError;
        break;

    case CMSG_SIGNER_UNAUTH_ATTR_PARAM:
        if (posib->bit_mask & unauthAttributes_present)
            fRet = ICM_GetAttributesData(
                        (Attributes *)&posib->unauthAttributes,
                        pvData,
                        pcbData);
        else
            goto UnauthAttrMissingError;
        break;

    default:
        goto InvalidParamError;
    }
    if (!fRet)
        dwError = GetLastError();

CommonReturn:
    PkiAsn1FreeInfo(pDec, SignerInfoWithBlobs_PDU, posib);
    PkiAsn1FreeInfo(pDec, pdunumRef, pv);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR_VAR(DecodeSignerInfoError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(DecodeCertIdentifierError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(DecodeAlgorithmIdentifierNC2Error, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(AuthAttrMissingError,CRYPT_E_ATTRIBUTES_MISSING)
SET_ERROR(UnauthAttrMissingError,CRYPT_E_ATTRIBUTES_MISSING)
SET_ERROR(ReEncodedSignerNotImplementedError,E_INVALIDARG)
SET_ERROR(InvalidParamError,E_INVALIDARG)
TRACE_ERROR(FindSignerInfoError)                    // error already set
}


//+-------------------------------------------------------------------------
//  Get the encoded blob for a SignerInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetEncodedSignerInfo(
    IN DWORD                dwEncodingType,
    IN PSIGNER_DATA_INFO    pSignerInfo,
    OUT PBYTE               pbSignerInfo,
    IN OUT PDWORD           pcbSignerInfo)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    SignerInfoWithAttrBlobs *posiab = NULL;
    Any                     *pAnyAttr = NULL;
    Any                     *pAny;
    DWORD                   cAnyAttr;
    AttributesNC            unauthAttributesSave;
                                        ZEROSTRUCT(unauthAttributesSave);
#ifdef OSS_CRYPT_ASN1
    BYTE                    bit_maskSave = 0;
#else
    ASN1uint16_t            bit_maskSave = 0;
#endif  // OSS_CRYPT_ASN1
    ASN1error_e             Asn1Err;
    ASN1decoding_t          pDec = ICM_GetDecoder();
    ASN1encoding_t          pEnc = ICM_GetEncoder();
    PBYTE                   pbEncoded = NULL;
    DWORD                   cbEncoded;
    CBlobNode               *pnBlob;
    DWORD                   cbOut;
    PBYTE                   pbOut;

    if (GET_CMSG_ENCODING_TYPE(dwEncodingType) != PKCS_7_ASN_ENCODING)
        goto InvalidEncodingTypeError;

    if (pSignerInfo->pUnauthAttrList) {
        if (0 != (Asn1Err = PkiAsn1Decode(
                pDec,
                (void **)&posiab,
                SignerInfoWithAttrBlobs_PDU,
                pSignerInfo->blob.pbData,
                pSignerInfo->blob.cbData)))
            goto DecodeSignerInfoWithAttrBlobsError;
        // We have to take into account both the case where we have added
        // unauth attrs, and the case where we have removed them. There might
        // have been unauth attrs in the original message, and we removed
        // them all. Or, there might have been none originally, and we added
        // some.
        bit_maskSave = posiab->bit_mask;
        unauthAttributesSave = posiab->unauthAttributes;
        cAnyAttr = pSignerInfo->pUnauthAttrList->Length();
        posiab->bit_mask &= ~unauthAttributes_present;
        posiab->bit_mask |= (cAnyAttr > 0) ? unauthAttributes_present : 0;
        if (NULL == (pAnyAttr = (Any *)ICM_AllocA( cAnyAttr * sizeof(Any))))
            goto AllocAnyAttrError;
        posiab->unauthAttributes.count = cAnyAttr;
        posiab->unauthAttributes.value = pAnyAttr;
        for (pnBlob=pSignerInfo->pUnauthAttrList->Head(), pAny=pAnyAttr;
                pnBlob;
                pnBlob=pnBlob->Next(), pAny++)
            *pAny = *(Any *)pnBlob->Data();
        if (0 != (Asn1Err = PkiAsn1Encode(
                pEnc,
                posiab,
                SignerInfoWithAttrBlobs_PDU,
                &pbEncoded,
                &cbEncoded)))
            goto EncodeSignerInfoWithAttrBlobsError;
        cbOut = cbEncoded;
        pbOut = pbEncoded;
    } else {
        cbOut = pSignerInfo->blob.cbData;
        pbOut = pSignerInfo->blob.pbData;
    }

    fRet = ICM_CopyOut(
                pbOut,
                cbOut,
                pbSignerInfo,
                pcbSignerInfo);
    if (!fRet)
        dwError = GetLastError();

CommonReturn:
    ICM_FreeA( pAnyAttr);
    if (posiab) {
        posiab->bit_mask = bit_maskSave;
        posiab->unauthAttributes = unauthAttributesSave;
        PkiAsn1FreeDecoded(pDec, posiab, SignerInfoWithAttrBlobs_PDU);
    }
    PkiAsn1FreeEncoded(pEnc, pbEncoded);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(InvalidEncodingTypeError,E_INVALIDARG)
SET_ERROR_VAR(DecodeSignerInfoWithAttrBlobsError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(EncodeSignerInfoWithAttrBlobsError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(AllocAnyAttrError)              // error already set
}


//+-------------------------------------------------------------------------
//  Get the data for a field in a Signer
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetEncodedMessageParam(
    IN PCRYPT_MSG_INFO  pcmi,
    OUT PBYTE           pbEncodedMessage,
    IN OUT PDWORD       pcbEncodedMessage)
{
    DWORD                   dwError = ERROR_SUCCESS;
    BOOL                    fRet;
    SignedDataWithBlobs     *posdb = NULL;
    PSIGNED_DATA_INFO       psdi = pcmi->psdi;
    Any                     *pAny;
    PSIGNER_DATA_INFO       pSignerInfo;
    ASN1error_e             Asn1Err;
    ASN1encoding_t          pEnc = ICM_GetEncoder();
    PBYTE                   pbEncodedSignedData = NULL;
    DWORD                   cbEncodedSignedData;
    PBYTE                   pbEncodedContentInfo = NULL;
    DWORD                   cbEncodedContentInfo;
    CSignerNode             *pnSigner;
    CBlobNode               *pnBlob;
    DWORD                   cb;
    PBYTE                   pb;
    DWORD                   i;
    ContentInfo             ci;


    if (NULL == (posdb = (SignedDataWithBlobs *)ICM_AllocZeroA(
                sizeof(SignedDataWithBlobs) +
                sizeof(Any) *
                   (psdi->pAlgidList->Length() +
                    psdi->pCertificateList->Length() +
                    psdi->pCrlList->Length() +
                    psdi->pSignerList->Length()))))
        goto AllocSignedDataWithBlobsError;
    pAny = (Any *)(posdb + 1);

    // version
    posdb->version = psdi->version;

    // digest algorithms
    posdb->digestAlgorithms.count = psdi->pAlgidList->Length();
    posdb->digestAlgorithms.value = pAny;
    for (pnBlob=psdi->pAlgidList->Head();
            pnBlob;
            pnBlob=pnBlob->Next())
        *pAny++ = *(Any *)pnBlob->Data();

    // contentInfo
    posdb->contentInfo.contentType.count = SIZE_OSS_OID;
    if (!PkiAsn1ToObjectIdentifier(
            psdi->pci->pszContentType,
            &posdb->contentInfo.contentType.count,
            posdb->contentInfo.contentType.value))
        goto PkiAsn1ToObjectIdentifierError;
    if (psdi->pci->content.cbData) {
        posdb->contentInfo.bit_mask |= content_present;
        posdb->contentInfo.content.length = psdi->pci->content.cbData;
        posdb->contentInfo.content.value  = psdi->pci->content.pbData;
    }

    // certificates
    posdb->certificates.count = psdi->pCertificateList->Length();
#ifdef OSS_CRYPT_ASN1
    posdb->certificates.certificates = pAny;
#else
    posdb->certificates.value = pAny;
#endif  // OSS_CRYPT_ASN1
    for (pnBlob=psdi->pCertificateList->Head();
            pnBlob;
            pnBlob=pnBlob->Next()) {
        posdb->bit_mask |= certificates_present;
        *pAny++ = *(Any *)pnBlob->Data();
    }

    // crls
    posdb->crls.count = psdi->pCrlList->Length();
#ifdef OSS_CRYPT_ASN1
    posdb->crls.crls  = pAny;
#else
    posdb->crls.value  = pAny;
#endif  // OSS_CRYPT_ASN1
    for (pnBlob=psdi->pCrlList->Head();
            pnBlob;
            pnBlob=pnBlob->Next()) {
        posdb->bit_mask |= crls_present;
        *pAny++ = *(Any *)pnBlob->Data();
    }

    // signerInfos
    posdb->signerInfos.count = psdi->pSignerList->Length();
    posdb->signerInfos.value = pAny;
    for (pnSigner=psdi->pSignerList->Head();
            pnSigner;
            pnSigner=pnSigner->Next()) {
        pSignerInfo = pnSigner->Data();
        if (!ICM_GetEncodedSignerInfo(
                PKCS_7_ASN_ENCODING,
                pnSigner->Data(),
                NULL,
                &cb))
            goto GetEncodedSignerInfoSizeError;
        if (NULL == (pb = (PBYTE)ICM_AllocA( cb)))
            goto AllocEncodedSignerInfoError;
        if (!ICM_GetEncodedSignerInfo(
                PKCS_7_ASN_ENCODING,
                pnSigner->Data(),
                pb,
                &cb))
            goto GetEncodedSignerInfoError;
        pAny->length = cb;
        pAny->value  = pb;
        pAny++;
    }

    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            posdb,
            SignedDataWithBlobs_PDU,
            &pbEncodedSignedData,
            &cbEncodedSignedData)))
        goto EncodeSignedDataWithBlobsError;

    ci.contentType.count = SIZE_OSS_OID;
    if (!PkiAsn1ToObjectIdentifier(
            szOID_RSA_signedData,
            &ci.contentType.count,
            ci.contentType.value))
        goto ConvSignedDataToOidError;
    ci.bit_mask = content_present;
    ci.content.length = cbEncodedSignedData;
    ci.content.value = pbEncodedSignedData;

    if (0 != (Asn1Err = PkiAsn1Encode(
            pEnc,
            &ci,
            ContentInfo_PDU,
            &pbEncodedContentInfo,
            &cbEncodedContentInfo)))
        goto EncodeContentInfoError;

    fRet = ICM_CopyOut(
                pbEncodedContentInfo,
                cbEncodedContentInfo,
                pbEncodedMessage,
                pcbEncodedMessage);

    if (!fRet)
        dwError = GetLastError();
CommonReturn:
    PkiAsn1FreeEncoded(pEnc, pbEncodedSignedData);
    PkiAsn1FreeEncoded(pEnc, pbEncodedContentInfo);
    for (i=posdb->signerInfos.count, pAny=posdb->signerInfos.value;
            i>0;
            i--, pAny++)
        ICM_FreeA( pAny->value);
    ICM_FreeA(posdb);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    dwError = GetLastError();
    fRet = FALSE;
    goto CommonReturn;
SET_ERROR(PkiAsn1ToObjectIdentifierError,CRYPT_E_OID_FORMAT)
SET_ERROR_VAR(EncodeSignedDataWithBlobsError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR(ConvSignedDataToOidError,CRYPT_E_OID_FORMAT)
SET_ERROR_VAR(EncodeContentInfoError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(AllocSignedDataWithBlobsError)      // error already set
TRACE_ERROR(GetEncodedSignerInfoSizeError)      // error already set
TRACE_ERROR(AllocEncodedSignerInfoError)        // error already set
TRACE_ERROR(GetEncodedSignerInfoError)          // error already set
}

#ifdef CMS_PKCS7

//+-------------------------------------------------------------------------
//  Get Oss OctetString
//--------------------------------------------------------------------------
void
inline
WINAPI
ICM_GetOssOctetString(
    IN OctetStringType *pOssOctetString,
    OUT PCRYPT_DATA_BLOB pOctetString,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    PkiAsn1GetOctetString(pOssOctetString->length, pOssOctetString->value, 0,
        pOctetString, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Get Oss BitString
//--------------------------------------------------------------------------
void
inline
WINAPI
ICM_GetOssBitString(
    IN BitStringType *pOssBitString,
    OUT PCRYPT_BIT_BLOB pBitString,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    PkiAsn1GetBitString(pOssBitString->length, pOssBitString->value, 0,
        pBitString, ppbExtra, plRemainExtra);
}


//+-------------------------------------------------------------------------
//  Get an Oss IssuerAndSerialNumber
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssIssuerAndSerialNumber(
    IN IssuerAndSerialNumber *pOssIssuerAndSerialNumber,
    OUT PCERT_ISSUER_SERIAL_NUMBER pIssuerAndSerialNumber,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra)
{
    ICM_GetOssHugeInteger(&pOssIssuerAndSerialNumber->serialNumber,
            &pIssuerAndSerialNumber->SerialNumber, ppbExtra, plRemainExtra);
    return ICM_GetOssAny(&pOssIssuerAndSerialNumber->issuer,
            &pIssuerAndSerialNumber->Issuer, ppbExtra, plRemainExtra);
}

//+-------------------------------------------------------------------------
//  Get Oss CertIdentifier
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssCertIdentifier(
    IN CertIdentifier *pOssCertId,
    OUT PCERT_ID pCertId,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    BOOL fRet;

    if (0 <= *plRemainExtra) {
        assert(CERT_ID_ISSUER_SERIAL_NUMBER == issuerAndSerialNumber_chosen);
        assert(CERT_ID_KEY_IDENTIFIER == subjectKeyIdentifier_chosen);
        pCertId->dwIdChoice = pOssCertId->choice;
    }

    switch (pOssCertId->choice) {
        case issuerAndSerialNumber_chosen:
            if (!ICM_GetOssIssuerAndSerialNumber(
                    &pOssCertId->u.issuerAndSerialNumber,
                    &pCertId->IssuerSerialNumber, ppbExtra, plRemainExtra))
                goto GetOssIssuerAndSerialNumberError;
            break;
        case subjectKeyIdentifier_chosen:
            ICM_GetOssOctetString( &pOssCertId->u.subjectKeyIdentifier,
                &pCertId->KeyId, ppbExtra, plRemainExtra);
            break;
        default:
            goto InvalidCertIdChoice;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetOssIssuerAndSerialNumberError)
SET_ERROR(InvalidCertIdChoice, CRYPT_E_BAD_ENCODE)
}

//+-------------------------------------------------------------------------
//  Get Oss OtherKeyAttribute
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssOtherKeyAttribute(
    IN OtherKeyAttribute *pOssOtherAttr,
    OUT PCRYPT_ATTRIBUTE_TYPE_VALUE *ppOtherAttr,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    BOOL fRet;
    LONG lData;
    PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr;

    lData = INFO_LEN_ALIGN(sizeof(CRYPT_ATTRIBUTE_TYPE_VALUE));
    *plRemainExtra -= lData;
    if (0 <= *plRemainExtra) {
        pOtherAttr = (PCRYPT_ATTRIBUTE_TYPE_VALUE) *ppbExtra;
        memset(pOtherAttr, 0, sizeof(*pOtherAttr));
        *ppOtherAttr = pOtherAttr;

        *ppbExtra += lData;
    } else
        pOtherAttr = NULL;

    if (!ICM_GetOssObjId(&pOssOtherAttr->keyAttrId, &pOtherAttr->pszObjId,
            ppbExtra, plRemainExtra))
        goto GetOssObjIdError;
    if (pOssOtherAttr->bit_mask & keyAttr_present) {
        if (!ICM_GetOssAny(&pOssOtherAttr->keyAttr,
                &pOtherAttr->Value, ppbExtra, plRemainExtra))
            goto GetOssAnyError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssObjIdError)
TRACE_ERROR(GetOssAnyError)
}


//+-------------------------------------------------------------------------
//  Get Oss KeyTransRecipientInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssKeyTransRecipientInfo(
    IN KeyTransRecipientInfo *pori,
    OUT PCMSG_KEY_TRANS_RECIPIENT_INFO *ppri,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    BOOL fRet;
    LONG lData;
    PCMSG_KEY_TRANS_RECIPIENT_INFO pri;

    lData = INFO_LEN_ALIGN(sizeof(CMSG_KEY_TRANS_RECIPIENT_INFO));
    *plRemainExtra -= lData;
    if (0 <= *plRemainExtra) {
        pri = (PCMSG_KEY_TRANS_RECIPIENT_INFO) *ppbExtra;
        *ppri = pri;
        *ppbExtra += lData;

        pri->dwVersion = pori->version;
    } else {
        pri = NULL;
    }
    
    if (!ICM_GetOssCertIdentifier(&pori->rid, &pri->RecipientId,
            ppbExtra, plRemainExtra))
        goto GetOssCertIdentifierError;

    if (!ICM_GetOssAlgorithm(&pori->keyEncryptionAlgorithm,
            &pri->KeyEncryptionAlgorithm,
            ppbExtra, plRemainExtra))
        goto GetOssKeyEncryptionAlgorithmError;

    ICM_GetOssOctetString(&pori->encryptedKey, &pri->EncryptedKey,
        ppbExtra, plRemainExtra);

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetOssCertIdentifierError)
TRACE_ERROR(GetOssKeyEncryptionAlgorithmError)
}

//+-------------------------------------------------------------------------
//  Get Oss KeyAgreeRecipientInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssKeyAgreeRecipientInfo(
    IN KeyAgreeRecipientInfo *pori,
    OUT PCMSG_KEY_AGREE_RECIPIENT_INFO *ppri,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    BOOL fRet;
    LONG lData;
    PCMSG_KEY_AGREE_RECIPIENT_INFO pri;
    DWORD count;
    OriginatorIdentifierOrKey *pooriginator;
    OriginatorPublicKey *pooriginatorKey;

    lData = INFO_LEN_ALIGN(sizeof(CMSG_KEY_AGREE_RECIPIENT_INFO));
    *plRemainExtra -= lData;
    if (0 <= *plRemainExtra) {
        pri = (PCMSG_KEY_AGREE_RECIPIENT_INFO) *ppbExtra;
        memset(pri, 0, sizeof(*pri));
        *ppri = pri;
        *ppbExtra += lData;

        pri->dwVersion = pori->version;
    } else {
        pri = NULL;
    }
    
    pooriginator = &pori->originator;
    switch (pooriginator->choice) {
        case issuerAndSerialNumber_chosen:
            if (!ICM_GetOssIssuerAndSerialNumber(
                    &pooriginator->u.issuerAndSerialNumber,
                    &pri->OriginatorCertId.IssuerSerialNumber,
                    ppbExtra, plRemainExtra))
                goto GetOssOriginatorIssuerAndSerialNumberError;
            if (0 <= *plRemainExtra) {
                pri->OriginatorCertId.dwIdChoice =
                    CERT_ID_ISSUER_SERIAL_NUMBER;
                pri->dwOriginatorChoice = CMSG_KEY_AGREE_ORIGINATOR_CERT;
            }
            break;
        case subjectKeyIdentifier_chosen:
            ICM_GetOssOctetString(
                &pooriginator->u.subjectKeyIdentifier,
                &pri->OriginatorCertId.KeyId,
                ppbExtra, plRemainExtra);
            if (0 <= *plRemainExtra) {
                pri->OriginatorCertId.dwIdChoice =
                    CERT_ID_KEY_IDENTIFIER;
                pri->dwOriginatorChoice = CMSG_KEY_AGREE_ORIGINATOR_CERT;
            }
            break;
        case originatorKey_chosen:
            pooriginatorKey = &pooriginator->u.originatorKey;
            if (!ICM_GetOssAlgorithm(&pooriginatorKey->algorithm,
                    &pri->OriginatorPublicKeyInfo.Algorithm,
                    ppbExtra, plRemainExtra
                    ))
                goto GetOssOriginatorPublicKeyAlgorithmError;
            ICM_GetOssBitString(&pooriginatorKey->publicKey,
                &pri->OriginatorPublicKeyInfo.PublicKey,
                ppbExtra, plRemainExtra);
            if (0 <= *plRemainExtra)
                pri->dwOriginatorChoice = CMSG_KEY_AGREE_ORIGINATOR_PUBLIC_KEY;
            break;
        default:
            goto InvalidOriginatorChoice;
    }

    if (pori->bit_mask & ukm_present)
        ICM_GetOssOctetString(&pori->ukm, &pri->UserKeyingMaterial,
            ppbExtra, plRemainExtra);

    if (!ICM_GetOssAlgorithm(&pori->keyEncryptionAlgorithm,
            &pri->KeyEncryptionAlgorithm,
            ppbExtra, plRemainExtra))
        goto GetOssKeyEncryptionAlgorithmError;

    count = pori->recipientEncryptedKeys.count;
    if (0 < count) {
        RecipientEncryptedKey *porek;
        PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO prek;
        PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO *pprek;

        lData = INFO_LEN_ALIGN(
            count * sizeof(PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO) +
            count * sizeof(CMSG_RECIPIENT_ENCRYPTED_KEY_INFO));

        *plRemainExtra -= lData;
        if (0 <= *plRemainExtra) {
            pprek = (PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO *) *ppbExtra;
            prek = (PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO) (((PBYTE) pprek) +
                (count * sizeof(PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO)));
            *ppbExtra += lData;

            pri->cRecipientEncryptedKeys = count;
            pri->rgpRecipientEncryptedKeys = pprek;
        } else {
            pprek = NULL;
            prek = NULL;
        }

        porek = pori->recipientEncryptedKeys.value;
        for ( ; 0 < count; count--, porek++, prek++, pprek++) {
            RecipientIdentifier *porid = &porek->rid;

            if (0 <= *plRemainExtra) {
                memset(prek, 0, sizeof(*prek));
                *pprek = prek;

                assert(issuerAndSerialNumber_chosen ==
                    CERT_ID_ISSUER_SERIAL_NUMBER);
                assert(rKeyId_chosen ==
                    CERT_ID_KEY_IDENTIFIER);
                prek->RecipientId.dwIdChoice = porid->choice;
            }

            ICM_GetOssOctetString(&porek->encryptedKey, &prek->EncryptedKey,
                ppbExtra, plRemainExtra);

            switch (porid->choice) {
                case issuerAndSerialNumber_chosen:
                    if (!ICM_GetOssIssuerAndSerialNumber(
                            &porid->u.issuerAndSerialNumber,
                            &prek->RecipientId.IssuerSerialNumber,
                            ppbExtra, plRemainExtra))
                        goto GetOssIssuerAndSerialNumberError;
                    break;
                case rKeyId_chosen:
                    ICM_GetOssOctetString(
                        &porid->u.rKeyId.subjectKeyIdentifier,
                        &prek->RecipientId.KeyId, ppbExtra, plRemainExtra);

                    if (porid->u.rKeyId.bit_mask & date_present) {
                        if (0 <= *plRemainExtra) {
                            if (!PkiAsn1FromGeneralizedTime(
                                    &porid->u.rKeyId.date, &prek->Date))
                                goto ConvFromGeneralizedTimeError;
                        }
                    }

                    if (porid->u.rKeyId.bit_mask & other_present) {
                        if (!ICM_GetOssOtherKeyAttribute(
                                &porid->u.rKeyId.other,
                                &prek->pOtherAttr,
                                ppbExtra, plRemainExtra))
                            goto GetOssOtherKeyAttributeError;
                    }
                    break;
                default:
                    goto InvalidRecipientChoice;
            }
        }
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetOssOriginatorIssuerAndSerialNumberError)
TRACE_ERROR(GetOssOriginatorPublicKeyAlgorithmError)
TRACE_ERROR(GetOssKeyEncryptionAlgorithmError)
TRACE_ERROR(GetOssIssuerAndSerialNumberError)
TRACE_ERROR(ConvFromGeneralizedTimeError)
TRACE_ERROR(GetOssOtherKeyAttributeError)
SET_ERROR(InvalidOriginatorChoice, CRYPT_E_BAD_ENCODE)
SET_ERROR(InvalidRecipientChoice, CRYPT_E_BAD_ENCODE)
}


//+-------------------------------------------------------------------------
//  Get Oss MailListRecipientInfo
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetOssMailListRecipientInfo(
    IN MailListRecipientInfo *pori,
    OUT PCMSG_MAIL_LIST_RECIPIENT_INFO *ppri,
    IN OUT BYTE **ppbExtra,
    IN OUT LONG *plRemainExtra
    )
{
    BOOL fRet;
    LONG lData;
    PCMSG_MAIL_LIST_RECIPIENT_INFO pri;
    MailListKeyIdentifier *pomlid;

    lData = INFO_LEN_ALIGN(sizeof(CMSG_MAIL_LIST_RECIPIENT_INFO));
    *plRemainExtra -= lData;
    if (0 <= *plRemainExtra) {
        pri = (PCMSG_MAIL_LIST_RECIPIENT_INFO) *ppbExtra;
        memset(pri, 0, sizeof(*pri));
        *ppri = pri;
        *ppbExtra += lData;

        pri->dwVersion = pori->version;
    } else {
        pri = NULL;
    }

    pomlid = &pori->mlid;
    ICM_GetOssOctetString(&pomlid->kekIdentifier, &pri->KeyId,
        ppbExtra, plRemainExtra);

    if (!ICM_GetOssAlgorithm(&pori->keyEncryptionAlgorithm,
            &pri->KeyEncryptionAlgorithm,
            ppbExtra, plRemainExtra))
        goto GetOssKeyEncryptionAlgorithmError;

    ICM_GetOssOctetString(&pori->encryptedKey, &pri->EncryptedKey,
        ppbExtra, plRemainExtra);


    if (pomlid->bit_mask & date_present) {
        if (0 <= *plRemainExtra) {
            if (!PkiAsn1FromGeneralizedTime(
                    &pomlid->date, &pri->Date))
                goto ConvFromGeneralizedTimeError;
        }
    }

    if (pomlid->bit_mask & other_present) {
        if (!ICM_GetOssOtherKeyAttribute(
                &pomlid->other,
                &pri->pOtherAttr,
                ppbExtra, plRemainExtra))
            goto GetOssOtherKeyAttributeError;
    }

    fRet = TRUE;
CommonReturn:
    return fRet;

ErrorReturn:
    fRet = FALSE;
    goto CommonReturn;

TRACE_ERROR(GetOssKeyEncryptionAlgorithmError)
TRACE_ERROR(ConvFromGeneralizedTimeError)
TRACE_ERROR(GetOssOtherKeyAttributeError)
}

//+-------------------------------------------------------------------------
//  Copy out a CMSG_CMS_RECIPIENT_INFO
//--------------------------------------------------------------------------
BOOL
WINAPI
ICM_GetCmsRecipientInfo(
    IN CmsRecipientInfo *pori,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fRet;
    LONG lData;
    PCMSG_CMS_RECIPIENT_INFO pri = (PCMSG_CMS_RECIPIENT_INFO) pvData;
    PBYTE pbExtra;
    LONG lRemainExtra;

    if (NULL == pvData)
        *pcbData = 0;

    // for lRemainExtra < 0, LENGTH_ONLY calculation
    lData = INFO_LEN_ALIGN(sizeof(CMSG_CMS_RECIPIENT_INFO));
    lRemainExtra = (LONG)*pcbData - lData;
    if (0 > lRemainExtra) {
        pri = NULL;
        pbExtra = NULL;
    } else {
        assert(CMSG_KEY_TRANS_RECIPIENT == keyTransRecipientInfo_chosen);
        assert(CMSG_KEY_AGREE_RECIPIENT == keyAgreeRecipientInfo_chosen);
        assert(CMSG_MAIL_LIST_RECIPIENT == mailListRecipientInfo_chosen);
        pri->dwRecipientChoice = pori->choice;

        pbExtra = (PBYTE) pri + lData;
    }

    switch (pori->choice) {
        case keyTransRecipientInfo_chosen:
            if (!ICM_GetOssKeyTransRecipientInfo(
                    &pori->u.keyTransRecipientInfo,
                    &pri->pKeyTrans,
                    &pbExtra, &lRemainExtra
                    ))
                goto GetOssKeyTransRecipientInfoError;
            break;
        case keyAgreeRecipientInfo_chosen:
            if (!ICM_GetOssKeyAgreeRecipientInfo(
                    &pori->u.keyAgreeRecipientInfo,
                    &pri->pKeyAgree,
                    &pbExtra, &lRemainExtra
                    ))
                goto GetOssKeyAgreeRecipientInfoError;
            break;
        case mailListRecipientInfo_chosen:
            if (!ICM_GetOssMailListRecipientInfo(
                    &pori->u.mailListRecipientInfo,
                    &pri->pMailList,
                    &pbExtra, &lRemainExtra
                    ))
                goto GetOssMailListRecipientInfoError;
            break;
        default:
            goto InvalidRecipientChoice;

    }

    fRet = ICM_GetSizeFromExtra(lRemainExtra, pvData, pcbData);

CommonReturn:
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
TRACE_ERROR(GetOssKeyTransRecipientInfoError)
TRACE_ERROR(GetOssKeyAgreeRecipientInfoError)
TRACE_ERROR(GetOssMailListRecipientInfoError)
SET_ERROR(InvalidRecipientChoice, CRYPT_E_BAD_ENCODE)
}
#endif  // CMS_PKCS7


//+-------------------------------------------------------------------------
//  Get a parameter after encoding/decoding a cryptographic message. Called
//  after the final CryptMsgUpdate. Only the CMSG_CONTENT_PARAM and
//  CMSG_COMPUTED_HASH_PARAM are valid for an encoded message.
//
//  For an encoded HASHED message, the CMSG_COMPUTED_HASH_PARAM can be got
//  before any CryptMsgUpdates to get its length.
//
//  The pvData type definition depends on the dwParamType value.
//
//  Elements pointed to by fields in the pvData structure follow the
//  structure. Therefore, *pcbData may exceed the size of the structure.
//
//  Upon input, if *pcbData == 0, then, *pcbData is updated with the length
//  of the data and the pvData parameter is ignored.
//
//  Upon return, *pcbData is updated with the length of the data.
//
//  The OBJID BLOBs returned in the pvData structures point to
//  their still encoded representation. The appropriate functions
//  must be called to decode the information.
//
//  See wincrypt.h for a list of the parameters to get.
//--------------------------------------------------------------------------
BOOL
WINAPI
#ifdef DEBUG_CRYPT_ASN1_MASTER
ICMTest_NewCryptMsgGetParam(
#else
CryptMsgGetParam(
#endif
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT void *pvData,
    IN OUT DWORD *pcbData)
{
    DWORD               dwError = ERROR_SUCCESS;
    BOOL                fRet;
    PCRYPT_MSG_INFO     pcmi = (PCRYPT_MSG_INFO)hCryptMsg;
    ASN1error_e         Asn1Err;
    PCMSG_STREAM_INFO   pcsi = pcmi->pStreamInfo;
    BOOL                fBER = FALSE;                

    DWORD dwExceptionCode;

    ICM_Lock( pcmi);    // Single thread access to HCRYPTMSG

  // Handle MappedFile Exceptions
  __try {

    if (NULL == pvData)
        *pcbData = 0;

#ifdef CMS_PKCS7
    if (CMSG_VERSION_PARAM == dwParamType) {
        int version = 0;

        switch (pcmi->dwMsgType) {
        case CMSG_SIGNED:
            if (pcmi->fEncoding) {
                if (NULL == pcmi->pvMsg)
                    goto InvalidMessageDataError;
                version = ((SignedData *)pcmi->pvMsg)->version;
            } else {
                if (NULL == pcmi->psdi)
                    goto MessageNotDecodedError;
                version = pcmi->psdi->version;
            }
            break;
        case CMSG_ENVELOPED:
            if (NULL == pcmi->pvMsg)
                goto MessageNotDecodedError;
            version = ((CmsEnvelopedData *)pcmi->pvMsg)->version;
            break;
        case CMSG_HASHED:
            if (NULL == pcmi->pvMsg)
                goto MessageNotDecodedError;
            version = ((DigestedData *)pcmi->pvMsg)->version;
            break;
        case CMSG_SIGNED_AND_ENVELOPED:
            goto MessageTypeNotSupportedYet;
        case CMSG_ENCRYPTED:
        case CMSG_DATA:
        default:
            goto InvalidMsgType;
        }

        fRet = ICM_GetDWORD(version, pvData, pcbData);
        goto PreserveLengthReturn;
    }
#endif  // CMS_PKCS7

    if (pcmi->fEncoding) {
        switch (dwParamType) {
        case CMSG_CONTENT_PARAM:
        case CMSG_BARE_CONTENT_PARAM:
            {
                ContentInfo     ci;
                ASN1encoding_t  pEnc = ICM_GetEncoder();
                PBYTE           pbEncoded = NULL;
                DWORD           cbEncoded;
                PBYTE           pbContent = NULL;

                if (pcsi)
                    goto GetContentParamNotValidForStreaming;

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (0 == ((SignedData *) pcmi->pvMsg)->signerInfos.count)
                        // For a bag of certs, don't DER order
                        fBER = TRUE;
                    break;
                case CMSG_DATA:
                case CMSG_ENVELOPED:
                case CMSG_HASHED:
                    break;
                case CMSG_SIGNED_AND_ENVELOPED:
                case CMSG_ENCRYPTED:
                    goto MessageTypeNotSupportedYet;
                default:
                    goto InvalidMsgType;
                }

                if (fBER)
                    PkiAsn1SetEncodingRule(ICM_GetEncoder(), ASN1_BER_RULE_BER);

                if (0 != (Asn1Err = PkiAsn1Encode(
                        pEnc,
                        pcmi->pvMsg,
                        aiPduNum[ pcmi->dwMsgType - 1],
                        &pbEncoded,
                        &cbEncoded))) {
                    goto CONTENT_PARAMAsn1EncodeError;
                }

                if (CMSG_CONTENT_PARAM == dwParamType) {
                    if (!ICM_CopyOssObjectIdentifier(
                            &ci.contentType,
                            &aoidMessages[ pcmi->dwMsgType - 1]))
                        goto CopyOssObjectIdentifierContentTypeError;
                    ci.bit_mask = content_present;
                    ci.content.length = cbEncoded;
                    ci.content.value = pbEncoded;
                    pbContent = pbEncoded;

                    if (0 != (Asn1Err = PkiAsn1Encode(
                            pEnc,
                            &ci,
                            ContentInfo_PDU,
                            &pbEncoded,
                            &cbEncoded))) {
                        PkiAsn1FreeEncoded(pEnc, pbContent);
                        goto Asn1EncodeSignedDataError;
                    }
                }

                fRet = ICM_CopyOut(
                            pbEncoded,
                            cbEncoded,
                            (PBYTE)pvData,
                            pcbData);
                if (!fRet)
                    dwError = GetLastError();
                if (pbContent)
                    PkiAsn1FreeEncoded(pEnc, pbContent);
                PkiAsn1FreeEncoded(pEnc, pbEncoded);
                if (!fRet)
                    SetLastError(dwError);
                break;
            }

        case CMSG_COMPUTED_HASH_PARAM:
            fRet = ICM_GetComputedDigestParam( pcmi, dwIndex, pvData, pcbData);
            break;

        case CMSG_ENCODED_SIGNER:
            switch (pcmi->dwMsgType) {
            case CMSG_SIGNED:
                break;
            case CMSG_SIGNED_AND_ENVELOPED:
                goto MessageTypeNotSupportedYet;
            default:
                goto InvalidMsgType;
            }
            fRet = ICM_GetSignerParamEncoding(
                            pcmi,
                            dwIndex,
                            dwParamType,
                            pvData,
                            pcbData);
            break;

        default:
            goto InvalidMsgType;
        }
    } else {
        //
        // Decode
        //
        switch (dwParamType) {
        case CMSG_TYPE_PARAM:
            if (pcsi && (0 == pcmi->dwMsgType))
                goto StreamMsgNotReadyError;
            fRet = ICM_GetDWORD( pcmi->dwMsgType, pvData, pcbData);
            break;
        case CMSG_CONTENT_PARAM:
            {
                ContentInfo     *pci;
                PCONTENT_INFO   pci2;
                PBYTE           pbDER = NULL;
                DWORD           cbDER;
                PBYTE           pb;
                DWORD           cb;

                if (pcsi)
                    goto GetContentParamNotValidForStreaming;

                switch (pcmi->dwMsgType) {
                case CMSG_DATA:
                {
                    OctetStringType *poos = (OctetStringType *)pcmi->pvMsg;

                    pb = (PBYTE)poos->value;
                    cb = poos->length;
                    fRet = ICM_CopyOut( pb, cb, (PBYTE)pvData, pcbData);
                    break;
                }
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    pci2 = pcmi->psdi->pci;
                    if (pci2->content.cbData) {
                        cb = pci2->content.cbData;
                        pb = pci2->content.pbData;

                        if (0 == strcmp(pszObjIdDataType,
                                pci2->pszContentType)
#ifdef CMS_PKCS7
                                ||  pcmi->psdi->version >= CMSG_SIGNED_DATA_CMS_VERSION 
#endif  // CMS_PKCS7
                                ) {
                            if (!ICM_ReEncodeAsOctetDER(
                                    pb,
                                    cb,
                                    &pbDER,
                                    &cbDER
                                    ))
                                goto ReEncodeAsOctetDERError;
                            if (pbDER) {
                                if (0 > Asn1UtilExtractContent( pbDER, cbDER,
                                        &cb, (const BYTE **)&pb)) {
                                    PkiAsn1FreeEncoded( ICM_GetEncoder(), pbDER);
                                    goto ExtractContentError;
                                }
                            }
                        }

                        fRet = ICM_CopyOut( pb, cb, (PBYTE)pvData, pcbData);
                        if (!fRet)
                            dwError = GetLastError();
                        if (pbDER)
                            PkiAsn1FreeEncoded( ICM_GetEncoder(), pbDER);
                        if (!fRet)
                            SetLastError(dwError);
                    } else {
                        *pcbData = 0;
                        fRet = TRUE;
                    }
                    break;
                case CMSG_ENVELOPED:
                    if (NULL == pcmi->Plaintext.pbData) {
                        // Hasn't been decrypted yet

                        EncryptedContentInfo *peci;
                        PBYTE pbCiphertext;
                        DWORD cbCiphertext;
#ifdef CMS_PKCS7
                        peci = &((CmsEnvelopedData *)pcmi->pvMsg)->encryptedContentInfo;
#else
                        peci = &((EnvelopedData *)pcmi->pvMsg)->encryptedContentInfo;
#endif  // CMS_PKCS7

                        if (peci->bit_mask & encryptedContent_present) {
                            pbCiphertext = peci->encryptedContent.value;
                            cbCiphertext = peci->encryptedContent.length;
                        } else {
                            pbCiphertext = NULL;
                            cbCiphertext = 0;
                        }


                        if (NULL == pvData) {
                            // Assume (sizeof plaintext) <=
                            // (sizeof ciphertext)
                            //
                            // not decrypted yet; return ciphertext size

                            fRet = TRUE;
                            // + 6 => to allow for identifier and length octets
                            *pcbData = cbCiphertext + 6;
                        } else
                            // Return ciphertext
                            fRet = ICM_CopyOut(
                                    pbCiphertext,
                                    cbCiphertext,
                                    (PBYTE)pvData,
                                    pcbData);
                        goto ContentCopiedOut;
                    }

                    if (!ICM_EqualObjectIDs(
#ifdef CMS_PKCS7
                            &((CmsEnvelopedData *)pcmi->pvMsg)->encryptedContentInfo.contentType,
                            &aoidMessages[ CMSG_DATA - 1])
                                    &&
                            CMSG_ENVELOPED_DATA_CMS_VERSION >
                                ((CmsEnvelopedData *)pcmi->pvMsg)->version) {
#else
                            &((EnvelopedData *)pcmi->pvMsg)->encryptedContentInfo.contentType,
                            &aoidMessages[ CMSG_DATA - 1])) {
#endif  // CMS_PKCS7
                        // Not DATA or encapsulated, so must prepend
                        // identifier and length octets
                        fRet = ICM_CopyOutAddDERPrefix(
                                    pcmi->Plaintext.pbData,
                                    pcmi->Plaintext.cbData,
                                    ICM_TAG_SEQ,
                                    (PBYTE)pvData,
                                    pcbData);
                    } else {
                        fRet = ICM_CopyOut(
                                    pcmi->Plaintext.pbData,
                                    pcmi->Plaintext.cbData,
                                    (PBYTE)pvData,
                                    pcbData);
                    }
                    goto ContentCopiedOut;

                case CMSG_HASHED:
                    pci = &((DigestedData *)pcmi->pvMsg)->contentInfo;
                    if (pci->bit_mask & content_present) {
                        cb = (DWORD)pci->content.length;
                        pb = (PBYTE)pci->content.value;

                        if (ICM_EqualObjectIDs(
                                    &pci->contentType,
                                    &aoidMessages[ CMSG_DATA - 1])
#ifdef CMS_PKCS7
                                || ((DigestedData *)pcmi->pvMsg)->version >=
                                    CMSG_HASHED_DATA_V2 
#endif  // CMS_PKCS7
                                ) {
                            if (!ICM_ReEncodeAsOctetDER(
                                    pb,
                                    cb,
                                    &pbDER,
                                    &cbDER
                                    ))
                                goto ReEncodeAsOctetDERError;
                            if (pbDER) {
                                if (0 > Asn1UtilExtractContent( pbDER, cbDER,
                                        &cb, (const BYTE **)&pb)) {
                                    PkiAsn1FreeEncoded( ICM_GetEncoder(), pbDER);
                                    goto ExtractContentError;
                                }
                            }
                        }

                        fRet = ICM_CopyOut( pb, cb, (PBYTE)pvData, pcbData);
                        if (!fRet)
                            dwError = GetLastError();
                        if (pbDER)
                            PkiAsn1FreeEncoded( ICM_GetEncoder(), pbDER);
                        if (!fRet)
                            SetLastError(dwError);
                    } else {
                        *pcbData = 0;
                        fRet = TRUE;
                    }
                    break;
                case CMSG_SIGNED_AND_ENVELOPED:
                case CMSG_ENCRYPTED:
                    goto MessageTypeNotSupportedYet;
                default:
                    goto InvalidMsgType;
                }
ContentCopiedOut:
                break;
            }

        case CMSG_INNER_CONTENT_TYPE_PARAM:
            {
                ContentType     *pct;

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    fRet = ICM_CopyOut(
                                (PBYTE)pcmi->psdi->pci->pszContentType,
                                strlen( pcmi->psdi->pci->pszContentType) + 1,
                                (PBYTE)pvData,
                                pcbData);
                    goto ContentTypeCopiedOut;
                    break;
                case CMSG_ENVELOPED:
#ifdef CMS_PKCS7
                    pct = &((CmsEnvelopedData *)pcmi->pvMsg)->encryptedContentInfo.contentType;
#else
                    pct = &((EnvelopedData *)pcmi->pvMsg)->encryptedContentInfo.contentType;
#endif  // CMS_PKCS7
                    break;
                case CMSG_HASHED:
                    pct = &((DigestedData *)pcmi->pvMsg)->contentInfo.contentType;
                    break;
                case CMSG_SIGNED_AND_ENVELOPED:
                case CMSG_ENCRYPTED:
                    goto MessageTypeNotSupportedYet;
                default:
                    goto InvalidMsgType;
                }
                fRet = PkiAsn1FromObjectIdentifier(
                            pct->count,
                            pct->value,
                            (LPSTR)pvData,
                            pcbData);
ContentTypeCopiedOut:
                break;
            }

        case CMSG_ENCODED_MESSAGE:
            fRet = ICM_GetEncodedMessageParam(
                            pcmi,
                            (PBYTE)pvData,
                            pcbData);
            break;

        case CMSG_SIGNER_COUNT_PARAM:
            {
                DWORD   cSigner;

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    cSigner = pcmi->psdi->pSignerList->Length();
                    break;
                case CMSG_SIGNED_AND_ENVELOPED:
                    goto MessageTypeNotSupportedYet;
                default:
                    goto InvalidMsgType;
                }
                fRet = ICM_GetDWORD( cSigner, pvData, pcbData);
                break;
            }

        case CMSG_ENCRYPTED_DIGEST:
        case CMSG_ENCODED_SIGNER:
        case CMSG_SIGNER_INFO_PARAM:
        case CMSG_SIGNER_CERT_INFO_PARAM:
        case CMSG_SIGNER_HASH_ALGORITHM_PARAM:
        case CMSG_SIGNER_AUTH_ATTR_PARAM:
        case CMSG_SIGNER_UNAUTH_ATTR_PARAM:

        case CMSG_CMS_SIGNER_INFO_PARAM:
        case CMSG_SIGNER_CERT_ID_PARAM:

            switch (pcmi->dwMsgType) {
            case CMSG_SIGNED:
                break;
            case CMSG_SIGNED_AND_ENVELOPED:
                goto MessageTypeNotSupportedYet;
            default:
                goto InvalidMsgType;
            }
            fRet = ICM_GetSignerParam(
                            pcmi,
                            dwIndex,
                            dwParamType,
                            pvData,
                            pcbData);
            break;

        case CMSG_CERT_COUNT_PARAM:
            {
                CBlobList *pBlobList;
                DWORD     dwCount;
#ifdef CMS_PKCS7
                BOOL      fPossibleAttrCert = FALSE;
#endif  // CMS_PKCS7

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    pBlobList = pcmi->psdi->pCertificateList;
#ifdef CMS_PKCS7
                    if (pcmi->psdi->version >= CMSG_SIGNED_DATA_CMS_VERSION)
                        fPossibleAttrCert = TRUE;
#endif  // CMS_PKCS7
                    break;
#ifdef CMS_PKCS7
                case CMSG_ENVELOPED:
                    pBlobList = pcmi->pCertificateList;
                    fPossibleAttrCert = TRUE;
                    break;
#endif  // CMS_PKCS7
                case CMSG_SIGNED_AND_ENVELOPED:
                    goto MessageTypeNotSupportedYet;
                default:
                    goto InvalidMsgType;
                }

                dwCount = pBlobList->Length();

#ifdef CMS_PKCS7
                if (dwCount && fPossibleAttrCert)
                    dwCount = ICM_GetTaggedBlobCount(
                        pBlobList,
                        ICM_TAG_SEQ
                        );
#endif  // CMS_PKCS7

                fRet = ICM_GetDWORD( dwCount, pvData, pcbData);
                break;
            }

        case CMSG_CERT_PARAM:
            {
                CBlobList   *pBlobList;
                CBlobNode   *pBlobNode;
#ifdef CMS_PKCS7
                BOOL        fPossibleAttrCert = FALSE;
#endif  // CMS_PKCS7

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    pBlobList = pcmi->psdi->pCertificateList;
#ifdef CMS_PKCS7
                    if (pcmi->psdi->version >= CMSG_SIGNED_DATA_CMS_VERSION)
                        fPossibleAttrCert = TRUE;
#endif  // CMS_PKCS7
                    break;
#ifdef CMS_PKCS7
                case CMSG_ENVELOPED:
                    pBlobList = pcmi->pCertificateList;
                    fPossibleAttrCert = TRUE;
                    break;
#endif  // CMS_PKCS7
                case CMSG_SIGNED_AND_ENVELOPED:
                    goto MessageTypeNotSupportedYet;
                default:
                    goto InvalidMsgType;
                }

                // Get blob at specified cert index. Index
                // is advanced to the appropriate blob.
                pBlobNode = ICM_GetTaggedBlobAndAdvanceIndex(
                    pBlobList,
#ifdef CMS_PKCS7
                    (BYTE)( fPossibleAttrCert ? ICM_TAG_SEQ : 0),
#else
                    0,                  // bTag
#endif  // CMS_PKCS7
                    &dwIndex
                    );
                    
                if (pBlobNode)
                    fRet = ICM_CopyOut(
                                pBlobNode->Data()->pbData,
                                pBlobNode->Data()->cbData,
                                (PBYTE)pvData,
                                pcbData);
                else
                    fRet = FALSE;
                break;
            }

#ifdef CMS_PKCS7
        case CMSG_ATTR_CERT_COUNT_PARAM:
            {
                CBlobList *pBlobList;
                BOOL      fPossibleAttrCert = FALSE;
                DWORD     dwCount;

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    pBlobList = pcmi->psdi->pCertificateList;
                    if (pcmi->psdi->version >= CMSG_SIGNED_DATA_CMS_VERSION)
                        fPossibleAttrCert = TRUE;
                    break;
                case CMSG_ENVELOPED:
                    pBlobList = pcmi->pCertificateList;
                    fPossibleAttrCert = TRUE;
                    break;
                default:
                    goto InvalidMsgType;
                }

                if (fPossibleAttrCert)
                    dwCount = ICM_GetTaggedBlobCount(
                        pBlobList,
                        ICM_TAG_CONSTRUCTED_CONTEXT_1
                        );
                else
                    dwCount = 0;

                fRet = ICM_GetDWORD( dwCount, pvData, pcbData);
                break;
            }

        case CMSG_ATTR_CERT_PARAM:
            {
                CBlobList   *pBlobList;
                CBlobNode   *pBlobNode;
                BOOL        fPossibleAttrCert = FALSE;

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    pBlobList = pcmi->psdi->pCertificateList;
                    if (pcmi->psdi->version >= CMSG_SIGNED_DATA_CMS_VERSION)
                        fPossibleAttrCert = TRUE;
                    break;
                case CMSG_ENVELOPED:
                    pBlobList = pcmi->pCertificateList;
                    fPossibleAttrCert = TRUE;
                    break;
                default:
                    goto InvalidMsgType;
                }

                if (!fPossibleAttrCert)
                    pBlobNode = NULL;
                else
                    // Get blob at specified attribute cert index. Index
                    // is advanced to the appropriate blob
                    pBlobNode = ICM_GetTaggedBlobAndAdvanceIndex(
                        pBlobList,
                        ICM_TAG_CONSTRUCTED_CONTEXT_1,
                        &dwIndex
                        );
                    
                if (pBlobNode) {
                    fRet = ICM_CopyOut(
                                pBlobNode->Data()->pbData,
                                pBlobNode->Data()->cbData,
                                (PBYTE)pvData,
                                pcbData);
                    if (fRet && pvData)
                        *((PBYTE)pvData) = ICM_TAG_SEQ;
                } else
                    fRet = FALSE;
                break;
            }
#endif  // CMS_PKCS7

        case CMSG_CRL_COUNT_PARAM:
            {
                CBlobList *pBlobList;

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    pBlobList = pcmi->psdi->pCrlList;
                    break;
#ifdef CMS_PKCS7
                case CMSG_ENVELOPED:
                    pBlobList = pcmi->pCrlList;
                    break;
#endif  // CMS_PKCS7
                case CMSG_SIGNED_AND_ENVELOPED:
                    goto MessageTypeNotSupportedYet;
                default:
                    goto InvalidMsgType;
                }
                fRet = ICM_GetDWORD( pBlobList->Length(), pvData, pcbData);
                break;
            }

        case CMSG_CRL_PARAM:
            {
                CBlobList   *pBlobList;
                CBlobNode   *pBlobNode;
                DWORD       i;

                switch (pcmi->dwMsgType) {
                case CMSG_SIGNED:
                    if (NULL == pcmi->psdi)
                        goto InvalidSignedMessageError;
                    pBlobList = pcmi->psdi->pCrlList;
                    break;
#ifdef CMS_PKCS7
                case CMSG_ENVELOPED:
                    pBlobList = pcmi->pCrlList;
                    break;
#endif  // CMS_PKCS7
                case CMSG_SIGNED_AND_ENVELOPED:
                    goto MessageTypeNotSupportedYet;
                default:
                    goto InvalidMsgType;
                }

                // This list-walking should be a class method
                for (i=dwIndex, pBlobNode=pBlobList->Head();
                        (i>0) && pBlobNode;
                        i--, pBlobNode=pBlobNode->Next())
                    ;
                if (pBlobNode)
                    fRet = ICM_CopyOut(
                                pBlobNode->Data()->pbData,
                                pBlobNode->Data()->cbData,
                                (PBYTE)pvData,
                                pcbData);
                else
                    fRet = FALSE;
                break;
            }

        case CMSG_ENVELOPE_ALGORITHM_PARAM:
            {
                ContentEncryptionAlgId  *pceai;

                if (pcsi &&
                        (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_ECIALGID)))
                    goto StreamMsgNotReadyError;

                switch (pcmi->dwMsgType) {
                case CMSG_ENVELOPED:
#ifdef CMS_PKCS7
                    pceai = &((CmsEnvelopedData *)pcmi->pvMsg)->encryptedContentInfo.contentEncryptionAlgorithm;
#else
                    pceai = &((EnvelopedData *)pcmi->pvMsg)->encryptedContentInfo.contentEncryptionAlgorithm;
#endif  // CMS_PKCS7
                    break;

                case CMSG_SIGNED_AND_ENVELOPED:
                    goto MessageTypeNotSupportedYet;

                default:
                    goto InvalidMsgType;
                }

                fRet = ICM_GetALGORITHM_IDENTIFIER( pceai, pvData, pcbData);
                break;
            }

#ifdef CMS_PKCS7
        case CMSG_UNPROTECTED_ATTR_PARAM:
            {
                CmsEnvelopedData *ped;

                ped = (CmsEnvelopedData *)pcmi->pvMsg;
                if (ped && (ped->bit_mask & unprotectedAttrs_present))
                    fRet = ICM_GetAttributesData(
                        &ped->unprotectedAttrs,
                        pvData,
                        pcbData);
                else
                    goto UnprotectedAttrMissingError;
            }
            break;

        case CMSG_RECIPIENT_COUNT_PARAM:
            {
                DWORD dwPkcsCount;
                if (!ICM_GetPkcsRecipientCount(pcmi, &dwPkcsCount))
                    goto GetPkcsRecipientCountError;
                fRet = ICM_GetDWORD(dwPkcsCount, pvData, pcbData);
            }
            break;

        case CMSG_RECIPIENT_INDEX_PARAM:
            {
                DWORD dwPkcsIndex;
                DWORD dwCmsIndex;
                DWORD cbData = sizeof(dwCmsIndex);

                if (!CryptMsgGetParam(
                        hCryptMsg,
                        CMSG_CMS_RECIPIENT_INDEX_PARAM,
                        0,                                  // dwIndex
                        &dwCmsIndex,
                        &cbData))
                    goto GetCmsRecipientIndexError;

                if (!ICM_ConvertCmsToPkcsRecipientIndex(
                        pcmi, dwCmsIndex, &dwPkcsIndex))
                    goto ConvertCmsToPkcsRecipientIndexError;

                fRet = ICM_GetDWORD(
                            dwPkcsIndex,
                            pvData,
                            pcbData);
            }
            break;

        case CMSG_RECIPIENT_INFO_PARAM:
            {
                CmsRecipientInfos *pris;
                KeyTransRecipientInfo *pri;
                DWORD dwCmsIndex;

                if (NULL == (pris = ICM_GetDecodedCmsRecipientInfos(pcmi)))
                    goto GetDecodedCmsRecipientsError;

                if (!ICM_ConvertPkcsToCmsRecipientIndex(
                        pcmi, dwIndex, &dwCmsIndex))
                    goto ConvertPkcsToCmsRecipientIndexError;
                pri = &pris->value[dwCmsIndex].u.keyTransRecipientInfo;

                fRet = ICM_GetCertInfoIssuerAndSerialNumber(
                    &pri->rid, pvData, pcbData);
                break;
            }

        case CMSG_CMS_RECIPIENT_COUNT_PARAM:
            {
                CmsRecipientInfos *pris;

                if (NULL == (pris = ICM_GetDecodedCmsRecipientInfos(pcmi)))
                    goto GetDecodedCmsRecipientsError;
                fRet = ICM_GetDWORD(pris->count, pvData, pcbData);
            }
            break;

        case CMSG_CMS_RECIPIENT_INDEX_PARAM:
            {
                CmsRecipientInfos *pris;

                if (NULL == (pris = ICM_GetDecodedCmsRecipientInfos(pcmi)))
                    goto GetDecodedCmsRecipientsError;
                fRet = ICM_GetDWORD(
                            pcmi->dwDecryptedRecipientIndex,
                            pvData,
                            pcbData);
            }
            break;

        case CMSG_CMS_RECIPIENT_ENCRYPTED_KEY_INDEX_PARAM:
            {
                CmsRecipientInfos *pris;
                CmsRecipientInfo *pri;

                if (NULL == (pris = ICM_GetDecodedCmsRecipientInfos(pcmi)))
                    goto GetDecodedCmsRecipientsError;

                pri = pris->value + pcmi->dwDecryptedRecipientIndex;
                if (keyAgreeRecipientInfo_chosen != pri->choice)
                    goto NotKeyAgreeRecipientIndex;
                
                fRet = ICM_GetDWORD(
                            pcmi->dwDecryptedRecipientEncryptedKeyIndex,
                            pvData,
                            pcbData);
            }
            break;

        case CMSG_CMS_RECIPIENT_INFO_PARAM:
            {
                CmsRecipientInfos *pris;

                if (NULL == (pris = ICM_GetDecodedCmsRecipientInfos(pcmi)))
                    goto GetDecodedCmsRecipientsError;
                if (dwIndex >= pris->count)
                    goto IndexTooBig;
                fRet = ICM_GetCmsRecipientInfo(pris->value + dwIndex,
                    pvData, pcbData);
            }
            break;
#else

        case CMSG_RECIPIENT_COUNT_PARAM:
            {
                RecipientInfos *pris;

                if (pcsi &&
                        (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_RECIPINFOS)))
                    goto StreamMsgNotReadyError;

                switch (pcmi->dwMsgType) {
                case CMSG_ENVELOPED:
                    pris = &((EnvelopedData *)pcmi->pvMsg)->recipientInfos;
                    break;

                case CMSG_SIGNED_AND_ENVELOPED:
                    goto MessageTypeNotSupportedYet;

                default:
                    goto InvalidMsgType;
                }

                fRet = ICM_GetDWORD( pris->count, pvData, pcbData);
                break;
            }

        case CMSG_RECIPIENT_INDEX_PARAM:
            {
                if (pcsi &&
                        (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_RECIPINFOS)))
                    goto StreamMsgNotReadyError;

                switch (pcmi->dwMsgType) {
                case CMSG_ENVELOPED:
                case CMSG_SIGNED_AND_ENVELOPED:
                    break;

                default:
                    goto InvalidMsgType;
                }

                fRet = ICM_GetDWORD(
                            pcmi->dwDecryptedRecipientIndex,
                            pvData,
                            pcbData);
                break;
            }

        case CMSG_RECIPIENT_INFO_PARAM:
            {
                RecipientInfos *pris;
                RecipientInfo  *pri;
                PCERT_INFO      pci = (PCERT_INFO)pvData;

                if (pcsi &&
                        (0 == (pcmi->aflDecode & ICMS_DECODED_ENVELOPED_RECIPINFOS)))
                    goto StreamMsgNotReadyError;

                switch (pcmi->dwMsgType) {
                case CMSG_ENVELOPED:
                    pris = &((EnvelopedData *)pcmi->pvMsg)->recipientInfos;
                    if (dwIndex >= pris->count)
                        goto IndexTooBig;
                    pri = pris->value + dwIndex;
                    break;

                case CMSG_SIGNED_AND_ENVELOPED:
                    goto MessageTypeNotSupportedYet;

                default:
                    goto InvalidMsgType;
                }

                // for lRemainExtra < 0, LENGTH_ONLY calculation
                lData = INFO_LEN_ALIGN( sizeof(CERT_INFO));
                lRemainExtra = (LONG)*pcbData - lData;
                if (0 > lRemainExtra) {
                    pci = NULL;
                    pbExtra = NULL;
                } else {
                    pbExtra = (PBYTE)pci + lData;
                }
                if (!ICM_GetOssIssuerAndSerialNumber(
                        &pri->issuerAndSerialNumber,
                        pci, &pbExtra, &lRemainExtra))
                    goto GetOssIssuerAndSerialNumberError;
                fRet = ICM_GetSizeFromExtra( lRemainExtra, pvData, pcbData);
                break;
            }
#endif  // CMS_PKCS7

        case CMSG_HASH_ALGORITHM_PARAM:
            fRet = ICM_GetALGORITHM_IDENTIFIER(
                            &((DigestedData *)pcmi->pvMsg)->digestAlgorithm,
                            pvData,
                            pcbData);
            break;

        case CMSG_HASH_DATA_PARAM:
            fRet = ICM_GetDigestDataParam( pcmi, pvData, pcbData);
            break;

        case CMSG_COMPUTED_HASH_PARAM:
            fRet = ICM_GetComputedDigestParam( pcmi, dwIndex, pvData, pcbData);
            break;

        case CMSG_ENCRYPT_PARAM:
#if 0
            {
                goto ParamTypeNotSupportedYet;
            }
#endif
        default:
            goto InvalidMsgType;
        }
    }

#ifdef CMS_PKCS7
PreserveLengthReturn:
#endif  // CMS_PKCS7

    if (!fRet)
        dwError = GetLastError();

  } __except(EXCEPTION_EXECUTE_HANDLER) {
    dwExceptionCode = GetExceptionCode();
    goto ExceptionError;
  }

CommonReturn:
    if (fBER)
        PkiAsn1SetEncodingRule(ICM_GetEncoder(), ASN1_BER_RULE_DER);

    ICM_Unlock( pcmi);
    ICM_SetLastError(dwError);
    return fRet;

ErrorReturn:
    *pcbData = 0;
    fRet = FALSE;
    goto CommonReturn;
StreamMsgNotReadyError:
    dwError = (DWORD)CRYPT_E_STREAM_MSG_NOT_READY;
    goto ErrorReturn;
SET_ERROR(GetContentParamNotValidForStreaming, E_INVALIDARG)
SET_ERROR(IndexTooBig,CRYPT_E_INVALID_INDEX)
SET_ERROR(MessageTypeNotSupportedYet,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(InvalidMsgType,CRYPT_E_INVALID_MSG_TYPE)
SET_ERROR(ExtractContentError,CRYPT_E_UNEXPECTED_ENCODING)
SET_ERROR_VAR(CONTENT_PARAMAsn1EncodeError, PkiAsn1ErrToHr(Asn1Err))
SET_ERROR_VAR(Asn1EncodeSignedDataError, PkiAsn1ErrToHr(Asn1Err))
TRACE_ERROR(CopyOssObjectIdentifierContentTypeError)    // error already set
TRACE_ERROR(ReEncodeAsOctetDERError)                    // error already set
SET_ERROR(InvalidSignedMessageError, ERROR_INVALID_DATA)
#ifdef CMS_PKCS7
SET_ERROR(MessageNotDecodedError, ERROR_INVALID_DATA)
SET_ERROR(InvalidMessageDataError, ERROR_INVALID_DATA)

TRACE_ERROR(GetDecodedCmsRecipientsError)
TRACE_ERROR(GetPkcsRecipientCountError)
TRACE_ERROR(ConvertCmsToPkcsRecipientIndexError)
TRACE_ERROR(ConvertPkcsToCmsRecipientIndexError)
TRACE_ERROR(GetCmsRecipientIndexError)
SET_ERROR(NotKeyAgreeRecipientIndex, CRYPT_E_INVALID_INDEX)
SET_ERROR(UnprotectedAttrMissingError,CRYPT_E_ATTRIBUTES_MISSING)
#else
TRACE_ERROR(GetOssIssuerAndSerialNumberError)           // error already set
#endif  // CMS_PKCS7
SET_ERROR_VAR(ExceptionError, dwExceptionCode)
}


//+=========================================================================
//  Data structures and functions to test and compare the NEW Net Meeting
//  ASN1 compiler and RTS with the OSS compiler and RTS.
//-=========================================================================

#ifdef DEBUG_CRYPT_ASN1

//#define DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG              0x010
//#define DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG      0x020
//#define DEBUG_OSS_CRYPT_ASN1_SAME_ENCRYPT_FLAG      0x100

//static BOOL fGotDebugCryptAsn1Flags = FALSE;
//static int iDebugCryptAsn1Flags = 0;

#ifdef DEBUG_CRYPT_ASN1_MASTER

typedef HCRYPTMSG (WINAPI *PFN_CRYPT_MSG_OPEN_TO_ENCODE)(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN void const *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo
    );
static PFN_CRYPT_MSG_OPEN_TO_ENCODE pfnOssCryptMsgOpenToEncode = NULL;

typedef HCRYPTMSG (WINAPI *PFN_CRYPT_MSG_OPEN_TO_DECODE)(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN HCRYPTPROV hCryptProv,
    IN OPTIONAL PCERT_INFO pRecipientInfo,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo
    );
static PFN_CRYPT_MSG_OPEN_TO_DECODE pfnOssCryptMsgOpenToDecode = NULL;

typedef HCRYPTMSG (WINAPI *PFN_CRYPT_MSG_DUPLICATE)(
    IN HCRYPTMSG hCryptMsg
    );
static PFN_CRYPT_MSG_DUPLICATE pfnOssCryptMsgDuplicate = NULL;

typedef BOOL (WINAPI *PFN_CRYPT_MSG_CLOSE)(
    IN HCRYPTMSG hCryptMsg
    );
static PFN_CRYPT_MSG_CLOSE pfnOssCryptMsgClose = NULL;

typedef BOOL (WINAPI *PFN_CRYPT_MSG_UPDATE)(
    IN HCRYPTMSG hCryptMsg,
    IN const BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal
    );
static PFN_CRYPT_MSG_UPDATE pfnOssCryptMsgUpdate = NULL;

typedef BOOL (WINAPI *PFN_CRYPT_MSG_GET_PARAM)(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    );
static PFN_CRYPT_MSG_GET_PARAM pfnOssCryptMsgGetParam = NULL;

typedef BOOL (WINAPI *PFN_CRYPT_MSG_CONTROL)(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwFlags,
    IN DWORD dwCtrlType,
    IN void const *pvCtrlPara
    );
static PFN_CRYPT_MSG_CONTROL pfnOssCryptMsgControl = NULL;


#ifdef CMS_PKCS7

typedef BOOL (WINAPI *PFN_CRYPT_MSG_VERIFY_COUNTERSIGNATURE_ENCODED_EX)(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwEncodingType,
    IN PBYTE        pbSignerInfo,
    IN DWORD        cbSignerInfo,
    IN PBYTE        pbSignerInfoCountersignature,
    IN DWORD        cbSignerInfoCountersignature,
    IN DWORD        dwSignerType,
    IN void         *pvSigner,
    IN DWORD        dwFlags,
    IN OPTIONAL void *pvReserved
    );
static PFN_CRYPT_MSG_VERIFY_COUNTERSIGNATURE_ENCODED_EX
            pfnOssCryptMsgVerifyCountersignatureEncodedEx = NULL;

#endif  // CMS_PKCS7

typedef BOOL (WINAPI *PFN_CRYPT_MSG_COUNTERSIGN)(
    IN OUT HCRYPTMSG            hCryptMsg,
    IN DWORD                    dwIndex,
    IN DWORD                    cCountersigners,
    IN PCMSG_SIGNER_ENCODE_INFO rgCountersigners
    );
static PFN_CRYPT_MSG_COUNTERSIGN pfnOssCryptMsgCountersign = NULL;

typedef BOOL (WINAPI *PFN_CRYPT_MSG_COUNTERSIGN_ENCODED)(
    IN DWORD                    dwEncodingType,
    IN PBYTE                    pbSignerInfo,
    IN DWORD                    cbSignerInfo,
    IN DWORD                    cCountersigners,
    IN PCMSG_SIGNER_ENCODE_INFO rgCountersigners,
    OUT PBYTE                   pbCountersignature,
    IN OUT PDWORD               pcbCountersignature
    );
static PFN_CRYPT_MSG_COUNTERSIGN_ENCODED
            pfnOssCryptMsgCountersignEncoded = NULL;

#endif  // DEBUG_CRYPT_ASN1_MASTER


int
WINAPI
ICMTest_GetDebugCryptAsn1Flags()
{
    if (!fGotDebugCryptAsn1Flags) {
        char    *pszEnvVar;
        char    *p;
        int     iFlags;

        if (pszEnvVar = getenv("DEBUG_CRYPT_ASN1_FLAGS")) {
            iFlags = strtol(pszEnvVar, &p, 16);
#ifdef DEBUG_CRYPT_ASN1_MASTER
            if (iFlags) {
                if (NULL == (hOssCryptDll = LoadLibraryA("osscrypt.dll"))) {
                    iFlags = 0;
                    MessageBoxA(
                        NULL,           // hwndOwner
                        "LoadLibrary(osscrypt.dll) failed",
                        "CheckCryptMessageAsn1",
                        MB_TOPMOST | MB_OK | MB_ICONWARNING |
                            MB_SERVICE_NOTIFICATION
                        );
                } else if (NULL == (pfnOssCryptMsgOpenToEncode = 
                            (PFN_CRYPT_MSG_OPEN_TO_ENCODE) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgOpenToEncode")) ||
                        NULL == (pfnOssCryptMsgOpenToDecode = 
                            (PFN_CRYPT_MSG_OPEN_TO_DECODE) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgOpenToDecode")) ||
                        NULL == (pfnOssCryptMsgDuplicate = 
                            (PFN_CRYPT_MSG_DUPLICATE) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgDuplicate")) ||
                        NULL == (pfnOssCryptMsgClose = 
                            (PFN_CRYPT_MSG_CLOSE) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgClose")) ||
                        NULL == (pfnOssCryptMsgUpdate = 
                            (PFN_CRYPT_MSG_UPDATE) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgUpdate")) ||
                        NULL == (pfnOssCryptMsgControl = 
                            (PFN_CRYPT_MSG_CONTROL) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgControl")) ||
                        NULL == (pfnOssCryptMsgGetParam = 
                            (PFN_CRYPT_MSG_GET_PARAM) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgGetParam")) ||
#ifdef CMS_PKCS7
                        NULL == (pfnOssCryptMsgVerifyCountersignatureEncodedEx = 
                            (PFN_CRYPT_MSG_VERIFY_COUNTERSIGNATURE_ENCODED_EX) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgVerifyCountersignatureEncodedEx"))
                                        ||
#endif  // CMS_PKCS7
                        NULL == (pfnOssCryptMsgCountersign = 
                            (PFN_CRYPT_MSG_COUNTERSIGN) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgCountersign")) ||
                        NULL == (pfnOssCryptMsgCountersignEncoded = 
                            (PFN_CRYPT_MSG_COUNTERSIGN_ENCODED) 
                                GetProcAddress(hOssCryptDll,
                                    "CryptMsgCountersignEncoded"))) {
                    iFlags = 0;
                    MessageBoxA(
                        NULL,           // hwndOwner
                        "GetProcAddress(osscrypt.dll) failed",
                        "CheckCryptMessageAsn1",
                        MB_TOPMOST | MB_OK | MB_ICONWARNING |
                            MB_SERVICE_NOTIFICATION
                        );
                }
            }
#endif  // DEBUG_CRYPT_ASN1_MASTER
        } else
            iFlags = 0;

        if (iFlags & DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG)
            iFlags &= ~DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG;

        iDebugCryptAsn1Flags = iFlags;
        fGotDebugCryptAsn1Flags = TRUE;
    }
    return iDebugCryptAsn1Flags;
}

HCRYPTKEY
ICMTest_GetSameEncryptKey()
{
    DWORD dwError = 0;
    HCRYPTPROV hCryptProv;                // doesn't need to be freed
    HCRYPTHASH hHash = 0;
    HCRYPTKEY hDeriveKey = 0;
    BYTE rgbBaseData[] = {1,2,3,4,5,6,7,8};

    hCryptProv = I_CryptGetDefaultCryptProvForEncrypt(
        0,          // aiPubKey
        CALG_RC2,
        0           // dwBitLen
        );

    if (0 == hCryptProv)
        goto GetDefaultCryptProvError;

    if (!CryptCreateHash(hCryptProv, CALG_SHA1, 0, 0, &hHash))
        goto CreateHashError;
    if (!CryptHashData(hHash, rgbBaseData, sizeof(rgbBaseData), 0))
        goto HashDataError;
    if (!CryptDeriveKey(hCryptProv, CALG_RC2, hHash, 0, &hDeriveKey))
        goto DeriveKeyError;

CommonReturn:
    if (hHash)
        CryptDestroyHash(hHash);
    ICM_SetLastError(dwError);
    return hDeriveKey;
ErrorReturn:
    dwError = GetLastError();
    if (hDeriveKey) {
        CryptDestroyKey(hDeriveKey);
        hDeriveKey = 0;
    }
    goto CommonReturn;

TRACE_ERROR(GetDefaultCryptProvError)
TRACE_ERROR(CreateHashError)
TRACE_ERROR(HashDataError)
TRACE_ERROR(DeriveKeyError)
}

#ifdef CMS_PKCS7

BOOL
WINAPI
ICM_DefaultGenContentEncryptKey(
    IN OUT PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    int iOssAsn1Flags = ICMTest_GetDebugCryptAsn1Flags();

    if (0 == (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_SAME_ENCRYPT_FLAG))
        return ICMTest_DefaultGenContentEncryptKey(
            pContentEncryptInfo,
            dwFlags,
            pvReserved
            );

    pContentEncryptInfo->hContentEncryptKey = ICMTest_GetSameEncryptKey();
    if (pContentEncryptInfo->hContentEncryptKey)
        return TRUE;
    else
        return FALSE;
}

BOOL
WINAPI
ICM_DefaultExportKeyTrans(
    IN PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
    IN PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTransEncodeInfo,
    IN OUT PCMSG_KEY_TRANS_ENCRYPT_INFO pKeyTransEncryptInfo,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    int iOssAsn1Flags = ICMTest_GetDebugCryptAsn1Flags();
    PCRYPT_DATA_BLOB pEncryptedKey;
    BYTE rgbEncryptedKey[] = {1,1,2,2,3,3,4,4,5,5};

    if (0 == (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_SAME_ENCRYPT_FLAG))
        return ICMTest_DefaultExportKeyTrans(
            pContentEncryptInfo,
            pKeyTransEncodeInfo,
            pKeyTransEncryptInfo,
            dwFlags,
            pvReserved
            );

    pEncryptedKey = &pKeyTransEncryptInfo->EncryptedKey;
    if (NULL == (pEncryptedKey->pbData = (PBYTE) ICM_Alloc(
            sizeof(rgbEncryptedKey))))
        return FALSE;
    pEncryptedKey->cbData = sizeof(rgbEncryptedKey);
    memcpy(pEncryptedKey->pbData, rgbEncryptedKey, sizeof(rgbEncryptedKey));
    return TRUE;
}

BOOL
WINAPI
ICM_DefaultImportKeyTrans(
    IN PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
    IN PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA pKeyTransDecryptPara,
    IN DWORD dwFlags,
    IN OPTIONAL void *pvReserved,
    OUT HCRYPTKEY *phContentEncryptKey
    )
{
    int iOssAsn1Flags = ICMTest_GetDebugCryptAsn1Flags();

    if (0 == (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_SAME_ENCRYPT_FLAG))
        return ICMTest_DefaultImportKeyTrans(
            pContentEncryptionAlgorithm,
            pKeyTransDecryptPara,
            dwFlags,
            pvReserved,
            phContentEncryptKey
            );
    *phContentEncryptKey = ICMTest_GetSameEncryptKey();
    if (*phContentEncryptKey)
        return TRUE;
    else
        return FALSE;
}

#endif  // CMS_PKCS7


#ifdef DEBUG_CRYPT_ASN1_MASTER

void
ICMTest_MessageBox(
    IN LPSTR pszText
    )
{
    int id;
    LPSTR pszAlloc = NULL;
    DWORD cchAlloc;

    static LPCSTR pszSelect =
        " Select Cancel to stop future OssCryptAsn1 Cryptographic Messages.";

    cchAlloc = strlen(pszText) + strlen(pszSelect) + 1;

    if (pszAlloc = (LPSTR) ICM_Alloc(cchAlloc)) {
        strcpy(pszAlloc, pszText);
        strcat(pszAlloc, pszSelect);
        pszText = pszAlloc;
    }

    id = MessageBoxA(
        NULL,           // hwndOwner
        pszText,
        "CheckCryptMessageAsn1",
        MB_TOPMOST | MB_OKCANCEL | MB_ICONQUESTION |
            MB_SERVICE_NOTIFICATION
        );
    if (IDCANCEL == id)
        iDebugCryptAsn1Flags = 0;

    ICM_Free(pszAlloc);
}

void
ICMTest_MessageBoxLastError(
    IN LPSTR pszText,
    IN DWORD dwOssErr,
    IN DWORD dwNewErr
    )
{
    char szText[512];

    if (dwNewErr == (DWORD) PkiAsn1ErrToHr(ASN1_ERR_BADTAG) &&
            (OSS_DATA_ERROR == dwOssErr || OSS_PDU_MISMATCH == dwOssErr))
        return;
    if (dwNewErr == (DWORD) PkiAsn1ErrToHr(ASN1_ERR_EOD) &&
            OSS_MORE_INPUT == dwOssErr)
        return;

    wsprintfA(szText,
        "%s:: failed with different LastError Oss: %d 0x%x New: %d 0x%x.",
        pszText, dwOssErr, dwOssErr, dwNewErr, dwNewErr
        );
    ICMTest_MessageBox(szText);
}

//+-------------------------------------------------------------------------
//  Write an encoded DER blob to a file
//--------------------------------------------------------------------------
BOOL
ICMTest_WriteDERToFile(
    LPCSTR  pszFileName,
    PBYTE   pbDER,
    DWORD   cbDER
    )
{
    BOOL fResult;

    // Write the Encoded Blob to the file
    HANDLE hFile;
    hFile = CreateFile(pszFileName,
                GENERIC_WRITE,
                0,                  // fdwShareMode
                NULL,               // lpsa
                CREATE_ALWAYS,
                0,                  // fdwAttrsAndFlags
                0);                 // TemplateFile
    if (INVALID_HANDLE_VALUE == hFile) {
        fResult = FALSE;
    } else {
        DWORD dwBytesWritten;
        fResult = WriteFile(
                hFile,
                pbDER,
                cbDER,
                &dwBytesWritten,
                NULL            // lpOverlapped
                );
        CloseHandle(hFile);
    }
    return fResult;
}


#define TEST_MAGIC -12348765

// Note, in the following data structure lMagic is at the same offest as
// lRefCnt in CRYPT_MSG_INFO. lRefCnt should never be negative.
typedef struct _OSS_CRYPT_ASN1_MSG_INFO {
    // The following must be ordered the same as CRYPT_MSG_INFO through
    // dwEncodingType. msghlpr.cpp does a (PCRYPT_MSG_INFO) cast to
    // access dwEncodingType.
    CRITICAL_SECTION        CriticalSection;
    LONG                    lMagic;             // lRefCnt in CRYPT_MSG_INFO
    HCRYPTPROV              hCryptProv;         // decode
    BOOL                    fDefaultCryptProv;  // decode
    DWORD                   dwKeySpec;          // key to use in CryptSignHash
    DWORD                   dwEncodingType;     // encode

    LONG                    lRefCnt;
    union {
        HCRYPTMSG               hNewCryptMsg;
        PCRYPT_MSG_INFO         pNewcmi;
    };
    union {
        HCRYPTMSG               hOssCryptMsg;
        PCRYPT_MSG_INFO         pOsscmi;
    };
    PFN_CMSG_STREAM_OUTPUT  pfnStreamOutput;
    void                    *pvArg;
    BYTE                    *pbOssOutput;
    DWORD                   cbOssOutput;
    BOOL                    fOssFinal;
    BYTE                    *pbNewOutput;
    DWORD                   cbNewOutput;
    BOOL                    fNewFinal;
    BOOL                    fDidCompare;
} OSS_CRYPT_ASN1_MSG_INFO, *POSS_CRYPT_ASN1_MSG_INFO;

BOOL
WINAPI
ICMTest_OssStreamOutput(
    IN const void *pvArg,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal
    )
{
    POSS_CRYPT_ASN1_MSG_INFO pInfo = (POSS_CRYPT_ASN1_MSG_INFO) pvArg;
    assert(TEST_MAGIC == pInfo->lMagic);

    assert(!pInfo->fOssFinal);
    pInfo->fOssFinal = fFinal;

    if (cbData) {
        BYTE *pbOssOutput;

        if (pbOssOutput = (BYTE *) ICM_ReAlloc(pInfo->pbOssOutput,
                pInfo->cbOssOutput + cbData)) {
            memcpy(pbOssOutput + pInfo->cbOssOutput, pbData, cbData);
            pInfo->pbOssOutput = pbOssOutput;
            pInfo->cbOssOutput += cbData;
        }
    }
    return TRUE;
}

BOOL
WINAPI
ICMTest_NewStreamOutput(
    IN const void *pvArg,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal
    )
{
    POSS_CRYPT_ASN1_MSG_INFO pInfo = (POSS_CRYPT_ASN1_MSG_INFO) pvArg;
    assert(TEST_MAGIC == pInfo->lMagic);

    assert(!pInfo->fNewFinal);
    pInfo->fNewFinal = fFinal;

    if (cbData) {
        BYTE *pbNewOutput;

        if (pbNewOutput = (BYTE *) ICM_ReAlloc(pInfo->pbNewOutput,
                pInfo->cbNewOutput + cbData)) {
            memcpy(pbNewOutput + pInfo->cbNewOutput, pbData, cbData);
            pInfo->pbNewOutput = pbNewOutput;
            pInfo->cbNewOutput += cbData;
        }
    }

    return pInfo->pfnStreamOutput(
        pInfo->pvArg,
        pbData,
        cbData,
        fFinal
        );
}

void
ICMTest_CompareMessageBox(
    IN LPSTR pszText,
    IN BYTE *pbOss,
    IN DWORD cbOss,
    IN BYTE *pbNew,
    IN DWORD cbNew
    )
{
    if (NULL == pbOss || NULL == pbNew)
        return;

    if (cbOss != cbNew || 0 != memcmp(pbOss, pbNew, cbNew)) {
        ICMTest_WriteDERToFile("ossasn1.der", pbOss, cbOss);
        ICMTest_WriteDERToFile("newasn1.der", pbNew, cbNew);
        
        ICMTest_MessageBox(pszText);
    }
}

void
ICMTest_CompareStreamOutput(
    IN POSS_CRYPT_ASN1_MSG_INFO pInfo,
    IN BOOL fForceCompare = FALSE
    )
{
    BOOL fDoCompare;

    if (NULL == pInfo->pfnStreamOutput || pInfo->fDidCompare)
        return;

    fDoCompare = fForceCompare;
    if (pInfo->fOssFinal || pInfo->fNewFinal)
        fDoCompare = TRUE;

    if (fDoCompare) {
        if (pInfo->fOssFinal != pInfo->fNewFinal) {
            if (pInfo->fOssFinal)
                ICMTest_MessageBox("No fFinal on NewStreamOutput.");
            else
                ICMTest_MessageBox("No fFinal on OssStreamOutput.");
        }

        ICMTest_CompareMessageBox(
            "StreamOutput compare failed. Check ossasn1.der and newasn1.der.",
            pInfo->pbOssOutput,
            pInfo->cbOssOutput,
            pInfo->pbNewOutput,
            pInfo->cbNewOutput
            );

        pInfo->fDidCompare = TRUE;
    }
}

void
ICMTest_CompareGetParam(
    IN POSS_CRYPT_ASN1_MSG_INFO pInfo,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    IN void *pvOssData,
    IN DWORD cbOssData,
    IN void *pvNewData,
    IN DWORD cbNewData
    )
{
    char szText[512];

    switch (dwParamType) {
        case CMSG_TYPE_PARAM:
        case CMSG_CONTENT_PARAM:
        case CMSG_BARE_CONTENT_PARAM:
        case CMSG_INNER_CONTENT_TYPE_PARAM:
        case CMSG_SIGNER_COUNT_PARAM:
        case CMSG_CERT_COUNT_PARAM:
        case CMSG_CERT_PARAM:
        case CMSG_CRL_COUNT_PARAM:
        case CMSG_CRL_PARAM:
        case CMSG_RECIPIENT_COUNT_PARAM:
        case CMSG_HASH_DATA_PARAM:
        case CMSG_COMPUTED_HASH_PARAM:
        case CMSG_ENCRYPTED_DIGEST:
        case CMSG_ENCODED_SIGNER:
        case CMSG_ENCODED_MESSAGE:
#ifdef CMS_PKCS7
        case CMSG_VERSION_PARAM:
        case CMSG_ATTR_CERT_COUNT_PARAM:
        case CMSG_ATTR_CERT_PARAM:
        case CMSG_CMS_RECIPIENT_COUNT_PARAM:
#endif  // CMS_PKCS7
            break;
        default:
            return;
    }

    if (NULL == pvOssData || NULL == pvNewData)
        return;


    wsprintfA(szText,
        "ParamType: %d compare failed. Check ossasn1.der and newasn1.der.",
        dwParamType
        );

    ICMTest_CompareMessageBox(
        szText,
        (BYTE *) pvOssData,
        cbOssData,
        (BYTE *) pvNewData,
        cbNewData
        );
}

inline
void
ICMTest_Lock(
    IN POSS_CRYPT_ASN1_MSG_INFO pInfo
    )
{
    EnterCriticalSection( &pInfo->CriticalSection);
}

inline
void
ICMTest_Unlock(
    IN POSS_CRYPT_ASN1_MSG_INFO pInfo
    )
{
    LeaveCriticalSection( &pInfo->CriticalSection);
}

HCRYPTMSG
WINAPI
CryptMsgOpenToEncode(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN void const *pvMsgEncodeInfo,
    IN OPTIONAL LPSTR pszInnerContentObjID,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo
    )
{
    int iOssAsn1Flags = ICMTest_GetDebugCryptAsn1Flags();

    if (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG) {
        POSS_CRYPT_ASN1_MSG_INFO pInfo;
        CMSG_STREAM_INFO StreamInfo;
        DWORD dwOssErr;
        DWORD dwNewErr;

        if (NULL == (pInfo = (POSS_CRYPT_ASN1_MSG_INFO) ICM_AllocZero(
                sizeof(OSS_CRYPT_ASN1_MSG_INFO))))
            return NULL;
        pInfo->lMagic = TEST_MAGIC;

        if (pStreamInfo) {
            pInfo->pfnStreamOutput = pStreamInfo->pfnStreamOutput;
            pInfo->pvArg = pStreamInfo->pvArg;
            StreamInfo.cbContent = pStreamInfo->cbContent;
            // StreamInfo.pfnStreamOutput =
            StreamInfo.pvArg = pInfo;
            pStreamInfo = &StreamInfo;
        }

        StreamInfo.pfnStreamOutput = ICMTest_NewStreamOutput;
        pInfo->hNewCryptMsg = ICMTest_NewCryptMsgOpenToEncode(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            pvMsgEncodeInfo,
            pszInnerContentObjID,
            pStreamInfo
            );
        dwNewErr = GetLastError();

        StreamInfo.pfnStreamOutput = ICMTest_OssStreamOutput;
        pInfo->hOssCryptMsg = pfnOssCryptMsgOpenToEncode(
            dwMsgEncodingType,
            dwFlags & ~CMSG_CRYPT_RELEASE_CONTEXT_FLAG,
            dwMsgType,
            pvMsgEncodeInfo,
            pszInnerContentObjID,
            pStreamInfo
            );
        dwOssErr = GetLastError();

        if (pInfo->hNewCryptMsg) {
            if (pInfo->hOssCryptMsg) {
                pInfo->dwEncodingType = pInfo->pNewcmi->dwEncodingType;
                InitializeCriticalSection(&pInfo->CriticalSection);
                pInfo->lRefCnt = 1;
                return (HCRYPTMSG) pInfo;
            } else {
                HCRYPTMSG hRet;
                ICMTest_MessageBox("OssCryptMsgOpenToEncode failed.");
                hRet = pInfo->hNewCryptMsg;
                ICM_Free(pInfo);
                return hRet;
            }
        } else {
            if (pInfo->hOssCryptMsg) {
                ICMTest_MessageBox("OssCryptMsgOpenToEncode succeeded while NewCryptMsgOpenToEncoded failed.");
                pfnOssCryptMsgClose(pInfo->hOssCryptMsg);
            } else if (dwOssErr != dwNewErr)
                ICMTest_MessageBoxLastError("CryptMsgOpenToEncode",
                    dwOssErr, dwNewErr);

            ICM_Free(pInfo);
            SetLastError(dwNewErr);
            return NULL;
        }
    } else if (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)
        return pfnOssCryptMsgOpenToEncode(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            pvMsgEncodeInfo,
            pszInnerContentObjID,
            pStreamInfo
            );
    else
        return ICMTest_NewCryptMsgOpenToEncode(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            pvMsgEncodeInfo,
            pszInnerContentObjID,
            pStreamInfo
            );
}

HCRYPTMSG
WINAPI
CryptMsgOpenToDecode(
    IN DWORD dwMsgEncodingType,
    IN DWORD dwFlags,
    IN DWORD dwMsgType,
    IN HCRYPTPROV hCryptProv,
    IN OPTIONAL PCERT_INFO pRecipientInfo,
    IN OPTIONAL PCMSG_STREAM_INFO pStreamInfo
    )
{
    int iOssAsn1Flags = ICMTest_GetDebugCryptAsn1Flags();

    if (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG) {
        POSS_CRYPT_ASN1_MSG_INFO pInfo;
        CMSG_STREAM_INFO StreamInfo;
        DWORD dwOssErr;
        DWORD dwNewErr;

        if (NULL == (pInfo = (POSS_CRYPT_ASN1_MSG_INFO) ICM_AllocZero(
                sizeof(OSS_CRYPT_ASN1_MSG_INFO))))
            return NULL;
        pInfo->lMagic = TEST_MAGIC;

        if (pStreamInfo) {
            pInfo->pfnStreamOutput = pStreamInfo->pfnStreamOutput;
            pInfo->pvArg = pStreamInfo->pvArg;
            StreamInfo.cbContent = pStreamInfo->cbContent;
            // StreamInfo.pfnStreamOutput =
            StreamInfo.pvArg = pInfo;
            pStreamInfo = &StreamInfo;
        }

        StreamInfo.pfnStreamOutput = ICMTest_NewStreamOutput;
        pInfo->hNewCryptMsg = ICMTest_NewCryptMsgOpenToDecode(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            hCryptProv,
            pRecipientInfo,
            pStreamInfo
            );
        dwNewErr = GetLastError();

        StreamInfo.pfnStreamOutput = ICMTest_OssStreamOutput;
        pInfo->hOssCryptMsg = pfnOssCryptMsgOpenToDecode(
            dwMsgEncodingType,
            dwFlags & ~CMSG_CRYPT_RELEASE_CONTEXT_FLAG,
            dwMsgType,
            hCryptProv,
            pRecipientInfo,
            pStreamInfo
            );
        dwOssErr = GetLastError();

        if (pInfo->hNewCryptMsg) {
            if (pInfo->hOssCryptMsg) {
                pInfo->dwEncodingType = pInfo->pNewcmi->dwEncodingType;
                InitializeCriticalSection(&pInfo->CriticalSection);
                pInfo->lRefCnt = 1;
                return (HCRYPTMSG) pInfo;
            } else {
                HCRYPTMSG hRet;
                ICMTest_MessageBox("OssCryptMsgOpenToDecode failed.");
                hRet = pInfo->hNewCryptMsg;
                ICM_Free(pInfo);
                return hRet;
            }
        } else {
            if (pInfo->hOssCryptMsg) {
                ICMTest_MessageBox("OssCryptMsgOpenToDecode succeeded while NewCryptMsgOpenToDecode failed.");
                pfnOssCryptMsgClose(pInfo->hOssCryptMsg);
            } else if (dwOssErr != dwNewErr)
                ICMTest_MessageBoxLastError("CryptMsgOpenToDecode",
                    dwOssErr, dwNewErr);

            ICM_Free(pInfo);
            SetLastError(dwNewErr);
            return NULL;
        }
    } else if (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)
        return pfnOssCryptMsgOpenToDecode(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            hCryptProv,
            pRecipientInfo,
            pStreamInfo
            );
    else
        return ICMTest_NewCryptMsgOpenToDecode(
            dwMsgEncodingType,
            dwFlags,
            dwMsgType,
            hCryptProv,
            pRecipientInfo,
            pStreamInfo
            );
}

HCRYPTMSG
WINAPI
CryptMsgDuplicate(
    IN HCRYPTMSG hCryptMsg
    )
{
    POSS_CRYPT_ASN1_MSG_INFO pInfo = (POSS_CRYPT_ASN1_MSG_INFO) hCryptMsg;
    if (pInfo && TEST_MAGIC == pInfo->lMagic) {
        InterlockedIncrement(&pInfo->lRefCnt);
        return hCryptMsg;
    } else if (ICMTest_GetDebugCryptAsn1Flags() &
                DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)
        return pfnOssCryptMsgDuplicate(hCryptMsg);
    else
        return ICMTest_NewCryptMsgDuplicate(hCryptMsg);
}

BOOL
WINAPI
CryptMsgClose(
    IN HCRYPTMSG hCryptMsg
    )
{
    BOOL fRet;
    DWORD dwError;

    POSS_CRYPT_ASN1_MSG_INFO pInfo = (POSS_CRYPT_ASN1_MSG_INFO) hCryptMsg;

    if (NULL == pInfo)
        return TRUE;
    if (TEST_MAGIC != pInfo->lMagic) {
        if (iDebugCryptAsn1Flags &
                DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)
            return pfnOssCryptMsgClose(hCryptMsg);
        else
            return ICMTest_NewCryptMsgClose(hCryptMsg);
    }
    if (0 != InterlockedDecrement(&pInfo->lRefCnt))
        return TRUE;

    // Preserve LastError
    dwError = GetLastError();

    assert(pInfo->hOssCryptMsg);
    assert(1 == ((PCRYPT_MSG_INFO) pInfo->hOssCryptMsg)->lRefCnt);
    assert(pInfo->hNewCryptMsg);
    assert(1 == ((PCRYPT_MSG_INFO) pInfo->hNewCryptMsg)->lRefCnt);

    ICMTest_CompareStreamOutput(pInfo, TRUE);

    pfnOssCryptMsgClose(pInfo->hOssCryptMsg);
    fRet = ICMTest_NewCryptMsgClose(pInfo->hNewCryptMsg);

    ICM_Free(pInfo->pbOssOutput);
    ICM_Free(pInfo->pbNewOutput);
    DeleteCriticalSection(&pInfo->CriticalSection);
    ICM_Free(pInfo);

    SetLastError(dwError);              // Preserve LastError
    return fRet;
}


BOOL
WINAPI
CryptMsgUpdate(
    IN HCRYPTMSG hCryptMsg,
    IN const BYTE *pbData,
    IN DWORD cbData,
    IN BOOL fFinal
    )
{
    BOOL fNew;
    DWORD dwNewErr;
    BOOL fOss;
    DWORD dwOssErr;

    POSS_CRYPT_ASN1_MSG_INFO pInfo = (POSS_CRYPT_ASN1_MSG_INFO) hCryptMsg;

    if (NULL == pInfo || TEST_MAGIC != pInfo->lMagic) {
        if (ICMTest_GetDebugCryptAsn1Flags() &
                DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)
            return pfnOssCryptMsgUpdate(
                hCryptMsg,
                pbData,
                cbData,
                fFinal
                );
        else
            return ICMTest_NewCryptMsgUpdate(
                hCryptMsg,
                pbData,
                cbData,
                fFinal
                );
    }

    ICMTest_Lock(pInfo);

    fOss = pfnOssCryptMsgUpdate(
        pInfo->hOssCryptMsg,
        pbData,
        cbData,
        fFinal
        );
    dwOssErr = GetLastError();

    fNew = ICMTest_NewCryptMsgUpdate(
        pInfo->hNewCryptMsg,
        pbData,
        cbData,
        fFinal
        );
    dwNewErr = GetLastError();

    if (fNew) {
        if (fOss)
            ICMTest_CompareStreamOutput(pInfo);
        else
            ICMTest_MessageBox("OssCryptMsgUpdate failed.");
    } else {
        if (fOss)
            ICMTest_MessageBox("OssCryptMsgUpdate succeeded while NewCryptMsgUpdate failed.");
        else if (dwOssErr != dwNewErr)
            ICMTest_MessageBoxLastError("CryptMsgUpdate",
                dwOssErr, dwNewErr);

    }

    ICMTest_Unlock(pInfo);

    SetLastError(dwNewErr);
    return fNew;
}
    

BOOL
WINAPI
CryptMsgGetParam(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwParamType,
    IN DWORD dwIndex,
    OUT void *pvData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fOss;
    DWORD dwOssErr;
    void *pvOssData = NULL;
    DWORD cbOssData;
    BOOL fNew;
    DWORD dwNewErr;

    POSS_CRYPT_ASN1_MSG_INFO pInfo = (POSS_CRYPT_ASN1_MSG_INFO) hCryptMsg;

    if (NULL == pInfo || TEST_MAGIC != pInfo->lMagic) {
        if (ICMTest_GetDebugCryptAsn1Flags() &
                DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)
            return pfnOssCryptMsgGetParam(
                hCryptMsg,
                dwParamType,
                dwIndex,
                pvData,
                pcbData
                );
        else
            return ICMTest_NewCryptMsgGetParam(
                hCryptMsg,
                dwParamType,
                dwIndex,
                pvData,
                pcbData
                );
    }

    ICMTest_Lock(pInfo);

    cbOssData = *pcbData;
    if (pvData)
        pvOssData = ICM_Alloc(cbOssData);

    fOss = pfnOssCryptMsgGetParam(
        pInfo->hOssCryptMsg,
        dwParamType,
        dwIndex,
        pvOssData,
        &cbOssData
        );
    dwOssErr = GetLastError();

    fNew = ICMTest_NewCryptMsgGetParam(
        pInfo->hNewCryptMsg,
        dwParamType,
        dwIndex,
        pvData,
        pcbData
        );
    dwNewErr = GetLastError();

    if (fNew) {
        if (fOss)
            ICMTest_CompareGetParam(
                pInfo,
                dwParamType,
                dwIndex,
                pvOssData,
                cbOssData,
                pvData,
                *pcbData
                );
        else
            ICMTest_MessageBox("OssCryptMsgGetParam failed.");
    } else {
        if (fOss)
            ICMTest_MessageBox("OssCryptMsgGetParam succeeded while NewCryptMsgGetParam failed.");
        else if (dwOssErr != dwNewErr)
            ICMTest_MessageBoxLastError("CryptMsgGetParam",
                dwOssErr, dwNewErr);
    }

    ICMTest_Unlock(pInfo);
    ICM_Free(pvOssData);
    SetLastError(dwNewErr);
    return fNew;
}


BOOL
WINAPI
CryptMsgControl(
    IN HCRYPTMSG hCryptMsg,
    IN DWORD dwFlags,
    IN DWORD dwCtrlType,
    IN void const *pvCtrlPara
    )
{
    BOOL fNew;
    DWORD dwNewErr;
    BOOL fOss;
    DWORD dwOssErr;

    POSS_CRYPT_ASN1_MSG_INFO pInfo = (POSS_CRYPT_ASN1_MSG_INFO) hCryptMsg;

    if (NULL == pInfo || TEST_MAGIC != pInfo->lMagic) {
        if (ICMTest_GetDebugCryptAsn1Flags() &
                DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)
            return pfnOssCryptMsgControl(
                hCryptMsg,
                dwFlags,
                dwCtrlType,
                pvCtrlPara
                );
        else
            return ICMTest_NewCryptMsgControl(
                hCryptMsg,
                dwFlags,
                dwCtrlType,
                pvCtrlPara
                );
    }

    ICMTest_Lock(pInfo);

    fOss = pfnOssCryptMsgControl(
        pInfo->hOssCryptMsg,
        dwFlags & ~CMSG_CRYPT_RELEASE_CONTEXT_FLAG,
        dwCtrlType,
        pvCtrlPara
        );
    dwOssErr = GetLastError();

    fNew = ICMTest_NewCryptMsgControl(
        pInfo->hNewCryptMsg,
        dwFlags,
        dwCtrlType,
        pvCtrlPara
        );
    dwNewErr = GetLastError();

    if (fNew) {
        if (fOss)
            ICMTest_CompareStreamOutput(pInfo);
        else
            ICMTest_MessageBox("OssCryptMsgControl failed.");
    } else {
        if (fOss)
            ICMTest_MessageBox("OssCryptMsgControl succeeded while NewCryptMsgControl failed.");
        else if (dwOssErr != dwNewErr)
            ICMTest_MessageBoxLastError("CryptMsgControl",
                dwOssErr, dwNewErr);

    }

    ICMTest_Unlock(pInfo);

    SetLastError(dwNewErr);
    return fNew;
}



#ifdef CMS_PKCS7
BOOL
WINAPI
CryptMsgVerifyCountersignatureEncodedEx(
    IN HCRYPTPROV   hCryptProv,
    IN DWORD        dwEncodingType,
    IN PBYTE        pbSignerInfo,
    IN DWORD        cbSignerInfo,
    IN PBYTE        pbSignerInfoCountersignature,
    IN DWORD        cbSignerInfoCountersignature,
    IN DWORD        dwSignerType,
    IN void         *pvSigner,
    IN DWORD        dwFlags,
    IN OPTIONAL void *pvReserved
    )
{
    BOOL fOss;
    int iOssAsn1Flags = ICMTest_GetDebugCryptAsn1Flags();

    if (0 == (iOssAsn1Flags &
            (DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG |
                DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)))
        return ICMTest_NewCryptMsgVerifyCountersignatureEncodedEx(
            hCryptProv,
            dwEncodingType,
            pbSignerInfo,
            cbSignerInfo,
            pbSignerInfoCountersignature,
            cbSignerInfoCountersignature,
            dwSignerType,
            pvSigner,
            dwFlags,
            pvReserved
            );

    fOss = pfnOssCryptMsgVerifyCountersignatureEncodedEx(
            hCryptProv,
            dwEncodingType,
            pbSignerInfo,
            cbSignerInfo,
            pbSignerInfoCountersignature,
            cbSignerInfoCountersignature,
            dwSignerType,
            pvSigner,
            dwFlags,
            pvReserved
            );

    if (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG) {
        DWORD dwOssErr = GetLastError();
        BOOL fNew;
        DWORD dwNewErr;

        fNew = ICMTest_NewCryptMsgVerifyCountersignatureEncodedEx(
            hCryptProv,
            dwEncodingType,
            pbSignerInfo,
            cbSignerInfo,
            pbSignerInfoCountersignature,
            cbSignerInfoCountersignature,
            dwSignerType,
            pvSigner,
            dwFlags,
            pvReserved
            );
        dwNewErr = GetLastError();

        if (fNew) {
            if (!fOss)
                ICMTest_MessageBox("OssCryptMsgVerifyCountersignatureEncodedEx failed.");
        } else {
            if (fOss)
                ICMTest_MessageBox("OssCryptMsgVerifyCountersignatureEncodedEx succeeded while NewCryptMsgVerifyCountersignatureEncodedEx failed.");
            else if (dwOssErr != dwNewErr)
                ICMTest_MessageBoxLastError("CryptMsgVerifyCountersignatureEncodedEx",
                    dwOssErr, dwNewErr);

        }

        SetLastError(dwOssErr);
    }

    return fOss;

}
#endif  // CMS_PKCS7

BOOL
WINAPI
CryptMsgCountersign(
    IN OUT HCRYPTMSG            hCryptMsg,
    IN DWORD                    dwIndex,
    IN DWORD                    cCountersigners,
    IN PCMSG_SIGNER_ENCODE_INFO rgCountersigners
    )
{
    BOOL fNew;
    DWORD dwNewErr;
    BOOL fOss;
    DWORD dwOssErr;

    POSS_CRYPT_ASN1_MSG_INFO pInfo = (POSS_CRYPT_ASN1_MSG_INFO) hCryptMsg;

    if (NULL == pInfo || TEST_MAGIC != pInfo->lMagic) {
        if (ICMTest_GetDebugCryptAsn1Flags() &
                DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)
            return pfnOssCryptMsgCountersign(
                hCryptMsg,
                dwIndex,
                cCountersigners,
                rgCountersigners
                );
        else
            return ICMTest_NewCryptMsgCountersign(
                hCryptMsg,
                dwIndex,
                cCountersigners,
                rgCountersigners
                );
    }

    ICMTest_Lock(pInfo);

    fOss = pfnOssCryptMsgCountersign(
        pInfo->hOssCryptMsg,
        dwIndex,
        cCountersigners,
        rgCountersigners
        );
    dwOssErr = GetLastError();

    fNew = ICMTest_NewCryptMsgCountersign(
        pInfo->hNewCryptMsg,
        dwIndex,
        cCountersigners,
        rgCountersigners
        );
    dwNewErr = GetLastError();

    if (fNew) {
        if (!fOss)
            ICMTest_MessageBox("OssCryptMsgCountersign failed.");
    } else {
        if (fOss)
            ICMTest_MessageBox("OssCryptMsgCountersign succeeded while NewCryptMsgCountersign failed.");
        else if (dwOssErr != dwNewErr)
            ICMTest_MessageBoxLastError("CryptMsgCountersign",
                dwOssErr, dwNewErr);

    }

    ICMTest_Unlock(pInfo);

    SetLastError(dwNewErr);
    return fNew;
}

BOOL
WINAPI
CryptMsgCountersignEncoded(
    IN DWORD                    dwEncodingType,
    IN PBYTE                    pbSignerInfo,
    IN DWORD                    cbSignerInfo,
    IN DWORD                    cCountersigners,
    IN PCMSG_SIGNER_ENCODE_INFO rgCountersigners,
    OUT PBYTE                   pbCountersignature,
    IN OUT PDWORD               pcbCountersignature
    )
{
    BOOL fOss;
    int iOssAsn1Flags = ICMTest_GetDebugCryptAsn1Flags();
    BYTE *pbNew = NULL;
    DWORD cbNew;

    if (0 == (iOssAsn1Flags &
            (DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG |
                DEBUG_OSS_CRYPT_ASN1_CMSG_FLAG)))
        return ICMTest_NewCryptMsgCountersignEncoded(
            dwEncodingType,
            pbSignerInfo,
            cbSignerInfo,
            cCountersigners,
            rgCountersigners,
            pbCountersignature,
            pcbCountersignature
            );

    if (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG) {
        cbNew = *pcbCountersignature;
        if (pbCountersignature)
            pbNew = (BYTE *) ICM_Alloc(cbNew);
    }

    fOss = pfnOssCryptMsgCountersignEncoded(
            dwEncodingType,
            pbSignerInfo,
            cbSignerInfo,
            cCountersigners,
            rgCountersigners,
            pbCountersignature,
            pcbCountersignature
            );

    if (iOssAsn1Flags & DEBUG_OSS_CRYPT_ASN1_CMSG_COMPARE_FLAG) {
        DWORD dwOssErr = GetLastError();
        BOOL fNew;
        DWORD dwNewErr;

        fNew = ICMTest_NewCryptMsgCountersignEncoded(
            dwEncodingType,
            pbSignerInfo,
            cbSignerInfo,
            cCountersigners,
            rgCountersigners,
            pbNew,
            &cbNew
            );
        dwNewErr = GetLastError();


        if (fNew) {
            if (fOss)
                ICMTest_CompareMessageBox(
                    "CountersignEncoded compare failed. Check ossasn1.der and newasn1.der.",
                    pbCountersignature,
                    *pcbCountersignature,
                    pbNew,
                    cbNew
                    );
            else
                ICMTest_MessageBox("NewCryptMsgCountersignEncoded failed.");
        } else {
            if (fOss)
                ICMTest_MessageBox("OssCryptMsgCountersignEncoded succeeded while NewCryptMsgCountersignEncoded failed.");
            else if (dwOssErr != dwNewErr)
                ICMTest_MessageBoxLastError("CryptMsgCountersignEncoded",
                    dwOssErr, dwNewErr);

        }

        SetLastError(dwOssErr);
    }

    ICM_Free(pbNew);
    return fOss;
}


#endif  // DEBUG_CRYPT_ASN1_MASTER

#endif  // DEBUG_CRYPT_ASN1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\mssign32\makefile.inc ===
mssign32_all:
    xcopy /D $(SDK_LIB_PATH)\mssign32.* $(SECURITY_LIB_PATH)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\mssign32\pvkhlpr.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pvkhlpr.cpp
//
//  Contents:   Private Key Helper APIs
//
//  Functions:  PrivateKeyLoad
//              PrivateKeySave
//              PrivateKeyLoadFromMemory
//              PrivateKeySaveToMemory
//              PrivateKeyAcquireContextFromMemory
//              PrivateKeyReleaseContext
//
//  Note:       Base CSP also exports/imports the public key with the
//              private key.
//
//  History:    10-May-96   philh   created
//--------------------------------------------------------------------------


#include "global.hxx"
#include <assert.h>
#include <string.h>
#include <memory.h>
#include <objbase.h>
#include "pvk.h"
#include "unicode.h"


//+-------------------------------------------------------------------------
//  Private Key file definitions
//
//  The file consists of the FILE_HDR followed by cbEncryptData optional
//  bytes used to encrypt the private key and then the private key.
//  The private key is encrypted according to dwEncryptType.
//
//  The public key is included with the private key.
//--------------------------------------------------------------------------
typedef struct _FILE_HDR {
    DWORD               dwMagic;
    DWORD               dwVersion;
    DWORD               dwKeySpec;
    DWORD               dwEncryptType;
    DWORD               cbEncryptData;
    DWORD               cbPvk;
} FILE_HDR, *PFILE_HDR;

#define PVK_FILE_VERSION_0          0
#define PVK_MAGIC                   0xb0b5f11e

// Private key encrypt types
#define PVK_NO_ENCRYPT                  0
#define PVK_RC4_PASSWORD_ENCRYPT        1
#define PVK_RC2_CBC_PASSWORD_ENCRYPT    2

#define MAX_PVK_FILE_LEN            4096
#define MAX_BOB_FILE_LEN            (4096*4)

typedef BOOL (* PFNWRITE)(HANDLE h, void * p, DWORD cb);
typedef BOOL (* PFNREAD)(HANDLE h, void * p, DWORD cb);



//+-------------------------------------------------------------------------
//  Private key helper allocation and free functions
//--------------------------------------------------------------------------
void *PvkAlloc(
    IN size_t cbBytes
    )
{
    void *pv;
    pv = malloc(cbBytes);
    if (pv == NULL)
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
    return pv;
}
void PvkFree(
    IN void *pv
    )
{
    free(pv);
}

//+-------------------------------------------------------------------------
//  Read  & Write to file function
//--------------------------------------------------------------------------
static BOOL WriteToFile(HANDLE h, void * p, DWORD cb) {

    DWORD   cbBytesWritten;

    return(WriteFile(h, p, cb, &cbBytesWritten, NULL));
}

static BOOL ReadFromFile(
    IN HANDLE h,
    IN void * p,
    IN DWORD cb
    )
{
    DWORD   cbBytesRead;

    return(ReadFile(h, p, cb, &cbBytesRead, NULL) && cbBytesRead == cb);
}


//+-------------------------------------------------------------------------
//  Read & Write to memory fucntion
//--------------------------------------------------------------------------
typedef struct _MEMINFO {
    BYTE *  pb;
    DWORD   cb;
    DWORD   cbSeek;
} MEMINFO, * PMEMINFO;

static BOOL WriteToMemory(HANDLE h, void * p, DWORD cb) {

    PMEMINFO pMemInfo = (PMEMINFO) h;

    // See if we have room. The caller will detect an error after the final
    // write
    if(pMemInfo->cbSeek + cb <= pMemInfo->cb)
        // copy the bytes
        memcpy(&pMemInfo->pb[pMemInfo->cbSeek], p, cb);

    pMemInfo->cbSeek += cb;

    return(TRUE);
}

static BOOL ReadFromMemory(
    IN HANDLE h,
    IN void * p,
    IN DWORD cb
    )
{
    PMEMINFO pMemInfo = (PMEMINFO) h;

    if (pMemInfo->cbSeek + cb <= pMemInfo->cb) {
        // copy the bytes
        memcpy(p, &pMemInfo->pb[pMemInfo->cbSeek], cb);
        pMemInfo->cbSeek += cb;
        return TRUE;
    } else {
        SetLastError(ERROR_END_OF_MEDIA);
        return FALSE;
    }
}

static BOOL GetPasswordKey(
    IN HCRYPTPROV hProv,
    IN ALG_ID Algid,
    IN PASSWORD_TYPE PasswordType,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN BOOL fNoPassDlg,
    IN BYTE *pbSalt,
    IN DWORD cbSalt,
    OUT HCRYPTKEY *phEncryptKey,
    OUT OPTIONAL HCRYPTKEY *ph40EncryptKey = NULL,
    OUT OPTIONAL HCRYPTKEY *ph128EncryptKey = NULL
    )
{
    BOOL fResult;
    BYTE *pbAllocPassword = NULL;
    BYTE *pbPassword;
    DWORD cbPassword;
    HCRYPTHASH hHash = 0;
    HCRYPTKEY hEncryptKey = 0;
    BYTE rgbDefPw []    = { 0x43, 0x52, 0x41, 0x50 };
    DWORD cbDefPw       = sizeof(rgbDefPw);

    if (ph40EncryptKey)
        *ph40EncryptKey = 0;
    if (ph128EncryptKey)
        *ph128EncryptKey = 0;

    if (fNoPassDlg) {
        pbPassword = rgbDefPw;
        cbPassword = cbDefPw;
    } else {
        if (IDOK != PvkDlgGetKeyPassword(
                PasswordType,
                hwndOwner,
                pwszKeyName,
                &pbAllocPassword,
                &cbPassword
                )) {
            SetLastError(PVK_HELPER_PASSWORD_CANCEL);
            goto ErrorReturn;
        }
        pbPassword = pbAllocPassword;
    }

    if (cbPassword) {
        if (!CryptCreateHash(hProv, CALG_SHA, 0, 0, &hHash))
            goto ErrorReturn;
        if (cbSalt) {
            if (!CryptHashData(hHash, pbSalt, cbSalt, 0))
                goto ErrorReturn;
        }
        if (!CryptHashData(hHash, pbPassword, cbPassword, 0))
            goto ErrorReturn;
        if (!CryptDeriveKey(hProv, Algid, hHash, 0, &hEncryptKey))
            goto ErrorReturn;
        if (ph40EncryptKey) {
            if (!CryptDeriveKey(hProv, Algid, hHash,
                    40 << 16,   // dwFlags, dwBitLen in upper WORD
                    ph40EncryptKey)) {
                *ph40EncryptKey = NULL;
            }
        }
        if (ph128EncryptKey) {
            if (!CryptDeriveKey(hProv, Algid, hHash,
                    128 << 16,  // dwFlags, dwBitLen in upper WORD
                    ph128EncryptKey)) {
                *ph128EncryptKey = NULL;
            }
        }
    }

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
    if (hEncryptKey) {
        CryptDestroyKey(hEncryptKey);
        hEncryptKey = 0;
    }
CommonReturn:
    if (pbAllocPassword)
        PvkFree(pbAllocPassword);
    if (hHash)
        CryptDestroyHash(hHash);
    *phEncryptKey = hEncryptKey;
    return fResult;
}

// Support backwards compatibility with Bob's storage file which contains
// a snap shot of the keys as they are stored in the registry. Note, for
// win95, the registry values are decrypted before being written to the file.
static BOOL LoadBobKey(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbBobKey,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    IN PFILE_HDR pHdr                   // header has already been read
    );

static BOOL LoadKeyW(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbKeyData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    BOOL fResult;
    FILE_HDR Hdr;
    HCRYPTKEY hDecryptKey = 0;
    HCRYPTKEY h40DecryptKey = 0;
    HCRYPTKEY h128DecryptKey = 0;
    HCRYPTKEY hKey = 0;
    BYTE *pbEncryptData = NULL;
    BYTE *pbPvk = NULL;
    DWORD cbPvk;

    // Read the file header and verify
    if (!pfnRead(hRead, &Hdr, sizeof(Hdr))) goto BadPvkFile;
    if (Hdr.dwMagic != PVK_MAGIC)
        // Try to load as Bob's storage file containing streams for the
        // private and public keys. Bob made a copy of the cryptography
        // registry key values.
        //
        // Note, Bob now has two different formats for storing the private
        // key information. See LoadBobKey for details.
        fResult = LoadBobKey(hCryptProv, hRead, pfnRead, cbKeyData, hwndOwner,
            pwszKeyName, dwFlags, pdwKeySpec, &Hdr);
    else {
        // Treat as a "normal" private key file
        cbPvk = Hdr.cbPvk;
        if (Hdr.dwVersion != PVK_FILE_VERSION_0 ||
            Hdr.cbEncryptData > MAX_PVK_FILE_LEN ||
            cbPvk == 0 || cbPvk > MAX_PVK_FILE_LEN)
        goto BadPvkFile;
    
        if (pdwKeySpec) {
            DWORD dwKeySpec = *pdwKeySpec;
            *pdwKeySpec = Hdr.dwKeySpec;
            if (dwKeySpec && dwKeySpec != Hdr.dwKeySpec) {
                SetLastError(PVK_HELPER_WRONG_KEY_TYPE);
                goto ErrorReturn;
            }
        }
    
        if (Hdr.cbEncryptData) {
            // Read the encrypt data
            if (NULL == (pbEncryptData = (BYTE *) PvkAlloc(Hdr.cbEncryptData)))
                goto ErrorReturn;
            if (!pfnRead(hRead, pbEncryptData, Hdr.cbEncryptData))
                goto BadPvkFile;
        }
    
        // Allocate and read the private key
        if (NULL == (pbPvk = (BYTE *) PvkAlloc(cbPvk)))
            goto ErrorReturn;
        if (!pfnRead(hRead, pbPvk, cbPvk))
            goto BadPvkFile;
    
    
        // Get symmetric key to decrypt the private key
        switch (Hdr.dwEncryptType) {
            case PVK_NO_ENCRYPT:
                break;
            case PVK_RC4_PASSWORD_ENCRYPT:
                if (!GetPasswordKey(hCryptProv, CALG_RC4,
                        ENTER_PASSWORD, hwndOwner,
                        pwszKeyName, FALSE, pbEncryptData, Hdr.cbEncryptData,
                        &hDecryptKey, &h40DecryptKey, &h128DecryptKey))
                    goto ErrorReturn;
                break;
            case PVK_RC2_CBC_PASSWORD_ENCRYPT:
                if (!GetPasswordKey(hCryptProv, CALG_RC2,
                        ENTER_PASSWORD, hwndOwner,
                        pwszKeyName, FALSE, pbEncryptData, Hdr.cbEncryptData,
                        &hDecryptKey, &h40DecryptKey, &h128DecryptKey))
                    goto ErrorReturn;
                break;
            default:
                goto BadPvkFile;
        }

        // Decrypt and import the private key
        hKey = 0;
        fResult = CryptImportKey(hCryptProv, pbPvk, cbPvk, hDecryptKey, dwFlags,
                &hKey);

        if (!fResult && h40DecryptKey) {
            hKey = 0;
            fResult = CryptImportKey(hCryptProv, pbPvk, cbPvk,
                h40DecryptKey, dwFlags, &hKey);
        }

        if (!fResult && h128DecryptKey) {
            hKey = 0;
            fResult = CryptImportKey(hCryptProv, pbPvk, cbPvk,
                h128DecryptKey, dwFlags, &hKey);
        }
    }
    goto CommonReturn;

BadPvkFile:
    SetLastError(PVK_HELPER_BAD_PVK_FILE);
    if (pdwKeySpec)
        *pdwKeySpec = 0;
ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pbEncryptData)
        PvkFree(pbEncryptData);
    if (pbPvk)
        PvkFree(pbPvk);
    if (hDecryptKey)
        CryptDestroyKey(hDecryptKey);
    if (h40DecryptKey)
        CryptDestroyKey(h40DecryptKey);
    if (h128DecryptKey)
        CryptDestroyKey(h128DecryptKey);
    if (hKey)
        CryptDestroyKey(hKey);
    return fResult;
}

static BOOL LoadKeyA(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbKeyData,
    IN HWND hwndOwner,
    IN LPCTSTR pszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    
    WIDEN(pszKeyName, pwszKeyName);
    //    LPWSTR pwszKeyName = MkWStr((char*) pszKeyName);
    BOOL fResult = LoadKeyW(hCryptProv,
                            hRead,
                            pfnRead,
                            cbKeyData,
                            hwndOwner,
                            pwszKeyName,
                            dwFlags,
                            pdwKeySpec);
    return fResult;
}

static BOOL SaveKeyW(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hWrite,
    IN PFNREAD pfnWrite,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN BOOL fNoPassDlg
    )
{
    BOOL fResult;
    FILE_HDR Hdr;
    HCRYPTKEY hEncryptKey = 0;
    HCRYPTKEY hKey = 0;
    BYTE *pbEncryptData = NULL;     // Not allocated
    BYTE *pbPvk = NULL;
    DWORD cbPvk;

    BYTE rgbSalt[16];

    // Initialize the header record
    memset(&Hdr, 0, sizeof(Hdr));
    Hdr.dwMagic = PVK_MAGIC;
    Hdr.dwVersion = PVK_FILE_VERSION_0;
    Hdr.dwKeySpec = dwKeySpec;

    // Generate random salt
    if (!CryptGenRandom(hCryptProv, sizeof(rgbSalt), rgbSalt))
        goto ErrorReturn;

    // Get symmetric key to use to encrypt the private key
#if 1
    if (!GetPasswordKey(hCryptProv, CALG_RC4,
#else
    if (!GetPasswordKey(hCryptProv, CALG_RC2,
#endif
            CREATE_PASSWORD, hwndOwner, pwszKeyName,
            fNoPassDlg, rgbSalt, sizeof(rgbSalt), &hEncryptKey))
        goto ErrorReturn;
    if (hEncryptKey) {
#if 1
        Hdr.dwEncryptType = PVK_RC4_PASSWORD_ENCRYPT;
#else
        Hdr.dwEncryptType = PVK_RC2_CBC_PASSWORD_ENCRYPT;
#endif
        Hdr.cbEncryptData = sizeof(rgbSalt);
        pbEncryptData = rgbSalt;
    } else
        Hdr.dwEncryptType = PVK_NO_ENCRYPT;

    // Allocate, encrypt and export the private key
    if (!CryptGetUserKey(hCryptProv, dwKeySpec, &hKey))
        goto ErrorReturn;
    cbPvk = 0;
    if (!CryptExportKey(hKey, hEncryptKey, PRIVATEKEYBLOB, dwFlags, NULL,
            &cbPvk))
        goto ErrorReturn;
    if (NULL == (pbPvk = (BYTE *) PvkAlloc(cbPvk)))
        goto ErrorReturn;
    if (!CryptExportKey(hKey, hEncryptKey, PRIVATEKEYBLOB, dwFlags, pbPvk,
            &cbPvk))
        goto ErrorReturn;
    Hdr.cbPvk = cbPvk;


    // Write the header, optional encrypt data, and private key to the file
    if (!pfnWrite(hWrite, &Hdr, sizeof(Hdr)))
        goto ErrorReturn;
    if (Hdr.cbEncryptData) {
        if (!pfnWrite(hWrite, pbEncryptData, Hdr.cbEncryptData))
            goto ErrorReturn;
    }
    if (!pfnWrite(hWrite, pbPvk, cbPvk))
        goto ErrorReturn;

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    fResult = FALSE;
CommonReturn:
    if (pbPvk)
        PvkFree(pbPvk);
    if (hEncryptKey)
        CryptDestroyKey(hEncryptKey);
    if (hKey)
        CryptDestroyKey(hKey);
    return fResult;
}


static BOOL SaveKeyA(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hWrite,
    IN PFNREAD pfnWrite,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCTSTR pszKeyName,
    IN DWORD dwFlags,
    IN BOOL fNoPassDlg
    )
{
    
    WIDEN(pszKeyName, pwszKeyName);

    //    LPWSTR pwszKeyName = MkWStr((char*) pszKeyName);
    BOOL fResult = SaveKeyW(hCryptProv,
                            hWrite,
                            pfnWrite,
                            dwKeySpec,
                            hwndOwner,
                            pwszKeyName,
                            dwFlags,
                            fNoPassDlg);
    return fResult;
}

//+-------------------------------------------------------------------------
//  Load the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
//  from the file into the cryptographic provider.
//
//  If the private key was password encrypted, then, the user is first
//  presented with a dialog box to enter the password.
//
//  If pdwKeySpec is non-Null, then, if *pdwKeySpec is nonzero, verifies the
//  key type before loading. Sets LastError to PVK_HELPER_WRONG_KEY_TYPE for
//  a mismatch. *pdwKeySpec is updated with the key type.
//
//  dwFlags is passed through to CryptImportKey.
//--------------------------------------------------------------------------
BOOL
WINAPI
PvkPrivateKeyLoad(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hFile,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    return LoadKeyW(
        hCryptProv,
        hFile,
        ReadFromFile,
        GetFileSize(hFile, NULL),
        hwndOwner,
        pwszKeyName,
        dwFlags,
        pdwKeySpec
        );
}

BOOL
WINAPI
PvkPrivateKeyLoadA(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hFile,
    IN HWND hwndOwner,
    IN LPCTSTR pszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    return LoadKeyA(
        hCryptProv,
        hFile,
        ReadFromFile,
        GetFileSize(hFile, NULL),
        hwndOwner,
        pszKeyName,
        dwFlags,
        pdwKeySpec
        );
}

//+-------------------------------------------------------------------------
//  Save the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
//  to the specified file.
//
//  The user is presented with a dialog box to enter an optional password to
//  encrypt the private key.
//
//  dwFlags is passed through to CryptExportKey.
//--------------------------------------------------------------------------
BOOL
WINAPI
PvkPrivateKeySave(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hFile,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags
    )
{
    return SaveKeyW(
        hCryptProv,
        hFile,
        WriteToFile,
        dwKeySpec,
        hwndOwner,
        pwszKeyName,
        dwFlags,
        FALSE           // fNoPassDlg
        );
}

BOOL
WINAPI
PvkPrivateKeySaveA(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hFile,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCTSTR pszKeyName,
    IN DWORD dwFlags
    )
{
    return SaveKeyA(
        hCryptProv,
        hFile,
        WriteToFile,
        dwKeySpec,
        hwndOwner,
        pszKeyName,
        dwFlags,
        FALSE           // fNoPassDlg
        );
}

//+-------------------------------------------------------------------------
//  Load the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
//  from memory into the cryptographic provider.
//
//  Except for the key being loaded from memory, identical to PrivateKeyLoad.
//--------------------------------------------------------------------------
BOOL
WINAPI
PvkPrivateKeyLoadFromMemory(
    IN HCRYPTPROV hCryptProv,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    MemInfo.cb = cbData;
    MemInfo.cbSeek = 0;
    return LoadKeyW(
        hCryptProv,
        (HANDLE) &MemInfo,
        ReadFromMemory,
        cbData,
        hwndOwner,
        pwszKeyName,
        dwFlags,
        pdwKeySpec
        );
}

BOOL
WINAPI
PvkPrivateKeyLoadFromMemoryA(
    IN HCRYPTPROV hCryptProv,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN HWND hwndOwner,
    IN LPCTSTR pszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec
    )
{
    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    MemInfo.cb = cbData;
    MemInfo.cbSeek = 0;
    return LoadKeyA(
        hCryptProv,
        (HANDLE) &MemInfo,
        ReadFromMemory,
        cbData,
        hwndOwner,
        pszKeyName,
        dwFlags,
        pdwKeySpec
        );
}

//+-------------------------------------------------------------------------
//  Save the AT_SIGNATURE or AT_KEYEXCHANGE private key (and its public key)
//  to memory.
//
//  If pbData == NULL || *pcbData == 0, calculates the length and doesn't
//  return an error (also, the user isn't prompted for a password).
//
//  Except for the key being saved to memory, identical to PrivateKeySave.
//--------------------------------------------------------------------------
BOOL
WINAPI
PvkPrivateKeySaveToMemory(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    OUT BYTE *pbData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fResult;
    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    if (pbData == NULL)
        *pcbData = 0;
    MemInfo.cb = *pcbData;
    MemInfo.cbSeek = 0;

    if (fResult = SaveKeyW(
            hCryptProv,
            (HANDLE) &MemInfo,
            WriteToMemory,
            dwKeySpec,
            hwndOwner,
            pwszKeyName,
            dwFlags,
            *pcbData == 0           // fNoPassDlg
            )) {
        if (MemInfo.cbSeek > MemInfo.cb && *pcbData) {
            fResult = FALSE;
            SetLastError(ERROR_END_OF_MEDIA);
        }
        *pcbData = MemInfo.cbSeek;
    } else
        *pcbData = 0;
    return fResult;
}


BOOL
WINAPI
PvkPrivateKeySaveToMemoryA(
    IN HCRYPTPROV hCryptProv,
    IN DWORD dwKeySpec,         // either AT_SIGNATURE or AT_KEYEXCHANGE
    IN HWND hwndOwner,
    IN LPCTSTR pszKeyName,
    IN DWORD dwFlags,
    OUT BYTE *pbData,
    IN OUT DWORD *pcbData
    )
{
    BOOL fResult;
    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    if (pbData == NULL)
        *pcbData = 0;
    MemInfo.cb = *pcbData;
    MemInfo.cbSeek = 0;

    if (fResult = SaveKeyA(
            hCryptProv,
            (HANDLE) &MemInfo,
            WriteToMemory,
            dwKeySpec,
            hwndOwner,
            pszKeyName,
            dwFlags,
            *pcbData == 0           // fNoPassDlg
            )) {
        if (MemInfo.cbSeek > MemInfo.cb && *pcbData) {
            fResult = FALSE;
            SetLastError(ERROR_END_OF_MEDIA);
        }
        *pcbData = MemInfo.cbSeek;
    } else
        *pcbData = 0;
    return fResult;
}


//+-------------------------------------------------------------------------
//  Converts the bytes into WCHAR hex
//
//  Needs (cb * 2 + 1) * sizeof(WCHAR) bytes of space in wsz
//--------------------------------------------------------------------------
static void BytesToWStr(ULONG cb, void* pv, LPWSTR wsz)
{
    BYTE* pb = (BYTE*) pv;
    for (ULONG i = 0; i<cb; i++) {
        int b;
        b = (*pb & 0xF0) >> 4;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        b = *pb & 0x0F;
        *wsz++ = (b <= 9) ? b + L'0' : (b - 10) + L'A';
        pb++;
    }
    *wsz++ = 0;
}

#define UUID_WSTR_BYTES ((sizeof(UUID) * 2 + 1) * sizeof(WCHAR))


//+-------------------------------------------------------------------------
//  Converts the bytes into CHAR hex
//
//  Needs (cb * 2 + 1) * sizeof(CHAR) bytes of space in sz
//--------------------------------------------------------------------------
static void BytesToStr(ULONG cb, void* pv, LPTSTR sz)
{
    BYTE* pb = (BYTE*) pv;
    for (ULONG i = 0; i<cb; i++) {
        int b;
        b = (*pb & 0xF0) >> 4;
        *sz++ = (b <= 9) ? b + '0' : (b - 10) + 'A';
        b = *pb & 0x0F;
        *sz++ = (b <= 9) ? b + '0' : (b - 10) + 'A';
        pb++;
    }
    *sz++ = 0;
}

#define UUID_STR_BYTES ((sizeof(UUID) * 2 + 1) * sizeof(CHAR))


static BOOL AcquireKeyContextW(
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbKeyData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv,
    OUT LPWSTR *ppwszTmpContainer
    )
{
    BOOL fResult;
    HCRYPTPROV hProv = 0;
    UUID TmpContainerUuid;
    LPWSTR pwszTmpContainer = NULL;

    // Create a temporary keyset to load the private key into
    // UuidCreate(&TmpContainerUuid);
    if (CoCreateGuid((GUID *)&TmpContainerUuid) != S_OK)
    {
        goto ErrorReturn;
    }
    if (NULL == (pwszTmpContainer = (LPWSTR) PvkAlloc(
            6 * sizeof(WCHAR) + UUID_WSTR_BYTES)))
        goto ErrorReturn;
    wcscpy(pwszTmpContainer, L"TmpKey");
    BytesToWStr(sizeof(UUID), &TmpContainerUuid, pwszTmpContainer + 6);

    if (!CryptAcquireContextU(
            &hProv,
            pwszTmpContainer,
            pwszProvName,
            dwProvType,
            CRYPT_NEWKEYSET
            ))
        goto ErrorReturn;

    if (!LoadKeyW(
            hProv,
            hRead,
            pfnRead,
            cbKeyData,
            hwndOwner,
            pwszKeyName,
            0,              // dwFlags
            pdwKeySpec
            ))
        goto DeleteKeySetReturn;

    fResult = TRUE;
    goto CommonReturn;

DeleteKeySetReturn:
    CryptReleaseContext(hProv, 0);
    CryptAcquireContextU(
        &hProv,
        pwszTmpContainer,
        pwszProvName,
        dwProvType,
        CRYPT_DELETEKEYSET
        );
    hProv = 0;
ErrorReturn:
    if (hProv) {
        CryptReleaseContext(hProv, 0);
        hProv = 0;
    }
    if (pwszTmpContainer) {
        PvkFree(pwszTmpContainer);
        pwszTmpContainer = NULL;
    }
    fResult = FALSE;

CommonReturn:
    *ppwszTmpContainer = pwszTmpContainer;
    *phCryptProv = hProv;
    return fResult;
}

static BOOL AcquireKeyContextA(
    IN LPCTSTR pszProvName,
    IN DWORD dwProvType,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbKeyData,
    IN HWND hwndOwner,
    IN LPCTSTR pszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv,
    OUT LPTSTR *ppszTmpContainer
    )
{
    DWORD hr;
    BOOL fResult;
    HCRYPTPROV hProv = 0;
    UUID TmpContainerUuid;
    LPTSTR pszTmpContainer = NULL;

    // Create a temporary keyset to load the private key into
    if (CoCreateGuid((GUID *)&TmpContainerUuid) != S_OK)
    {
        goto ErrorReturn;
    }
    if (NULL == (pszTmpContainer = (LPTSTR) PvkAlloc(
            6 * sizeof(CHAR) + UUID_STR_BYTES)))
        goto ErrorReturn;
    strcpy(pszTmpContainer, "TmpKey");
    BytesToStr(sizeof(UUID), &TmpContainerUuid, pszTmpContainer + 6);

    if (!CryptAcquireContext(
            &hProv,
            pszTmpContainer,
            pszProvName,
            dwProvType,
            CRYPT_NEWKEYSET
            ))
        goto ErrorReturn;

    if (!LoadKeyA(
            hProv,
            hRead,
            pfnRead,
            cbKeyData,
            hwndOwner,
            pszKeyName,
            0,              // dwFlags
            pdwKeySpec
            ))
        goto DeleteKeySetReturn;

    fResult = TRUE;
    goto CommonReturn;

DeleteKeySetReturn:
    CryptReleaseContext(hProv, 0);
    CryptAcquireContext(
        &hProv,
        pszTmpContainer,
        pszProvName,
        dwProvType,
        CRYPT_DELETEKEYSET
        );
    hProv = 0;
ErrorReturn:
    hr = GetLastError();
    if (hProv) {
        CryptReleaseContext(hProv, 0);
        hProv = 0;
    }
    if (pszTmpContainer) {
        PvkFree(pszTmpContainer);
        pszTmpContainer = NULL;
    }
    fResult = FALSE;

CommonReturn:
    *ppszTmpContainer = pszTmpContainer;
    *phCryptProv = hProv;
    return fResult;
}

//+-------------------------------------------------------------------------
//  Creates a temporary container in the provider and loads the private key
//  from the specified file.
//  For success, returns a handle to a cryptographic provider for the private
//  key and the name of the temporary container. PrivateKeyReleaseContext must
//  be called to release the hCryptProv and delete the temporary container.
//
//  PrivateKeyLoad is called to load the private key into the temporary
//  container.
//--------------------------------------------------------------------------
BOOL
WINAPI
PvkPrivateKeyAcquireContext(
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN HANDLE hFile,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv,
    OUT LPWSTR *ppwszTmpContainer
    )
{
    HRESULT hr = S_OK;

    if(FAILED(hr))
        return FALSE;

    BOOL fhr = AcquireKeyContextW(
        pwszProvName,
        dwProvType,
        hFile,
        ReadFromFile,
        GetFileSize(hFile, NULL),
        hwndOwner,
        pwszKeyName,
        pdwKeySpec,
        phCryptProv,
        ppwszTmpContainer
        );
    return fhr;
}

BOOL
WINAPI
PvkPrivateKeyAcquireContextA(
    IN LPCTSTR pszProvName,
    IN DWORD dwProvType,
    IN HANDLE hFile,
    IN HWND hwndOwner,
    IN LPCTSTR pszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv,
    OUT LPTSTR *ppszTmpContainer
    )
{
    HRESULT hr = S_OK;
    if(FAILED(hr))
        return FALSE;

    BOOL fhr = AcquireKeyContextA(
        pszProvName,
        dwProvType,
        hFile,
        ReadFromFile,
        GetFileSize(hFile, NULL),
        hwndOwner,
        pszKeyName,
        pdwKeySpec,
        phCryptProv,
        ppszTmpContainer
        );
    return fhr;
}

//+-------------------------------------------------------------------------
//  Creates a temporary container in the provider and loads the private key
//  from memory.
//  For success, returns a handle to a cryptographic provider for the private
//  key and the name of the temporary container. PrivateKeyReleaseContext must
//  be called to release the hCryptProv and delete the temporary container.
//
//  PrivateKeyLoadFromMemory is called to load the private key into the
//  temporary container.
//--------------------------------------------------------------------------
BOOL
WINAPI
PvkPrivateKeyAcquireContextFromMemory(
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv,
    OUT LPWSTR *ppwszTmpContainer
    )
{

    HRESULT hr = S_OK;
    if(FAILED(hr))
        return FALSE;

    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    MemInfo.cb = cbData;
    MemInfo.cbSeek = 0;
    BOOL fhr = AcquireKeyContextW(
        pwszProvName,
        dwProvType,
        (HANDLE) &MemInfo,
        ReadFromMemory,
        cbData,
        hwndOwner,
        pwszKeyName,
        pdwKeySpec,
        phCryptProv,
        ppwszTmpContainer
        );
    return fhr;
}

BOOL
WINAPI
PvkPrivateKeyAcquireContextFromMemoryA(
    IN LPCTSTR pszProvName,
    IN DWORD dwProvType,
    IN BYTE *pbData,
    IN DWORD cbData,
    IN HWND hwndOwner,
    IN LPCTSTR pszKeyName,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    OUT HCRYPTPROV *phCryptProv,
    OUT LPTSTR *ppszTmpContainer
    )
{

    HRESULT hr = S_OK;
    if(FAILED(hr))
        return FALSE;

    MEMINFO MemInfo;

    MemInfo.pb = pbData;
    MemInfo.cb = cbData;
    MemInfo.cbSeek = 0;
    BOOL fhr = AcquireKeyContextA(
        pszProvName,
        dwProvType,
        (HANDLE) &MemInfo,
        ReadFromMemory,
        cbData,
        hwndOwner,
        pszKeyName,
        pdwKeySpec,
        phCryptProv,
        ppszTmpContainer
        );
    return fhr;
}

//+-------------------------------------------------------------------------
//  Releases the cryptographic provider and deletes the temporary container
//  created by PrivateKeyAcquireContext or PrivateKeyAcquireContextFromMemory.
//--------------------------------------------------------------------------
BOOL
WINAPI
PvkPrivateKeyReleaseContext(
    IN HCRYPTPROV hCryptProv,
    IN LPCWSTR pwszProvName,
    IN DWORD dwProvType,
    IN LPWSTR pwszTmpContainer
    )
{

    HRESULT hr = S_OK;
    if(FAILED(hr))
        return FALSE;

    if (hCryptProv)
        CryptReleaseContext(hCryptProv, 0);

    if (pwszTmpContainer) {
        // Delete the temporary container for the private key from
        // the provider
        //
        // Note: for CRYPT_DELETEKEYSET, the returned hCryptProv is undefined
        // and must not be released.
        CryptAcquireContextU(
                &hCryptProv,
                pwszTmpContainer,
                pwszProvName,
                dwProvType,
                CRYPT_DELETEKEYSET
                );
        PvkFree(pwszTmpContainer);
    }

    return TRUE;
}

BOOL
WINAPI
PvkPrivateKeyReleaseContextA(
    IN HCRYPTPROV hCryptProv,
    IN LPCTSTR pszProvName,
    IN DWORD dwProvType,
    IN LPTSTR pszTmpContainer
    )
{
    HRESULT hr = S_OK;
    if(FAILED(hr))
        return FALSE;

    if (hCryptProv)
        CryptReleaseContext(hCryptProv, 0);

    if (pszTmpContainer) {
        // Delete the temporary container for the private key from
        // the provider
        //
        // Note: for CRYPT_DELETEKEYSET, the returned hCryptProv is undefined
        // and must not be released.
        CryptAcquireContext(
                &hCryptProv,
                pszTmpContainer,
                pszProvName,
                dwProvType,
                CRYPT_DELETEKEYSET
                );
        PvkFree(pszTmpContainer);
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
//  Functions supporting backwards compatibility with Bob's storage file
//  containing a snap shot of the keys as they are stored in the registry.
//  Note, for win95, the registry values are decrypted before being written to
//  the file.
//--------------------------------------------------------------------------

// Return the size of this stream; return 0 if an error
static DWORD CbBobSize(IStream *pStm)
{
    STATSTG stat;
    if (FAILED(pStm->Stat(&stat, STATFLAG_NONAME)))
        return 0;
    return stat.cbSize.LowPart;
}

// Allocate and read this value which has the indicated stream name from the
// storage
static BOOL LoadBobStream(
    IStorage *pStg,
    LPCWSTR pwszStm,
    BYTE **ppbValue,
    DWORD *pcbValue
    )
{
    BOOL fResult;
    HRESULT hr;
    IStream *pStm = NULL;
    BYTE *pbValue = NULL;
    DWORD cbValue;
    DWORD cbRead;

    if (FAILED(hr = pStg->OpenStream(pwszStm, 0,
            STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &pStm)))
        goto HrError;

    if (0 == (cbValue = CbBobSize(pStm))) goto BadBobFile;

    if (NULL == (pbValue = (BYTE *) PvkAlloc(cbValue))) goto ErrorReturn;

    pStm->Read(pbValue, cbValue, &cbRead);
    if (cbRead != cbValue) goto BadBobFile;

    fResult = TRUE;
    goto CommonReturn;

HrError:
    SetLastError((DWORD) hr);
    goto ErrorReturn;
BadBobFile:
    SetLastError(PVK_HELPER_BAD_PVK_FILE);
ErrorReturn:
    if (pbValue) {
        PvkFree(pbValue);
        pbValue = NULL;
    }
    cbValue = 0;
    fResult = FALSE;
CommonReturn:
    if (pStm)
        pStm->Release();
    *ppbValue = pbValue;
    *pcbValue = cbValue;
    return fResult;
}

// New "Bob" format::
//
// Allocate and read either the Exported Signature or Exchange Private 
// key stream from the storage
static BOOL LoadBobExportedPvk(
    IStorage *pStg,
    DWORD dwKeySpec,
    BYTE **ppbPvkValue,
    DWORD *pcbPvkValue
    )
{
    BOOL fResult;
    LPCWSTR pwszPvk;

    switch (dwKeySpec) {
    case AT_SIGNATURE:
        pwszPvk = L"Exported Signature Private Key";
        break;
    case AT_KEYEXCHANGE:
        pwszPvk = L"Exported Exchange Private Key";
        break;
    default:
        SetLastError(PVK_HELPER_BAD_PARAMETER);
        goto ErrorReturn;
    }

    fResult = LoadBobStream(pStg, pwszPvk, ppbPvkValue, pcbPvkValue);
    if (fResult) goto CommonReturn;

ErrorReturn:
    *ppbPvkValue = NULL;
    *pcbPvkValue = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

// Old "Bob" format::
//
// Allocate and read either the Signature or Exchange Private
// key streams from the storage
static BOOL LoadBobOldPvk(
    IStorage *pStg,
    DWORD dwKeySpec,
    BYTE **ppbPvkValue,
    DWORD *pcbPvkValue
    )
{
    BOOL fResult;
    LPCWSTR pwszPvk;

    switch (dwKeySpec) {
    case AT_SIGNATURE:
        pwszPvk = L"SPvk";
        break;
    case AT_KEYEXCHANGE:
        pwszPvk = L"EPvk";
        break;
    default:
        SetLastError(PVK_HELPER_BAD_PARAMETER);
        goto ErrorReturn;
    }

    fResult = LoadBobStream(pStg, pwszPvk, ppbPvkValue, pcbPvkValue);
    if (fResult) goto CommonReturn;

ErrorReturn:
    *ppbPvkValue = NULL;
    *pcbPvkValue = 0;
    fResult = FALSE;
CommonReturn:
    return fResult;
}

///////////////////////////////////////////////////////////////////////////////////////
//
// Key header structures for private key construction
//
//    These structs define the fixed data at the beginning of an RSA key.
//    They are followed by a variable length of data, sized by the stlen
//    field.
//
//    For more info see Jeff Spellman in the crypto team or look in the
//    source to RsaBase.Dll
//

typedef struct {
    DWORD       magic;                  /* Should always be RSA2 */
    DWORD       keylen;                 // size of modulus buffer
    DWORD       bitlen;                 // bit size of key
    DWORD       datalen;                // max number of bytes to be encoded
    DWORD       pubexp;                 // public exponent
} BSAFE_PRV_KEY, FAR *LPBSAFE_PRV_KEY;

typedef struct {
    BYTE    *modulus;
    BYTE    *prvexp;
    BYTE    *prime1;
    BYTE    *prime2;
    BYTE    *exp1;
    BYTE    *exp2;
    BYTE    *coef;
    BYTE    *invmod;
    BYTE    *invpr1;
    BYTE    *invpr2;
} BSAFE_KEY_PARTS, FAR *LPBSAFE_KEY_PARTS;

typedef struct {
    DWORD       magic;                  /* Should always be RSA2 */
    DWORD       bitlen;                 // bit size of key
    DWORD       pubexp;                 // public exponent
} EXPORT_PRV_KEY, FAR *PEXPORT_PRV_KEY;

///////////////////////////////////////////////////////////////////////////////////////
//
//  Take a raw exported unshrowded private key from the registry and turn it
//  into a private key export blob.
//
//  This is based on the PreparePrivateKeyForExport routine from rsabase.dll
//
static BOOL ConstructPrivateKeyExportBlob(
        IN DWORD            dwKeySpec,
        IN BSAFE_PRV_KEY *  pPrvKey,            
        IN DWORD            PrvKeyLen,
        OUT PBYTE           *ppbBlob,
        OUT DWORD           *pcbBlob
        )
{
    BOOL fResult;
    PEXPORT_PRV_KEY pExportKey;
    DWORD           cbHalfModLen;
    PBYTE           pbBlob = NULL;
    DWORD           cbBlob;
    PBYTE           pbIn;
    PBYTE           pbOut;

    cbHalfModLen = pPrvKey->bitlen / 16;
    cbBlob = sizeof(EXPORT_PRV_KEY) + 9 * cbHalfModLen +
        sizeof(PUBLICKEYSTRUC);

    if (NULL == (pbBlob = (BYTE *) PvkAlloc(cbBlob))) {
        fResult = FALSE;
        cbBlob = 0;
    } else {
        BYTE* pb = pbBlob;
        PUBLICKEYSTRUC *pPubKeyStruc = (PUBLICKEYSTRUC *) pb;
        pPubKeyStruc->bType         = PRIVATEKEYBLOB;
        pPubKeyStruc->bVersion      = 2;
        pPubKeyStruc->reserved      = 0;
        if (dwKeySpec == AT_KEYEXCHANGE)
            pPubKeyStruc->aiKeyAlg = CALG_RSA_KEYX;
        else if (dwKeySpec == AT_SIGNATURE)
            pPubKeyStruc->aiKeyAlg = CALG_RSA_SIGN;
        else
            pPubKeyStruc->aiKeyAlg = 0;

        pb = pbBlob + sizeof(PUBLICKEYSTRUC);

        // take most of the header info
        pExportKey = (PEXPORT_PRV_KEY)pb;
        pExportKey->magic  = pPrvKey->magic;
        pExportKey->bitlen = pPrvKey->bitlen;
        pExportKey->pubexp = pPrvKey->pubexp;

        pbIn = (PBYTE)pPrvKey + sizeof(BSAFE_PRV_KEY);
        pbOut = pb + sizeof(EXPORT_PRV_KEY);

        // copy all the private key info
        memcpy(pbOut, pbIn, cbHalfModLen * 2);
        pbIn += (cbHalfModLen + sizeof(DWORD)) * 2;
        pbOut += cbHalfModLen * 2;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen);
        pbIn += cbHalfModLen + sizeof(DWORD);
        pbOut += cbHalfModLen;
        memcpy(pbOut, pbIn, cbHalfModLen * 2);

        fResult = TRUE;
    }
    *ppbBlob = pbBlob;
    *pcbBlob = cbBlob;
    return fResult;
}

static BOOL LoadBobKey(
    IN HCRYPTPROV hCryptProv,
    IN HANDLE hRead,
    IN PFNREAD pfnRead,
    IN DWORD cbBobKey,
    IN HWND hwndOwner,
    IN LPCWSTR pwszKeyName,
    IN DWORD dwFlags,
    IN OUT OPTIONAL DWORD *pdwKeySpec,
    IN PFILE_HDR pHdr                   // header has already been read
    )
{
    BOOL fResult;
    DWORD dwErr = 0;
    HRESULT hr;
    HGLOBAL hGlobal = NULL;
    BYTE *pbBobKey;         // not allocated
    ILockBytes *pLkByt = NULL;
    IStorage *pStg = NULL;
    IStorage *pPrivStg = NULL;
    BYTE *pbPvkValue = NULL;
    DWORD cbPvkValue;
    DWORD dwKeySpec;

    BYTE *pbPvk = NULL;
    DWORD cbPvk;

    if (cbBobKey > MAX_BOB_FILE_LEN) goto BadBobFile;

    if (NULL == (hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_DISCARDABLE,
            cbBobKey)))
        goto ErrorReturn;

    if (NULL == (pbBobKey = (BYTE *) GlobalLock(hGlobal)))
        goto ErrorReturn;
    memcpy(pbBobKey, (BYTE *) pHdr, sizeof(FILE_HDR));
    if (cbBobKey > sizeof(FILE_HDR))
        fResult = pfnRead(hRead, pbBobKey + sizeof(FILE_HDR),
            cbBobKey - sizeof(FILE_HDR));
    else
        fResult = TRUE;
    GlobalUnlock(hGlobal);
    if (!fResult) goto ErrorReturn;

    // FALSE => don't DeleteOnRelease
    if (FAILED(hr = CreateILockBytesOnHGlobal(hGlobal, FALSE, &pLkByt)))
        goto HrError;

    if (FAILED(hr = StgOpenStorageOnILockBytes(
            pLkByt,
            NULL,       // pStgPriority
            STGM_DIRECT | STGM_READ | STGM_SHARE_DENY_WRITE,
            NULL,    // snbExclude
            0,       // dwReserved
            &pStg
            ))) goto HrError;

    if (FAILED(pStg->OpenStorage(
            L"Plain Private Key",
            0,
            STGM_READ | STGM_SHARE_EXCLUSIVE,
            NULL,
            0,
            &pPrivStg))) goto BadBobFile;

    if (pdwKeySpec && *pdwKeySpec)
        dwKeySpec = *pdwKeySpec;
    else
        dwKeySpec = AT_SIGNATURE;

    // First, attempt to read the new format where the keys are stored in
    // the private key export format
    fResult = LoadBobExportedPvk(pPrivStg, dwKeySpec, &pbPvkValue,
        &cbPvkValue);
    if (!fResult && (pdwKeySpec == NULL || *pdwKeySpec == 0)) {
        dwKeySpec = AT_KEYEXCHANGE;
        fResult = LoadBobExportedPvk(pPrivStg, dwKeySpec,
            &pbPvkValue, &cbPvkValue);
    }
    if (fResult)
        fResult =  PvkPrivateKeyLoadFromMemory(
            hCryptProv,
            pbPvkValue,
            cbPvkValue,
            hwndOwner,
            pwszKeyName,
            dwFlags,
            &dwKeySpec
            );
    else {
        // Try "old" format

        if (pdwKeySpec && *pdwKeySpec)
            dwKeySpec = *pdwKeySpec;
        else
            dwKeySpec = AT_SIGNATURE;

        fResult = LoadBobOldPvk(pPrivStg, dwKeySpec, &pbPvkValue, &cbPvkValue);
        if (!fResult && (pdwKeySpec == NULL || *pdwKeySpec == 0)) {
            dwKeySpec = AT_KEYEXCHANGE;
            fResult = LoadBobOldPvk(pPrivStg, dwKeySpec,
                &pbPvkValue, &cbPvkValue);
        }
        if (fResult) {
            BYTE *pbExportPvk;
            DWORD cbExportPvk;
            // Convert Bob's old private key format to the new export private
            // key format
            if ((fResult = ConstructPrivateKeyExportBlob(
                    dwKeySpec,
                    (BSAFE_PRV_KEY *) pbPvkValue,
                    cbPvkValue,
                    &pbExportPvk,
                    &cbExportPvk
                    ))) {
                HCRYPTKEY hKey = 0;
                // Import the private key
                fResult = CryptImportKey(hCryptProv, pbExportPvk, cbExportPvk,
                    0, dwFlags, &hKey);
                if (hKey)
                    CryptDestroyKey(hKey);
                PvkFree(pbExportPvk);
            }
        }
    }
    
    if (fResult) goto CommonReturn;
    goto ErrorReturn;

HrError:
    SetLastError((DWORD) hr);
    goto ErrorReturn;

BadBobFile:
    SetLastError(PVK_HELPER_BAD_PVK_FILE);
ErrorReturn:
    dwKeySpec = 0;
    fResult = FALSE;

    // One of the following Releases may clear it out
    dwErr = GetLastError();
CommonReturn:
    if (pbPvkValue)
        PvkFree(pbPvkValue);
    if (pPrivStg)
        pPrivStg->Release();
    if (pStg)
        pStg->Release();
    if (pLkByt)
        pLkByt->Release();
    if (hGlobal)
        GlobalFree(hGlobal);

    if (pdwKeySpec)
        *pdwKeySpec = dwKeySpec;
    if (dwErr)
        SetLastError(dwErr);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\mssign32\mssign32.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 1999
//
//  File:       signer.cpp
//
//  Contents:   Microsoft Internet Security Signing API
//
//  History:    June-25-97 xiaohs   created
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include <stdio.h>



//--------------------------------------------------------------------------
//
//	 InternalSign:
//		 The signing routine called by signer.dll internally.  This is the 
//		 function that actually does the job.
//
//--------------------------------------------------------------------------
HRESULT WINAPI 
InternalSign(IN  DWORD dwEncodingType,			// Encoding type
             IN  HCRYPTPROV hCryptProv,			// CAPI provider, opened for signing private key
             IN  DWORD dwKeySpec,				// Type of signing key, AT_SIGNATURE or AT_EXCHANGE
             IN  LPCSTR pszAlgorithmOid,		// Algorithm id used to create digest
             IN  LPSIP_SUBJECTINFO pSipInfo,    // SIP information
			 IN  DWORD	*pdwIndex,				// signer index
             IN  PCCERT_CONTEXT psSigningContext, // Cert context to the signing certificate
             IN  HCERTSTORE hSpcStore,			// The credentials to use in the signing
             IN  LPCWSTR pwszOpusName,			// Optional, the name of the program to appear in
             IN  LPCWSTR pwszOpusInfo,			// Optional, the unparsed name of a link to more
             IN  BOOL fIncludeCerts,			// add the certificates to the signature
             IN  BOOL fCommercial,				// commerical signing
			 IN  BOOL fIndividual,				// individual signing
             IN  BOOL fAuthcode,				// whether use fCommercial as an attributes
             IN  PCRYPT_ATTRIBUTES  psAuthenticated,   // Optional, authenticated attributes added to signature
             IN  PCRYPT_ATTRIBUTES  psUnauthenticated, // Optional, unauthenticated attributes added to signature
             OUT PBYTE* ppbDigest,				//Optional: return the Digest of the file
             OUT DWORD* pcbDigest,			    //Optional: return the size of the digest
             OUT PBYTE* ppbMessage,				//Optional: return the encoded signed message
             OUT DWORD* pcbMessage)				//Optional: return the size of encoded signed message
{

    HRESULT    hr = S_OK;

    SIP_DISPATCH_INFO sSip;  ZERO(sSip); // Table of sip functions

    PBYTE      pbOpusAttribute = NULL; // Encoding for the opus attribute
    DWORD      cbOpusAttribute = 0;    //    :

    PBYTE      pbStatementAttribute = NULL; // Encoding for the statement attribute
    DWORD      cbStatementAttribute = 0;    //    :

    PCRYPT_ATTRIBUTE rgpAuthAttributes = NULL;
    DWORD             dwAuthAttributes = 0;

    PCRYPT_ATTRIBUTE rgpUnauthAttributes = NULL;
    DWORD             dwUnauthAttributes = 0;

    PSIP_INDIRECT_DATA psIndirectData = NULL; // Indirect data structure
    DWORD              dwIndirectData = 0; 

    PBYTE      pbIndirectBlob = NULL; // Encoding Indirect blob
    DWORD      cbIndirectBlob = 0;    //    :

    PBYTE               pbGetBlob=NULL;
    DWORD               cbGetBlob=0;
    CRYPT_DATA_BLOB     PKCS7Blob;
    HCERTSTORE          hPKCS7CertStore=NULL;
    DWORD               dwPKCS7Certs=0;
    PCERT_BLOB          rgPKCS7Certs=NULL;

    PBYTE      pbEncodedSignMsg = NULL; // Encoding for the statement attribute
    DWORD      cbEncodedSignMsg  = 0;    //    :


    HCRYPTMSG hMsg = NULL;
    CMSG_SIGNER_ENCODE_INFO sSignerInfo;
    CMSG_SIGNED_ENCODE_INFO sSignedInfo;

    PCERT_BLOB    rgpCryptMsgCertificates = NULL;
    DWORD          dwCryptMsgCertificates = 0;
    PCRL_BLOB     rgpCryptMsgCrls = NULL;
    DWORD          dwCryptMsgCrls = 0;

    PBYTE pbSignerData = NULL;
    DWORD cbSignerData = 0;	 

	BOOL		    fSignCommercial=FALSE;
    BOOL            fCTLFile =FALSE;

    PCTL_CONTEXT    pCTLContext=NULL;

    GUID            CTLGuid=CRYPT_SUBJTYPE_CTL_IMAGE;
    GUID            CATGuid=CRYPT_SUBJTYPE_CATALOG_IMAGE;
    DWORD           dwCertIndex=0;
    BOOL            fFound=FALSE;
    BOOL            fNeedStatementType=FALSE;

    PKITRY {

        //init memory
        ZeroMemory(&sSignerInfo, sizeof(CMSG_SIGNER_ENCODE_INFO));

        ZeroMemory(&sSignedInfo, sizeof(CMSG_SIGNED_ENCODE_INFO));


		// Load up the sip functions. 
        if(!CryptSIPLoad(pSipInfo->pgSubjectType,   // GUID for the requried sip
                         0,                              // Reserved
                         &sSip))                         // Table of functions
            PKITHROW(SignError());


        // Set up the attributes (AUTHENTICODE Specific, replace with your attributes)
        // Encode the opus information up into an attribute
		if(fAuthcode)
		{
			hr = CreateOpusInfo(pwszOpusName,
                            pwszOpusInfo,
                            &pbOpusAttribute,
                            &cbOpusAttribute);
			if(hr != S_OK) PKITHROW(hr);


            //Check to see if we need to put the statement type attributes
            if(NeedStatementTypeAttr(psSigningContext, fCommercial, fIndividual))
            {
            
                fNeedStatementType=TRUE;

			    // Check signing certificate to see if its signing cabablity complies
			    //with the request
			    if(S_OK!=(hr=CheckCommercial(psSigningContext,fCommercial, fIndividual,
							    &fSignCommercial)))
				    PKITHROW(hr);
        
			    if(S_OK !=(hr = CreateStatementType(fSignCommercial,
									    &pbStatementAttribute,
									    &cbStatementAttribute)))
				    PKITHROW(hr);
            }
            else
                fNeedStatementType=FALSE;
		}

        // Create Authenticode attributes and append additional authenticated attributes.
        // Allocate and add StatementType and SpOpusInfo (add room for one blob per attribute, which we need)
        DWORD dwAttrSize = 0;

        //get the number of authenticated attributes
		if(fAuthcode)
        {
            if(fNeedStatementType)
			    dwAuthAttributes = 2;  // StatementType + opus
            else
                dwAuthAttributes= 1;
        }
		else
			dwAuthAttributes=  0;  

        if(psAuthenticated)
            dwAuthAttributes += psAuthenticated->cAttr;
        
        dwAttrSize = sizeof(CRYPT_ATTRIBUTE) * dwAuthAttributes + 2 * sizeof(CRYPT_ATTR_BLOB);
        rgpAuthAttributes = (PCRYPT_ATTRIBUTE) malloc(dwAttrSize);
        if(!rgpAuthAttributes) PKITHROW(E_OUTOFMEMORY);

        ZeroMemory(rgpAuthAttributes, dwAttrSize);
        PCRYPT_ATTR_BLOB pValue = (PCRYPT_ATTR_BLOB) (rgpAuthAttributes + dwAuthAttributes);
    
		//the start of the authenticated attributes
		dwAttrSize=0;

		//add the authenticode specific attributes
		if(fAuthcode)
		{
    
			// Update SpOpusInfo
			rgpAuthAttributes[dwAttrSize].pszObjId = SPC_SP_OPUS_INFO_OBJID;
			rgpAuthAttributes[dwAttrSize].cValue = 1;
			rgpAuthAttributes[dwAttrSize].rgValue = &pValue[dwAttrSize];
			pValue[dwAttrSize].pbData = pbOpusAttribute;
			pValue[dwAttrSize].cbData = cbOpusAttribute;
			dwAttrSize++;

			// Update StatementType
            if(fNeedStatementType)
            {
			    rgpAuthAttributes[dwAttrSize].pszObjId = SPC_STATEMENT_TYPE_OBJID;
			    rgpAuthAttributes[dwAttrSize].cValue = 1;
			    rgpAuthAttributes[dwAttrSize].rgValue = &pValue[dwAttrSize];
			    pValue[dwAttrSize].pbData = pbStatementAttribute;
			    pValue[dwAttrSize].cbData = cbStatementAttribute;
			    dwAttrSize++;
            }
		}
        
        if(psAuthenticated) {
            for(DWORD i = dwAttrSize, ii = 0; ii < psAuthenticated->cAttr; ii++, i++) 
                rgpAuthAttributes[i] = psAuthenticated->rgAttr[ii];
        }

        // Get the Unauthenticated attributes
        if(psUnauthenticated) {
            rgpUnauthAttributes = psUnauthenticated->rgAttr;
            dwUnauthAttributes = psUnauthenticated->cAttr;
        }

		//check to see if the file is either a catalog file or a CTL file 
		if((CTLGuid == (*(pSipInfo->pgSubjectType))) ||
           (CATGuid == (*(pSipInfo->pgSubjectType))) 
            )
			fCTLFile=TRUE;
		else
		{
            // Get the indirect data struct from the SIP
		    if(!sSip.pfCreate(pSipInfo,
                          &dwIndirectData,
                          psIndirectData))
                PKITHROW(SignError());


            psIndirectData = (PSIP_INDIRECT_DATA) malloc(dwIndirectData);
            if(!psIndirectData) 
                PKITHROW(E_OUTOFMEMORY);
            
            if(!sSip.pfCreate(pSipInfo,
                              &dwIndirectData,
                              psIndirectData))
                PKITHROW(SignError());
            
            // Encode the indirect data
            CryptEncodeObject(dwEncodingType,
                              SPC_INDIRECT_DATA_CONTENT_STRUCT,
                              psIndirectData,
                              pbIndirectBlob,                   
                              &cbIndirectBlob);
            if (cbIndirectBlob == 0) 
                PKITHROW(SignError());
            pbIndirectBlob = (PBYTE) malloc(cbIndirectBlob);
            if(!pbIndirectBlob)
                PKITHROW(E_OUTOFMEMORY);
            if (!CryptEncodeObject(dwEncodingType,
                                   SPC_INDIRECT_DATA_CONTENT_STRUCT,
                                   psIndirectData,
                                   pbIndirectBlob,
                                   &cbIndirectBlob))
                PKITHROW(SignError());
        }
	
        
        
        // Encode the signed message
        // Setup the signing info
        ZeroMemory(&sSignerInfo, sizeof(CMSG_SIGNER_ENCODE_INFO));
        sSignerInfo.cbSize = sizeof(CMSG_SIGNER_ENCODE_INFO);
        sSignerInfo.pCertInfo = psSigningContext->pCertInfo;
        sSignerInfo.hCryptProv = hCryptProv;
        sSignerInfo.dwKeySpec = dwKeySpec;
        sSignerInfo.HashAlgorithm.pszObjId = (char*) pszAlgorithmOid;
        sSignerInfo.cAuthAttr = dwAuthAttributes;
        sSignerInfo.rgAuthAttr = rgpAuthAttributes;
        sSignerInfo.cUnauthAttr = dwUnauthAttributes;
        sSignerInfo.rgUnauthAttr = rgpUnauthAttributes;


        // Setup the signing structures
        ZeroMemory(&sSignedInfo, sizeof(CMSG_SIGNED_ENCODE_INFO));
        sSignedInfo.cbSize = sizeof(CMSG_SIGNED_ENCODE_INFO);
        sSignedInfo.cSigners = 1;
        sSignedInfo.rgSigners = &sSignerInfo;

        //  if there are certificates to add change them to the 
        //  form required by CryptMsg... functions

        //    load up the certificates into a vector 
        //    Count the number of certs in the store
        if(fIncludeCerts && hSpcStore) {
            PCCERT_CONTEXT pCert = NULL;
            while ((pCert = CertEnumCertificatesInStore(hSpcStore, pCert)))
                dwCryptMsgCertificates++;
            
            //        Get the encoded blobs of the CERTS
            if (dwCryptMsgCertificates > 0) {
                rgpCryptMsgCertificates = (PCERT_BLOB) malloc(sizeof(CERT_BLOB) * dwCryptMsgCertificates);
                if(!rgpCryptMsgCertificates)
                    PKITHROW(E_OUTOFMEMORY);

                ZeroMemory(rgpCryptMsgCertificates, sizeof(CERT_BLOB) * dwCryptMsgCertificates);
                
                PCERT_BLOB pCertPtr = rgpCryptMsgCertificates;
                pCert = NULL;
                DWORD c = 0;
                while ((pCert = CertEnumCertificatesInStore(hSpcStore, pCert)) && c < dwCryptMsgCertificates) {
                    pCertPtr->pbData = pCert->pbCertEncoded;
                    pCertPtr->cbData = pCert->cbCertEncoded;
                    c++; pCertPtr++;
                }
            }
            sSignedInfo.cCertEncoded = dwCryptMsgCertificates;
            sSignedInfo.rgCertEncoded = rgpCryptMsgCertificates;

            rgpCryptMsgCertificates=NULL;

            //        Get the encoded blobs of the CRLS
            DWORD crlFlag = 0;
            PCCRL_CONTEXT pCrl = NULL;
            while ((pCrl = CertGetCRLFromStore(hSpcStore, NULL, pCrl, &crlFlag)))
                dwCryptMsgCrls++;
            
            if (dwCryptMsgCrls > 0) {
                rgpCryptMsgCrls = (PCRL_BLOB) malloc(sizeof(CRL_BLOB) * dwCryptMsgCrls);
                if(!rgpCryptMsgCrls) PKITHROW(E_OUTOFMEMORY);

                ZeroMemory(rgpCryptMsgCrls, sizeof(CRL_BLOB) * dwCryptMsgCrls);
                PCRL_BLOB pCrlPtr = rgpCryptMsgCrls;
                pCrl = NULL;
                DWORD c = 0;
                while ((pCrl = CertGetCRLFromStore(hSpcStore, NULL, pCrl, &crlFlag)) && c < dwCryptMsgCrls) {
                    pCrlPtr->pbData = pCrl->pbCrlEncoded;
                    pCrlPtr->cbData = pCrl->cbCrlEncoded;
                    c++; pCrlPtr++;
                }
            }
            sSignedInfo.cCrlEncoded = dwCryptMsgCrls;
            sSignedInfo.rgCrlEncoded = rgpCryptMsgCrls;

            rgpCryptMsgCrls=NULL;
        }
        
        //check to see if the subject is a CTL file.  If it is, we need to preserve
        //all the certificates in the original signer Info
        if(CTLGuid == (*(pSipInfo->pgSubjectType)))
        {
            PCCERT_CONTEXT pCert = NULL;

            //call Get the get the original signer information
            sSip.pfGet(pSipInfo, &dwEncodingType, *pdwIndex, &cbGetBlob, NULL);
            
            if (cbGetBlob < 1)
            {
                PKITHROW(SignError());
            }

            if (!(pbGetBlob = (BYTE *)malloc(cbGetBlob)))
            {
                PKITHROW(E_OUTOFMEMORY);
            }

            if (!(sSip.pfGet(pSipInfo, &dwEncodingType, *pdwIndex, &cbGetBlob, pbGetBlob)))
            {
                PKITHROW(SignError());
            }

            //open the PKCS7 BLOB as a certificate store
            PKCS7Blob.cbData=cbGetBlob;
            PKCS7Blob.pbData=pbGetBlob;

            hPKCS7CertStore=CertOpenStore(CERT_STORE_PROV_PKCS7,
                                          dwEncodingType,
                                          NULL,
                                          0,
                                          &PKCS7Blob);

            if(!hPKCS7CertStore)
                PKITHROW(SignError());  

            //enum all the certificate in the store
            while ((pCert = CertEnumCertificatesInStore(hPKCS7CertStore, pCert)))
                dwPKCS7Certs++;
            
            //Get the encoded blobs of the CERTS
            if (dwPKCS7Certs > 0) 
            {
                sSignedInfo.rgCertEncoded = (PCERT_BLOB) 
                                realloc(sSignedInfo.rgCertEncoded, 
                                sizeof(CERT_BLOB) * (sSignedInfo.cCertEncoded+dwPKCS7Certs));

                if(!sSignedInfo.rgCertEncoded)
                    PKITHROW(E_OUTOFMEMORY);
                
                PCERT_BLOB pCertPtr = (sSignedInfo.rgCertEncoded + sSignedInfo.cCertEncoded);
                pCert = NULL;
                DWORD c = 0;
                while ((pCert = CertEnumCertificatesInStore(hPKCS7CertStore, pCert)) && c < dwPKCS7Certs) 
                {
                   fFound=FALSE;

                    //we need to make sure that we do not add duplicated certificates
                    for(dwCertIndex=0; dwCertIndex<sSignedInfo.cCertEncoded; dwCertIndex++)
                    {
                        if((sSignedInfo.rgCertEncoded[dwCertIndex]).cbData==pCert->cbCertEncoded)
                        {
                          if(0==memcmp((sSignedInfo.rgCertEncoded[dwCertIndex]).pbData,
                                       pCert->pbCertEncoded, pCert->cbCertEncoded))
                          {
                               fFound=TRUE;
                               break;
                          }
                        }

                    }

                    //we only add the certificates that do not duplicates the signer's
                    //certificates
                    if(FALSE==fFound)
                    {
                        pCertPtr->pbData = pCert->pbCertEncoded;
                        pCertPtr->cbData = pCert->cbCertEncoded;
                        c++; pCertPtr++; 
                    }
                }
            
                sSignedInfo.cCertEncoded += c;
            }
        }

        if (fCTLFile)
        {
            //
            //  get the signed message if we need to
            //
            if(NULL==pbGetBlob)
            {
                //
                sSip.pfGet(pSipInfo, &dwEncodingType, *pdwIndex, &cbGetBlob, NULL);
            
                if (cbGetBlob < 1)
                {
                    PKITHROW(SignError());
                }
                if (!(pbGetBlob = (BYTE *)malloc(cbGetBlob)))
                {
                    PKITHROW(E_OUTOFMEMORY);
                }

                if (!(sSip.pfGet(pSipInfo, &dwEncodingType, *pdwIndex, &cbGetBlob, pbGetBlob)))
                {
                    PKITHROW(SignError());
                } 
            }

            //
            //  extract the inner content
            //
            
            pCTLContext = (PCTL_CONTEXT)CertCreateCTLContext(
                                                    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                                    pbGetBlob,
                                                    cbGetBlob);

            if (!(pCTLContext))
            {
                PKITHROW(SignError());
            }

            if (!(pCTLContext->pbCtlContent))
            {
                PKITHROW(SignError());
            }

            //
            //  add singer info! (e.g.: sign it!)
            //
            cbEncodedSignMsg = 0;

            CryptMsgSignCTL(dwEncodingType, pCTLContext->pbCtlContent, pCTLContext->cbCtlContent,
                                &sSignedInfo, 0, NULL, &cbEncodedSignMsg);

            if (cbEncodedSignMsg < 1)
            {
                PKITHROW(SignError());
            }

            if (!(pbEncodedSignMsg = (BYTE *)malloc(cbEncodedSignMsg)))
            {
                PKITHROW(E_OUTOFMEMORY);
            }

            if (!(CryptMsgSignCTL(dwEncodingType, 
                                  pCTLContext->pbCtlContent, pCTLContext->cbCtlContent,
                                  &sSignedInfo, 0, pbEncodedSignMsg, &cbEncodedSignMsg)))
            {
                PKITHROW(SignError());
            }

            CertFreeCTLContext(pCTLContext);
            pCTLContext = NULL;
        }
        else
        {
            hMsg = CryptMsgOpenToEncode(dwEncodingType,
                                        0,                      // dwFlags
                                        CMSG_SIGNED,
                                        &sSignedInfo,
                                        SPC_INDIRECT_DATA_OBJID,
                                        NULL);
            if(hMsg == NULL)
                PKITHROW(SignError());
            
            if (!CryptMsgUpdate(hMsg,
                                pbIndirectBlob,
                                cbIndirectBlob,
                                TRUE))  // Final
                PKITHROW(SignError());
            
            CryptMsgGetParam(hMsg,
                             CMSG_CONTENT_PARAM,
                             0,                      // dwIndex
                             NULL,                   // pbSignedData
                             &cbEncodedSignMsg);
            if (cbEncodedSignMsg == 0) PKITHROW(SignError());
            
            pbEncodedSignMsg = (PBYTE) malloc(cbEncodedSignMsg);
            if(!pbEncodedSignMsg) PKITHROW(E_OUTOFMEMORY);
            
            if (!CryptMsgGetParam(hMsg,
                                  CMSG_CONTENT_PARAM,
                                  0,                      // dwIndex
                                  pbEncodedSignMsg,
                                  &cbEncodedSignMsg))
                PKITHROW(SignError());
        }
        
        //put the signatures if we are dealing with anything other than the BLOB
        if(pSipInfo->dwUnionChoice != MSSIP_ADDINFO_BLOB)
        {
            // Purge all the signatures in the subject
            sSip.pfRemove(pSipInfo, *pdwIndex);

            // Store the Signed Message in the sip
            if(!(sSip.pfPut(    pSipInfo,
                                dwEncodingType,
                                pdwIndex,
                                cbEncodedSignMsg,
                                pbEncodedSignMsg)))
            {
                PKITHROW(SignError());
            }
        }

        if(ppbMessage && pcbMessage) {
            *ppbMessage = pbEncodedSignMsg;
            pbEncodedSignMsg = NULL;
            *pcbMessage = cbEncodedSignMsg;
        }

        if(ppbDigest && pcbDigest) {
            // Get the encrypted digest
            pbSignerData = NULL;
            CryptMsgGetParam(hMsg,
                             CMSG_ENCRYPTED_DIGEST,
                             0,                      // dwIndex
                             pbSignerData,
                             &cbSignerData);
            if(cbSignerData == 0) PKITHROW(SignError());
            
            pbSignerData = (PBYTE)  malloc(cbSignerData);
            if(!pbSignerData) PKITHROW(E_OUTOFMEMORY);
            
            if(!CryptMsgGetParam(hMsg,
                                 CMSG_ENCRYPTED_DIGEST,
                                 0,                      // dwIndex
                                 pbSignerData,
                                 &cbSignerData))
                PKITHROW(SignError());
            *ppbDigest = pbSignerData;
            pbSignerData = NULL;
            *pcbDigest = cbSignerData;
        }
    }
    PKICATCH(err) {
        hr = err.pkiError;
    } PKIEND;

    if (pCTLContext)
    {
        CertFreeCTLContext(pCTLContext);
    }

    if (pbSignerData) 
        free(pbSignerData);
    if(pbEncodedSignMsg)
        free(pbEncodedSignMsg);
    if(hMsg)
        CryptMsgClose(hMsg);

    if(sSignedInfo.rgCrlEncoded)
        free(sSignedInfo.rgCrlEncoded);

    if(sSignedInfo.rgCertEncoded)
        free(sSignedInfo.rgCertEncoded);

    if(pbIndirectBlob)                      
        free(pbIndirectBlob);
    if(pbGetBlob)
        free(pbGetBlob);
    if(hPKCS7CertStore)
        CertCloseStore(hPKCS7CertStore,0);
    if(psIndirectData)
        free(psIndirectData);
    if(rgpAuthAttributes)
        free(rgpAuthAttributes);
    if(pbStatementAttribute)
        free(pbStatementAttribute);
    if(pbOpusAttribute)
        free(pbOpusAttribute);
    return hr;
}


//--------------------------------------------------------------------------
//
//  SignerTimeStamp:
//		Timestamp a file.  
//
//--------------------------------------------------------------------------
HRESULT WINAPI 
SignerTimeStamp(
IN  SIGNER_SUBJECT_INFO	*pSubjectInfo,		//Required: The subject to be timestamped 
IN  LPCWSTR				pwszHttpTimeStamp,	// Required: timestamp server HTTP address
IN  PCRYPT_ATTRIBUTES	psRequest,			// Optional, attributes added to the timestamp 
IN	LPVOID				pSipData			// Optional: The additional data passed to sip funcitons
)
{
    return SignerTimeStampEx(0,
                            pSubjectInfo,
                           pwszHttpTimeStamp,
                           psRequest,
                           pSipData,
                           NULL);
}

//--------------------------------------------------------------------------
//
//  SignerTimeStampEx:
//		Timestamp a file.  
//
//--------------------------------------------------------------------------
HRESULT WINAPI 
SignerTimeStampEx(
IN  DWORD               dwFlags,            //Reserved: Has to be set to 0.
IN  SIGNER_SUBJECT_INFO	*pSubjectInfo,		//Required: The subject to be timestamped 
IN  LPCWSTR				pwszHttpTimeStamp,	// Required: timestamp server HTTP address
IN  PCRYPT_ATTRIBUTES	psRequest,			// Optional, attributes added to the timestamp 
IN	LPVOID				pSipData,			// Optional: The additional data passed to sip funcitons
OUT SIGNER_CONTEXT      **ppSignerContext   // Optional: The signed BLOB.  User has to free
                                            //          the context via SignerFreeSignerContext
)		
{
	HRESULT		hr=E_FAIL;
	DWORD		dwTimeStampRequest=0;
	BYTE		*pbTimeStampRequest=NULL;
	DWORD		dwTimeStampResponse=0;
	BYTE		*pbTimeStampResponse=NULL;
	CHttpTran   cTran;
	BOOL		fOpen=FALSE;
	DWORD		err;
	LPSTR		szURL=NULL;
	DWORD		dwEncodingType=OCTET_ENCODING;
	CHAR		*pEncodedRequest=NULL;
	DWORD		dwEncodedRequest=0;
	CHAR		*pEncodedResponse=NULL;
	DWORD		dwEncodedResponse=0;

	//input parameter check
	if((!pwszHttpTimeStamp) ||(FALSE==CheckSigncodeSubjectInfo(pSubjectInfo)))
		return E_INVALIDARG;

	//request a time stamp
	hr=SignerCreateTimeStampRequest(pSubjectInfo,
								psRequest,
								pSipData,
								NULL,
								&dwTimeStampRequest);

	if(hr!=S_OK)
		goto CLEANUP;

	pbTimeStampRequest=(BYTE *)malloc(dwTimeStampRequest);

	if(!pbTimeStampRequest)
	{
		hr=E_OUTOFMEMORY;
		goto CLEANUP;
	}


   	hr=SignerCreateTimeStampRequest(pSubjectInfo,
								psRequest,
								pSipData,
								pbTimeStampRequest,
								&dwTimeStampRequest);

   if(hr!=S_OK)
	   goto CLEANUP;

   //conver the WSTR of URL to STR
   if((hr=WSZtoSZ((LPWSTR)pwszHttpTimeStamp,&szURL))!=S_OK)
	   goto CLEANUP;

   //base64 encode the request
   if(S_OK!=(hr=BytesToBase64(pbTimeStampRequest, 
	   dwTimeStampRequest, 
	   &pEncodedRequest,
	   &dwEncodedRequest)))
	   goto CLEANUP;

   //estalish the connection between the http site
   err=cTran.Open( szURL, GTREAD|GTWRITE);

   if(err!=ERROR_SUCCESS)
   {
		hr=E_FAIL;
		goto CLEANUP;
   }

   //mark that we have open the connection successful
   fOpen=TRUE;


   //send the request
   err=cTran.Send(dwEncodingType,dwEncodedRequest,(BYTE *)pEncodedRequest);

   if(err!=ERROR_SUCCESS)
   {
		hr=HRESULT_FROM_WIN32(ERROR_INVALID_FUNCTION);
		goto CLEANUP;
   }

      //send the request
   err=cTran.Receive(&dwEncodingType,&dwEncodedResponse,(BYTE **)&pEncodedResponse);

   if(err!=ERROR_SUCCESS)
   {
		hr=E_FAIL;
		goto CLEANUP;
   }
	  
   //make sure the encoding type is correct
  // if(dwEncodingType!=OCTET_ENCODING)
  // {
//		hr=E_FAIL;
//		goto CLEANUP;
 //  }

   //base64 decode the response
   if(S_OK != (hr=Base64ToBytes(
	   pEncodedResponse,
	   dwEncodedResponse,
	   &pbTimeStampResponse,
	   &dwTimeStampResponse)))
	   goto CLEANUP;


   //add the timestamp response to the time
   hr=SignerAddTimeStampResponseEx(0, pSubjectInfo,pbTimeStampResponse,
								dwTimeStampResponse, pSipData,
                                ppSignerContext);



CLEANUP:
		  
   if(pEncodedRequest)
	   free(pEncodedRequest);

   if(pbTimeStampResponse)
	   free(pbTimeStampResponse);

   if(pbTimeStampRequest)
	   free(pbTimeStampRequest);

   if(szURL)
	   free(szURL);

   if(fOpen)
   {
		if(pEncodedResponse)
			cTran.Free((BYTE *)pEncodedResponse);

		cTran.Close();
   }

	return hr;

}
//+-----------------------------------------------------------------------
//  
//  SignerSign:
//		Sign and/or timestamp a file.
//     
//------------------------------------------------------------------------

HRESULT WINAPI 
SignerSign(
IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,		//Required: The subject to be signed and/or timestamped 
IN	SIGNER_CERT				*pSignerCert,		//Required: The signing certificate to use
IN	SIGNER_SIGNATURE_INFO	*pSignatureInfo,	//Required: The signature information during signing process
IN	SIGNER_PROVIDER_INFO	*pProviderInfo,		//Optional:	The crypto security provider to use.
												//			This parameter has to be set unless
												//			certStoreInfo is set in *pSignerCert
												//			and the signing certificate has provider
												//			information associated with it
IN  LPCWSTR					pwszHttpTimeStamp,	//Optional: Timestamp server http address.  If this parameter
												//			is set, the file will be timestamped.
IN  PCRYPT_ATTRIBUTES		psRequest,			//Optional: Attributes added to Time stamp request. Ignored
												//			unless pwszHttpTimeStamp is set   
IN	LPVOID					pSipData			//Optional: The additional data passed to sip funcitons
)
{

    return SignerSignEx(
                0,
               pSubjectInfo,		
               pSignerCert,		
               pSignatureInfo,	
               pProviderInfo,		
               pwszHttpTimeStamp,	
               psRequest,			
               pSipData,
               NULL);

}


//+-----------------------------------------------------------------------
//  
//  SignerSignEx:
//		Sign and/or timestamp a file.
//     
//------------------------------------------------------------------------

HRESULT WINAPI 
SignerSignEx(
IN  DWORD                   dwFlags,            //Reserved: Has to be set to 0.
IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,		//Required: The subject to be signed and/or timestamped 
IN	SIGNER_CERT				*pSignerCert,		//Required: The signing certificate to use
IN	SIGNER_SIGNATURE_INFO	*pSignatureInfo,	//Required: The signature information during signing process
IN	SIGNER_PROVIDER_INFO	*pProviderInfo,		//Optional:	The crypto security provider to use.
												//			This parameter has to be set unless
												//			certStoreInfo is set in *pSignerCert
												//			and the signing certificate has provider
												//			information associated with it
IN  LPCWSTR					pwszHttpTimeStamp,	//Optional: Timestamp server http address.  If this parameter
												//			is set, the file will be timestamped.
IN  PCRYPT_ATTRIBUTES		psRequest,			//Optional: Attributes added to Time stamp request. Ignored
												//			unless pwszHttpTimeStamp is set   
IN	LPVOID					pSipData,			//Optional: The additional data passed to sip funcitons
OUT SIGNER_CONTEXT          **ppSignerContext   //Optional: The signed BLOB.  User has to free
                                                //          the context via SignerFreeSignerContext
)									
{

    HRESULT				hr = S_OK;
    HANDLE				hFile = NULL;      // File to sign
	BOOL				fFileOpen=FALSE;
    HCERTSTORE			hSpcStore = NULL;  // Certificates added to signature
    PCCERT_CONTEXT		psSigningContext = NULL; // Cert context to the signing certificate

    GUID				gSubjectGuid; // The subject guid used to load the sip
    SIP_SUBJECTINFO		sSubjInfo; ZERO(sSubjInfo);
	MS_ADDINFO_BLOB		sBlob; 

    HCRYPTPROV			hCryptProv = NULL; // Crypto provider, uses private key container
	HCRYPTPROV			hMSBaseProv = NULL; //This is the MS base provider for hashing purpose
    LPWSTR				pwszTmpContainer = NULL; // Pvk container (opened up pvk file)
	LPWSTR				pwszProvName=NULL;
	DWORD				dwProvType;
	BOOL				fAcquired=FALSE;

	LPCWSTR				pwszPvkFile = NULL;
	LPCWSTR				pwszKeyContainerName = NULL; 
	BOOL				fAuthcode=FALSE;
	BOOL				fCertAcquire=FALSE;

	//set dwKeySpec to 0.  That is, we allow any key specification 
	//for code signing
    DWORD				dwKeySpec = 0; 
    DWORD				dwEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING; // For this version we default to this.
    LPCSTR				pszAlgorithmOid = NULL;
	WCHAR				wszPublisher[40];

    PBYTE               pbEncodedMessage=NULL;			
    DWORD               cbEncodedMessage=0;			


	//input parameter checking
	if(!CheckSigncodeParam(pSubjectInfo, pSignerCert, pSignatureInfo,
					pProviderInfo))
		return E_INVALIDARG;

	//determine if this is an authenticode specific signing
	if(pSignatureInfo->dwAttrChoice==SIGNER_AUTHCODE_ATTR)
		fAuthcode=TRUE;

    //init
    if(ppSignerContext)
        *ppSignerContext=NULL;
            
	// Acquire a context for the specified provider

	// First,try to acquire the provider context based on the properties on a cert
	if(pSignerCert->dwCertChoice==SIGNER_CERT_STORE)
	{
		if(GetCryptProvFromCert(pSignerCert->hwnd,
							(pSignerCert->pCertStoreInfo)->pSigningCert,
							&hCryptProv,
							&dwKeySpec,
							&fAcquired,
							&pwszTmpContainer,
							&pwszProvName,
							&dwProvType))
		    //mark that we acquire the context via the cert's property
		    fCertAcquire=TRUE;
	}

	// If the 1st failed, try to acquire the provider context based on 
	//pPvkInfo
	if(hCryptProv==NULL)
	{
		//pProviderInfo has to be set
		if(!pProviderInfo)
		{
			hr=CRYPT_E_NO_PROVIDER;
			goto CLEANUP;
		}

		//decide the PVK file name or the key container name
		if(pProviderInfo->dwPvkChoice == PVK_TYPE_FILE_NAME)
			pwszPvkFile=pProviderInfo->pwszPvkFileName;
		else
			pwszKeyContainerName=pProviderInfo->pwszKeyContainer;

		//load from the resource of string L"publisher"
		if(0==LoadStringU(hInstance, IDS_Publisher, wszPublisher, 40))
		{
			hr=SignError();
			goto CLEANUP;
		}

		//acquire the context
		if(S_OK != (hr=PvkGetCryptProv(
							pSignerCert->hwnd,
							wszPublisher,
							pProviderInfo->pwszProviderName,
							pProviderInfo->dwProviderType,
							pwszPvkFile,
							pwszKeyContainerName,
							&(pProviderInfo->dwKeySpec),
							&pwszTmpContainer,
							&hCryptProv)))
		{
			hr=CRYPT_E_NO_PROVIDER;
			goto CLEANUP;
		}

		//mark the hCryptProv is acquired
		fAcquired=TRUE;

		//mark the key spec that we used
		dwKeySpec=pProviderInfo->dwKeySpec;
	}


	//now, acquire a MS base crypto provider for any operation other than
	//signing

	if(!CryptAcquireContext(&hMSBaseProv,
                            NULL,
                            MS_DEF_PROV,
                            PROV_RSA_FULL,
                            CRYPT_VERIFYCONTEXT))
    {
		hr=GetLastError();
		goto CLEANUP;
	}

	

	//build a certificate store, which includes the signing certificate,
	//and all the certs necessary in the signature
    //get the signing certificate
	if(S_OK != (hr = BuildCertStore(hCryptProv,
                                    dwKeySpec,
                                    hMSBaseProv, 
                                    dwEncodingType,
                                    pSignerCert, 
                                    &hSpcStore,
                                    &psSigningContext)))
		goto CLEANUP;      
	
	//check the time validity of the signing certificate
	if(0!=CertVerifyTimeValidity(NULL, psSigningContext->pCertInfo))
	{
		hr=CERT_E_EXPIRED;
		goto CLEANUP;
	}

    // Determine the hashing algorithm
    pszAlgorithmOid = CertAlgIdToOID(pSignatureInfo->algidHash);
            
    // Set up the sip information 
    sSubjInfo.hProv = hMSBaseProv;
    sSubjInfo.DigestAlgorithm.pszObjId = (char*) pszAlgorithmOid;
    sSubjInfo.dwEncodingType = dwEncodingType;
    sSubjInfo.cbSize = sizeof(SIP_SUBJECTINFO); // Version
	sSubjInfo.pClientData = pSipData;
		   

	//set up file information
	if(pSubjectInfo->dwSubjectChoice==SIGNER_SUBJECT_FILE)
	{
		// Open up the file
		if((pSubjectInfo->pSignerFileInfo->hFile)==NULL ||
			(pSubjectInfo->pSignerFileInfo->hFile)==INVALID_HANDLE_VALUE)
		{
			if(S_OK != (hr = SignOpenFile(
							pSubjectInfo->pSignerFileInfo->pwszFileName, &hFile)))
				goto CLEANUP;

			fFileOpen=TRUE;
		}
		else
			hFile=pSubjectInfo->pSignerFileInfo->hFile;

		// Get the subject type.
		if(S_OK != (hr=SignGetFileType(hFile, pSubjectInfo->pSignerFileInfo->pwszFileName, &gSubjectGuid)))
			goto CLEANUP;


		sSubjInfo.pgSubjectType = (GUID*) &gSubjectGuid;
		sSubjInfo.hFile = hFile;
		sSubjInfo.pwsFileName = pSubjectInfo->pSignerFileInfo->pwszFileName;
	}
	else
	{
		 memset(&sBlob, 0, sizeof(MS_ADDINFO_BLOB));

		 sSubjInfo.pgSubjectType=pSubjectInfo->pSignerBlobInfo->pGuidSubject;
		 sSubjInfo.pwsDisplayName=pSubjectInfo->pSignerBlobInfo->pwszDisplayName;
		 sSubjInfo.dwUnionChoice=MSSIP_ADDINFO_BLOB;
		 sSubjInfo.psBlob=&sBlob;

		 sBlob.cbStruct=sizeof(MS_ADDINFO_BLOB);
		 sBlob.cbMemObject=pSubjectInfo->pSignerBlobInfo->cbBlob;
		 sBlob.pbMemObject=pSubjectInfo->pSignerBlobInfo->pbBlob;
	}

	//now call InternalSign to do the real work
    hr = InternalSign(dwEncodingType,
          hCryptProv,
          dwKeySpec,
          pszAlgorithmOid,
          &sSubjInfo,
		  pSubjectInfo->pdwIndex,
          psSigningContext,
          hSpcStore,
		  fAuthcode ? pSignatureInfo->pAttrAuthcode->pwszName : NULL,
		  fAuthcode ? pSignatureInfo->pAttrAuthcode->pwszInfo : NULL,
          TRUE,
		  fAuthcode ? pSignatureInfo->pAttrAuthcode->fCommercial : FALSE,
		  fAuthcode ? pSignatureInfo->pAttrAuthcode->fIndividual : FALSE,
          fAuthcode,
          pSignatureInfo->psAuthenticated,
          pSignatureInfo->psUnauthenticated,
          NULL,
          NULL,
          &pbEncodedMessage,
          &cbEncodedMessage);

    if ((hFile) && (fFileOpen == TRUE) && !(sSubjInfo.hFile)) 
    {
        fFileOpen = FALSE;  // we opened it, but, the SIP closed it!
    }

    if(hr != S_OK) 
		goto CLEANUP;

	//timestamp the file if requested
	if(pwszHttpTimeStamp)
	{
		if(S_OK != (hr =SignerTimeStampEx(0,
                                          pSubjectInfo,pwszHttpTimeStamp, 
                                          psRequest,pSipData,
                                          ppSignerContext)))
			goto CLEANUP;
    }
    else
    {
        if(ppSignerContext)
        {
            //set up the context information
            *ppSignerContext=(SIGNER_CONTEXT *)malloc(sizeof(SIGNER_CONTEXT));

            if(NULL==(*ppSignerContext))
            {
                hr=E_OUTOFMEMORY;
                goto CLEANUP;
            }

            (*ppSignerContext)->cbSize=sizeof(SIGNER_CONTEXT);
            (*ppSignerContext)->cbBlob=cbEncodedMessage;
            (*ppSignerContext)->pbBlob=pbEncodedMessage;
            pbEncodedMessage=NULL;
        }
    }

    hr=S_OK;


CLEANUP:

	//free the memory. 
    if(pbEncodedMessage)
        free(pbEncodedMessage);

    if(psSigningContext) 
        CertFreeCertificateContext(psSigningContext);

    if(hSpcStore) 
		CertCloseStore(hSpcStore, 0);

	//free the CryptProvider
	if(hCryptProv)
	{
		if(fCertAcquire)
		{
		   FreeCryptProvFromCert(fAcquired,
								 hCryptProv,
								 pwszProvName,
								 dwProvType,
								 pwszTmpContainer);
		}
		else
		{
			PvkFreeCryptProv(hCryptProv,
							 pProviderInfo? pProviderInfo->pwszProviderName : NULL,
							 pProviderInfo? pProviderInfo->dwProviderType : 0,
							 pwszTmpContainer);
		}
	}

	if(hMSBaseProv)
	{
		CryptReleaseContext(hMSBaseProv, 0);
	}


    if(hFile && (fFileOpen==TRUE)) 
		CloseHandle(hFile);

#if (1) //DSIE: bug 306005.
    if (hr != S_OK && !HRESULT_SEVERITY(hr))
    {
        // Some CAPIs does not return HRESULT. They return Win API errors,
        // so need to convert to HRESULT so that caller using the FAILED
        // macro will catch the error.
        hr = HRESULT_FROM_WIN32((DWORD) hr);
    }
#endif

    return hr;
}


//+-----------------------------------------------------------------------
//  
// SignerFreeSignerContext
//     
//------------------------------------------------------------------------
HRESULT WINAPI
SignerFreeSignerContext(
IN  SIGNER_CONTEXT          *pSignerContext)
{
    if(pSignerContext)
    {
        if(pSignerContext->pbBlob)
            free(pSignerContext->pbBlob);

        free(pSignerContext);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\mssign32\pvkdlg.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       pvkdlg.cpp
//
//  Contents:   Private Key Dialog Box APIs.
//
//  Functions:  PvkDlgGetKeyPassword
//
//  History:    12-May-96   philh created
//
//--------------------------------------------------------------------------


#include "global.hxx"
#include <assert.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <memory.h>
#include <time.h>

#include "pvk.h"

// ENTER_PASSWORD:
//  IDC_PASSWORD0 - Password

// CREATE_PASSWORD:
//  IDC_PASSWORD0 - Password
//  IDC_PASSWORD1 - Confirm Password


typedef struct _KEY_PASSWORD_PARAM {
    PASSWORD_TYPE   PasswordType;
    LPWSTR          pwszKey;           // IDC_KEY
    LPSTR           *ppszPassword;
} KEY_PASSWORD_PARAM, *PKEY_PASSWORD_PARAM;


// Where to get the dialog resources from

// Forward reference to local functions
static int GetPassword(
            IN HWND hwndDlg,
            IN PASSWORD_TYPE PasswordType,
            OUT LPSTR *ppszPassword
            );

static INT_PTR CALLBACK KeyPasswordDlgProc(
            IN HWND hwndDlg,
            IN UINT uMsg,
            IN WPARAM wParam,
            IN LPARAM lParam
            );

//+-------------------------------------------------------------------------
//  Enter or Create Private Key Password Dialog Box
//--------------------------------------------------------------------------
int PvkDlgGetKeyPassword(
            IN PASSWORD_TYPE PasswordType,
            IN HWND hwndOwner,
            IN LPCWSTR pwszKeyName,
            OUT BYTE **ppbPassword,
            OUT DWORD *pcbPassword
            )
{
    int nResult;
    LPSTR pszPassword = NULL;
    KEY_PASSWORD_PARAM KeyPasswordParam = {
        PasswordType,
        (LPWSTR) pwszKeyName,
        &pszPassword
    };

    LPCSTR pszTemplate = PasswordType == ENTER_PASSWORD ?
        MAKEINTRESOURCE(IDD_ENTERKEYPASSWORD) :
        MAKEINTRESOURCE(IDD_CREATEKEYPASSWORD);

    nResult = (BOOL)DialogBoxParam(
        GetInstanceHandle(),
        pszTemplate,
        hwndOwner,
        KeyPasswordDlgProc,
        (LPARAM) &KeyPasswordParam
        );

    *ppbPassword = (BYTE *) pszPassword;
    if (pszPassword)
        *pcbPassword = strlen(pszPassword);
    else
        *pcbPassword = 0;

    return nResult;
}

//+-------------------------------------------------------------------------
//  Allocate and get the password(s) from the dialog box
//
//  For no password input, returns NULL
//  pointer for the password. Otherwise, the password is PvkAlloc'ed.
//--------------------------------------------------------------------------
static int GetPassword(
            IN HWND hwndDlg,
            IN PASSWORD_TYPE PasswordType,
            OUT LPSTR *ppszPassword
            )
{
    LPSTR rgpszPassword[2] = {NULL, NULL};
	WCHAR	wszNoPassword[128];
	WCHAR	wszPasswordNoMatch[128];

    *ppszPassword = NULL;

    // Get the entered password(s)
    assert(PasswordType < 2);
    int i;
    for (i = 0; i <= PasswordType; i++) {
        LONG cchPassword;
        cchPassword = (LONG)SendDlgItemMessage(
            hwndDlg,
            IDC_PASSWORD0 + i,
            EM_LINELENGTH,
            (WPARAM) 0,
            (LPARAM) 0
            );
        if (cchPassword > 0) {
            rgpszPassword[i] = (LPSTR) PvkAlloc(cchPassword + 1);
            assert(rgpszPassword[i]);
            if (rgpszPassword[i])
                GetDlgItemText(
                    hwndDlg,
                    IDC_PASSWORD0 + i,
                    rgpszPassword[i],
                    cchPassword + 1
                    );
        }
    }

    if (PasswordType == ENTER_PASSWORD) {
        *ppszPassword = rgpszPassword[0];
        return IDOK;
    }

    int nResult = IDOK;
#define MSG_BOX_TITLE_LEN 128
    WCHAR wszMsgBoxTitle[MSG_BOX_TITLE_LEN];
    GetWindowTextU(hwndDlg, wszMsgBoxTitle, MSG_BOX_TITLE_LEN);

    if (rgpszPassword[0] == NULL && rgpszPassword[1] == NULL) {

		if(0 == LoadStringU(hInstance, IDS_NO_PASSWORD, wszNoPassword, 128))
			wcscpy(wszNoPassword, L"Without password protection ?");

        // Didn't enter a password
        nResult = MessageBoxU(
            hwndDlg,
            wszNoPassword,
            wszMsgBoxTitle,
            MB_YESNOCANCEL | MB_ICONQUESTION | MB_DEFBUTTON2
            );
        if (nResult == IDYES)
            nResult = IDOK;
        else if (nResult == IDNO)
            nResult = IDRETRY;
    } else if (rgpszPassword[0] == NULL || rgpszPassword[1] == NULL ||
               strcmp(rgpszPassword[0], rgpszPassword[1]) != 0) {

		if(0 == LoadStringU(hInstance, IDS_PASSWORD_NO_MATCH, wszPasswordNoMatch, 128))
			wcscpy(wszPasswordNoMatch, L"Confirm password doesn't match");

        // Confirmed password didn't match
        nResult = MessageBoxU(
            hwndDlg,
            wszPasswordNoMatch,
            wszMsgBoxTitle,
            MB_RETRYCANCEL | MB_ICONEXCLAMATION
            );
        if (nResult == IDRETRY) {
            SetDlgItemText(hwndDlg, IDC_PASSWORD0 + 0, "");
            SetDlgItemText(hwndDlg, IDC_PASSWORD0 + 1, "");
        }
    }

    if (nResult == IDOK)
        *ppszPassword = rgpszPassword[0];
    else if (rgpszPassword[0])
        PvkFree(rgpszPassword[0]);
    if (rgpszPassword[1])
        PvkFree(rgpszPassword[1]);

    if (nResult == IDRETRY)
        SetFocus(GetDlgItem(hwndDlg, IDC_PASSWORD0));
    return nResult;
}

//+-------------------------------------------------------------------------
//  Enter or Create Private Key Password DialogProc
//--------------------------------------------------------------------------
static INT_PTR CALLBACK KeyPasswordDlgProc(
            IN HWND hwndDlg,
            IN UINT uMsg,
            IN WPARAM wParam,
            IN LPARAM lParam
            )
{
    switch (uMsg) {
        case WM_INITDIALOG:
        {
            PKEY_PASSWORD_PARAM pKeyPasswordParam =
                (PKEY_PASSWORD_PARAM) lParam;

            char sz[128];
            WideCharToMultiByte(CP_ACP, 0, pKeyPasswordParam->pwszKey, -1,
                (LPSTR) sz, 128, NULL, NULL);

            SetDlgItemText(hwndDlg, IDC_KEY, sz);
            SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR) pKeyPasswordParam);
            return TRUE;
        }
        case WM_COMMAND:
            int nResult = LOWORD(wParam);
            switch (nResult) {
                case IDOK:
                {
                    PKEY_PASSWORD_PARAM pKeyPasswordParam =
                        (PKEY_PASSWORD_PARAM) GetWindowLongPtr(hwndDlg, DWLP_USER);

                    nResult = GetPassword(
                        hwndDlg,
                        pKeyPasswordParam->PasswordType,
                        pKeyPasswordParam->ppszPassword
                        );
                    if (nResult != IDRETRY)
                        EndDialog(hwndDlg, nResult);
                    return TRUE;
                }
                    break;
                case IDC_NONE:
                    nResult = IDOK;     // *ppszPassword == NULL
                    // Fall through
                case IDCANCEL:
                    EndDialog(hwndDlg, nResult);
                    return TRUE;
            }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\mssign32\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mssign32.rc
//
#define IDC_PASSWORD0                   501
#define IDC_PASSWORD1                   502
#define IDC_KEY                         504
#define IDC_NONE                        505
#define IDD_ENTERKEYPASSWORD            530
#define IDD_CREATEKEYPASSWORD           540
#define IDS_Publisher                   6000
#define IDS_MY                          6001
#define IDS_CA                          6002
#define IDS_SPC                         6003
#define IDS_ROOTSTORE                   6004
#define	IDS_NO_PASSWORD					6005
#define	IDS_PASSWORD_NO_MATCH			6006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\mssign32\signhlp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       signhlp.cpp
//
//  Contents:   Digital Signing Helper APIs
//
//  History:    June-25-1997	Xiaohs    Created
//----------------------------------------------------------------------------
#include "global.hxx"

//+-------------------------------------------------------------------------
// Local function for SpcGetCertFromKey
//
//  Signer cert flags. Used to determine the "strength" of the signer cert.
//
//  The following must be ordered as follows. ie, END_ENTITY_FLAG is most
//  important and needs to be the largest number.
//--------------------------------------------------------------------------
#define SIGNER_CERT_NOT_SELF_SIGNED_FLAG    0x00000001
#define SIGNER_CERT_NOT_GLUE_FLAG           0x00000002
#define SIGNER_CERT_NOT_CA_FLAG             0x00000004
#define SIGNER_CERT_END_ENTITY_FLAG         0x00000008
#define SIGNER_CERT_ALL_FLAGS               0x0000000F


//--------------------------------------------------------------------------
//
//	Copy all the certs from store name to hDescStore
//
//--------------------------------------------------------------------------
HRESULT	MoveStoreName(HCRYPTPROV	hCryptProv, 
					  DWORD			dwCertEncodingType, 
					  HCERTSTORE	hDescStore, 
					  DWORD			dwStoreName,
					  DWORD			dwStoreFlag)
{
	HCERTSTORE	hTmpStore=NULL;
	HRESULT		hr;
	WCHAR		wszStoreName[40];

	//load the name of the store
	if(0==LoadStringU(hInstance, dwStoreName, wszStoreName, 40))
	{
		hr=SignError();
		goto CLEANUP;
	}


	//open a system cert store
   	if (NULL == (hTmpStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_W,
            dwCertEncodingType,      
            hCryptProv,                  
            dwStoreFlag,                   
            wszStoreName                  
            ))) 
	{
		 hr=SignError();
		 goto CLEANUP;
	}

	hr=MoveStore(hDescStore, hTmpStore);

CLEANUP:
	if(hTmpStore)
		CertCloseStore(hTmpStore,0);

	return hr;

}

//--------------------------------------------------------------------------
//
//	Copy all the certs from hSrcStore to hDescStore
//
//--------------------------------------------------------------------------
HRESULT	MoveStore(HCERTSTORE	hDescStore, 
				  HCERTSTORE	hSrcStore)
{
	PCCERT_CONTEXT	pCertContext=NULL;
	PCCERT_CONTEXT	pPreContext=NULL;
	HRESULT			hr=S_OK;

	while(pCertContext=CertEnumCertificatesInStore(hSrcStore,
							pPreContext))
	{
		if(!(CertAddCertificateContextToStore(hDescStore,
							pCertContext,CERT_STORE_ADD_USE_EXISTING,
							NULL)))
		{
			hr=SignError();
			goto CLEANUP;
		}

		pPreContext=pCertContext;
		pCertContext=NULL;
	}

	hr=S_OK;

CLEANUP:
	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	return hr;
}

//--------------------------------------------------------------------------
//
//	Build up the certificate chain.  Put the whole chain to the store
//
//
//--------------------------------------------------------------------------
HRESULT	BuildCertChain(HCRYPTPROV		hCryptProv, 
					   DWORD			dwCertEncodingType,
					   HCERTSTORE		hStore, 
					   HCERTSTORE		hOptionalStore,
					   PCCERT_CONTEXT	pSigningCert, 
					   DWORD            dwCertPolicy)
{

    DWORD						i=0;
	PCCERT_CHAIN_CONTEXT		pCertChainContext = NULL;
	CERT_CHAIN_PARA				CertChainPara;
	HRESULT						hr=E_FAIL;
    
    //we regard the chain is good unless there are some cryptographic errors.
    //all error code regarding trusted root and CTLs are machine dependent, therefore
    //they are ignored.  We do not consider revocation.  
    DWORD                       dwChainError=CERT_TRUST_IS_NOT_TIME_VALID | 
                                           CERT_TRUST_IS_NOT_SIGNATURE_VALID;

	memset(&CertChainPara, 0, sizeof(CertChainPara));
	CertChainPara.cbSize = sizeof(CertChainPara);

	if (!CertGetCertificateChain(
				HCCE_CURRENT_USER,
				pSigningCert,
				NULL,
                hOptionalStore,
				&CertChainPara,
				0,
				NULL,
				&pCertChainContext))
	{
		hr=SignError();
        goto CLEANUP;
	}
    
	//
	// make sure there is at least 1 simple chain
	//
    if (pCertChainContext->cChain == 0)
    {
        hr=SignError();
        goto CLEANUP;
    }

    // make sure that we have a good chain
    if(dwChainError & (pCertChainContext->rgpChain[0]->TrustStatus.dwErrorStatus))
    {
        hr=CERT_E_CHAINING;
        goto CLEANUP;
    }


	i = 0;

	while (i < pCertChainContext->rgpChain[0]->cElement)
	{
		//
		// if we are supposed to skip the root cert,
		// and we are on the root cert, then continue
		//
	     if(dwCertPolicy & SIGNER_CERT_POLICY_CHAIN_NO_ROOT ||
            dwCertPolicy & SIGNER_CERT_POLICY_SPC)
         {
		    if ((pCertChainContext->rgpChain[0]->rgpElement[i]->TrustStatus.dwInfoStatus & CERT_TRUST_IS_SELF_SIGNED))
            {
                i++;
			    continue;
            }
         }

		 CertAddCertificateContextToStore(
				hStore, 
				pCertChainContext->rgpChain[0]->rgpElement[i]->pCertContext, 
				CERT_STORE_ADD_REPLACE_EXISTING, 
				NULL);

		i++;
	}
    
    hr=S_OK;

	
CLEANUP:

	if (pCertChainContext != NULL)
	{
		CertFreeCertificateChain(pCertChainContext);
	}

	return hr;

}

//--------------------------------------------------------------------------
//
//	 Make sure the two certificates are the same
//
//
//--------------------------------------------------------------------------
BOOL    SameCert(PCCERT_CONTEXT pCertOne, PCCERT_CONTEXT    pCertTwo)
{
    if(!pCertOne || !pCertTwo)
        return FALSE;

    if(pCertOne->cbCertEncoded != pCertTwo->cbCertEncoded)
        return FALSE;

    if(0 == memcmp(pCertOne->pbCertEncoded, pCertTwo->pbCertEncoded, pCertTwo->cbCertEncoded))
        return TRUE;

    return FALSE;
}


//The following cert chain building code is obsolete.  The new cert chain
//building API should be used
//--------------------------------------------------------------------------
//
//	Build up the certificate chain.  Put the whole chain to the store
//
//
//--------------------------------------------------------------------------
/*HRESULT	BuildCertChain(HCRYPTPROV		hCryptProv, 
					   DWORD			dwCertEncodingType,
					   HCERTSTORE		hStore, 
					   HCERTSTORE		hOptionalStore,
					   PCCERT_CONTEXT	pSigningCert, 
					   DWORD            dwCertPolicy)
{
	HRESULT			hr=E_FAIL;
	HCERTSTORE		hSpcStore=NULL;
  	PCCERT_CONTEXT	pSubCertContext=NULL;
	PCCERT_CONTEXT	pIssuerCertContext=NULL;
	PCCERT_CONTEXT	pFindCertContext=NULL;
    LPWSTR			rgwszStoreName[4] ={L"MY", L"ROOT", L"CA",L"SPC"};
	DWORD			dwStoreOpenFlag=0;
	HCERTSTORE		rghStore[5]={NULL, NULL, NULL, NULL,NULL};
	DWORD			dwStoreCount=0;
	DWORD			dwStoreIndex=0;
	FILETIME		fileTime;
	DWORD			dwConfidence=0;
	DWORD			dwError=0;
	BYTE			*pbHash=NULL;
    DWORD			cbHash = 0;
	CRYPT_HASH_BLOB Blob;


	//open a spc cert store
	dwStoreCount=sizeof(rgwszStoreName)/sizeof(rgwszStoreName[0]); 
	GetSystemTimeAsFileTime(&fileTime);

	//open the spc store
	if (NULL == (hSpcStore = CertOpenStore(
            CERT_STORE_PROV_SYSTEM_W,
            dwCertEncodingType,      
            hCryptProv,                  
            CERT_STORE_NO_CRYPT_RELEASE_FLAG|CERT_SYSTEM_STORE_CURRENT_USER,                   
            L"SPC"                  
            ))) 
	{
		 hr=SignError();
		 goto CLEANUP;
	}

	//open SPC, my, CA, root store
	for(dwStoreIndex=0; dwStoreIndex<dwStoreCount; dwStoreIndex++)
	{
		//open the store
	    dwStoreOpenFlag= CERT_STORE_NO_CRYPT_RELEASE_FLAG|CERT_SYSTEM_STORE_CURRENT_USER;


		if (NULL == (rghStore[dwStoreIndex] = CertOpenStore(
				CERT_STORE_PROV_SYSTEM_W,
				dwCertEncodingType,      
				hCryptProv,                  
				dwStoreOpenFlag,
				rgwszStoreName[dwStoreIndex]                  
				))) 
		{
			hr=SignError();
			goto CLEANUP;
		}
	}

	//copy all the certs in hOptionalStore if present
	if(hOptionalStore)
	{
		rghStore[dwStoreCount]=hOptionalStore;
		dwStoreCount++;
	}

	//now, build the chain
	pSubCertContext=CertDuplicateCertificateContext(pSigningCert);

	//loop until break
	while(1==1)
	{
		//find the issuer of the certificate
		if(!(pIssuerCertContext=TrustFindIssuerCertificate(
										   pSubCertContext,
                                           dwCertEncodingType,
                                           dwStoreCount,
                                           rghStore,
                                           &fileTime,
                                           &dwConfidence,
                                           &dwError,
                                           0)))

		{
			 //fail if we can not find one
			hr=CERT_E_CHAINING;
			goto CLEANUP;
		}

		//now, make sure the confidence level is hign enough
		if(dwConfidence < (CERT_CONFIDENCE_SIG+CERT_CONFIDENCE_TIME+CERT_CONFIDENCE_TIMENEST))
		{
			hr=CERT_E_CHAINING;
			goto CLEANUP;
		}
		
        //check to see if the cert is the root cert
        if(TrustIsCertificateSelfSigned(pIssuerCertContext,
            pIssuerCertContext->dwCertEncodingType,
            0))
        {
            if(dwCertPolicy & SIGNER_CERT_POLICY_CHAIN_NO_ROOT)
		        break;
            else
            {
                //add the root and we are done
		        if(!CertAddCertificateContextToStore(hStore,pIssuerCertContext,
								        CERT_STORE_ADD_USE_EXISTING, NULL))
		        {
				        hr=CERT_E_CHAINING;
				        goto CLEANUP;
		        }

                break;
            }
        }
        else
        {
		    //add the certificate context to the store
		    if(!CertAddCertificateContextToStore(hStore,pIssuerCertContext,
								    CERT_STORE_ADD_USE_EXISTING, NULL	))
		    {
				    hr=CERT_E_CHAINING;
				    goto CLEANUP;
		    }
        }



		//check if the certificate is from the spc store
		if(dwCertPolicy & SIGNER_CERT_POLICY_SPC)
		{

			//get the SHA1 hash of the certificate
			if(!CertGetCertificateContextProperty(
				pIssuerCertContext,
				CERT_SHA1_HASH_PROP_ID,
				NULL,
				&cbHash
				))
			{
				hr=SignError();
				goto CLEANUP;
			}

			pbHash=(BYTE *)malloc(cbHash);
			if(!pbHash)
			{
				hr=E_OUTOFMEMORY;
				goto CLEANUP;
			}
 			if(!CertGetCertificateContextProperty(
				pIssuerCertContext,
				CERT_SHA1_HASH_PROP_ID,
				pbHash,
				&cbHash
				))
			{
				hr=SignError();
				goto CLEANUP;
			}


			//find the ceritificate in the store
			Blob.cbData=cbHash;
			Blob.pbData=pbHash;

			pFindCertContext=CertFindCertificateInStore(
								hSpcStore,
								dwCertEncodingType,
								0,
								CERT_FIND_SHA1_HASH,
								&Blob,
								NULL);

			//if the certificate is from the SPC store, we are done
			if(pFindCertContext)
				break;
		}

		//free the subject context
		if(pSubCertContext)
			CertFreeCertificateContext(pSubCertContext);

		pSubCertContext=pIssuerCertContext;

		pIssuerCertContext=NULL;

	}

	hr=S_OK;

CLEANUP:
   if(pIssuerCertContext)
	   CertFreeCertificateContext(pIssuerCertContext);

   if(pSubCertContext)
	   CertFreeCertificateContext(pSubCertContext);


   if(pFindCertContext)
	   CertFreeCertificateContext(pFindCertContext);

   //close all of the stores
   for(dwStoreIndex=0; dwStoreIndex < (hOptionalStore ? dwStoreCount-1 : dwStoreCount); 
			dwStoreIndex++)
   {
	  if(rghStore[dwStoreIndex])
		CertCloseStore(rghStore[dwStoreIndex], 0);
   }

   if(hSpcStore)
	   CertCloseStore(hSpcStore,0);

   if(pbHash)
	   free(pbHash);
	
	return hr;
}  */

//+-------------------------------------------------------------------------
//  Build the SPC certificate store from the SPC file and the certificate chain
//--------------------------------------------------------------------------
HRESULT	BuildStoreFromSpcChain(HCRYPTPROV              hPvkProv,
                            DWORD                   dwKeySpec,
                            HCRYPTPROV				hCryptProv, 
							DWORD					dwCertEncodingType,				
                            SIGNER_SPC_CHAIN_INFO   *pSpcChainInfo, 
							HCERTSTORE				*phSpcStore,
                            PCCERT_CONTEXT          *ppSignCert
)
{
	HCERTSTORE		hMemoryStore=NULL;
	HRESULT			hr=S_OK;
	PCCERT_CONTEXT	pCertContext=NULL;
	PCCERT_CONTEXT	pPreContext=NULL;

	if(!pSpcChainInfo || !phSpcStore || !ppSignCert)
		return E_INVALIDARG;

	//init
	*phSpcStore=NULL;

	//open a memory store
	 if (NULL == (hMemoryStore = CertOpenStore(
                              CERT_STORE_PROV_FILENAME_W,
                              dwCertEncodingType,
                              hCryptProv,
                              CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                              pSpcChainInfo->pwszSpcFile)))
	{
		 hr=SignError();
		 goto CLEANUP;
	}

    //get the signing certificate
    if(S_OK != SpcGetCertFromKey(
							   dwCertEncodingType,
                               hMemoryStore, 
                               hPvkProv,
                               dwKeySpec,
                               ppSignCert))
	{
		hr=CRYPT_E_NO_MATCH;
		goto CLEANUP;
	}


	 //add all the certs in optional certStore
	 if(pSpcChainInfo->dwCertPolicy & SIGNER_CERT_POLICY_STORE)
	 {
		if(!(pSpcChainInfo->hCertStore))
		{
			hr=CERT_E_CHAINING;
			goto CLEANUP;
		}

		//enumerate all the certs in store and add them
		while(pCertContext=CertEnumCertificatesInStore(pSpcChainInfo->hCertStore,
												pPreContext))
		{
			if(!CertAddCertificateContextToStore(hMemoryStore, pCertContext,
									CERT_STORE_ADD_USE_EXISTING,
									NULL))
			{
				hr=SignError();
				goto CLEANUP;
			}

			pPreContext=pCertContext;
		}

		hr=S_OK;
	 }

	 //see if the certs if self-signed
   /*  if(TrustIsCertificateSelfSigned(*ppSignCert,
         (*ppSignCert)->dwCertEncodingType,
         0))
     {
			//no need to build the certificate chain anymore
			hr=S_OK;
			goto CLEANUP;
	 } */

	 //build up the cert chain as requested
	 if(pSpcChainInfo->dwCertPolicy & SIGNER_CERT_POLICY_CHAIN ||
        pSpcChainInfo->dwCertPolicy & SIGNER_CERT_POLICY_CHAIN_NO_ROOT ||
        pSpcChainInfo->dwCertPolicy & SIGNER_CERT_POLICY_SPC
       )
	 {
		//include everthing in the chain
		hr=BuildCertChain(hCryptProv, dwCertEncodingType,
							hMemoryStore, hMemoryStore,
							*ppSignCert, pSpcChainInfo->dwCertPolicy);
     }


CLEANUP:

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	if(hr==S_OK)
	{
		*phSpcStore=hMemoryStore;
	}
	else
	{
		if(hMemoryStore)
			CertCloseStore(hMemoryStore, 0);

        if(*ppSignCert)
        {
            CertFreeCertificateContext(*ppSignCert);
            *ppSignCert=NULL;
        }
	}

	return hr;
}

//+-------------------------------------------------------------------------
//  Build the spc certificate store from cert chain 
//--------------------------------------------------------------------------
HRESULT	BuildStoreFromStore(HCRYPTPROV              hPvkProv,
                            DWORD                   dwKeySpec,
                            HCRYPTPROV				hCryptProv, 
							DWORD					dwCertEncodingType,				
							SIGNER_CERT_STORE_INFO  *pCertStoreInfo,
							HCERTSTORE				*phSpcStore,
                            PCCERT_CONTEXT          *ppSignCert
)
{
	HCERTSTORE		hMemoryStore=NULL;
	HRESULT			hr=S_OK;
	PCCERT_CONTEXT	pCertContext=NULL;
	PCCERT_CONTEXT	pPreContext=NULL;

	if(!pCertStoreInfo || !phSpcStore || !ppSignCert)
		return E_INVALIDARG;

	//init
	*phSpcStore=NULL;

	//open a memory store
	 if (NULL == (hMemoryStore = CertOpenStore(
            CERT_STORE_PROV_MEMORY,
            dwCertEncodingType,      
            hCryptProv,                  
            CERT_STORE_NO_CRYPT_RELEASE_FLAG,                   
            NULL                  
            ))) 
	{
		 hr=SignError();
		 goto CLEANUP;
	}

	//add the signing cert to the store
	 if(!CertAddCertificateContextToStore(hMemoryStore, 
										pCertStoreInfo->pSigningCert,
										CERT_STORE_ADD_USE_EXISTING	,
										NULL))
	 {
		hr=SignError();
		goto CLEANUP;
	 }


    //get the signing certificate based on the private key
    if(S_OK != SpcGetCertFromKey(
							   dwCertEncodingType,
                               hMemoryStore, 
                               hPvkProv,
                               dwKeySpec,
                               ppSignCert))
	{
		hr=CRYPT_E_NO_MATCH;
		goto CLEANUP;
	}


	 //add all the certs in optional certStore
	 if(pCertStoreInfo->dwCertPolicy & SIGNER_CERT_POLICY_STORE)
	 {
		if(!(pCertStoreInfo->hCertStore))
		{
			hr=CERT_E_CHAINING;
			goto CLEANUP;
		}

		//enumerate all the certs in store and add them
		while(pCertContext=CertEnumCertificatesInStore(pCertStoreInfo->hCertStore,
												pPreContext))
		{
			if(!CertAddCertificateContextToStore(hMemoryStore, pCertContext,
									CERT_STORE_ADD_USE_EXISTING,
									NULL))
			{
				hr=SignError();
				goto CLEANUP;
			}

			pPreContext=pCertContext;
		}

		hr=S_OK;
	 }

	 //see if the certs if self-signed
    /* if(TrustIsCertificateSelfSigned(pCertStoreInfo->pSigningCert,
         pCertStoreInfo->pSigningCert->dwCertEncodingType,
         0))
     {
			//no need to build the certificate chain anymore
            *ppSignCert=CertDuplicateCertificateContext(pCertStoreInfo->pSigningCert);
			hr=S_OK;
			goto CLEANUP;
	 }*/

	 //build up the cert chain as requested
	 if(pCertStoreInfo->dwCertPolicy & SIGNER_CERT_POLICY_CHAIN ||
        pCertStoreInfo->dwCertPolicy & SIGNER_CERT_POLICY_CHAIN_NO_ROOT ||
        pCertStoreInfo->dwCertPolicy & SIGNER_CERT_POLICY_SPC
       )
	 {
		//include everthing in the chain
		hr=BuildCertChain(hCryptProv, dwCertEncodingType,
							hMemoryStore, NULL,
							pCertStoreInfo->pSigningCert, pCertStoreInfo->dwCertPolicy);
	 }

     if(S_OK != hr)
         goto CLEANUP;
    

    hr=S_OK;

CLEANUP:

	if(pCertContext)
		CertFreeCertificateContext(pCertContext);

	if(hr==S_OK)
	{
		*phSpcStore=hMemoryStore;
	}
	else
	{
		if(hMemoryStore)
			CertCloseStore(hMemoryStore, 0);

        if(*ppSignCert)
        {
            CertFreeCertificateContext(*ppSignCert);
            *ppSignCert=NULL;
        }

    }

	return hr;
}

//+-------------------------------------------------------------------------
//  Build the spc certificate store from  a spc file 
//--------------------------------------------------------------------------
HRESULT	BuildStoreFromSpcFile(HCRYPTPROV        hPvkProv,
                              DWORD             dwKeySpec,
                              HCRYPTPROV	    hCryptProv, 
							  DWORD			    dwCertEncodingType,
							  LPCWSTR		    pwszSpcFile, 
							  HCERTSTORE	    *phSpcStore,
                              PCCERT_CONTEXT    *ppSignCert)
{
	
	
	if(!phSpcStore || !pwszSpcFile || !ppSignCert)
		return E_INVALIDARG;

	*phSpcStore=NULL;

	// Open up the spc store
	*phSpcStore= CertOpenStore(CERT_STORE_PROV_FILENAME_W,
                              dwCertEncodingType,
                              hCryptProv,
                              CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                              pwszSpcFile);
	if(!(*phSpcStore))
		return SignError();


    //get the signing certificate
    if(S_OK != SpcGetCertFromKey(dwCertEncodingType,
                               *phSpcStore, 
                               hPvkProv,
                               dwKeySpec,
                               ppSignCert))
    {
        CertCloseStore(*phSpcStore, 0);
        *phSpcStore=NULL;

		return CRYPT_E_NO_MATCH;
    }

    return S_OK;


}

//+-------------------------------------------------------------------------
//  Build the spc certificate store from either a spc file or the
//	cert chain
//--------------------------------------------------------------------------
HRESULT	BuildCertStore(HCRYPTPROV       hPvkProv,
                       DWORD            dwKeySpec,    
                       HCRYPTPROV	    hCryptProv,
					   DWORD		    dwCertEncodingType,
					   SIGNER_CERT	    *pSignerCert,
					   HCERTSTORE	    *phSpcStore,
                       PCCERT_CONTEXT   *ppSigningCert)
{
	HRESULT		hr;

	if(!pSignerCert || !phSpcStore || !ppSigningCert)
		return E_INVALIDARG;

	//init
	*phSpcStore=NULL;

	if(pSignerCert->dwCertChoice==SIGNER_CERT_SPC_FILE)
	{
		hr=BuildStoreFromSpcFile(hPvkProv,
                                dwKeySpec,
                                hCryptProv, 
                                dwCertEncodingType,
							    pSignerCert->pwszSpcFile, 
                                phSpcStore,
                                ppSigningCert);
	}
	else
	{
        if(pSignerCert->dwCertChoice==SIGNER_CERT_STORE)
        {

		    hr=BuildStoreFromStore(hPvkProv,
                                    dwKeySpec,
                                    hCryptProv, 
                                    dwCertEncodingType,
									(pSignerCert->pCertStoreInfo),
                                    phSpcStore,
                                    ppSigningCert);
        }
        else
            hr=BuildStoreFromSpcChain(hPvkProv,
                                      dwKeySpec,
                                      hCryptProv, 
                                      dwCertEncodingType,
                                      (pSignerCert->pSpcChainInfo), 
                                      phSpcStore,
                                      ppSigningCert);
	}

#if (0) //DSIE: Bug 284639, the fix is to also preserve 0x80070002 since we
        //      really don't know what the impact will be for existing apps,
        //      if we preserve all error codes.
	if(hr!=S_OK && hr!=CRYPT_E_NO_MATCH)
		hr=CERT_E_CHAINING;
#else
	if(hr!=S_OK && hr!=CRYPT_E_NO_MATCH && hr!=0x80070002)
		hr=CERT_E_CHAINING;
#endif

	return hr;

}

//-----------------------------------------------------------------------------
//
//  Parse the private key information from a pCertContext's property
//	CERT_PVK_FILE_PROP_ID
//
//----------------------------------------------------------------------------
BOOL	GetProviderInfoFromCert(PCCERT_CONTEXT		pCertContext, 
								CRYPT_KEY_PROV_INFO	*pKeyProvInfo)
{

	BOOL				fResult=FALSE;
	BYTE				*pbData=NULL;
	BYTE				*pbToFree=NULL;
	DWORD				cbData=0;

	//init
	if(!pCertContext || !pKeyProvInfo)
		return FALSE;

	memset(pKeyProvInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));

	//get the property
	if(!CertGetCertificateContextProperty(pCertContext,
							CERT_PVK_FILE_PROP_ID,
							NULL,
							&cbData))
		return FALSE;

	pbData=(BYTE *)malloc(cbData);

	if(!pbData)
		return FALSE;

	if(!CertGetCertificateContextProperty(pCertContext,
							CERT_PVK_FILE_PROP_ID,
							pbData,
							&cbData))
		goto CLEANUP;

	
	//get the information from the property
	pbToFree=pbData;

	//get the private key information
	cbData=sizeof(WCHAR)*(wcslen((LPWSTR)pbData)+1);

	pKeyProvInfo->pwszContainerName=(LPWSTR)malloc(cbData);

	if(!(pKeyProvInfo->pwszContainerName))
		goto CLEANUP;

	wcscpy(pKeyProvInfo->pwszContainerName,(LPWSTR)pbData);
	
	//get the key spec
	pbData = pbData + cbData;

	cbData=sizeof(WCHAR)*(wcslen((LPWSTR)pbData)+1);

	pKeyProvInfo->dwKeySpec=_wtol((LPWSTR)pbData);

	//get the provider type
	pbData = pbData + cbData;

	cbData=sizeof(WCHAR)*(wcslen((LPWSTR)pbData)+1);

	pKeyProvInfo->dwProvType=_wtol((LPWSTR)pbData);

	//get the provider name
	pbData = pbData + cbData;

	if(*((LPWSTR)pbData)!=L'\0')
	{
		cbData=sizeof(WCHAR)*(wcslen((LPWSTR)pbData)+1);
		pKeyProvInfo->pwszProvName=(LPWSTR)malloc(cbData);

        if(NULL == pKeyProvInfo->pwszProvName)
            goto CLEANUP;

		wcscpy(pKeyProvInfo->pwszProvName, (LPWSTR)pbData);
	}

	fResult=TRUE;

CLEANUP:

	if(pbToFree)
		free(pbToFree);

	if(FALSE==fResult)
	{
		if(pKeyProvInfo->pwszContainerName)
			free( pKeyProvInfo->pwszContainerName);

		if(pKeyProvInfo->pwszProvName)
			free( pKeyProvInfo->pwszProvName);

		//memset the output to 0
		memset(pKeyProvInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));

	}

	return fResult;
}


//+-------------------------------------------------------------------------
//  Get hCryptProv handle and key spec for the certificate
//--------------------------------------------------------------------------
BOOL WINAPI GetCryptProvFromCert( 
	HWND			hwnd,
    PCCERT_CONTEXT	pCert,
    HCRYPTPROV		*phCryptProv,
    DWORD			*pdwKeySpec,
    BOOL			*pfDidCryptAcquire,
	LPWSTR			*ppwszTmpContainer,
	LPWSTR			*ppwszProviderName,
	DWORD			*pdwProviderType
    )
{
	
	BOOL					fResult=FALSE;
	WCHAR					wszPublisher[45];
	CRYPT_KEY_PROV_INFO		keyProvInfo;
	HRESULT					hr;
	


	memset(&keyProvInfo, 0, sizeof(CRYPT_KEY_PROV_INFO));

	*ppwszTmpContainer=NULL;
	*phCryptProv=NULL;
	*pfDidCryptAcquire=FALSE;
	*ppwszProviderName=NULL;
	*pdwKeySpec=0;

	//first, try to get from the key container
	if(CryptProvFromCert(hwnd, pCert, phCryptProv, 
					pdwKeySpec, pfDidCryptAcquire))
		return TRUE;

	//load from the resource of string L"publisher"
	if(0==LoadStringU(hInstance, IDS_Publisher, wszPublisher, 40))
		goto CLEANUP;


	//Get provider information from the property
	if(!GetProviderInfoFromCert(pCert, &keyProvInfo))
	{
		SetLastError((DWORD) CRYPT_E_NO_KEY_PROPERTY);
		goto CLEANUP;
	}

	//acquire context based on the private key file.  A temporary
	//key container will be created, along with information 
	//about the provider name and provider type, which are needed
	//to destroy the key container
	if(S_OK!=(hr=PvkGetCryptProv(	hwnd,                     
									wszPublisher,           
									keyProvInfo.pwszProvName,      
									keyProvInfo.dwProvType,        
									keyProvInfo.pwszContainerName,           
									NULL,  
									&(keyProvInfo.dwKeySpec),           
									ppwszTmpContainer,    
									phCryptProv)))
	{
		*phCryptProv=NULL;
		*ppwszTmpContainer=NULL;
		SetLastError((DWORD)hr);
		goto CLEANUP;
	}


	//copy the provder name
	if(keyProvInfo.pwszProvName)
	{
		*ppwszProviderName=(LPWSTR)malloc(
			sizeof(WCHAR)*(wcslen(keyProvInfo.pwszProvName)+1));

		if((*ppwszProviderName)==NULL)
		{
			SetLastError(E_OUTOFMEMORY);

			//free the hCrytProv
			PvkPrivateKeyReleaseContext(
									*phCryptProv,
                                    keyProvInfo.pwszProvName,
                                    keyProvInfo.dwProvType,
                                    *ppwszTmpContainer);

			*phCryptProv=NULL;
			*ppwszTmpContainer=NULL;

			goto CLEANUP;
		}

		wcscpy(*ppwszProviderName, keyProvInfo.pwszProvName);
	}

	//copy the provider type
	*pdwProviderType=keyProvInfo.dwProvType; 

	//copy the key spec
	*pdwKeySpec=keyProvInfo.dwKeySpec;
	*pfDidCryptAcquire=TRUE;

	fResult=TRUE;

CLEANUP:

	if(keyProvInfo.pwszProvName)
		free(keyProvInfo.pwszProvName);

	if(keyProvInfo.pwszContainerName)
		free(keyProvInfo.pwszContainerName);

	return fResult;

}

//+-------------------------------------------------------------------------
//  Free hCryptProv handle and key spec for the certificate
//--------------------------------------------------------------------------
void WINAPI FreeCryptProvFromCert(BOOL			fAcquired,
						   HCRYPTPROV	hProv,
						   LPWSTR		pwszCapiProvider,
                           DWORD		dwProviderType,
                           LPWSTR		pwszTmpContainer)
{
    
	if(fAcquired)
	{
		if (pwszTmpContainer) 
		{
			// Delete the temporary container for the private key from
			// the provider
			PvkPrivateKeyReleaseContext(hProv,
                                    pwszCapiProvider,
                                    dwProviderType,
                                    pwszTmpContainer);

			if(pwszCapiProvider)
				free(pwszCapiProvider);
		} 
		else 
		{
			if (hProv)
				CryptReleaseContext(hProv, 0);
		}
	}
}


//+-------------------------------------------------------------------------
//
//This is a subst of GetCryptProvFromCert.  This function does not consider
//the private key file property of the certificate
//+-------------------------------------------------------------------------
BOOL WINAPI CryptProvFromCert(
	HWND				hwnd,
    PCCERT_CONTEXT		pCert,
    HCRYPTPROV			*phCryptProv,
    DWORD				*pdwKeySpec,
    BOOL				*pfDidCryptAcquire
    )
{
    return CryptAcquireCertificatePrivateKey(
            pCert,
            0,   //we do not do the compare.  It will be done later.
            NULL,
            phCryptProv,
            pdwKeySpec,
            pfDidCryptAcquire);


    /*BOOL fResult;
    BOOL fDidCryptAcquire = FALSE;
    CERT_KEY_CONTEXT KeyContext;
    memset(&KeyContext, 0, sizeof(KeyContext));
    PCRYPT_KEY_PROV_INFO pKeyProvInfo = NULL;
    DWORD cbData;
    DWORD dwIdx;


    // Get either the CERT_KEY_CONTEXT_PROP_ID or
    // CERT_KEY_PROV_INFO_PROP_ID, or 
	// CERT_PVK_FILE_PROP_ID for the Cert.
    cbData = sizeof(KeyContext);
    CertGetCertificateContextProperty(
        pCert,
        CERT_KEY_CONTEXT_PROP_ID,
        &KeyContext,
        &cbData
        );

    if (KeyContext.hCryptProv == 0) 
	{
        cbData = 0;
        CertGetCertificateContextProperty(
            pCert,
            CERT_KEY_PROV_INFO_PROP_ID,
            NULL,
            &cbData
            );
        if (cbData == 0) 
		{
            SetLastError((DWORD) CRYPT_E_NO_KEY_PROPERTY);
            goto ErrorReturn;
		}
		else
		{
			pKeyProvInfo = (PCRYPT_KEY_PROV_INFO) malloc(cbData);
			if (pKeyProvInfo == NULL) goto ErrorReturn;
			fResult = CertGetCertificateContextProperty(
				pCert,
				CERT_KEY_PROV_INFO_PROP_ID,
				pKeyProvInfo,
				&cbData
				);
			if (!fResult) goto ErrorReturn;

			if (PROV_RSA_FULL == pKeyProvInfo->dwProvType &&
					(NULL == pKeyProvInfo->pwszProvName ||
						L'\0' == *pKeyProvInfo->pwszProvName))
				fResult = CryptAcquireContextU(
					&KeyContext.hCryptProv,
					pKeyProvInfo->pwszContainerName,
					MS_ENHANCED_PROV_W,
					PROV_RSA_FULL,
					pKeyProvInfo->dwFlags & ~CERT_SET_KEY_CONTEXT_PROP_ID
					);
			else
				fResult = FALSE;
			if (!fResult)
				fResult = CryptAcquireContextU(
					&KeyContext.hCryptProv,
					pKeyProvInfo->pwszContainerName,
					pKeyProvInfo->pwszProvName,
					pKeyProvInfo->dwProvType,
					pKeyProvInfo->dwFlags & ~CERT_SET_KEY_CONTEXT_PROP_ID
					);
			if (!fResult) goto ErrorReturn;
			fDidCryptAcquire = TRUE;
			for (dwIdx = 0; dwIdx < pKeyProvInfo->cProvParam; dwIdx++) 
			{
				PCRYPT_KEY_PROV_PARAM pKeyProvParam = &pKeyProvInfo->rgProvParam[dwIdx];
				fResult = CryptSetProvParam(
					KeyContext.hCryptProv,
					pKeyProvParam->dwParam,
					pKeyProvParam->pbData,
					pKeyProvParam->dwFlags
					);
				if (!fResult) goto ErrorReturn;
			}
			KeyContext.dwKeySpec = pKeyProvInfo->dwKeySpec;
			if (pKeyProvInfo->dwFlags & CERT_SET_KEY_CONTEXT_PROP_ID) 
			{
				// Set the certificate's property so we only need to do the
				// acquire once
				KeyContext.cbSize = sizeof(KeyContext);
				fResult = CertSetCertificateContextProperty(
					pCert,
					CERT_KEY_CONTEXT_PROP_ID,
					0,                              // dwFlags
					(void *) &KeyContext
					);
				if (!fResult) goto ErrorReturn;
				fDidCryptAcquire = FALSE;
			}
		}
    } 

    fResult = TRUE;
    goto CommonReturn;

ErrorReturn:
    if (fDidCryptAcquire) {
        DWORD dwErr = GetLastError();
        CryptReleaseContext(KeyContext.hCryptProv, 0);
        SetLastError(dwErr);

        fDidCryptAcquire = FALSE;
    }
    KeyContext.hCryptProv = 0;
    fResult = FALSE;
CommonReturn:
    if (pKeyProvInfo)
        free(pKeyProvInfo);
    *phCryptProv = KeyContext.hCryptProv;
    *pdwKeySpec = KeyContext.dwKeySpec;
    *pfDidCryptAcquire = fDidCryptAcquire;
    return fResult;*/
}

//+-----------------------------------------------------------------------
//  Check the SIGNER_SUBJECT_INFO
//  
//+-----------------------------------------------------------------------
BOOL	CheckSigncodeSubjectInfo(
				PSIGNER_SUBJECT_INFO		pSubjectInfo) 
{
		if(!pSubjectInfo)
			return FALSE;

		//check pSubjectInfo
		if(pSubjectInfo->cbSize < sizeof(SIGNER_SUBJECT_INFO))
			return FALSE;

		if(NULL==(pSubjectInfo->pdwIndex))
			return FALSE;

        //currently, we only allow index of 0
        if(0!= (*(pSubjectInfo->pdwIndex)))
            return FALSE;

		if((pSubjectInfo->dwSubjectChoice!=SIGNER_SUBJECT_FILE)&&
		   (pSubjectInfo->dwSubjectChoice!=SIGNER_SUBJECT_BLOB))
		   return FALSE;

		if(pSubjectInfo->dwSubjectChoice==SIGNER_SUBJECT_FILE)
		{
			if((pSubjectInfo->pSignerFileInfo)==NULL)
				return FALSE;
			
			//check SIGNER_FILE_INFO
			if(pSubjectInfo->pSignerFileInfo->cbSize < sizeof(SIGNER_FILE_INFO))
				return FALSE;

			if((pSubjectInfo->pSignerFileInfo->pwszFileName)==NULL)
				return FALSE;
		}
		else
		{
			if((pSubjectInfo->pSignerBlobInfo)==NULL)
				return FALSE;

			//check SIGNER_BLOB_INFO
			if(pSubjectInfo->pSignerBlobInfo->cbSize < sizeof(SIGNER_BLOB_INFO))
				return FALSE;

			if(NULL==(pSubjectInfo->pSignerBlobInfo->pGuidSubject))
				return FALSE;

			if(0==(pSubjectInfo->pSignerBlobInfo->cbBlob))
				return FALSE;

			if(NULL==(pSubjectInfo->pSignerBlobInfo->pbBlob))
				return FALSE;
		}

		return TRUE;
}


//+-----------------------------------------------------------------------
//  Check the input parameters of Signcode.  Make sure they are valid.
//  
//+-----------------------------------------------------------------------
BOOL	CheckSigncodeParam(
				PSIGNER_SUBJECT_INFO		pSubjectInfo, 
				PSIGNER_CERT				pSignerCert,
				PSIGNER_SIGNATURE_INFO		pSignatureInfo,
				PSIGNER_PROVIDER_INFO		pProviderInfo) 
{
		//except for pPvkInfo and pProviderInfo, the rest are required.
		if(!pSubjectInfo ||!pSignerCert || !pSignatureInfo)
			return FALSE;

		//check pSubjectInfo
		if(FALSE==CheckSigncodeSubjectInfo(pSubjectInfo))
			return FALSE;

		//check pSignatureInfo
		if(pSignatureInfo->cbSize < sizeof(SIGNER_SIGNATURE_INFO))
			return FALSE;

		//check the attributes in pSignatureInfo
		if(pSignatureInfo->dwAttrChoice == SIGNER_AUTHCODE_ATTR)
		{
			if((pSignatureInfo->pAttrAuthcode)==NULL)
				return FALSE;

			//check pSignatureInfo->pAttrAuthcode
			if(pSignatureInfo->pAttrAuthcode->cbSize < sizeof(SIGNER_ATTR_AUTHCODE))
				return FALSE;
		}
		else
		{
			if(pSignatureInfo->dwAttrChoice !=SIGNER_NO_ATTR)
				return FALSE;
		}


		//check provider info
		if(pProviderInfo)
		{
			if(pProviderInfo->cbSize < sizeof(SIGNER_PROVIDER_INFO))
				return FALSE;

			//dwPvkType has to be valid
			if((pProviderInfo->dwPvkChoice!=PVK_TYPE_FILE_NAME) &&
			   (pProviderInfo->dwPvkChoice!=PVK_TYPE_KEYCONTAINER) )
			   return FALSE;

			if(pProviderInfo->dwPvkChoice==PVK_TYPE_FILE_NAME)
			{
				if(!(pProviderInfo->pwszPvkFileName))
					return FALSE;
			}
			else
			{
				if(!(pProviderInfo->pwszKeyContainer))
					return FALSE;
			}

		}


		//check pSignerCert
		if(pSignerCert->cbSize < sizeof(SIGNER_CERT))
			return FALSE;

		//check the dwCertChoice
		if((pSignerCert->dwCertChoice!= SIGNER_CERT_SPC_FILE) && 
			((pSignerCert->dwCertChoice!= SIGNER_CERT_STORE)) &&
            (pSignerCert->dwCertChoice!= SIGNER_CERT_SPC_CHAIN) 
           )
			return FALSE;

		//check the spc file situation
		if(pSignerCert->dwCertChoice == SIGNER_CERT_SPC_FILE)
		{
		   if(pSignerCert->pwszSpcFile==NULL)
			   return FALSE;
		}

		//check the cert store situation
		if(pSignerCert->dwCertChoice==SIGNER_CERT_STORE)
		{
			//pCertStoreInfo has to be set
			if((pSignerCert->pCertStoreInfo)==NULL)
				return FALSE;

			if((pSignerCert->pCertStoreInfo)->cbSize < sizeof(SIGNER_CERT_STORE_INFO))
				return FALSE;

			//pSigngingCert has to be set
			if((pSignerCert->pCertStoreInfo)->pSigningCert == NULL )
				return FALSE;
		}

		//check the SPC chain situation
		if(pSignerCert->dwCertChoice==SIGNER_CERT_SPC_CHAIN)
		{
			//pCertStoreInfo has to be set
			if((pSignerCert->pSpcChainInfo)==NULL)
				return FALSE;

			if((pSignerCert->pSpcChainInfo)->cbSize != sizeof(SIGNER_SPC_CHAIN_INFO))
				return FALSE;

			//pSigngingCert has to be set
			if((pSignerCert->pSpcChainInfo)->pwszSpcFile == NULL )
				return FALSE;
		}
		//end of the checking
		return TRUE;

}


//-------------------------------------------------------------------------
//
//	GetSubjectTypeFlags:
//		Check the BASIC_CONSTRAINTS extension from the certificate
//		to see if the certificate is a CA or end entity certs
//
//-------------------------------------------------------------------------
static DWORD GetSubjectTypeFlags(IN DWORD dwCertEncodingType,
                                 IN PCCERT_CONTEXT pCert)
{
    HRESULT hr = S_OK;
    DWORD grfSubjectType = 0;
    PCERT_EXTENSION pExt;
    PCERT_BASIC_CONSTRAINTS_INFO pInfo = NULL;
    DWORD cbInfo;
    
    PKITRY {
        if ((pExt = CertFindExtension(szOID_BASIC_CONSTRAINTS,
                                      pCert->pCertInfo->cExtension,
                                      pCert->pCertInfo->rgExtension)) == NULL)
            PKITHROW(CRYPT_E_NO_MATCH);
        
        cbInfo = 0;
        CryptDecodeObject(dwCertEncodingType, 
                     X509_BASIC_CONSTRAINTS,
                     pExt->Value.pbData,
                     pExt->Value.cbData,
                     0,                      // dwFlags
                     NULL,                   // pInfo
                     &cbInfo);
        if (cbInfo == 0) 
            PKITHROW(CRYPT_E_NO_MATCH);
        pInfo = (PCERT_BASIC_CONSTRAINTS_INFO) malloc(cbInfo);
        if(!pInfo)
            PKITHROW(E_OUTOFMEMORY);
        if (!CryptDecodeObject(dwCertEncodingType, 
                               X509_BASIC_CONSTRAINTS,
                               pExt->Value.pbData,
                               pExt->Value.cbData,
                               0,                  // dwFlags
                               pInfo,
                               &cbInfo)) 
            PKITHROW(SignError());
        
        if (pInfo->SubjectType.cbData > 0) {
            BYTE bSubjectType = *pInfo->SubjectType.pbData;
            if (bSubjectType & CERT_END_ENTITY_SUBJECT_FLAG)
                grfSubjectType |= SIGNER_CERT_END_ENTITY_FLAG;
            if (0 == (bSubjectType & CERT_CA_SUBJECT_FLAG))
                grfSubjectType |= SIGNER_CERT_NOT_CA_FLAG;
        }
    }
    PKICATCH(err) {
        hr = err.pkiError;
    } PKIEND;

    if (pInfo) free(pInfo);
    return grfSubjectType;
}

//-------------------------------------------------------------------------
//
//	WSZtoSZ:
//		Convert a wchar string to a multi-byte string.
//
//-------------------------------------------------------------------------
HRESULT	WSZtoSZ(LPWSTR wsz, LPSTR *psz)
{

	DWORD	cbSize=0;


	*psz=NULL;

	if(!wsz)
		return S_OK;

	cbSize=WideCharToMultiByte(0,0,wsz,-1,
			NULL,0,0,0);

	if(cbSize==0)
	   	return SignError();


	*psz=(LPSTR)malloc(cbSize);

	if(*psz==NULL)
		return E_OUTOFMEMORY;

	if(WideCharToMultiByte(0,0,wsz,-1,
			*psz,cbSize,0,0))
	{
		return S_OK;
	}
	else
	{
		 free(*psz);
		 return SignError();
	}
}


//-------------------------------------------------------------------------
//
//	BytesToBase64:
//			convert bytes to base64 bstr
//
//-------------------------------------------------------------------------
HRESULT BytesToBase64(BYTE *pb, DWORD cb, CHAR **pszEncode, DWORD *pdwEncode)
{
    DWORD dwErr;
    DWORD cch;
    CHAR  *psz=NULL;

	*pszEncode=NULL;
	*pdwEncode=0;

    if (cb == 0) {
          return S_OK;
    }

    cch = 0;
    if (!CryptBinaryToStringA(
            pb,
            cb,
            CRYPT_STRING_BASE64,
            NULL,
            &cch
            ))
        return HRESULT_FROM_WIN32(GetLastError());
    if (NULL == (psz=(CHAR *)malloc(cch * sizeof(char))))
        return E_OUTOFMEMORY;

    if (!CryptBinaryToStringA(
            pb,
            cb,
            CRYPT_STRING_BASE64,
            psz,
            &cch
            )) {
        free(psz);
        return HRESULT_FROM_WIN32(GetLastError());
    } else {
        *pszEncode=psz;
		*pdwEncode=cch + 1; //plus 1 to include NULL
        return S_OK;
    }
}


//-------------------------------------------------------------------------
//
//	BytesToBase64:
//			conver base64 bstr to bytes
//
//-------------------------------------------------------------------------
HRESULT Base64ToBytes(CHAR *pEncode, DWORD cbEncode, BYTE **ppb, DWORD *pcb)
{
    DWORD dwErr;
    BYTE *pb;
    DWORD cb;

    *ppb = NULL;
    *pcb = 0;

 
    cb = 0;
    if (!CryptStringToBinaryA(
            pEncode,
            cbEncode,
            CRYPT_STRING_ANY,
            NULL,
            &cb,
            NULL,
            NULL))
        return HRESULT_FROM_WIN32(GetLastError());
    if (cb == 0)
        return S_OK;

    if (NULL == (pb = (BYTE *) malloc(cb)))
        return E_OUTOFMEMORY;

    if (!CryptStringToBinaryA(
            pEncode,
            cbEncode,
            CRYPT_STRING_ANY,
            pb,
            &cb,
            NULL,
            NULL
            )) {
        free(pb);
        return HRESULT_FROM_WIN32(GetLastError());
    } else {
        *ppb = pb;
        *pcb = cb;
        return S_OK;
    }

}




//+-------------------------------------------------------------------------
//  Find the the cert from the hprov
//  Parameter Returns:
//      pReturnCert - context of the cert found (must pass in cert context);
//  Returns:
//      S_OK - everything worked
//      E_OUTOFMEMORY - memory failure
//      E_INVALIDARG - no pReturnCert supplied
//      CRYPT_E_NO_MATCH - could not locate certificate in store
//
//+-------------------------------------------------------------------------     
HRESULT 
SpcGetCertFromKey(IN DWORD dwCertEncodingType,
                  IN HCERTSTORE hStore,
                  IN HCRYPTPROV hProv,
                  IN DWORD dwKeySpec,
                  OUT PCCERT_CONTEXT* pReturnCert)
{
    PCERT_PUBLIC_KEY_INFO psPubKeyInfo = NULL;
    DWORD dwPubKeyInfo;
    PCCERT_CONTEXT pCert = NULL;
    PCCERT_CONTEXT pEnumCert = NULL;
    DWORD grfCert = 0;
    HRESULT hr = S_OK;

    PKITRY {
        if(!pReturnCert) PKITHROW(E_INVALIDARG);

        // Get public key to compare certificates with
        dwPubKeyInfo = 0;
        CryptExportPublicKeyInfo(hProv,
                                 dwKeySpec,
                                 dwCertEncodingType,
                                 NULL,               // psPubKeyInfo
                                 &dwPubKeyInfo);
        if (dwPubKeyInfo == 0) 
            PKITHROW(SignError());
        psPubKeyInfo = (PCERT_PUBLIC_KEY_INFO) malloc(dwPubKeyInfo);
        if(!psPubKeyInfo) PKITHROW(E_OUTOFMEMORY);
        
        if (!CryptExportPublicKeyInfo(hProv,
                                      dwKeySpec,
                                      dwCertEncodingType,
                                      psPubKeyInfo,
                                      &dwPubKeyInfo)) 
            PKITHROW(SignError());
        
        // Find the "strongest" cert with a matching public key
        while (TRUE) {
            pEnumCert = CertEnumCertificatesInStore(hStore, pEnumCert);
            if (pEnumCert) {
                if (CertComparePublicKeyInfo(pEnumCert->dwCertEncodingType,
                                             &pEnumCert->pCertInfo->SubjectPublicKeyInfo,
                                             psPubKeyInfo)) {
                    
                    // END_ENTITY, NOT_CA
                    DWORD grfEnumCert = GetSubjectTypeFlags(pEnumCert->dwCertEncodingType,
                                                            pEnumCert);
                    if (S_OK != SignIsGlueCert(pEnumCert))
                        grfEnumCert |= SIGNER_CERT_NOT_GLUE_FLAG;
                    if (!CertCompareCertificateName(pEnumCert->dwCertEncodingType,
                                                    &pEnumCert->pCertInfo->Issuer,
                                                    &pEnumCert->pCertInfo->Subject))
                        grfEnumCert |= SIGNER_CERT_NOT_SELF_SIGNED_FLAG;
                    
                    if (grfEnumCert >= grfCert) {
                        // Found a signer cert with a stronger match
                        if (pCert)
                            CertFreeCertificateContext(pCert);
                        grfCert = grfEnumCert;
                        if (grfCert == SIGNER_CERT_ALL_FLAGS) {
                            pCert = pEnumCert;
                            break;
                        } else
                            // Not a perfect match. Check for a better signer cert.
                            pCert = CertDuplicateCertificateContext(pEnumCert);
                    }
                }
            } else
                break;
        }
        if (pCert == NULL) 
            PKITHROW(CRYPT_E_NO_MATCH);
        
        if (!CertSetCertificateContextProperty(pCert,
                                               CERT_KEY_PROV_HANDLE_PROP_ID,
                                               CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                               (void *) hProv)) 
            PKITHROW(SignError());
    }
    PKICATCH(err) {
        hr = err.pkiError;
        if (pCert) {
            CertFreeCertificateContext(pCert);
            pCert = NULL;
        }
    } PKIEND;
    
    *pReturnCert = pCert;
    if (psPubKeyInfo)
        free(psPubKeyInfo);
    return hr;
}

///-------------------------------------------------------------------------
// Authenticode routines (not necessary for all implementations)


//+-------------------------------------------------------------------------
//If all of the  following three conditions are true, we should not put 
// commercial or individual authenticated attributes into signer info 
//
//1. the enhanced key usage extension of the signer's certificate has no code signing usage (szOID_PKIX_KP_CODE_SIGNING)
//2. basic constraints extension of the signer's cert is missing, or it is neither commercial nor individual
//3. user did not specify -individual or -commercial in signcode.exe.
//--------------------------------------------------------------------------
BOOL    NeedStatementTypeAttr(IN PCCERT_CONTEXT pSignerCert, 
                              IN BOOL           fCommercial, 
                              IN BOOL           fIndividual)
{
    BOOL                    fNeedStatementTypeAttr=FALSE;
    PCERT_EXTENSION         pEKUExt=NULL;
    PCERT_EXTENSION         pRestrictionExt=NULL;
    DWORD                   cPolicyId=0;
    PCERT_POLICY_ID         pPolicyId=NULL;

    BOOL                    fPolicyCommercial = FALSE;
    BOOL                    fPolicyIndividual = FALSE; 
    BOOL                    fCodeSiginigEKU=FALSE;
    
    PCERT_KEY_USAGE_RESTRICTION_INFO pInfo = NULL;
    DWORD                   cbInfo=0;

    PCERT_ENHKEY_USAGE      pEKUInfo=NULL;
    DWORD                   dwIndex=0;


    if(!pSignerCert)
        return FALSE;


    //check for condition # 3
    if(fCommercial || fIndividual)
        return TRUE;

    //now we know user did not specify -individual or -commerical options

    //if the cert has enhanced key usage extension 
    pEKUExt = CertFindExtension(szOID_ENHANCED_KEY_USAGE,
                                 pSignerCert->pCertInfo->cExtension,
                                 pSignerCert->pCertInfo->rgExtension);


    pRestrictionExt = CertFindExtension(szOID_KEY_USAGE_RESTRICTION,
                                 pSignerCert->pCertInfo->cExtension,
                                 pSignerCert->pCertInfo->rgExtension);


    if((!pEKUExt) && (!pRestrictionExt))
        return FALSE;

    if(pEKUExt)
    {
        cbInfo=0;

        if(CryptDecodeObject(X509_ASN_ENCODING,
                          X509_ENHANCED_KEY_USAGE,
                          pEKUExt->Value.pbData,
                          pEKUExt->Value.cbData,
                          0,                      // dwFlags
                          NULL,                   // pInfo
                          &cbInfo) && (cbInfo != 0))
        {
            pEKUInfo = (PCERT_ENHKEY_USAGE) malloc(cbInfo);
            if(pEKUInfo)
            {
                if(CryptDecodeObject(X509_ASN_ENCODING,
                                  X509_ENHANCED_KEY_USAGE,
                                  pEKUExt->Value.pbData,
                                  pEKUExt->Value.cbData,
                                  0,                          // dwFlags
                                  pEKUInfo,                   // pInfo
                                  &cbInfo) && (cbInfo != 0))
                {
                    for(dwIndex=0; dwIndex < pEKUInfo->cUsageIdentifier; dwIndex++)
                    {
                        if(0==strcmp(szOID_PKIX_KP_CODE_SIGNING, 
                                pEKUInfo->rgpszUsageIdentifier[dwIndex]))
                                fCodeSiginigEKU=TRUE;


                        if(0==strcmp(SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID, 
                                pEKUInfo->rgpszUsageIdentifier[dwIndex]))
                                fPolicyCommercial=TRUE;


                        if(0==strcmp(SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID, 
                                pEKUInfo->rgpszUsageIdentifier[dwIndex]))
                                fPolicyIndividual=TRUE;


                    }
                }

            }

        }

    }

    if(pRestrictionExt)
    {
        cbInfo = 0;
        if(CryptDecodeObject(X509_ASN_ENCODING,
                          X509_KEY_USAGE_RESTRICTION,
                          pRestrictionExt->Value.pbData,
                          pRestrictionExt->Value.cbData,
                          0,                      // dwFlags
                          NULL,                   // pInfo
                          &cbInfo) && (cbInfo != 0))
        {
            pInfo = (PCERT_KEY_USAGE_RESTRICTION_INFO) malloc(cbInfo);
            if(pInfo)
            {
                if (CryptDecodeObject(X509_ASN_ENCODING,
                               X509_KEY_USAGE_RESTRICTION,
                               pRestrictionExt->Value.pbData,
                               pRestrictionExt->Value.cbData,
                               0,                  // dwFlags
                               pInfo,
                               &cbInfo)) 
                {
                    if (pInfo->cCertPolicyId) 
		            {
                        cPolicyId = pInfo->cCertPolicyId;
                        pPolicyId = pInfo->rgCertPolicyId;

                        for ( ; cPolicyId > 0; cPolicyId--, pPolicyId++) 
			            {
                            DWORD cElementId = pPolicyId->cCertPolicyElementId;
                            LPSTR *ppszElementId = pPolicyId->rgpszCertPolicyElementId;

                            for ( ; cElementId > 0; cElementId--, ppszElementId++) 
				            {
                                if (strcmp(*ppszElementId,
                                           SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID) == 0)
                                {
                                    fPolicyCommercial = TRUE;
                                }

                                if (strcmp(*ppszElementId,
                                           SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID) == 0)
                                    fPolicyIndividual = TRUE;
                            }
                        }
                    }
                }

            }

        }
    }
        

    //free the memory
    if(pInfo)
        free(pInfo);

    if(pEKUInfo)
        free(pEKUInfo);

    //if any of the value is true in the properties,
    //we need to add the statement type attribute
    if( fPolicyCommercial || fPolicyIndividual || fCodeSiginigEKU)
        return TRUE;

    return FALSE;
}


//+-------------------------------------------------------------------------
//  
//	The function decides whether to sign the certificate as a commerical,
// or individual.  The default is the certificate's highest capability.  If fCommercial
// is set and the cert can not signly commercially, an error is returned.
// Same for fIndividual.  
//
//--------------------------------------------------------------------------
HRESULT CheckCommercial(PCCERT_CONTEXT pSignerCert, BOOL fCommercial,
				BOOL fIndividual, BOOL *pfCommercial)
{
    HRESULT                 hr = S_OK;
    BOOL                    fPolicyCommercial = FALSE;
    BOOL                    fPolicyIndividual = FALSE;  
    PCERT_EXTENSION         pExt;
    PCERT_KEY_USAGE_RESTRICTION_INFO pInfo = NULL;
    DWORD                   cbInfo;

    PCERT_EXTENSION         pEKUExt=NULL;
    PCERT_ENHKEY_USAGE      pUsage=NULL;
    DWORD                   cCount=0;

	if(!pfCommercial)
		return E_INVALIDARG;

	//init
	*pfCommercial=FALSE;

	//fCommercial and fIndividual can not be set at the same time
	if(fCommercial && fIndividual)
		return E_INVALIDARG;


    PKITRY {

		//first look into the cert extension szOID_KEY_USAGE_RESTRICTION
        pExt = CertFindExtension(szOID_KEY_USAGE_RESTRICTION,
                                 pSignerCert->pCertInfo->cExtension,
                                 pSignerCert->pCertInfo->rgExtension);
        
        if(pExt) 
		{
            
            cbInfo = 0;
            CryptDecodeObject(X509_ASN_ENCODING,
                              X509_KEY_USAGE_RESTRICTION,
                              pExt->Value.pbData,
                              pExt->Value.cbData,
                              0,                      // dwFlags
                              NULL,                   // pInfo
                              &cbInfo);
            if (cbInfo == 0)
                PKITHROW(SignError());
            pInfo = (PCERT_KEY_USAGE_RESTRICTION_INFO) malloc(cbInfo);
            if(!pInfo)
                PKITHROW(E_OUTOFMEMORY);
            if (!CryptDecodeObject(X509_ASN_ENCODING,
                                   X509_KEY_USAGE_RESTRICTION,
                                   pExt->Value.pbData,
                                   pExt->Value.cbData,
                                   0,                  // dwFlags
                                   pInfo,
                                   &cbInfo)) 
                PKITHROW(SignError());
            
            if (pInfo->cCertPolicyId) 
			{
                DWORD cPolicyId;
                PCERT_POLICY_ID pPolicyId;
                
                cPolicyId = pInfo->cCertPolicyId;
                pPolicyId = pInfo->rgCertPolicyId;
                for ( ; cPolicyId > 0; cPolicyId--, pPolicyId++) 
				{
                    DWORD cElementId = pPolicyId->cCertPolicyElementId;
                    LPSTR *ppszElementId = pPolicyId->rgpszCertPolicyElementId;
                    for ( ; cElementId > 0; cElementId--, ppszElementId++) 
					{
                        if (strcmp(*ppszElementId,
                                   SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID) == 0)
                        {
                            fPolicyCommercial = TRUE;
                        }
                        if (strcmp(*ppszElementId,
                                   SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID) == 0)
                            fPolicyIndividual = TRUE;
                    }
                }
            } //end of pInfo->cCertPolicyId
        } //end of pExt


		//now 
    }
    PKICATCH(err) 
	{
        hr = err.pkiError;
    } PKIEND;


    if (pInfo)
    {
        free(pInfo);
        pInfo=NULL;
    }

	if(hr!=S_OK)
		return hr;


    //if either of the policy is set, we check for the EKU extension
    if((!fPolicyCommercial) && (!fPolicyIndividual))
    {
        pExt = CertFindExtension(szOID_ENHANCED_KEY_USAGE,
                                 pSignerCert->pCertInfo->cExtension,
                                 pSignerCert->pCertInfo->rgExtension);

        if(pExt)
        {
            cbInfo = 0;

            if(CryptDecodeObject(X509_ASN_ENCODING,
                              X509_ENHANCED_KEY_USAGE,
                              pExt->Value.pbData,
                              pExt->Value.cbData,
                              0,                     
                              NULL,                   
                              &cbInfo) && (cbInfo != 0))
            {
                pUsage = (PCERT_ENHKEY_USAGE) malloc(cbInfo);

                if(pUsage)
                {
                    if (CryptDecodeObject(X509_ASN_ENCODING,
                                           X509_ENHANCED_KEY_USAGE,
                                           pExt->Value.pbData,
                                           pExt->Value.cbData,
                                           0,                  // dwFlags
                                           pUsage,
                                           &cbInfo))
                    {
                        
                        for(cCount=0; cCount< pUsage->cUsageIdentifier; cCount++)
                        {
                            if (strcmp((pUsage->rgpszUsageIdentifier)[cCount],
                                       SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID) == 0)
                            {
                                fPolicyCommercial = TRUE;
                            }

                            if (strcmp((pUsage->rgpszUsageIdentifier)[cCount],
                                       SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID) == 0)
                            {
                                fPolicyIndividual = TRUE;     
                            }
                        }
                    }

                }
            }
        }
    }
	
    if(pUsage)
    {
        free(pUsage);
        pUsage=NULL;
    }

	//if either of the policy is set, we use individual
	if(!fPolicyCommercial && !fPolicyIndividual)
		fPolicyIndividual=TRUE;

	//default
	if((!fCommercial) && (!fIndividual))
	{
		if(fPolicyCommercial)
			*pfCommercial=TRUE;
		else
			*pfCommercial=FALSE;	

		return S_OK;
	}


	if(fCommercial && (!fIndividual))
	{
		if(fPolicyCommercial)
		{
			*pfCommercial=TRUE;
			return S_OK;
		}
		else
			return TYPE_E_TYPEMISMATCH;
	}

	//the following is fIndividual and !fCommercial
	if(fPolicyIndividual)
	{
		*pfCommercial=FALSE;
		return S_OK;
	}
	else
		return TYPE_E_TYPEMISMATCH;
}


//+-------------------------------------------------------------------------
//  Encode the StatementType authenticated attribute value
//--------------------------------------------------------------------------
HRESULT CreateStatementType(IN BOOL fCommercial,
                            OUT BYTE **ppbEncoded,
                            IN OUT DWORD *pcbEncoded)
{
    HRESULT hr = S_OK;
    PBYTE pbEncoded = NULL;
    DWORD cbEncoded;
    LPSTR pszIndividual = SPC_INDIVIDUAL_SP_KEY_PURPOSE_OBJID;
    LPSTR pszCommercial = SPC_COMMERCIAL_SP_KEY_PURPOSE_OBJID;
    SPC_STATEMENT_TYPE StatementType;

    StatementType.cKeyPurposeId = 1;
    if (fCommercial)
        StatementType.rgpszKeyPurposeId = &pszCommercial;
    else
        StatementType.rgpszKeyPurposeId = &pszIndividual;

    PKITRY {

        cbEncoded = 0;
        CryptEncodeObject(X509_ASN_ENCODING,
                          SPC_STATEMENT_TYPE_STRUCT,
                          &StatementType,
                          NULL,           // pbEncoded
                          &cbEncoded);
        if (cbEncoded == 0)
            PKITHROW(SignError());
        pbEncoded = (BYTE *) malloc(cbEncoded);
        if (pbEncoded == NULL) 
            PKITHROW(E_OUTOFMEMORY);
        if (!CryptEncodeObject(X509_ASN_ENCODING,
                               SPC_STATEMENT_TYPE_STRUCT,
                               &StatementType,
                               pbEncoded,
                               &cbEncoded)) 
            PKITHROW(SignError());
    }
    PKICATCH(err) {
        if (pbEncoded) {
            free(pbEncoded);
            pbEncoded = NULL;
        }
        cbEncoded = 0;
        hr = err.pkiError;
    } PKIEND;

    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return hr;
}

//+-------------------------------------------------------------------------
//  Encode the SpOpusInfo authenticated attribute value
//--------------------------------------------------------------------------
HRESULT CreateOpusInfo(IN LPCWSTR pwszOpusName,
                       IN LPCWSTR pwszOpusInfo,
                       OUT BYTE **ppbEncoded,
                       IN OUT DWORD *pcbEncoded)
{
    HRESULT hr = S_OK;
    BYTE *pbEncoded = NULL;
    DWORD cbEncoded;
    SPC_LINK MoreInfo;
    SPC_SP_OPUS_INFO sSpcOpusInfo;
    
    ZeroMemory(&sSpcOpusInfo, sizeof(SPC_SP_OPUS_INFO));
    sSpcOpusInfo.pwszProgramName = (LPWSTR) pwszOpusName;

    if (pwszOpusInfo) {
        MoreInfo.dwLinkChoice = SPC_URL_LINK_CHOICE;

        //
        // To be backwards compatible with IE 3.0 WinVerifyTrust the
        // following is set to an even length to inhibit the possibility
        // of an 0x7f length in the encoded ASN.
        // In IE 3.0 an 0x81 is erroneously prepended before a
        // 0x7f length when the OPUS info is re-encoded before hashing. Making
        // the length of pwszUrl even precludes this from happening.
        //
        // Note, the pwszUrl is first converted to multibyte before being
        // encoded. Its the multibyte length that must have an even length.

        int cchMultiByte;
        cchMultiByte = WideCharToMultiByte(CP_ACP,
                                           0,          // dwFlags
                                           pwszOpusInfo,
                                           -1,         // cchWideChar, -1 => null terminated
                                           NULL,       // lpMultiByteStr
                                           0,          // cchMultiByte
                                           NULL,       // lpDefaultChar
                                           NULL        // lpfUsedDefaultChar
                                           );
        // cchMultiByte includes the null terminator
        if (cchMultiByte > 1 && ((cchMultiByte - 1) & 1)) {
            // Odd length. Add extra space to end.
            int Len = wcslen(pwszOpusInfo);
            MoreInfo.pwszUrl = (LPWSTR) _alloca((Len + 2) * sizeof(WCHAR));
            wcscpy(MoreInfo.pwszUrl, pwszOpusInfo);
            wcscpy(MoreInfo.pwszUrl + Len, L" ");
        } else
            MoreInfo.pwszUrl = (LPWSTR) pwszOpusInfo;
        sSpcOpusInfo.pMoreInfo = &MoreInfo;
    }
    
    PKITRY {
        cbEncoded = 0;
        CryptEncodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                          SPC_SP_OPUS_INFO_STRUCT,
                          &sSpcOpusInfo,
                          NULL,           // pbEncoded
                          &cbEncoded);
        if (cbEncoded == 0) 
            PKITHROW(SignError());
        
        pbEncoded = (BYTE *) malloc(cbEncoded);
        if (pbEncoded == NULL) 
            PKITHROW(E_OUTOFMEMORY);
        
        if (!CryptEncodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                               SPC_SP_OPUS_INFO_STRUCT,
                               &sSpcOpusInfo,
                               pbEncoded,
                               &cbEncoded)) 
            PKITHROW(SignError());
        
    }
    PKICATCH(err) {
        if (pbEncoded) {
            free(pbEncoded);
            pbEncoded = NULL;
        }
        cbEncoded = 0;
        hr = err.pkiError;
    } PKIEND;

    *ppbEncoded = pbEncoded;
    *pcbEncoded = cbEncoded;
    return hr;
}

//+-------------------------------------------------------------------------
//  Checks if the certificate a glue certificate
//  in IE30
//  Returns: S_OK                   - Is a glue certificate
//           S_FALSE                - Not a certificate
//           CRYPT_E_OSS_ERROR + Oss error - Encode or Decode error.
//+-------------------------------------------------------------------------
HRESULT SignIsGlueCert(IN PCCERT_CONTEXT pCert)
{
    HRESULT hr = S_OK;
    PCERT_NAME_BLOB pName = &pCert->pCertInfo->Subject;
    PCERT_NAME_INFO pNameInfo = NULL;
    DWORD cbNameInfo;

    PKITRY {
        cbNameInfo = 0;
        CryptDecodeObject(X509_ASN_ENCODING,
                     X509_NAME,
                     pName->pbData,
                     pName->cbData,
                     0,                      // dwFlags
                     NULL,                   // pNameInfo
                     &cbNameInfo);
        
        if (cbNameInfo == 0) 
            PKITHROW(SignError());
        
        pNameInfo = (PCERT_NAME_INFO) malloc(cbNameInfo);
        if(!pNameInfo)
            return E_OUTOFMEMORY;
        
        if (!CryptDecodeObject(X509_ASN_ENCODING,
                          X509_NAME,
                          pName->pbData,
                          pName->cbData,
                          0,                  // dwFlags
                          pNameInfo,
                          &cbNameInfo)) 
            PKITHROW(SignError());

        if(!CertFindRDNAttr(SPC_GLUE_RDN_OBJID, pNameInfo) != NULL)
            hr = S_FALSE;
    }
    PKICATCH (err) {
        hr = err.pkiError;
    } PKIEND;

    if (pNameInfo) free(pNameInfo);

    return hr;
}


//+-------------------------------------------------------------------------
//  Skip over the identifier and length octets in an ASN encoded blob.
//  Returns the number of bytes skipped.
//
//  For an invalid identifier or length octet returns 0.
//--------------------------------------------------------------------------
static DWORD SkipOverIdentifierAndLengthOctets(
    IN const BYTE *pbDER,
    IN DWORD cbDER
    )
{
#define TAG_MASK 0x1f
    DWORD   cb;
    DWORD   cbLength;
    const BYTE   *pb = pbDER;

    // Need minimum of 2 bytes
    if (cbDER < 2)
        return 0;

    // Skip over the identifier octet(s)
    if (TAG_MASK == (*pb++ & TAG_MASK)) {
        // high-tag-number form
        for (cb=2; *pb++ & 0x80; cb++) {
            if (cb >= cbDER)
                return 0;
        }
    } else
        // low-tag-number form
        cb = 1;

    // need at least one more byte for length
    if (cb >= cbDER)
        return 0;

    if (0x80 == *pb)
        // Indefinite
        cb++;
    else if ((cbLength = *pb) & 0x80) {
        cbLength &= ~0x80;         // low 7 bits have number of bytes
        cb += cbLength + 1;
        if (cb > cbDER)
            return 0;
    } else
        cb++;

    return cb;
}

//--------------------------------------------------------------------------
//
//	Skip over the tag and length
//----------------------------------------------------------------------------
BOOL WINAPI SignNoContentWrap(IN const BYTE *pbDER,
              IN DWORD cbDER)
{
    DWORD cb;

    cb = SkipOverIdentifierAndLengthOctets(pbDER, cbDER);
    if (cb > 0 && cb < cbDER && pbDER[cb] == 0x02)
        return TRUE;
    else
        return FALSE;
}

#define SH1_HASH_LENGTH     20

//+-----------------------------------------------------------------------
//  Make sure that the certificate is valid for timestamp 
//------------------------------------------------------------------------
/*BOOL	ValidTimestampCert(PCCERT_CONTEXT pCertContext)
{
	BOOL				fValid=FALSE;	
    DWORD               cbSize=0;
    PCERT_ENHKEY_USAGE  pCertEKU=NULL;
    BYTE                *pbaSignersThumbPrint=NULL;
	DWORD				dwIndex=0;

    static BYTE         baVerisignTimeStampThumbPrint[SH1_HASH_LENGTH] =
                            { 0x38, 0x73, 0xB6, 0x99, 0xF3, 0x5B, 0x9C, 0xCC, 0x36, 0x62,
                              0xB6, 0x48, 0x3A, 0x96, 0xBD, 0x6E, 0xEC, 0x97, 0xCF, 0xB7 };

    cbSize = 0;

	if (!(CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, 
                    NULL, &cbSize)))
		goto CLEANUP;

	pbaSignersThumbPrint=(BYTE *)malloc(cbSize);
	if(!pbaSignersThumbPrint)
		goto CLEANUP;


    if (!(CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, 
                                        pbaSignersThumbPrint, &cbSize)))
		goto CLEANUP;

    //
    //  1st, check to see if it's Verisign's first timestamp certificate
	if(cbSize!=sizeof(baVerisignTimeStampThumbPrint)/sizeof(baVerisignTimeStampThumbPrint[0]))
		goto CLEANUP;

    if (memcmp(pbaSignersThumbPrint, baVerisignTimeStampThumbPrint, cbSize) == 0)
    {
		fValid=TRUE;
		goto CLEANUP;
    }

    //
    //  see if the certificate has the proper enhanced key usage OID
    //
    cbSize = 0;

    if(!CertGetEnhancedKeyUsage(pCertContext, 
                            CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                            NULL,
                            &cbSize) || (cbSize==0))
		goto CLEANUP;

	pCertEKU = (PCERT_ENHKEY_USAGE)malloc(cbSize);
	if(!pCertEKU)
		goto CLEANUP;

    if (!(CertGetEnhancedKeyUsage(pCertContext,
                                  CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG,
                                  pCertEKU,
                                  &cbSize)))
		goto CLEANUP;		

    for (dwIndex = 0; dwIndex < pCertEKU->cUsageIdentifier; dwIndex++)
    {
        if (strcmp(pCertEKU->rgpszUsageIdentifier[dwIndex], szOID_KP_TIME_STAMP_SIGNING) == 0)
        {
			fValid=TRUE;
			break;
		}


        if (strcmp(pCertEKU->rgpszUsageIdentifier[dwIndex], szOID_PKIX_KP_TIMESTAMP_SIGNING) == 0)
        {
            fValid=TRUE;
            break;
        }

    }


CLEANUP:

	if(pbaSignersThumbPrint)
		free(pbaSignersThumbPrint);

	if(pCertEKU)
		free(pCertEKU);

	return fValid;
}  */

//-------------------------------------------------------------------------
//
//	Call GetLastError and convert the return code to HRESULT
//--------------------------------------------------------------------------
HRESULT WINAPI SignError ()
{
    DWORD   dw = GetLastError ();
    HRESULT hr;
    if ( dw <= (DWORD) 0xFFFF )
        hr = HRESULT_FROM_WIN32 ( dw );
    else
        hr = dw;
    if ( ! FAILED ( hr ) )
    {
        // somebody failed a call without properly setting an error condition

        hr = E_UNEXPECTED;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\mssign32\pvkutil.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pvkutil.cpp
//
//--------------------------------------------------------------------------

#include "global.hxx"
#include "pvkhlpr.h"

//+-------------------------------------------------------------------------
//  Get crypto provider to based on either the pvkfile or key container name
//--------------------------------------------------------------------------
HRESULT WINAPI PvkGetCryptProv(	IN HWND hwnd,
							IN LPCWSTR pwszCaption,
							IN LPCWSTR pwszCapiProvider,
							IN DWORD   dwProviderType,
							IN LPCWSTR pwszPvkFile,
							IN LPCWSTR pwszKeyContainerName,
							IN DWORD   *pdwKeySpec,
							OUT LPWSTR *ppwszTmpContainer,
							OUT HCRYPTPROV *phCryptProv)
{
	HANDLE	hFile=NULL;
	HRESULT	hr=E_FAIL;
	DWORD	dwRequiredKeySpec=0;

	//Init
	*ppwszTmpContainer=NULL;
	*phCryptProv=NULL;

	//get the provider handle based on the key container name
	if(pwszKeyContainerName)
	{
		if(!CryptAcquireContextU(phCryptProv,
                                 pwszKeyContainerName,
                                 pwszCapiProvider,
                                 dwProviderType,
                                 0))          // dwFlags
			return SignError();

		//try to figure out the key specification
		if((*pdwKeySpec)==0)
			dwRequiredKeySpec=AT_SIGNATURE;
		else
			dwRequiredKeySpec=*pdwKeySpec;

		//make sure *pdwKeySpec is the correct key spec
		HCRYPTKEY hPubKey;
		if (CryptGetUserKey(
            *phCryptProv,
            dwRequiredKeySpec,
            &hPubKey
            )) 
		{
			CryptDestroyKey(hPubKey);
			*pdwKeySpec=dwRequiredKeySpec;
			return S_OK;
		} 
		else 
		{
			//we fail is user required another key spec
			if((*pdwKeySpec)!=0)
			{
				// Doesn't have the specified public key
				hr=SignError();
				CryptReleaseContext(*phCryptProv, 0);
				*phCryptProv=NULL;
				return hr;
			}

			//now we try AT_EXCHANGE key
			dwRequiredKeySpec=AT_KEYEXCHANGE;

			if (CryptGetUserKey(
				*phCryptProv,
				dwRequiredKeySpec,
				&hPubKey
				)) 
			{
				CryptDestroyKey(hPubKey);
				*pdwKeySpec=dwRequiredKeySpec;
				return S_OK;
			}
			else
			{
				// Doesn't have the specified public key
				hr=SignError();
				CryptReleaseContext(*phCryptProv, 0);
				*phCryptProv=NULL;
				return hr;
			}
		}		
	}

	//get the providedr handle based on the pvk file name

     hFile = CreateFileU(pwszPvkFile,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            NULL,                   // lpsa
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);	// hTemplateFile


     if (hFile == INVALID_HANDLE_VALUE) 
		  return SignError();
		 

     if(!PvkPrivateKeyAcquireContext(pwszCapiProvider,
                                            dwProviderType,
                                            hFile,
                                            hwnd,
                                            pwszCaption,
                                            pdwKeySpec,
                                            phCryptProv,
                                            ppwszTmpContainer))
	 {
			*phCryptProv=NULL;
			hr=SignError();
	 }
	 else
		    hr=S_OK;

    CloseHandle(hFile);
    return hr;
}



void WINAPI PvkFreeCryptProv(IN HCRYPTPROV hProv,
                      IN LPCWSTR pwszCapiProvider,
                      IN DWORD dwProviderType,
                      IN LPWSTR pwszTmpContainer)
{
    
    if (pwszTmpContainer) {
        // Delete the temporary container for the private key from
        // the provider
        PvkPrivateKeyReleaseContext(hProv,
                                    pwszCapiProvider,
                                    dwProviderType,
                                    pwszTmpContainer);
    } else {
        if (hProv)
            CryptReleaseContext(hProv, 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\mssign32\signhlp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       signhlp.h
//
//  Contents:   Digital Signing Helper APIs
//
//  History:    June-25-1997	Xiaohs    Created
//----------------------------------------------------------------------------
#ifndef _SIGNHLP_H
#define _SIGNHLP_H


#ifdef __cplusplus
extern "C" {
#endif	 


//--------------------------------------------------------------------------
//
//	Copy all the certs from store name to hDescStore
//
//--------------------------------------------------------------------------
HRESULT	MoveStoreName(HCRYPTPROV	hCryptProv, 
					  DWORD			dwCertEncodingType, 
					  HCERTSTORE	hDescStore, 
					  DWORD			dwStoreName,
					  DWORD			dwStoreFlag);


//--------------------------------------------------------------------------
//
//	Copy all the certs from hSrcStore to hDescStore
//
//--------------------------------------------------------------------------
HRESULT	MoveStore(HCERTSTORE	hDescStore, 
				  HCERTSTORE	hSrcStore);


//--------------------------------------------------------------------------
//
//	Build up the certificate chain.  Put the whole chain to the store
//
//
//--------------------------------------------------------------------------
HRESULT	BuildCertChain(HCRYPTPROV		hCryptProv, 
					   DWORD			dwCertEncodingType,
					   HCERTSTORE		hStore, 
					   HCERTSTORE		hOptionalStore,
					   PCCERT_CONTEXT	pSigningCert, 
					   DWORD            dwCertPolicy);


//+-------------------------------------------------------------------------
//  Build the spc certificate store from the cert chain
//--------------------------------------------------------------------------
HRESULT	BuildStoreFromStore(HCRYPTPROV              hPvkProv,
                            DWORD                   dwKeySpec,
                            HCRYPTPROV				hCryptProv, 
							DWORD					dwCertEncodingType,				
							SIGNER_CERT_STORE_INFO  *pCertStoreInfo,
							HCERTSTORE				*phSpcStore,
                            PCCERT_CONTEXT          *ppSignCert);

//+-------------------------------------------------------------------------
//  Build the spc certificate store from  a spc file 
//--------------------------------------------------------------------------
HRESULT	BuildStoreFromSpcFile(HCRYPTPROV        hPvkProv,
                              DWORD             dwKeySpec,
                              HCRYPTPROV	    hCryptProv, 
							  DWORD			    dwCertEncodingType,
							  LPCWSTR		    pwszSpcFile, 
							  HCERTSTORE	    *phSpcStore,
                              PCCERT_CONTEXT    *ppSignCert);



//+-------------------------------------------------------------------------
//  Build the spc certificate store from either a spc file or the
//	cert chain
//--------------------------------------------------------------------------
HRESULT	BuildCertStore(HCRYPTPROV        hPvkProv,
                       DWORD            dwKeySpec,    
                       HCRYPTPROV	    hCryptProv,
					   DWORD		    dwCertEncodingType,
					   SIGNER_CERT	    *pSignerCert,
					   HCERTSTORE	    *phSpcStore,
                       PCCERT_CONTEXT   *ppSigningCert);
												   

//-----------------------------------------------------------------------------
//
//  Parse the private key information from a pCertContext's property
//	CERT_PVK_FILE_PROP_ID
//
//----------------------------------------------------------------------------
BOOL	GetProviderInfoFromCert(PCCERT_CONTEXT		pCertContext, 
								CRYPT_KEY_PROV_INFO	*pKeyProvInfo);

//+-------------------------------------------------------------------------
//  Get hCryptProv handle and key spec for the certificate
//--------------------------------------------------------------------------
BOOL WINAPI GetCryptProvFromCert( 
	HWND			hwnd,
    PCCERT_CONTEXT	pCert,
    HCRYPTPROV		*phCryptProv,
    DWORD			*pdwKeySpec,
    BOOL			*pfDidCryptAcquire,
	LPWSTR			*ppwszTmpContainer,
	LPWSTR			*ppwszProviderName,
	DWORD			*pdwProviderType
    );


//This is a subst of GetCryptProvFromCert.  This function does not consider
//the private key file property of the certificate
BOOL WINAPI CryptProvFromCert(
	HWND				hwnd,
    PCCERT_CONTEXT		pCert,
    HCRYPTPROV			*phCryptProv,
    DWORD				*pdwKeySpec,
    BOOL				*pfDidCryptAcquire
    );

//+-------------------------------------------------------------------------
//  Free hCryptProv handle and key spec for the certificate
//--------------------------------------------------------------------------
void WINAPI FreeCryptProvFromCert(BOOL			fAcquired,
						   HCRYPTPROV	hProv,
						   LPWSTR		pwszCapiProvider,
                           DWORD		dwProviderType,
                           LPWSTR		pwszTmpContainer);


//+-----------------------------------------------------------------------
//  Check the input parameters of Signcode.  Make sure they are valid.
//  
//+-----------------------------------------------------------------------
BOOL	CheckSigncodeParam(
				SIGNER_SUBJECT_INFO		*pSubjectInfo,			
				SIGNER_CERT				*pSignerCert,
				SIGNER_SIGNATURE_INFO	*pSignatureInfo,
				SIGNER_PROVIDER_INFO	*pProviderInfo); 

//+-----------------------------------------------------------------------
//  Check the SIGNER_SUBJECT_INFO
//  
//+-----------------------------------------------------------------------
BOOL	CheckSigncodeSubjectInfo(
				PSIGNER_SUBJECT_INFO		pSubjectInfo); 


//+-----------------------------------------------------------------------
//  
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//     
//------------------------------------------------------------------------

HRESULT WINAPI
AddTimeStampSubj(IN DWORD dwEncodingType,
                 IN HCRYPTPROV hCryptProv,
                 IN LPSIP_SUBJECTINFO pSipInfo,
				 IN DWORD *pdwIndex,
                 IN PBYTE pbTimeStampResponse,
                 IN DWORD cbTimeStampResponse,
				 IN PBYTE pbEncodedSignerInfo,
				 IN DWORD cbEncodedSignerInfo,
                 OUT PBYTE* ppbMessage,				
                 OUT DWORD* pcbMessage);			


//+-----------------------------------------------------------------------
//  
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//     
//------------------------------------------------------------------------

HRESULT WINAPI 
GetSignedMessageDigest(IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,		//Required: The subject based on which to create a timestamp request 
					   IN  LPVOID					pSipData,
                       IN  OUT PBYTE*				ppbDigest,    
                       IN  OUT DWORD*				pcbDigest);

//+-----------------------------------------------------------------------
//  
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//     
//------------------------------------------------------------------------

HRESULT WINAPI 
GetSignedMessageDigestSubj(IN  DWORD dwEncodingType,
                           IN  HCRYPTPROV hCryptProv,
                           IN  struct SIP_SUBJECTINFO_ *pSipInfo,           // SIP information
						   IN  DWORD*     pdwIndex,
                           IN  OUT PBYTE* ppbTimeDigest,    
                           IN  OUT DWORD* pcbTimeDigest);

//+-----------------------------------------------------------------------
//  
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//     
//------------------------------------------------------------------------

HRESULT WINAPI 
TimeStampRequest(IN  DWORD dwEncodingType,
                 IN  PCRYPT_ATTRIBUTES psRequest,
                 IN  PBYTE pbDigest,
                 IN  DWORD cbDigest,
                 OUT PBYTE pbTimeRequest,      
                 IN  OUT DWORD* pcbTimeRequest);


//+-----------------------------------------------------------------------
//  FileToSubjectType
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//    E_INVALIDARG
//      Invalid arguement passed in (Requires a file name 
//                                   and pointer to a guid ptr)
//    TRUST_E_SUBJECT_FORM_UNKNOWN
//       Unknow file type
//    See also:
//      GetFileInformationByHandle()
//      CreateFile()
//     
//------------------------------------------------------------------------

HRESULT SignOpenFile(LPCWSTR  pwszFilename, 
                    HANDLE*  pFileHandle);


//+-----------------------------------------------------------------------
//  SignGetFileType
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//    E_INVALIDARG
//      Invalid arguement passed in (Requires a file name 
//                                   and pointer to a guid ptr)
//    See also:
//      GetFileInformationByHandle()
//      CreateFile()
//     
//------------------------------------------------------------------------

HRESULT SignGetFileType(HANDLE hFile,
                        const WCHAR *pwszFile,
                       GUID* pGuid);

//+-----------------------------------------------------------------------
//  SpcGetFileType
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//    E_INVALIDARG
//      Invalid arguement passed in (Requires a file name 
//                                   and pointer to a guid ptr)
//    See also:
//      GetFileInformationByHandle()
//      CreateFile()
//     
//------------------------------------------------------------------------
HRESULT SpcGetFileType(HANDLE hFile,
                       GUID*  pGuid);


//+-----------------------------------------------------------------------
//  SpcOpenFile
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//    E_INVALIDARG
//      Invalid arguement passed in (Requires a file name 
//                                   and pointer to a handle);
//    See also:
//      GetFileInformationByHandle()
//      CreateFile()
//     
//------------------------------------------------------------------------

HRESULT SpcOpenFile(LPCWSTR  pwszFileName, 
                    HANDLE* pFileHandle);


//+-------------------------------------------------------------------------
//  Find the the cert from the hprov
//  Parameter Returns:
//      pReturnCert - context of the cert found (must pass in cert context);
//  Returns:
//      S_OK - everything worked
//      E_OUTOFMEMORY - memory failure
//      E_INVALIDARG - no pReturnCert supplied
//      CRYPT_E_NO_MATCH - could not locate certificate in store
//
     
HRESULT 
SpcGetCertFromKey(IN DWORD dwCertEncodingType,
                  IN HCERTSTORE hStore,
                  IN HCRYPTPROV hProv,
                  IN DWORD hKeySpec,
                  OUT PCCERT_CONTEXT* pReturnCert);


//+-------------------------------------------------------------------------
//If all of the  following three conditions are true, we should not put 
// commercial or individual authenticated attributes into signer info 
//
//1.  the enhanced key usage extension of the signer's certificate has no code signing usage (szOID_PKIX_KP_CODE_SIGNING)
//2. basic constraints extension of the signer's cert is missing, or it is neither commercial nor individual
//3. user did not specify -individual or -commercial in signcode.exe.
//--------------------------------------------------------------------------
BOOL    NeedStatementTypeAttr(IN PCCERT_CONTEXT psSigningContext, 
                              IN BOOL           fCommercial, 
                              IN BOOL           fIndividual);

//+-------------------------------------------------------------------------
//  Returns TRUE if the Signer Cert has a Key Usage Restriction extension and
//  only the commercial key purpose policy object identifier.
//
//  Returns FALSE if it contains both a commercial and individual purpose
//  policy object identifier.
//--------------------------------------------------------------------------
HRESULT CheckCommercial(IN PCCERT_CONTEXT pSignerCert,
							   IN BOOL fCommercial,
							   IN BOOL fIndividual, 
							   OUT BOOL *pfCommercial);


//+-------------------------------------------------------------------------
//  Encode the StatementType authenticated attribute value
//--------------------------------------------------------------------------
HRESULT CreateStatementType(IN BOOL fCommercial,
                            OUT BYTE **ppbEncoded,
                            IN OUT DWORD *pcbEncoded);

//+-------------------------------------------------------------------------
//  Encode the SpOpusInfo authenticated attribute value
//--------------------------------------------------------------------------
HRESULT CreateOpusInfo(IN LPCWSTR pwszOpusName,
                       IN LPCWSTR pwszOpusInfo,
                       OUT BYTE **ppbEncoded,
                       IN OUT DWORD *pcbEncoded);


//+-----------------------------------------------------------------------
//  
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//     
//------------------------------------------------------------------------

HRESULT SpcLoadSipFlags(GUID* pSubjectGuid,
                        DWORD *dwFlags);

//+-----------------------------------------------------------------------
//  
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//     
//------------------------------------------------------------------------

HINSTANCE GetInstanceHandle();

//+-----------------------------------------------------------------------
//  
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//     
//------------------------------------------------------------------------

void WINAPI PvkFreeCryptProv(IN HCRYPTPROV hProv,
                      IN LPCWSTR pwszCapiProvider,
                      IN DWORD dwProviderType,
                      IN LPWSTR pwszTmpContainer);


//+-----------------------------------------------------------------------
//  
//  
//  Parameters:
//  Return Values:
//  Error Codes:
//     
//------------------------------------------------------------------------
HRESULT WINAPI PvkGetCryptProv(	IN HWND hwnd,
							IN LPCWSTR pwszCaption,
							IN LPCWSTR pwszCapiProvider,
							IN DWORD   dwProviderType,
							IN LPCWSTR pwszPvkFile,
							IN LPCWSTR pwszKeyContainerName,
							IN DWORD   *pdwKeySpec,
							OUT LPWSTR *ppwszTmpContainer,
							OUT HCRYPTPROV *phCryptProv);




//+-----------------------------------------------------------------------
//  Check to see if the certificate is a glue cert
//------------------------------------------------------------------------
HRESULT SignIsGlueCert(IN PCCERT_CONTEXT pCert);

//+-----------------------------------------------------------------------
//  Return hr based on GetLastError().
//------------------------------------------------------------------------
HRESULT WINAPI SignError();

//+-----------------------------------------------------------------------
//  Check if there is TAG in front of a PKCS7 signed message
//------------------------------------------------------------------------
BOOL WINAPI SignNoContentWrap(IN const BYTE *pbDER,
							 IN DWORD cbDER);

//-------------------------------------------------------------------------
//
//	WSZtoSZ:
//		Convert a wchar string to a multi-byte string.
//
//-------------------------------------------------------------------------
HRESULT	WSZtoSZ(LPWSTR wsz, LPSTR *psz);

//-------------------------------------------------------------------------
//
//	BytesToBase64:
//			convert bytes to base64 bstr
//
//-------------------------------------------------------------------------
HRESULT BytesToBase64(BYTE *pb, DWORD cb, CHAR **pszEncode, DWORD *pdwEncode);

//-------------------------------------------------------------------------
//
//	BytesToBase64:
//			conver base64 bstr to bytes
//
//-------------------------------------------------------------------------
HRESULT Base64ToBytes(CHAR *pEncode, DWORD cbEncode, BYTE **ppb, DWORD *pcb);



#ifdef __cplusplus
}
#endif



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\mssign32\timereq.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1999
//
//  File:       timereq.cpp
//
//  Contents:   Digital Timestamping APIs
//
//  History:    June-25-1997	Xiaohs    Created
//----------------------------------------------------------------------------

#include "global.hxx"
#include <stdio.h>

static char szCrypt32[]="crypt32.dll";
//The version for crtyp32.dll which shipped with NT sp3: "4.0.1381.4"
static DWORD	dwLowVersion=0x05650004;
static DWORD	dwHighVersion=0x00040000;

HRESULT WINAPI 
GetSignedMessageSignerInfoSubj(IN  DWORD dwEncodingType,
                           IN  HCRYPTPROV hCryptProv,
                           IN  LPSIP_SUBJECTINFO pSipInfo,  
						   IN  DWORD*     pdwIndex,
                           IN  OUT PBYTE* ppbSignerInfo,    
                           IN  OUT DWORD* pcbSignerInfo)
{
    HRESULT hr = S_OK;
    SIP_DISPATCH_INFO sSip;  ZERO(sSip); // Table of sip functions
    DWORD cbSignedMsg = 0;
    PBYTE pbSignedMsg = 0;
    DWORD dwCertEncoding = 0;
    DWORD dwMsgType = 0;
    HCRYPTMSG hMsg = NULL;
    DWORD   cbSignerInfo=0;
    BYTE    *pbSignerInfo=NULL;

    PKITRY {

        if(!pcbSignerInfo || !ppbSignerInfo)
            PKITHROW(E_INVALIDARG);

        //init
        *pcbSignerInfo=0;
        *ppbSignerInfo=NULL;


       // Load up the sip functions. 
        if(!CryptSIPLoad(pSipInfo->pgSubjectType,   // GUID for the requried sip
                         0,               // Reserved
                         &sSip))          // Table of functions
            PKITHROW(SignError());
            
        sSip.pfGet(pSipInfo, 
                   &dwCertEncoding,
                   *pdwIndex, 
                   &cbSignedMsg,
                   NULL);
        if(cbSignedMsg == 0) PKITHROW(SignError());
        
        pbSignedMsg = (PBYTE) malloc(cbSignedMsg);
        if (!pbSignedMsg) PKITHROW(E_OUTOFMEMORY);
        
        if(!sSip.pfGet(pSipInfo, 
                       &dwCertEncoding,
                       *pdwIndex, 
                       &cbSignedMsg,
                       pbSignedMsg))
            PKITHROW(SignError()); // Real error.
       if(pSipInfo->dwUnionChoice != MSSIP_ADDINFO_BLOB)
       {
        if(dwCertEncoding != dwEncodingType) 
            PKITHROW(TRUST_E_NOSIGNATURE); 
       }
        
        if ((GET_CMSG_ENCODING_TYPE(dwEncodingType) & PKCS_7_ASN_ENCODING) &&
                SignNoContentWrap(pbSignedMsg, cbSignedMsg))
                dwMsgType = CMSG_SIGNED;
            
        // Use CryptMsg to crack the encoded PKCS7 Signed Message
        if (!(hMsg = CryptMsgOpenToDecode(dwEncodingType,
                                          0,              // dwFlags
                                          dwMsgType,
                                          hCryptProv,
                                          NULL,           // pRecipientInfo
                                          NULL))) 
            PKITHROW(E_UNEXPECTED);
        
        if (!CryptMsgUpdate(hMsg,
                            pbSignedMsg,
                            cbSignedMsg,
                            TRUE))                    // fFinal
            PKITHROW(SignError());

        if(!CryptMsgGetParam(hMsg,
                             CMSG_ENCODED_SIGNER,
                             0, // First signer
                             NULL,
                             &cbSignerInfo))
             PKITHROW(SignError());

        pbSignerInfo=(PBYTE)malloc(cbSignerInfo);
        if(!pbSignerInfo)
            PKITHROW(E_OUTOFMEMORY);

        if(!CryptMsgGetParam(hMsg,
                             CMSG_ENCODED_SIGNER,
                             0, // First signer
                             pbSignerInfo,
                             &cbSignerInfo))
             PKITHROW(SignError());

        //copy to the out put
        *ppbSignerInfo=pbSignerInfo;
        *pcbSignerInfo=cbSignerInfo;

        hr=S_OK;

        
    }
    PKICATCH(err) {
        hr = err.pkiError;
    } PKIEND;

    if (hMsg) 
        CryptMsgClose(hMsg);
    if(pbSignedMsg)
        free(pbSignedMsg);
    if( (hr!=S_OK) && (pbSignerInfo))
        free(pbSignerInfo);
    return hr;
}



HRESULT WINAPI 
GetSignedMessageSignerInfo(IN  HCRYPTPROV				hCryptProv,
						   IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,	
						   IN  LPVOID					pSipInfo,
						   IN  OUT PBYTE*				ppbSignerInfo,    
                           IN  OUT DWORD*				pcbSignerInfo)
{
    HRESULT    hr = S_OK;
    HANDLE     hFile = NULL;
	BOOL	   fFileOpen=FALSE;

    GUID			gSubjectGuid; // The subject guid used to load the sip
	MS_ADDINFO_BLOB	sBlob;
    SIP_SUBJECTINFO sSubjInfo; ZERO(sSubjInfo);
    
    DWORD dwEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING; // For this version we default to this.

    PKITRY {
        if(!pcbSignerInfo || !ppbSignerInfo)
            PKITHROW(E_INVALIDARG);
        
        sSubjInfo.dwEncodingType = dwEncodingType;
        sSubjInfo.cbSize = sizeof(SIP_SUBJECTINFO); // Version
        sSubjInfo.pgSubjectType = (GUID*) &gSubjectGuid;
		sSubjInfo.hProv=hCryptProv;
        
		//set up file information
		if(pSubjectInfo->dwSubjectChoice==SIGNER_SUBJECT_FILE)
		{
			// Open up the file
			if((pSubjectInfo->pSignerFileInfo->hFile)==NULL ||
				(pSubjectInfo->pSignerFileInfo->hFile)==INVALID_HANDLE_VALUE)
			{
				if(S_OK != (hr = SignOpenFile(
							pSubjectInfo->pSignerFileInfo->pwszFileName, &hFile)))
					PKITHROW(hr);

				fFileOpen=TRUE;
			}
			else
				hFile=pSubjectInfo->pSignerFileInfo->hFile;

			// Get the subject type.
            if(S_OK != (hr=SignGetFileType(hFile, pSubjectInfo->pSignerFileInfo->pwszFileName, &gSubjectGuid)))
					PKITHROW(hr);


			sSubjInfo.pgSubjectType = (GUID*) &gSubjectGuid;
			sSubjInfo.hFile = hFile;
			sSubjInfo.pwsFileName = pSubjectInfo->pSignerFileInfo->pwszFileName;
		}
		else
		{
			memset(&sBlob, 0, sizeof(MS_ADDINFO_BLOB));

			sSubjInfo.pgSubjectType=pSubjectInfo->pSignerBlobInfo->pGuidSubject;
			sSubjInfo.pwsDisplayName=pSubjectInfo->pSignerBlobInfo->pwszDisplayName;
			sSubjInfo.dwUnionChoice=MSSIP_ADDINFO_BLOB;
			sSubjInfo.psBlob=&sBlob;

			sBlob.cbStruct=sizeof(MS_ADDINFO_BLOB);
			sBlob.cbMemObject=pSubjectInfo->pSignerBlobInfo->cbBlob;
			sBlob.pbMemObject=pSubjectInfo->pSignerBlobInfo->pbBlob;
		}


        hr = GetSignedMessageSignerInfoSubj(
										dwEncodingType,
                                        hCryptProv,
                                        &sSubjInfo,
										pSubjectInfo->pdwIndex,
                                        ppbSignerInfo,
                                        pcbSignerInfo);

    if ((hFile) && (fFileOpen == TRUE) && !(sSubjInfo.hFile)) 
    {
        fFileOpen = FALSE;  // we opened it, but, the SIP closed it!
    }

        if(hr != S_OK) PKITHROW(hr);
    }
    PKICATCH(err) {
        hr = err.pkiError;
    } PKIEND;
    if(hFile && (fFileOpen==TRUE)) CloseHandle(hFile);
    return hr;
}

HRESULT WINAPI
SignerAddTimeStampResponse(
			IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,			//Required: The subject to which the timestamp request should be added 
             IN PBYTE					pbTimeStampResponse,
             IN DWORD					cbTimeStampResponse,
			 IN LPVOID					pSipData)
{
    return SignerAddTimeStampResponseEx(
            0,
            pSubjectInfo,		
            pbTimeStampResponse, 
            cbTimeStampResponse, 
            pSipData,
            NULL);            
}



HRESULT WINAPI
SignerAddTimeStampResponseEx(
             IN  DWORD                  dwFlags,                //Reserved: Has to be set to 0.
			 IN  SIGNER_SUBJECT_INFO    *pSubjectInfo,			//Required: The subject to which the timestamp request should be added 
             IN PBYTE					pbTimeStampResponse,
             IN DWORD					cbTimeStampResponse,
			 IN LPVOID					pSipData,
             OUT SIGNER_CONTEXT         **ppSignerContext      
             )
{
    HRESULT    hr = S_OK;
    HANDLE     hFile = NULL;
	BOOL	   fFileOpen=FALSE;


    DWORD dwEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING;


    GUID			gSubjectGuid; // The subject guid used to load the sip
    SIP_SUBJECTINFO sSubjInfo; ZERO(sSubjInfo);
	MS_ADDINFO_BLOB	sBlob;
    HCRYPTPROV		hCryptProv = NULL;

	DWORD	        cbSignerInfo=0;
	BYTE        	*pbSignerInfo=NULL;

    PBYTE           pbEncodedMessage=NULL;			
    DWORD           cbEncodedMessage=0;			


    PKITRY {

        //init
       if(ppSignerContext)
           *ppSignerContext=NULL;

	   if(FALSE==CheckSigncodeSubjectInfo(pSubjectInfo))
            PKITHROW(E_INVALIDARG);

        // Use the default provider
        if(!CryptAcquireContext(&hCryptProv,
                                NULL,
                                MS_DEF_PROV,
                                PROV_RSA_FULL,
                                CRYPT_VERIFYCONTEXT))
            PKITHROW(SignError());
        

		//retrieve the enccoded signer info
		hr = GetSignedMessageSignerInfo(hCryptProv,
										pSubjectInfo,
										pSipData,
                                        &pbSignerInfo,
                                        &cbSignerInfo);

		if(hr != S_OK) PKITHROW(hr);


        
        sSubjInfo.hProv = hCryptProv;
        sSubjInfo.DigestAlgorithm.pszObjId = NULL;
        sSubjInfo.dwEncodingType = dwEncodingType;
        
        sSubjInfo.cbSize = sizeof(SIP_SUBJECTINFO); // Version
		sSubjInfo.pClientData = pSipData;

		//set up file information
		if(pSubjectInfo->dwSubjectChoice==SIGNER_SUBJECT_FILE)
		{
			// Open up the file
			if((pSubjectInfo->pSignerFileInfo->hFile)==NULL ||
				(pSubjectInfo->pSignerFileInfo->hFile)==INVALID_HANDLE_VALUE)
			{
				if(S_OK != (hr = SignOpenFile(
							pSubjectInfo->pSignerFileInfo->pwszFileName, &hFile)))
					PKITHROW(hr);

				fFileOpen=TRUE;
			}
			else
				hFile=pSubjectInfo->pSignerFileInfo->hFile;

			// Get the subject type.
			if(S_OK != (hr=SignGetFileType(hFile, pSubjectInfo->pSignerFileInfo->pwszFileName, &gSubjectGuid)))
					PKITHROW(hr);


			sSubjInfo.pgSubjectType = (GUID*) &gSubjectGuid;
			sSubjInfo.hFile = hFile;
			sSubjInfo.pwsFileName = pSubjectInfo->pSignerFileInfo->pwszFileName;
		}
		else
		{
			memset(&sBlob, 0, sizeof(MS_ADDINFO_BLOB));

			sSubjInfo.pgSubjectType=pSubjectInfo->pSignerBlobInfo->pGuidSubject;
			sSubjInfo.pwsDisplayName=pSubjectInfo->pSignerBlobInfo->pwszDisplayName;
			sSubjInfo.dwUnionChoice=MSSIP_ADDINFO_BLOB;
			sSubjInfo.psBlob=&sBlob;

			sBlob.cbStruct=sizeof(MS_ADDINFO_BLOB);
			sBlob.cbMemObject=pSubjectInfo->pSignerBlobInfo->cbBlob;
			sBlob.pbMemObject=pSubjectInfo->pSignerBlobInfo->pbBlob;
		}

        
        hr = AddTimeStampSubj(dwEncodingType,
                              hCryptProv,
                              &sSubjInfo,
							  pSubjectInfo->pdwIndex,
                              pbTimeStampResponse,
                              cbTimeStampResponse,
							  pbSignerInfo,
							  cbSignerInfo,
                              &pbEncodedMessage,
                              &cbEncodedMessage);

        if ((hFile) && (fFileOpen == TRUE) && !(sSubjInfo.hFile)) 
        {
            fFileOpen = FALSE;  // we opened it, but, the SIP closed it!
        }

        if(hr != S_OK) PKITHROW(hr);
        
        //set up the signer context
        if(ppSignerContext)
        {
            //set up the context information
            *ppSignerContext=(SIGNER_CONTEXT *)malloc(sizeof(SIGNER_CONTEXT));

            if(NULL==(*ppSignerContext))
            {
                hr=E_OUTOFMEMORY;
                PKITHROW(hr);
            }

            (*ppSignerContext)->cbSize=sizeof(SIGNER_CONTEXT);
            (*ppSignerContext)->cbBlob=cbEncodedMessage;
            (*ppSignerContext)->pbBlob=pbEncodedMessage;
            pbEncodedMessage=NULL;
        }

        hr=S_OK;

    }
    PKICATCH(err) {
        hr = err.pkiError;
    } PKIEND;
    if(hFile && (fFileOpen==TRUE)) CloseHandle(hFile);
    if(hCryptProv) CryptReleaseContext(hCryptProv, 0); 
	if(pbSignerInfo) free(pbSignerInfo);
    if(pbEncodedMessage) 
        free(pbEncodedMessage);
        
    return hr;
}


HRESULT WINAPI
AddTimeStampSubj(IN DWORD dwEncodingType,
                 IN HCRYPTPROV hCryptProv,
                 IN LPSIP_SUBJECTINFO pSipInfo,
				 IN DWORD *pdwIndex,
                 IN PBYTE pbTimeStampResponse,
                 IN DWORD cbTimeStampResponse,
				 IN PBYTE pbEncodedSignerInfo,
				 IN DWORD cbEncodedSignerInfo,
                 OUT PBYTE* ppbMessage,				
                 OUT DWORD* pcbMessage			
)
{
    HRESULT hr = S_OK;
    SIP_DISPATCH_INFO sSip;  ZERO(sSip); // Table of sip functions

    DWORD cbSignedMsg = 0;
    PBYTE pbSignedMsg = 0;
    DWORD dwCertEncoding = 0;
    DWORD dwMsgType = 0;
    HCRYPTMSG hMsg = NULL;
    PBYTE pbEncodedSigner = NULL;
    DWORD cbEncodedSigner = 0;
    PBYTE pbEncodedSignMsg = NULL; // Encoding for the statement attribute
    DWORD cbEncodedSignMsg  = 0;    //    :

    PBYTE pbCounterSign = NULL;
    DWORD cbCounterSign = 0;

	CERT_INFO	*pbCertInfo = NULL;
	DWORD		cbCertInfo = 0;

    HCERTSTORE hTmpCertStore=NULL;
    PCCERT_CONTEXT pCert = NULL;
    PCCRL_CONTEXT pCrl = NULL;

    PCRYPT_ATTRIBUTES pbUnauth = NULL;
    DWORD             cbUnauth = 0;
	DWORD			  dwFileVersionSize=0;
	DWORD			  dwFile=0;
	BYTE			  *pVersionInfo=NULL;
	VS_FIXEDFILEINFO  *pFixedFileInfo=NULL;
	UINT			  unitFixedFileInfo=0; 	

    
    PKITRY {
        
		// Use CryptMsg to crack the encoded PKCS7 Signed Message
        if (!(hMsg = CryptMsgOpenToDecode(dwEncodingType,
                                          0,              // dwFlags
                                          dwMsgType,
                                          hCryptProv,
                                          NULL,           // pRecipientInfo
                                          NULL))) 
            PKITHROW(E_UNEXPECTED);
        
        if (!CryptMsgUpdate(hMsg,
                            pbTimeStampResponse,
                            cbTimeStampResponse,
                            TRUE))                    // fFinal
            PKITHROW(SignError());

		//get the encoded signer BLOB
        CryptMsgGetParam(hMsg,
                         CMSG_ENCODED_SIGNER,
                         0,
                         NULL,               
                         &cbEncodedSigner);
        if (cbEncodedSigner == 0) PKITHROW(S_FALSE); // no attributes
        
        pbEncodedSigner = (PBYTE) malloc(cbEncodedSigner);
        if(!pbEncodedSigner) PKITHROW(E_OUTOFMEMORY);
        
        if (!CryptMsgGetParam(hMsg,
                              CMSG_ENCODED_SIGNER,
                              0,
                              pbEncodedSigner,
                              &cbEncodedSigner))
            PKITHROW(SignError());

		//get the timestamp signer's cert info
        if(!CryptMsgGetParam(hMsg,
                         CMSG_SIGNER_CERT_INFO_PARAM,
                         0,
                         NULL,               
                         &cbCertInfo))
			PKITHROW(SignError());

        if (cbCertInfo == 0) PKITHROW(SignError()); 
        
        pbCertInfo = (CERT_INFO *) malloc(cbCertInfo);
        if(!pbCertInfo) PKITHROW(E_OUTOFMEMORY);
        
        if (!CryptMsgGetParam(hMsg,
                              CMSG_SIGNER_CERT_INFO_PARAM,
                              0,
                              pbCertInfo,
                              &cbCertInfo))
            PKITHROW(SignError());


		// get the cert store from the timestamp response
		hTmpCertStore = CertOpenStore(CERT_STORE_PROV_MSG,
                                      dwEncodingType,
                                      hCryptProv,
                                      CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                      hMsg);

		if (hTmpCertStore == NULL) PKITHROW(SignError()); 

		//find the timestamper's certificate
		pCert = CertGetSubjectCertificateFromStore(
					hTmpCertStore,
					X509_ASN_ENCODING,
					pbCertInfo);

		if(NULL == pCert)
		{
			hr=HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
			PKITHROW(hr);
		}	

		//make sure the timestamper's certiricate is either from verisign, 
		// or has the correct key usage
	/*	if(!ValidTimestampCert(pCert))
		{
			hr=TRUST_E_TIME_STAMP;
			PKITHROW(hr);
		}  	   */


		//Compare hashed signature of the orinigal signed message
		//with the authenticated attribute from the timestamp respoonse.
		//they have to match
		if(pbEncodedSignerInfo!=NULL && cbEncodedSignerInfo!=0)
		{			
			//verify the signature of the timestamp
			if(0==CryptMsgControl(hMsg,0,CMSG_CTRL_VERIFY_SIGNATURE,
				 pCert->pCertInfo))
			{
				hr=HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
				PKITHROW(hr);
			}

			//verify the signatures
			if(!CryptMsgVerifyCountersignatureEncoded(
				hCryptProv,
				dwEncodingType,
				pbEncodedSignerInfo,
				cbEncodedSignerInfo,
				pbEncodedSigner,
				cbEncodedSigner,
				pCert->pCertInfo))
			{
				hr=HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
				PKITHROW(hr);
			}	
		
		}//end of the counter signature verificate
		
		//release the cert context
		if(pCert)
		{
			CertFreeCertificateContext(pCert);
			pCert=NULL;
		}

		//close the certstore
		if(hTmpCertStore)
		{
			CertCloseStore(hTmpCertStore, 0);
			hTmpCertStore=NULL;
		}

        // get the cert store from the file
        hTmpCertStore = CertOpenStore(CERT_STORE_PROV_MSG,
                                      dwEncodingType,
                                      hCryptProv,
                                      CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                      hMsg);
        if (hTmpCertStore == NULL) PKITHROW(SignError());
            
        CryptMsgClose(hMsg);
		hMsg = NULL;
        
        // Load up the sip functions. 
        if(!CryptSIPLoad(pSipInfo->pgSubjectType,   // GUID for the requried sip
                         0,							// Reserved
                         &sSip))					// Table of functions
            PKITHROW(SignError());

        sSip.pfGet(pSipInfo, 
                   &dwCertEncoding,
                   *pdwIndex, 
                   &cbSignedMsg,
                   NULL);
        if(cbSignedMsg == 0) PKITHROW(SignError());
        
        pbSignedMsg = (PBYTE) malloc(cbSignedMsg);
        if (!pbSignedMsg) PKITHROW(E_OUTOFMEMORY);
        
        if(!sSip.pfGet(pSipInfo, 
                       &dwCertEncoding,
                       *pdwIndex, 
                       &cbSignedMsg,
                       pbSignedMsg))
            PKITHROW(SignError()); // Real error.

        if(pSipInfo->dwUnionChoice != MSSIP_ADDINFO_BLOB)
        {
            if(dwCertEncoding != dwEncodingType) 
                PKITHROW(TRUST_E_NOSIGNATURE); 
        }
        
        if ((GET_CMSG_ENCODING_TYPE(dwEncodingType) & PKCS_7_ASN_ENCODING) &&
            SignNoContentWrap(pbSignedMsg, cbSignedMsg))
            dwMsgType = CMSG_SIGNED;
        

        // Use CryptMsg to crack the encoded PKCS7 Signed Message
        if (!(hMsg = CryptMsgOpenToDecode(dwEncodingType,
                                          0,              // dwFlags
                                          dwMsgType,
                                          hCryptProv,
                                          NULL,           // pRecipientInfo
                                          NULL))) 
            PKITHROW(E_UNEXPECTED);
        
        if (!CryptMsgUpdate(hMsg,
                            pbSignedMsg,
                            cbSignedMsg,
                            TRUE))                    // fFinal
            PKITHROW(SignError());


        // Encode up the signer info from the timestamp response and
        // add it as an unauthenticated attribute.
        CRYPT_ATTRIBUTE sAttr;
        CRYPT_ATTR_BLOB sSig;

        sSig.pbData = pbEncodedSigner;
        sSig.cbData = cbEncodedSigner;
        sAttr.pszObjId = szOID_RSA_counterSign;
        sAttr.cValue = 1;
        sAttr.rgValue = &sSig;

        CryptEncodeObject(dwEncodingType,
                          PKCS_ATTRIBUTE,
                          &sAttr,
                          pbCounterSign,
                          &cbCounterSign);
        if(cbCounterSign == 0) PKITHROW(SignError());
        
        pbCounterSign = (PBYTE) malloc(cbCounterSign);
        if(!pbCounterSign) PKITHROW(E_OUTOFMEMORY);

        if(!CryptEncodeObject(dwEncodingType,
                              PKCS_ATTRIBUTE,
                              &sAttr,
                              pbCounterSign,
                              &cbCounterSign))
            PKITHROW(SignError());
        

        CryptMsgGetParam(hMsg,
                         CMSG_SIGNER_UNAUTH_ATTR_PARAM,
                         0,
                         NULL,
                         &cbUnauth);
        if(cbUnauth) 
		{
            
			//check the version of "crytp32.dll".  If it is more than
			//"4.0.1381.4", we should be able to timestamp a timestamped
			//file



			dwFileVersionSize=GetFileVersionInfoSize(szCrypt32,&dwFile);

			if(!dwFileVersionSize)
				PKITHROW(SignError());

			pVersionInfo=(BYTE *)malloc(dwFileVersionSize);

			if(!pVersionInfo)
				 PKITHROW(SignError());

			if(!GetFileVersionInfo(szCrypt32, NULL,dwFileVersionSize,
				pVersionInfo))
				  PKITHROW(SignError());

			if(!VerQueryValue(pVersionInfo, "\\", (LPVOID *)&pFixedFileInfo,
				&unitFixedFileInfo))
			  PKITHROW(SignError());

			if(pFixedFileInfo->dwFileVersionMS <= dwHighVersion &&
				pFixedFileInfo->dwFileVersionLS <= dwLowVersion)
				PKITHROW(SignError());


			// we delete any existing time stamps since our policy provider
			//only support one timestamp per file
		
			pbUnauth = (PCRYPT_ATTRIBUTES) malloc(cbUnauth);
            if(!pbUnauth) PKITHROW(E_OUTOFMEMORY);
            
            if(!CryptMsgGetParam(hMsg,
                                 CMSG_SIGNER_UNAUTH_ATTR_PARAM,
                                 0,
                                 pbUnauth,
                                 &cbUnauth))
                PKITHROW(SignError());
            
            
            CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA  sAttrDel; ZERO(sAttrDel);
            sAttrDel.cbSize = sizeof(CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA);
			//we always assume there is only one signer
            sAttrDel.dwSignerIndex = 0;
            for(DWORD ii = 0; ii < pbUnauth->cAttr; ii++) 
			{
                if(strcmp(pbUnauth->rgAttr[ii].pszObjId, szOID_RSA_counterSign) == 0) 
				{
                        sAttrDel.dwUnauthAttrIndex = ii;
                        if (!CryptMsgControl(hMsg,
                                             0,
                                             CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR,
                                             &sAttrDel))
                            PKITHROW(SignError());
                }
            }  
        }
            
        CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA  sAttrPara; ZERO(sAttrPara);
        sAttrPara.cbSize = sizeof(CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA);
        sAttrPara.dwSignerIndex = 0;
        sAttrPara.blob.pbData = pbCounterSign;
        sAttrPara.blob.cbData = cbCounterSign;
        if (!CryptMsgControl(hMsg,
                             0,
                             CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR,
                             &sAttrPara))
            PKITHROW(SignError());
        // merge all the certificates from the time stamp response
        DWORD dwFlags = 0;

        while ((pCert = CertEnumCertificatesInStore(hTmpCertStore, pCert))) {
            CRYPT_DATA_BLOB blob;
            blob.pbData = pCert->pbCertEncoded;
            blob.cbData = pCert->cbCertEncoded;
            if (!CryptMsgControl(hMsg,
                                 0,
                                 CMSG_CTRL_ADD_CERT,
                                 &blob))
                PKITHROW(SignError());
        }

        while ((pCrl = CertGetCRLFromStore(hTmpCertStore, NULL, pCrl, &dwFlags))) {
            CRYPT_DATA_BLOB blob;
            blob.pbData = pCrl->pbCrlEncoded;
            blob.cbData = pCrl->cbCrlEncoded;
            if (!CryptMsgControl(hMsg,
                                 0,
                                 CMSG_CTRL_ADD_CRL,
                                 &blob))
                PKITHROW(SignError());
        }

        // Re-encode up the message and away we go.
        CryptMsgGetParam(hMsg,
                         CMSG_ENCODED_MESSAGE,
                         0,                      // dwIndex
                         NULL,                   // pbSignedData
                         &cbEncodedSignMsg);
        if (cbEncodedSignMsg == 0) PKITHROW(SignError());
        
        pbEncodedSignMsg = (PBYTE) malloc(cbEncodedSignMsg);
        if(!pbEncodedSignMsg) PKITHROW(E_OUTOFMEMORY);
        
        if (!CryptMsgGetParam(hMsg,
                              CMSG_ENCODED_MESSAGE,
                              0,                      // dwIndex
                              pbEncodedSignMsg,
                              &cbEncodedSignMsg))
            PKITHROW(SignError());
        
        //put the signatures if we are dealing with anything other than the BLOB
        if(pSipInfo->dwUnionChoice != MSSIP_ADDINFO_BLOB)
        {
            // Purge all the signatures in the subject
            sSip.pfRemove(pSipInfo, *pdwIndex);

            // Store the Signed Message in the sip
            if(!sSip.pfPut(pSipInfo,
                           dwEncodingType,
                           pdwIndex,
                           cbEncodedSignMsg,
                           pbEncodedSignMsg))
                PKITHROW(SignError());
        }


        if(ppbMessage && pcbMessage) 
        {
            *ppbMessage = pbEncodedSignMsg;
            pbEncodedSignMsg = NULL;
            *pcbMessage = cbEncodedSignMsg;
        }

    }
    PKICATCH(err) {
        hr = err.pkiError;
    } PKIEND;

    if(pbUnauth)
        free(pbUnauth);
    if(pCert)
        CertFreeCertificateContext(pCert);
    if(pCrl)
        CertFreeCRLContext(pCrl);
    if(hTmpCertStore)
        CertCloseStore(hTmpCertStore, 0);
    if(pbCounterSign)
        free(pbCounterSign);
    if(pbEncodedSignMsg)
        free(pbEncodedSignMsg);
    if (hMsg) 
        CryptMsgClose(hMsg);
    if(pbEncodedSigner)
        free(pbEncodedSigner);
    if(pbSignedMsg)
        free(pbSignedMsg);
	if(pVersionInfo)
		free(pVersionInfo);
	if(pbCertInfo)
		free(pbCertInfo);

    return hr;
}            


HRESULT WINAPI 
SignerCreateTimeStampRequest(
					   IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,		//Required: The subject based on which to create a timestamp request 
                       IN  PCRYPT_ATTRIBUTES psRequest,         // Optional, attributes added to Time stamp request 
					   IN  LPVOID	pSipData,
                       OUT PBYTE pbTimeStampRequest,
                       IN OUT DWORD* pcbTimeStampRequest)
{
    HRESULT    hr = S_OK;
	BOOL		fResult=FALSE;

    DWORD dwEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING; // For this version we default to this.

    PBYTE pbDigest = NULL;
    DWORD cbDigest = 0;

    PKITRY {
        if((!pcbTimeStampRequest) ||(FALSE==CheckSigncodeSubjectInfo(pSubjectInfo)))
            PKITHROW(E_INVALIDARG);

        if(*pcbTimeStampRequest == 0)
            pbTimeStampRequest = NULL;

            
        // Retrieve the digest from the signature on the file.

		hr = GetSignedMessageDigest(pSubjectInfo,
									  pSipData,
                                       &pbDigest,
                                        &cbDigest);

		if(hr != S_OK) PKITHROW(hr);

        hr = TimeStampRequest(dwEncodingType,
                              psRequest,
                              pbDigest,
                              cbDigest,
                              pbTimeStampRequest,
                              pcbTimeStampRequest);
        if(hr != S_OK) PKITHROW(hr);
    }
    PKICATCH(err) {
        hr = err.pkiError;
    } PKIEND;

    if(pbDigest) free(pbDigest);

    return hr;
}    
            

HRESULT WINAPI 
GetSignedMessageDigest(IN  SIGNER_SUBJECT_INFO		*pSubjectInfo,		//Required: The subject based on which to create a timestamp request 
					   IN  LPVOID					pSipData,
                       IN  OUT PBYTE*				ppbDigest,    
                       IN  OUT DWORD*				pcbDigest)
{
    HRESULT    hr = S_OK;
    HANDLE     hFile = NULL; 
	BOOL	   fFileOpen=FALSE;


    GUID				gSubjectGuid; // The subject guid used to load the sip
	MS_ADDINFO_BLOB		sBlob;
    SIP_SUBJECTINFO		sSubjInfo; ZERO(sSubjInfo);
    
    DWORD dwEncodingType = X509_ASN_ENCODING | PKCS_7_ASN_ENCODING; // For this version we default to this.

    PKITRY {
        if((!pcbDigest) || (!ppbDigest) || (FALSE==CheckSigncodeSubjectInfo(pSubjectInfo)))
            PKITHROW(E_INVALIDARG);

		*ppbDigest = NULL;

        
        // Set up the sip information (this is based on mssip.h)
        sSubjInfo.dwEncodingType = dwEncodingType;
        
        sSubjInfo.cbSize = sizeof(SIP_SUBJECTINFO); // Version
		sSubjInfo.pClientData = pSipData;


		//set up file information
		if(pSubjectInfo->dwSubjectChoice==SIGNER_SUBJECT_FILE)
		{
			// Open up the file
			if((pSubjectInfo->pSignerFileInfo->hFile)==NULL ||
				(pSubjectInfo->pSignerFileInfo->hFile)==INVALID_HANDLE_VALUE)
			{
				if(S_OK != (hr = SignOpenFile(
							pSubjectInfo->pSignerFileInfo->pwszFileName, &hFile)))
					PKITHROW(hr);

				fFileOpen=TRUE;
			}
			else
				hFile=pSubjectInfo->pSignerFileInfo->hFile;

			// Get the subject type.
			if(S_OK != (hr=SignGetFileType(hFile, pSubjectInfo->pSignerFileInfo->pwszFileName, &gSubjectGuid)))
					PKITHROW(hr);


			sSubjInfo.pgSubjectType = (GUID*) &gSubjectGuid;
			sSubjInfo.hFile = hFile;
			sSubjInfo.pwsFileName = pSubjectInfo->pSignerFileInfo->pwszFileName;
		}
		else
		{
			memset(&sBlob, 0, sizeof(MS_ADDINFO_BLOB));

			sSubjInfo.pgSubjectType=pSubjectInfo->pSignerBlobInfo->pGuidSubject;
			sSubjInfo.pwsDisplayName=pSubjectInfo->pSignerBlobInfo->pwszDisplayName;
			sSubjInfo.dwUnionChoice=MSSIP_ADDINFO_BLOB;
			sSubjInfo.psBlob=&sBlob;

			sBlob.cbStruct=sizeof(MS_ADDINFO_BLOB);
			sBlob.cbMemObject=pSubjectInfo->pSignerBlobInfo->cbBlob;
			sBlob.pbMemObject=pSubjectInfo->pSignerBlobInfo->pbBlob;
		}

        hr = GetSignedMessageDigestSubj(dwEncodingType,
                                        NULL,
                                        &sSubjInfo,
										pSubjectInfo->pdwIndex,
                                        ppbDigest,
                                        pcbDigest);

        if ((hFile) && (fFileOpen == TRUE) && !(sSubjInfo.hFile)) 
        {
            fFileOpen = FALSE;  // we opened it, but, the SIP closed it!
        }


        if(hr != S_OK) PKITHROW(hr);
    }
    PKICATCH(err) {
        hr = err.pkiError;
    } PKIEND;
    if(hFile && (fFileOpen==TRUE)) CloseHandle(hFile);
    return hr;
}


HRESULT WINAPI 
GetSignedMessageDigestSubj(IN  DWORD dwEncodingType,
                           IN  HCRYPTPROV hCryptProv,
                           IN  LPSIP_SUBJECTINFO pSipInfo,  
						   IN  DWORD	  *pdwIndex,
                           IN  OUT PBYTE* ppbTimeDigest,    
                           IN  OUT DWORD* pcbTimeDigest)
{
    HRESULT hr = S_OK;
    SIP_DISPATCH_INFO sSip;  ZERO(sSip); // Table of sip functions
    DWORD cbSignedMsg = 0;
    PBYTE pbSignedMsg = 0;
    DWORD dwCertEncoding = 0;
    DWORD dwMsgType = 0;
    HCRYPTMSG hMsg = NULL;
    BOOL fAcquiredCryptProv = FALSE;
	DWORD	cbTimeDigest=0;
	BYTE	*pbTimeDigest=NULL;

    PKITRY {

        if(!pcbTimeDigest || !ppbTimeDigest)
            PKITHROW(E_INVALIDARG);

		*ppbTimeDigest=NULL;
        *pcbTimeDigest=0;

        if(hCryptProv == NULL) 
		{
            if(!CryptAcquireContext(&hCryptProv,
                                    NULL,
                                    MS_DEF_PROV,
                                    PROV_RSA_FULL,
                                    CRYPT_VERIFYCONTEXT))
                PKITHROW(SignError());
            fAcquiredCryptProv = TRUE;

			//update the subject Info
			if(NULL==(pSipInfo->hProv))
				pSipInfo->hProv=hCryptProv;
        }            

        // Load up the sip functions. 
        if(!CryptSIPLoad(pSipInfo->pgSubjectType,   // GUID for the requried sip
                         0,               // Reserved
                         &sSip))          // Table of functions
            PKITHROW(SignError());
            
        sSip.pfGet(pSipInfo, 
                   &dwCertEncoding,
                   *pdwIndex, 
                   &cbSignedMsg,
                   NULL);
        if(cbSignedMsg == 0) PKITHROW(SignError());
        
        pbSignedMsg = (PBYTE) malloc(cbSignedMsg);
        if (!pbSignedMsg) PKITHROW(E_OUTOFMEMORY);
        
        if(!sSip.pfGet(pSipInfo, 
                       &dwCertEncoding,
                       *pdwIndex, 
                       &cbSignedMsg,
                       pbSignedMsg))
            PKITHROW(SignError()); // Real error.
        if(pSipInfo->dwUnionChoice != MSSIP_ADDINFO_BLOB)
        {
             if(dwCertEncoding != dwEncodingType) 
                    PKITHROW(TRUST_E_NOSIGNATURE); 
        }
        
        if ((GET_CMSG_ENCODING_TYPE(dwEncodingType) & PKCS_7_ASN_ENCODING) &&
                SignNoContentWrap(pbSignedMsg, cbSignedMsg))
                dwMsgType = CMSG_SIGNED;
            
        // Use CryptMsg to crack the encoded PKCS7 Signed Message
        if (!(hMsg = CryptMsgOpenToDecode(dwEncodingType,
                                          0,              // dwFlags
                                          dwMsgType,
                                          hCryptProv,
                                          NULL,           // pRecipientInfo
                                          NULL))) 
            PKITHROW(E_UNEXPECTED);
        
        if (!CryptMsgUpdate(hMsg,
                            pbSignedMsg,
                            cbSignedMsg,
                            TRUE))                    // fFinal
            PKITHROW(SignError());
						                
        if(!CryptMsgGetParam(hMsg,
                             CMSG_ENCRYPTED_DIGEST,
                             0, 
                             NULL,
                             &cbTimeDigest))
              PKITHROW(SignError());

        //allocate memory
        pbTimeDigest = (PBYTE)malloc(cbTimeDigest);
        if(!pbTimeDigest)
            PKITHROW(E_OUTOFMEMORY);


        if(!CryptMsgGetParam(hMsg,
                             CMSG_ENCRYPTED_DIGEST,
                             0,
                             pbTimeDigest,
                             &cbTimeDigest))
              PKITHROW(SignError());

        //copy the information
        *ppbTimeDigest=pbTimeDigest;
        *pcbTimeDigest=cbTimeDigest;

        hr=S_OK;
    }
    PKICATCH(err) {
        hr = err.pkiError;
    } PKIEND;

    if (hMsg) 
        CryptMsgClose(hMsg);
    if(pbSignedMsg)
        free(pbSignedMsg);
    if((hr!=S_OK) && (pbTimeDigest))
        free(pbTimeDigest);
    if(fAcquiredCryptProv)
        CryptReleaseContext(hCryptProv, 0);
    return hr;
}

HRESULT WINAPI 
TimeStampRequest(IN  DWORD dwEncodingType,
                 IN  PCRYPT_ATTRIBUTES psRequest,
                 IN  PBYTE pbDigest,
                 IN  DWORD cbDigest,
                 OUT PBYTE pbTimeRequest,      
                 IN  OUT DWORD* pcbTimeRequest)
{
    HRESULT    hr = S_OK;

    CRYPT_TIME_STAMP_REQUEST_INFO sTimeRequest; ZERO(sTimeRequest);
    PBYTE pbEncodedRequest = NULL;
    DWORD cbEncodedRequest = 0;



    PKITRY {
        if(!pcbTimeRequest) 
            PKITHROW(E_INVALIDARG);
        
        if(*pcbTimeRequest == 0)
            pbTimeRequest = NULL;

        sTimeRequest.pszTimeStampAlgorithm = SPC_TIME_STAMP_REQUEST_OBJID;
        sTimeRequest.pszContentType = szOID_RSA_data;
        sTimeRequest.Content.pbData = pbDigest;
        sTimeRequest.Content.cbData = cbDigest;
        if(psRequest) {
            sTimeRequest.cAttribute = psRequest->cAttr;
            sTimeRequest.rgAttribute = psRequest->rgAttr;
        }
        
        CryptEncodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                          PKCS_TIME_REQUEST,
                          &sTimeRequest,
                          pbEncodedRequest,
                          &cbEncodedRequest);

        if(cbEncodedRequest == 0) PKITHROW(SignError());

        pbEncodedRequest = (PBYTE) malloc(cbEncodedRequest);
        if(!pbEncodedRequest) PKITHROW(E_OUTOFMEMORY);
        
        if(!CryptEncodeObject(X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                              PKCS_TIME_REQUEST,
                              &sTimeRequest,
                              pbEncodedRequest,
                              &cbEncodedRequest))
            PKITHROW(SignError());
        
		//return the infomation
		if(*pcbTimeRequest==0)
		{
			*pcbTimeRequest=cbEncodedRequest;
			hr=S_OK;
		}
		else
		{
			if(*pcbTimeRequest < cbEncodedRequest)
			{
				hr=ERROR_MORE_DATA;
				PKITHROW(SignError());
			}
			else
			{
				memcpy(pbTimeRequest, pbEncodedRequest, cbEncodedRequest);
				hr=S_OK;
			}
		}
        
        
    }
    PKICATCH(err) {
        hr = err.pkiError;
    } PKIEND;

    if(pbEncodedRequest)
        free(pbEncodedRequest);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\security\cryptoapi\pkisign\tools\cert2spc\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1999
//
//  File:       resource.h
//
//  Contents:   the resource header for cert2spc.cpp.  
//
//
//  History:    01-May-97   xiaohs   created
//              
//--------------------------------------------------------------------------

//defintion for string IDS
 
#define IDS_ENDOF_LINE				6001
#define IDS_SYNTAX					6002
#define IDS_CRL_EXTENSION			6003
#define IDS_CAN_NOT_OPEN_FILE		6004
#define IDS_OUT_OF_MEMORY			6005 
#define IDS_FILE_EMPTY				6006
#define IDS_CAN_NOT_READ_FILE		6007
#define IDS_CAN_NOT_WRITE_FILE		6008
#define IDS_CAN_NOT_OPEN_STORE		6009
#define IDS_CAN_NOT_LOAD_CRL		6010
#define IDS_CAN_NOT_LOAD			6011
#define IDS_ERROR_OUTPUT			6012
#define IDS_FAILED					6013
#